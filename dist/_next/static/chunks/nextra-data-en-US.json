{"/html":{"title":"HTML: The structure of web pages","data":{"":"HTML started as a portable markup language to share academic papers with other people on the same network. Browsers were co-developed as a way to (1) fetch those files, and (2) display them.While the web has changed a lot since then, that core technologies haven't. When you navigate to a URL like google.com/foo/bar.html, the browser requests the shared file foo/bar.html from the server at google.com; if you specify a folder path without a file, the browser will automatically request index.html on your behalf (specifically, the requests google.com/foo/ and google.com/foo/index.html are the same).","a-basic-page#A basic page":"The most basic HTML page you could write looks something like this:\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <title>Demo app</title>\n  </head>\n  <body>\n    <p>Hello, world!</p>\n  </body>\n</html>\nIn this example, we're creating a page that has a single paragraph, <p>, with the text \"Hello, world!\".HTML is a subset of XML, that is to say it encodes the document as a tree of tags; tags can be <opening>, </closing>, or <both />. Every opening tag must have a closing tag, and opening and self-closing tag (what we referred to as \"both\") can have attributes that change the behavior of the tag (for example, <img width=\"800\" /> is an image with a width of 800px).A tag nested within another tag is referred to as a child, and the outer tag is referred to as the parent:\n<parent>\n  <child />\n</parent>\nBuilding on that, the entire nomenclature for family trees applies (there are grandparents, siblings, descendents, etc...)HTML documents begin with a <!DOCTYPE html> declaration that tells the parser the document is HTML (much like a shebang in a scripting language), and consist of at most two children:\nhead: defining the metadata of the document (such as the tab's title)\nbody: defining the contents of the document (such as the paragraph with the text hello world to show)","tags-tags-tags#Tags, tags, tags":"If you were to only know 2 other tags beyond <html>, <title>, and <body> they would definitely be:\n<div>: an arbitrary block of content\n<span>: a way to select text within a block\nWe'll talk about both of these more in the CSS section.There are other common tags to add functionality to the page: <img> for images, <video> for videos, <textarea> for long-form text-input, but we don't need to understand those yet. There are also other tags that encode the purpose of the element: <main>, <article>, <header> (these act the same as a div, but allow bots and accessibility software to more easily read the webpage). My advice with these semantic elements is to use them where you can, but not to stress about them; there are still many, many websites that get along just fine with divs.","try-it-yourself#Try it yourself":"To play with this further, you can use a service like JSFiddle or CodePen, which injects the HTML directly into the body tag (and allows you to define CSS and JS files, but more on that later).","media#Media":"In addition to HTML, browsers can render and embed a variety of media files to make documents more rich. For example, they can handle a variety of images:\nJPEG: Lossy image files\nPNG: Lossless image files\nWEBP: Google-optimized image files\nSVG: Vector files\nThey can also natively embed audio and video through MP4s."}},"/":{"title":"üëã Hi! My name is Tomas.","data":{"":"I have been programming for the web for 15+ years, developed reactive frontend frameworks at Facebook, and fucking love JavaScript.In that time, I've had the chance to teach a few people about frontend development; inevitably they'll ask me, \"hey, this is all great, is there anywhere I can go to read more\", or worse, \"I was doing some reading online and read an article that says {some hyperbole about how a certain framework / library / technology solves all problems}. Why don't we just use that?\" And that's when I explain three truths about the frontend ecosystem:\nIt's quickly evolving and highly volatile: what was true last year (/ month / week) may not be true today.\nIt's very hype-driven: because so few technologies have been around to stand the test of time, technology popularity is heavily influenced by marketing hype instead of robustness.\nA lot of the documentation is targeting first time programmers: For whatever reason, frontend attracts a lot of new developers, which is awesome; however, a lot of the documentation excludes context, tradeoffs, and nuance because it assumes the reader won't be able to, or care to, evaluate it themselves.\nThat last point, in particular, upsets me. I think frontend has many real engineering problems to work on, and the lack of experienced-developer-facing documentation discourages many developers from engaging with it.So that's why I'm here: I want to share frontend with you. I wanted to write a document that:\nTeaches frontend: assuming little to no background knowledge.\nTargets experienced developers: including any relevant context, trade-offs, and nuance. If you're just looking to get started, there are better documents for you.\nIs short: I've worked really hard to keep this whole thing front-to-back readable, and under 20 pages.\nPerhaps you're a backend developer dipping your toes into frontend for the first time; perhaps you're a frontend developer who wants to go deeper; perhaps, you've just always been curious. Regardless of the situation, if you've been coding for a while and want to learn more about frontend, this is for you.Lastly, two quick editorial notes:\nWhile I aim to be fair with this, I'm certainly not impartial. My goal is to pass on both my opinions and their reasoning, hopefully allowing you to bootstrap your own.\nThere is a lot to cover and this is very much a work in progress. If you feel I missed something, got it wrong, or just could have gone deeper feel free to DM me on Twitter (link in header).\nAnyway, I only have ~19 pages left, so let's dive in!"}},"/ecosystem":{"title":"The ecosystem: more tools, more problems","data":{"":"The JavaScript ecosystem is a reminder that the web is held up by shoestrings and gum; it is this immense mess of technologies, all haphazardly thrown together, that somehow happens to work just enough to get your website online.\nI have no doubt that this heavily-customized, and poorly abstracted, tooling is one of the many things that scares away the casual developer from exploring frontend development. I hope to provide you with just enough context to see the forest among the trees, and let you resume your journey in frontend development.","writing-and-running-code#Writing and running code":"As the web has gotten more complex, JavaScript has turned from a simple scripting language--primarily embedded in HTML--to a full blown language. Its simple origins necessitated extensive tooling to keep up with the explosive adoption and ever-more-complex use-cases.","languages#Languages":"While JavaScript, the runtime target, has experienced incredible growth, people have done a lot to avoid writing JavaScript, the language. For example, CoffeeScript was pure syntactic sugar over JavaScript to emphasize the functional programming features of the language.Beyond syntax, as JavaScript codebases grew, they needed static typing:\nFlow: built by Facebook, one of the earliest attempts to add type annotations to JavaScript.\nTypeScript: the most popular way to add types to JavaScript. Built by Microsoft, it has become the defacto way to add types to JavaScript with support across the ecosystem.\nA second transformation of the language happened with React. As mentioned last chapter, a core innovation of React was .jsx files: allowing developers to write HTML in JavaScript. JSX used a transpiler to transform JSX files into JavaScript files by transforming the HTML-like syntax into JavaScript function calls. Specifically, the transpiler can take\nfunction Component() {\n  return <h1 className='title'>Hello, world!</h1>;\n}\n... and transform it into this:\nfunction Component() {\n  return JSX.createElement(\n    'h1',\n    {className: 'title'},\n    'Hello, world!'\n  );\n}\nBecause of the popularity of TypeScript, there is now a tsx file type: TypeScript with HTML-like syntax.","compilers-and-transpilers#Compilers and transpilers":"Supporting those different languages are compilers and transpilers. In the world of frontend web development, the transpiler serves 4 key purposes:\nTypes: Supporting static typing, probably through TypeScript\nJSX: Supporting JSX / TSX\nSupporting different runtimes: these days, JavaScript runs everywhere--browsers (including different versions), the server, in desktop apps (via Electron), in CLI tools, etc. Those different runtimes require slightly different formats (more on that in the next section), and the compiler can abstract this away from the developer.\nPolyfills: Because different runtimes and different versions support different language features, the compiler can detect which features you need and inject any necessary polyfills.\nCommon compilers are:\nTSC: Ships with TypeScript.\nBabel: A pluggable compiler. Currently the most popular.\nSWC: A replacement for Babel written by Vercel intended to be faster.\nUse of these compilers and transpilers are not mutually exclusive. It's not uncommon to see projects use both TSC and babel in the same build step.","linters#Linters":"Lastly, sizable codebases want to ensure that developers are following common formatting. ESLint is the most popular linter, with many community-built plugins.While linters can catch many code-formatting bugs, Prettier is a very popular code formatter. It is typically used along-side Eslint.","build-targets#Build targets":"Because JavaScript runs everywhere, new platforms continue to create support for JavaScript. It is a self fufilling prophecy.","runtimes#Runtimes":"While JavaScript does have a language spec: there are different runtime engines (with partial or extended implementations of the language), different versions, and different global variables available at runtime; as a result, you need to know what platform you're building your JavaScript program for.The most common place to run JavaScript is the browser. Browsers consist of two parts: the UI (how you navigate to web pages) and the browser engine, the part that takes web pages and runs / renders them; while there are many browsers, there are only a few browser engines. Three key JS engines to be aware of are:\nChrome: supported by the V8 JavaScript engine, maintained by Google\nFirefox: supported by the SpiderMonkey JavaScript engine, maintained by Mozilla\nSafari: supported by the JavascriptCore engine (part of WebKit), maintained by Apple\nAs code running in the browser, any scripts have access to the document and window global variables.For a long time, those were the only platforms most developers JavaScript authored JavaScript for. Then Node came around and changed everything. Node took Chrome's JavaScript engine (V8) and created a set of APIs intended to run JavaScript outside the browser's sandbox. To this day, Node is the most popular way to author a JavaScript web server or run JavaScript scripts locally. It introduces a few global variables (including global, process, etc.) because the window and document APIs don't make sense when running outside of a web browser.Because users sometimes need to test or run code against different versions of node, nvm is a tool that lets users manage multiple node installs.While node is definitely still the most popular runtime for non-browser-based code, more recently we've seen the creation of new runtimes, including Deno and Bun, that try to improve upon the speed, size, and developer experience of node.For developers writing \"native\" (not browser based) applications, Electron is a platform built on top of Node and Chromium (the open source foundation of Chrome) that allows developers to write desktop apps in JavaScript. To enable that, it introduces a suite of APIs to access the native platform.And for developers writing mobile apps, React Native is the latest and most popular runtime allowing developers to write their mobile apps with web technologies. React Native used to use the platform's native JavaScript engine (V8 on Android and JavascriptCore on iOS), but more recently they've developed their own runtime, Hermes. Much like Electron, it introduces a handful of APIs for communicating with the host device. Older technologies that tried to make web technologies available to mobile developers include NativeScript and Apache Cordova.","module-systems#Module systems":"Due to its simple origins, JavaScript never had a good way to split out code across files. It wasn't intended for applications of that scale; as JavaScript broke out of the browser, this had to change, and many people rushed to create a solution. This led to many, competing solutions to the problem of \"how do I import one JavaScript file from another\".These module systems have mostly been paired down to 2:\nCommonJS (CJS): The most popular standard to date.\nECMAScript modules (ESM): The newer standard introduced as part of the JavaScript spec. This will eventually become the standard; it just takes time.\nOlder technologies that are no longer common are:\nAsynchronous module definition (AMD): Created for a polyfill that is no longer necessary.\nUniversal module definition (UMD): Created to unify the other module definition syntaxes. Relevant XKCD.\nIntroduced by Node, CommonJS allows developers to assign variables and functions to an automatically created module.exports object (e.g. module.exports.title = \"Hello, world!\"), and then import files via require(\"path/to/file.js\"). The contents of that file is the wrapped in a function and executed, returning the resultant value of module.exports. This object is a singleton (so requiring the object multiple times will return the same object).ECMAScript modules improve on this standard in a few key ways:\nExports are now done via an exports keyword (export const title = \"Hello, world\";)\nImports are done via an import keyword (import { title } from \"./path/to/file.js\")\nPromises can be awaited at the top level\nBecause ECMAScript modules are a superset of CJS modules, ESM files can import CJS, but not the other way around. Sometimes authors will denote this by naming ESM files as *.mjs, although I do not recommend this because ESM will become the standard after a few years.","bundlers#Bundlers":"While modules, predicatably, became a very popular way to organize code, web browsers never added first party support for them. The result was a need for packagers: a way to take all of the modularized code and concatenate it into one file.The most popular packager is Webpack, which not only bundles, but has an extensive plugin ecosystem.That said, like everything else in this ecosystem, there are many alternatives. Some older ones include:\nBrowserify: early to the game, was very popular.\nMetro: used by React Native.\nMore recently, there have been a class of new entrants, all targeting the same problem: improving upon Webpack's (notably bad) performance:\nRollup\nESBuild\nVite\nUltimately, the bundler is a glorified version of cat, with a few extra features to ensure things like:\nDependencies are correctly ordered\nAny unreferenced code is removed\nFiles are split up to optimize for browser caching (e.g. if you depend on a library that is unlikely to change, output a separate file so the browser can cache it across version bumps of your application)\nNode globals are shimmed to work in the browser (a common one is to replace process.env.FOO, the way you access the env variable FOO with whatever the value of FOO is at build time)\nMinifying code to save network bandwidth (for example, comments don't need to be sent to the browser and whitespace can be removed)","orchestrators#Orchestrators":"That's a lot of tools. Running them all in concert is difficult. The result is a set of tooling intended to help you coordinate all the other tools. Other languages and ecosystems use MAKE, some JavaScript projects do to, but as is customary here, we also have our own, bespoke, solutions.Grunt and, later, Gulp were introduced to help transform files. These days they're less frequent (as the packagers have subsumed much of this functionality), but still exist.","sharing-code-and-scripts#Sharing code and scripts":"The advent of modules and packages (more on that in a second) lowered the barrier to share and reuse others code, and led to an explosion of JavaScript libraries.","libraries-and-frameworks#Libraries and frameworks":"While modules certainly lowered the barrier to share, people have been sharing JavaScript forever. These days, most libraries can be found in the NPM package registry. And range from full fledged frameworks (you can install Electron that way) to libraries that add whitespace to strings.There are too many libraries to go through my favorites, so instead I'll try to reference them as they're relevant in later chapters. Three general pieces of wisdom about them are:\nWhile libraries are really easy to add and appear really friendly, make no mistake, you are introducing someone else's code to your codebase. That code could be buggy, built with a different set of constraints, or plainly insecure. Because JS developers are so quick to introduce packages, software supply chain security is especially difficult in JavaScript.\nSpeaking of different constraints, don't be afraid to peak into how a package is implemented. Far too often I hear developers say \"well I can't do that because the package does something close to what we need, but not exactly what we need\". Many packages are less than 100 lines, it's frequently easier and more maintainble to maintain that yourself than to hack around someone else's constraints.\nWhile many packages are written, far fewer are maintained. Part of the reason you'll hear me reference who authors which library is because I have far more faith that a tool built and used by Facebook will be maintained than one built by a no-name developer with no incentive to do so.","package-managers#Package managers":"Packaged with node came a tool called npm. npm created a standard way to share code. It specified a format of a zip archive with a package.json file at the root that specified any dependencies and the entrypoint to the code. It also provided an online regsitry to share these packages, that could easily be published to (using npm publish) or pulled from (using npm install PACKAGE_NAME).NPM is still the largest, and most common, registry; although some companies maintain private registries to share internal packages.That said, NPM is no longer the only package manager, and there are now other tools that help manage packages locally while still publish to and pulling from npm's online registry. PNPM is a tool developed as drop-in replacement for NPM, with one core advantage: it saves disk space by deduplicating shared packages across your machine.Yarn was developed by FB with a few key benefits over NPM:\nZero install: yarn stores a copy of dependencies as a zip file that you can commit. While you might wonder if committing dependencies is advisable, it speeds up CI and protects you from remote changes in the registry (in the past, people have removed versions of packages from NPM, breaking builds, and uploaded malicious versions that get updated with little auditability).\nPlug-n-play: Yarn introduced PNP as an opt-in way to save disk space, because zero install means that all packages are in zip files, why not override require() to simply reach into those zip files (which are unzipped in memory); this also saves the OS from having to page 100s-100,000s of tiny files into memory. While interesting in theory, and faster in practice, the ecosystem has not adopted it and getting tools like React Native, Webpack, or Electron to work with PNP is difficult. For this reason, I typically disable this.\nWorkspaces: discussed below.\nBecause of Facebook's support, and the corresponding features intended for company-wide monorepos, yarn is my prefered package manager.","workspaces-monorepos#Workspaces (monorepos)":"Packages were great, and soon people started putting many packages in a single repo. If memory serves, I think React was one of the earliest people to do this.NPM did not have great support for importing local packages (and certainly not for developing multiple local packages simultaneously). Yarn solved this through workspaces, and soon this became a common feature across various package managers.Along with supporting multiple local packages, developers needed a way to coordinate tasks across those packages (the most simple example being you should first build any dependencies of a package before you build the package itself). Two tools that came into existence were TurboRepo and Lerna. Because TurboRepo is supported by Vercel, it is my preferred tool.One edgecase to call out with multiple local packages is Hoisting:For background, when you import a package in node, node climbs the directory structure checking in node_modules. For example, if I require package foo from /some/path/file.js, node will check the following locations, stopping when it finds a file.\n/some/path/node_modules/foo, and then\n/some/node_modules/foo, and then\n/node_modules/foo\nNow, imagine you have a repository with two workspaces, each which depend on react:\nrepository/\n  workspace-a/\n    node_modules/\n      react/\n  workspace-b/\n    node_modules/\n      react/\nIf A depends on B, compiling A will result in an artifact that contains two copies of react (as any code in workspace-a that references react will resolve to one react, and any code in workspace-b that references react will resolve to another react).One way to solve this in a workspace is to \"hoist\" react:\nrepository/\n  workspace-a/\n  workspace-b/\n  node_modules/\n    react/\nNow both workspaces will resolve to the same react.If you find this confusing, it is, but it's something to be mindful of when working with workspaces.","scaffolders#Scaffolders":"If you had to set it all this tooling yourself, it could easily be a week of work. As a result, there are a handful of tools that help you scaffold new projects.The most common general tool here is Yeoman, which lets developers author customer project generators. There are also application-specific scaffolders, such as create-next-app, create-react-native-app, or HTML5 boilerplate.","styling#Styling":"If you find this all dizzying, I have good and bad news for you: none of this is specific to JavaScript. CSS has gone through the same transformation in recent years. With LESS and SASS emerging as alternative syntaxes. And more recently SASS adopting modules to help developers better organize their code.With SASS modules and a packager (like webpack), I can now author a react component that imports a style and references any defined classnames like variables.\nimport s from \"./my-style-file.module.scss\";\nfunction SomeReactComponent() {\n  return <div className={s.someClassname}>Hello, world!</div>\n}\nWhile the above is my curently recommended way to write CSS, it's worth noting that there has been a push to try and colocate CSS definitions in JS (much like JSX moved HTML into JS files). Two efforts here have been StyledComponents and StyleX. While I agree this is the right long-term direction, I have yet to see good support for:\nPsuedo-selectors (:hover)\nPsuedo-elements (::before)\nKeyframes (@keyframes)\nMedia queries (@media)\netc."}},"/css":{"title":"CSS: The style of web pages","data":{"":"HTML was great for academic documents, but not great for marketing materials and definitely not great for full applications. People wanted a way to style their documents, and that is how we got CSS.Building on our earlier example, let's create a folder with two documents:\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <title>Demo app</title>\n    <link rel=\"stylesheet\" type=\"text/css\" href=\"styles.css\" />\n  </head>\n  <body>\n    <p>Hello, world!</p>\n  </body>\n</html>\nThis is the same as above, but with and added <link> tag (which is just telling the browser the address it can request to find an associated CSS file; because the address doesn't begin with a / it's presumed to be relative to the HTML file). And:\np {\n  color: red;\n}\nThis is a CSS file! It says that all paragraph tags, p, should have a text color of red.You can open that HTML file to see it with the style applied. And, like our HTML example, we can continue to experiment using JSFiddle:","selectors#Selectors":"CSS is all about selecting elements and modifying their properties. CSS files are structured as lists of these rules, which use a selector to specify element(s) the rule applies to and lists properties to apply to those matched elements.\n/**\n * This is a c-style comment.\n *\n * This paragraph says all paragraph tags should be red. \n */\np {\n  color: red;\n}\n/* This paragraph says all headings should be bold and blue. */\nh1 {\n  color: blue;\n  font-weight: bold;\n}\nThere are three types of selectors:\nfoo: this matches all elements of the tag foo (for example, <foo />)\n#foo: this matches the element with the attribute id=\"foo\". Every ID must be unique.\n.foo: this matches all elements which include the attribute class=\"foo\". Unlike IDs, there can be many elements with the same class; there can also be multiple classes per element; for example, an element with class=\"foo bar\" will match both .foo and .bar.","composing-selectors#Composing selectors":"Selectors can also be combined:\nCommas allow either selector to match (e.g. #foo, #bar applies to either #foo or #bar)\nSelectors can be concatenated so ALL selectors must match (e.g. p#foo.bar matches any p tags with the ID foo and the class bar)\nSpaces match descendents (e.g. .foo .bar matches any element with class bar that is a descendent of an element with class foo)\nCombinators can be used to build more complicated relationships (e.g. .foo > .bar matches any element with class bar that is a direct descendent of an element with class foo)","specificity#Specificity":"If two different selectors apply to an element:\nthe properties in the selector with the most IDs in it wins (#foo has 1 ID but #foo #bar has two IDs);\nif both selectors have the same number of IDs, the properties in the selector with the most classes wins;\nif both selectors have the same number of classes, the properties in the selector with the most tags wins;\nif both selectors have the same number of tags, the properties in the selector defined later in the file wins.\nThis is called specificity.CSS rules can be thought of as applying from lowest specificity upwards. So, if a rule sets the text color to red, and no higher specificity rule overrides it (or there is no higher specificity rule), the text color will still be red. (This is where the cascading of Cascading Style Sheets comes from).","psuedo-selectors#Psuedo-selectors":"Selectors can also match states. These selectors are prefixed with a colon. For example, .foo:hover matches elements with class .foo when the mouse hovers over them:","properties#Properties":"As I said, CSS is all about selecting elements and modifying their properties. Properties are all of the form property-name colon property-value (which sometimes includes a unit). For example,\nwidth: 200px\nwidth: is the property\n200px is the value (px is the unit, meaning pixels)\nValues can either be:\nEnums (e.g. text-decoration: underline): which are property specific.\nMeasurements (e.g. width: 200px): that take the form of pixels (px), inches (in), as a percent of the screen‚Äôs height (vh), or something else entirely. Zero is always unitless (because it‚Äôs always the same).\nPaths to other files (e.g. background-image: url(./file.png)): the value is a filepath relative to the CSS file, and while url() may look like a function, it is just telling CSS the type of the value. The path can either be quoted or unquoted (like bash parameters, the quotes are only important if there is a space).\nColors (e.g. color: red): which either take the form of names (e.g. red) or as triplets of red, green, and blue values (RGB). If you're new to digital graphics, an online color picker is a good way to build intuition mapping colors to RGB (rgb(255, 0, 0)) or hex(adecimal) values (#FF0000). (Note: there are other ways to specify colors, but they are less common.)\nWith CSS properties, you can do everything from change the cursor to full 3d transforms. While I can't cover everything CSS can do, some basics you might encounter are:\nText color: color: red;\nText size: font-size: 12px;\nBold text: font-weight: bold;\nBackground color: background-color: red;","layout#Layout":"One particularly important set of properties are those that effect the size and position of your elements.By default, divs are arranged in one column from the top of the page to the bottom and have the height of their contents. This is one of three default layout kinds:\nblock: the element takes up a whole row (e.g. <div>)\ninline: a selection of text, the element takes up no space beyond the inner content (e.g. <span>)\ninline-block: something that has a height and width, but doesn't need a full row to itself (e.g. <img>)\nYou can override the layout kind via the display property. For example, normally divs don‚Äôt show up next to each other, but by changing their display to inline-block we can get the browser to lay them out next to each other.","sizing-the-box-model#Sizing: the box model":"As for how these elements are sized, no CSS tutorial would be complete without a discussion of the box model. The box model is a framework for how much space each element takes.Each element is modeled as four concentric rectangles (or boxes):\nContent: the innermost box that contains the children of the element\nPadding: white space that includes the background\nBorder: a line around the padding\nMargin: space outside the border separating the element from adjacent elements.\nFor each rectangle, you can define all sides at once (padding; 16px), each side individually (padding-left: 16px), or each side individually using a shorthand (padding: 16px 12px 8px 4px defines the top as 16px, right as 12px, bottom as 8px, and left as 4px).The height and width of the content default to whatever height and width the children require to be laid out, but can be explicitly set via the height and width properties (e.g. height: 100px). In addition to specifying a height and width, you can also constrain them using max-height, max-width, min-width, and min-height. For example, an element with the below will be as wide as possible, but not more than 800px:\n.example {\n  width: 100%;\n  max-width: 800px;\n}\nWhile height was intended to define height of the content, many developers assume it refers to height of the element (including the height of contents, padding, and border). For example, a developer that assigns a box a height of 16px and a padding of 4px, might be confused when the height of the element is 24px instead of 16px (4px top padding + 16px height + 4px bottom padding).This confusion was sufficiently widespread (as was the desire to specify the overall height of the element) that css introduced the box-sizing property to allow developers to toggle whether height refers to the height of the content or the height of the element: box-sizing: border-box redefines height as content height + padding height + border height (the same applies to width).So far, we haven't talked much about margin, a word of caution there: many developers shy away from margin because doesn't always behave intuitively. Specifically: if you have two div's on top of each other with a margin of 10px, the total space between them will only be 10px (as both are at least 10px away from their neighbors). This is called margin collapsing.","flex-and-grid#Flex and Grid":"While blocks and inline-blocks worked well for documents, they reached their limits with applications. For a long time people hacked <tables>'s for layout, then <div>'s became popular, but ultimately application UIs demanded something more. As a result, two layouts were introduced: flexbox and grid, which both let you define elements flexibly and in relation to other elements.\nWhile the full APIs are probably more complicated than we have space to get into, there are wonderful tutorials:\nFlexbox: https://flexboxfroggy.com/\nGrid: https://cssgridgarden.com/","positioning#Positioning":"Lastly, sometimes you want to position an element directly (rather than having the browser lay it out for you). In this case, you can position an element relative to:\nits parent: using position: absolute\nthe browser window: using position: fixed","browser-defaults#Browser defaults":"If you don't define a property, the browser will fall back to its default; different tags have different defaults (for example, on Chrome, the <body> has a default padding of 8px). These defaults are not consistent across browsers. As a result, developers will frequently reset these properties themselves, and it is common to see declarations like the below in boilerplate projects:\nhtml, body {\n  padding: 0;\n  margin: 0;\n}\nTo standardize CSS defaults across browsers, the idea of a \"CSS Reset\" was introduced:a stylesheet that overrides browser defaults. One of the more popular resets is normalize.css.","devtools#Devtools":"You might be wondering, is that all it really is? Is every web page written this way? Yes, and I can prove it. If you're using Chrome, right click on this page and click ‚ÄúInspect‚Äù you‚Äôll open up your browser‚Äôs developer tools panel (a similar concept exists in most browsers, but I'll be focusing on Chrome's).The developer tools panel includes a variety of tools, but if you open ‚ÄúElements‚Äù you‚Äôll see the full HTML of the webpage, starting with the <html> tag (technically this is showing you the DOM, but more on that later). You can select an element to see its CSS and box model.\nYou can read more about the developer tools panel here; the rest of the tools primarily help you debug any JavaScript running alongside the page, and we‚Äôll get to that in the next chapter.","advanced#Advanced":"There is no way to cover all of CSS in one chapter. There are simply too many properties. Even people who have been working with CSS for years still discover new properties (partially because new properties are also introduced regularly).Hopefully, I've given you enough of a foundation to understand any new properties you run into. To that end, there are a few remaining concepts that could benefit from additional explanation. Here is a whirlwind tour.","media-queries#Media queries":"Media queries allow you to apply different CSS properties based on properties of the medium (most commonly, browser width). This lets you have different designs for, for example, mobile vs desktop.","variables#Variables":"CSS has gotten more advanced over the years, and you can now specify properties that compose into other properties.\nAs a warning, you can also compute things with calc (e.g. width: calc(80% - 10px). In general, I would avoid using this, and I would especially avoid putting variables in it. Calc is rarely necessary and leads to hard to understand code.","animations#Animations":"There are two types of animations you can define in CSS. Transitions, which define how to change between different values of a property:\nAnimations, which animate an object:\nAnimations rely on \"keyframes\": a concept borrowed from animation, you specify the properties at specific points, and let the runtime interpolate the middle state (for example, if you know that a box starts at 10px wide and ends at 20px wide, you can infer that half way through that animation, the box should be 15px wide).","psuedo-elements#Psuedo-elements":"Selectors can also create elements. For example, .foo::before will create an element within all elements with class foo but before their children.Yes this is weird; an example of when you might use it is to add a bullet point before items in a bullet point list."}},"/javascript":{"title":"JavaScript: The function of web pages","data":{"":"All UI pretty much boils down to this:\nDraw something on the screen\nListen to and react to user events (clicks, hovers, swipes, etc.) or global events (time changed, window resized, wifi disabled)\nJavaScript was developed in response to that second requirement; it was famously ‚Äúdeveloped in 5 days‚Äù as a way to add limited interactivity to documents: for example, to power dropdown menus.","the-language#The language":"Despite the name, the language has no relation to Java, and is instead based on the ECMAscript standard (an abstract spec for a scripting languages). Because of its rapid adoption and growth from a small scripting language to a full-blown application framework, JavaScript certainly has its quirks, and there is certainly language bloat and more bad than good.\nFor a good highlight-reel of those quirks, check out the WAT of JavaScript.\nHowever, quirks aside, it is a full, turing-complete programming language. In fact, your browser has a full JavaScript REPL embedded in it: open up devtools and click on the ‚ÄúConsole‚Äù tab and type:\nconsole.log(\"Hello, world!\");\nWhen you click enter, the browser will evaluate that line and print ‚ÄúHello, world!‚Äù. To take it a step further, you can copy the following to print your name!\nconst name = \"YOUR NAME\";\nconsole.log(\"Hello, \" + name + \"!\");\nFor a crash course on the syntax of JavaScript, check out Learn X in Y.","the-browser-runtime#The browser runtime":"In the context of web pages, JavaScript is either included as a referenced file (same way CSS is included):\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <title>Demo app</title>\n    <script src=\"script.js\" />\n  </head>\n  <body>\n    <p>Hello, world!</p>\n  </body>\n</html>\nOr directly written inline:\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <title>Demo app</title>\n    <script>\n      console.log(\"Hello, world!\");\n    </script>\n  </head>\n  <body>\n    <p>Hello, world!</p>\n  </body>\n</html>\nBy default, when the browser is parsing the HTML, if it encounters a script tag, it will stop, load, parse, and run the JavaScript before it resumes parsing the HTML. This is very rarely desired‚Äîas you almost always want to display SOMETHING to the user before you start loading a script‚Äîso you‚Äôll either see script tags included at the bottom of the body (after the main content has been parsed and displayed) or with an async attribute (e.g. <script src=\"...\" async />) which does the same thing.","the-dom#The DOM":"JavaScript is loaded along-side the webpage, and the runtime provides hooks into the browser‚Äôs in-memory model of the page: called the ‚Äúdocument object model‚Äù or ‚ÄúDOM‚Äù. The DOM lets JavaScript listen for events and modify the page in response.Much like we did with HTML or CSS, we can experiment using JSFiddle. For example, I can query for all the paragraph tags using:\nconsole.log(document.querySelectorAll(\"p\"));\nAnd I can modify, or remove, those matching elements:","events#Events":"As I said before, every UI language needs a way to respond to user events. In JavaScript, this takes the form of explicit event listeners that you can attach. For example, I can add an event listener for click events:\nBecause components are nested, events may occur on multiple components:\nYou may have noticed that the parent event happens AFTER the child event. For historical reasons, every node actually receives the event twice: once during the ‚Äúcapture‚Äù phase (from ancestors to descendents), and once during the ‚Äúbubble‚Äù phase (from descendents to ancestors). In this specific case, events are received in the order:\nCapture parent\nCapture child\nBubble child\nBubble parent\nEvent listeners default to listening to the bubble event, but you can use the third parameter of addEventListener to instead listen to the capture event:\nBy selecting the element in your browser‚Äôs developer tools, you can see any event handlers attached to it:\nAnd if you go to the source panel, you can even set a breakpoint on it.","frontend-frameworks#Frontend frameworks":"With the building blocks of HTML, CSS, and JavaScript, the web changed very quickly: JavaScript didn‚Äôt stay a scripting language intended to open and close dropdowns for long; developers got increasingly ambitious with what web applications could do; and APIs were added to enable increasingly more native experiences; specifically:\nXHR: enabling webpages to programmatically query the network for additional data. (These days, the fetch API is more common.)\nHTML5: an updated specification for HTML, adding APIs targeted at full application development such as offline, history, geolocation, file reading, image rendering, etc.\nFor a full list of JavaScript APIs, check out MDN.Alongside the new APIs and browser-based applications (or perhaps powering the browser-based applications) came a suite of libraries built at targeting frontend.","wave-1-utilities#Wave 1: Utilities":"The first wave of popular frontend frameworks came about in the 2000s and provided utilities for selecting elements (at this point, you could not select elements with CSS selectors natively) and requesting data from the network (something that was difficult).\n$( \"#button-container button\" ).on( \"click\", function( event ) {\n  hiddenBox.show();\n});\nExamples include: Mootools, Prototype, and jQuery.","wave-2-data-binding#Wave 2: Data binding":"The second wave came about in the late 2000s / early 2010s and made it easier to bind data to HTML. This allowed developers to more easily store state in JavaScript, interpolate that state into their HTML, and modify that state in response to HTML events.\n<html ng-app>\n <!-- Body tag augmented with ngController directive  -->\n <body ng-controller=\"MyController\">\n   <input ng-model=\"foo\" value=\"bar\">\n   <!-- Button tag with ngClick directive, and\n          string expression 'buttonText'\n          wrapped in \"{{ }}\" markup -->\n   <button ng-click=\"changeFoo()\">{{buttonText}}</button>\n   <script src=\"angular.js\"></script>\n </body>\n</html>\nExamples include: Backbone, Angular 1.0, Ember, and Knockout.","wave-3-components#Wave 3: Components":"The third wave further abstracted UI into components: bundles of structure, style, and function creating reusable UI concepts (a menu, table row, or form input).\nfunction Welcome(props) {\n  return <h1>Hello, {props.name}</h1>;\n}\nExamples include: React, Angular 2.0, Svelte, Vue, and Solid.js.A key innovation of React was JSX, a superset of JavaScript that allowed developers to write HTML-like syntax in JavaScript files. This language could be transpiled into JavaScript (with a object-based representation of the inlined HTML). We'll cover this more later.","wave-4-fullstack#Wave 4: Fullstack":"More recently, we've seen a fourth wave begin to emerge. Technologies like Next.js take advantage of the fact that JavaScript now powers both the client and server for many sites. By using Next.js, you can write React code that renders on the server, and keeps the client up-to-date.While this wave is still early, examples include: Next.js, Remix, and Astro.I will call out that these waves are fuzzy, and the idea of writing JavaScript that was shared between client and server started much earlier with Meteor.","a-desert-island#A desert island":"A good friend once described JavaScript to me as \"a desert island\":\nYou can do literally anything you want... but if you want indoor plumbing, you're going to have to build it.\nThat stuck.JavaScript is an incredibly flexible language, but in many ways it's very bare. The need for frontend frameworks is indicative of that, and it doesn't include basic convenience methods or things we take foregranted in other languages (such as a consistent language spec).","shims-and-polyfills#Shims and polyfills":"Speaking of a consistent language spec, we haven‚Äôt talked about the governance of the web yet. The web standard is officially maintained by the W3C, a standalone group created to steward the protocols of the web; however, because browsers are maintained by various organizations, which APIs you can use depends on which parts of the spec the browser vendor has implemented. In addition,browser vendors (specifically Chrome and Safari) will implement APIs before they're standards as a way to serve the needs of their parent organizations (Google and Apple respectively) and as a way to push the web forward.CanIUse maintains a set of compatibility tables for various features across browser vendors and versions.To deal with the inconsistency of runtimes, websites use one of three strategies:\nBrowser detection: If you've ever seen the message \"Please open this site in Chrome or Firefox for the best experience\", you've experienced browser detection. The website is detecting which browser you're using, and gating the experience based on it, probably because the website requires some not-yet-widely-supported API. While common, this is broadly considered bad practice because it excludes niche browsers, excludes future browsers, and is unlikely to be updated once the new version of a currently-incompatible browser adds all the necessary APIs to support the site.\nFeature detection: The better version of browser detection is feature detection, which simply asks \"does the current browser support the specific feature I need\" (for example, if you're trying to use the window.querySelectorAll() function, you can test if window.querySelectorAll is a function; because in incompatible browsers it's not even defined). A popular library for this is Modernizr.\nPolyfills (aka Shims): The even better version of feature detection is to not only detect if the browser supports a feature, but to retrofit it when it doesn't. As I said, JavaScript is an incredibly flexible langugae and even lets you add new functions to base types (for example, you can add a method to the base array type). Polyfills will detect if a browser has an API, and if not, define it for you; for example, the .forEach() method was introduced on arrays, but before every browser had it, websites might include a piece of code that checked if forEach existed on the base array type, and if not, define it.","utility-libraries#Utility libraries":"In addition to frameworks and polyfills, there are a handful of libraries dedicated to adding common utility functions to JavaScript. This is common in various languages; a popular example here is underscore.js.","evolving-the-langauge#Evolving the langauge":"While the bareness of JavaScript can be disheartening to developers coming from more full-featured languages, I'll leave you on a positive note:As one who's been watching the language and browser runtime evolve, we are making strides. For example, when jQuery was popular, selecting elements in the DOM was difficult. The author of jQuery built Sizzle, a library that abstracted away selecting elements and let developers use CSS selectors instead. Since then, browsers have added native support for this pattern with document.querySelectorAll.And it doesn't stop there, we're watching the same thing play out with web components right now: browsers are adding native support for the component architecture that frontend libraries have popularized.","the-universal-virtual-machine#The universal virtual machine":"Speaking of evolution, people who really believe in the web platform will tell you it‚Äôs a full fledged virtual machine: a sandboxed render engine and scripting environment that runs on virtually every device.One technological arc to highlight is the compilation of traditionally native languages into JavaScript.It started with ASM.js and Emscripten: ASM.js was a subset of JavaScript intended as a compile target, and Emscripten was a backend for LLVM (a very common compiler with support for C, C++, ObjC, etc.). Emscripten could compile native code into ASM.js and even render graphics APIs directly to the screen via Canvas (JavaScript‚Äôs realtime drawing APIs).This made for interesting technical demos, but became very real with WASM (or WebAssembly), a browser-supported compile target for the web that was (1) safe, and (2) directly transformable into native bytecode. This made it much faster than anything interpretted; some of the early benchmarks of WASM showed that it was only 2x slower than native! While the might seem like a high number, imagine being able to run PhotoShop in your browser with only 2x overhead compared running native... that‚Äôs really fast.While WASM is not yet widely used in production (a notable exception being Figma, which uses it to power their editor), there are very cool demos:\nDOOM 3\nGoogle Earth\nWindows 95\nFor something between satire and reality, The Birth and Death of JavaScript is a funny talk that becomes more real every day."}}}