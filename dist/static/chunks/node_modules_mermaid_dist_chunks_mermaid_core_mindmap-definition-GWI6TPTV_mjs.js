/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["node_modules_mermaid_dist_chunks_mermaid_core_mindmap-definition-GWI6TPTV_mjs"],{

/***/ "./node_modules/cose-base/cose-base.js":
/*!*********************************************!*\
  !*** ./node_modules/cose-base/cose-base.js ***!
  \*********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("(function webpackUniversalModuleDefinition(root, factory) {\n\tif(true)\n\t\tmodule.exports = factory(__webpack_require__(/*! layout-base */ \"./node_modules/layout-base/layout-base.js\"));\n\telse {}\n})(this, function(__WEBPACK_EXTERNAL_MODULE_0__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __nested_webpack_require_643__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_643__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__nested_webpack_require_643__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__nested_webpack_require_643__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__nested_webpack_require_643__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__nested_webpack_require_643__.d = function(exports, name, getter) {\n/******/ \t\tif(!__nested_webpack_require_643__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__nested_webpack_require_643__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__nested_webpack_require_643__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__nested_webpack_require_643__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__nested_webpack_require_643__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __nested_webpack_require_643__(__nested_webpack_require_643__.s = 7);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports) {\n\nmodule.exports = __WEBPACK_EXTERNAL_MODULE_0__;\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __nested_webpack_require_3185__) {\n\n\"use strict\";\n\n\nvar FDLayoutConstants = __nested_webpack_require_3185__(0).FDLayoutConstants;\n\nfunction CoSEConstants() {}\n\n//CoSEConstants inherits static props in FDLayoutConstants\nfor (var prop in FDLayoutConstants) {\n  CoSEConstants[prop] = FDLayoutConstants[prop];\n}\n\nCoSEConstants.DEFAULT_USE_MULTI_LEVEL_SCALING = false;\nCoSEConstants.DEFAULT_RADIAL_SEPARATION = FDLayoutConstants.DEFAULT_EDGE_LENGTH;\nCoSEConstants.DEFAULT_COMPONENT_SEPERATION = 60;\nCoSEConstants.TILE = true;\nCoSEConstants.TILING_PADDING_VERTICAL = 10;\nCoSEConstants.TILING_PADDING_HORIZONTAL = 10;\nCoSEConstants.TREE_REDUCTION_ON_INCREMENTAL = false; // make this true when cose is used incrementally as a part of other non-incremental layout\n\nmodule.exports = CoSEConstants;\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __nested_webpack_require_4002__) {\n\n\"use strict\";\n\n\nvar FDLayoutEdge = __nested_webpack_require_4002__(0).FDLayoutEdge;\n\nfunction CoSEEdge(source, target, vEdge) {\n  FDLayoutEdge.call(this, source, target, vEdge);\n}\n\nCoSEEdge.prototype = Object.create(FDLayoutEdge.prototype);\nfor (var prop in FDLayoutEdge) {\n  CoSEEdge[prop] = FDLayoutEdge[prop];\n}\n\nmodule.exports = CoSEEdge;\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __nested_webpack_require_4409__) {\n\n\"use strict\";\n\n\nvar LGraph = __nested_webpack_require_4409__(0).LGraph;\n\nfunction CoSEGraph(parent, graphMgr, vGraph) {\n  LGraph.call(this, parent, graphMgr, vGraph);\n}\n\nCoSEGraph.prototype = Object.create(LGraph.prototype);\nfor (var prop in LGraph) {\n  CoSEGraph[prop] = LGraph[prop];\n}\n\nmodule.exports = CoSEGraph;\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __nested_webpack_require_4790__) {\n\n\"use strict\";\n\n\nvar LGraphManager = __nested_webpack_require_4790__(0).LGraphManager;\n\nfunction CoSEGraphManager(layout) {\n  LGraphManager.call(this, layout);\n}\n\nCoSEGraphManager.prototype = Object.create(LGraphManager.prototype);\nfor (var prop in LGraphManager) {\n  CoSEGraphManager[prop] = LGraphManager[prop];\n}\n\nmodule.exports = CoSEGraphManager;\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __nested_webpack_require_5205__) {\n\n\"use strict\";\n\n\nvar FDLayoutNode = __nested_webpack_require_5205__(0).FDLayoutNode;\nvar IMath = __nested_webpack_require_5205__(0).IMath;\n\nfunction CoSENode(gm, loc, size, vNode) {\n  FDLayoutNode.call(this, gm, loc, size, vNode);\n}\n\nCoSENode.prototype = Object.create(FDLayoutNode.prototype);\nfor (var prop in FDLayoutNode) {\n  CoSENode[prop] = FDLayoutNode[prop];\n}\n\nCoSENode.prototype.move = function () {\n  var layout = this.graphManager.getLayout();\n  this.displacementX = layout.coolingFactor * (this.springForceX + this.repulsionForceX + this.gravitationForceX) / this.noOfChildren;\n  this.displacementY = layout.coolingFactor * (this.springForceY + this.repulsionForceY + this.gravitationForceY) / this.noOfChildren;\n\n  if (Math.abs(this.displacementX) > layout.coolingFactor * layout.maxNodeDisplacement) {\n    this.displacementX = layout.coolingFactor * layout.maxNodeDisplacement * IMath.sign(this.displacementX);\n  }\n\n  if (Math.abs(this.displacementY) > layout.coolingFactor * layout.maxNodeDisplacement) {\n    this.displacementY = layout.coolingFactor * layout.maxNodeDisplacement * IMath.sign(this.displacementY);\n  }\n\n  // a simple node, just move it\n  if (this.child == null) {\n    this.moveBy(this.displacementX, this.displacementY);\n  }\n  // an empty compound node, again just move it\n  else if (this.child.getNodes().length == 0) {\n      this.moveBy(this.displacementX, this.displacementY);\n    }\n    // non-empty compound node, propogate movement to children as well\n    else {\n        this.propogateDisplacementToChildren(this.displacementX, this.displacementY);\n      }\n\n  layout.totalDisplacement += Math.abs(this.displacementX) + Math.abs(this.displacementY);\n\n  this.springForceX = 0;\n  this.springForceY = 0;\n  this.repulsionForceX = 0;\n  this.repulsionForceY = 0;\n  this.gravitationForceX = 0;\n  this.gravitationForceY = 0;\n  this.displacementX = 0;\n  this.displacementY = 0;\n};\n\nCoSENode.prototype.propogateDisplacementToChildren = function (dX, dY) {\n  var nodes = this.getChild().getNodes();\n  var node;\n  for (var i = 0; i < nodes.length; i++) {\n    node = nodes[i];\n    if (node.getChild() == null) {\n      node.moveBy(dX, dY);\n      node.displacementX += dX;\n      node.displacementY += dY;\n    } else {\n      node.propogateDisplacementToChildren(dX, dY);\n    }\n  }\n};\n\nCoSENode.prototype.setPred1 = function (pred1) {\n  this.pred1 = pred1;\n};\n\nCoSENode.prototype.getPred1 = function () {\n  return pred1;\n};\n\nCoSENode.prototype.getPred2 = function () {\n  return pred2;\n};\n\nCoSENode.prototype.setNext = function (next) {\n  this.next = next;\n};\n\nCoSENode.prototype.getNext = function () {\n  return next;\n};\n\nCoSENode.prototype.setProcessed = function (processed) {\n  this.processed = processed;\n};\n\nCoSENode.prototype.isProcessed = function () {\n  return processed;\n};\n\nmodule.exports = CoSENode;\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __nested_webpack_require_8085__) {\n\n\"use strict\";\n\n\nvar FDLayout = __nested_webpack_require_8085__(0).FDLayout;\nvar CoSEGraphManager = __nested_webpack_require_8085__(4);\nvar CoSEGraph = __nested_webpack_require_8085__(3);\nvar CoSENode = __nested_webpack_require_8085__(5);\nvar CoSEEdge = __nested_webpack_require_8085__(2);\nvar CoSEConstants = __nested_webpack_require_8085__(1);\nvar FDLayoutConstants = __nested_webpack_require_8085__(0).FDLayoutConstants;\nvar LayoutConstants = __nested_webpack_require_8085__(0).LayoutConstants;\nvar Point = __nested_webpack_require_8085__(0).Point;\nvar PointD = __nested_webpack_require_8085__(0).PointD;\nvar Layout = __nested_webpack_require_8085__(0).Layout;\nvar Integer = __nested_webpack_require_8085__(0).Integer;\nvar IGeometry = __nested_webpack_require_8085__(0).IGeometry;\nvar LGraph = __nested_webpack_require_8085__(0).LGraph;\nvar Transform = __nested_webpack_require_8085__(0).Transform;\n\nfunction CoSELayout() {\n  FDLayout.call(this);\n\n  this.toBeTiled = {}; // Memorize if a node is to be tiled or is tiled\n}\n\nCoSELayout.prototype = Object.create(FDLayout.prototype);\n\nfor (var prop in FDLayout) {\n  CoSELayout[prop] = FDLayout[prop];\n}\n\nCoSELayout.prototype.newGraphManager = function () {\n  var gm = new CoSEGraphManager(this);\n  this.graphManager = gm;\n  return gm;\n};\n\nCoSELayout.prototype.newGraph = function (vGraph) {\n  return new CoSEGraph(null, this.graphManager, vGraph);\n};\n\nCoSELayout.prototype.newNode = function (vNode) {\n  return new CoSENode(this.graphManager, vNode);\n};\n\nCoSELayout.prototype.newEdge = function (vEdge) {\n  return new CoSEEdge(null, null, vEdge);\n};\n\nCoSELayout.prototype.initParameters = function () {\n  FDLayout.prototype.initParameters.call(this, arguments);\n  if (!this.isSubLayout) {\n    if (CoSEConstants.DEFAULT_EDGE_LENGTH < 10) {\n      this.idealEdgeLength = 10;\n    } else {\n      this.idealEdgeLength = CoSEConstants.DEFAULT_EDGE_LENGTH;\n    }\n\n    this.useSmartIdealEdgeLengthCalculation = CoSEConstants.DEFAULT_USE_SMART_IDEAL_EDGE_LENGTH_CALCULATION;\n    this.springConstant = FDLayoutConstants.DEFAULT_SPRING_STRENGTH;\n    this.repulsionConstant = FDLayoutConstants.DEFAULT_REPULSION_STRENGTH;\n    this.gravityConstant = FDLayoutConstants.DEFAULT_GRAVITY_STRENGTH;\n    this.compoundGravityConstant = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_STRENGTH;\n    this.gravityRangeFactor = FDLayoutConstants.DEFAULT_GRAVITY_RANGE_FACTOR;\n    this.compoundGravityRangeFactor = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR;\n\n    // variables for tree reduction support\n    this.prunedNodesAll = [];\n    this.growTreeIterations = 0;\n    this.afterGrowthIterations = 0;\n    this.isTreeGrowing = false;\n    this.isGrowthFinished = false;\n\n    // variables for cooling\n    this.coolingCycle = 0;\n    this.maxCoolingCycle = this.maxIterations / FDLayoutConstants.CONVERGENCE_CHECK_PERIOD;\n    this.finalTemperature = FDLayoutConstants.CONVERGENCE_CHECK_PERIOD / this.maxIterations;\n    this.coolingAdjuster = 1;\n  }\n};\n\nCoSELayout.prototype.layout = function () {\n  var createBendsAsNeeded = LayoutConstants.DEFAULT_CREATE_BENDS_AS_NEEDED;\n  if (createBendsAsNeeded) {\n    this.createBendpoints();\n    this.graphManager.resetAllEdges();\n  }\n\n  this.level = 0;\n  return this.classicLayout();\n};\n\nCoSELayout.prototype.classicLayout = function () {\n  this.nodesWithGravity = this.calculateNodesToApplyGravitationTo();\n  this.graphManager.setAllNodesToApplyGravitation(this.nodesWithGravity);\n  this.calcNoOfChildrenForAllNodes();\n  this.graphManager.calcLowestCommonAncestors();\n  this.graphManager.calcInclusionTreeDepths();\n  this.graphManager.getRoot().calcEstimatedSize();\n  this.calcIdealEdgeLengths();\n\n  if (!this.incremental) {\n    var forest = this.getFlatForest();\n\n    // The graph associated with this layout is flat and a forest\n    if (forest.length > 0) {\n      this.positionNodesRadially(forest);\n    }\n    // The graph associated with this layout is not flat or a forest\n    else {\n        // Reduce the trees when incremental mode is not enabled and graph is not a forest \n        this.reduceTrees();\n        // Update nodes that gravity will be applied\n        this.graphManager.resetAllNodesToApplyGravitation();\n        var allNodes = new Set(this.getAllNodes());\n        var intersection = this.nodesWithGravity.filter(function (x) {\n          return allNodes.has(x);\n        });\n        this.graphManager.setAllNodesToApplyGravitation(intersection);\n\n        this.positionNodesRandomly();\n      }\n  } else {\n    if (CoSEConstants.TREE_REDUCTION_ON_INCREMENTAL) {\n      // Reduce the trees in incremental mode if only this constant is set to true \n      this.reduceTrees();\n      // Update nodes that gravity will be applied\n      this.graphManager.resetAllNodesToApplyGravitation();\n      var allNodes = new Set(this.getAllNodes());\n      var intersection = this.nodesWithGravity.filter(function (x) {\n        return allNodes.has(x);\n      });\n      this.graphManager.setAllNodesToApplyGravitation(intersection);\n    }\n  }\n\n  this.initSpringEmbedder();\n  this.runSpringEmbedder();\n\n  return true;\n};\n\nCoSELayout.prototype.tick = function () {\n  this.totalIterations++;\n\n  if (this.totalIterations === this.maxIterations && !this.isTreeGrowing && !this.isGrowthFinished) {\n    if (this.prunedNodesAll.length > 0) {\n      this.isTreeGrowing = true;\n    } else {\n      return true;\n    }\n  }\n\n  if (this.totalIterations % FDLayoutConstants.CONVERGENCE_CHECK_PERIOD == 0 && !this.isTreeGrowing && !this.isGrowthFinished) {\n    if (this.isConverged()) {\n      if (this.prunedNodesAll.length > 0) {\n        this.isTreeGrowing = true;\n      } else {\n        return true;\n      }\n    }\n\n    this.coolingCycle++;\n\n    if (this.layoutQuality == 0) {\n      // quality - \"draft\"\n      this.coolingAdjuster = this.coolingCycle;\n    } else if (this.layoutQuality == 1) {\n      // quality - \"default\"\n      this.coolingAdjuster = this.coolingCycle / 3;\n    }\n\n    // cooling schedule is based on http://www.btluke.com/simanf1.html -> cooling schedule 3\n    this.coolingFactor = Math.max(this.initialCoolingFactor - Math.pow(this.coolingCycle, Math.log(100 * (this.initialCoolingFactor - this.finalTemperature)) / Math.log(this.maxCoolingCycle)) / 100 * this.coolingAdjuster, this.finalTemperature);\n    this.animationPeriod = Math.ceil(this.initialAnimationPeriod * Math.sqrt(this.coolingFactor));\n  }\n  // Operations while tree is growing again \n  if (this.isTreeGrowing) {\n    if (this.growTreeIterations % 10 == 0) {\n      if (this.prunedNodesAll.length > 0) {\n        this.graphManager.updateBounds();\n        this.updateGrid();\n        this.growTree(this.prunedNodesAll);\n        // Update nodes that gravity will be applied\n        this.graphManager.resetAllNodesToApplyGravitation();\n        var allNodes = new Set(this.getAllNodes());\n        var intersection = this.nodesWithGravity.filter(function (x) {\n          return allNodes.has(x);\n        });\n        this.graphManager.setAllNodesToApplyGravitation(intersection);\n\n        this.graphManager.updateBounds();\n        this.updateGrid();\n        this.coolingFactor = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL;\n      } else {\n        this.isTreeGrowing = false;\n        this.isGrowthFinished = true;\n      }\n    }\n    this.growTreeIterations++;\n  }\n  // Operations after growth is finished\n  if (this.isGrowthFinished) {\n    if (this.isConverged()) {\n      return true;\n    }\n    if (this.afterGrowthIterations % 10 == 0) {\n      this.graphManager.updateBounds();\n      this.updateGrid();\n    }\n    this.coolingFactor = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL * ((100 - this.afterGrowthIterations) / 100);\n    this.afterGrowthIterations++;\n  }\n\n  var gridUpdateAllowed = !this.isTreeGrowing && !this.isGrowthFinished;\n  var forceToNodeSurroundingUpdate = this.growTreeIterations % 10 == 1 && this.isTreeGrowing || this.afterGrowthIterations % 10 == 1 && this.isGrowthFinished;\n\n  this.totalDisplacement = 0;\n  this.graphManager.updateBounds();\n  this.calcSpringForces();\n  this.calcRepulsionForces(gridUpdateAllowed, forceToNodeSurroundingUpdate);\n  this.calcGravitationalForces();\n  this.moveNodes();\n  this.animate();\n\n  return false; // Layout is not ended yet return false\n};\n\nCoSELayout.prototype.getPositionsData = function () {\n  var allNodes = this.graphManager.getAllNodes();\n  var pData = {};\n  for (var i = 0; i < allNodes.length; i++) {\n    var rect = allNodes[i].rect;\n    var id = allNodes[i].id;\n    pData[id] = {\n      id: id,\n      x: rect.getCenterX(),\n      y: rect.getCenterY(),\n      w: rect.width,\n      h: rect.height\n    };\n  }\n\n  return pData;\n};\n\nCoSELayout.prototype.runSpringEmbedder = function () {\n  this.initialAnimationPeriod = 25;\n  this.animationPeriod = this.initialAnimationPeriod;\n  var layoutEnded = false;\n\n  // If aminate option is 'during' signal that layout is supposed to start iterating\n  if (FDLayoutConstants.ANIMATE === 'during') {\n    this.emit('layoutstarted');\n  } else {\n    // If aminate option is 'during' tick() function will be called on index.js\n    while (!layoutEnded) {\n      layoutEnded = this.tick();\n    }\n\n    this.graphManager.updateBounds();\n  }\n};\n\nCoSELayout.prototype.calculateNodesToApplyGravitationTo = function () {\n  var nodeList = [];\n  var graph;\n\n  var graphs = this.graphManager.getGraphs();\n  var size = graphs.length;\n  var i;\n  for (i = 0; i < size; i++) {\n    graph = graphs[i];\n\n    graph.updateConnected();\n\n    if (!graph.isConnected) {\n      nodeList = nodeList.concat(graph.getNodes());\n    }\n  }\n\n  return nodeList;\n};\n\nCoSELayout.prototype.createBendpoints = function () {\n  var edges = [];\n  edges = edges.concat(this.graphManager.getAllEdges());\n  var visited = new Set();\n  var i;\n  for (i = 0; i < edges.length; i++) {\n    var edge = edges[i];\n\n    if (!visited.has(edge)) {\n      var source = edge.getSource();\n      var target = edge.getTarget();\n\n      if (source == target) {\n        edge.getBendpoints().push(new PointD());\n        edge.getBendpoints().push(new PointD());\n        this.createDummyNodesForBendpoints(edge);\n        visited.add(edge);\n      } else {\n        var edgeList = [];\n\n        edgeList = edgeList.concat(source.getEdgeListToNode(target));\n        edgeList = edgeList.concat(target.getEdgeListToNode(source));\n\n        if (!visited.has(edgeList[0])) {\n          if (edgeList.length > 1) {\n            var k;\n            for (k = 0; k < edgeList.length; k++) {\n              var multiEdge = edgeList[k];\n              multiEdge.getBendpoints().push(new PointD());\n              this.createDummyNodesForBendpoints(multiEdge);\n            }\n          }\n          edgeList.forEach(function (edge) {\n            visited.add(edge);\n          });\n        }\n      }\n    }\n\n    if (visited.size == edges.length) {\n      break;\n    }\n  }\n};\n\nCoSELayout.prototype.positionNodesRadially = function (forest) {\n  // We tile the trees to a grid row by row; first tree starts at (0,0)\n  var currentStartingPoint = new Point(0, 0);\n  var numberOfColumns = Math.ceil(Math.sqrt(forest.length));\n  var height = 0;\n  var currentY = 0;\n  var currentX = 0;\n  var point = new PointD(0, 0);\n\n  for (var i = 0; i < forest.length; i++) {\n    if (i % numberOfColumns == 0) {\n      // Start of a new row, make the x coordinate 0, increment the\n      // y coordinate with the max height of the previous row\n      currentX = 0;\n      currentY = height;\n\n      if (i != 0) {\n        currentY += CoSEConstants.DEFAULT_COMPONENT_SEPERATION;\n      }\n\n      height = 0;\n    }\n\n    var tree = forest[i];\n\n    // Find the center of the tree\n    var centerNode = Layout.findCenterOfTree(tree);\n\n    // Set the staring point of the next tree\n    currentStartingPoint.x = currentX;\n    currentStartingPoint.y = currentY;\n\n    // Do a radial layout starting with the center\n    point = CoSELayout.radialLayout(tree, centerNode, currentStartingPoint);\n\n    if (point.y > height) {\n      height = Math.floor(point.y);\n    }\n\n    currentX = Math.floor(point.x + CoSEConstants.DEFAULT_COMPONENT_SEPERATION);\n  }\n\n  this.transform(new PointD(LayoutConstants.WORLD_CENTER_X - point.x / 2, LayoutConstants.WORLD_CENTER_Y - point.y / 2));\n};\n\nCoSELayout.radialLayout = function (tree, centerNode, startingPoint) {\n  var radialSep = Math.max(this.maxDiagonalInTree(tree), CoSEConstants.DEFAULT_RADIAL_SEPARATION);\n  CoSELayout.branchRadialLayout(centerNode, null, 0, 359, 0, radialSep);\n  var bounds = LGraph.calculateBounds(tree);\n\n  var transform = new Transform();\n  transform.setDeviceOrgX(bounds.getMinX());\n  transform.setDeviceOrgY(bounds.getMinY());\n  transform.setWorldOrgX(startingPoint.x);\n  transform.setWorldOrgY(startingPoint.y);\n\n  for (var i = 0; i < tree.length; i++) {\n    var node = tree[i];\n    node.transform(transform);\n  }\n\n  var bottomRight = new PointD(bounds.getMaxX(), bounds.getMaxY());\n\n  return transform.inverseTransformPoint(bottomRight);\n};\n\nCoSELayout.branchRadialLayout = function (node, parentOfNode, startAngle, endAngle, distance, radialSeparation) {\n  // First, position this node by finding its angle.\n  var halfInterval = (endAngle - startAngle + 1) / 2;\n\n  if (halfInterval < 0) {\n    halfInterval += 180;\n  }\n\n  var nodeAngle = (halfInterval + startAngle) % 360;\n  var teta = nodeAngle * IGeometry.TWO_PI / 360;\n\n  // Make polar to java cordinate conversion.\n  var cos_teta = Math.cos(teta);\n  var x_ = distance * Math.cos(teta);\n  var y_ = distance * Math.sin(teta);\n\n  node.setCenter(x_, y_);\n\n  // Traverse all neighbors of this node and recursively call this\n  // function.\n  var neighborEdges = [];\n  neighborEdges = neighborEdges.concat(node.getEdges());\n  var childCount = neighborEdges.length;\n\n  if (parentOfNode != null) {\n    childCount--;\n  }\n\n  var branchCount = 0;\n\n  var incEdgesCount = neighborEdges.length;\n  var startIndex;\n\n  var edges = node.getEdgesBetween(parentOfNode);\n\n  // If there are multiple edges, prune them until there remains only one\n  // edge.\n  while (edges.length > 1) {\n    //neighborEdges.remove(edges.remove(0));\n    var temp = edges[0];\n    edges.splice(0, 1);\n    var index = neighborEdges.indexOf(temp);\n    if (index >= 0) {\n      neighborEdges.splice(index, 1);\n    }\n    incEdgesCount--;\n    childCount--;\n  }\n\n  if (parentOfNode != null) {\n    //assert edges.length == 1;\n    startIndex = (neighborEdges.indexOf(edges[0]) + 1) % incEdgesCount;\n  } else {\n    startIndex = 0;\n  }\n\n  var stepAngle = Math.abs(endAngle - startAngle) / childCount;\n\n  for (var i = startIndex; branchCount != childCount; i = ++i % incEdgesCount) {\n    var currentNeighbor = neighborEdges[i].getOtherEnd(node);\n\n    // Don't back traverse to root node in current tree.\n    if (currentNeighbor == parentOfNode) {\n      continue;\n    }\n\n    var childStartAngle = (startAngle + branchCount * stepAngle) % 360;\n    var childEndAngle = (childStartAngle + stepAngle) % 360;\n\n    CoSELayout.branchRadialLayout(currentNeighbor, node, childStartAngle, childEndAngle, distance + radialSeparation, radialSeparation);\n\n    branchCount++;\n  }\n};\n\nCoSELayout.maxDiagonalInTree = function (tree) {\n  var maxDiagonal = Integer.MIN_VALUE;\n\n  for (var i = 0; i < tree.length; i++) {\n    var node = tree[i];\n    var diagonal = node.getDiagonal();\n\n    if (diagonal > maxDiagonal) {\n      maxDiagonal = diagonal;\n    }\n  }\n\n  return maxDiagonal;\n};\n\nCoSELayout.prototype.calcRepulsionRange = function () {\n  // formula is 2 x (level + 1) x idealEdgeLength\n  return 2 * (this.level + 1) * this.idealEdgeLength;\n};\n\n// Tiling methods\n\n// Group zero degree members whose parents are not to be tiled, create dummy parents where needed and fill memberGroups by their dummp parent id's\nCoSELayout.prototype.groupZeroDegreeMembers = function () {\n  var self = this;\n  // array of [parent_id x oneDegreeNode_id]\n  var tempMemberGroups = {}; // A temporary map of parent node and its zero degree members\n  this.memberGroups = {}; // A map of dummy parent node and its zero degree members whose parents are not to be tiled\n  this.idToDummyNode = {}; // A map of id to dummy node \n\n  var zeroDegree = []; // List of zero degree nodes whose parents are not to be tiled\n  var allNodes = this.graphManager.getAllNodes();\n\n  // Fill zero degree list\n  for (var i = 0; i < allNodes.length; i++) {\n    var node = allNodes[i];\n    var parent = node.getParent();\n    // If a node has zero degree and its parent is not to be tiled if exists add that node to zeroDegres list\n    if (this.getNodeDegreeWithChildren(node) === 0 && (parent.id == undefined || !this.getToBeTiled(parent))) {\n      zeroDegree.push(node);\n    }\n  }\n\n  // Create a map of parent node and its zero degree members\n  for (var i = 0; i < zeroDegree.length; i++) {\n    var node = zeroDegree[i]; // Zero degree node itself\n    var p_id = node.getParent().id; // Parent id\n\n    if (typeof tempMemberGroups[p_id] === \"undefined\") tempMemberGroups[p_id] = [];\n\n    tempMemberGroups[p_id] = tempMemberGroups[p_id].concat(node); // Push node to the list belongs to its parent in tempMemberGroups\n  }\n\n  // If there are at least two nodes at a level, create a dummy compound for them\n  Object.keys(tempMemberGroups).forEach(function (p_id) {\n    if (tempMemberGroups[p_id].length > 1) {\n      var dummyCompoundId = \"DummyCompound_\" + p_id; // The id of dummy compound which will be created soon\n      self.memberGroups[dummyCompoundId] = tempMemberGroups[p_id]; // Add dummy compound to memberGroups\n\n      var parent = tempMemberGroups[p_id][0].getParent(); // The parent of zero degree nodes will be the parent of new dummy compound\n\n      // Create a dummy compound with calculated id\n      var dummyCompound = new CoSENode(self.graphManager);\n      dummyCompound.id = dummyCompoundId;\n      dummyCompound.paddingLeft = parent.paddingLeft || 0;\n      dummyCompound.paddingRight = parent.paddingRight || 0;\n      dummyCompound.paddingBottom = parent.paddingBottom || 0;\n      dummyCompound.paddingTop = parent.paddingTop || 0;\n\n      self.idToDummyNode[dummyCompoundId] = dummyCompound;\n\n      var dummyParentGraph = self.getGraphManager().add(self.newGraph(), dummyCompound);\n      var parentGraph = parent.getChild();\n\n      // Add dummy compound to parent the graph\n      parentGraph.add(dummyCompound);\n\n      // For each zero degree node in this level remove it from its parent graph and add it to the graph of dummy parent\n      for (var i = 0; i < tempMemberGroups[p_id].length; i++) {\n        var node = tempMemberGroups[p_id][i];\n\n        parentGraph.remove(node);\n        dummyParentGraph.add(node);\n      }\n    }\n  });\n};\n\nCoSELayout.prototype.clearCompounds = function () {\n  var childGraphMap = {};\n  var idToNode = {};\n\n  // Get compound ordering by finding the inner one first\n  this.performDFSOnCompounds();\n\n  for (var i = 0; i < this.compoundOrder.length; i++) {\n\n    idToNode[this.compoundOrder[i].id] = this.compoundOrder[i];\n    childGraphMap[this.compoundOrder[i].id] = [].concat(this.compoundOrder[i].getChild().getNodes());\n\n    // Remove children of compounds\n    this.graphManager.remove(this.compoundOrder[i].getChild());\n    this.compoundOrder[i].child = null;\n  }\n\n  this.graphManager.resetAllNodes();\n\n  // Tile the removed children\n  this.tileCompoundMembers(childGraphMap, idToNode);\n};\n\nCoSELayout.prototype.clearZeroDegreeMembers = function () {\n  var self = this;\n  var tiledZeroDegreePack = this.tiledZeroDegreePack = [];\n\n  Object.keys(this.memberGroups).forEach(function (id) {\n    var compoundNode = self.idToDummyNode[id]; // Get the dummy compound\n\n    tiledZeroDegreePack[id] = self.tileNodes(self.memberGroups[id], compoundNode.paddingLeft + compoundNode.paddingRight);\n\n    // Set the width and height of the dummy compound as calculated\n    compoundNode.rect.width = tiledZeroDegreePack[id].width;\n    compoundNode.rect.height = tiledZeroDegreePack[id].height;\n  });\n};\n\nCoSELayout.prototype.repopulateCompounds = function () {\n  for (var i = this.compoundOrder.length - 1; i >= 0; i--) {\n    var lCompoundNode = this.compoundOrder[i];\n    var id = lCompoundNode.id;\n    var horizontalMargin = lCompoundNode.paddingLeft;\n    var verticalMargin = lCompoundNode.paddingTop;\n\n    this.adjustLocations(this.tiledMemberPack[id], lCompoundNode.rect.x, lCompoundNode.rect.y, horizontalMargin, verticalMargin);\n  }\n};\n\nCoSELayout.prototype.repopulateZeroDegreeMembers = function () {\n  var self = this;\n  var tiledPack = this.tiledZeroDegreePack;\n\n  Object.keys(tiledPack).forEach(function (id) {\n    var compoundNode = self.idToDummyNode[id]; // Get the dummy compound by its id\n    var horizontalMargin = compoundNode.paddingLeft;\n    var verticalMargin = compoundNode.paddingTop;\n\n    // Adjust the positions of nodes wrt its compound\n    self.adjustLocations(tiledPack[id], compoundNode.rect.x, compoundNode.rect.y, horizontalMargin, verticalMargin);\n  });\n};\n\nCoSELayout.prototype.getToBeTiled = function (node) {\n  var id = node.id;\n  //firstly check the previous results\n  if (this.toBeTiled[id] != null) {\n    return this.toBeTiled[id];\n  }\n\n  //only compound nodes are to be tiled\n  var childGraph = node.getChild();\n  if (childGraph == null) {\n    this.toBeTiled[id] = false;\n    return false;\n  }\n\n  var children = childGraph.getNodes(); // Get the children nodes\n\n  //a compound node is not to be tiled if all of its compound children are not to be tiled\n  for (var i = 0; i < children.length; i++) {\n    var theChild = children[i];\n\n    if (this.getNodeDegree(theChild) > 0) {\n      this.toBeTiled[id] = false;\n      return false;\n    }\n\n    //pass the children not having the compound structure\n    if (theChild.getChild() == null) {\n      this.toBeTiled[theChild.id] = false;\n      continue;\n    }\n\n    if (!this.getToBeTiled(theChild)) {\n      this.toBeTiled[id] = false;\n      return false;\n    }\n  }\n  this.toBeTiled[id] = true;\n  return true;\n};\n\n// Get degree of a node depending of its edges and independent of its children\nCoSELayout.prototype.getNodeDegree = function (node) {\n  var id = node.id;\n  var edges = node.getEdges();\n  var degree = 0;\n\n  // For the edges connected\n  for (var i = 0; i < edges.length; i++) {\n    var edge = edges[i];\n    if (edge.getSource().id !== edge.getTarget().id) {\n      degree = degree + 1;\n    }\n  }\n  return degree;\n};\n\n// Get degree of a node with its children\nCoSELayout.prototype.getNodeDegreeWithChildren = function (node) {\n  var degree = this.getNodeDegree(node);\n  if (node.getChild() == null) {\n    return degree;\n  }\n  var children = node.getChild().getNodes();\n  for (var i = 0; i < children.length; i++) {\n    var child = children[i];\n    degree += this.getNodeDegreeWithChildren(child);\n  }\n  return degree;\n};\n\nCoSELayout.prototype.performDFSOnCompounds = function () {\n  this.compoundOrder = [];\n  this.fillCompexOrderByDFS(this.graphManager.getRoot().getNodes());\n};\n\nCoSELayout.prototype.fillCompexOrderByDFS = function (children) {\n  for (var i = 0; i < children.length; i++) {\n    var child = children[i];\n    if (child.getChild() != null) {\n      this.fillCompexOrderByDFS(child.getChild().getNodes());\n    }\n    if (this.getToBeTiled(child)) {\n      this.compoundOrder.push(child);\n    }\n  }\n};\n\n/**\n* This method places each zero degree member wrt given (x,y) coordinates (top left).\n*/\nCoSELayout.prototype.adjustLocations = function (organization, x, y, compoundHorizontalMargin, compoundVerticalMargin) {\n  x += compoundHorizontalMargin;\n  y += compoundVerticalMargin;\n\n  var left = x;\n\n  for (var i = 0; i < organization.rows.length; i++) {\n    var row = organization.rows[i];\n    x = left;\n    var maxHeight = 0;\n\n    for (var j = 0; j < row.length; j++) {\n      var lnode = row[j];\n\n      lnode.rect.x = x; // + lnode.rect.width / 2;\n      lnode.rect.y = y; // + lnode.rect.height / 2;\n\n      x += lnode.rect.width + organization.horizontalPadding;\n\n      if (lnode.rect.height > maxHeight) maxHeight = lnode.rect.height;\n    }\n\n    y += maxHeight + organization.verticalPadding;\n  }\n};\n\nCoSELayout.prototype.tileCompoundMembers = function (childGraphMap, idToNode) {\n  var self = this;\n  this.tiledMemberPack = [];\n\n  Object.keys(childGraphMap).forEach(function (id) {\n    // Get the compound node\n    var compoundNode = idToNode[id];\n\n    self.tiledMemberPack[id] = self.tileNodes(childGraphMap[id], compoundNode.paddingLeft + compoundNode.paddingRight);\n\n    compoundNode.rect.width = self.tiledMemberPack[id].width;\n    compoundNode.rect.height = self.tiledMemberPack[id].height;\n  });\n};\n\nCoSELayout.prototype.tileNodes = function (nodes, minWidth) {\n  var verticalPadding = CoSEConstants.TILING_PADDING_VERTICAL;\n  var horizontalPadding = CoSEConstants.TILING_PADDING_HORIZONTAL;\n  var organization = {\n    rows: [],\n    rowWidth: [],\n    rowHeight: [],\n    width: 0,\n    height: minWidth, // assume minHeight equals to minWidth\n    verticalPadding: verticalPadding,\n    horizontalPadding: horizontalPadding\n  };\n\n  // Sort the nodes in ascending order of their areas\n  nodes.sort(function (n1, n2) {\n    if (n1.rect.width * n1.rect.height > n2.rect.width * n2.rect.height) return -1;\n    if (n1.rect.width * n1.rect.height < n2.rect.width * n2.rect.height) return 1;\n    return 0;\n  });\n\n  // Create the organization -> tile members\n  for (var i = 0; i < nodes.length; i++) {\n    var lNode = nodes[i];\n\n    if (organization.rows.length == 0) {\n      this.insertNodeToRow(organization, lNode, 0, minWidth);\n    } else if (this.canAddHorizontal(organization, lNode.rect.width, lNode.rect.height)) {\n      this.insertNodeToRow(organization, lNode, this.getShortestRowIndex(organization), minWidth);\n    } else {\n      this.insertNodeToRow(organization, lNode, organization.rows.length, minWidth);\n    }\n\n    this.shiftToLastRow(organization);\n  }\n\n  return organization;\n};\n\nCoSELayout.prototype.insertNodeToRow = function (organization, node, rowIndex, minWidth) {\n  var minCompoundSize = minWidth;\n\n  // Add new row if needed\n  if (rowIndex == organization.rows.length) {\n    var secondDimension = [];\n\n    organization.rows.push(secondDimension);\n    organization.rowWidth.push(minCompoundSize);\n    organization.rowHeight.push(0);\n  }\n\n  // Update row width\n  var w = organization.rowWidth[rowIndex] + node.rect.width;\n\n  if (organization.rows[rowIndex].length > 0) {\n    w += organization.horizontalPadding;\n  }\n\n  organization.rowWidth[rowIndex] = w;\n  // Update compound width\n  if (organization.width < w) {\n    organization.width = w;\n  }\n\n  // Update height\n  var h = node.rect.height;\n  if (rowIndex > 0) h += organization.verticalPadding;\n\n  var extraHeight = 0;\n  if (h > organization.rowHeight[rowIndex]) {\n    extraHeight = organization.rowHeight[rowIndex];\n    organization.rowHeight[rowIndex] = h;\n    extraHeight = organization.rowHeight[rowIndex] - extraHeight;\n  }\n\n  organization.height += extraHeight;\n\n  // Insert node\n  organization.rows[rowIndex].push(node);\n};\n\n//Scans the rows of an organization and returns the one with the min width\nCoSELayout.prototype.getShortestRowIndex = function (organization) {\n  var r = -1;\n  var min = Number.MAX_VALUE;\n\n  for (var i = 0; i < organization.rows.length; i++) {\n    if (organization.rowWidth[i] < min) {\n      r = i;\n      min = organization.rowWidth[i];\n    }\n  }\n  return r;\n};\n\n//Scans the rows of an organization and returns the one with the max width\nCoSELayout.prototype.getLongestRowIndex = function (organization) {\n  var r = -1;\n  var max = Number.MIN_VALUE;\n\n  for (var i = 0; i < organization.rows.length; i++) {\n\n    if (organization.rowWidth[i] > max) {\n      r = i;\n      max = organization.rowWidth[i];\n    }\n  }\n\n  return r;\n};\n\n/**\n* This method checks whether adding extra width to the organization violates\n* the aspect ratio(1) or not.\n*/\nCoSELayout.prototype.canAddHorizontal = function (organization, extraWidth, extraHeight) {\n\n  var sri = this.getShortestRowIndex(organization);\n\n  if (sri < 0) {\n    return true;\n  }\n\n  var min = organization.rowWidth[sri];\n\n  if (min + organization.horizontalPadding + extraWidth <= organization.width) return true;\n\n  var hDiff = 0;\n\n  // Adding to an existing row\n  if (organization.rowHeight[sri] < extraHeight) {\n    if (sri > 0) hDiff = extraHeight + organization.verticalPadding - organization.rowHeight[sri];\n  }\n\n  var add_to_row_ratio;\n  if (organization.width - min >= extraWidth + organization.horizontalPadding) {\n    add_to_row_ratio = (organization.height + hDiff) / (min + extraWidth + organization.horizontalPadding);\n  } else {\n    add_to_row_ratio = (organization.height + hDiff) / organization.width;\n  }\n\n  // Adding a new row for this node\n  hDiff = extraHeight + organization.verticalPadding;\n  var add_new_row_ratio;\n  if (organization.width < extraWidth) {\n    add_new_row_ratio = (organization.height + hDiff) / extraWidth;\n  } else {\n    add_new_row_ratio = (organization.height + hDiff) / organization.width;\n  }\n\n  if (add_new_row_ratio < 1) add_new_row_ratio = 1 / add_new_row_ratio;\n\n  if (add_to_row_ratio < 1) add_to_row_ratio = 1 / add_to_row_ratio;\n\n  return add_to_row_ratio < add_new_row_ratio;\n};\n\n//If moving the last node from the longest row and adding it to the last\n//row makes the bounding box smaller, do it.\nCoSELayout.prototype.shiftToLastRow = function (organization) {\n  var longest = this.getLongestRowIndex(organization);\n  var last = organization.rowWidth.length - 1;\n  var row = organization.rows[longest];\n  var node = row[row.length - 1];\n\n  var diff = node.width + organization.horizontalPadding;\n\n  // Check if there is enough space on the last row\n  if (organization.width - organization.rowWidth[last] > diff && longest != last) {\n    // Remove the last element of the longest row\n    row.splice(-1, 1);\n\n    // Push it to the last row\n    organization.rows[last].push(node);\n\n    organization.rowWidth[longest] = organization.rowWidth[longest] - diff;\n    organization.rowWidth[last] = organization.rowWidth[last] + diff;\n    organization.width = organization.rowWidth[instance.getLongestRowIndex(organization)];\n\n    // Update heights of the organization\n    var maxHeight = Number.MIN_VALUE;\n    for (var i = 0; i < row.length; i++) {\n      if (row[i].height > maxHeight) maxHeight = row[i].height;\n    }\n    if (longest > 0) maxHeight += organization.verticalPadding;\n\n    var prevTotal = organization.rowHeight[longest] + organization.rowHeight[last];\n\n    organization.rowHeight[longest] = maxHeight;\n    if (organization.rowHeight[last] < node.height + organization.verticalPadding) organization.rowHeight[last] = node.height + organization.verticalPadding;\n\n    var finalTotal = organization.rowHeight[longest] + organization.rowHeight[last];\n    organization.height += finalTotal - prevTotal;\n\n    this.shiftToLastRow(organization);\n  }\n};\n\nCoSELayout.prototype.tilingPreLayout = function () {\n  if (CoSEConstants.TILE) {\n    // Find zero degree nodes and create a compound for each level\n    this.groupZeroDegreeMembers();\n    // Tile and clear children of each compound\n    this.clearCompounds();\n    // Separately tile and clear zero degree nodes for each level\n    this.clearZeroDegreeMembers();\n  }\n};\n\nCoSELayout.prototype.tilingPostLayout = function () {\n  if (CoSEConstants.TILE) {\n    this.repopulateZeroDegreeMembers();\n    this.repopulateCompounds();\n  }\n};\n\n// -----------------------------------------------------------------------------\n// Section: Tree Reduction methods\n// -----------------------------------------------------------------------------\n// Reduce trees \nCoSELayout.prototype.reduceTrees = function () {\n  var prunedNodesAll = [];\n  var containsLeaf = true;\n  var node;\n\n  while (containsLeaf) {\n    var allNodes = this.graphManager.getAllNodes();\n    var prunedNodesInStepTemp = [];\n    containsLeaf = false;\n\n    for (var i = 0; i < allNodes.length; i++) {\n      node = allNodes[i];\n      if (node.getEdges().length == 1 && !node.getEdges()[0].isInterGraph && node.getChild() == null) {\n        prunedNodesInStepTemp.push([node, node.getEdges()[0], node.getOwner()]);\n        containsLeaf = true;\n      }\n    }\n    if (containsLeaf == true) {\n      var prunedNodesInStep = [];\n      for (var j = 0; j < prunedNodesInStepTemp.length; j++) {\n        if (prunedNodesInStepTemp[j][0].getEdges().length == 1) {\n          prunedNodesInStep.push(prunedNodesInStepTemp[j]);\n          prunedNodesInStepTemp[j][0].getOwner().remove(prunedNodesInStepTemp[j][0]);\n        }\n      }\n      prunedNodesAll.push(prunedNodesInStep);\n      this.graphManager.resetAllNodes();\n      this.graphManager.resetAllEdges();\n    }\n  }\n  this.prunedNodesAll = prunedNodesAll;\n};\n\n// Grow tree one step \nCoSELayout.prototype.growTree = function (prunedNodesAll) {\n  var lengthOfPrunedNodesInStep = prunedNodesAll.length;\n  var prunedNodesInStep = prunedNodesAll[lengthOfPrunedNodesInStep - 1];\n\n  var nodeData;\n  for (var i = 0; i < prunedNodesInStep.length; i++) {\n    nodeData = prunedNodesInStep[i];\n\n    this.findPlaceforPrunedNode(nodeData);\n\n    nodeData[2].add(nodeData[0]);\n    nodeData[2].add(nodeData[1], nodeData[1].source, nodeData[1].target);\n  }\n\n  prunedNodesAll.splice(prunedNodesAll.length - 1, 1);\n  this.graphManager.resetAllNodes();\n  this.graphManager.resetAllEdges();\n};\n\n// Find an appropriate position to replace pruned node, this method can be improved\nCoSELayout.prototype.findPlaceforPrunedNode = function (nodeData) {\n\n  var gridForPrunedNode;\n  var nodeToConnect;\n  var prunedNode = nodeData[0];\n  if (prunedNode == nodeData[1].source) {\n    nodeToConnect = nodeData[1].target;\n  } else {\n    nodeToConnect = nodeData[1].source;\n  }\n  var startGridX = nodeToConnect.startX;\n  var finishGridX = nodeToConnect.finishX;\n  var startGridY = nodeToConnect.startY;\n  var finishGridY = nodeToConnect.finishY;\n\n  var upNodeCount = 0;\n  var downNodeCount = 0;\n  var rightNodeCount = 0;\n  var leftNodeCount = 0;\n  var controlRegions = [upNodeCount, rightNodeCount, downNodeCount, leftNodeCount];\n\n  if (startGridY > 0) {\n    for (var i = startGridX; i <= finishGridX; i++) {\n      controlRegions[0] += this.grid[i][startGridY - 1].length + this.grid[i][startGridY].length - 1;\n    }\n  }\n  if (finishGridX < this.grid.length - 1) {\n    for (var i = startGridY; i <= finishGridY; i++) {\n      controlRegions[1] += this.grid[finishGridX + 1][i].length + this.grid[finishGridX][i].length - 1;\n    }\n  }\n  if (finishGridY < this.grid[0].length - 1) {\n    for (var i = startGridX; i <= finishGridX; i++) {\n      controlRegions[2] += this.grid[i][finishGridY + 1].length + this.grid[i][finishGridY].length - 1;\n    }\n  }\n  if (startGridX > 0) {\n    for (var i = startGridY; i <= finishGridY; i++) {\n      controlRegions[3] += this.grid[startGridX - 1][i].length + this.grid[startGridX][i].length - 1;\n    }\n  }\n  var min = Integer.MAX_VALUE;\n  var minCount;\n  var minIndex;\n  for (var j = 0; j < controlRegions.length; j++) {\n    if (controlRegions[j] < min) {\n      min = controlRegions[j];\n      minCount = 1;\n      minIndex = j;\n    } else if (controlRegions[j] == min) {\n      minCount++;\n    }\n  }\n\n  if (minCount == 3 && min == 0) {\n    if (controlRegions[0] == 0 && controlRegions[1] == 0 && controlRegions[2] == 0) {\n      gridForPrunedNode = 1;\n    } else if (controlRegions[0] == 0 && controlRegions[1] == 0 && controlRegions[3] == 0) {\n      gridForPrunedNode = 0;\n    } else if (controlRegions[0] == 0 && controlRegions[2] == 0 && controlRegions[3] == 0) {\n      gridForPrunedNode = 3;\n    } else if (controlRegions[1] == 0 && controlRegions[2] == 0 && controlRegions[3] == 0) {\n      gridForPrunedNode = 2;\n    }\n  } else if (minCount == 2 && min == 0) {\n    var random = Math.floor(Math.random() * 2);\n    if (controlRegions[0] == 0 && controlRegions[1] == 0) {\n      ;\n      if (random == 0) {\n        gridForPrunedNode = 0;\n      } else {\n        gridForPrunedNode = 1;\n      }\n    } else if (controlRegions[0] == 0 && controlRegions[2] == 0) {\n      if (random == 0) {\n        gridForPrunedNode = 0;\n      } else {\n        gridForPrunedNode = 2;\n      }\n    } else if (controlRegions[0] == 0 && controlRegions[3] == 0) {\n      if (random == 0) {\n        gridForPrunedNode = 0;\n      } else {\n        gridForPrunedNode = 3;\n      }\n    } else if (controlRegions[1] == 0 && controlRegions[2] == 0) {\n      if (random == 0) {\n        gridForPrunedNode = 1;\n      } else {\n        gridForPrunedNode = 2;\n      }\n    } else if (controlRegions[1] == 0 && controlRegions[3] == 0) {\n      if (random == 0) {\n        gridForPrunedNode = 1;\n      } else {\n        gridForPrunedNode = 3;\n      }\n    } else {\n      if (random == 0) {\n        gridForPrunedNode = 2;\n      } else {\n        gridForPrunedNode = 3;\n      }\n    }\n  } else if (minCount == 4 && min == 0) {\n    var random = Math.floor(Math.random() * 4);\n    gridForPrunedNode = random;\n  } else {\n    gridForPrunedNode = minIndex;\n  }\n\n  if (gridForPrunedNode == 0) {\n    prunedNode.setCenter(nodeToConnect.getCenterX(), nodeToConnect.getCenterY() - nodeToConnect.getHeight() / 2 - FDLayoutConstants.DEFAULT_EDGE_LENGTH - prunedNode.getHeight() / 2);\n  } else if (gridForPrunedNode == 1) {\n    prunedNode.setCenter(nodeToConnect.getCenterX() + nodeToConnect.getWidth() / 2 + FDLayoutConstants.DEFAULT_EDGE_LENGTH + prunedNode.getWidth() / 2, nodeToConnect.getCenterY());\n  } else if (gridForPrunedNode == 2) {\n    prunedNode.setCenter(nodeToConnect.getCenterX(), nodeToConnect.getCenterY() + nodeToConnect.getHeight() / 2 + FDLayoutConstants.DEFAULT_EDGE_LENGTH + prunedNode.getHeight() / 2);\n  } else {\n    prunedNode.setCenter(nodeToConnect.getCenterX() - nodeToConnect.getWidth() / 2 - FDLayoutConstants.DEFAULT_EDGE_LENGTH - prunedNode.getWidth() / 2, nodeToConnect.getCenterY());\n  }\n};\n\nmodule.exports = CoSELayout;\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __nested_webpack_require_45620__) {\n\n\"use strict\";\n\n\nvar coseBase = {};\n\ncoseBase.layoutBase = __nested_webpack_require_45620__(0);\ncoseBase.CoSEConstants = __nested_webpack_require_45620__(1);\ncoseBase.CoSEEdge = __nested_webpack_require_45620__(2);\ncoseBase.CoSEGraph = __nested_webpack_require_45620__(3);\ncoseBase.CoSEGraphManager = __nested_webpack_require_45620__(4);\ncoseBase.CoSELayout = __nested_webpack_require_45620__(6);\ncoseBase.CoSENode = __nested_webpack_require_45620__(5);\n\nmodule.exports = coseBase;\n\n/***/ })\n/******/ ]);\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY29zZS1iYXNlL2Nvc2UtYmFzZS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLElBQUksSUFBeUQ7QUFDN0QsMkJBQTJCLG1CQUFPLENBQUMsOERBQWE7QUFDaEQsTUFBTSxFQUsyQztBQUNqRCxDQUFDO0FBQ0QscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDhCQUFtQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRSw4QkFBbUI7QUFDN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDhCQUFtQjtBQUM3QjtBQUNBO0FBQ0EsVUFBVSw4QkFBbUI7QUFDN0I7QUFDQTtBQUNBLFVBQVUsOEJBQW1CLHVCQUF1QjtBQUNwRDtBQUNBO0FBQ0EsVUFBVSw4QkFBbUI7QUFDN0IsZUFBZSw4QkFBbUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDhCQUFtQjtBQUM3QjtBQUNBLG9DQUFvQyw0QkFBNEI7QUFDaEUsMENBQTBDO0FBQzFDLFdBQVcsOEJBQW1CO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSw4QkFBbUIsa0NBQWtDO0FBQy9EO0FBQ0E7QUFDQSxVQUFVLDhCQUFtQjtBQUM3QjtBQUNBO0FBQ0EsaUJBQWlCLDhCQUFtQixDQUFDLDhCQUFtQjtBQUN4RCxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsT0FBTztBQUNQO0FBQ0EsaUNBQWlDLCtCQUFtQjs7QUFFcEQ7OztBQUdBLHdCQUF3QiwrQkFBbUI7O0FBRTNDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDs7QUFFckQ7O0FBRUEsT0FBTztBQUNQO0FB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QkFBMkI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBOztBQUVBLE9BQU87QUFDUDtBQUNBLGlDQUFpQyxnQ0FBbUI7O0FBRXBEOzs7QUFHQTs7QUFFQSxzQkFBc0IsZ0NBQW1CO0FBQ3pDLHlCQUF5QixnQ0FBbUI7QUFDNUMsb0JBQW9CLGdDQUFtQjtBQUN2QyxxQkFBcUIsZ0NBQW1CO0FBQ3hDLDRCQUE0QixnQ0FBbUI7QUFDL0Msc0JBQXNCLGdDQUFtQjtBQUN6QyxvQkFBb0IsZ0NBQW1COztBQUV2Qzs7QUFFQSxPQUFPO0FBQ1A7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9jb3NlLWJhc2UvY29zZS1iYXNlLmpzP2Y4Y2YiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKFwibGF5b3V0LWJhc2VcIikpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoW1wibGF5b3V0LWJhc2VcIl0sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1wiY29zZUJhc2VcIl0gPSBmYWN0b3J5KHJlcXVpcmUoXCJsYXlvdXQtYmFzZVwiKSk7XG5cdGVsc2Vcblx0XHRyb290W1wiY29zZUJhc2VcIl0gPSBmYWN0b3J5KHJvb3RbXCJsYXlvdXRCYXNlXCJdKTtcbn0pKHRoaXMsIGZ1bmN0aW9uKF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfMF9fKSB7XG5yZXR1cm4gLyoqKioqKi8gKGZ1bmN0aW9uKG1vZHVsZXMpIHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuLyoqKioqKi8gXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuLyoqKioqKi8gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuLyoqKioqKi8gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4vKioqKioqLyBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbi8qKioqKiovIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4vKioqKioqLyBcdFx0XHRpOiBtb2R1bGVJZCxcbi8qKioqKiovIFx0XHRcdGw6IGZhbHNlLFxuLyoqKioqKi8gXHRcdFx0ZXhwb3J0czoge31cbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbi8qKioqKiovIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuLyoqKioqKi8gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdH1cbi8qKioqKiovXG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGlkZW50aXR5IGZ1bmN0aW9uIGZvciBjYWxsaW5nIGhhcm1vbnkgaW1wb3J0cyB3aXRoIHRoZSBjb3JyZWN0IGNvbnRleHRcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5pID0gZnVuY3Rpb24odmFsdWUpIHsgcmV0dXJuIHZhbHVlOyB9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuLyoqKioqKi8gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbi8qKioqKiovIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7XG4vKioqKioqLyBcdFx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4vKioqKioqLyBcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG4vKioqKioqLyBcdFx0XHRcdGdldDogZ2V0dGVyXG4vKioqKioqLyBcdFx0XHR9KTtcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbi8qKioqKiovIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbi8qKioqKiovIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4vKioqKioqLyBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbi8qKioqKiovIFx0XHRyZXR1cm4gZ2V0dGVyO1xuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbi8qKioqKiovIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gNyk7XG4vKioqKioqLyB9KVxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIChbXG4vKiAwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV8wX187XG5cbi8qKiovIH0pLFxuLyogMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgRkRMYXlvdXRDb25zdGFudHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApLkZETGF5b3V0Q29uc3RhbnRzO1xuXG5mdW5jdGlvbiBDb1NFQ29uc3RhbnRzKCkge31cblxuLy9Db1NFQ29uc3RhbnRzIGluaGVyaXRzIHN0YXRpYyBwcm9wcyBpbiBGRExheW91dENvbnN0YW50c1xuZm9yICh2YXIgcHJvcCBpbiBGRExheW91dENvbnN0YW50cykge1xuICBDb1NFQ29uc3RhbnRzW3Byb3BdID0gRkRMYXlvdXRDb25zdGFudHNbcHJvcF07XG59XG5cbkNvU0VDb25zdGFudHMuREVGQVVMVF9VU0VfTVVMVElfTEVWRUxfU0NBTElORyA9IGZhbHNlO1xuQ29TRUNvbnN0YW50cy5ERUZBVUxUX1JBRElBTF9TRVBBUkFUSU9OID0gRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9FREdFX0xFTkdUSDtcbkNvU0VDb25zdGFudHMuREVGQVVMVF9DT01QT05FTlRfU0VQRVJBVElPTiA9IDYwO1xuQ29TRUNvbnN0YW50cy5USUxFID0gdHJ1ZTtcbkNvU0VDb25zdGFudHMuVElMSU5HX1BBRERJTkdfVkVSVElDQUwgPSAxMDtcbkNvU0VDb25zdGFudHMuVElMSU5HX1BBRERJTkdfSE9SSVpPTlRBTCA9IDEwO1xuQ29TRUNvbnN0YW50cy5UUkVFX1JFRFVDVElPTl9PTl9JTkNSRU1FTlRBTCA9IGZhbHNlOyAvLyBtYWtlIHRoaXMgdHJ1ZSB3aGVuIGNvc2UgaXMgdXNlZCBpbmNyZW1lbnRhbGx5IGFzIGEgcGFydCBvZiBvdGhlciBub24taW5jcmVtZW50YWwgbGF5b3V0XG5cbm1vZHVsZS5leHBvcnRzID0gQ29TRUNvbnN0YW50cztcblxuLyoqKi8gfSksXG4vKiAyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBGRExheW91dEVkZ2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApLkZETGF5b3V0RWRnZTtcblxuZnVuY3Rpb24gQ29TRUVkZ2Uoc291cmNlLCB0YXJnZXQsIHZFZGdlKSB7XG4gIEZETGF5b3V0RWRnZS5jYWxsKHRoaXMsIHNvdXJjZSwgdGFyZ2V0LCB2RWRnZSk7XG59XG5cbkNvU0VFZGdlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRkRMYXlvdXRFZGdlLnByb3RvdHlwZSk7XG5mb3IgKHZhciBwcm9wIGluIEZETGF5b3V0RWRnZSkge1xuICBDb1NFRWRnZVtwcm9wXSA9IEZETGF5b3V0RWRnZVtwcm9wXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBDb1NFRWRnZTtcblxuLyoqKi8gfSksXG4vKiAzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBMR3JhcGggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApLkxHcmFwaDtcblxuZnVuY3Rpb24gQ29TRUdyYXBoKHBhcmVudCwgZ3JhcGhNZ3IsIHZHcmFwaCkge1xuICBMR3JhcGguY2FsbCh0aGlzLCBwYXJlbnQsIGdyYXBoTWdyLCB2R3JhcGgpO1xufVxuXG5Db1NFR3JhcGgucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShMR3JhcGgucHJvdG90eXBlKTtcbmZvciAodmFyIHByb3AgaW4gTEdyYXBoKSB7XG4gIENvU0VHcmFwaFtwcm9wXSA9IExHcmFwaFtwcm9wXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBDb1NFR3JhcGg7XG5cbi8qKiovIH0pLFxuLyogNCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgTEdyYXBoTWFuYWdlciA9IF9fd2VicGFja19yZXF1aXJlX18oMCkuTEdyYXBoTWFuYWdlcjtcblxuZnVuY3Rpb24gQ29TRUdyYXBoTWFuYWdlcihsYXlvdXQpIHtcbiAgTEdyYXBoTWFuYWdlci5jYWxsKHRoaXMsIGxheW91dCk7XG59XG5cbkNvU0VHcmFwaE1hbmFnZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShMR3JhcGhNYW5hZ2VyLnByb3RvdHlwZSk7XG5mb3IgKHZhciBwcm9wIGluIExHcmFwaE1hbmFnZXIpIHtcbiAgQ29TRUdyYXBoTWFuYWdlcltwcm9wXSA9IExHcmFwaE1hbmFnZXJbcHJvcF07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQ29TRUdyYXBoTWFuYWdlcjtcblxuLyoqKi8gfSksXG4vKiA1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBGRExheW91dE5vZGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApLkZETGF5b3V0Tm9kZTtcbnZhciBJTWF0aCA9IF9fd2VicGFja19yZXF1aXJlX18oMCkuSU1hdGg7XG5cbmZ1bmN0aW9uIENvU0VOb2RlKGdtLCBsb2MsIHNpemUsIHZOb2RlKSB7XG4gIEZETGF5b3V0Tm9kZS5jYWxsKHRoaXMsIGdtLCBsb2MsIHNpemUsIHZOb2RlKTtcbn1cblxuQ29TRU5vZGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShGRExheW91dE5vZGUucHJvdG90eXBlKTtcbmZvciAodmFyIHByb3AgaW4gRkRMYXlvdXROb2RlKSB7XG4gIENvU0VOb2RlW3Byb3BdID0gRkRMYXlvdXROb2RlW3Byb3BdO1xufVxuXG5Db1NFTm9kZS5wcm90b3R5cGUubW92ZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGxheW91dCA9IHRoaXMuZ3JhcGhNYW5hZ2VyLmdldExheW91dCgpO1xuICB0aGlzLmRpc3BsYWNlbWVudFggPSBsYXlvdXQuY29vbGluZ0ZhY3RvciAqICh0aGlzLnNwcmluZ0ZvcmNlWCArIHRoaXMucmVwdWxzaW9uRm9yY2VYICsgdGhpcy5ncmF2aXRhdGlvbkZvcmNlWCkgLyB0aGlzLm5vT2ZDaGlsZHJlbjtcbiAgdGhpcy5kaXNwbGFjZW1lbnRZID0gbGF5b3V0LmNvb2xpbmdGYWN0b3IgKiAodGhpcy5zcHJpbmdGb3JjZVkgKyB0aGlzLnJlcHVsc2lvbkZvcmNlWSArIHRoaXMuZ3Jhdml0YXRpb25Gb3JjZVkpIC8gdGhpcy5ub09mQ2hpbGRyZW47XG5cbiAgaWYgKE1hdGguYWJzKHRoaXMuZGlzcGxhY2VtZW50WCkgPiBsYXlvdXQuY29vbGluZ0ZhY3RvciAqIGxheW91dC5tYXhOb2RlRGlzcGxhY2VtZW50KSB7XG4gICAgdGhpcy5kaXNwbGFjZW1lbnRYID0gbGF5b3V0LmNvb2xpbmdGYWN0b3IgKiBsYXlvdXQubWF4Tm9kZURpc3BsYWNlbWVudCAqIElNYXRoLnNpZ24odGhpcy5kaXNwbGFjZW1lbnRYKTtcbiAgfVxuXG4gIGlmIChNYXRoLmFicyh0aGlzLmRpc3BsYWNlbWVudFkpID4gbGF5b3V0LmNvb2xpbmdGYWN0b3IgKiBsYXlvdXQubWF4Tm9kZURpc3BsYWNlbWVudCkge1xuICAgIHRoaXMuZGlzcGxhY2VtZW50WSA9IGxheW91dC5jb29saW5nRmFjdG9yICogbGF5b3V0Lm1heE5vZGVEaXNwbGFjZW1lbnQgKiBJTWF0aC5zaWduKHRoaXMuZGlzcGxhY2VtZW50WSk7XG4gIH1cblxuICAvLyBhIHNpbXBsZSBub2RlLCBqdXN0IG1vdmUgaXRcbiAgaWYgKHRoaXMuY2hpbGQgPT0gbnVsbCkge1xuICAgIHRoaXMubW92ZUJ5KHRoaXMuZGlzcGxhY2VtZW50WCwgdGhpcy5kaXNwbGFjZW1lbnRZKTtcbiAgfVxuICAvLyBhbiBlbXB0eSBjb21wb3VuZCBub2RlLCBhZ2FpbiBqdXN0IG1vdmUgaXRcbiAgZWxzZSBpZiAodGhpcy5jaGlsZC5nZXROb2RlcygpLmxlbmd0aCA9PSAwKSB7XG4gICAgICB0aGlzLm1vdmVCeSh0aGlzLmRpc3BsYWNlbWVudFgsIHRoaXMuZGlzcGxhY2VtZW50WSk7XG4gICAgfVxuICAgIC8vIG5vbi1lbXB0eSBjb21wb3VuZCBub2RlLCBwcm9wb2dhdGUgbW92ZW1lbnQgdG8gY2hpbGRyZW4gYXMgd2VsbFxuICAgIGVsc2Uge1xuICAgICAgICB0aGlzLnByb3BvZ2F0ZURpc3BsYWNlbWVudFRvQ2hpbGRyZW4odGhpcy5kaXNwbGFjZW1lbnRYLCB0aGlzLmRpc3BsYWNlbWVudFkpO1xuICAgICAgfVxuXG4gIGxheW91dC50b3RhbERpc3BsYWNlbWVudCArPSBNYXRoLmFicyh0aGlzLmRpc3BsYWNlbWVudFgpICsgTWF0aC5hYnModGhpcy5kaXNwbGFjZW1lbnRZKTtcblxuICB0aGlzLnNwcmluZ0ZvcmNlWCA9IDA7XG4gIHRoaXMuc3ByaW5nRm9yY2VZID0gMDtcbiAgdGhpcy5yZXB1bHNpb25Gb3JjZVggPSAwO1xuICB0aGlzLnJlcHVsc2lvbkZvcmNlWSA9IDA7XG4gIHRoaXMuZ3Jhdml0YXRpb25Gb3JjZVggPSAwO1xuICB0aGlzLmdyYXZpdGF0aW9uRm9yY2VZID0gMDtcbiAgdGhpcy5kaXNwbGFjZW1lbnRYID0gMDtcbiAgdGhpcy5kaXNwbGFjZW1lbnRZID0gMDtcbn07XG5cbkNvU0VOb2RlLnByb3RvdHlwZS5wcm9wb2dhdGVEaXNwbGFjZW1lbnRUb0NoaWxkcmVuID0gZnVuY3Rpb24gKGRYLCBkWSkge1xuICB2YXIgbm9kZXMgPSB0aGlzLmdldENoaWxkKCkuZ2V0Tm9kZXMoKTtcbiAgdmFyIG5vZGU7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICBub2RlID0gbm9kZXNbaV07XG4gICAgaWYgKG5vZGUuZ2V0Q2hpbGQoKSA9PSBudWxsKSB7XG4gICAgICBub2RlLm1vdmVCeShkWCwgZFkpO1xuICAgICAgbm9kZS5kaXNwbGFjZW1lbnRYICs9IGRYO1xuICAgICAgbm9kZS5kaXNwbGFjZW1lbnRZICs9IGRZO1xuICAgIH0gZWxzZSB7XG4gICAgICBub2RlLnByb3BvZ2F0ZURpc3BsYWNlbWVudFRvQ2hpbGRyZW4oZFgsIGRZKTtcbiAgICB9XG4gIH1cbn07XG5cbkNvU0VOb2RlLnByb3RvdHlwZS5zZXRQcmVkMSA9IGZ1bmN0aW9uIChwcmVkMSkge1xuICB0aGlzLnByZWQxID0gcHJlZDE7XG59O1xuXG5Db1NFTm9kZS5wcm90b3R5cGUuZ2V0UHJlZDEgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBwcmVkMTtcbn07XG5cbkNvU0VOb2RlLnByb3RvdHlwZS5nZXRQcmVkMiA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHByZWQyO1xufTtcblxuQ29TRU5vZGUucHJvdG90eXBlLnNldE5leHQgPSBmdW5jdGlvbiAobmV4dCkge1xuICB0aGlzLm5leHQgPSBuZXh0O1xufTtcblxuQ29TRU5vZGUucHJvdG90eXBlLmdldE5leHQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBuZXh0O1xufTtcblxuQ29TRU5vZGUucHJvdG90eXBlLnNldFByb2Nlc3NlZCA9IGZ1bmN0aW9uIChwcm9jZXNzZWQpIHtcbiAgdGhpcy5wcm9jZXNzZWQgPSBwcm9jZXNzZWQ7XG59O1xuXG5Db1NFTm9kZS5wcm90b3R5cGUuaXNQcm9jZXNzZWQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBwcm9jZXNzZWQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvU0VOb2RlO1xuXG4vKioqLyB9KSxcbi8qIDYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIEZETGF5b3V0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKS5GRExheW91dDtcbnZhciBDb1NFR3JhcGhNYW5hZ2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcbnZhciBDb1NFR3JhcGggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xudmFyIENvU0VOb2RlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbnZhciBDb1NFRWRnZSA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG52YXIgQ29TRUNvbnN0YW50cyA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG52YXIgRkRMYXlvdXRDb25zdGFudHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApLkZETGF5b3V0Q29uc3RhbnRzO1xudmFyIExheW91dENvbnN0YW50cyA9IF9fd2VicGFja19yZXF1aXJlX18oMCkuTGF5b3V0Q29uc3RhbnRzO1xudmFyIFBvaW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKS5Qb2ludDtcbnZhciBQb2ludEQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApLlBvaW50RDtcbnZhciBMYXlvdXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApLkxheW91dDtcbnZhciBJbnRlZ2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKS5JbnRlZ2VyO1xudmFyIElHZW9tZXRyeSA9IF9fd2VicGFja19yZXF1aXJlX18oMCkuSUdlb21ldHJ5O1xudmFyIExHcmFwaCA9IF9fd2VicGFja19yZXF1aXJlX18oMCkuTEdyYXBoO1xudmFyIFRyYW5zZm9ybSA9IF9fd2VicGFja19yZXF1aXJlX18oMCkuVHJhbnNmb3JtO1xuXG5mdW5jdGlvbiBDb1NFTGF5b3V0KCkge1xuICBGRExheW91dC5jYWxsKHRoaXMpO1xuXG4gIHRoaXMudG9CZVRpbGVkID0ge307IC8vIE1lbW9yaXplIGlmIGEgbm9kZSBpcyB0byBiZSB0aWxlZCBvciBpcyB0aWxlZFxufVxuXG5Db1NFTGF5b3V0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRkRMYXlvdXQucHJvdG90eXBlKTtcblxuZm9yICh2YXIgcHJvcCBpbiBGRExheW91dCkge1xuICBDb1NFTGF5b3V0W3Byb3BdID0gRkRMYXlvdXRbcHJvcF07XG59XG5cbkNvU0VMYXlvdXQucHJvdG90eXBlLm5ld0dyYXBoTWFuYWdlciA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGdtID0gbmV3IENvU0VHcmFwaE1hbmFnZXIodGhpcyk7XG4gIHRoaXMuZ3JhcGhNYW5hZ2VyID0gZ207XG4gIHJldHVybiBnbTtcbn07XG5cbkNvU0VMYXlvdXQucHJvdG90eXBlLm5ld0dyYXBoID0gZnVuY3Rpb24gKHZHcmFwaCkge1xuICByZXR1cm4gbmV3IENvU0VHcmFwaChudWxsLCB0aGlzLmdyYXBoTWFuYWdlciwgdkdyYXBoKTtcbn07XG5cbkNvU0VMYXlvdXQucHJvdG90eXBlLm5ld05vZGUgPSBmdW5jdGlvbiAodk5vZGUpIHtcbiAgcmV0dXJuIG5ldyBDb1NFTm9kZSh0aGlzLmdyYXBoTWFuYWdlciwgdk5vZGUpO1xufTtcblxuQ29TRUxheW91dC5wcm90b3R5cGUubmV3RWRnZSA9IGZ1bmN0aW9uICh2RWRnZSkge1xuICByZXR1cm4gbmV3IENvU0VFZGdlKG51bGwsIG51bGwsIHZFZGdlKTtcbn07XG5cbkNvU0VMYXlvdXQucHJvdG90eXBlLmluaXRQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkge1xuICBGRExheW91dC5wcm90b3R5cGUuaW5pdFBhcmFtZXRlcnMuY2FsbCh0aGlzLCBhcmd1bWVudHMpO1xuICBpZiAoIXRoaXMuaXNTdWJMYXlvdXQpIHtcbiAgICBpZiAoQ29TRUNvbnN0YW50cy5ERUZBVUxUX0VER0VfTEVOR1RIIDwgMTApIHtcbiAgICAgIHRoaXMuaWRlYWxFZGdlTGVuZ3RoID0gMTA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaWRlYWxFZGdlTGVuZ3RoID0gQ29TRUNvbnN0YW50cy5ERUZBVUxUX0VER0VfTEVOR1RIO1xuICAgIH1cblxuICAgIHRoaXMudXNlU21hcnRJZGVhbEVkZ2VMZW5ndGhDYWxjdWxhdGlvbiA9IENvU0VDb25zdGFudHMuREVGQVVMVF9VU0VfU01BUlRfSURFQUxfRURHRV9MRU5HVEhfQ0FMQ1VMQVRJT047XG4gICAgdGhpcy5zcHJpbmdDb25zdGFudCA9IEZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfU1BSSU5HX1NUUkVOR1RIO1xuICAgIHRoaXMucmVwdWxzaW9uQ29uc3RhbnQgPSBGRExheW91dENvbnN0YW50cy5ERUZBVUxUX1JFUFVMU0lPTl9TVFJFTkdUSDtcbiAgICB0aGlzLmdyYXZpdHlDb25zdGFudCA9IEZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfR1JBVklUWV9TVFJFTkdUSDtcbiAgICB0aGlzLmNvbXBvdW5kR3Jhdml0eUNvbnN0YW50ID0gRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9DT01QT1VORF9HUkFWSVRZX1NUUkVOR1RIO1xuICAgIHRoaXMuZ3Jhdml0eVJhbmdlRmFjdG9yID0gRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9HUkFWSVRZX1JBTkdFX0ZBQ1RPUjtcbiAgICB0aGlzLmNvbXBvdW5kR3Jhdml0eVJhbmdlRmFjdG9yID0gRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9DT01QT1VORF9HUkFWSVRZX1JBTkdFX0ZBQ1RPUjtcblxuICAgIC8vIHZhcmlhYmxlcyBmb3IgdHJlZSByZWR1Y3Rpb24gc3VwcG9ydFxuICAgIHRoaXMucHJ1bmVkTm9kZXNBbGwgPSBbXTtcbiAgICB0aGlzLmdyb3dUcmVlSXRlcmF0aW9ucyA9IDA7XG4gICAgdGhpcy5hZnRlckdyb3d0aEl0ZXJhdGlvbnMgPSAwO1xuICAgIHRoaXMuaXNUcmVlR3Jvd2luZyA9IGZhbHNlO1xuICAgIHRoaXMuaXNHcm93dGhGaW5pc2hlZCA9IGZhbHNlO1xuXG4gICAgLy8gdmFyaWFibGVzIGZvciBjb29saW5nXG4gICAgdGhpcy5jb29saW5nQ3ljbGUgPSAwO1xuICAgIHRoaXMubWF4Q29vbGluZ0N5Y2xlID0gdGhpcy5tYXhJdGVyYXRpb25zIC8gRkRMYXlvdXRDb25zdGFudHMuQ09OVkVSR0VOQ0VfQ0hFQ0tfUEVSSU9EO1xuICAgIHRoaXMuZmluYWxUZW1wZXJhdHVyZSA9IEZETGF5b3V0Q29uc3RhbnRzLkNPTlZFUkdFTkNFX0NIRUNLX1BFUklPRCAvIHRoaXMubWF4SXRlcmF0aW9ucztcbiAgICB0aGlzLmNvb2xpbmdBZGp1c3RlciA9IDE7XG4gIH1cbn07XG5cbkNvU0VMYXlvdXQucHJvdG90eXBlLmxheW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGNyZWF0ZUJlbmRzQXNOZWVkZWQgPSBMYXlvdXRDb25zdGFudHMuREVGQVVMVF9DUkVBVEVfQkVORFNfQVNfTkVFREVEO1xuICBpZiAoY3JlYXRlQmVuZHNBc05lZWRlZCkge1xuICAgIHRoaXMuY3JlYXRlQmVuZHBvaW50cygpO1xuICAgIHRoaXMuZ3JhcGhNYW5hZ2VyLnJlc2V0QWxsRWRnZXMoKTtcbiAgfVxuXG4gIHRoaXMubGV2ZWwgPSAwO1xuICByZXR1cm4gdGhpcy5jbGFzc2ljTGF5b3V0KCk7XG59O1xuXG5Db1NFTGF5b3V0LnByb3RvdHlwZS5jbGFzc2ljTGF5b3V0ID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLm5vZGVzV2l0aEdyYXZpdHkgPSB0aGlzLmNhbGN1bGF0ZU5vZGVzVG9BcHBseUdyYXZpdGF0aW9uVG8oKTtcbiAgdGhpcy5ncmFwaE1hbmFnZXIuc2V0QWxsTm9kZXNUb0FwcGx5R3Jhdml0YXRpb24odGhpcy5ub2Rlc1dpdGhHcmF2aXR5KTtcbiAgdGhpcy5jYWxjTm9PZkNoaWxkcmVuRm9yQWxsTm9kZXMoKTtcbiAgdGhpcy5ncmFwaE1hbmFnZXIuY2FsY0xvd2VzdENvbW1vbkFuY2VzdG9ycygpO1xuICB0aGlzLmdyYXBoTWFuYWdlci5jYWxjSW5jbHVzaW9uVHJlZURlcHRocygpO1xuICB0aGlzLmdyYXBoTWFuYWdlci5nZXRSb290KCkuY2FsY0VzdGltYXRlZFNpemUoKTtcbiAgdGhpcy5jYWxjSWRlYWxFZGdlTGVuZ3RocygpO1xuXG4gIGlmICghdGhpcy5pbmNyZW1lbnRhbCkge1xuICAgIHZhciBmb3Jlc3QgPSB0aGlzLmdldEZsYXRGb3Jlc3QoKTtcblxuICAgIC8vIFRoZSBncmFwaCBhc3NvY2lhdGVkIHdpdGggdGhpcyBsYXlvdXQgaXMgZmxhdCBhbmQgYSBmb3Jlc3RcbiAgICBpZiAoZm9yZXN0Lmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMucG9zaXRpb25Ob2Rlc1JhZGlhbGx5KGZvcmVzdCk7XG4gICAgfVxuICAgIC8vIFRoZSBncmFwaCBhc3NvY2lhdGVkIHdpdGggdGhpcyBsYXlvdXQgaXMgbm90IGZsYXQgb3IgYSBmb3Jlc3RcbiAgICBlbHNlIHtcbiAgICAgICAgLy8gUmVkdWNlIHRoZSB0cmVlcyB3aGVuIGluY3JlbWVudGFsIG1vZGUgaXMgbm90IGVuYWJsZWQgYW5kIGdyYXBoIGlzIG5vdCBhIGZvcmVzdCBcbiAgICAgICAgdGhpcy5yZWR1Y2VUcmVlcygpO1xuICAgICAgICAvLyBVcGRhdGUgbm9kZXMgdGhhdCBncmF2aXR5IHdpbGwgYmUgYXBwbGllZFxuICAgICAgICB0aGlzLmdyYXBoTWFuYWdlci5yZXNldEFsbE5vZGVzVG9BcHBseUdyYXZpdGF0aW9uKCk7XG4gICAgICAgIHZhciBhbGxOb2RlcyA9IG5ldyBTZXQodGhpcy5nZXRBbGxOb2RlcygpKTtcbiAgICAgICAgdmFyIGludGVyc2VjdGlvbiA9IHRoaXMubm9kZXNXaXRoR3Jhdml0eS5maWx0ZXIoZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICByZXR1cm4gYWxsTm9kZXMuaGFzKHgpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5ncmFwaE1hbmFnZXIuc2V0QWxsTm9kZXNUb0FwcGx5R3Jhdml0YXRpb24oaW50ZXJzZWN0aW9uKTtcblxuICAgICAgICB0aGlzLnBvc2l0aW9uTm9kZXNSYW5kb21seSgpO1xuICAgICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChDb1NFQ29uc3RhbnRzLlRSRUVfUkVEVUNUSU9OX09OX0lOQ1JFTUVOVEFMKSB7XG4gICAgICAvLyBSZWR1Y2UgdGhlIHRyZWVzIGluIGluY3JlbWVudGFsIG1vZGUgaWYgb25seSB0aGlzIGNvbnN0YW50IGlzIHNldCB0byB0cnVlIFxuICAgICAgdGhpcy5yZWR1Y2VUcmVlcygpO1xuICAgICAgLy8gVXBkYXRlIG5vZGVzIHRoYXQgZ3Jhdml0eSB3aWxsIGJlIGFwcGxpZWRcbiAgICAgIHRoaXMuZ3JhcGhNYW5hZ2VyLnJlc2V0QWxsTm9kZXNUb0FwcGx5R3Jhdml0YXRpb24oKTtcbiAgICAgIHZhciBhbGxOb2RlcyA9IG5ldyBTZXQodGhpcy5nZXRBbGxOb2RlcygpKTtcbiAgICAgIHZhciBpbnRlcnNlY3Rpb24gPSB0aGlzLm5vZGVzV2l0aEdyYXZpdHkuZmlsdGVyKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHJldHVybiBhbGxOb2Rlcy5oYXMoeCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuZ3JhcGhNYW5hZ2VyLnNldEFsbE5vZGVzVG9BcHBseUdyYXZpdGF0aW9uKGludGVyc2VjdGlvbik7XG4gICAgfVxuICB9XG5cbiAgdGhpcy5pbml0U3ByaW5nRW1iZWRkZXIoKTtcbiAgdGhpcy5ydW5TcHJpbmdFbWJlZGRlcigpO1xuXG4gIHJldHVybiB0cnVlO1xufTtcblxuQ29TRUxheW91dC5wcm90b3R5cGUudGljayA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy50b3RhbEl0ZXJhdGlvbnMrKztcblxuICBpZiAodGhpcy50b3RhbEl0ZXJhdGlvbnMgPT09IHRoaXMubWF4SXRlcmF0aW9ucyAmJiAhdGhpcy5pc1RyZWVHcm93aW5nICYmICF0aGlzLmlzR3Jvd3RoRmluaXNoZWQpIHtcbiAgICBpZiAodGhpcy5wcnVuZWROb2Rlc0FsbC5sZW5ndGggPiAwKSB7XG4gICAgICB0aGlzLmlzVHJlZUdyb3dpbmcgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBpZiAodGhpcy50b3RhbEl0ZXJhdGlvbnMgJSBGRExheW91dENvbnN0YW50cy5DT05WRVJHRU5DRV9DSEVDS19QRVJJT0QgPT0gMCAmJiAhdGhpcy5pc1RyZWVHcm93aW5nICYmICF0aGlzLmlzR3Jvd3RoRmluaXNoZWQpIHtcbiAgICBpZiAodGhpcy5pc0NvbnZlcmdlZCgpKSB7XG4gICAgICBpZiAodGhpcy5wcnVuZWROb2Rlc0FsbC5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRoaXMuaXNUcmVlR3Jvd2luZyA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmNvb2xpbmdDeWNsZSsrO1xuXG4gICAgaWYgKHRoaXMubGF5b3V0UXVhbGl0eSA9PSAwKSB7XG4gICAgICAvLyBxdWFsaXR5IC0gXCJkcmFmdFwiXG4gICAgICB0aGlzLmNvb2xpbmdBZGp1c3RlciA9IHRoaXMuY29vbGluZ0N5Y2xlO1xuICAgIH0gZWxzZSBpZiAodGhpcy5sYXlvdXRRdWFsaXR5ID09IDEpIHtcbiAgICAgIC8vIHF1YWxpdHkgLSBcImRlZmF1bHRcIlxuICAgICAgdGhpcy5jb29saW5nQWRqdXN0ZXIgPSB0aGlzLmNvb2xpbmdDeWNsZSAvIDM7XG4gICAgfVxuXG4gICAgLy8gY29vbGluZyBzY2hlZHVsZSBpcyBiYXNlZCBvbiBodHRwOi8vd3d3LmJ0bHVrZS5jb20vc2ltYW5mMS5odG1sIC0+IGNvb2xpbmcgc2NoZWR1bGUgM1xuICAgIHRoaXMuY29vbGluZ0ZhY3RvciA9IE1hdGgubWF4KHRoaXMuaW5pdGlhbENvb2xpbmdGYWN0b3IgLSBNYXRoLnBvdyh0aGlzLmNvb2xpbmdDeWNsZSwgTWF0aC5sb2coMTAwICogKHRoaXMuaW5pdGlhbENvb2xpbmdGYWN0b3IgLSB0aGlzLmZpbmFsVGVtcGVyYXR1cmUpKSAvIE1hdGgubG9nKHRoaXMubWF4Q29vbGluZ0N5Y2xlKSkgLyAxMDAgKiB0aGlzLmNvb2xpbmdBZGp1c3RlciwgdGhpcy5maW5hbFRlbXBlcmF0dXJlKTtcbiAgICB0aGlzLmFuaW1hdGlvblBlcmlvZCA9IE1hdGguY2VpbCh0aGlzLmluaXRpYWxBbmltYXRpb25QZXJpb2QgKiBNYXRoLnNxcnQodGhpcy5jb29saW5nRmFjdG9yKSk7XG4gIH1cbiAgLy8gT3BlcmF0aW9ucyB3aGlsZSB0cmVlIGlzIGdyb3dpbmcgYWdhaW4gXG4gIGlmICh0aGlzLmlzVHJlZUdyb3dpbmcpIHtcbiAgICBpZiAodGhpcy5ncm93VHJlZUl0ZXJhdGlvbnMgJSAxMCA9PSAwKSB7XG4gICAgICBpZiAodGhpcy5wcnVuZWROb2Rlc0FsbC5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRoaXMuZ3JhcGhNYW5hZ2VyLnVwZGF0ZUJvdW5kcygpO1xuICAgICAgICB0aGlzLnVwZGF0ZUdyaWQoKTtcbiAgICAgICAgdGhpcy5ncm93VHJlZSh0aGlzLnBydW5lZE5vZGVzQWxsKTtcbiAgICAgICAgLy8gVXBkYXRlIG5vZGVzIHRoYXQgZ3Jhdml0eSB3aWxsIGJlIGFwcGxpZWRcbiAgICAgICAgdGhpcy5ncmFwaE1hbmFnZXIucmVzZXRBbGxOb2Rlc1RvQXBwbHlHcmF2aXRhdGlvbigpO1xuICAgICAgICB2YXIgYWxsTm9kZXMgPSBuZXcgU2V0KHRoaXMuZ2V0QWxsTm9kZXMoKSk7XG4gICAgICAgIHZhciBpbnRlcnNlY3Rpb24gPSB0aGlzLm5vZGVzV2l0aEdyYXZpdHkuZmlsdGVyKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgcmV0dXJuIGFsbE5vZGVzLmhhcyh4KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZ3JhcGhNYW5hZ2VyLnNldEFsbE5vZGVzVG9BcHBseUdyYXZpdGF0aW9uKGludGVyc2VjdGlvbik7XG5cbiAgICAgICAgdGhpcy5ncmFwaE1hbmFnZXIudXBkYXRlQm91bmRzKCk7XG4gICAgICAgIHRoaXMudXBkYXRlR3JpZCgpO1xuICAgICAgICB0aGlzLmNvb2xpbmdGYWN0b3IgPSBGRExheW91dENvbnN0YW50cy5ERUZBVUxUX0NPT0xJTkdfRkFDVE9SX0lOQ1JFTUVOVEFMO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5pc1RyZWVHcm93aW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaXNHcm93dGhGaW5pc2hlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuZ3Jvd1RyZWVJdGVyYXRpb25zKys7XG4gIH1cbiAgLy8gT3BlcmF0aW9ucyBhZnRlciBncm93dGggaXMgZmluaXNoZWRcbiAgaWYgKHRoaXMuaXNHcm93dGhGaW5pc2hlZCkge1xuICAgIGlmICh0aGlzLmlzQ29udmVyZ2VkKCkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAodGhpcy5hZnRlckdyb3d0aEl0ZXJhdGlvbnMgJSAxMCA9PSAwKSB7XG4gICAgICB0aGlzLmdyYXBoTWFuYWdlci51cGRhdGVCb3VuZHMoKTtcbiAgICAgIHRoaXMudXBkYXRlR3JpZCgpO1xuICAgIH1cbiAgICB0aGlzLmNvb2xpbmdGYWN0b3IgPSBGRExheW91dENvbnN0YW50cy5ERUZBVUxUX0NPT0xJTkdfRkFDVE9SX0lOQ1JFTUVOVEFMICogKCgxMDAgLSB0aGlzLmFmdGVyR3Jvd3RoSXRlcmF0aW9ucykgLyAxMDApO1xuICAgIHRoaXMuYWZ0ZXJHcm93dGhJdGVyYXRpb25zKys7XG4gIH1cblxuICB2YXIgZ3JpZFVwZGF0ZUFsbG93ZWQgPSAhdGhpcy5pc1RyZWVHcm93aW5nICYmICF0aGlzLmlzR3Jvd3RoRmluaXNoZWQ7XG4gIHZhciBmb3JjZVRvTm9kZVN1cnJvdW5kaW5nVXBkYXRlID0gdGhpcy5ncm93VHJlZUl0ZXJhdGlvbnMgJSAxMCA9PSAxICYmIHRoaXMuaXNUcmVlR3Jvd2luZyB8fCB0aGlzLmFmdGVyR3Jvd3RoSXRlcmF0aW9ucyAlIDEwID09IDEgJiYgdGhpcy5pc0dyb3d0aEZpbmlzaGVkO1xuXG4gIHRoaXMudG90YWxEaXNwbGFjZW1lbnQgPSAwO1xuICB0aGlzLmdyYXBoTWFuYWdlci51cGRhdGVCb3VuZHMoKTtcbiAgdGhpcy5jYWxjU3ByaW5nRm9yY2VzKCk7XG4gIHRoaXMuY2FsY1JlcHVsc2lvbkZvcmNlcyhncmlkVXBkYXRlQWxsb3dlZCwgZm9yY2VUb05vZGVTdXJyb3VuZGluZ1VwZGF0ZSk7XG4gIHRoaXMuY2FsY0dyYXZpdGF0aW9uYWxGb3JjZXMoKTtcbiAgdGhpcy5tb3ZlTm9kZXMoKTtcbiAgdGhpcy5hbmltYXRlKCk7XG5cbiAgcmV0dXJuIGZhbHNlOyAvLyBMYXlvdXQgaXMgbm90IGVuZGVkIHlldCByZXR1cm4gZmFsc2Vcbn07XG5cbkNvU0VMYXlvdXQucHJvdG90eXBlLmdldFBvc2l0aW9uc0RhdGEgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBhbGxOb2RlcyA9IHRoaXMuZ3JhcGhNYW5hZ2VyLmdldEFsbE5vZGVzKCk7XG4gIHZhciBwRGF0YSA9IHt9O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFsbE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHJlY3QgPSBhbGxOb2Rlc1tpXS5yZWN0O1xuICAgIHZhciBpZCA9IGFsbE5vZGVzW2ldLmlkO1xuICAgIHBEYXRhW2lkXSA9IHtcbiAgICAgIGlkOiBpZCxcbiAgICAgIHg6IHJlY3QuZ2V0Q2VudGVyWCgpLFxuICAgICAgeTogcmVjdC5nZXRDZW50ZXJZKCksXG4gICAgICB3OiByZWN0LndpZHRoLFxuICAgICAgaDogcmVjdC5oZWlnaHRcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHBEYXRhO1xufTtcblxuQ29TRUxheW91dC5wcm90b3R5cGUucnVuU3ByaW5nRW1iZWRkZXIgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuaW5pdGlhbEFuaW1hdGlvblBlcmlvZCA9IDI1O1xuICB0aGlzLmFuaW1hdGlvblBlcmlvZCA9IHRoaXMuaW5pdGlhbEFuaW1hdGlvblBlcmlvZDtcbiAgdmFyIGxheW91dEVuZGVkID0gZmFsc2U7XG5cbiAgLy8gSWYgYW1pbmF0ZSBvcHRpb24gaXMgJ2R1cmluZycgc2lnbmFsIHRoYXQgbGF5b3V0IGlzIHN1cHBvc2VkIHRvIHN0YXJ0IGl0ZXJhdGluZ1xuICBpZiAoRkRMYXlvdXRDb25zdGFudHMuQU5JTUFURSA9PT0gJ2R1cmluZycpIHtcbiAgICB0aGlzLmVtaXQoJ2xheW91dHN0YXJ0ZWQnKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBJZiBhbWluYXRlIG9wdGlvbiBpcyAnZHVyaW5nJyB0aWNrKCkgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgb24gaW5kZXguanNcbiAgICB3aGlsZSAoIWxheW91dEVuZGVkKSB7XG4gICAgICBsYXlvdXRFbmRlZCA9IHRoaXMudGljaygpO1xuICAgIH1cblxuICAgIHRoaXMuZ3JhcGhNYW5hZ2VyLnVwZGF0ZUJvdW5kcygpO1xuICB9XG59O1xuXG5Db1NFTGF5b3V0LnByb3RvdHlwZS5jYWxjdWxhdGVOb2Rlc1RvQXBwbHlHcmF2aXRhdGlvblRvID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbm9kZUxpc3QgPSBbXTtcbiAgdmFyIGdyYXBoO1xuXG4gIHZhciBncmFwaHMgPSB0aGlzLmdyYXBoTWFuYWdlci5nZXRHcmFwaHMoKTtcbiAgdmFyIHNpemUgPSBncmFwaHMubGVuZ3RoO1xuICB2YXIgaTtcbiAgZm9yIChpID0gMDsgaSA8IHNpemU7IGkrKykge1xuICAgIGdyYXBoID0gZ3JhcGhzW2ldO1xuXG4gICAgZ3JhcGgudXBkYXRlQ29ubmVjdGVkKCk7XG5cbiAgICBpZiAoIWdyYXBoLmlzQ29ubmVjdGVkKSB7XG4gICAgICBub2RlTGlzdCA9IG5vZGVMaXN0LmNvbmNhdChncmFwaC5nZXROb2RlcygpKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbm9kZUxpc3Q7XG59O1xuXG5Db1NFTGF5b3V0LnByb3RvdHlwZS5jcmVhdGVCZW5kcG9pbnRzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgZWRnZXMgPSBbXTtcbiAgZWRnZXMgPSBlZGdlcy5jb25jYXQodGhpcy5ncmFwaE1hbmFnZXIuZ2V0QWxsRWRnZXMoKSk7XG4gIHZhciB2aXNpdGVkID0gbmV3IFNldCgpO1xuICB2YXIgaTtcbiAgZm9yIChpID0gMDsgaSA8IGVkZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGVkZ2UgPSBlZGdlc1tpXTtcblxuICAgIGlmICghdmlzaXRlZC5oYXMoZWRnZSkpIHtcbiAgICAgIHZhciBzb3VyY2UgPSBlZGdlLmdldFNvdXJjZSgpO1xuICAgICAgdmFyIHRhcmdldCA9IGVkZ2UuZ2V0VGFyZ2V0KCk7XG5cbiAgICAgIGlmIChzb3VyY2UgPT0gdGFyZ2V0KSB7XG4gICAgICAgIGVkZ2UuZ2V0QmVuZHBvaW50cygpLnB1c2gobmV3IFBvaW50RCgpKTtcbiAgICAgICAgZWRnZS5nZXRCZW5kcG9pbnRzKCkucHVzaChuZXcgUG9pbnREKCkpO1xuICAgICAgICB0aGlzLmNyZWF0ZUR1bW15Tm9kZXNGb3JCZW5kcG9pbnRzKGVkZ2UpO1xuICAgICAgICB2aXNpdGVkLmFkZChlZGdlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBlZGdlTGlzdCA9IFtdO1xuXG4gICAgICAgIGVkZ2VMaXN0ID0gZWRnZUxpc3QuY29uY2F0KHNvdXJjZS5nZXRFZGdlTGlzdFRvTm9kZSh0YXJnZXQpKTtcbiAgICAgICAgZWRnZUxpc3QgPSBlZGdlTGlzdC5jb25jYXQodGFyZ2V0LmdldEVkZ2VMaXN0VG9Ob2RlKHNvdXJjZSkpO1xuXG4gICAgICAgIGlmICghdmlzaXRlZC5oYXMoZWRnZUxpc3RbMF0pKSB7XG4gICAgICAgICAgaWYgKGVkZ2VMaXN0Lmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHZhciBrO1xuICAgICAgICAgICAgZm9yIChrID0gMDsgayA8IGVkZ2VMaXN0Lmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICAgIHZhciBtdWx0aUVkZ2UgPSBlZGdlTGlzdFtrXTtcbiAgICAgICAgICAgICAgbXVsdGlFZGdlLmdldEJlbmRwb2ludHMoKS5wdXNoKG5ldyBQb2ludEQoKSk7XG4gICAgICAgICAgICAgIHRoaXMuY3JlYXRlRHVtbXlOb2Rlc0ZvckJlbmRwb2ludHMobXVsdGlFZGdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZWRnZUxpc3QuZm9yRWFjaChmdW5jdGlvbiAoZWRnZSkge1xuICAgICAgICAgICAgdmlzaXRlZC5hZGQoZWRnZSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodmlzaXRlZC5zaXplID09IGVkZ2VzLmxlbmd0aCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG59O1xuXG5Db1NFTGF5b3V0LnByb3RvdHlwZS5wb3NpdGlvbk5vZGVzUmFkaWFsbHkgPSBmdW5jdGlvbiAoZm9yZXN0KSB7XG4gIC8vIFdlIHRpbGUgdGhlIHRyZWVzIHRvIGEgZ3JpZCByb3cgYnkgcm93OyBmaXJzdCB0cmVlIHN0YXJ0cyBhdCAoMCwwKVxuICB2YXIgY3VycmVudFN0YXJ0aW5nUG9pbnQgPSBuZXcgUG9pbnQoMCwgMCk7XG4gIHZhciBudW1iZXJPZkNvbHVtbnMgPSBNYXRoLmNlaWwoTWF0aC5zcXJ0KGZvcmVzdC5sZW5ndGgpKTtcbiAgdmFyIGhlaWdodCA9IDA7XG4gIHZhciBjdXJyZW50WSA9IDA7XG4gIHZhciBjdXJyZW50WCA9IDA7XG4gIHZhciBwb2ludCA9IG5ldyBQb2ludEQoMCwgMCk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBmb3Jlc3QubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoaSAlIG51bWJlck9mQ29sdW1ucyA9PSAwKSB7XG4gICAgICAvLyBTdGFydCBvZiBhIG5ldyByb3csIG1ha2UgdGhlIHggY29vcmRpbmF0ZSAwLCBpbmNyZW1lbnQgdGhlXG4gICAgICAvLyB5IGNvb3JkaW5hdGUgd2l0aCB0aGUgbWF4IGhlaWdodCBvZiB0aGUgcHJldmlvdXMgcm93XG4gICAgICBjdXJyZW50WCA9IDA7XG4gICAgICBjdXJyZW50WSA9IGhlaWdodDtcblxuICAgICAgaWYgKGkgIT0gMCkge1xuICAgICAgICBjdXJyZW50WSArPSBDb1NFQ29uc3RhbnRzLkRFRkFVTFRfQ09NUE9ORU5UX1NFUEVSQVRJT047XG4gICAgICB9XG5cbiAgICAgIGhlaWdodCA9IDA7XG4gICAgfVxuXG4gICAgdmFyIHRyZWUgPSBmb3Jlc3RbaV07XG5cbiAgICAvLyBGaW5kIHRoZSBjZW50ZXIgb2YgdGhlIHRyZWVcbiAgICB2YXIgY2VudGVyTm9kZSA9IExheW91dC5maW5kQ2VudGVyT2ZUcmVlKHRyZWUpO1xuXG4gICAgLy8gU2V0IHRoZSBzdGFyaW5nIHBvaW50IG9mIHRoZSBuZXh0IHRyZWVcbiAgICBjdXJyZW50U3RhcnRpbmdQb2ludC54ID0gY3VycmVudFg7XG4gICAgY3VycmVudFN0YXJ0aW5nUG9pbnQueSA9IGN1cnJlbnRZO1xuXG4gICAgLy8gRG8gYSByYWRpYWwgbGF5b3V0IHN0YXJ0aW5nIHdpdGggdGhlIGNlbnRlclxuICAgIHBvaW50ID0gQ29TRUxheW91dC5yYWRpYWxMYXlvdXQodHJlZSwgY2VudGVyTm9kZSwgY3VycmVudFN0YXJ0aW5nUG9pbnQpO1xuXG4gICAgaWYgKHBvaW50LnkgPiBoZWlnaHQpIHtcbiAgICAgIGhlaWdodCA9IE1hdGguZmxvb3IocG9pbnQueSk7XG4gICAgfVxuXG4gICAgY3VycmVudFggPSBNYXRoLmZsb29yKHBvaW50LnggKyBDb1NFQ29uc3RhbnRzLkRFRkFVTFRfQ09NUE9ORU5UX1NFUEVSQVRJT04pO1xuICB9XG5cbiAgdGhpcy50cmFuc2Zvcm0obmV3IFBvaW50RChMYXlvdXRDb25zdGFudHMuV09STERfQ0VOVEVSX1ggLSBwb2ludC54IC8gMiwgTGF5b3V0Q29uc3RhbnRzLldPUkxEX0NFTlRFUl9ZIC0gcG9pbnQueSAvIDIpKTtcbn07XG5cbkNvU0VMYXlvdXQucmFkaWFsTGF5b3V0ID0gZnVuY3Rpb24gKHRyZWUsIGNlbnRlck5vZGUsIHN0YXJ0aW5nUG9pbnQpIHtcbiAgdmFyIHJhZGlhbFNlcCA9IE1hdGgubWF4KHRoaXMubWF4RGlhZ29uYWxJblRyZWUodHJlZSksIENvU0VDb25zdGFudHMuREVGQVVMVF9SQURJQUxfU0VQQVJBVElPTik7XG4gIENvU0VMYXlvdXQuYnJhbmNoUmFkaWFsTGF5b3V0KGNlbnRlck5vZGUsIG51bGwsIDAsIDM1OSwgMCwgcmFkaWFsU2VwKTtcbiAgdmFyIGJvdW5kcyA9IExHcmFwaC5jYWxjdWxhdGVCb3VuZHModHJlZSk7XG5cbiAgdmFyIHRyYW5zZm9ybSA9IG5ldyBUcmFuc2Zvcm0oKTtcbiAgdHJhbnNmb3JtLnNldERldmljZU9yZ1goYm91bmRzLmdldE1pblgoKSk7XG4gIHRyYW5zZm9ybS5zZXREZXZpY2VPcmdZKGJvdW5kcy5nZXRNaW5ZKCkpO1xuICB0cmFuc2Zvcm0uc2V0V29ybGRPcmdYKHN0YXJ0aW5nUG9pbnQueCk7XG4gIHRyYW5zZm9ybS5zZXRXb3JsZE9yZ1koc3RhcnRpbmdQb2ludC55KTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRyZWUubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbm9kZSA9IHRyZWVbaV07XG4gICAgbm9kZS50cmFuc2Zvcm0odHJhbnNmb3JtKTtcbiAgfVxuXG4gIHZhciBib3R0b21SaWdodCA9IG5ldyBQb2ludEQoYm91bmRzLmdldE1heFgoKSwgYm91bmRzLmdldE1heFkoKSk7XG5cbiAgcmV0dXJuIHRyYW5zZm9ybS5pbnZlcnNlVHJhbnNmb3JtUG9pbnQoYm90dG9tUmlnaHQpO1xufTtcblxuQ29TRUxheW91dC5icmFuY2hSYWRpYWxMYXlvdXQgPSBmdW5jdGlvbiAobm9kZSwgcGFyZW50T2ZOb2RlLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgZGlzdGFuY2UsIHJhZGlhbFNlcGFyYXRpb24pIHtcbiAgLy8gRmlyc3QsIHBvc2l0aW9uIHRoaXMgbm9kZSBieSBmaW5kaW5nIGl0cyBhbmdsZS5cbiAgdmFyIGhhbGZJbnRlcnZhbCA9IChlbmRBbmdsZSAtIHN0YXJ0QW5nbGUgKyAxKSAvIDI7XG5cbiAgaWYgKGhhbGZJbnRlcnZhbCA8IDApIHtcbiAgICBoYWxmSW50ZXJ2YWwgKz0gMTgwO1xuICB9XG5cbiAgdmFyIG5vZGVBbmdsZSA9IChoYWxmSW50ZXJ2YWwgKyBzdGFydEFuZ2xlKSAlIDM2MDtcbiAgdmFyIHRldGEgPSBub2RlQW5nbGUgKiBJR2VvbWV0cnkuVFdPX1BJIC8gMzYwO1xuXG4gIC8vIE1ha2UgcG9sYXIgdG8gamF2YSBjb3JkaW5hdGUgY29udmVyc2lvbi5cbiAgdmFyIGNvc190ZXRhID0gTWF0aC5jb3ModGV0YSk7XG4gIHZhciB4XyA9IGRpc3RhbmNlICogTWF0aC5jb3ModGV0YSk7XG4gIHZhciB5XyA9IGRpc3RhbmNlICogTWF0aC5zaW4odGV0YSk7XG5cbiAgbm9kZS5zZXRDZW50ZXIoeF8sIHlfKTtcblxuICAvLyBUcmF2ZXJzZSBhbGwgbmVpZ2hib3JzIG9mIHRoaXMgbm9kZSBhbmQgcmVjdXJzaXZlbHkgY2FsbCB0aGlzXG4gIC8vIGZ1bmN0aW9uLlxuICB2YXIgbmVpZ2hib3JFZGdlcyA9IFtdO1xuICBuZWlnaGJvckVkZ2VzID0gbmVpZ2hib3JFZGdlcy5jb25jYXQobm9kZS5nZXRFZGdlcygpKTtcbiAgdmFyIGNoaWxkQ291bnQgPSBuZWlnaGJvckVkZ2VzLmxlbmd0aDtcblxuICBpZiAocGFyZW50T2ZOb2RlICE9IG51bGwpIHtcbiAgICBjaGlsZENvdW50LS07XG4gIH1cblxuICB2YXIgYnJhbmNoQ291bnQgPSAwO1xuXG4gIHZhciBpbmNFZGdlc0NvdW50ID0gbmVpZ2hib3JFZGdlcy5sZW5ndGg7XG4gIHZhciBzdGFydEluZGV4O1xuXG4gIHZhciBlZGdlcyA9IG5vZGUuZ2V0RWRnZXNCZXR3ZWVuKHBhcmVudE9mTm9kZSk7XG5cbiAgLy8gSWYgdGhlcmUgYXJlIG11bHRpcGxlIGVkZ2VzLCBwcnVuZSB0aGVtIHVudGlsIHRoZXJlIHJlbWFpbnMgb25seSBvbmVcbiAgLy8gZWRnZS5cbiAgd2hpbGUgKGVkZ2VzLmxlbmd0aCA+IDEpIHtcbiAgICAvL25laWdoYm9yRWRnZXMucmVtb3ZlKGVkZ2VzLnJlbW92ZSgwKSk7XG4gICAgdmFyIHRlbXAgPSBlZGdlc1swXTtcbiAgICBlZGdlcy5zcGxpY2UoMCwgMSk7XG4gICAgdmFyIGluZGV4ID0gbmVpZ2hib3JFZGdlcy5pbmRleE9mKHRlbXApO1xuICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICBuZWlnaGJvckVkZ2VzLnNwbGljZShpbmRleCwgMSk7XG4gICAgfVxuICAgIGluY0VkZ2VzQ291bnQtLTtcbiAgICBjaGlsZENvdW50LS07XG4gIH1cblxuICBpZiAocGFyZW50T2ZOb2RlICE9IG51bGwpIHtcbiAgICAvL2Fzc2VydCBlZGdlcy5sZW5ndGggPT0gMTtcbiAgICBzdGFydEluZGV4ID0gKG5laWdoYm9yRWRnZXMuaW5kZXhPZihlZGdlc1swXSkgKyAxKSAlIGluY0VkZ2VzQ291bnQ7XG4gIH0gZWxzZSB7XG4gICAgc3RhcnRJbmRleCA9IDA7XG4gIH1cblxuICB2YXIgc3RlcEFuZ2xlID0gTWF0aC5hYnMoZW5kQW5nbGUgLSBzdGFydEFuZ2xlKSAvIGNoaWxkQ291bnQ7XG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0SW5kZXg7IGJyYW5jaENvdW50ICE9IGNoaWxkQ291bnQ7IGkgPSArK2kgJSBpbmNFZGdlc0NvdW50KSB7XG4gICAgdmFyIGN1cnJlbnROZWlnaGJvciA9IG5laWdoYm9yRWRnZXNbaV0uZ2V0T3RoZXJFbmQobm9kZSk7XG5cbiAgICAvLyBEb24ndCBiYWNrIHRyYXZlcnNlIHRvIHJvb3Qgbm9kZSBpbiBjdXJyZW50IHRyZWUuXG4gICAgaWYgKGN1cnJlbnROZWlnaGJvciA9PSBwYXJlbnRPZk5vZGUpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHZhciBjaGlsZFN0YXJ0QW5nbGUgPSAoc3RhcnRBbmdsZSArIGJyYW5jaENvdW50ICogc3RlcEFuZ2xlKSAlIDM2MDtcbiAgICB2YXIgY2hpbGRFbmRBbmdsZSA9IChjaGlsZFN0YXJ0QW5nbGUgKyBzdGVwQW5nbGUpICUgMzYwO1xuXG4gICAgQ29TRUxheW91dC5icmFuY2hSYWRpYWxMYXlvdXQoY3VycmVudE5laWdoYm9yLCBub2RlLCBjaGlsZFN0YXJ0QW5nbGUsIGNoaWxkRW5kQW5nbGUsIGRpc3RhbmNlICsgcmFkaWFsU2VwYXJhdGlvbiwgcmFkaWFsU2VwYXJhdGlvbik7XG5cbiAgICBicmFuY2hDb3VudCsrO1xuICB9XG59O1xuXG5Db1NFTGF5b3V0Lm1heERpYWdvbmFsSW5UcmVlID0gZnVuY3Rpb24gKHRyZWUpIHtcbiAgdmFyIG1heERpYWdvbmFsID0gSW50ZWdlci5NSU5fVkFMVUU7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmVlLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG5vZGUgPSB0cmVlW2ldO1xuICAgIHZhciBkaWFnb25hbCA9IG5vZGUuZ2V0RGlhZ29uYWwoKTtcblxuICAgIGlmIChkaWFnb25hbCA+IG1heERpYWdvbmFsKSB7XG4gICAgICBtYXhEaWFnb25hbCA9IGRpYWdvbmFsO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBtYXhEaWFnb25hbDtcbn07XG5cbkNvU0VMYXlvdXQucHJvdG90eXBlLmNhbGNSZXB1bHNpb25SYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gZm9ybXVsYSBpcyAyIHggKGxldmVsICsgMSkgeCBpZGVhbEVkZ2VMZW5ndGhcbiAgcmV0dXJuIDIgKiAodGhpcy5sZXZlbCArIDEpICogdGhpcy5pZGVhbEVkZ2VMZW5ndGg7XG59O1xuXG4vLyBUaWxpbmcgbWV0aG9kc1xuXG4vLyBHcm91cCB6ZXJvIGRlZ3JlZSBtZW1iZXJzIHdob3NlIHBhcmVudHMgYXJlIG5vdCB0byBiZSB0aWxlZCwgY3JlYXRlIGR1bW15IHBhcmVudHMgd2hlcmUgbmVlZGVkIGFuZCBmaWxsIG1lbWJlckdyb3VwcyBieSB0aGVpciBkdW1tcCBwYXJlbnQgaWQnc1xuQ29TRUxheW91dC5wcm90b3R5cGUuZ3JvdXBaZXJvRGVncmVlTWVtYmVycyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICAvLyBhcnJheSBvZiBbcGFyZW50X2lkIHggb25lRGVncmVlTm9kZV9pZF1cbiAgdmFyIHRlbXBNZW1iZXJHcm91cHMgPSB7fTsgLy8gQSB0ZW1wb3JhcnkgbWFwIG9mIHBhcmVudCBub2RlIGFuZCBpdHMgemVybyBkZWdyZWUgbWVtYmVyc1xuICB0aGlzLm1lbWJlckdyb3VwcyA9IHt9OyAvLyBBIG1hcCBvZiBkdW1teSBwYXJlbnQgbm9kZSBhbmQgaXRzIHplcm8gZGVncmVlIG1lbWJlcnMgd2hvc2UgcGFyZW50cyBhcmUgbm90IHRvIGJlIHRpbGVkXG4gIHRoaXMuaWRUb0R1bW15Tm9kZSA9IHt9OyAvLyBBIG1hcCBvZiBpZCB0byBkdW1teSBub2RlIFxuXG4gIHZhciB6ZXJvRGVncmVlID0gW107IC8vIExpc3Qgb2YgemVybyBkZWdyZWUgbm9kZXMgd2hvc2UgcGFyZW50cyBhcmUgbm90IHRvIGJlIHRpbGVkXG4gIHZhciBhbGxOb2RlcyA9IHRoaXMuZ3JhcGhNYW5hZ2VyLmdldEFsbE5vZGVzKCk7XG5cbiAgLy8gRmlsbCB6ZXJvIGRlZ3JlZSBsaXN0XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYWxsTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbm9kZSA9IGFsbE5vZGVzW2ldO1xuICAgIHZhciBwYXJlbnQgPSBub2RlLmdldFBhcmVudCgpO1xuICAgIC8vIElmIGEgbm9kZSBoYXMgemVybyBkZWdyZWUgYW5kIGl0cyBwYXJlbnQgaXMgbm90IHRvIGJlIHRpbGVkIGlmIGV4aXN0cyBhZGQgdGhhdCBub2RlIHRvIHplcm9EZWdyZXMgbGlzdFxuICAgIGlmICh0aGlzLmdldE5vZGVEZWdyZWVXaXRoQ2hpbGRyZW4obm9kZSkgPT09IDAgJiYgKHBhcmVudC5pZCA9PSB1bmRlZmluZWQgfHwgIXRoaXMuZ2V0VG9CZVRpbGVkKHBhcmVudCkpKSB7XG4gICAgICB6ZXJvRGVncmVlLnB1c2gobm9kZSk7XG4gICAgfVxuICB9XG5cbiAgLy8gQ3JlYXRlIGEgbWFwIG9mIHBhcmVudCBub2RlIGFuZCBpdHMgemVybyBkZWdyZWUgbWVtYmVyc1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHplcm9EZWdyZWUubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbm9kZSA9IHplcm9EZWdyZWVbaV07IC8vIFplcm8gZGVncmVlIG5vZGUgaXRzZWxmXG4gICAgdmFyIHBfaWQgPSBub2RlLmdldFBhcmVudCgpLmlkOyAvLyBQYXJlbnQgaWRcblxuICAgIGlmICh0eXBlb2YgdGVtcE1lbWJlckdyb3Vwc1twX2lkXSA9PT0gXCJ1bmRlZmluZWRcIikgdGVtcE1lbWJlckdyb3Vwc1twX2lkXSA9IFtdO1xuXG4gICAgdGVtcE1lbWJlckdyb3Vwc1twX2lkXSA9IHRlbXBNZW1iZXJHcm91cHNbcF9pZF0uY29uY2F0KG5vZGUpOyAvLyBQdXNoIG5vZGUgdG8gdGhlIGxpc3QgYmVsb25ncyB0byBpdHMgcGFyZW50IGluIHRlbXBNZW1iZXJHcm91cHNcbiAgfVxuXG4gIC8vIElmIHRoZXJlIGFyZSBhdCBsZWFzdCB0d28gbm9kZXMgYXQgYSBsZXZlbCwgY3JlYXRlIGEgZHVtbXkgY29tcG91bmQgZm9yIHRoZW1cbiAgT2JqZWN0LmtleXModGVtcE1lbWJlckdyb3VwcykuZm9yRWFjaChmdW5jdGlvbiAocF9pZCkge1xuICAgIGlmICh0ZW1wTWVtYmVyR3JvdXBzW3BfaWRdLmxlbmd0aCA+IDEpIHtcbiAgICAgIHZhciBkdW1teUNvbXBvdW5kSWQgPSBcIkR1bW15Q29tcG91bmRfXCIgKyBwX2lkOyAvLyBUaGUgaWQgb2YgZHVtbXkgY29tcG91bmQgd2hpY2ggd2lsbCBiZSBjcmVhdGVkIHNvb25cbiAgICAgIHNlbGYubWVtYmVyR3JvdXBzW2R1bW15Q29tcG91bmRJZF0gPSB0ZW1wTWVtYmVyR3JvdXBzW3BfaWRdOyAvLyBBZGQgZHVtbXkgY29tcG91bmQgdG8gbWVtYmVyR3JvdXBzXG5cbiAgICAgIHZhciBwYXJlbnQgPSB0ZW1wTWVtYmVyR3JvdXBzW3BfaWRdWzBdLmdldFBhcmVudCgpOyAvLyBUaGUgcGFyZW50IG9mIHplcm8gZGVncmVlIG5vZGVzIHdpbGwgYmUgdGhlIHBhcmVudCBvZiBuZXcgZHVtbXkgY29tcG91bmRcblxuICAgICAgLy8gQ3JlYXRlIGEgZHVtbXkgY29tcG91bmQgd2l0aCBjYWxjdWxhdGVkIGlkXG4gICAgICB2YXIgZHVtbXlDb21wb3VuZCA9IG5ldyBDb1NFTm9kZShzZWxmLmdyYXBoTWFuYWdlcik7XG4gICAgICBkdW1teUNvbXBvdW5kLmlkID0gZHVtbXlDb21wb3VuZElkO1xuICAgICAgZHVtbXlDb21wb3VuZC5wYWRkaW5nTGVmdCA9IHBhcmVudC5wYWRkaW5nTGVmdCB8fCAwO1xuICAgICAgZHVtbXlDb21wb3VuZC5wYWRkaW5nUmlnaHQgPSBwYXJlbnQucGFkZGluZ1JpZ2h0IHx8IDA7XG4gICAgICBkdW1teUNvbXBvdW5kLnBhZGRpbmdCb3R0b20gPSBwYXJlbnQucGFkZGluZ0JvdHRvbSB8fCAwO1xuICAgICAgZHVtbXlDb21wb3VuZC5wYWRkaW5nVG9wID0gcGFyZW50LnBhZGRpbmdUb3AgfHwgMDtcblxuICAgICAgc2VsZi5pZFRvRHVtbXlOb2RlW2R1bW15Q29tcG91bmRJZF0gPSBkdW1teUNvbXBvdW5kO1xuXG4gICAgICB2YXIgZHVtbXlQYXJlbnRHcmFwaCA9IHNlbGYuZ2V0R3JhcGhNYW5hZ2VyKCkuYWRkKHNlbGYubmV3R3JhcGgoKSwgZHVtbXlDb21wb3VuZCk7XG4gICAgICB2YXIgcGFyZW50R3JhcGggPSBwYXJlbnQuZ2V0Q2hpbGQoKTtcblxuICAgICAgLy8gQWRkIGR1bW15IGNvbXBvdW5kIHRvIHBhcmVudCB0aGUgZ3JhcGhcbiAgICAgIHBhcmVudEdyYXBoLmFkZChkdW1teUNvbXBvdW5kKTtcblxuICAgICAgLy8gRm9yIGVhY2ggemVybyBkZWdyZWUgbm9kZSBpbiB0aGlzIGxldmVsIHJlbW92ZSBpdCBmcm9tIGl0cyBwYXJlbnQgZ3JhcGggYW5kIGFkZCBpdCB0byB0aGUgZ3JhcGggb2YgZHVtbXkgcGFyZW50XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRlbXBNZW1iZXJHcm91cHNbcF9pZF0ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG5vZGUgPSB0ZW1wTWVtYmVyR3JvdXBzW3BfaWRdW2ldO1xuXG4gICAgICAgIHBhcmVudEdyYXBoLnJlbW92ZShub2RlKTtcbiAgICAgICAgZHVtbXlQYXJlbnRHcmFwaC5hZGQobm9kZSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn07XG5cbkNvU0VMYXlvdXQucHJvdG90eXBlLmNsZWFyQ29tcG91bmRzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgY2hpbGRHcmFwaE1hcCA9IHt9O1xuICB2YXIgaWRUb05vZGUgPSB7fTtcblxuICAvLyBHZXQgY29tcG91bmQgb3JkZXJpbmcgYnkgZmluZGluZyB0aGUgaW5uZXIgb25lIGZpcnN0XG4gIHRoaXMucGVyZm9ybURGU09uQ29tcG91bmRzKCk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNvbXBvdW5kT3JkZXIubGVuZ3RoOyBpKyspIHtcblxuICAgIGlkVG9Ob2RlW3RoaXMuY29tcG91bmRPcmRlcltpXS5pZF0gPSB0aGlzLmNvbXBvdW5kT3JkZXJbaV07XG4gICAgY2hpbGRHcmFwaE1hcFt0aGlzLmNvbXBvdW5kT3JkZXJbaV0uaWRdID0gW10uY29uY2F0KHRoaXMuY29tcG91bmRPcmRlcltpXS5nZXRDaGlsZCgpLmdldE5vZGVzKCkpO1xuXG4gICAgLy8gUmVtb3ZlIGNoaWxkcmVuIG9mIGNvbXBvdW5kc1xuICAgIHRoaXMuZ3JhcGhNYW5hZ2VyLnJlbW92ZSh0aGlzLmNvbXBvdW5kT3JkZXJbaV0uZ2V0Q2hpbGQoKSk7XG4gICAgdGhpcy5jb21wb3VuZE9yZGVyW2ldLmNoaWxkID0gbnVsbDtcbiAgfVxuXG4gIHRoaXMuZ3JhcGhNYW5hZ2VyLnJlc2V0QWxsTm9kZXMoKTtcblxuICAvLyBUaWxlIHRoZSByZW1vdmVkIGNoaWxkcmVuXG4gIHRoaXMudGlsZUNvbXBvdW5kTWVtYmVycyhjaGlsZEdyYXBoTWFwLCBpZFRvTm9kZSk7XG59O1xuXG5Db1NFTGF5b3V0LnByb3RvdHlwZS5jbGVhclplcm9EZWdyZWVNZW1iZXJzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciB0aWxlZFplcm9EZWdyZWVQYWNrID0gdGhpcy50aWxlZFplcm9EZWdyZWVQYWNrID0gW107XG5cbiAgT2JqZWN0LmtleXModGhpcy5tZW1iZXJHcm91cHMpLmZvckVhY2goZnVuY3Rpb24gKGlkKSB7XG4gICAgdmFyIGNvbXBvdW5kTm9kZSA9IHNlbGYuaWRUb0R1bW15Tm9kZVtpZF07IC8vIEdldCB0aGUgZHVtbXkgY29tcG91bmRcblxuICAgIHRpbGVkWmVyb0RlZ3JlZVBhY2tbaWRdID0gc2VsZi50aWxlTm9kZXMoc2VsZi5tZW1iZXJHcm91cHNbaWRdLCBjb21wb3VuZE5vZGUucGFkZGluZ0xlZnQgKyBjb21wb3VuZE5vZGUucGFkZGluZ1JpZ2h0KTtcblxuICAgIC8vIFNldCB0aGUgd2lkdGggYW5kIGhlaWdodCBvZiB0aGUgZHVtbXkgY29tcG91bmQgYXMgY2FsY3VsYXRlZFxuICAgIGNvbXBvdW5kTm9kZS5yZWN0LndpZHRoID0gdGlsZWRaZXJvRGVncmVlUGFja1tpZF0ud2lkdGg7XG4gICAgY29tcG91bmROb2RlLnJlY3QuaGVpZ2h0ID0gdGlsZWRaZXJvRGVncmVlUGFja1tpZF0uaGVpZ2h0O1xuICB9KTtcbn07XG5cbkNvU0VMYXlvdXQucHJvdG90eXBlLnJlcG9wdWxhdGVDb21wb3VuZHMgPSBmdW5jdGlvbiAoKSB7XG4gIGZvciAodmFyIGkgPSB0aGlzLmNvbXBvdW5kT3JkZXIubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICB2YXIgbENvbXBvdW5kTm9kZSA9IHRoaXMuY29tcG91bmRPcmRlcltpXTtcbiAgICB2YXIgaWQgPSBsQ29tcG91bmROb2RlLmlkO1xuICAgIHZhciBob3Jpem9udGFsTWFyZ2luID0gbENvbXBvdW5kTm9kZS5wYWRkaW5nTGVmdDtcbiAgICB2YXIgdmVydGljYWxNYXJnaW4gPSBsQ29tcG91bmROb2RlLnBhZGRpbmdUb3A7XG5cbiAgICB0aGlzLmFkanVzdExvY2F0aW9ucyh0aGlzLnRpbGVkTWVtYmVyUGFja1tpZF0sIGxDb21wb3VuZE5vZGUucmVjdC54LCBsQ29tcG91bmROb2RlLnJlY3QueSwgaG9yaXpvbnRhbE1hcmdpbiwgdmVydGljYWxNYXJnaW4pO1xuICB9XG59O1xuXG5Db1NFTGF5b3V0LnByb3RvdHlwZS5yZXBvcHVsYXRlWmVyb0RlZ3JlZU1lbWJlcnMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHRpbGVkUGFjayA9IHRoaXMudGlsZWRaZXJvRGVncmVlUGFjaztcblxuICBPYmplY3Qua2V5cyh0aWxlZFBhY2spLmZvckVhY2goZnVuY3Rpb24gKGlkKSB7XG4gICAgdmFyIGNvbXBvdW5kTm9kZSA9IHNlbGYuaWRUb0R1bW15Tm9kZVtpZF07IC8vIEdldCB0aGUgZHVtbXkgY29tcG91bmQgYnkgaXRzIGlkXG4gICAgdmFyIGhvcml6b250YWxNYXJnaW4gPSBjb21wb3VuZE5vZGUucGFkZGluZ0xlZnQ7XG4gICAgdmFyIHZlcnRpY2FsTWFyZ2luID0gY29tcG91bmROb2RlLnBhZGRpbmdUb3A7XG5cbiAgICAvLyBBZGp1c3QgdGhlIHBvc2l0aW9ucyBvZiBub2RlcyB3cnQgaXRzIGNvbXBvdW5kXG4gICAgc2VsZi5hZGp1c3RMb2NhdGlvbnModGlsZWRQYWNrW2lkXSwgY29tcG91bmROb2RlLnJlY3QueCwgY29tcG91bmROb2RlLnJlY3QueSwgaG9yaXpvbnRhbE1hcmdpbiwgdmVydGljYWxNYXJnaW4pO1xuICB9KTtcbn07XG5cbkNvU0VMYXlvdXQucHJvdG90eXBlLmdldFRvQmVUaWxlZCA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIHZhciBpZCA9IG5vZGUuaWQ7XG4gIC8vZmlyc3RseSBjaGVjayB0aGUgcHJldmlvdXMgcmVzdWx0c1xuICBpZiAodGhpcy50b0JlVGlsZWRbaWRdICE9IG51bGwpIHtcbiAgICByZXR1cm4gdGhpcy50b0JlVGlsZWRbaWRdO1xuICB9XG5cbiAgLy9vbmx5IGNvbXBvdW5kIG5vZGVzIGFyZSB0byBiZSB0aWxlZFxuICB2YXIgY2hpbGRHcmFwaCA9IG5vZGUuZ2V0Q2hpbGQoKTtcbiAgaWYgKGNoaWxkR3JhcGggPT0gbnVsbCkge1xuICAgIHRoaXMudG9CZVRpbGVkW2lkXSA9IGZhbHNlO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBjaGlsZHJlbiA9IGNoaWxkR3JhcGguZ2V0Tm9kZXMoKTsgLy8gR2V0IHRoZSBjaGlsZHJlbiBub2Rlc1xuXG4gIC8vYSBjb21wb3VuZCBub2RlIGlzIG5vdCB0byBiZSB0aWxlZCBpZiBhbGwgb2YgaXRzIGNvbXBvdW5kIGNoaWxkcmVuIGFyZSBub3QgdG8gYmUgdGlsZWRcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIHZhciB0aGVDaGlsZCA9IGNoaWxkcmVuW2ldO1xuXG4gICAgaWYgKHRoaXMuZ2V0Tm9kZURlZ3JlZSh0aGVDaGlsZCkgPiAwKSB7XG4gICAgICB0aGlzLnRvQmVUaWxlZFtpZF0gPSBmYWxzZTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvL3Bhc3MgdGhlIGNoaWxkcmVuIG5vdCBoYXZpbmcgdGhlIGNvbXBvdW5kIHN0cnVjdHVyZVxuICAgIGlmICh0aGVDaGlsZC5nZXRDaGlsZCgpID09IG51bGwpIHtcbiAgICAgIHRoaXMudG9CZVRpbGVkW3RoZUNoaWxkLmlkXSA9IGZhbHNlO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmdldFRvQmVUaWxlZCh0aGVDaGlsZCkpIHtcbiAgICAgIHRoaXMudG9CZVRpbGVkW2lkXSA9IGZhbHNlO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICB0aGlzLnRvQmVUaWxlZFtpZF0gPSB0cnVlO1xuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8vIEdldCBkZWdyZWUgb2YgYSBub2RlIGRlcGVuZGluZyBvZiBpdHMgZWRnZXMgYW5kIGluZGVwZW5kZW50IG9mIGl0cyBjaGlsZHJlblxuQ29TRUxheW91dC5wcm90b3R5cGUuZ2V0Tm9kZURlZ3JlZSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIHZhciBpZCA9IG5vZGUuaWQ7XG4gIHZhciBlZGdlcyA9IG5vZGUuZ2V0RWRnZXMoKTtcbiAgdmFyIGRlZ3JlZSA9IDA7XG5cbiAgLy8gRm9yIHRoZSBlZGdlcyBjb25uZWN0ZWRcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBlZGdlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBlZGdlID0gZWRnZXNbaV07XG4gICAgaWYgKGVkZ2UuZ2V0U291cmNlKCkuaWQgIT09IGVkZ2UuZ2V0VGFyZ2V0KCkuaWQpIHtcbiAgICAgIGRlZ3JlZSA9IGRlZ3JlZSArIDE7XG4gICAgfVxuICB9XG4gIHJldHVybiBkZWdyZWU7XG59O1xuXG4vLyBHZXQgZGVncmVlIG9mIGEgbm9kZSB3aXRoIGl0cyBjaGlsZHJlblxuQ29TRUxheW91dC5wcm90b3R5cGUuZ2V0Tm9kZURlZ3JlZVdpdGhDaGlsZHJlbiA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIHZhciBkZWdyZWUgPSB0aGlzLmdldE5vZGVEZWdyZWUobm9kZSk7XG4gIGlmIChub2RlLmdldENoaWxkKCkgPT0gbnVsbCkge1xuICAgIHJldHVybiBkZWdyZWU7XG4gIH1cbiAgdmFyIGNoaWxkcmVuID0gbm9kZS5nZXRDaGlsZCgpLmdldE5vZGVzKCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICBkZWdyZWUgKz0gdGhpcy5nZXROb2RlRGVncmVlV2l0aENoaWxkcmVuKGNoaWxkKTtcbiAgfVxuICByZXR1cm4gZGVncmVlO1xufTtcblxuQ29TRUxheW91dC5wcm90b3R5cGUucGVyZm9ybURGU09uQ29tcG91bmRzID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmNvbXBvdW5kT3JkZXIgPSBbXTtcbiAgdGhpcy5maWxsQ29tcGV4T3JkZXJCeURGUyh0aGlzLmdyYXBoTWFuYWdlci5nZXRSb290KCkuZ2V0Tm9kZXMoKSk7XG59O1xuXG5Db1NFTGF5b3V0LnByb3RvdHlwZS5maWxsQ29tcGV4T3JkZXJCeURGUyA9IGZ1bmN0aW9uIChjaGlsZHJlbikge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgaWYgKGNoaWxkLmdldENoaWxkKCkgIT0gbnVsbCkge1xuICAgICAgdGhpcy5maWxsQ29tcGV4T3JkZXJCeURGUyhjaGlsZC5nZXRDaGlsZCgpLmdldE5vZGVzKCkpO1xuICAgIH1cbiAgICBpZiAodGhpcy5nZXRUb0JlVGlsZWQoY2hpbGQpKSB7XG4gICAgICB0aGlzLmNvbXBvdW5kT3JkZXIucHVzaChjaGlsZCk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiogVGhpcyBtZXRob2QgcGxhY2VzIGVhY2ggemVybyBkZWdyZWUgbWVtYmVyIHdydCBnaXZlbiAoeCx5KSBjb29yZGluYXRlcyAodG9wIGxlZnQpLlxuKi9cbkNvU0VMYXlvdXQucHJvdG90eXBlLmFkanVzdExvY2F0aW9ucyA9IGZ1bmN0aW9uIChvcmdhbml6YXRpb24sIHgsIHksIGNvbXBvdW5kSG9yaXpvbnRhbE1hcmdpbiwgY29tcG91bmRWZXJ0aWNhbE1hcmdpbikge1xuICB4ICs9IGNvbXBvdW5kSG9yaXpvbnRhbE1hcmdpbjtcbiAgeSArPSBjb21wb3VuZFZlcnRpY2FsTWFyZ2luO1xuXG4gIHZhciBsZWZ0ID0geDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG9yZ2FuaXphdGlvbi5yb3dzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHJvdyA9IG9yZ2FuaXphdGlvbi5yb3dzW2ldO1xuICAgIHggPSBsZWZ0O1xuICAgIHZhciBtYXhIZWlnaHQgPSAwO1xuXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCByb3cubGVuZ3RoOyBqKyspIHtcbiAgICAgIHZhciBsbm9kZSA9IHJvd1tqXTtcblxuICAgICAgbG5vZGUucmVjdC54ID0geDsgLy8gKyBsbm9kZS5yZWN0LndpZHRoIC8gMjtcbiAgICAgIGxub2RlLnJlY3QueSA9IHk7IC8vICsgbG5vZGUucmVjdC5oZWlnaHQgLyAyO1xuXG4gICAgICB4ICs9IGxub2RlLnJlY3Qud2lkdGggKyBvcmdhbml6YXRpb24uaG9yaXpvbnRhbFBhZGRpbmc7XG5cbiAgICAgIGlmIChsbm9kZS5yZWN0LmhlaWdodCA+IG1heEhlaWdodCkgbWF4SGVpZ2h0ID0gbG5vZGUucmVjdC5oZWlnaHQ7XG4gICAgfVxuXG4gICAgeSArPSBtYXhIZWlnaHQgKyBvcmdhbml6YXRpb24udmVydGljYWxQYWRkaW5nO1xuICB9XG59O1xuXG5Db1NFTGF5b3V0LnByb3RvdHlwZS50aWxlQ29tcG91bmRNZW1iZXJzID0gZnVuY3Rpb24gKGNoaWxkR3JhcGhNYXAsIGlkVG9Ob2RlKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdGhpcy50aWxlZE1lbWJlclBhY2sgPSBbXTtcblxuICBPYmplY3Qua2V5cyhjaGlsZEdyYXBoTWFwKS5mb3JFYWNoKGZ1bmN0aW9uIChpZCkge1xuICAgIC8vIEdldCB0aGUgY29tcG91bmQgbm9kZVxuICAgIHZhciBjb21wb3VuZE5vZGUgPSBpZFRvTm9kZVtpZF07XG5cbiAgICBzZWxmLnRpbGVkTWVtYmVyUGFja1tpZF0gPSBzZWxmLnRpbGVOb2RlcyhjaGlsZEdyYXBoTWFwW2lkXSwgY29tcG91bmROb2RlLnBhZGRpbmdMZWZ0ICsgY29tcG91bmROb2RlLnBhZGRpbmdSaWdodCk7XG5cbiAgICBjb21wb3VuZE5vZGUucmVjdC53aWR0aCA9IHNlbGYudGlsZWRNZW1iZXJQYWNrW2lkXS53aWR0aDtcbiAgICBjb21wb3VuZE5vZGUucmVjdC5oZWlnaHQgPSBzZWxmLnRpbGVkTWVtYmVyUGFja1tpZF0uaGVpZ2h0O1xuICB9KTtcbn07XG5cbkNvU0VMYXlvdXQucHJvdG90eXBlLnRpbGVOb2RlcyA9IGZ1bmN0aW9uIChub2RlcywgbWluV2lkdGgpIHtcbiAgdmFyIHZlcnRpY2FsUGFkZGluZyA9IENvU0VDb25zdGFudHMuVElMSU5HX1BBRERJTkdfVkVSVElDQUw7XG4gIHZhciBob3Jpem9udGFsUGFkZGluZyA9IENvU0VDb25zdGFudHMuVElMSU5HX1BBRERJTkdfSE9SSVpPTlRBTDtcbiAgdmFyIG9yZ2FuaXphdGlvbiA9IHtcbiAgICByb3dzOiBbXSxcbiAgICByb3dXaWR0aDogW10sXG4gICAgcm93SGVpZ2h0OiBbXSxcbiAgICB3aWR0aDogMCxcbiAgICBoZWlnaHQ6IG1pbldpZHRoLCAvLyBhc3N1bWUgbWluSGVpZ2h0IGVxdWFscyB0byBtaW5XaWR0aFxuICAgIHZlcnRpY2FsUGFkZGluZzogdmVydGljYWxQYWRkaW5nLFxuICAgIGhvcml6b250YWxQYWRkaW5nOiBob3Jpem9udGFsUGFkZGluZ1xuICB9O1xuXG4gIC8vIFNvcnQgdGhlIG5vZGVzIGluIGFzY2VuZGluZyBvcmRlciBvZiB0aGVpciBhcmVhc1xuICBub2Rlcy5zb3J0KGZ1bmN0aW9uIChuMSwgbjIpIHtcbiAgICBpZiAobjEucmVjdC53aWR0aCAqIG4xLnJlY3QuaGVpZ2h0ID4gbjIucmVjdC53aWR0aCAqIG4yLnJlY3QuaGVpZ2h0KSByZXR1cm4gLTE7XG4gICAgaWYgKG4xLnJlY3Qud2lkdGggKiBuMS5yZWN0LmhlaWdodCA8IG4yLnJlY3Qud2lkdGggKiBuMi5yZWN0LmhlaWdodCkgcmV0dXJuIDE7XG4gICAgcmV0dXJuIDA7XG4gIH0pO1xuXG4gIC8vIENyZWF0ZSB0aGUgb3JnYW5pemF0aW9uIC0+IHRpbGUgbWVtYmVyc1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGxOb2RlID0gbm9kZXNbaV07XG5cbiAgICBpZiAob3JnYW5pemF0aW9uLnJvd3MubGVuZ3RoID09IDApIHtcbiAgICAgIHRoaXMuaW5zZXJ0Tm9kZVRvUm93KG9yZ2FuaXphdGlvbiwgbE5vZGUsIDAsIG1pbldpZHRoKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuY2FuQWRkSG9yaXpvbnRhbChvcmdhbml6YXRpb24sIGxOb2RlLnJlY3Qud2lkdGgsIGxOb2RlLnJlY3QuaGVpZ2h0KSkge1xuICAgICAgdGhpcy5pbnNlcnROb2RlVG9Sb3cob3JnYW5pemF0aW9uLCBsTm9kZSwgdGhpcy5nZXRTaG9ydGVzdFJvd0luZGV4KG9yZ2FuaXphdGlvbiksIG1pbldpZHRoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5pbnNlcnROb2RlVG9Sb3cob3JnYW5pemF0aW9uLCBsTm9kZSwgb3JnYW5pemF0aW9uLnJvd3MubGVuZ3RoLCBtaW5XaWR0aCk7XG4gICAgfVxuXG4gICAgdGhpcy5zaGlmdFRvTGFzdFJvdyhvcmdhbml6YXRpb24pO1xuICB9XG5cbiAgcmV0dXJuIG9yZ2FuaXphdGlvbjtcbn07XG5cbkNvU0VMYXlvdXQucHJvdG90eXBlLmluc2VydE5vZGVUb1JvdyA9IGZ1bmN0aW9uIChvcmdhbml6YXRpb24sIG5vZGUsIHJvd0luZGV4LCBtaW5XaWR0aCkge1xuICB2YXIgbWluQ29tcG91bmRTaXplID0gbWluV2lkdGg7XG5cbiAgLy8gQWRkIG5ldyByb3cgaWYgbmVlZGVkXG4gIGlmIChyb3dJbmRleCA9PSBvcmdhbml6YXRpb24ucm93cy5sZW5ndGgpIHtcbiAgICB2YXIgc2Vjb25kRGltZW5zaW9uID0gW107XG5cbiAgICBvcmdhbml6YXRpb24ucm93cy5wdXNoKHNlY29uZERpbWVuc2lvbik7XG4gICAgb3JnYW5pemF0aW9uLnJvd1dpZHRoLnB1c2gobWluQ29tcG91bmRTaXplKTtcbiAgICBvcmdhbml6YXRpb24ucm93SGVpZ2h0LnB1c2goMCk7XG4gIH1cblxuICAvLyBVcGRhdGUgcm93IHdpZHRoXG4gIHZhciB3ID0gb3JnYW5pemF0aW9uLnJvd1dpZHRoW3Jvd0luZGV4XSArIG5vZGUucmVjdC53aWR0aDtcblxuICBpZiAob3JnYW5pemF0aW9uLnJvd3Nbcm93SW5kZXhdLmxlbmd0aCA+IDApIHtcbiAgICB3ICs9IG9yZ2FuaXphdGlvbi5ob3Jpem9udGFsUGFkZGluZztcbiAgfVxuXG4gIG9yZ2FuaXphdGlvbi5yb3dXaWR0aFtyb3dJbmRleF0gPSB3O1xuICAvLyBVcGRhdGUgY29tcG91bmQgd2lkdGhcbiAgaWYgKG9yZ2FuaXphdGlvbi53aWR0aCA8IHcpIHtcbiAgICBvcmdhbml6YXRpb24ud2lkdGggPSB3O1xuICB9XG5cbiAgLy8gVXBkYXRlIGhlaWdodFxuICB2YXIgaCA9IG5vZGUucmVjdC5oZWlnaHQ7XG4gIGlmIChyb3dJbmRleCA+IDApIGggKz0gb3JnYW5pemF0aW9uLnZlcnRpY2FsUGFkZGluZztcblxuICB2YXIgZXh0cmFIZWlnaHQgPSAwO1xuICBpZiAoaCA+IG9yZ2FuaXphdGlvbi5yb3dIZWlnaHRbcm93SW5kZXhdKSB7XG4gICAgZXh0cmFIZWlnaHQgPSBvcmdhbml6YXRpb24ucm93SGVpZ2h0W3Jvd0luZGV4XTtcbiAgICBvcmdhbml6YXRpb24ucm93SGVpZ2h0W3Jvd0luZGV4XSA9IGg7XG4gICAgZXh0cmFIZWlnaHQgPSBvcmdhbml6YXRpb24ucm93SGVpZ2h0W3Jvd0luZGV4XSAtIGV4dHJhSGVpZ2h0O1xuICB9XG5cbiAgb3JnYW5pemF0aW9uLmhlaWdodCArPSBleHRyYUhlaWdodDtcblxuICAvLyBJbnNlcnQgbm9kZVxuICBvcmdhbml6YXRpb24ucm93c1tyb3dJbmRleF0ucHVzaChub2RlKTtcbn07XG5cbi8vU2NhbnMgdGhlIHJvd3Mgb2YgYW4gb3JnYW5pemF0aW9uIGFuZCByZXR1cm5zIHRoZSBvbmUgd2l0aCB0aGUgbWluIHdpZHRoXG5Db1NFTGF5b3V0LnByb3RvdHlwZS5nZXRTaG9ydGVzdFJvd0luZGV4ID0gZnVuY3Rpb24gKG9yZ2FuaXphdGlvbikge1xuICB2YXIgciA9IC0xO1xuICB2YXIgbWluID0gTnVtYmVyLk1BWF9WQUxVRTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG9yZ2FuaXphdGlvbi5yb3dzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKG9yZ2FuaXphdGlvbi5yb3dXaWR0aFtpXSA8IG1pbikge1xuICAgICAgciA9IGk7XG4gICAgICBtaW4gPSBvcmdhbml6YXRpb24ucm93V2lkdGhbaV07XG4gICAgfVxuICB9XG4gIHJldHVybiByO1xufTtcblxuLy9TY2FucyB0aGUgcm93cyBvZiBhbiBvcmdhbml6YXRpb24gYW5kIHJldHVybnMgdGhlIG9uZSB3aXRoIHRoZSBtYXggd2lkdGhcbkNvU0VMYXlvdXQucHJvdG90eXBlLmdldExvbmdlc3RSb3dJbmRleCA9IGZ1bmN0aW9uIChvcmdhbml6YXRpb24pIHtcbiAgdmFyIHIgPSAtMTtcbiAgdmFyIG1heCA9IE51bWJlci5NSU5fVkFMVUU7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcmdhbml6YXRpb24ucm93cy5sZW5ndGg7IGkrKykge1xuXG4gICAgaWYgKG9yZ2FuaXphdGlvbi5yb3dXaWR0aFtpXSA+IG1heCkge1xuICAgICAgciA9IGk7XG4gICAgICBtYXggPSBvcmdhbml6YXRpb24ucm93V2lkdGhbaV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHI7XG59O1xuXG4vKipcbiogVGhpcyBtZXRob2QgY2hlY2tzIHdoZXRoZXIgYWRkaW5nIGV4dHJhIHdpZHRoIHRvIHRoZSBvcmdhbml6YXRpb24gdmlvbGF0ZXNcbiogdGhlIGFzcGVjdCByYXRpbygxKSBvciBub3QuXG4qL1xuQ29TRUxheW91dC5wcm90b3R5cGUuY2FuQWRkSG9yaXpvbnRhbCA9IGZ1bmN0aW9uIChvcmdhbml6YXRpb24sIGV4dHJhV2lkdGgsIGV4dHJhSGVpZ2h0KSB7XG5cbiAgdmFyIHNyaSA9IHRoaXMuZ2V0U2hvcnRlc3RSb3dJbmRleChvcmdhbml6YXRpb24pO1xuXG4gIGlmIChzcmkgPCAwKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICB2YXIgbWluID0gb3JnYW5pemF0aW9uLnJvd1dpZHRoW3NyaV07XG5cbiAgaWYgKG1pbiArIG9yZ2FuaXphdGlvbi5ob3Jpem9udGFsUGFkZGluZyArIGV4dHJhV2lkdGggPD0gb3JnYW5pemF0aW9uLndpZHRoKSByZXR1cm4gdHJ1ZTtcblxuICB2YXIgaERpZmYgPSAwO1xuXG4gIC8vIEFkZGluZyB0byBhbiBleGlzdGluZyByb3dcbiAgaWYgKG9yZ2FuaXphdGlvbi5yb3dIZWlnaHRbc3JpXSA8IGV4dHJhSGVpZ2h0KSB7XG4gICAgaWYgKHNyaSA+IDApIGhEaWZmID0gZXh0cmFIZWlnaHQgKyBvcmdhbml6YXRpb24udmVydGljYWxQYWRkaW5nIC0gb3JnYW5pemF0aW9uLnJvd0hlaWdodFtzcmldO1xuICB9XG5cbiAgdmFyIGFkZF90b19yb3dfcmF0aW87XG4gIGlmIChvcmdhbml6YXRpb24ud2lkdGggLSBtaW4gPj0gZXh0cmFXaWR0aCArIG9yZ2FuaXphdGlvbi5ob3Jpem9udGFsUGFkZGluZykge1xuICAgIGFkZF90b19yb3dfcmF0aW8gPSAob3JnYW5pemF0aW9uLmhlaWdodCArIGhEaWZmKSAvIChtaW4gKyBleHRyYVdpZHRoICsgb3JnYW5pemF0aW9uLmhvcml6b250YWxQYWRkaW5nKTtcbiAgfSBlbHNlIHtcbiAgICBhZGRfdG9fcm93X3JhdGlvID0gKG9yZ2FuaXphdGlvbi5oZWlnaHQgKyBoRGlmZikgLyBvcmdhbml6YXRpb24ud2lkdGg7XG4gIH1cblxuICAvLyBBZGRpbmcgYSBuZXcgcm93IGZvciB0aGlzIG5vZGVcbiAgaERpZmYgPSBleHRyYUhlaWdodCArIG9yZ2FuaXphdGlvbi52ZXJ0aWNhbFBhZGRpbmc7XG4gIHZhciBhZGRfbmV3X3Jvd19yYXRpbztcbiAgaWYgKG9yZ2FuaXphdGlvbi53aWR0aCA8IGV4dHJhV2lkdGgpIHtcbiAgICBhZGRfbmV3X3Jvd19yYXRpbyA9IChvcmdhbml6YXRpb24uaGVpZ2h0ICsgaERpZmYpIC8gZXh0cmFXaWR0aDtcbiAgfSBlbHNlIHtcbiAgICBhZGRfbmV3X3Jvd19yYXRpbyA9IChvcmdhbml6YXRpb24uaGVpZ2h0ICsgaERpZmYpIC8gb3JnYW5pemF0aW9uLndpZHRoO1xuICB9XG5cbiAgaWYgKGFkZF9uZXdfcm93X3JhdGlvIDwgMSkgYWRkX25ld19yb3dfcmF0aW8gPSAxIC8gYWRkX25ld19yb3dfcmF0aW87XG5cbiAgaWYgKGFkZF90b19yb3dfcmF0aW8gPCAxKSBhZGRfdG9fcm93X3JhdGlvID0gMSAvIGFkZF90b19yb3dfcmF0aW87XG5cbiAgcmV0dXJuIGFkZF90b19yb3dfcmF0aW8gPCBhZGRfbmV3X3Jvd19yYXRpbztcbn07XG5cbi8vSWYgbW92aW5nIHRoZSBsYXN0IG5vZGUgZnJvbSB0aGUgbG9uZ2VzdCByb3cgYW5kIGFkZGluZyBpdCB0byB0aGUgbGFzdFxuLy9yb3cgbWFrZXMgdGhlIGJvdW5kaW5nIGJveCBzbWFsbGVyLCBkbyBpdC5cbkNvU0VMYXlvdXQucHJvdG90eXBlLnNoaWZ0VG9MYXN0Um93ID0gZnVuY3Rpb24gKG9yZ2FuaXphdGlvbikge1xuICB2YXIgbG9uZ2VzdCA9IHRoaXMuZ2V0TG9uZ2VzdFJvd0luZGV4KG9yZ2FuaXphdGlvbik7XG4gIHZhciBsYXN0ID0gb3JnYW5pemF0aW9uLnJvd1dpZHRoLmxlbmd0aCAtIDE7XG4gIHZhciByb3cgPSBvcmdhbml6YXRpb24ucm93c1tsb25nZXN0XTtcbiAgdmFyIG5vZGUgPSByb3dbcm93Lmxlbmd0aCAtIDFdO1xuXG4gIHZhciBkaWZmID0gbm9kZS53aWR0aCArIG9yZ2FuaXphdGlvbi5ob3Jpem9udGFsUGFkZGluZztcblxuICAvLyBDaGVjayBpZiB0aGVyZSBpcyBlbm91Z2ggc3BhY2Ugb24gdGhlIGxhc3Qgcm93XG4gIGlmIChvcmdhbml6YXRpb24ud2lkdGggLSBvcmdhbml6YXRpb24ucm93V2lkdGhbbGFzdF0gPiBkaWZmICYmIGxvbmdlc3QgIT0gbGFzdCkge1xuICAgIC8vIFJlbW92ZSB0aGUgbGFzdCBlbGVtZW50IG9mIHRoZSBsb25nZXN0IHJvd1xuICAgIHJvdy5zcGxpY2UoLTEsIDEpO1xuXG4gICAgLy8gUHVzaCBpdCB0byB0aGUgbGFzdCByb3dcbiAgICBvcmdhbml6YXRpb24ucm93c1tsYXN0XS5wdXNoKG5vZGUpO1xuXG4gICAgb3JnYW5pemF0aW9uLnJvd1dpZHRoW2xvbmdlc3RdID0gb3JnYW5pemF0aW9uLnJvd1dpZHRoW2xvbmdlc3RdIC0gZGlmZjtcbiAgICBvcmdhbml6YXRpb24ucm93V2lkdGhbbGFzdF0gPSBvcmdhbml6YXRpb24ucm93V2lkdGhbbGFzdF0gKyBkaWZmO1xuICAgIG9yZ2FuaXphdGlvbi53aWR0aCA9IG9yZ2FuaXphdGlvbi5yb3dXaWR0aFtpbnN0YW5jZS5nZXRMb25nZXN0Um93SW5kZXgob3JnYW5pemF0aW9uKV07XG5cbiAgICAvLyBVcGRhdGUgaGVpZ2h0cyBvZiB0aGUgb3JnYW5pemF0aW9uXG4gICAgdmFyIG1heEhlaWdodCA9IE51bWJlci5NSU5fVkFMVUU7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCByb3cubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChyb3dbaV0uaGVpZ2h0ID4gbWF4SGVpZ2h0KSBtYXhIZWlnaHQgPSByb3dbaV0uaGVpZ2h0O1xuICAgIH1cbiAgICBpZiAobG9uZ2VzdCA+IDApIG1heEhlaWdodCArPSBvcmdhbml6YXRpb24udmVydGljYWxQYWRkaW5nO1xuXG4gICAgdmFyIHByZXZUb3RhbCA9IG9yZ2FuaXphdGlvbi5yb3dIZWlnaHRbbG9uZ2VzdF0gKyBvcmdhbml6YXRpb24ucm93SGVpZ2h0W2xhc3RdO1xuXG4gICAgb3JnYW5pemF0aW9uLnJvd0hlaWdodFtsb25nZXN0XSA9IG1heEhlaWdodDtcbiAgICBpZiAob3JnYW5pemF0aW9uLnJvd0hlaWdodFtsYXN0XSA8IG5vZGUuaGVpZ2h0ICsgb3JnYW5pemF0aW9uLnZlcnRpY2FsUGFkZGluZykgb3JnYW5pemF0aW9uLnJvd0hlaWdodFtsYXN0XSA9IG5vZGUuaGVpZ2h0ICsgb3JnYW5pemF0aW9uLnZlcnRpY2FsUGFkZGluZztcblxuICAgIHZhciBmaW5hbFRvdGFsID0gb3JnYW5pemF0aW9uLnJvd0hlaWdodFtsb25nZXN0XSArIG9yZ2FuaXphdGlvbi5yb3dIZWlnaHRbbGFzdF07XG4gICAgb3JnYW5pemF0aW9uLmhlaWdodCArPSBmaW5hbFRvdGFsIC0gcHJldlRvdGFsO1xuXG4gICAgdGhpcy5zaGlmdFRvTGFzdFJvdyhvcmdhbml6YXRpb24pO1xuICB9XG59O1xuXG5Db1NFTGF5b3V0LnByb3RvdHlwZS50aWxpbmdQcmVMYXlvdXQgPSBmdW5jdGlvbiAoKSB7XG4gIGlmIChDb1NFQ29uc3RhbnRzLlRJTEUpIHtcbiAgICAvLyBGaW5kIHplcm8gZGVncmVlIG5vZGVzIGFuZCBjcmVhdGUgYSBjb21wb3VuZCBmb3IgZWFjaCBsZXZlbFxuICAgIHRoaXMuZ3JvdXBaZXJvRGVncmVlTWVtYmVycygpO1xuICAgIC8vIFRpbGUgYW5kIGNsZWFyIGNoaWxkcmVuIG9mIGVhY2ggY29tcG91bmRcbiAgICB0aGlzLmNsZWFyQ29tcG91bmRzKCk7XG4gICAgLy8gU2VwYXJhdGVseSB0aWxlIGFuZCBjbGVhciB6ZXJvIGRlZ3JlZSBub2RlcyBmb3IgZWFjaCBsZXZlbFxuICAgIHRoaXMuY2xlYXJaZXJvRGVncmVlTWVtYmVycygpO1xuICB9XG59O1xuXG5Db1NFTGF5b3V0LnByb3RvdHlwZS50aWxpbmdQb3N0TGF5b3V0ID0gZnVuY3Rpb24gKCkge1xuICBpZiAoQ29TRUNvbnN0YW50cy5USUxFKSB7XG4gICAgdGhpcy5yZXBvcHVsYXRlWmVyb0RlZ3JlZU1lbWJlcnMoKTtcbiAgICB0aGlzLnJlcG9wdWxhdGVDb21wb3VuZHMoKTtcbiAgfVxufTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFNlY3Rpb246IFRyZWUgUmVkdWN0aW9uIG1ldGhvZHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBSZWR1Y2UgdHJlZXMgXG5Db1NFTGF5b3V0LnByb3RvdHlwZS5yZWR1Y2VUcmVlcyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHBydW5lZE5vZGVzQWxsID0gW107XG4gIHZhciBjb250YWluc0xlYWYgPSB0cnVlO1xuICB2YXIgbm9kZTtcblxuICB3aGlsZSAoY29udGFpbnNMZWFmKSB7XG4gICAgdmFyIGFsbE5vZGVzID0gdGhpcy5ncmFwaE1hbmFnZXIuZ2V0QWxsTm9kZXMoKTtcbiAgICB2YXIgcHJ1bmVkTm9kZXNJblN0ZXBUZW1wID0gW107XG4gICAgY29udGFpbnNMZWFmID0gZmFsc2U7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFsbE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBub2RlID0gYWxsTm9kZXNbaV07XG4gICAgICBpZiAobm9kZS5nZXRFZGdlcygpLmxlbmd0aCA9PSAxICYmICFub2RlLmdldEVkZ2VzKClbMF0uaXNJbnRlckdyYXBoICYmIG5vZGUuZ2V0Q2hpbGQoKSA9PSBudWxsKSB7XG4gICAgICAgIHBydW5lZE5vZGVzSW5TdGVwVGVtcC5wdXNoKFtub2RlLCBub2RlLmdldEVkZ2VzKClbMF0sIG5vZGUuZ2V0T3duZXIoKV0pO1xuICAgICAgICBjb250YWluc0xlYWYgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoY29udGFpbnNMZWFmID09IHRydWUpIHtcbiAgICAgIHZhciBwcnVuZWROb2Rlc0luU3RlcCA9IFtdO1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBwcnVuZWROb2Rlc0luU3RlcFRlbXAubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgaWYgKHBydW5lZE5vZGVzSW5TdGVwVGVtcFtqXVswXS5nZXRFZGdlcygpLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgICAgcHJ1bmVkTm9kZXNJblN0ZXAucHVzaChwcnVuZWROb2Rlc0luU3RlcFRlbXBbal0pO1xuICAgICAgICAgIHBydW5lZE5vZGVzSW5TdGVwVGVtcFtqXVswXS5nZXRPd25lcigpLnJlbW92ZShwcnVuZWROb2Rlc0luU3RlcFRlbXBbal1bMF0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBwcnVuZWROb2Rlc0FsbC5wdXNoKHBydW5lZE5vZGVzSW5TdGVwKTtcbiAgICAgIHRoaXMuZ3JhcGhNYW5hZ2VyLnJlc2V0QWxsTm9kZXMoKTtcbiAgICAgIHRoaXMuZ3JhcGhNYW5hZ2VyLnJlc2V0QWxsRWRnZXMoKTtcbiAgICB9XG4gIH1cbiAgdGhpcy5wcnVuZWROb2Rlc0FsbCA9IHBydW5lZE5vZGVzQWxsO1xufTtcblxuLy8gR3JvdyB0cmVlIG9uZSBzdGVwIFxuQ29TRUxheW91dC5wcm90b3R5cGUuZ3Jvd1RyZWUgPSBmdW5jdGlvbiAocHJ1bmVkTm9kZXNBbGwpIHtcbiAgdmFyIGxlbmd0aE9mUHJ1bmVkTm9kZXNJblN0ZXAgPSBwcnVuZWROb2Rlc0FsbC5sZW5ndGg7XG4gIHZhciBwcnVuZWROb2Rlc0luU3RlcCA9IHBydW5lZE5vZGVzQWxsW2xlbmd0aE9mUHJ1bmVkTm9kZXNJblN0ZXAgLSAxXTtcblxuICB2YXIgbm9kZURhdGE7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJ1bmVkTm9kZXNJblN0ZXAubGVuZ3RoOyBpKyspIHtcbiAgICBub2RlRGF0YSA9IHBydW5lZE5vZGVzSW5TdGVwW2ldO1xuXG4gICAgdGhpcy5maW5kUGxhY2Vmb3JQcnVuZWROb2RlKG5vZGVEYXRhKTtcblxuICAgIG5vZGVEYXRhWzJdLmFkZChub2RlRGF0YVswXSk7XG4gICAgbm9kZURhdGFbMl0uYWRkKG5vZGVEYXRhWzFdLCBub2RlRGF0YVsxXS5zb3VyY2UsIG5vZGVEYXRhWzFdLnRhcmdldCk7XG4gIH1cblxuICBwcnVuZWROb2Rlc0FsbC5zcGxpY2UocHJ1bmVkTm9kZXNBbGwubGVuZ3RoIC0gMSwgMSk7XG4gIHRoaXMuZ3JhcGhNYW5hZ2VyLnJlc2V0QWxsTm9kZXMoKTtcbiAgdGhpcy5ncmFwaE1hbmFnZXIucmVzZXRBbGxFZGdlcygpO1xufTtcblxuLy8gRmluZCBhbiBhcHByb3ByaWF0ZSBwb3NpdGlvbiB0byByZXBsYWNlIHBydW5lZCBub2RlLCB0aGlzIG1ldGhvZCBjYW4gYmUgaW1wcm92ZWRcbkNvU0VMYXlvdXQucHJvdG90eXBlLmZpbmRQbGFjZWZvclBydW5lZE5vZGUgPSBmdW5jdGlvbiAobm9kZURhdGEpIHtcblxuICB2YXIgZ3JpZEZvclBydW5lZE5vZGU7XG4gIHZhciBub2RlVG9Db25uZWN0O1xuICB2YXIgcHJ1bmVkTm9kZSA9IG5vZGVEYXRhWzBdO1xuICBpZiAocHJ1bmVkTm9kZSA9PSBub2RlRGF0YVsxXS5zb3VyY2UpIHtcbiAgICBub2RlVG9Db25uZWN0ID0gbm9kZURhdGFbMV0udGFyZ2V0O1xuICB9IGVsc2Uge1xuICAgIG5vZGVUb0Nvbm5lY3QgPSBub2RlRGF0YVsxXS5zb3VyY2U7XG4gIH1cbiAgdmFyIHN0YXJ0R3JpZFggPSBub2RlVG9Db25uZWN0LnN0YXJ0WDtcbiAgdmFyIGZpbmlzaEdyaWRYID0gbm9kZVRvQ29ubmVjdC5maW5pc2hYO1xuICB2YXIgc3RhcnRHcmlkWSA9IG5vZGVUb0Nvbm5lY3Quc3RhcnRZO1xuICB2YXIgZmluaXNoR3JpZFkgPSBub2RlVG9Db25uZWN0LmZpbmlzaFk7XG5cbiAgdmFyIHVwTm9kZUNvdW50ID0gMDtcbiAgdmFyIGRvd25Ob2RlQ291bnQgPSAwO1xuICB2YXIgcmlnaHROb2RlQ291bnQgPSAwO1xuICB2YXIgbGVmdE5vZGVDb3VudCA9IDA7XG4gIHZhciBjb250cm9sUmVnaW9ucyA9IFt1cE5vZGVDb3VudCwgcmlnaHROb2RlQ291bnQsIGRvd25Ob2RlQ291bnQsIGxlZnROb2RlQ291bnRdO1xuXG4gIGlmIChzdGFydEdyaWRZID4gMCkge1xuICAgIGZvciAodmFyIGkgPSBzdGFydEdyaWRYOyBpIDw9IGZpbmlzaEdyaWRYOyBpKyspIHtcbiAgICAgIGNvbnRyb2xSZWdpb25zWzBdICs9IHRoaXMuZ3JpZFtpXVtzdGFydEdyaWRZIC0gMV0ubGVuZ3RoICsgdGhpcy5ncmlkW2ldW3N0YXJ0R3JpZFldLmxlbmd0aCAtIDE7XG4gICAgfVxuICB9XG4gIGlmIChmaW5pc2hHcmlkWCA8IHRoaXMuZ3JpZC5sZW5ndGggLSAxKSB7XG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0R3JpZFk7IGkgPD0gZmluaXNoR3JpZFk7IGkrKykge1xuICAgICAgY29udHJvbFJlZ2lvbnNbMV0gKz0gdGhpcy5ncmlkW2ZpbmlzaEdyaWRYICsgMV1baV0ubGVuZ3RoICsgdGhpcy5ncmlkW2ZpbmlzaEdyaWRYXVtpXS5sZW5ndGggLSAxO1xuICAgIH1cbiAgfVxuICBpZiAoZmluaXNoR3JpZFkgPCB0aGlzLmdyaWRbMF0ubGVuZ3RoIC0gMSkge1xuICAgIGZvciAodmFyIGkgPSBzdGFydEdyaWRYOyBpIDw9IGZpbmlzaEdyaWRYOyBpKyspIHtcbiAgICAgIGNvbnRyb2xSZWdpb25zWzJdICs9IHRoaXMuZ3JpZFtpXVtmaW5pc2hHcmlkWSArIDFdLmxlbmd0aCArIHRoaXMuZ3JpZFtpXVtmaW5pc2hHcmlkWV0ubGVuZ3RoIC0gMTtcbiAgICB9XG4gIH1cbiAgaWYgKHN0YXJ0R3JpZFggPiAwKSB7XG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0R3JpZFk7IGkgPD0gZmluaXNoR3JpZFk7IGkrKykge1xuICAgICAgY29udHJvbFJlZ2lvbnNbM10gKz0gdGhpcy5ncmlkW3N0YXJ0R3JpZFggLSAxXVtpXS5sZW5ndGggKyB0aGlzLmdyaWRbc3RhcnRHcmlkWF1baV0ubGVuZ3RoIC0gMTtcbiAgICB9XG4gIH1cbiAgdmFyIG1pbiA9IEludGVnZXIuTUFYX1ZBTFVFO1xuICB2YXIgbWluQ291bnQ7XG4gIHZhciBtaW5JbmRleDtcbiAgZm9yICh2YXIgaiA9IDA7IGogPCBjb250cm9sUmVnaW9ucy5sZW5ndGg7IGorKykge1xuICAgIGlmIChjb250cm9sUmVnaW9uc1tqXSA8IG1pbikge1xuICAgICAgbWluID0gY29udHJvbFJlZ2lvbnNbal07XG4gICAgICBtaW5Db3VudCA9IDE7XG4gICAgICBtaW5JbmRleCA9IGo7XG4gICAgfSBlbHNlIGlmIChjb250cm9sUmVnaW9uc1tqXSA9PSBtaW4pIHtcbiAgICAgIG1pbkNvdW50Kys7XG4gICAgfVxuICB9XG5cbiAgaWYgKG1pbkNvdW50ID09IDMgJiYgbWluID09IDApIHtcbiAgICBpZiAoY29udHJvbFJlZ2lvbnNbMF0gPT0gMCAmJiBjb250cm9sUmVnaW9uc1sxXSA9PSAwICYmIGNvbnRyb2xSZWdpb25zWzJdID09IDApIHtcbiAgICAgIGdyaWRGb3JQcnVuZWROb2RlID0gMTtcbiAgICB9IGVsc2UgaWYgKGNvbnRyb2xSZWdpb25zWzBdID09IDAgJiYgY29udHJvbFJlZ2lvbnNbMV0gPT0gMCAmJiBjb250cm9sUmVnaW9uc1szXSA9PSAwKSB7XG4gICAgICBncmlkRm9yUHJ1bmVkTm9kZSA9IDA7XG4gICAgfSBlbHNlIGlmIChjb250cm9sUmVnaW9uc1swXSA9PSAwICYmIGNvbnRyb2xSZWdpb25zWzJdID09IDAgJiYgY29udHJvbFJlZ2lvbnNbM10gPT0gMCkge1xuICAgICAgZ3JpZEZvclBydW5lZE5vZGUgPSAzO1xuICAgIH0gZWxzZSBpZiAoY29udHJvbFJlZ2lvbnNbMV0gPT0gMCAmJiBjb250cm9sUmVnaW9uc1syXSA9PSAwICYmIGNvbnRyb2xSZWdpb25zWzNdID09IDApIHtcbiAgICAgIGdyaWRGb3JQcnVuZWROb2RlID0gMjtcbiAgICB9XG4gIH0gZWxzZSBpZiAobWluQ291bnQgPT0gMiAmJiBtaW4gPT0gMCkge1xuICAgIHZhciByYW5kb20gPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAyKTtcbiAgICBpZiAoY29udHJvbFJlZ2lvbnNbMF0gPT0gMCAmJiBjb250cm9sUmVnaW9uc1sxXSA9PSAwKSB7XG4gICAgICA7XG4gICAgICBpZiAocmFuZG9tID09IDApIHtcbiAgICAgICAgZ3JpZEZvclBydW5lZE5vZGUgPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZ3JpZEZvclBydW5lZE5vZGUgPSAxO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY29udHJvbFJlZ2lvbnNbMF0gPT0gMCAmJiBjb250cm9sUmVnaW9uc1syXSA9PSAwKSB7XG4gICAgICBpZiAocmFuZG9tID09IDApIHtcbiAgICAgICAgZ3JpZEZvclBydW5lZE5vZGUgPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZ3JpZEZvclBydW5lZE5vZGUgPSAyO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY29udHJvbFJlZ2lvbnNbMF0gPT0gMCAmJiBjb250cm9sUmVnaW9uc1szXSA9PSAwKSB7XG4gICAgICBpZiAocmFuZG9tID09IDApIHtcbiAgICAgICAgZ3JpZEZvclBydW5lZE5vZGUgPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZ3JpZEZvclBydW5lZE5vZGUgPSAzO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY29udHJvbFJlZ2lvbnNbMV0gPT0gMCAmJiBjb250cm9sUmVnaW9uc1syXSA9PSAwKSB7XG4gICAgICBpZiAocmFuZG9tID09IDApIHtcbiAgICAgICAgZ3JpZEZvclBydW5lZE5vZGUgPSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZ3JpZEZvclBydW5lZE5vZGUgPSAyO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY29udHJvbFJlZ2lvbnNbMV0gPT0gMCAmJiBjb250cm9sUmVnaW9uc1szXSA9PSAwKSB7XG4gICAgICBpZiAocmFuZG9tID09IDApIHtcbiAgICAgICAgZ3JpZEZvclBydW5lZE5vZGUgPSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZ3JpZEZvclBydW5lZE5vZGUgPSAzO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocmFuZG9tID09IDApIHtcbiAgICAgICAgZ3JpZEZvclBydW5lZE5vZGUgPSAyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZ3JpZEZvclBydW5lZE5vZGUgPSAzO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChtaW5Db3VudCA9PSA0ICYmIG1pbiA9PSAwKSB7XG4gICAgdmFyIHJhbmRvbSA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDQpO1xuICAgIGdyaWRGb3JQcnVuZWROb2RlID0gcmFuZG9tO1xuICB9IGVsc2Uge1xuICAgIGdyaWRGb3JQcnVuZWROb2RlID0gbWluSW5kZXg7XG4gIH1cblxuICBpZiAoZ3JpZEZvclBydW5lZE5vZGUgPT0gMCkge1xuICAgIHBydW5lZE5vZGUuc2V0Q2VudGVyKG5vZGVUb0Nvbm5lY3QuZ2V0Q2VudGVyWCgpLCBub2RlVG9Db25uZWN0LmdldENlbnRlclkoKSAtIG5vZGVUb0Nvbm5lY3QuZ2V0SGVpZ2h0KCkgLyAyIC0gRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9FREdFX0xFTkdUSCAtIHBydW5lZE5vZGUuZ2V0SGVpZ2h0KCkgLyAyKTtcbiAgfSBlbHNlIGlmIChncmlkRm9yUHJ1bmVkTm9kZSA9PSAxKSB7XG4gICAgcHJ1bmVkTm9kZS5zZXRDZW50ZXIobm9kZVRvQ29ubmVjdC5nZXRDZW50ZXJYKCkgKyBub2RlVG9Db25uZWN0LmdldFdpZHRoKCkgLyAyICsgRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9FREdFX0xFTkdUSCArIHBydW5lZE5vZGUuZ2V0V2lkdGgoKSAvIDIsIG5vZGVUb0Nvbm5lY3QuZ2V0Q2VudGVyWSgpKTtcbiAgfSBlbHNlIGlmIChncmlkRm9yUHJ1bmVkTm9kZSA9PSAyKSB7XG4gICAgcHJ1bmVkTm9kZS5zZXRDZW50ZXIobm9kZVRvQ29ubmVjdC5nZXRDZW50ZXJYKCksIG5vZGVUb0Nvbm5lY3QuZ2V0Q2VudGVyWSgpICsgbm9kZVRvQ29ubmVjdC5nZXRIZWlnaHQoKSAvIDIgKyBGRExheW91dENvbnN0YW50cy5ERUZBVUxUX0VER0VfTEVOR1RIICsgcHJ1bmVkTm9kZS5nZXRIZWlnaHQoKSAvIDIpO1xuICB9IGVsc2Uge1xuICAgIHBydW5lZE5vZGUuc2V0Q2VudGVyKG5vZGVUb0Nvbm5lY3QuZ2V0Q2VudGVyWCgpIC0gbm9kZVRvQ29ubmVjdC5nZXRXaWR0aCgpIC8gMiAtIEZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfRURHRV9MRU5HVEggLSBwcnVuZWROb2RlLmdldFdpZHRoKCkgLyAyLCBub2RlVG9Db25uZWN0LmdldENlbnRlclkoKSk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ29TRUxheW91dDtcblxuLyoqKi8gfSksXG4vKiA3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBjb3NlQmFzZSA9IHt9O1xuXG5jb3NlQmFzZS5sYXlvdXRCYXNlID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbmNvc2VCYXNlLkNvU0VDb25zdGFudHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuY29zZUJhc2UuQ29TRUVkZ2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuY29zZUJhc2UuQ29TRUdyYXBoID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcbmNvc2VCYXNlLkNvU0VHcmFwaE1hbmFnZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuY29zZUJhc2UuQ29TRUxheW91dCA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XG5jb3NlQmFzZS5Db1NFTm9kZSA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG5cbm1vZHVsZS5leHBvcnRzID0gY29zZUJhc2U7XG5cbi8qKiovIH0pXG4vKioqKioqLyBdKTtcbn0pOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/cose-base/cose-base.js\n"));

/***/ }),

/***/ "./node_modules/cytoscape-cose-bilkent/cytoscape-cose-bilkent.js":
/*!***********************************************************************!*\
  !*** ./node_modules/cytoscape-cose-bilkent/cytoscape-cose-bilkent.js ***!
  \***********************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("(function webpackUniversalModuleDefinition(root, factory) {\n\tif(true)\n\t\tmodule.exports = factory(__webpack_require__(/*! cose-base */ \"./node_modules/cose-base/cose-base.js\"));\n\telse {}\n})(this, function(__WEBPACK_EXTERNAL_MODULE_0__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __nested_webpack_require_659__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_659__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__nested_webpack_require_659__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__nested_webpack_require_659__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__nested_webpack_require_659__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__nested_webpack_require_659__.d = function(exports, name, getter) {\n/******/ \t\tif(!__nested_webpack_require_659__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__nested_webpack_require_659__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__nested_webpack_require_659__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__nested_webpack_require_659__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__nested_webpack_require_659__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __nested_webpack_require_659__(__nested_webpack_require_659__.s = 1);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports) {\n\nmodule.exports = __WEBPACK_EXTERNAL_MODULE_0__;\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __nested_webpack_require_3201__) {\n\n\"use strict\";\n\n\nvar LayoutConstants = __nested_webpack_require_3201__(0).layoutBase.LayoutConstants;\nvar FDLayoutConstants = __nested_webpack_require_3201__(0).layoutBase.FDLayoutConstants;\nvar CoSEConstants = __nested_webpack_require_3201__(0).CoSEConstants;\nvar CoSELayout = __nested_webpack_require_3201__(0).CoSELayout;\nvar CoSENode = __nested_webpack_require_3201__(0).CoSENode;\nvar PointD = __nested_webpack_require_3201__(0).layoutBase.PointD;\nvar DimensionD = __nested_webpack_require_3201__(0).layoutBase.DimensionD;\n\nvar defaults = {\n  // Called on `layoutready`\n  ready: function ready() {},\n  // Called on `layoutstop`\n  stop: function stop() {},\n  // 'draft', 'default' or 'proof\" \n  // - 'draft' fast cooling rate \n  // - 'default' moderate cooling rate \n  // - \"proof\" slow cooling rate\n  quality: 'default',\n  // include labels in node dimensions\n  nodeDimensionsIncludeLabels: false,\n  // number of ticks per frame; higher is faster but more jerky\n  refresh: 30,\n  // Whether to fit the network view after when done\n  fit: true,\n  // Padding on fit\n  padding: 10,\n  // Whether to enable incremental mode\n  randomize: true,\n  // Node repulsion (non overlapping) multiplier\n  nodeRepulsion: 4500,\n  // Ideal edge (non nested) length\n  idealEdgeLength: 50,\n  // Divisor to compute edge forces\n  edgeElasticity: 0.45,\n  // Nesting factor (multiplier) to compute ideal edge length for nested edges\n  nestingFactor: 0.1,\n  // Gravity force (constant)\n  gravity: 0.25,\n  // Maximum number of iterations to perform\n  numIter: 2500,\n  // For enabling tiling\n  tile: true,\n  // Type of layout animation. The option set is {'during', 'end', false}\n  animate: 'end',\n  // Duration for animate:end\n  animationDuration: 500,\n  // Represents the amount of the vertical space to put between the zero degree members during the tiling operation(can also be a function)\n  tilingPaddingVertical: 10,\n  // Represents the amount of the horizontal space to put between the zero degree members during the tiling operation(can also be a function)\n  tilingPaddingHorizontal: 10,\n  // Gravity range (constant) for compounds\n  gravityRangeCompound: 1.5,\n  // Gravity force (constant) for compounds\n  gravityCompound: 1.0,\n  // Gravity range (constant)\n  gravityRange: 3.8,\n  // Initial cooling factor for incremental layout\n  initialEnergyOnIncremental: 0.5\n};\n\nfunction extend(defaults, options) {\n  var obj = {};\n\n  for (var i in defaults) {\n    obj[i] = defaults[i];\n  }\n\n  for (var i in options) {\n    obj[i] = options[i];\n  }\n\n  return obj;\n};\n\nfunction _CoSELayout(_options) {\n  this.options = extend(defaults, _options);\n  getUserOptions(this.options);\n}\n\nvar getUserOptions = function getUserOptions(options) {\n  if (options.nodeRepulsion != null) CoSEConstants.DEFAULT_REPULSION_STRENGTH = FDLayoutConstants.DEFAULT_REPULSION_STRENGTH = options.nodeRepulsion;\n  if (options.idealEdgeLength != null) CoSEConstants.DEFAULT_EDGE_LENGTH = FDLayoutConstants.DEFAULT_EDGE_LENGTH = options.idealEdgeLength;\n  if (options.edgeElasticity != null) CoSEConstants.DEFAULT_SPRING_STRENGTH = FDLayoutConstants.DEFAULT_SPRING_STRENGTH = options.edgeElasticity;\n  if (options.nestingFactor != null) CoSEConstants.PER_LEVEL_IDEAL_EDGE_LENGTH_FACTOR = FDLayoutConstants.PER_LEVEL_IDEAL_EDGE_LENGTH_FACTOR = options.nestingFactor;\n  if (options.gravity != null) CoSEConstants.DEFAULT_GRAVITY_STRENGTH = FDLayoutConstants.DEFAULT_GRAVITY_STRENGTH = options.gravity;\n  if (options.numIter != null) CoSEConstants.MAX_ITERATIONS = FDLayoutConstants.MAX_ITERATIONS = options.numIter;\n  if (options.gravityRange != null) CoSEConstants.DEFAULT_GRAVITY_RANGE_FACTOR = FDLayoutConstants.DEFAULT_GRAVITY_RANGE_FACTOR = options.gravityRange;\n  if (options.gravityCompound != null) CoSEConstants.DEFAULT_COMPOUND_GRAVITY_STRENGTH = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_STRENGTH = options.gravityCompound;\n  if (options.gravityRangeCompound != null) CoSEConstants.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR = options.gravityRangeCompound;\n  if (options.initialEnergyOnIncremental != null) CoSEConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL = options.initialEnergyOnIncremental;\n\n  if (options.quality == 'draft') LayoutConstants.QUALITY = 0;else if (options.quality == 'proof') LayoutConstants.QUALITY = 2;else LayoutConstants.QUALITY = 1;\n\n  CoSEConstants.NODE_DIMENSIONS_INCLUDE_LABELS = FDLayoutConstants.NODE_DIMENSIONS_INCLUDE_LABELS = LayoutConstants.NODE_DIMENSIONS_INCLUDE_LABELS = options.nodeDimensionsIncludeLabels;\n  CoSEConstants.DEFAULT_INCREMENTAL = FDLayoutConstants.DEFAULT_INCREMENTAL = LayoutConstants.DEFAULT_INCREMENTAL = !options.randomize;\n  CoSEConstants.ANIMATE = FDLayoutConstants.ANIMATE = LayoutConstants.ANIMATE = options.animate;\n  CoSEConstants.TILE = options.tile;\n  CoSEConstants.TILING_PADDING_VERTICAL = typeof options.tilingPaddingVertical === 'function' ? options.tilingPaddingVertical.call() : options.tilingPaddingVertical;\n  CoSEConstants.TILING_PADDING_HORIZONTAL = typeof options.tilingPaddingHorizontal === 'function' ? options.tilingPaddingHorizontal.call() : options.tilingPaddingHorizontal;\n};\n\n_CoSELayout.prototype.run = function () {\n  var ready;\n  var frameId;\n  var options = this.options;\n  var idToLNode = this.idToLNode = {};\n  var layout = this.layout = new CoSELayout();\n  var self = this;\n\n  self.stopped = false;\n\n  this.cy = this.options.cy;\n\n  this.cy.trigger({ type: 'layoutstart', layout: this });\n\n  var gm = layout.newGraphManager();\n  this.gm = gm;\n\n  var nodes = this.options.eles.nodes();\n  var edges = this.options.eles.edges();\n\n  this.root = gm.addRoot();\n  this.processChildrenList(this.root, this.getTopMostNodes(nodes), layout);\n\n  for (var i = 0; i < edges.length; i++) {\n    var edge = edges[i];\n    var sourceNode = this.idToLNode[edge.data(\"source\")];\n    var targetNode = this.idToLNode[edge.data(\"target\")];\n    if (sourceNode !== targetNode && sourceNode.getEdgesBetween(targetNode).length == 0) {\n      var e1 = gm.add(layout.newEdge(), sourceNode, targetNode);\n      e1.id = edge.id();\n    }\n  }\n\n  var getPositions = function getPositions(ele, i) {\n    if (typeof ele === \"number\") {\n      ele = i;\n    }\n    var theId = ele.data('id');\n    var lNode = self.idToLNode[theId];\n\n    return {\n      x: lNode.getRect().getCenterX(),\n      y: lNode.getRect().getCenterY()\n    };\n  };\n\n  /*\n   * Reposition nodes in iterations animatedly\n   */\n  var iterateAnimated = function iterateAnimated() {\n    // Thigs to perform after nodes are repositioned on screen\n    var afterReposition = function afterReposition() {\n      if (options.fit) {\n        options.cy.fit(options.eles, options.padding);\n      }\n\n      if (!ready) {\n        ready = true;\n        self.cy.one('layoutready', options.ready);\n        self.cy.trigger({ type: 'layoutready', layout: self });\n      }\n    };\n\n    var ticksPerFrame = self.options.refresh;\n    var isDone;\n\n    for (var i = 0; i < ticksPerFrame && !isDone; i++) {\n      isDone = self.stopped || self.layout.tick();\n    }\n\n    // If layout is done\n    if (isDone) {\n      // If the layout is not a sublayout and it is successful perform post layout.\n      if (layout.checkLayoutSuccess() && !layout.isSubLayout) {\n        layout.doPostLayout();\n      }\n\n      // If layout has a tilingPostLayout function property call it.\n      if (layout.tilingPostLayout) {\n        layout.tilingPostLayout();\n      }\n\n      layout.isLayoutFinished = true;\n\n      self.options.eles.nodes().positions(getPositions);\n\n      afterReposition();\n\n      // trigger layoutstop when the layout stops (e.g. finishes)\n      self.cy.one('layoutstop', self.options.stop);\n      self.cy.trigger({ type: 'layoutstop', layout: self });\n\n      if (frameId) {\n        cancelAnimationFrame(frameId);\n      }\n\n      ready = false;\n      return;\n    }\n\n    var animationData = self.layout.getPositionsData(); // Get positions of layout nodes note that all nodes may not be layout nodes because of tiling\n\n    // Position nodes, for the nodes whose id does not included in data (because they are removed from their parents and included in dummy compounds)\n    // use position of their ancestors or dummy ancestors\n    options.eles.nodes().positions(function (ele, i) {\n      if (typeof ele === \"number\") {\n        ele = i;\n      }\n      // If ele is a compound node, then its position will be defined by its children\n      if (!ele.isParent()) {\n        var theId = ele.id();\n        var pNode = animationData[theId];\n        var temp = ele;\n        // If pNode is undefined search until finding position data of its first ancestor (It may be dummy as well)\n        while (pNode == null) {\n          pNode = animationData[temp.data('parent')] || animationData['DummyCompound_' + temp.data('parent')];\n          animationData[theId] = pNode;\n          temp = temp.parent()[0];\n          if (temp == undefined) {\n            break;\n          }\n        }\n        if (pNode != null) {\n          return {\n            x: pNode.x,\n            y: pNode.y\n          };\n        } else {\n          return {\n            x: ele.position('x'),\n            y: ele.position('y')\n          };\n        }\n      }\n    });\n\n    afterReposition();\n\n    frameId = requestAnimationFrame(iterateAnimated);\n  };\n\n  /*\n  * Listen 'layoutstarted' event and start animated iteration if animate option is 'during'\n  */\n  layout.addListener('layoutstarted', function () {\n    if (self.options.animate === 'during') {\n      frameId = requestAnimationFrame(iterateAnimated);\n    }\n  });\n\n  layout.runLayout(); // Run cose layout\n\n  /*\n   * If animate option is not 'during' ('end' or false) perform these here (If it is 'during' similar things are already performed)\n   */\n  if (this.options.animate !== \"during\") {\n    self.options.eles.nodes().not(\":parent\").layoutPositions(self, self.options, getPositions); // Use layout positions to reposition the nodes it considers the options parameter\n    ready = false;\n  }\n\n  return this; // chaining\n};\n\n//Get the top most ones of a list of nodes\n_CoSELayout.prototype.getTopMostNodes = function (nodes) {\n  var nodesMap = {};\n  for (var i = 0; i < nodes.length; i++) {\n    nodesMap[nodes[i].id()] = true;\n  }\n  var roots = nodes.filter(function (ele, i) {\n    if (typeof ele === \"number\") {\n      ele = i;\n    }\n    var parent = ele.parent()[0];\n    while (parent != null) {\n      if (nodesMap[parent.id()]) {\n        return false;\n      }\n      parent = parent.parent()[0];\n    }\n    return true;\n  });\n\n  return roots;\n};\n\n_CoSELayout.prototype.processChildrenList = function (parent, children, layout) {\n  var size = children.length;\n  for (var i = 0; i < size; i++) {\n    var theChild = children[i];\n    var children_of_children = theChild.children();\n    var theNode;\n\n    var dimensions = theChild.layoutDimensions({\n      nodeDimensionsIncludeLabels: this.options.nodeDimensionsIncludeLabels\n    });\n\n    if (theChild.outerWidth() != null && theChild.outerHeight() != null) {\n      theNode = parent.add(new CoSENode(layout.graphManager, new PointD(theChild.position('x') - dimensions.w / 2, theChild.position('y') - dimensions.h / 2), new DimensionD(parseFloat(dimensions.w), parseFloat(dimensions.h))));\n    } else {\n      theNode = parent.add(new CoSENode(this.graphManager));\n    }\n    // Attach id to the layout node\n    theNode.id = theChild.data(\"id\");\n    // Attach the paddings of cy node to layout node\n    theNode.paddingLeft = parseInt(theChild.css('padding'));\n    theNode.paddingTop = parseInt(theChild.css('padding'));\n    theNode.paddingRight = parseInt(theChild.css('padding'));\n    theNode.paddingBottom = parseInt(theChild.css('padding'));\n\n    //Attach the label properties to compound if labels will be included in node dimensions  \n    if (this.options.nodeDimensionsIncludeLabels) {\n      if (theChild.isParent()) {\n        var labelWidth = theChild.boundingBox({ includeLabels: true, includeNodes: false }).w;\n        var labelHeight = theChild.boundingBox({ includeLabels: true, includeNodes: false }).h;\n        var labelPos = theChild.css(\"text-halign\");\n        theNode.labelWidth = labelWidth;\n        theNode.labelHeight = labelHeight;\n        theNode.labelPos = labelPos;\n      }\n    }\n\n    // Map the layout node\n    this.idToLNode[theChild.data(\"id\")] = theNode;\n\n    if (isNaN(theNode.rect.x)) {\n      theNode.rect.x = 0;\n    }\n\n    if (isNaN(theNode.rect.y)) {\n      theNode.rect.y = 0;\n    }\n\n    if (children_of_children != null && children_of_children.length > 0) {\n      var theNewGraph;\n      theNewGraph = layout.getGraphManager().add(layout.newGraph(), theNode);\n      this.processChildrenList(theNewGraph, children_of_children, layout);\n    }\n  }\n};\n\n/**\n * @brief : called on continuous layouts to stop them before they finish\n */\n_CoSELayout.prototype.stop = function () {\n  this.stopped = true;\n\n  return this; // chaining\n};\n\nvar register = function register(cytoscape) {\n  //  var Layout = getLayout( cytoscape );\n\n  cytoscape('layout', 'cose-bilkent', _CoSELayout);\n};\n\n// auto reg for globals\nif (typeof cytoscape !== 'undefined') {\n  register(cytoscape);\n}\n\nmodule.exports = register;\n\n/***/ })\n/******/ ]);\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY3l0b3NjYXBlLWNvc2UtYmlsa2VudC9jeXRvc2NhcGUtY29zZS1iaWxrZW50LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0EsSUFBSSxJQUF5RDtBQUM3RCwyQkFBMkIsbUJBQU8sQ0FBQyx3REFBVztBQUM5QyxNQUFNLEVBS3FEO0FBQzNELENBQUM7QUFDRCxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsOEJBQW1CO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEVBQTBFLDhCQUFtQjtBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsOEJBQW1CO0FBQzdCO0FBQ0E7QUFDQSxVQUFVLDhCQUFtQjtBQUM3QjtBQUNBO0FBQ0EsVUFBVSw4QkFBbUIsdUJBQXVCO0FBQ3BEO0FBQ0E7QUFDQSxVQUFVLDhCQUFtQjtBQUM3QixlQUFlLDhCQUFtQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsOEJBQW1CO0FBQzdCO0FBQ0Esb0NBQW9DLDRCQUE0QjtBQUNoRSwwQ0FBMEM7QUFDMUMsV0FBVyw4QkFBbUI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDhCQUFtQixrQ0FBa0M7QUFDL0Q7QUFDQTtBQUNBLFVBQVUsOEJBQW1CO0FBQzdCO0FBQ0E7QUFDQSxpQkFBaUIsOEJBQW1CLENBQUMsOEJBQW1CO0FBQ3hELFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQSxpQ0FBaUMsK0JBQW1COztBQUVwRDs7O0FBR0Esc0JBQXNCLCtCQUFtQjtBQUN6Qyx3QkFBd0IsK0JBQW1CO0FBQzNDLG9CQUFvQiwrQkFBbUI7QUFDdkMsaUJBQWlCLCtCQUFtQjtBQUNwQyxlQUFl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Zjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsT0FBTztBQUNQO0FBQ0EsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvY3l0b3NjYXBlLWNvc2UtYmlsa2VudC9jeXRvc2NhcGUtY29zZS1iaWxrZW50LmpzPzBhMTQiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKFwiY29zZS1iYXNlXCIpKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFtcImNvc2UtYmFzZVwiXSwgZmFjdG9yeSk7XG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJjeXRvc2NhcGVDb3NlQmlsa2VudFwiXSA9IGZhY3RvcnkocmVxdWlyZShcImNvc2UtYmFzZVwiKSk7XG5cdGVsc2Vcblx0XHRyb290W1wiY3l0b3NjYXBlQ29zZUJpbGtlbnRcIl0gPSBmYWN0b3J5KHJvb3RbXCJjb3NlQmFzZVwiXSk7XG59KSh0aGlzLCBmdW5jdGlvbihfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzBfXykge1xucmV0dXJuIC8qKioqKiovIChmdW5jdGlvbihtb2R1bGVzKSB7IC8vIHdlYnBhY2tCb290c3RyYXBcbi8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbi8qKioqKiovIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbi8qKioqKiovIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4vKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gXHRcdFx0aTogbW9kdWxlSWQsXG4vKioqKioqLyBcdFx0XHRsOiBmYWxzZSxcbi8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9XG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4vKioqKioqLyBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbi8qKioqKiovIFx0XHRtb2R1bGUubCA9IHRydWU7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4vKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHR9XG4vKioqKioqL1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBpZGVudGl0eSBmdW5jdGlvbiBmb3IgY2FsbGluZyBoYXJtb255IGltcG9ydHMgd2l0aCB0aGUgY29ycmVjdCBjb250ZXh0XG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uaSA9IGZ1bmN0aW9uKHZhbHVlKSB7IHJldHVybiB2YWx1ZTsgfTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbi8qKioqKiovIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4vKioqKioqLyBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwge1xuLyoqKioqKi8gXHRcdFx0XHRjb25maWd1cmFibGU6IGZhbHNlLFxuLyoqKioqKi8gXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuLyoqKioqKi8gXHRcdFx0XHRnZXQ6IGdldHRlclxuLyoqKioqKi8gXHRcdFx0fSk7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4vKioqKioqLyBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4vKioqKioqLyBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuLyoqKioqKi8gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4vKioqKioqLyBcdFx0cmV0dXJuIGdldHRlcjtcbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4vKioqKioqLyBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IDEpO1xuLyoqKioqKi8gfSlcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyAoW1xuLyogMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfMF9fO1xuXG4vKioqLyB9KSxcbi8qIDEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIExheW91dENvbnN0YW50cyA9IF9fd2VicGFja19yZXF1aXJlX18oMCkubGF5b3V0QmFzZS5MYXlvdXRDb25zdGFudHM7XG52YXIgRkRMYXlvdXRDb25zdGFudHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApLmxheW91dEJhc2UuRkRMYXlvdXRDb25zdGFudHM7XG52YXIgQ29TRUNvbnN0YW50cyA9IF9fd2VicGFja19yZXF1aXJlX18oMCkuQ29TRUNvbnN0YW50cztcbnZhciBDb1NFTGF5b3V0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKS5Db1NFTGF5b3V0O1xudmFyIENvU0VOb2RlID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKS5Db1NFTm9kZTtcbnZhciBQb2ludEQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApLmxheW91dEJhc2UuUG9pbnREO1xudmFyIERpbWVuc2lvbkQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApLmxheW91dEJhc2UuRGltZW5zaW9uRDtcblxudmFyIGRlZmF1bHRzID0ge1xuICAvLyBDYWxsZWQgb24gYGxheW91dHJlYWR5YFxuICByZWFkeTogZnVuY3Rpb24gcmVhZHkoKSB7fSxcbiAgLy8gQ2FsbGVkIG9uIGBsYXlvdXRzdG9wYFxuICBzdG9wOiBmdW5jdGlvbiBzdG9wKCkge30sXG4gIC8vICdkcmFmdCcsICdkZWZhdWx0JyBvciAncHJvb2ZcIiBcbiAgLy8gLSAnZHJhZnQnIGZhc3QgY29vbGluZyByYXRlIFxuICAvLyAtICdkZWZhdWx0JyBtb2RlcmF0ZSBjb29saW5nIHJhdGUgXG4gIC8vIC0gXCJwcm9vZlwiIHNsb3cgY29vbGluZyByYXRlXG4gIHF1YWxpdHk6ICdkZWZhdWx0JyxcbiAgLy8gaW5jbHVkZSBsYWJlbHMgaW4gbm9kZSBkaW1lbnNpb25zXG4gIG5vZGVEaW1lbnNpb25zSW5jbHVkZUxhYmVsczogZmFsc2UsXG4gIC8vIG51bWJlciBvZiB0aWNrcyBwZXIgZnJhbWU7IGhpZ2hlciBpcyBmYXN0ZXIgYnV0IG1vcmUgamVya3lcbiAgcmVmcmVzaDogMzAsXG4gIC8vIFdoZXRoZXIgdG8gZml0IHRoZSBuZXR3b3JrIHZpZXcgYWZ0ZXIgd2hlbiBkb25lXG4gIGZpdDogdHJ1ZSxcbiAgLy8gUGFkZGluZyBvbiBmaXRcbiAgcGFkZGluZzogMTAsXG4gIC8vIFdoZXRoZXIgdG8gZW5hYmxlIGluY3JlbWVudGFsIG1vZGVcbiAgcmFuZG9taXplOiB0cnVlLFxuICAvLyBOb2RlIHJlcHVsc2lvbiAobm9uIG92ZXJsYXBwaW5nKSBtdWx0aXBsaWVyXG4gIG5vZGVSZXB1bHNpb246IDQ1MDAsXG4gIC8vIElkZWFsIGVkZ2UgKG5vbiBuZXN0ZWQpIGxlbmd0aFxuICBpZGVhbEVkZ2VMZW5ndGg6IDUwLFxuICAvLyBEaXZpc29yIHRvIGNvbXB1dGUgZWRnZSBmb3JjZXNcbiAgZWRnZUVsYXN0aWNpdHk6IDAuNDUsXG4gIC8vIE5lc3RpbmcgZmFjdG9yIChtdWx0aXBsaWVyKSB0byBjb21wdXRlIGlkZWFsIGVkZ2UgbGVuZ3RoIGZvciBuZXN0ZWQgZWRnZXNcbiAgbmVzdGluZ0ZhY3RvcjogMC4xLFxuICAvLyBHcmF2aXR5IGZvcmNlIChjb25zdGFudClcbiAgZ3Jhdml0eTogMC4yNSxcbiAgLy8gTWF4aW11bSBudW1iZXIgb2YgaXRlcmF0aW9ucyB0byBwZXJmb3JtXG4gIG51bUl0ZXI6IDI1MDAsXG4gIC8vIEZvciBlbmFibGluZyB0aWxpbmdcbiAgdGlsZTogdHJ1ZSxcbiAgLy8gVHlwZSBvZiBsYXlvdXQgYW5pbWF0aW9uLiBUaGUgb3B0aW9uIHNldCBpcyB7J2R1cmluZycsICdlbmQnLCBmYWxzZX1cbiAgYW5pbWF0ZTogJ2VuZCcsXG4gIC8vIER1cmF0aW9uIGZvciBhbmltYXRlOmVuZFxuICBhbmltYXRpb25EdXJhdGlvbjogNTAwLFxuICAvLyBSZXByZXNlbnRzIHRoZSBhbW91bnQgb2YgdGhlIHZlcnRpY2FsIHNwYWNlIHRvIHB1dCBiZXR3ZWVuIHRoZSB6ZXJvIGRlZ3JlZSBtZW1iZXJzIGR1cmluZyB0aGUgdGlsaW5nIG9wZXJhdGlvbihjYW4gYWxzbyBiZSBhIGZ1bmN0aW9uKVxuICB0aWxpbmdQYWRkaW5nVmVydGljYWw6IDEwLFxuICAvLyBSZXByZXNlbnRzIHRoZSBhbW91bnQgb2YgdGhlIGhvcml6b250YWwgc3BhY2UgdG8gcHV0IGJldHdlZW4gdGhlIHplcm8gZGVncmVlIG1lbWJlcnMgZHVyaW5nIHRoZSB0aWxpbmcgb3BlcmF0aW9uKGNhbiBhbHNvIGJlIGEgZnVuY3Rpb24pXG4gIHRpbGluZ1BhZGRpbmdIb3Jpem9udGFsOiAxMCxcbiAgLy8gR3Jhdml0eSByYW5nZSAoY29uc3RhbnQpIGZvciBjb21wb3VuZHNcbiAgZ3Jhdml0eVJhbmdlQ29tcG91bmQ6IDEuNSxcbiAgLy8gR3Jhdml0eSBmb3JjZSAoY29uc3RhbnQpIGZvciBjb21wb3VuZHNcbiAgZ3Jhdml0eUNvbXBvdW5kOiAxLjAsXG4gIC8vIEdyYXZpdHkgcmFuZ2UgKGNvbnN0YW50KVxuICBncmF2aXR5UmFuZ2U6IDMuOCxcbiAgLy8gSW5pdGlhbCBjb29saW5nIGZhY3RvciBmb3IgaW5jcmVtZW50YWwgbGF5b3V0XG4gIGluaXRpYWxFbmVyZ3lPbkluY3JlbWVudGFsOiAwLjVcbn07XG5cbmZ1bmN0aW9uIGV4dGVuZChkZWZhdWx0cywgb3B0aW9ucykge1xuICB2YXIgb2JqID0ge307XG5cbiAgZm9yICh2YXIgaSBpbiBkZWZhdWx0cykge1xuICAgIG9ialtpXSA9IGRlZmF1bHRzW2ldO1xuICB9XG5cbiAgZm9yICh2YXIgaSBpbiBvcHRpb25zKSB7XG4gICAgb2JqW2ldID0gb3B0aW9uc1tpXTtcbiAgfVxuXG4gIHJldHVybiBvYmo7XG59O1xuXG5mdW5jdGlvbiBfQ29TRUxheW91dChfb3B0aW9ucykge1xuICB0aGlzLm9wdGlvbnMgPSBleHRlbmQoZGVmYXVsdHMsIF9vcHRpb25zKTtcbiAgZ2V0VXNlck9wdGlvbnModGhpcy5vcHRpb25zKTtcbn1cblxudmFyIGdldFVzZXJPcHRpb25zID0gZnVuY3Rpb24gZ2V0VXNlck9wdGlvbnMob3B0aW9ucykge1xuICBpZiAob3B0aW9ucy5ub2RlUmVwdWxzaW9uICE9IG51bGwpIENvU0VDb25zdGFudHMuREVGQVVMVF9SRVBVTFNJT05fU1RSRU5HVEggPSBGRExheW91dENvbnN0YW50cy5ERUZBVUxUX1JFUFVMU0lPTl9TVFJFTkdUSCA9IG9wdGlvbnMubm9kZVJlcHVsc2lvbjtcbiAgaWYgKG9wdGlvbnMuaWRlYWxFZGdlTGVuZ3RoICE9IG51bGwpIENvU0VDb25zdGFudHMuREVGQVVMVF9FREdFX0xFTkdUSCA9IEZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfRURHRV9MRU5HVEggPSBvcHRpb25zLmlkZWFsRWRnZUxlbmd0aDtcbiAgaWYgKG9wdGlvbnMuZWRnZUVsYXN0aWNpdHkgIT0gbnVsbCkgQ29TRUNvbnN0YW50cy5ERUZBVUxUX1NQUklOR19TVFJFTkdUSCA9IEZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfU1BSSU5HX1NUUkVOR1RIID0gb3B0aW9ucy5lZGdlRWxhc3RpY2l0eTtcbiAgaWYgKG9wdGlvbnMubmVzdGluZ0ZhY3RvciAhPSBudWxsKSBDb1NFQ29uc3RhbnRzLlBFUl9MRVZFTF9JREVBTF9FREdFX0xFTkdUSF9GQUNUT1IgPSBGRExheW91dENvbnN0YW50cy5QRVJfTEVWRUxfSURFQUxfRURHRV9MRU5HVEhfRkFDVE9SID0gb3B0aW9ucy5uZXN0aW5nRmFjdG9yO1xuICBpZiAob3B0aW9ucy5ncmF2aXR5ICE9IG51bGwpIENvU0VDb25zdGFudHMuREVGQVVMVF9HUkFWSVRZX1NUUkVOR1RIID0gRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9HUkFWSVRZX1NUUkVOR1RIID0gb3B0aW9ucy5ncmF2aXR5O1xuICBpZiAob3B0aW9ucy5udW1JdGVyICE9IG51bGwpIENvU0VDb25zdGFudHMuTUFYX0lURVJBVElPTlMgPSBGRExheW91dENvbnN0YW50cy5NQVhfSVRFUkFUSU9OUyA9IG9wdGlvbnMubnVtSXRlcjtcbiAgaWYgKG9wdGlvbnMuZ3Jhdml0eVJhbmdlICE9IG51bGwpIENvU0VDb25zdGFudHMuREVGQVVMVF9HUkFWSVRZX1JBTkdFX0ZBQ1RPUiA9IEZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfR1JBVklUWV9SQU5HRV9GQUNUT1IgPSBvcHRpb25zLmdyYXZpdHlSYW5nZTtcbiAgaWYgKG9wdGlvbnMuZ3Jhdml0eUNvbXBvdW5kICE9IG51bGwpIENvU0VDb25zdGFudHMuREVGQVVMVF9DT01QT1VORF9HUkFWSVRZX1NUUkVOR1RIID0gRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9DT01QT1VORF9HUkFWSVRZX1NUUkVOR1RIID0gb3B0aW9ucy5ncmF2aXR5Q29tcG91bmQ7XG4gIGlmIChvcHRpb25zLmdyYXZpdHlSYW5nZUNvbXBvdW5kICE9IG51bGwpIENvU0VDb25zdGFudHMuREVGQVVMVF9DT01QT1VORF9HUkFWSVRZX1JBTkdFX0ZBQ1RPUiA9IEZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfQ09NUE9VTkRfR1JBVklUWV9SQU5HRV9GQUNUT1IgPSBvcHRpb25zLmdyYXZpdHlSYW5nZUNvbXBvdW5kO1xuICBpZiAob3B0aW9ucy5pbml0aWFsRW5lcmd5T25JbmNyZW1lbnRhbCAhPSBudWxsKSBDb1NFQ29uc3RhbnRzLkRFRkFVTFRfQ09PTElOR19GQUNUT1JfSU5DUkVNRU5UQUwgPSBGRExheW91dENvbnN0YW50cy5ERUZBVUxUX0NPT0xJTkdfRkFDVE9SX0lOQ1JFTUVOVEFMID0gb3B0aW9ucy5pbml0aWFsRW5lcmd5T25JbmNyZW1lbnRhbDtcblxuICBpZiAob3B0aW9ucy5xdWFsaXR5ID09ICdkcmFmdCcpIExheW91dENvbnN0YW50cy5RVUFMSVRZID0gMDtlbHNlIGlmIChvcHRpb25zLnF1YWxpdHkgPT0gJ3Byb29mJykgTGF5b3V0Q29uc3RhbnRzLlFVQUxJVFkgPSAyO2Vsc2UgTGF5b3V0Q29uc3RhbnRzLlFVQUxJVFkgPSAxO1xuXG4gIENvU0VDb25zdGFudHMuTk9ERV9ESU1FTlNJT05TX0lOQ0xVREVfTEFCRUxTID0gRkRMYXlvdXRDb25zdGFudHMuTk9ERV9ESU1FTlNJT05TX0lOQ0xVREVfTEFCRUxTID0gTGF5b3V0Q29uc3RhbnRzLk5PREVfRElNRU5TSU9OU19JTkNMVURFX0xBQkVMUyA9IG9wdGlvbnMubm9kZURpbWVuc2lvbnNJbmNsdWRlTGFiZWxzO1xuICBDb1NFQ29uc3RhbnRzLkRFRkFVTFRfSU5DUkVNRU5UQUwgPSBGRExheW91dENvbnN0YW50cy5ERUZBVUxUX0lOQ1JFTUVOVEFMID0gTGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfSU5DUkVNRU5UQUwgPSAhb3B0aW9ucy5yYW5kb21pemU7XG4gIENvU0VDb25zdGFudHMuQU5JTUFURSA9IEZETGF5b3V0Q29uc3RhbnRzLkFOSU1BVEUgPSBMYXlvdXRDb25zdGFudHMuQU5JTUFURSA9IG9wdGlvbnMuYW5pbWF0ZTtcbiAgQ29TRUNvbnN0YW50cy5USUxFID0gb3B0aW9ucy50aWxlO1xuICBDb1NFQ29uc3RhbnRzLlRJTElOR19QQURESU5HX1ZFUlRJQ0FMID0gdHlwZW9mIG9wdGlvbnMudGlsaW5nUGFkZGluZ1ZlcnRpY2FsID09PSAnZnVuY3Rpb24nID8gb3B0aW9ucy50aWxpbmdQYWRkaW5nVmVydGljYWwuY2FsbCgpIDogb3B0aW9ucy50aWxpbmdQYWRkaW5nVmVydGljYWw7XG4gIENvU0VDb25zdGFudHMuVElMSU5HX1BBRERJTkdfSE9SSVpPTlRBTCA9IHR5cGVvZiBvcHRpb25zLnRpbGluZ1BhZGRpbmdIb3Jpem9udGFsID09PSAnZnVuY3Rpb24nID8gb3B0aW9ucy50aWxpbmdQYWRkaW5nSG9yaXpvbnRhbC5jYWxsKCkgOiBvcHRpb25zLnRpbGluZ1BhZGRpbmdIb3Jpem9udGFsO1xufTtcblxuX0NvU0VMYXlvdXQucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHJlYWR5O1xuICB2YXIgZnJhbWVJZDtcbiAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gIHZhciBpZFRvTE5vZGUgPSB0aGlzLmlkVG9MTm9kZSA9IHt9O1xuICB2YXIgbGF5b3V0ID0gdGhpcy5sYXlvdXQgPSBuZXcgQ29TRUxheW91dCgpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgc2VsZi5zdG9wcGVkID0gZmFsc2U7XG5cbiAgdGhpcy5jeSA9IHRoaXMub3B0aW9ucy5jeTtcblxuICB0aGlzLmN5LnRyaWdnZXIoeyB0eXBlOiAnbGF5b3V0c3RhcnQnLCBsYXlvdXQ6IHRoaXMgfSk7XG5cbiAgdmFyIGdtID0gbGF5b3V0Lm5ld0dyYXBoTWFuYWdlcigpO1xuICB0aGlzLmdtID0gZ207XG5cbiAgdmFyIG5vZGVzID0gdGhpcy5vcHRpb25zLmVsZXMubm9kZXMoKTtcbiAgdmFyIGVkZ2VzID0gdGhpcy5vcHRpb25zLmVsZXMuZWRnZXMoKTtcblxuICB0aGlzLnJvb3QgPSBnbS5hZGRSb290KCk7XG4gIHRoaXMucHJvY2Vzc0NoaWxkcmVuTGlzdCh0aGlzLnJvb3QsIHRoaXMuZ2V0VG9wTW9zdE5vZGVzKG5vZGVzKSwgbGF5b3V0KTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGVkZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGVkZ2UgPSBlZGdlc1tpXTtcbiAgICB2YXIgc291cmNlTm9kZSA9IHRoaXMuaWRUb0xOb2RlW2VkZ2UuZGF0YShcInNvdXJjZVwiKV07XG4gICAgdmFyIHRhcmdldE5vZGUgPSB0aGlzLmlkVG9MTm9kZVtlZGdlLmRhdGEoXCJ0YXJnZXRcIildO1xuICAgIGlmIChzb3VyY2VOb2RlICE9PSB0YXJnZXROb2RlICYmIHNvdXJjZU5vZGUuZ2V0RWRnZXNCZXR3ZWVuKHRhcmdldE5vZGUpLmxlbmd0aCA9PSAwKSB7XG4gICAgICB2YXIgZTEgPSBnbS5hZGQobGF5b3V0Lm5ld0VkZ2UoKSwgc291cmNlTm9kZSwgdGFyZ2V0Tm9kZSk7XG4gICAgICBlMS5pZCA9IGVkZ2UuaWQoKTtcbiAgICB9XG4gIH1cblxuICB2YXIgZ2V0UG9zaXRpb25zID0gZnVuY3Rpb24gZ2V0UG9zaXRpb25zKGVsZSwgaSkge1xuICAgIGlmICh0eXBlb2YgZWxlID09PSBcIm51bWJlclwiKSB7XG4gICAgICBlbGUgPSBpO1xuICAgIH1cbiAgICB2YXIgdGhlSWQgPSBlbGUuZGF0YSgnaWQnKTtcbiAgICB2YXIgbE5vZGUgPSBzZWxmLmlkVG9MTm9kZVt0aGVJZF07XG5cbiAgICByZXR1cm4ge1xuICAgICAgeDogbE5vZGUuZ2V0UmVjdCgpLmdldENlbnRlclgoKSxcbiAgICAgIHk6IGxOb2RlLmdldFJlY3QoKS5nZXRDZW50ZXJZKClcbiAgICB9O1xuICB9O1xuXG4gIC8qXG4gICAqIFJlcG9zaXRpb24gbm9kZXMgaW4gaXRlcmF0aW9ucyBhbmltYXRlZGx5XG4gICAqL1xuICB2YXIgaXRlcmF0ZUFuaW1hdGVkID0gZnVuY3Rpb24gaXRlcmF0ZUFuaW1hdGVkKCkge1xuICAgIC8vIFRoaWdzIHRvIHBlcmZvcm0gYWZ0ZXIgbm9kZXMgYXJlIHJlcG9zaXRpb25lZCBvbiBzY3JlZW5cbiAgICB2YXIgYWZ0ZXJSZXBvc2l0aW9uID0gZnVuY3Rpb24gYWZ0ZXJSZXBvc2l0aW9uKCkge1xuICAgICAgaWYgKG9wdGlvbnMuZml0KSB7XG4gICAgICAgIG9wdGlvbnMuY3kuZml0KG9wdGlvbnMuZWxlcywgb3B0aW9ucy5wYWRkaW5nKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFyZWFkeSkge1xuICAgICAgICByZWFkeSA9IHRydWU7XG4gICAgICAgIHNlbGYuY3kub25lKCdsYXlvdXRyZWFkeScsIG9wdGlvbnMucmVhZHkpO1xuICAgICAgICBzZWxmLmN5LnRyaWdnZXIoeyB0eXBlOiAnbGF5b3V0cmVhZHknLCBsYXlvdXQ6IHNlbGYgfSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciB0aWNrc1BlckZyYW1lID0gc2VsZi5vcHRpb25zLnJlZnJlc2g7XG4gICAgdmFyIGlzRG9uZTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGlja3NQZXJGcmFtZSAmJiAhaXNEb25lOyBpKyspIHtcbiAgICAgIGlzRG9uZSA9IHNlbGYuc3RvcHBlZCB8fCBzZWxmLmxheW91dC50aWNrKCk7XG4gICAgfVxuXG4gICAgLy8gSWYgbGF5b3V0IGlzIGRvbmVcbiAgICBpZiAoaXNEb25lKSB7XG4gICAgICAvLyBJZiB0aGUgbGF5b3V0IGlzIG5vdCBhIHN1YmxheW91dCBhbmQgaXQgaXMgc3VjY2Vzc2Z1bCBwZXJmb3JtIHBvc3QgbGF5b3V0LlxuICAgICAgaWYgKGxheW91dC5jaGVja0xheW91dFN1Y2Nlc3MoKSAmJiAhbGF5b3V0LmlzU3ViTGF5b3V0KSB7XG4gICAgICAgIGxheW91dC5kb1Bvc3RMYXlvdXQoKTtcbiAgICAgIH1cblxuICAgICAgLy8gSWYgbGF5b3V0IGhhcyBhIHRpbGluZ1Bvc3RMYXlvdXQgZnVuY3Rpb24gcHJvcGVydHkgY2FsbCBpdC5cbiAgICAgIGlmIChsYXlvdXQudGlsaW5nUG9zdExheW91dCkge1xuICAgICAgICBsYXlvdXQudGlsaW5nUG9zdExheW91dCgpO1xuICAgICAgfVxuXG4gICAgICBsYXlvdXQuaXNMYXlvdXRGaW5pc2hlZCA9IHRydWU7XG5cbiAgICAgIHNlbGYub3B0aW9ucy5lbGVzLm5vZGVzKCkucG9zaXRpb25zKGdldFBvc2l0aW9ucyk7XG5cbiAgICAgIGFmdGVyUmVwb3NpdGlvbigpO1xuXG4gICAgICAvLyB0cmlnZ2VyIGxheW91dHN0b3Agd2hlbiB0aGUgbGF5b3V0IHN0b3BzIChlLmcuIGZpbmlzaGVzKVxuICAgICAgc2VsZi5jeS5vbmUoJ2xheW91dHN0b3AnLCBzZWxmLm9wdGlvbnMuc3RvcCk7XG4gICAgICBzZWxmLmN5LnRyaWdnZXIoeyB0eXBlOiAnbGF5b3V0c3RvcCcsIGxheW91dDogc2VsZiB9KTtcblxuICAgICAgaWYgKGZyYW1lSWQpIHtcbiAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUoZnJhbWVJZCk7XG4gICAgICB9XG5cbiAgICAgIHJlYWR5ID0gZmFsc2U7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGFuaW1hdGlvbkRhdGEgPSBzZWxmLmxheW91dC5nZXRQb3NpdGlvbnNEYXRhKCk7IC8vIEdldCBwb3NpdGlvbnMgb2YgbGF5b3V0IG5vZGVzIG5vdGUgdGhhdCBhbGwgbm9kZXMgbWF5IG5vdCBiZSBsYXlvdXQgbm9kZXMgYmVjYXVzZSBvZiB0aWxpbmdcblxuICAgIC8vIFBvc2l0aW9uIG5vZGVzLCBmb3IgdGhlIG5vZGVzIHdob3NlIGlkIGRvZXMgbm90IGluY2x1ZGVkIGluIGRhdGEgKGJlY2F1c2UgdGhleSBhcmUgcmVtb3ZlZCBmcm9tIHRoZWlyIHBhcmVudHMgYW5kIGluY2x1ZGVkIGluIGR1bW15IGNvbXBvdW5kcylcbiAgICAvLyB1c2UgcG9zaXRpb24gb2YgdGhlaXIgYW5jZXN0b3JzIG9yIGR1bW15IGFuY2VzdG9yc1xuICAgIG9wdGlvbnMuZWxlcy5ub2RlcygpLnBvc2l0aW9ucyhmdW5jdGlvbiAoZWxlLCBpKSB7XG4gICAgICBpZiAodHlwZW9mIGVsZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICBlbGUgPSBpO1xuICAgICAgfVxuICAgICAgLy8gSWYgZWxlIGlzIGEgY29tcG91bmQgbm9kZSwgdGhlbiBpdHMgcG9zaXRpb24gd2lsbCBiZSBkZWZpbmVkIGJ5IGl0cyBjaGlsZHJlblxuICAgICAgaWYgKCFlbGUuaXNQYXJlbnQoKSkge1xuICAgICAgICB2YXIgdGhlSWQgPSBlbGUuaWQoKTtcbiAgICAgICAgdmFyIHBOb2RlID0gYW5pbWF0aW9uRGF0YVt0aGVJZF07XG4gICAgICAgIHZhciB0ZW1wID0gZWxlO1xuICAgICAgICAvLyBJZiBwTm9kZSBpcyB1bmRlZmluZWQgc2VhcmNoIHVudGlsIGZpbmRpbmcgcG9zaXRpb24gZGF0YSBvZiBpdHMgZmlyc3QgYW5jZXN0b3IgKEl0IG1heSBiZSBkdW1teSBhcyB3ZWxsKVxuICAgICAgICB3aGlsZSAocE5vZGUgPT0gbnVsbCkge1xuICAgICAgICAgIHBOb2RlID0gYW5pbWF0aW9uRGF0YVt0ZW1wLmRhdGEoJ3BhcmVudCcpXSB8fCBhbmltYXRpb25EYXRhWydEdW1teUNvbXBvdW5kXycgKyB0ZW1wLmRhdGEoJ3BhcmVudCcpXTtcbiAgICAgICAgICBhbmltYXRpb25EYXRhW3RoZUlkXSA9IHBOb2RlO1xuICAgICAgICAgIHRlbXAgPSB0ZW1wLnBhcmVudCgpWzBdO1xuICAgICAgICAgIGlmICh0ZW1wID09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChwTm9kZSAhPSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHg6IHBOb2RlLngsXG4gICAgICAgICAgICB5OiBwTm9kZS55XG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeDogZWxlLnBvc2l0aW9uKCd4JyksXG4gICAgICAgICAgICB5OiBlbGUucG9zaXRpb24oJ3knKVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGFmdGVyUmVwb3NpdGlvbigpO1xuXG4gICAgZnJhbWVJZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShpdGVyYXRlQW5pbWF0ZWQpO1xuICB9O1xuXG4gIC8qXG4gICogTGlzdGVuICdsYXlvdXRzdGFydGVkJyBldmVudCBhbmQgc3RhcnQgYW5pbWF0ZWQgaXRlcmF0aW9uIGlmIGFuaW1hdGUgb3B0aW9uIGlzICdkdXJpbmcnXG4gICovXG4gIGxheW91dC5hZGRMaXN0ZW5lcignbGF5b3V0c3RhcnRlZCcsIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoc2VsZi5vcHRpb25zLmFuaW1hdGUgPT09ICdkdXJpbmcnKSB7XG4gICAgICBmcmFtZUlkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGl0ZXJhdGVBbmltYXRlZCk7XG4gICAgfVxuICB9KTtcblxuICBsYXlvdXQucnVuTGF5b3V0KCk7IC8vIFJ1biBjb3NlIGxheW91dFxuXG4gIC8qXG4gICAqIElmIGFuaW1hdGUgb3B0aW9uIGlzIG5vdCAnZHVyaW5nJyAoJ2VuZCcgb3IgZmFsc2UpIHBlcmZvcm0gdGhlc2UgaGVyZSAoSWYgaXQgaXMgJ2R1cmluZycgc2ltaWxhciB0aGluZ3MgYXJlIGFscmVhZHkgcGVyZm9ybWVkKVxuICAgKi9cbiAgaWYgKHRoaXMub3B0aW9ucy5hbmltYXRlICE9PSBcImR1cmluZ1wiKSB7XG4gICAgc2VsZi5vcHRpb25zLmVsZXMubm9kZXMoKS5ub3QoXCI6cGFyZW50XCIpLmxheW91dFBvc2l0aW9ucyhzZWxmLCBzZWxmLm9wdGlvbnMsIGdldFBvc2l0aW9ucyk7IC8vIFVzZSBsYXlvdXQgcG9zaXRpb25zIHRvIHJlcG9zaXRpb24gdGhlIG5vZGVzIGl0IGNvbnNpZGVycyB0aGUgb3B0aW9ucyBwYXJhbWV0ZXJcbiAgICByZWFkeSA9IGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG59O1xuXG4vL0dldCB0aGUgdG9wIG1vc3Qgb25lcyBvZiBhIGxpc3Qgb2Ygbm9kZXNcbl9Db1NFTGF5b3V0LnByb3RvdHlwZS5nZXRUb3BNb3N0Tm9kZXMgPSBmdW5jdGlvbiAobm9kZXMpIHtcbiAgdmFyIG5vZGVzTWFwID0ge307XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICBub2Rlc01hcFtub2Rlc1tpXS5pZCgpXSA9IHRydWU7XG4gIH1cbiAgdmFyIHJvb3RzID0gbm9kZXMuZmlsdGVyKGZ1bmN0aW9uIChlbGUsIGkpIHtcbiAgICBpZiAodHlwZW9mIGVsZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgZWxlID0gaTtcbiAgICB9XG4gICAgdmFyIHBhcmVudCA9IGVsZS5wYXJlbnQoKVswXTtcbiAgICB3aGlsZSAocGFyZW50ICE9IG51bGwpIHtcbiAgICAgIGlmIChub2Rlc01hcFtwYXJlbnQuaWQoKV0pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudCgpWzBdO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSk7XG5cbiAgcmV0dXJuIHJvb3RzO1xufTtcblxuX0NvU0VMYXlvdXQucHJvdG90eXBlLnByb2Nlc3NDaGlsZHJlbkxpc3QgPSBmdW5jdGlvbiAocGFyZW50LCBjaGlsZHJlbiwgbGF5b3V0KSB7XG4gIHZhciBzaXplID0gY2hpbGRyZW4ubGVuZ3RoO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKykge1xuICAgIHZhciB0aGVDaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgIHZhciBjaGlsZHJlbl9vZl9jaGlsZHJlbiA9IHRoZUNoaWxkLmNoaWxkcmVuKCk7XG4gICAgdmFyIHRoZU5vZGU7XG5cbiAgICB2YXIgZGltZW5zaW9ucyA9IHRoZUNoaWxkLmxheW91dERpbWVuc2lvbnMoe1xuICAgICAgbm9kZURpbWVuc2lvbnNJbmNsdWRlTGFiZWxzOiB0aGlzLm9wdGlvbnMubm9kZURpbWVuc2lvbnNJbmNsdWRlTGFiZWxzXG4gICAgfSk7XG5cbiAgICBpZiAodGhlQ2hpbGQub3V0ZXJXaWR0aCgpICE9IG51bGwgJiYgdGhlQ2hpbGQub3V0ZXJIZWlnaHQoKSAhPSBudWxsKSB7XG4gICAgICB0aGVOb2RlID0gcGFyZW50LmFkZChuZXcgQ29TRU5vZGUobGF5b3V0LmdyYXBoTWFuYWdlciwgbmV3IFBvaW50RCh0aGVDaGlsZC5wb3NpdGlvbigneCcpIC0gZGltZW5zaW9ucy53IC8gMiwgdGhlQ2hpbGQucG9zaXRpb24oJ3knKSAtIGRpbWVuc2lvbnMuaCAvIDIpLCBuZXcgRGltZW5zaW9uRChwYXJzZUZsb2F0KGRpbWVuc2lvbnMudyksIHBhcnNlRmxvYXQoZGltZW5zaW9ucy5oKSkpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhlTm9kZSA9IHBhcmVudC5hZGQobmV3IENvU0VOb2RlKHRoaXMuZ3JhcGhNYW5hZ2VyKSk7XG4gICAgfVxuICAgIC8vIEF0dGFjaCBpZCB0byB0aGUgbGF5b3V0IG5vZGVcbiAgICB0aGVOb2RlLmlkID0gdGhlQ2hpbGQuZGF0YShcImlkXCIpO1xuICAgIC8vIEF0dGFjaCB0aGUgcGFkZGluZ3Mgb2YgY3kgbm9kZSB0byBsYXlvdXQgbm9kZVxuICAgIHRoZU5vZGUucGFkZGluZ0xlZnQgPSBwYXJzZUludCh0aGVDaGlsZC5jc3MoJ3BhZGRpbmcnKSk7XG4gICAgdGhlTm9kZS5wYWRkaW5nVG9wID0gcGFyc2VJbnQodGhlQ2hpbGQuY3NzKCdwYWRkaW5nJykpO1xuICAgIHRoZU5vZGUucGFkZGluZ1JpZ2h0ID0gcGFyc2VJbnQodGhlQ2hpbGQuY3NzKCdwYWRkaW5nJykpO1xuICAgIHRoZU5vZGUucGFkZGluZ0JvdHRvbSA9IHBhcnNlSW50KHRoZUNoaWxkLmNzcygncGFkZGluZycpKTtcblxuICAgIC8vQXR0YWNoIHRoZSBsYWJlbCBwcm9wZXJ0aWVzIHRvIGNvbXBvdW5kIGlmIGxhYmVscyB3aWxsIGJlIGluY2x1ZGVkIGluIG5vZGUgZGltZW5zaW9ucyAgXG4gICAgaWYgKHRoaXMub3B0aW9ucy5ub2RlRGltZW5zaW9uc0luY2x1ZGVMYWJlbHMpIHtcbiAgICAgIGlmICh0aGVDaGlsZC5pc1BhcmVudCgpKSB7XG4gICAgICAgIHZhciBsYWJlbFdpZHRoID0gdGhlQ2hpbGQuYm91bmRpbmdCb3goeyBpbmNsdWRlTGFiZWxzOiB0cnVlLCBpbmNsdWRlTm9kZXM6IGZhbHNlIH0pLnc7XG4gICAgICAgIHZhciBsYWJlbEhlaWdodCA9IHRoZUNoaWxkLmJvdW5kaW5nQm94KHsgaW5jbHVkZUxhYmVsczogdHJ1ZSwgaW5jbHVkZU5vZGVzOiBmYWxzZSB9KS5oO1xuICAgICAgICB2YXIgbGFiZWxQb3MgPSB0aGVDaGlsZC5jc3MoXCJ0ZXh0LWhhbGlnblwiKTtcbiAgICAgICAgdGhlTm9kZS5sYWJlbFdpZHRoID0gbGFiZWxXaWR0aDtcbiAgICAgICAgdGhlTm9kZS5sYWJlbEhlaWdodCA9IGxhYmVsSGVpZ2h0O1xuICAgICAgICB0aGVOb2RlLmxhYmVsUG9zID0gbGFiZWxQb3M7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gTWFwIHRoZSBsYXlvdXQgbm9kZVxuICAgIHRoaXMuaWRUb0xOb2RlW3RoZUNoaWxkLmRhdGEoXCJpZFwiKV0gPSB0aGVOb2RlO1xuXG4gICAgaWYgKGlzTmFOKHRoZU5vZGUucmVjdC54KSkge1xuICAgICAgdGhlTm9kZS5yZWN0LnggPSAwO1xuICAgIH1cblxuICAgIGlmIChpc05hTih0aGVOb2RlLnJlY3QueSkpIHtcbiAgICAgIHRoZU5vZGUucmVjdC55ID0gMDtcbiAgICB9XG5cbiAgICBpZiAoY2hpbGRyZW5fb2ZfY2hpbGRyZW4gIT0gbnVsbCAmJiBjaGlsZHJlbl9vZl9jaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgICB2YXIgdGhlTmV3R3JhcGg7XG4gICAgICB0aGVOZXdHcmFwaCA9IGxheW91dC5nZXRHcmFwaE1hbmFnZXIoKS5hZGQobGF5b3V0Lm5ld0dyYXBoKCksIHRoZU5vZGUpO1xuICAgICAgdGhpcy5wcm9jZXNzQ2hpbGRyZW5MaXN0KHRoZU5ld0dyYXBoLCBjaGlsZHJlbl9vZl9jaGlsZHJlbiwgbGF5b3V0KTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogQGJyaWVmIDogY2FsbGVkIG9uIGNvbnRpbnVvdXMgbGF5b3V0cyB0byBzdG9wIHRoZW0gYmVmb3JlIHRoZXkgZmluaXNoXG4gKi9cbl9Db1NFTGF5b3V0LnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLnN0b3BwZWQgPSB0cnVlO1xuXG4gIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xufTtcblxudmFyIHJlZ2lzdGVyID0gZnVuY3Rpb24gcmVnaXN0ZXIoY3l0b3NjYXBlKSB7XG4gIC8vICB2YXIgTGF5b3V0ID0gZ2V0TGF5b3V0KCBjeXRvc2NhcGUgKTtcblxuICBjeXRvc2NhcGUoJ2xheW91dCcsICdjb3NlLWJpbGtlbnQnLCBfQ29TRUxheW91dCk7XG59O1xuXG4vLyBhdXRvIHJlZyBmb3IgZ2xvYmFsc1xuaWYgKHR5cGVvZiBjeXRvc2NhcGUgIT09ICd1bmRlZmluZWQnKSB7XG4gIHJlZ2lzdGVyKGN5dG9zY2FwZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcmVnaXN0ZXI7XG5cbi8qKiovIH0pXG4vKioqKioqLyBdKTtcbn0pOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/cytoscape-cose-bilkent/cytoscape-cose-bilkent.js\n"));

/***/ }),

/***/ "./node_modules/layout-base/layout-base.js":
/*!*************************************************!*\
  !*** ./node_modules/layout-base/layout-base.js ***!
  \*************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("(function webpackUniversalModuleDefinition(root, factory) {\n\tif(true)\n\t\tmodule.exports = factory();\n\telse {}\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __nested_webpack_require_543__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_543__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__nested_webpack_require_543__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__nested_webpack_require_543__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__nested_webpack_require_543__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__nested_webpack_require_543__.d = function(exports, name, getter) {\n/******/ \t\tif(!__nested_webpack_require_543__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__nested_webpack_require_543__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__nested_webpack_require_543__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__nested_webpack_require_543__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__nested_webpack_require_543__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __nested_webpack_require_543__(__nested_webpack_require_543__.s = 26);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nfunction LayoutConstants() {}\n\n/**\r\n * Layout Quality: 0:draft, 1:default, 2:proof\r\n */\nLayoutConstants.QUALITY = 1;\n\n/**\r\n * Default parameters\r\n */\nLayoutConstants.DEFAULT_CREATE_BENDS_AS_NEEDED = false;\nLayoutConstants.DEFAULT_INCREMENTAL = false;\nLayoutConstants.DEFAULT_ANIMATION_ON_LAYOUT = true;\nLayoutConstants.DEFAULT_ANIMATION_DURING_LAYOUT = false;\nLayoutConstants.DEFAULT_ANIMATION_PERIOD = 50;\nLayoutConstants.DEFAULT_UNIFORM_LEAF_NODE_SIZES = false;\n\n// -----------------------------------------------------------------------------\n// Section: General other constants\n// -----------------------------------------------------------------------------\n/*\r\n * Margins of a graph to be applied on bouding rectangle of its contents. We\r\n * assume margins on all four sides to be uniform.\r\n */\nLayoutConstants.DEFAULT_GRAPH_MARGIN = 15;\n\n/*\r\n * Whether to consider labels in node dimensions or not\r\n */\nLayoutConstants.NODE_DIMENSIONS_INCLUDE_LABELS = false;\n\n/*\r\n * Default dimension of a non-compound node.\r\n */\nLayoutConstants.SIMPLE_NODE_SIZE = 40;\n\n/*\r\n * Default dimension of a non-compound node.\r\n */\nLayoutConstants.SIMPLE_NODE_HALF_SIZE = LayoutConstants.SIMPLE_NODE_SIZE / 2;\n\n/*\r\n * Empty compound node size. When a compound node is empty, its both\r\n * dimensions should be of this value.\r\n */\nLayoutConstants.EMPTY_COMPOUND_NODE_SIZE = 40;\n\n/*\r\n * Minimum length that an edge should take during layout\r\n */\nLayoutConstants.MIN_EDGE_LENGTH = 1;\n\n/*\r\n * World boundaries that layout operates on\r\n */\nLayoutConstants.WORLD_BOUNDARY = 1000000;\n\n/*\r\n * World boundaries that random positioning can be performed with\r\n */\nLayoutConstants.INITIAL_WORLD_BOUNDARY = LayoutConstants.WORLD_BOUNDARY / 1000;\n\n/*\r\n * Coordinates of the world center\r\n */\nLayoutConstants.WORLD_CENTER_X = 1200;\nLayoutConstants.WORLD_CENTER_Y = 900;\n\nmodule.exports = LayoutConstants;\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __nested_webpack_require_4947__) {\n\n\"use strict\";\n\n\nvar LGraphObject = __nested_webpack_require_4947__(2);\nvar IGeometry = __nested_webpack_require_4947__(8);\nvar IMath = __nested_webpack_require_4947__(9);\n\nfunction LEdge(source, target, vEdge) {\n  LGraphObject.call(this, vEdge);\n\n  this.isOverlapingSourceAndTarget = false;\n  this.vGraphObject = vEdge;\n  this.bendpoints = [];\n  this.source = source;\n  this.target = target;\n}\n\nLEdge.prototype = Object.create(LGraphObject.prototype);\n\nfor (var prop in LGraphObject) {\n  LEdge[prop] = LGraphObject[prop];\n}\n\nLEdge.prototype.getSource = function () {\n  return this.source;\n};\n\nLEdge.prototype.getTarget = function () {\n  return this.target;\n};\n\nLEdge.prototype.isInterGraph = function () {\n  return this.isInterGraph;\n};\n\nLEdge.prototype.getLength = function () {\n  return this.length;\n};\n\nLEdge.prototype.isOverlapingSourceAndTarget = function () {\n  return this.isOverlapingSourceAndTarget;\n};\n\nLEdge.prototype.getBendpoints = function () {\n  return this.bendpoints;\n};\n\nLEdge.prototype.getLca = function () {\n  return this.lca;\n};\n\nLEdge.prototype.getSourceInLca = function () {\n  return this.sourceInLca;\n};\n\nLEdge.prototype.getTargetInLca = function () {\n  return this.targetInLca;\n};\n\nLEdge.prototype.getOtherEnd = function (node) {\n  if (this.source === node) {\n    return this.target;\n  } else if (this.target === node) {\n    return this.source;\n  } else {\n    throw \"Node is not incident with this edge\";\n  }\n};\n\nLEdge.prototype.getOtherEndInGraph = function (node, graph) {\n  var otherEnd = this.getOtherEnd(node);\n  var root = graph.getGraphManager().getRoot();\n\n  while (true) {\n    if (otherEnd.getOwner() == graph) {\n      return otherEnd;\n    }\n\n    if (otherEnd.getOwner() == root) {\n      break;\n    }\n\n    otherEnd = otherEnd.getOwner().getParent();\n  }\n\n  return null;\n};\n\nLEdge.prototype.updateLength = function () {\n  var clipPointCoordinates = new Array(4);\n\n  this.isOverlapingSourceAndTarget = IGeometry.getIntersection(this.target.getRect(), this.source.getRect(), clipPointCoordinates);\n\n  if (!this.isOverlapingSourceAndTarget) {\n    this.lengthX = clipPointCoordinates[0] - clipPointCoordinates[2];\n    this.lengthY = clipPointCoordinates[1] - clipPointCoordinates[3];\n\n    if (Math.abs(this.lengthX) < 1.0) {\n      this.lengthX = IMath.sign(this.lengthX);\n    }\n\n    if (Math.abs(this.lengthY) < 1.0) {\n      this.lengthY = IMath.sign(this.lengthY);\n    }\n\n    this.length = Math.sqrt(this.lengthX * this.lengthX + this.lengthY * this.lengthY);\n  }\n};\n\nLEdge.prototype.updateLengthSimple = function () {\n  this.lengthX = this.target.getCenterX() - this.source.getCenterX();\n  this.lengthY = this.target.getCenterY() - this.source.getCenterY();\n\n  if (Math.abs(this.lengthX) < 1.0) {\n    this.lengthX = IMath.sign(this.lengthX);\n  }\n\n  if (Math.abs(this.lengthY) < 1.0) {\n    this.lengthY = IMath.sign(this.lengthY);\n  }\n\n  this.length = Math.sqrt(this.lengthX * this.lengthX + this.lengthY * this.lengthY);\n};\n\nmodule.exports = LEdge;\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nfunction LGraphObject(vGraphObject) {\n  this.vGraphObject = vGraphObject;\n}\n\nmodule.exports = LGraphObject;\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __nested_webpack_require_8167__) {\n\n\"use strict\";\n\n\nvar LGraphObject = __nested_webpack_require_8167__(2);\nvar Integer = __nested_webpack_require_8167__(10);\nvar RectangleD = __nested_webpack_require_8167__(13);\nvar LayoutConstants = __nested_webpack_require_8167__(0);\nvar RandomSeed = __nested_webpack_require_8167__(16);\nvar PointD = __nested_webpack_require_8167__(4);\n\nfunction LNode(gm, loc, size, vNode) {\n  //Alternative constructor 1 : LNode(LGraphManager gm, Point loc, Dimension size, Object vNode)\n  if (size == null && vNode == null) {\n    vNode = loc;\n  }\n\n  LGraphObject.call(this, vNode);\n\n  //Alternative constructor 2 : LNode(Layout layout, Object vNode)\n  if (gm.graphManager != null) gm = gm.graphManager;\n\n  this.estimatedSize = Integer.MIN_VALUE;\n  this.inclusionTreeDepth = Integer.MAX_VALUE;\n  this.vGraphObject = vNode;\n  this.edges = [];\n  this.graphManager = gm;\n\n  if (size != null && loc != null) this.rect = new RectangleD(loc.x, loc.y, size.width, size.height);else this.rect = new RectangleD();\n}\n\nLNode.prototype = Object.create(LGraphObject.prototype);\nfor (var prop in LGraphObject) {\n  LNode[prop] = LGraphObject[prop];\n}\n\nLNode.prototype.getEdges = function () {\n  return this.edges;\n};\n\nLNode.prototype.getChild = function () {\n  return this.child;\n};\n\nLNode.prototype.getOwner = function () {\n  //  if (this.owner != null) {\n  //    if (!(this.owner == null || this.owner.getNodes().indexOf(this) > -1)) {\n  //      throw \"assert failed\";\n  //    }\n  //  }\n\n  return this.owner;\n};\n\nLNode.prototype.getWidth = function () {\n  return this.rect.width;\n};\n\nLNode.prototype.setWidth = function (width) {\n  this.rect.width = width;\n};\n\nLNode.prototype.getHeight = function () {\n  return this.rect.height;\n};\n\nLNode.prototype.setHeight = function (height) {\n  this.rect.height = height;\n};\n\nLNode.prototype.getCenterX = function () {\n  return this.rect.x + this.rect.width / 2;\n};\n\nLNode.prototype.getCenterY = function () {\n  return this.rect.y + this.rect.height / 2;\n};\n\nLNode.prototype.getCenter = function () {\n  return new PointD(this.rect.x + this.rect.width / 2, this.rect.y + this.rect.height / 2);\n};\n\nLNode.prototype.getLocation = function () {\n  return new PointD(this.rect.x, this.rect.y);\n};\n\nLNode.prototype.getRect = function () {\n  return this.rect;\n};\n\nLNode.prototype.getDiagonal = function () {\n  return Math.sqrt(this.rect.width * this.rect.width + this.rect.height * this.rect.height);\n};\n\n/**\n * This method returns half the diagonal length of this node.\n */\nLNode.prototype.getHalfTheDiagonal = function () {\n  return Math.sqrt(this.rect.height * this.rect.height + this.rect.width * this.rect.width) / 2;\n};\n\nLNode.prototype.setRect = function (upperLeft, dimension) {\n  this.rect.x = upperLeft.x;\n  this.rect.y = upperLeft.y;\n  this.rect.width = dimension.width;\n  this.rect.height = dimension.height;\n};\n\nLNode.prototype.setCenter = function (cx, cy) {\n  this.rect.x = cx - this.rect.width / 2;\n  this.rect.y = cy - this.rect.height / 2;\n};\n\nLNode.prototype.setLocation = function (x, y) {\n  this.rect.x = x;\n  this.rect.y = y;\n};\n\nLNode.prototype.moveBy = function (dx, dy) {\n  this.rect.x += dx;\n  this.rect.y += dy;\n};\n\nLNode.prototype.getEdgeListToNode = function (to) {\n  var edgeList = [];\n  var edge;\n  var self = this;\n\n  self.edges.forEach(function (edge) {\n\n    if (edge.target == to) {\n      if (edge.source != self) throw \"Incorrect edge source!\";\n\n      edgeList.push(edge);\n    }\n  });\n\n  return edgeList;\n};\n\nLNode.prototype.getEdgesBetween = function (other) {\n  var edgeList = [];\n  var edge;\n\n  var self = this;\n  self.edges.forEach(function (edge) {\n\n    if (!(edge.source == self || edge.target == self)) throw \"Incorrect edge source and/or target\";\n\n    if (edge.target == other || edge.source == other) {\n      edgeList.push(edge);\n    }\n  });\n\n  return edgeList;\n};\n\nLNode.prototype.getNeighborsList = function () {\n  var neighbors = new Set();\n\n  var self = this;\n  self.edges.forEach(function (edge) {\n\n    if (edge.source == self) {\n      neighbors.add(edge.target);\n    } else {\n      if (edge.target != self) {\n        throw \"Incorrect incidency!\";\n      }\n\n      neighbors.add(edge.source);\n    }\n  });\n\n  return neighbors;\n};\n\nLNode.prototype.withChildren = function () {\n  var withNeighborsList = new Set();\n  var childNode;\n  var children;\n\n  withNeighborsList.add(this);\n\n  if (this.child != null) {\n    var nodes = this.child.getNodes();\n    for (var i = 0; i < nodes.length; i++) {\n      childNode = nodes[i];\n      children = childNode.withChildren();\n      children.forEach(function (node) {\n        withNeighborsList.add(node);\n      });\n    }\n  }\n\n  return withNeighborsList;\n};\n\nLNode.prototype.getNoOfChildren = function () {\n  var noOfChildren = 0;\n  var childNode;\n\n  if (this.child == null) {\n    noOfChildren = 1;\n  } else {\n    var nodes = this.child.getNodes();\n    for (var i = 0; i < nodes.length; i++) {\n      childNode = nodes[i];\n\n      noOfChildren += childNode.getNoOfChildren();\n    }\n  }\n\n  if (noOfChildren == 0) {\n    noOfChildren = 1;\n  }\n  return noOfChildren;\n};\n\nLNode.prototype.getEstimatedSize = function () {\n  if (this.estimatedSize == Integer.MIN_VALUE) {\n    throw \"assert failed\";\n  }\n  return this.estimatedSize;\n};\n\nLNode.prototype.calcEstimatedSize = function () {\n  if (this.child == null) {\n    return this.estimatedSize = (this.rect.width + this.rect.height) / 2;\n  } else {\n    this.estimatedSize = this.child.calcEstimatedSize();\n    this.rect.width = this.estimatedSize;\n    this.rect.height = this.estimatedSize;\n\n    return this.estimatedSize;\n  }\n};\n\nLNode.prototype.scatter = function () {\n  var randomCenterX;\n  var randomCenterY;\n\n  var minX = -LayoutConstants.INITIAL_WORLD_BOUNDARY;\n  var maxX = LayoutConstants.INITIAL_WORLD_BOUNDARY;\n  randomCenterX = LayoutConstants.WORLD_CENTER_X + RandomSeed.nextDouble() * (maxX - minX) + minX;\n\n  var minY = -LayoutConstants.INITIAL_WORLD_BOUNDARY;\n  var maxY = LayoutConstants.INITIAL_WORLD_BOUNDARY;\n  randomCenterY = LayoutConstants.WORLD_CENTER_Y + RandomSeed.nextDouble() * (maxY - minY) + minY;\n\n  this.rect.x = randomCenterX;\n  this.rect.y = randomCenterY;\n};\n\nLNode.prototype.updateBounds = function () {\n  if (this.getChild() == null) {\n    throw \"assert failed\";\n  }\n  if (this.getChild().getNodes().length != 0) {\n    // wrap the children nodes by re-arranging the boundaries\n    var childGraph = this.getChild();\n    childGraph.updateBounds(true);\n\n    this.rect.x = childGraph.getLeft();\n    this.rect.y = childGraph.getTop();\n\n    this.setWidth(childGraph.getRight() - childGraph.getLeft());\n    this.setHeight(childGraph.getBottom() - childGraph.getTop());\n\n    // Update compound bounds considering its label properties    \n    if (LayoutConstants.NODE_DIMENSIONS_INCLUDE_LABELS) {\n\n      var width = childGraph.getRight() - childGraph.getLeft();\n      var height = childGraph.getBottom() - childGraph.getTop();\n\n      if (this.labelWidth > width) {\n        this.rect.x -= (this.labelWidth - width) / 2;\n        this.setWidth(this.labelWidth);\n      }\n\n      if (this.labelHeight > height) {\n        if (this.labelPos == \"center\") {\n          this.rect.y -= (this.labelHeight - height) / 2;\n        } else if (this.labelPos == \"top\") {\n          this.rect.y -= this.labelHeight - height;\n        }\n        this.setHeight(this.labelHeight);\n      }\n    }\n  }\n};\n\nLNode.prototype.getInclusionTreeDepth = function () {\n  if (this.inclusionTreeDepth == Integer.MAX_VALUE) {\n    throw \"assert failed\";\n  }\n  return this.inclusionTreeDepth;\n};\n\nLNode.prototype.transform = function (trans) {\n  var left = this.rect.x;\n\n  if (left > LayoutConstants.WORLD_BOUNDARY) {\n    left = LayoutConstants.WORLD_BOUNDARY;\n  } else if (left < -LayoutConstants.WORLD_BOUNDARY) {\n    left = -LayoutConstants.WORLD_BOUNDARY;\n  }\n\n  var top = this.rect.y;\n\n  if (top > LayoutConstants.WORLD_BOUNDARY) {\n    top = LayoutConstants.WORLD_BOUNDARY;\n  } else if (top < -LayoutConstants.WORLD_BOUNDARY) {\n    top = -LayoutConstants.WORLD_BOUNDARY;\n  }\n\n  var leftTop = new PointD(left, top);\n  var vLeftTop = trans.inverseTransformPoint(leftTop);\n\n  this.setLocation(vLeftTop.x, vLeftTop.y);\n};\n\nLNode.prototype.getLeft = function () {\n  return this.rect.x;\n};\n\nLNode.prototype.getRight = function () {\n  return this.rect.x + this.rect.width;\n};\n\nLNode.prototype.getTop = function () {\n  return this.rect.y;\n};\n\nLNode.prototype.getBottom = function () {\n  return this.rect.y + this.rect.height;\n};\n\nLNode.prototype.getParent = function () {\n  if (this.owner == null) {\n    return null;\n  }\n\n  return this.owner.getParent();\n};\n\nmodule.exports = LNode;\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nfunction PointD(x, y) {\n  if (x == null && y == null) {\n    this.x = 0;\n    this.y = 0;\n  } else {\n    this.x = x;\n    this.y = y;\n  }\n}\n\nPointD.prototype.getX = function () {\n  return this.x;\n};\n\nPointD.prototype.getY = function () {\n  return this.y;\n};\n\nPointD.prototype.setX = function (x) {\n  this.x = x;\n};\n\nPointD.prototype.setY = function (y) {\n  this.y = y;\n};\n\nPointD.prototype.getDifference = function (pt) {\n  return new DimensionD(this.x - pt.x, this.y - pt.y);\n};\n\nPointD.prototype.getCopy = function () {\n  return new PointD(this.x, this.y);\n};\n\nPointD.prototype.translate = function (dim) {\n  this.x += dim.width;\n  this.y += dim.height;\n  return this;\n};\n\nmodule.exports = PointD;\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __nested_webpack_require_17549__) {\n\n\"use strict\";\n\n\nvar LGraphObject = __nested_webpack_require_17549__(2);\nvar Integer = __nested_webpack_require_17549__(10);\nvar LayoutConstants = __nested_webpack_require_17549__(0);\nvar LGraphManager = __nested_webpack_require_17549__(6);\nvar LNode = __nested_webpack_require_17549__(3);\nvar LEdge = __nested_webpack_require_17549__(1);\nvar RectangleD = __nested_webpack_require_17549__(13);\nvar Point = __nested_webpack_require_17549__(12);\nvar LinkedList = __nested_webpack_require_17549__(11);\n\nfunction LGraph(parent, obj2, vGraph) {\n  LGraphObject.call(this, vGraph);\n  this.estimatedSize = Integer.MIN_VALUE;\n  this.margin = LayoutConstants.DEFAULT_GRAPH_MARGIN;\n  this.edges = [];\n  this.nodes = [];\n  this.isConnected = false;\n  this.parent = parent;\n\n  if (obj2 != null && obj2 instanceof LGraphManager) {\n    this.graphManager = obj2;\n  } else if (obj2 != null && obj2 instanceof Layout) {\n    this.graphManager = obj2.graphManager;\n  }\n}\n\nLGraph.prototype = Object.create(LGraphObject.prototype);\nfor (var prop in LGraphObject) {\n  LGraph[prop] = LGraphObject[prop];\n}\n\nLGraph.prototype.getNodes = function () {\n  return this.nodes;\n};\n\nLGraph.prototype.getEdges = function () {\n  return this.edges;\n};\n\nLGraph.prototype.getGraphManager = function () {\n  return this.graphManager;\n};\n\nLGraph.prototype.getParent = function () {\n  return this.parent;\n};\n\nLGraph.prototype.getLeft = function () {\n  return this.left;\n};\n\nLGraph.prototype.getRight = function () {\n  return this.right;\n};\n\nLGraph.prototype.getTop = function () {\n  return this.top;\n};\n\nLGraph.prototype.getBottom = function () {\n  return this.bottom;\n};\n\nLGraph.prototype.isConnected = function () {\n  return this.isConnected;\n};\n\nLGraph.prototype.add = function (obj1, sourceNode, targetNode) {\n  if (sourceNode == null && targetNode == null) {\n    var newNode = obj1;\n    if (this.graphManager == null) {\n      throw \"Graph has no graph mgr!\";\n    }\n    if (this.getNodes().indexOf(newNode) > -1) {\n      throw \"Node already in graph!\";\n    }\n    newNode.owner = this;\n    this.getNodes().push(newNode);\n\n    return newNode;\n  } else {\n    var newEdge = obj1;\n    if (!(this.getNodes().indexOf(sourceNode) > -1 && this.getNodes().indexOf(targetNode) > -1)) {\n      throw \"Source or target not in graph!\";\n    }\n\n    if (!(sourceNode.owner == targetNode.owner && sourceNode.owner == this)) {\n      throw \"Both owners must be this graph!\";\n    }\n\n    if (sourceNode.owner != targetNode.owner) {\n      return null;\n    }\n\n    // set source and target\n    newEdge.source = sourceNode;\n    newEdge.target = targetNode;\n\n    // set as intra-graph edge\n    newEdge.isInterGraph = false;\n\n    // add to graph edge list\n    this.getEdges().push(newEdge);\n\n    // add to incidency lists\n    sourceNode.edges.push(newEdge);\n\n    if (targetNode != sourceNode) {\n      targetNode.edges.push(newEdge);\n    }\n\n    return newEdge;\n  }\n};\n\nLGraph.prototype.remove = function (obj) {\n  var node = obj;\n  if (obj instanceof LNode) {\n    if (node == null) {\n      throw \"Node is null!\";\n    }\n    if (!(node.owner != null && node.owner == this)) {\n      throw \"Owner graph is invalid!\";\n    }\n    if (this.graphManager == null) {\n      throw \"Owner graph manager is invalid!\";\n    }\n    // remove incident edges first (make a copy to do it safely)\n    var edgesToBeRemoved = node.edges.slice();\n    var edge;\n    var s = edgesToBeRemoved.length;\n    for (var i = 0; i < s; i++) {\n      edge = edgesToBeRemoved[i];\n\n      if (edge.isInterGraph) {\n        this.graphManager.remove(edge);\n      } else {\n        edge.source.owner.remove(edge);\n      }\n    }\n\n    // now the node itself\n    var index = this.nodes.indexOf(node);\n    if (index == -1) {\n      throw \"Node not in owner node list!\";\n    }\n\n    this.nodes.splice(index, 1);\n  } else if (obj instanceof LEdge) {\n    var edge = obj;\n    if (edge == null) {\n      throw \"Edge is null!\";\n    }\n    if (!(edge.source != null && edge.target != null)) {\n      throw \"Source and/or target is null!\";\n    }\n    if (!(edge.source.owner != null && edge.target.owner != null && edge.source.owner == this && edge.target.owner == this)) {\n      throw \"Source and/or target owner is invalid!\";\n    }\n\n    var sourceIndex = edge.source.edges.indexOf(edge);\n    var targetIndex = edge.target.edges.indexOf(edge);\n    if (!(sourceIndex > -1 && targetIndex > -1)) {\n      throw \"Source and/or target doesn't know this edge!\";\n    }\n\n    edge.source.edges.splice(sourceIndex, 1);\n\n    if (edge.target != edge.source) {\n      edge.target.edges.splice(targetIndex, 1);\n    }\n\n    var index = edge.source.owner.getEdges().indexOf(edge);\n    if (index == -1) {\n      throw \"Not in owner's edge list!\";\n    }\n\n    edge.source.owner.getEdges().splice(index, 1);\n  }\n};\n\nLGraph.prototype.updateLeftTop = function () {\n  var top = Integer.MAX_VALUE;\n  var left = Integer.MAX_VALUE;\n  var nodeTop;\n  var nodeLeft;\n  var margin;\n\n  var nodes = this.getNodes();\n  var s = nodes.length;\n\n  for (var i = 0; i < s; i++) {\n    var lNode = nodes[i];\n    nodeTop = lNode.getTop();\n    nodeLeft = lNode.getLeft();\n\n    if (top > nodeTop) {\n      top = nodeTop;\n    }\n\n    if (left > nodeLeft) {\n      left = nodeLeft;\n    }\n  }\n\n  // Do we have any nodes in this graph?\n  if (top == Integer.MAX_VALUE) {\n    return null;\n  }\n\n  if (nodes[0].getParent().paddingLeft != undefined) {\n    margin = nodes[0].getParent().paddingLeft;\n  } else {\n    margin = this.margin;\n  }\n\n  this.left = left - margin;\n  this.top = top - margin;\n\n  // Apply the margins and return the result\n  return new Point(this.left, this.top);\n};\n\nLGraph.prototype.updateBounds = function (recursive) {\n  // calculate bounds\n  var left = Integer.MAX_VALUE;\n  var right = -Integer.MAX_VALUE;\n  var top = Integer.MAX_VALUE;\n  var bottom = -Integer.MAX_VALUE;\n  var nodeLeft;\n  var nodeRight;\n  var nodeTop;\n  var nodeBottom;\n  var margin;\n\n  var nodes = this.nodes;\n  var s = nodes.length;\n  for (var i = 0; i < s; i++) {\n    var lNode = nodes[i];\n\n    if (recursive && lNode.child != null) {\n      lNode.updateBounds();\n    }\n    nodeLeft = lNode.getLeft();\n    nodeRight = lNode.getRight();\n    nodeTop = lNode.getTop();\n    nodeBottom = lNode.getBottom();\n\n    if (left > nodeLeft) {\n      left = nodeLeft;\n    }\n\n    if (right < nodeRight) {\n      right = nodeRight;\n    }\n\n    if (top > nodeTop) {\n      top = nodeTop;\n    }\n\n    if (bottom < nodeBottom) {\n      bottom = nodeBottom;\n    }\n  }\n\n  var boundingRect = new RectangleD(left, top, right - left, bottom - top);\n  if (left == Integer.MAX_VALUE) {\n    this.left = this.parent.getLeft();\n    this.right = this.parent.getRight();\n    this.top = this.parent.getTop();\n    this.bottom = this.parent.getBottom();\n  }\n\n  if (nodes[0].getParent().paddingLeft != undefined) {\n    margin = nodes[0].getParent().paddingLeft;\n  } else {\n    margin = this.margin;\n  }\n\n  this.left = boundingRect.x - margin;\n  this.right = boundingRect.x + boundingRect.width + margin;\n  this.top = boundingRect.y - margin;\n  this.bottom = boundingRect.y + boundingRect.height + margin;\n};\n\nLGraph.calculateBounds = function (nodes) {\n  var left = Integer.MAX_VALUE;\n  var right = -Integer.MAX_VALUE;\n  var top = Integer.MAX_VALUE;\n  var bottom = -Integer.MAX_VALUE;\n  var nodeLeft;\n  var nodeRight;\n  var nodeTop;\n  var nodeBottom;\n\n  var s = nodes.length;\n\n  for (var i = 0; i < s; i++) {\n    var lNode = nodes[i];\n    nodeLeft = lNode.getLeft();\n    nodeRight = lNode.getRight();\n    nodeTop = lNode.getTop();\n    nodeBottom = lNode.getBottom();\n\n    if (left > nodeLeft) {\n      left = nodeLeft;\n    }\n\n    if (right < nodeRight) {\n      right = nodeRight;\n    }\n\n    if (top > nodeTop) {\n      top = nodeTop;\n    }\n\n    if (bottom < nodeBottom) {\n      bottom = nodeBottom;\n    }\n  }\n\n  var boundingRect = new RectangleD(left, top, right - left, bottom - top);\n\n  return boundingRect;\n};\n\nLGraph.prototype.getInclusionTreeDepth = function () {\n  if (this == this.graphManager.getRoot()) {\n    return 1;\n  } else {\n    return this.parent.getInclusionTreeDepth();\n  }\n};\n\nLGraph.prototype.getEstimatedSize = function () {\n  if (this.estimatedSize == Integer.MIN_VALUE) {\n    throw \"assert failed\";\n  }\n  return this.estimatedSize;\n};\n\nLGraph.prototype.calcEstimatedSize = function () {\n  var size = 0;\n  var nodes = this.nodes;\n  var s = nodes.length;\n\n  for (var i = 0; i < s; i++) {\n    var lNode = nodes[i];\n    size += lNode.calcEstimatedSize();\n  }\n\n  if (size == 0) {\n    this.estimatedSize = LayoutConstants.EMPTY_COMPOUND_NODE_SIZE;\n  } else {\n    this.estimatedSize = size / Math.sqrt(this.nodes.length);\n  }\n\n  return this.estimatedSize;\n};\n\nLGraph.prototype.updateConnected = function () {\n  var self = this;\n  if (this.nodes.length == 0) {\n    this.isConnected = true;\n    return;\n  }\n\n  var queue = new LinkedList();\n  var visited = new Set();\n  var currentNode = this.nodes[0];\n  var neighborEdges;\n  var currentNeighbor;\n  var childrenOfNode = currentNode.withChildren();\n  childrenOfNode.forEach(function (node) {\n    queue.push(node);\n    visited.add(node);\n  });\n\n  while (queue.length !== 0) {\n    currentNode = queue.shift();\n\n    // Traverse all neighbors of this node\n    neighborEdges = currentNode.getEdges();\n    var size = neighborEdges.length;\n    for (var i = 0; i < size; i++) {\n      var neighborEdge = neighborEdges[i];\n      currentNeighbor = neighborEdge.getOtherEndInGraph(currentNode, this);\n\n      // Add unvisited neighbors to the list to visit\n      if (currentNeighbor != null && !visited.has(currentNeighbor)) {\n        var childrenOfNeighbor = currentNeighbor.withChildren();\n\n        childrenOfNeighbor.forEach(function (node) {\n          queue.push(node);\n          visited.add(node);\n        });\n      }\n    }\n  }\n\n  this.isConnected = false;\n\n  if (visited.size >= this.nodes.length) {\n    var noOfVisitedInThisGraph = 0;\n\n    visited.forEach(function (visitedNode) {\n      if (visitedNode.owner == self) {\n        noOfVisitedInThisGraph++;\n      }\n    });\n\n    if (noOfVisitedInThisGraph == this.nodes.length) {\n      this.isConnected = true;\n    }\n  }\n};\n\nmodule.exports = LGraph;\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __nested_webpack_require_27617__) {\n\n\"use strict\";\n\n\nvar LGraph;\nvar LEdge = __nested_webpack_require_27617__(1);\n\nfunction LGraphManager(layout) {\n  LGraph = __nested_webpack_require_27617__(5); // It may be better to initilize this out of this function but it gives an error (Right-hand side of 'instanceof' is not callable) now.\n  this.layout = layout;\n\n  this.graphs = [];\n  this.edges = [];\n}\n\nLGraphManager.prototype.addRoot = function () {\n  var ngraph = this.layout.newGraph();\n  var nnode = this.layout.newNode(null);\n  var root = this.add(ngraph, nnode);\n  this.setRootGraph(root);\n  return this.rootGraph;\n};\n\nLGraphManager.prototype.add = function (newGraph, parentNode, newEdge, sourceNode, targetNode) {\n  //there are just 2 parameters are passed then it adds an LGraph else it adds an LEdge\n  if (newEdge == null && sourceNode == null && targetNode == null) {\n    if (newGraph == null) {\n      throw \"Graph is null!\";\n    }\n    if (parentNode == null) {\n      throw \"Parent node is null!\";\n    }\n    if (this.graphs.indexOf(newGraph) > -1) {\n      throw \"Graph already in this graph mgr!\";\n    }\n\n    this.graphs.push(newGraph);\n\n    if (newGraph.parent != null) {\n      throw \"Already has a parent!\";\n    }\n    if (parentNode.child != null) {\n      throw \"Already has a child!\";\n    }\n\n    newGraph.parent = parentNode;\n    parentNode.child = newGraph;\n\n    return newGraph;\n  } else {\n    //change the order of the parameters\n    targetNode = newEdge;\n    sourceNode = parentNode;\n    newEdge = newGraph;\n    var sourceGraph = sourceNode.getOwner();\n    var targetGraph = targetNode.getOwner();\n\n    if (!(sourceGraph != null && sourceGraph.getGraphManager() == this)) {\n      throw \"Source not in this graph mgr!\";\n    }\n    if (!(targetGraph != null && targetGraph.getGraphManager() == this)) {\n      throw \"Target not in this graph mgr!\";\n    }\n\n    if (sourceGraph == targetGraph) {\n      newEdge.isInterGraph = false;\n      return sourceGraph.add(newEdge, sourceNode, targetNode);\n    } else {\n      newEdge.isInterGraph = true;\n\n      // set source and target\n      newEdge.source = sourceNode;\n      newEdge.target = targetNode;\n\n      // add edge to inter-graph edge list\n      if (this.edges.indexOf(newEdge) > -1) {\n        throw \"Edge already in inter-graph edge list!\";\n      }\n\n      this.edges.push(newEdge);\n\n      // add edge to source and target incidency lists\n      if (!(newEdge.source != null && newEdge.target != null)) {\n        throw \"Edge source and/or target is null!\";\n      }\n\n      if (!(newEdge.source.edges.indexOf(newEdge) == -1 && newEdge.target.edges.indexOf(newEdge) == -1)) {\n        throw \"Edge already in source and/or target incidency list!\";\n      }\n\n      newEdge.source.edges.push(newEdge);\n      newEdge.target.edges.push(newEdge);\n\n      return newEdge;\n    }\n  }\n};\n\nLGraphManager.prototype.remove = function (lObj) {\n  if (lObj instanceof LGraph) {\n    var graph = lObj;\n    if (graph.getGraphManager() != this) {\n      throw \"Graph not in this graph mgr\";\n    }\n    if (!(graph == this.rootGraph || graph.parent != null && graph.parent.graphManager == this)) {\n      throw \"Invalid parent node!\";\n    }\n\n    // first the edges (make a copy to do it safely)\n    var edgesToBeRemoved = [];\n\n    edgesToBeRemoved = edgesToBeRemoved.concat(graph.getEdges());\n\n    var edge;\n    var s = edgesToBeRemoved.length;\n    for (var i = 0; i < s; i++) {\n      edge = edgesToBeRemoved[i];\n      graph.remove(edge);\n    }\n\n    // then the nodes (make a copy to do it safely)\n    var nodesToBeRemoved = [];\n\n    nodesToBeRemoved = nodesToBeRemoved.concat(graph.getNodes());\n\n    var node;\n    s = nodesToBeRemoved.length;\n    for (var i = 0; i < s; i++) {\n      node = nodesToBeRemoved[i];\n      graph.remove(node);\n    }\n\n    // check if graph is the root\n    if (graph == this.rootGraph) {\n      this.setRootGraph(null);\n    }\n\n    // now remove the graph itself\n    var index = this.graphs.indexOf(graph);\n    this.graphs.splice(index, 1);\n\n    // also reset the parent of the graph\n    graph.parent = null;\n  } else if (lObj instanceof LEdge) {\n    edge = lObj;\n    if (edge == null) {\n      throw \"Edge is null!\";\n    }\n    if (!edge.isInterGraph) {\n      throw \"Not an inter-graph edge!\";\n    }\n    if (!(edge.source != null && edge.target != null)) {\n      throw \"Source and/or target is null!\";\n    }\n\n    // remove edge from source and target nodes' incidency lists\n\n    if (!(edge.source.edges.indexOf(edge) != -1 && edge.target.edges.indexOf(edge) != -1)) {\n      throw \"Source and/or target doesn't know this edge!\";\n    }\n\n    var index = edge.source.edges.indexOf(edge);\n    edge.source.edges.splice(index, 1);\n    index = edge.target.edges.indexOf(edge);\n    edge.target.edges.splice(index, 1);\n\n    // remove edge from owner graph manager's inter-graph edge list\n\n    if (!(edge.source.owner != null && edge.source.owner.getGraphManager() != null)) {\n      throw \"Edge owner graph or owner graph manager is null!\";\n    }\n    if (edge.source.owner.getGraphManager().edges.indexOf(edge) == -1) {\n      throw \"Not in owner graph manager's edge list!\";\n    }\n\n    var index = edge.source.owner.getGraphManager().edges.indexOf(edge);\n    edge.source.owner.getGraphManager().edges.splice(index, 1);\n  }\n};\n\nLGraphManager.prototype.updateBounds = function () {\n  this.rootGraph.updateBounds(true);\n};\n\nLGraphManager.prototype.getGraphs = function () {\n  return this.graphs;\n};\n\nLGraphManager.prototype.getAllNodes = function () {\n  if (this.allNodes == null) {\n    var nodeList = [];\n    var graphs = this.getGraphs();\n    var s = graphs.length;\n    for (var i = 0; i < s; i++) {\n      nodeList = nodeList.concat(graphs[i].getNodes());\n    }\n    this.allNodes = nodeList;\n  }\n  return this.allNodes;\n};\n\nLGraphManager.prototype.resetAllNodes = function () {\n  this.allNodes = null;\n};\n\nLGraphManager.prototype.resetAllEdges = function () {\n  this.allEdges = null;\n};\n\nLGraphManager.prototype.resetAllNodesToApplyGravitation = function () {\n  this.allNodesToApplyGravitation = null;\n};\n\nLGraphManager.prototype.getAllEdges = function () {\n  if (this.allEdges == null) {\n    var edgeList = [];\n    var graphs = this.getGraphs();\n    var s = graphs.length;\n    for (var i = 0; i < graphs.length; i++) {\n      edgeList = edgeList.concat(graphs[i].getEdges());\n    }\n\n    edgeList = edgeList.concat(this.edges);\n\n    this.allEdges = edgeList;\n  }\n  return this.allEdges;\n};\n\nLGraphManager.prototype.getAllNodesToApplyGravitation = function () {\n  return this.allNodesToApplyGravitation;\n};\n\nLGraphManager.prototype.setAllNodesToApplyGravitation = function (nodeList) {\n  if (this.allNodesToApplyGravitation != null) {\n    throw \"assert failed\";\n  }\n\n  this.allNodesToApplyGravitation = nodeList;\n};\n\nLGraphManager.prototype.getRoot = function () {\n  return this.rootGraph;\n};\n\nLGraphManager.prototype.setRootGraph = function (graph) {\n  if (graph.getGraphManager() != this) {\n    throw \"Root not in this graph mgr!\";\n  }\n\n  this.rootGraph = graph;\n  // root graph must have a root node associated with it for convenience\n  if (graph.parent == null) {\n    graph.parent = this.layout.newNode(\"Root node\");\n  }\n};\n\nLGraphManager.prototype.getLayout = function () {\n  return this.layout;\n};\n\nLGraphManager.prototype.isOneAncestorOfOther = function (firstNode, secondNode) {\n  if (!(firstNode != null && secondNode != null)) {\n    throw \"assert failed\";\n  }\n\n  if (firstNode == secondNode) {\n    return true;\n  }\n  // Is second node an ancestor of the first one?\n  var ownerGraph = firstNode.getOwner();\n  var parentNode;\n\n  do {\n    parentNode = ownerGraph.getParent();\n\n    if (parentNode == null) {\n      break;\n    }\n\n    if (parentNode == secondNode) {\n      return true;\n    }\n\n    ownerGraph = parentNode.getOwner();\n    if (ownerGraph == null) {\n      break;\n    }\n  } while (true);\n  // Is first node an ancestor of the second one?\n  ownerGraph = secondNode.getOwner();\n\n  do {\n    parentNode = ownerGraph.getParent();\n\n    if (parentNode == null) {\n      break;\n    }\n\n    if (parentNode == firstNode) {\n      return true;\n    }\n\n    ownerGraph = parentNode.getOwner();\n    if (ownerGraph == null) {\n      break;\n    }\n  } while (true);\n\n  return false;\n};\n\nLGraphManager.prototype.calcLowestCommonAncestors = function () {\n  var edge;\n  var sourceNode;\n  var targetNode;\n  var sourceAncestorGraph;\n  var targetAncestorGraph;\n\n  var edges = this.getAllEdges();\n  var s = edges.length;\n  for (var i = 0; i < s; i++) {\n    edge = edges[i];\n\n    sourceNode = edge.source;\n    targetNode = edge.target;\n    edge.lca = null;\n    edge.sourceInLca = sourceNode;\n    edge.targetInLca = targetNode;\n\n    if (sourceNode == targetNode) {\n      edge.lca = sourceNode.getOwner();\n      continue;\n    }\n\n    sourceAncestorGraph = sourceNode.getOwner();\n\n    while (edge.lca == null) {\n      edge.targetInLca = targetNode;\n      targetAncestorGraph = targetNode.getOwner();\n\n      while (edge.lca == null) {\n        if (targetAncestorGraph == sourceAncestorGraph) {\n          edge.lca = targetAncestorGraph;\n          break;\n        }\n\n        if (targetAncestorGraph == this.rootGraph) {\n          break;\n        }\n\n        if (edge.lca != null) {\n          throw \"assert failed\";\n        }\n        edge.targetInLca = targetAncestorGraph.getParent();\n        targetAncestorGraph = edge.targetInLca.getOwner();\n      }\n\n      if (sourceAncestorGraph == this.rootGraph) {\n        break;\n      }\n\n      if (edge.lca == null) {\n        edge.sourceInLca = sourceAncestorGraph.getParent();\n        sourceAncestorGraph = edge.sourceInLca.getOwner();\n      }\n    }\n\n    if (edge.lca == null) {\n      throw \"assert failed\";\n    }\n  }\n};\n\nLGraphManager.prototype.calcLowestCommonAncestor = function (firstNode, secondNode) {\n  if (firstNode == secondNode) {\n    return firstNode.getOwner();\n  }\n  var firstOwnerGraph = firstNode.getOwner();\n\n  do {\n    if (firstOwnerGraph == null) {\n      break;\n    }\n    var secondOwnerGraph = secondNode.getOwner();\n\n    do {\n      if (secondOwnerGraph == null) {\n        break;\n      }\n\n      if (secondOwnerGraph == firstOwnerGraph) {\n        return secondOwnerGraph;\n      }\n      secondOwnerGraph = secondOwnerGraph.getParent().getOwner();\n    } while (true);\n\n    firstOwnerGraph = firstOwnerGraph.getParent().getOwner();\n  } while (true);\n\n  return firstOwnerGraph;\n};\n\nLGraphManager.prototype.calcInclusionTreeDepths = function (graph, depth) {\n  if (graph == null && depth == null) {\n    graph = this.rootGraph;\n    depth = 1;\n  }\n  var node;\n\n  var nodes = graph.getNodes();\n  var s = nodes.length;\n  for (var i = 0; i < s; i++) {\n    node = nodes[i];\n    node.inclusionTreeDepth = depth;\n\n    if (node.child != null) {\n      this.calcInclusionTreeDepths(node.child, depth + 1);\n    }\n  }\n};\n\nLGraphManager.prototype.includesInvalidEdge = function () {\n  var edge;\n\n  var s = this.edges.length;\n  for (var i = 0; i < s; i++) {\n    edge = this.edges[i];\n\n    if (this.isOneAncestorOfOther(edge.source, edge.target)) {\n      return true;\n    }\n  }\n  return false;\n};\n\nmodule.exports = LGraphManager;\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __nested_webpack_require_38707__) {\n\n\"use strict\";\n\n\nvar LayoutConstants = __nested_webpack_require_38707__(0);\n\nfunction FDLayoutConstants() {}\n\n//FDLayoutConstants inherits static props in LayoutConstants\nfor (var prop in LayoutConstants) {\n  FDLayoutConstants[prop] = LayoutConstants[prop];\n}\n\nFDLayoutConstants.MAX_ITERATIONS = 2500;\n\nFDLayoutConstants.DEFAULT_EDGE_LENGTH = 50;\nFDLayoutConstants.DEFAULT_SPRING_STRENGTH = 0.45;\nFDLayoutConstants.DEFAULT_REPULSION_STRENGTH = 4500.0;\nFDLayoutConstants.DEFAULT_GRAVITY_STRENGTH = 0.4;\nFDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_STRENGTH = 1.0;\nFDLayoutConstants.DEFAULT_GRAVITY_RANGE_FACTOR = 3.8;\nFDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR = 1.5;\nFDLayoutConstants.DEFAULT_USE_SMART_IDEAL_EDGE_LENGTH_CALCULATION = true;\nFDLayoutConstants.DEFAULT_USE_SMART_REPULSION_RANGE_CALCULATION = true;\nFDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL = 0.3;\nFDLayoutConstants.COOLING_ADAPTATION_FACTOR = 0.33;\nFDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT = 1000;\nFDLayoutConstants.ADAPTATION_UPPER_NODE_LIMIT = 5000;\nFDLayoutConstants.MAX_NODE_DISPLACEMENT_INCREMENTAL = 100.0;\nFDLayoutConstants.MAX_NODE_DISPLACEMENT = FDLayoutConstants.MAX_NODE_DISPLACEMENT_INCREMENTAL * 3;\nFDLayoutConstants.MIN_REPULSION_DIST = FDLayoutConstants.DEFAULT_EDGE_LENGTH / 10.0;\nFDLayoutConstants.CONVERGENCE_CHECK_PERIOD = 100;\nFDLayoutConstants.PER_LEVEL_IDEAL_EDGE_LENGTH_FACTOR = 0.1;\nFDLayoutConstants.MIN_EDGE_LENGTH = 1;\nFDLayoutConstants.GRID_CALCULATION_CHECK_PERIOD = 10;\n\nmodule.exports = FDLayoutConstants;\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports, __nested_webpack_require_40298__) {\n\n\"use strict\";\n\n\n/**\n * This class maintains a list of static geometry related utility methods.\n *\n *\n * Copyright: i-Vis Research Group, Bilkent University, 2007 - present\n */\n\nvar Point = __nested_webpack_require_40298__(12);\n\nfunction IGeometry() {}\n\n/**\n * This method calculates *half* the amount in x and y directions of the two\n * input rectangles needed to separate them keeping their respective\n * positioning, and returns the result in the input array. An input\n * separation buffer added to the amount in both directions. We assume that\n * the two rectangles do intersect.\n */\nIGeometry.calcSeparationAmount = function (rectA, rectB, overlapAmount, separationBuffer) {\n  if (!rectA.intersects(rectB)) {\n    throw \"assert failed\";\n  }\n\n  var directions = new Array(2);\n\n  this.decideDirectionsForOverlappingNodes(rectA, rectB, directions);\n\n  overlapAmount[0] = Math.min(rectA.getRight(), rectB.getRight()) - Math.max(rectA.x, rectB.x);\n  overlapAmount[1] = Math.min(rectA.getBottom(), rectB.getBottom()) - Math.max(rectA.y, rectB.y);\n\n  // update the overlapping amounts for the following cases:\n  if (rectA.getX() <= rectB.getX() && rectA.getRight() >= rectB.getRight()) {\n    /* Case x.1:\n    *\n    * rectA\n    * \t|                       |\n    * \t|        _________      |\n    * \t|        |       |      |\n    * \t|________|_______|______|\n    * \t\t\t |       |\n    *           |       |\n    *        rectB\n    */\n    overlapAmount[0] += Math.min(rectB.getX() - rectA.getX(), rectA.getRight() - rectB.getRight());\n  } else if (rectB.getX() <= rectA.getX() && rectB.getRight() >= rectA.getRight()) {\n    /* Case x.2:\n    *\n    * rectB\n    * \t|                       |\n    * \t|        _________      |\n    * \t|        |       |      |\n    * \t|________|_______|______|\n    * \t\t\t |       |\n    *           |       |\n    *        rectA\n    */\n    overlapAmount[0] += Math.min(rectA.getX() - rectB.getX(), rectB.getRight() - rectA.getRight());\n  }\n  if (rectA.getY() <= rectB.getY() && rectA.getBottom() >= rectB.getBottom()) {\n    /* Case y.1:\n     *          ________ rectA\n     *         |\n     *         |\n     *   ______|____  rectB\n     *         |    |\n     *         |    |\n     *   ______|____|\n     *         |\n     *         |\n     *         |________\n     *\n     */\n    overlapAmount[1] += Math.min(rectB.getY() - rectA.getY(), rectA.getBottom() - rectB.getBottom());\n  } else if (rectB.getY() <= rectA.getY() && rectB.getBottom() >= rectA.getBottom()) {\n    /* Case y.2:\n    *          ________ rectB\n    *         |\n    *         |\n    *   ______|____  rectA\n    *         |    |\n    *         |    |\n    *   ______|____|\n    *         |\n    *         |\n    *         |________\n    *\n    */\n    overlapAmount[1] += Math.min(rectA.getY() - rectB.getY(), rectB.getBottom() - rectA.getBottom());\n  }\n\n  // find slope of the line passes two centers\n  var slope = Math.abs((rectB.getCenterY() - rectA.getCenterY()) / (rectB.getCenterX() - rectA.getCenterX()));\n  // if centers are overlapped\n  if (rectB.getCenterY() === rectA.getCenterY() && rectB.getCenterX() === rectA.getCenterX()) {\n    // assume the slope is 1 (45 degree)\n    slope = 1.0;\n  }\n\n  var moveByY = slope * overlapAmount[0];\n  var moveByX = overlapAmount[1] / slope;\n  if (overlapAmount[0] < moveByX) {\n    moveByX = overlapAmount[0];\n  } else {\n    moveByY = overlapAmount[1];\n  }\n  // return half the amount so that if each rectangle is moved by these\n  // amounts in opposite directions, overlap will be resolved\n  overlapAmount[0] = -1 * directions[0] * (moveByX / 2 + separationBuffer);\n  overlapAmount[1] = -1 * directions[1] * (moveByY / 2 + separationBuffer);\n};\n\n/**\n * This method decides the separation direction of overlapping nodes\n *\n * if directions[0] = -1, then rectA goes left\n * if directions[0] = 1,  then rectA goes right\n * if directions[1] = -1, then rectA goes up\n * if directions[1] = 1,  then rectA goes down\n */\nIGeometry.decideDirectionsForOverlappingNodes = function (rectA, rectB, directions) {\n  if (rectA.getCenterX() < rectB.getCenterX()) {\n    directions[0] = -1;\n  } else {\n    directions[0] = 1;\n  }\n\n  if (rectA.getCenterY() < rectB.getCenterY()) {\n    directions[1] = -1;\n  } else {\n    directions[1] = 1;\n  }\n};\n\n/**\n * This method calculates the intersection (clipping) points of the two\n * input rectangles with line segment defined by the centers of these two\n * rectangles. The clipping points are saved in the input double array and\n * whether or not the two rectangles overlap is returned.\n */\nIGeometry.getIntersection2 = function (rectA, rectB, result) {\n  //result[0-1] will contain clipPoint of rectA, result[2-3] will contain clipPoint of rectB\n  var p1x = rectA.getCenterX();\n  var p1y = rectA.getCenterY();\n  var p2x = rectB.getCenterX();\n  var p2y = rectB.getCenterY();\n\n  //if two rectangles intersect, then clipping points are centers\n  if (rectA.intersects(rectB)) {\n    result[0] = p1x;\n    result[1] = p1y;\n    result[2] = p2x;\n    result[3] = p2y;\n    return true;\n  }\n  //variables for rectA\n  var topLeftAx = rectA.getX();\n  var topLeftAy = rectA.getY();\n  var topRightAx = rectA.getRight();\n  var bottomLeftAx = rectA.getX();\n  var bottomLeftAy = rectA.getBottom();\n  var bottomRightAx = rectA.getRight();\n  var halfWidthA = rectA.getWidthHalf();\n  var halfHeightA = rectA.getHeightHalf();\n  //variables for rectB\n  var topLeftBx = rectB.getX();\n  var topLeftBy = rectB.getY();\n  var topRightBx = rectB.getRight();\n  var bottomLeftBx = rectB.getX();\n  var bottomLeftBy = rectB.getBottom();\n  var bottomRightBx = rectB.getRight();\n  var halfWidthB = rectB.getWidthHalf();\n  var halfHeightB = rectB.getHeightHalf();\n\n  //flag whether clipping points are found\n  var clipPointAFound = false;\n  var clipPointBFound = false;\n\n  // line is vertical\n  if (p1x === p2x) {\n    if (p1y > p2y) {\n      result[0] = p1x;\n      result[1] = topLeftAy;\n      result[2] = p2x;\n      result[3] = bottomLeftBy;\n      return false;\n    } else if (p1y < p2y) {\n      result[0] = p1x;\n      result[1] = bottomLeftAy;\n      result[2] = p2x;\n      result[3] = topLeftBy;\n      return false;\n    } else {\n      //not line, return null;\n    }\n  }\n  // line is horizontal\n  else if (p1y === p2y) {\n      if (p1x > p2x) {\n        result[0] = topLeftAx;\n        result[1] = p1y;\n        result[2] = topRightBx;\n        result[3] = p2y;\n        return false;\n      } else if (p1x < p2x) {\n        result[0] = topRightAx;\n        result[1] = p1y;\n        result[2] = topLeftBx;\n        result[3] = p2y;\n        return false;\n      } else {\n        //not valid line, return null;\n      }\n    } else {\n      //slopes of rectA's and rectB's diagonals\n      var slopeA = rectA.height / rectA.width;\n      var slopeB = rectB.height / rectB.width;\n\n      //slope of line between center of rectA and center of rectB\n      var slopePrime = (p2y - p1y) / (p2x - p1x);\n      var cardinalDirectionA = void 0;\n      var cardinalDirectionB = void 0;\n      var tempPointAx = void 0;\n      var tempPointAy = void 0;\n      var tempPointBx = void 0;\n      var tempPointBy = void 0;\n\n      //determine whether clipping point is the corner of nodeA\n      if (-slopeA === slopePrime) {\n        if (p1x > p2x) {\n          result[0] = bottomLeftAx;\n          result[1] = bottomLeftAy;\n          clipPointAFound = true;\n        } else {\n          result[0] = topRightAx;\n          result[1] = topLeftAy;\n          clipPointAFound = true;\n        }\n      } else if (slopeA === slopePrime) {\n        if (p1x > p2x) {\n          result[0] = topLeftAx;\n          result[1] = topLeftAy;\n          clipPointAFound = true;\n        } else {\n          result[0] = bottomRightAx;\n          result[1] = bottomLeftAy;\n          clipPointAFound = true;\n        }\n      }\n\n      //determine whether clipping point is the corner of nodeB\n      if (-slopeB === slopePrime) {\n        if (p2x > p1x) {\n          result[2] = bottomLeftBx;\n          result[3] = bottomLeftBy;\n          clipPointBFound = true;\n        } else {\n          result[2] = topRightBx;\n          result[3] = topLeftBy;\n          clipPointBFound = true;\n        }\n      } else if (slopeB === slopePrime) {\n        if (p2x > p1x) {\n          result[2] = topLeftBx;\n          result[3] = topLeftBy;\n          clipPointBFound = true;\n        } else {\n          result[2] = bottomRightBx;\n          result[3] = bottomLeftBy;\n          clipPointBFound = true;\n        }\n      }\n\n      //if both clipping points are corners\n      if (clipPointAFound && clipPointBFound) {\n        return false;\n      }\n\n      //determine Cardinal Direction of rectangles\n      if (p1x > p2x) {\n        if (p1y > p2y) {\n          cardinalDirectionA = this.getCardinalDirection(slopeA, slopePrime, 4);\n          cardinalDirectionB = this.getCardinalDirection(slopeB, slopePrime, 2);\n        } else {\n          cardinalDirectionA = this.getCardinalDirection(-slopeA, slopePrime, 3);\n          cardinalDirectionB = this.getCardinalDirection(-slopeB, slopePrime, 1);\n        }\n      } else {\n        if (p1y > p2y) {\n          cardinalDirectionA = this.getCardinalDirection(-slopeA, slopePrime, 1);\n          cardinalDirectionB = this.getCardinalDirection(-slopeB, slopePrime, 3);\n        } else {\n          cardinalDirectionA = this.getCardinalDirection(slopeA, slopePrime, 2);\n          cardinalDirectionB = this.getCardinalDirection(slopeB, slopePrime, 4);\n        }\n      }\n      //calculate clipping Point if it is not found before\n      if (!clipPointAFound) {\n        switch (cardinalDirectionA) {\n          case 1:\n            tempPointAy = topLeftAy;\n            tempPointAx = p1x + -halfHeightA / slopePrime;\n            result[0] = tempPointAx;\n            result[1] = tempPointAy;\n            break;\n          case 2:\n            tempPointAx = bottomRightAx;\n            tempPointAy = p1y + halfWidthA * slopePrime;\n            result[0] = tempPointAx;\n            result[1] = tempPointAy;\n            break;\n          case 3:\n            tempPointAy = bottomLeftAy;\n            tempPointAx = p1x + halfHeightA / slopePrime;\n            result[0] = tempPointAx;\n            result[1] = tempPointAy;\n            break;\n          case 4:\n            tempPointAx = bottomLeftAx;\n            tempPointAy = p1y + -halfWidthA * slopePrime;\n            result[0] = tempPointAx;\n            result[1] = tempPointAy;\n            break;\n        }\n      }\n      if (!clipPointBFound) {\n        switch (cardinalDirectionB) {\n          case 1:\n            tempPointBy = topLeftBy;\n            tempPointBx = p2x + -halfHeightB / slopePrime;\n            result[2] = tempPointBx;\n            result[3] = tempPointBy;\n            break;\n          case 2:\n            tempPointBx = bottomRightBx;\n            tempPointBy = p2y + halfWidthB * slopePrime;\n            result[2] = tempPointBx;\n            result[3] = tempPointBy;\n            break;\n          case 3:\n            tempPointBy = bottomLeftBy;\n            tempPointBx = p2x + halfHeightB / slopePrime;\n            result[2] = tempPointBx;\n            result[3] = tempPointBy;\n            break;\n          case 4:\n            tempPointBx = bottomLeftBx;\n            tempPointBy = p2y + -halfWidthB * slopePrime;\n            result[2] = tempPointBx;\n            result[3] = tempPointBy;\n            break;\n        }\n      }\n    }\n  return false;\n};\n\n/**\n * This method returns in which cardinal direction does input point stays\n * 1: North\n * 2: East\n * 3: South\n * 4: West\n */\nIGeometry.getCardinalDirection = function (slope, slopePrime, line) {\n  if (slope > slopePrime) {\n    return line;\n  } else {\n    return 1 + line % 4;\n  }\n};\n\n/**\n * This method calculates the intersection of the two lines defined by\n * point pairs (s1,s2) and (f1,f2).\n */\nIGeometry.getIntersection = function (s1, s2, f1, f2) {\n  if (f2 == null) {\n    return this.getIntersection2(s1, s2, f1);\n  }\n\n  var x1 = s1.x;\n  var y1 = s1.y;\n  var x2 = s2.x;\n  var y2 = s2.y;\n  var x3 = f1.x;\n  var y3 = f1.y;\n  var x4 = f2.x;\n  var y4 = f2.y;\n  var x = void 0,\n      y = void 0; // intersection point\n  var a1 = void 0,\n      a2 = void 0,\n      b1 = void 0,\n      b2 = void 0,\n      c1 = void 0,\n      c2 = void 0; // coefficients of line eqns.\n  var denom = void 0;\n\n  a1 = y2 - y1;\n  b1 = x1 - x2;\n  c1 = x2 * y1 - x1 * y2; // { a1*x + b1*y + c1 = 0 is line 1 }\n\n  a2 = y4 - y3;\n  b2 = x3 - x4;\n  c2 = x4 * y3 - x3 * y4; // { a2*x + b2*y + c2 = 0 is line 2 }\n\n  denom = a1 * b2 - a2 * b1;\n\n  if (denom === 0) {\n    return null;\n  }\n\n  x = (b1 * c2 - b2 * c1) / denom;\n  y = (a2 * c1 - a1 * c2) / denom;\n\n  return new Point(x, y);\n};\n\n/**\n * This method finds and returns the angle of the vector from the + x-axis\n * in clockwise direction (compatible w/ Java coordinate system!).\n */\nIGeometry.angleOfVector = function (Cx, Cy, Nx, Ny) {\n  var C_angle = void 0;\n\n  if (Cx !== Nx) {\n    C_angle = Math.atan((Ny - Cy) / (Nx - Cx));\n\n    if (Nx < Cx) {\n      C_angle += Math.PI;\n    } else if (Ny < Cy) {\n      C_angle += this.TWO_PI;\n    }\n  } else if (Ny < Cy) {\n    C_angle = this.ONE_AND_HALF_PI; // 270 degrees\n  } else {\n    C_angle = this.HALF_PI; // 90 degrees\n  }\n\n  return C_angle;\n};\n\n/**\n * This method checks whether the given two line segments (one with point\n * p1 and p2, the other with point p3 and p4) intersect at a point other\n * than these points.\n */\nIGeometry.doIntersect = function (p1, p2, p3, p4) {\n  var a = p1.x;\n  var b = p1.y;\n  var c = p2.x;\n  var d = p2.y;\n  var p = p3.x;\n  var q = p3.y;\n  var r = p4.x;\n  var s = p4.y;\n  var det = (c - a) * (s - q) - (r - p) * (d - b);\n\n  if (det === 0) {\n    return false;\n  } else {\n    var lambda = ((s - q) * (r - a) + (p - r) * (s - b)) / det;\n    var gamma = ((b - d) * (r - a) + (c - a) * (s - b)) / det;\n    return 0 < lambda && lambda < 1 && 0 < gamma && gamma < 1;\n  }\n};\n\n// -----------------------------------------------------------------------------\n// Section: Class Constants\n// -----------------------------------------------------------------------------\n/**\n * Some useful pre-calculated constants\n */\nIGeometry.HALF_PI = 0.5 * Math.PI;\nIGeometry.ONE_AND_HALF_PI = 1.5 * Math.PI;\nIGeometry.TWO_PI = 2.0 * Math.PI;\nIGeometry.THREE_PI = 3.0 * Math.PI;\n\nmodule.exports = IGeometry;\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nfunction IMath() {}\n\n/**\n * This method returns the sign of the input value.\n */\nIMath.sign = function (value) {\n  if (value > 0) {\n    return 1;\n  } else if (value < 0) {\n    return -1;\n  } else {\n    return 0;\n  }\n};\n\nIMath.floor = function (value) {\n  return value < 0 ? Math.ceil(value) : Math.floor(value);\n};\n\nIMath.ceil = function (value) {\n  return value < 0 ? Math.floor(value) : Math.ceil(value);\n};\n\nmodule.exports = IMath;\n\n/***/ }),\n/* 10 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nfunction Integer() {}\n\nInteger.MAX_VALUE = 2147483647;\nInteger.MIN_VALUE = -2147483648;\n\nmodule.exports = Integer;\n\n/***/ }),\n/* 11 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar nodeFrom = function nodeFrom(value) {\n  return { value: value, next: null, prev: null };\n};\n\nvar add = function add(prev, node, next, list) {\n  if (prev !== null) {\n    prev.next = node;\n  } else {\n    list.head = node;\n  }\n\n  if (next !== null) {\n    next.prev = node;\n  } else {\n    list.tail = node;\n  }\n\n  node.prev = prev;\n  node.next = next;\n\n  list.length++;\n\n  return node;\n};\n\nvar _remove = function _remove(node, list) {\n  var prev = node.prev,\n      next = node.next;\n\n\n  if (prev !== null) {\n    prev.next = next;\n  } else {\n    list.head = next;\n  }\n\n  if (next !== null) {\n    next.prev = prev;\n  } else {\n    list.tail = prev;\n  }\n\n  node.prev = node.next = null;\n\n  list.length--;\n\n  return node;\n};\n\nvar LinkedList = function () {\n  function LinkedList(vals) {\n    var _this = this;\n\n    _classCallCheck(this, LinkedList);\n\n    this.length = 0;\n    this.head = null;\n    this.tail = null;\n\n    if (vals != null) {\n      vals.forEach(function (v) {\n        return _this.push(v);\n      });\n    }\n  }\n\n  _createClass(LinkedList, [{\n    key: \"size\",\n    value: function size() {\n      return this.length;\n    }\n  }, {\n    key: \"insertBefore\",\n    value: function insertBefore(val, otherNode) {\n      return add(otherNode.prev, nodeFrom(val), otherNode, this);\n    }\n  }, {\n    key: \"insertAfter\",\n    value: function insertAfter(val, otherNode) {\n      return add(otherNode, nodeFrom(val), otherNode.next, this);\n    }\n  }, {\n    key: \"insertNodeBefore\",\n    value: function insertNodeBefore(newNode, otherNode) {\n      return add(otherNode.prev, newNode, otherNode, this);\n    }\n  }, {\n    key: \"insertNodeAfter\",\n    value: function insertNodeAfter(newNode, otherNode) {\n      return add(otherNode, newNode, otherNode.next, this);\n    }\n  }, {\n    key: \"push\",\n    value: function push(val) {\n      return add(this.tail, nodeFrom(val), null, this);\n    }\n  }, {\n    key: \"unshift\",\n    value: function unshift(val) {\n      return add(null, nodeFrom(val), this.head, this);\n    }\n  }, {\n    key: \"remove\",\n    value: function remove(node) {\n      return _remove(node, this);\n    }\n  }, {\n    key: \"pop\",\n    value: function pop() {\n      return _remove(this.tail, this).value;\n    }\n  }, {\n    key: \"popNode\",\n    value: function popNode() {\n      return _remove(this.tail, this);\n    }\n  }, {\n    key: \"shift\",\n    value: function shift() {\n      return _remove(this.head, this).value;\n    }\n  }, {\n    key: \"shiftNode\",\n    value: function shiftNode() {\n      return _remove(this.head, this);\n    }\n  }, {\n    key: \"get_object_at\",\n    value: function get_object_at(index) {\n      if (index <= this.length()) {\n        var i = 1;\n        var current = this.head;\n        while (i < index) {\n          current = current.next;\n          i++;\n        }\n        return current.value;\n      }\n    }\n  }, {\n    key: \"set_object_at\",\n    value: function set_object_at(index, value) {\n      if (index <= this.length()) {\n        var i = 1;\n        var current = this.head;\n        while (i < index) {\n          current = current.next;\n          i++;\n        }\n        current.value = value;\n      }\n    }\n  }]);\n\n  return LinkedList;\n}();\n\nmodule.exports = LinkedList;\n\n/***/ }),\n/* 12 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/*\r\n *This class is the javascript implementation of the Point.java class in jdk\r\n */\nfunction Point(x, y, p) {\n  this.x = null;\n  this.y = null;\n  if (x == null && y == null && p == null) {\n    this.x = 0;\n    this.y = 0;\n  } else if (typeof x == 'number' && typeof y == 'number' && p == null) {\n    this.x = x;\n    this.y = y;\n  } else if (x.constructor.name == 'Point' && y == null && p == null) {\n    p = x;\n    this.x = p.x;\n    this.y = p.y;\n  }\n}\n\nPoint.prototype.getX = function () {\n  return this.x;\n};\n\nPoint.prototype.getY = function () {\n  return this.y;\n};\n\nPoint.prototype.getLocation = function () {\n  return new Point(this.x, this.y);\n};\n\nPoint.prototype.setLocation = function (x, y, p) {\n  if (x.constructor.name == 'Point' && y == null && p == null) {\n    p = x;\n    this.setLocation(p.x, p.y);\n  } else if (typeof x == 'number' && typeof y == 'number' && p == null) {\n    //if both parameters are integer just move (x,y) location\n    if (parseInt(x) == x && parseInt(y) == y) {\n      this.move(x, y);\n    } else {\n      this.x = Math.floor(x + 0.5);\n      this.y = Math.floor(y + 0.5);\n    }\n  }\n};\n\nPoint.prototype.move = function (x, y) {\n  this.x = x;\n  this.y = y;\n};\n\nPoint.prototype.translate = function (dx, dy) {\n  this.x += dx;\n  this.y += dy;\n};\n\nPoint.prototype.equals = function (obj) {\n  if (obj.constructor.name == \"Point\") {\n    var pt = obj;\n    return this.x == pt.x && this.y == pt.y;\n  }\n  return this == obj;\n};\n\nPoint.prototype.toString = function () {\n  return new Point().constructor.name + \"[x=\" + this.x + \",y=\" + this.y + \"]\";\n};\n\nmodule.exports = Point;\n\n/***/ }),\n/* 13 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nfunction RectangleD(x, y, width, height) {\n  this.x = 0;\n  this.y = 0;\n  this.width = 0;\n  this.height = 0;\n\n  if (x != null && y != null && width != null && height != null) {\n    this.x = x;\n    this.y = y;\n    this.width = width;\n    this.height = height;\n  }\n}\n\nRectangleD.prototype.getX = function () {\n  return this.x;\n};\n\nRectangleD.prototype.setX = function (x) {\n  this.x = x;\n};\n\nRectangleD.prototype.getY = function () {\n  return this.y;\n};\n\nRectangleD.prototype.setY = function (y) {\n  this.y = y;\n};\n\nRectangleD.prototype.getWidth = function () {\n  return this.width;\n};\n\nRectangleD.prototype.setWidth = function (width) {\n  this.width = width;\n};\n\nRectangleD.prototype.getHeight = function () {\n  return this.height;\n};\n\nRectangleD.prototype.setHeight = function (height) {\n  this.height = height;\n};\n\nRectangleD.prototype.getRight = function () {\n  return this.x + this.width;\n};\n\nRectangleD.prototype.getBottom = function () {\n  return this.y + this.height;\n};\n\nRectangleD.prototype.intersects = function (a) {\n  if (this.getRight() < a.x) {\n    return false;\n  }\n\n  if (this.getBottom() < a.y) {\n    return false;\n  }\n\n  if (a.getRight() < this.x) {\n    return false;\n  }\n\n  if (a.getBottom() < this.y) {\n    return false;\n  }\n\n  return true;\n};\n\nRectangleD.prototype.getCenterX = function () {\n  return this.x + this.width / 2;\n};\n\nRectangleD.prototype.getMinX = function () {\n  return this.getX();\n};\n\nRectangleD.prototype.getMaxX = function () {\n  return this.getX() + this.width;\n};\n\nRectangleD.prototype.getCenterY = function () {\n  return this.y + this.height / 2;\n};\n\nRectangleD.prototype.getMinY = function () {\n  return this.getY();\n};\n\nRectangleD.prototype.getMaxY = function () {\n  return this.getY() + this.height;\n};\n\nRectangleD.prototype.getWidthHalf = function () {\n  return this.width / 2;\n};\n\nRectangleD.prototype.getHeightHalf = function () {\n  return this.height / 2;\n};\n\nmodule.exports = RectangleD;\n\n/***/ }),\n/* 14 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nfunction UniqueIDGeneretor() {}\n\nUniqueIDGeneretor.lastID = 0;\n\nUniqueIDGeneretor.createID = function (obj) {\n  if (UniqueIDGeneretor.isPrimitive(obj)) {\n    return obj;\n  }\n  if (obj.uniqueID != null) {\n    return obj.uniqueID;\n  }\n  obj.uniqueID = UniqueIDGeneretor.getString();\n  UniqueIDGeneretor.lastID++;\n  return obj.uniqueID;\n};\n\nUniqueIDGeneretor.getString = function (id) {\n  if (id == null) id = UniqueIDGeneretor.lastID;\n  return \"Object#\" + id + \"\";\n};\n\nUniqueIDGeneretor.isPrimitive = function (arg) {\n  var type = typeof arg === \"undefined\" ? \"undefined\" : _typeof(arg);\n  return arg == null || type != \"object\" && type != \"function\";\n};\n\nmodule.exports = UniqueIDGeneretor;\n\n/***/ }),\n/* 15 */\n/***/ (function(module, exports, __nested_webpack_require_64072__) {\n\n\"use strict\";\n\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nvar LayoutConstants = __nested_webpack_require_64072__(0);\nvar LGraphManager = __nested_webpack_require_64072__(6);\nvar LNode = __nested_webpack_require_64072__(3);\nvar LEdge = __nested_webpack_require_64072__(1);\nvar LGraph = __nested_webpack_require_64072__(5);\nvar PointD = __nested_webpack_require_64072__(4);\nvar Transform = __nested_webpack_require_64072__(17);\nvar Emitter = __nested_webpack_require_64072__(27);\n\nfunction Layout(isRemoteUse) {\n  Emitter.call(this);\n\n  //Layout Quality: 0:draft, 1:default, 2:proof\n  this.layoutQuality = LayoutConstants.QUALITY;\n  //Whether layout should create bendpoints as needed or not\n  this.createBendsAsNeeded = LayoutConstants.DEFAULT_CREATE_BENDS_AS_NEEDED;\n  //Whether layout should be incremental or not\n  this.incremental = LayoutConstants.DEFAULT_INCREMENTAL;\n  //Whether we animate from before to after layout node positions\n  this.animationOnLayout = LayoutConstants.DEFAULT_ANIMATION_ON_LAYOUT;\n  //Whether we animate the layout process or not\n  this.animationDuringLayout = LayoutConstants.DEFAULT_ANIMATION_DURING_LAYOUT;\n  //Number iterations that should be done between two successive animations\n  this.animationPeriod = LayoutConstants.DEFAULT_ANIMATION_PERIOD;\n  /**\r\n   * Whether or not leaf nodes (non-compound nodes) are of uniform sizes. When\r\n   * they are, both spring and repulsion forces between two leaf nodes can be\r\n   * calculated without the expensive clipping point calculations, resulting\r\n   * in major speed-up.\r\n   */\n  this.uniformLeafNodeSizes = LayoutConstants.DEFAULT_UNIFORM_LEAF_NODE_SIZES;\n  /**\r\n   * This is used for creation of bendpoints by using dummy nodes and edges.\r\n   * Maps an LEdge to its dummy bendpoint path.\r\n   */\n  this.edgeToDummyNodes = new Map();\n  this.graphManager = new LGraphManager(this);\n  this.isLayoutFinished = false;\n  this.isSubLayout = false;\n  this.isRemoteUse = false;\n\n  if (isRemoteUse != null) {\n    this.isRemoteUse = isRemoteUse;\n  }\n}\n\nLayout.RANDOM_SEED = 1;\n\nLayout.prototype = Object.create(Emitter.prototype);\n\nLayout.prototype.getGraphManager = function () {\n  return this.graphManager;\n};\n\nLayout.prototype.getAllNodes = function () {\n  return this.graphManager.getAllNodes();\n};\n\nLayout.prototype.getAllEdges = function () {\n  return this.graphManager.getAllEdges();\n};\n\nLayout.prototype.getAllNodesToApplyGravitation = function () {\n  return this.graphManager.getAllNodesToApplyGravitation();\n};\n\nLayout.prototype.newGraphManager = function () {\n  var gm = new LGraphManager(this);\n  this.graphManager = gm;\n  return gm;\n};\n\nLayout.prototype.newGraph = function (vGraph) {\n  return new LGraph(null, this.graphManager, vGraph);\n};\n\nLayout.prototype.newNode = function (vNode) {\n  return new LNode(this.graphManager, vNode);\n};\n\nLayout.prototype.newEdge = function (vEdge) {\n  return new LEdge(null, null, vEdge);\n};\n\nLayout.prototype.checkLayoutSuccess = function () {\n  return this.graphManager.getRoot() == null || this.graphManager.getRoot().getNodes().length == 0 || this.graphManager.includesInvalidEdge();\n};\n\nLayout.prototype.runLayout = function () {\n  this.isLayoutFinished = false;\n\n  if (this.tilingPreLayout) {\n    this.tilingPreLayout();\n  }\n\n  this.initParameters();\n  var isLayoutSuccessfull;\n\n  if (this.checkLayoutSuccess()) {\n    isLayoutSuccessfull = false;\n  } else {\n    isLayoutSuccessfull = this.layout();\n  }\n\n  if (LayoutConstants.ANIMATE === 'during') {\n    // If this is a 'during' layout animation. Layout is not finished yet. \n    // We need to perform these in index.js when layout is really finished.\n    return false;\n  }\n\n  if (isLayoutSuccessfull) {\n    if (!this.isSubLayout) {\n      this.doPostLayout();\n    }\n  }\n\n  if (this.tilingPostLayout) {\n    this.tilingPostLayout();\n  }\n\n  this.isLayoutFinished = true;\n\n  return isLayoutSuccessfull;\n};\n\n/**\r\n * This method performs the operations required after layout.\r\n */\nLayout.prototype.doPostLayout = function () {\n  //assert !isSubLayout : \"Should not be called on sub-layout!\";\n  // Propagate geometric changes to v-level objects\n  if (!this.incremental) {\n    this.transform();\n  }\n  this.update();\n};\n\n/**\r\n * This method updates the geometry of the target graph according to\r\n * calculated layout.\r\n */\nLayout.prototype.update2 = function () {\n  // update bend points\n  if (this.createBendsAsNeeded) {\n    this.createBendpointsFromDummyNodes();\n\n    // reset all edges, since the topology has changed\n    this.graphManager.resetAllEdges();\n  }\n\n  // perform edge, node and root updates if layout is not called\n  // remotely\n  if (!this.isRemoteUse) {\n    // update all edges\n    var edge;\n    var allEdges = this.graphManager.getAllEdges();\n    for (var i = 0; i < allEdges.length; i++) {\n      edge = allEdges[i];\n      //      this.update(edge);\n    }\n\n    // recursively update nodes\n    var node;\n    var nodes = this.graphManager.getRoot().getNodes();\n    for (var i = 0; i < nodes.length; i++) {\n      node = nodes[i];\n      //      this.update(node);\n    }\n\n    // update root graph\n    this.update(this.graphManager.getRoot());\n  }\n};\n\nLayout.prototype.update = function (obj) {\n  if (obj == null) {\n    this.update2();\n  } else if (obj instanceof LNode) {\n    var node = obj;\n    if (node.getChild() != null) {\n      // since node is compound, recursively update child nodes\n      var nodes = node.getChild().getNodes();\n      for (var i = 0; i < nodes.length; i++) {\n        update(nodes[i]);\n      }\n    }\n\n    // if the l-level node is associated with a v-level graph object,\n    // then it is assumed that the v-level node implements the\n    // interface Updatable.\n    if (node.vGraphObject != null) {\n      // cast to Updatable without any type check\n      var vNode = node.vGraphObject;\n\n      // call the update method of the interface\n      vNode.update(node);\n    }\n  } else if (obj instanceof LEdge) {\n    var edge = obj;\n    // if the l-level edge is associated with a v-level graph object,\n    // then it is assumed that the v-level edge implements the\n    // interface Updatable.\n\n    if (edge.vGraphObject != null) {\n      // cast to Updatable without any type check\n      var vEdge = edge.vGraphObject;\n\n      // call the update method of the interface\n      vEdge.update(edge);\n    }\n  } else if (obj instanceof LGraph) {\n    var graph = obj;\n    // if the l-level graph is associated with a v-level graph object,\n    // then it is assumed that the v-level object implements the\n    // interface Updatable.\n\n    if (graph.vGraphObject != null) {\n      // cast to Updatable without any type check\n      var vGraph = graph.vGraphObject;\n\n      // call the update method of the interface\n      vGraph.update(graph);\n    }\n  }\n};\n\n/**\r\n * This method is used to set all layout parameters to default values\r\n * determined at compile time.\r\n */\nLayout.prototype.initParameters = function () {\n  if (!this.isSubLayout) {\n    this.layoutQuality = LayoutConstants.QUALITY;\n    this.animationDuringLayout = LayoutConstants.DEFAULT_ANIMATION_DURING_LAYOUT;\n    this.animationPeriod = LayoutConstants.DEFAULT_ANIMATION_PERIOD;\n    this.animationOnLayout = LayoutConstants.DEFAULT_ANIMATION_ON_LAYOUT;\n    this.incremental = LayoutConstants.DEFAULT_INCREMENTAL;\n    this.createBendsAsNeeded = LayoutConstants.DEFAULT_CREATE_BENDS_AS_NEEDED;\n    this.uniformLeafNodeSizes = LayoutConstants.DEFAULT_UNIFORM_LEAF_NODE_SIZES;\n  }\n\n  if (this.animationDuringLayout) {\n    this.animationOnLayout = false;\n  }\n};\n\nLayout.prototype.transform = function (newLeftTop) {\n  if (newLeftTop == undefined) {\n    this.transform(new PointD(0, 0));\n  } else {\n    // create a transformation object (from Eclipse to layout). When an\n    // inverse transform is applied, we get upper-left coordinate of the\n    // drawing or the root graph at given input coordinate (some margins\n    // already included in calculation of left-top).\n\n    var trans = new Transform();\n    var leftTop = this.graphManager.getRoot().updateLeftTop();\n\n    if (leftTop != null) {\n      trans.setWorldOrgX(newLeftTop.x);\n      trans.setWorldOrgY(newLeftTop.y);\n\n      trans.setDeviceOrgX(leftTop.x);\n      trans.setDeviceOrgY(leftTop.y);\n\n      var nodes = this.getAllNodes();\n      var node;\n\n      for (var i = 0; i < nodes.length; i++) {\n        node = nodes[i];\n        node.transform(trans);\n      }\n    }\n  }\n};\n\nLayout.prototype.positionNodesRandomly = function (graph) {\n\n  if (graph == undefined) {\n    //assert !this.incremental;\n    this.positionNodesRandomly(this.getGraphManager().getRoot());\n    this.getGraphManager().getRoot().updateBounds(true);\n  } else {\n    var lNode;\n    var childGraph;\n\n    var nodes = graph.getNodes();\n    for (var i = 0; i < nodes.length; i++) {\n      lNode = nodes[i];\n      childGraph = lNode.getChild();\n\n      if (childGraph == null) {\n        lNode.scatter();\n      } else if (childGraph.getNodes().length == 0) {\n        lNode.scatter();\n      } else {\n        this.positionNodesRandomly(childGraph);\n        lNode.updateBounds();\n      }\n    }\n  }\n};\n\n/**\r\n * This method returns a list of trees where each tree is represented as a\r\n * list of l-nodes. The method returns a list of size 0 when:\r\n * - The graph is not flat or\r\n * - One of the component(s) of the graph is not a tree.\r\n */\nLayout.prototype.getFlatForest = function () {\n  var flatForest = [];\n  var isForest = true;\n\n  // Quick reference for all nodes in the graph manager associated with\n  // this layout. The list should not be changed.\n  var allNodes = this.graphManager.getRoot().getNodes();\n\n  // First be sure that the graph is flat\n  var isFlat = true;\n\n  for (var i = 0; i < allNodes.length; i++) {\n    if (allNodes[i].getChild() != null) {\n      isFlat = false;\n    }\n  }\n\n  // Return empty forest if the graph is not flat.\n  if (!isFlat) {\n    return flatForest;\n  }\n\n  // Run BFS for each component of the graph.\n\n  var visited = new Set();\n  var toBeVisited = [];\n  var parents = new Map();\n  var unProcessedNodes = [];\n\n  unProcessedNodes = unProcessedNodes.concat(allNodes);\n\n  // Each iteration of this loop finds a component of the graph and\n  // decides whether it is a tree or not. If it is a tree, adds it to the\n  // forest and continued with the next component.\n\n  while (unProcessedNodes.length > 0 && isForest) {\n    toBeVisited.push(unProcessedNodes[0]);\n\n    // Start the BFS. Each iteration of this loop visits a node in a\n    // BFS manner.\n    while (toBeVisited.length > 0 && isForest) {\n      //pool operation\n      var currentNode = toBeVisited[0];\n      toBeVisited.splice(0, 1);\n      visited.add(currentNode);\n\n      // Traverse all neighbors of this node\n      var neighborEdges = currentNode.getEdges();\n\n      for (var i = 0; i < neighborEdges.length; i++) {\n        var currentNeighbor = neighborEdges[i].getOtherEnd(currentNode);\n\n        // If BFS is not growing from this neighbor.\n        if (parents.get(currentNode) != currentNeighbor) {\n          // We haven't previously visited this neighbor.\n          if (!visited.has(currentNeighbor)) {\n            toBeVisited.push(currentNeighbor);\n            parents.set(currentNeighbor, currentNode);\n          }\n          // Since we have previously visited this neighbor and\n          // this neighbor is not parent of currentNode, given\n          // graph contains a component that is not tree, hence\n          // it is not a forest.\n          else {\n              isForest = false;\n              break;\n            }\n        }\n      }\n    }\n\n    // The graph contains a component that is not a tree. Empty\n    // previously found trees. The method will end.\n    if (!isForest) {\n      flatForest = [];\n    }\n    // Save currently visited nodes as a tree in our forest. Reset\n    // visited and parents lists. Continue with the next component of\n    // the graph, if any.\n    else {\n        var temp = [].concat(_toConsumableArray(visited));\n        flatForest.push(temp);\n        //flatForest = flatForest.concat(temp);\n        //unProcessedNodes.removeAll(visited);\n        for (var i = 0; i < temp.length; i++) {\n          var value = temp[i];\n          var index = unProcessedNodes.indexOf(value);\n          if (index > -1) {\n            unProcessedNodes.splice(index, 1);\n          }\n        }\n        visited = new Set();\n        parents = new Map();\n      }\n  }\n\n  return flatForest;\n};\n\n/**\r\n * This method creates dummy nodes (an l-level node with minimal dimensions)\r\n * for the given edge (one per bendpoint). The existing l-level structure\r\n * is updated accordingly.\r\n */\nLayout.prototype.createDummyNodesForBendpoints = function (edge) {\n  var dummyNodes = [];\n  var prev = edge.source;\n\n  var graph = this.graphManager.calcLowestCommonAncestor(edge.source, edge.target);\n\n  for (var i = 0; i < edge.bendpoints.length; i++) {\n    // create new dummy node\n    var dummyNode = this.newNode(null);\n    dummyNode.setRect(new Point(0, 0), new Dimension(1, 1));\n\n    graph.add(dummyNode);\n\n    // create new dummy edge between prev and dummy node\n    var dummyEdge = this.newEdge(null);\n    this.graphManager.add(dummyEdge, prev, dummyNode);\n\n    dummyNodes.add(dummyNode);\n    prev = dummyNode;\n  }\n\n  var dummyEdge = this.newEdge(null);\n  this.graphManager.add(dummyEdge, prev, edge.target);\n\n  this.edgeToDummyNodes.set(edge, dummyNodes);\n\n  // remove real edge from graph manager if it is inter-graph\n  if (edge.isInterGraph()) {\n    this.graphManager.remove(edge);\n  }\n  // else, remove the edge from the current graph\n  else {\n      graph.remove(edge);\n    }\n\n  return dummyNodes;\n};\n\n/**\r\n * This method creates bendpoints for edges from the dummy nodes\r\n * at l-level.\r\n */\nLayout.prototype.createBendpointsFromDummyNodes = function () {\n  var edges = [];\n  edges = edges.concat(this.graphManager.getAllEdges());\n  edges = [].concat(_toConsumableArray(this.edgeToDummyNodes.keys())).concat(edges);\n\n  for (var k = 0; k < edges.length; k++) {\n    var lEdge = edges[k];\n\n    if (lEdge.bendpoints.length > 0) {\n      var path = this.edgeToDummyNodes.get(lEdge);\n\n      for (var i = 0; i < path.length; i++) {\n        var dummyNode = path[i];\n        var p = new PointD(dummyNode.getCenterX(), dummyNode.getCenterY());\n\n        // update bendpoint's location according to dummy node\n        var ebp = lEdge.bendpoints.get(i);\n        ebp.x = p.x;\n        ebp.y = p.y;\n\n        // remove the dummy node, dummy edges incident with this\n        // dummy node is also removed (within the remove method)\n        dummyNode.getOwner().remove(dummyNode);\n      }\n\n      // add the real edge to graph\n      this.graphManager.add(lEdge, lEdge.source, lEdge.target);\n    }\n  }\n};\n\nLayout.transform = function (sliderValue, defaultValue, minDiv, maxMul) {\n  if (minDiv != undefined && maxMul != undefined) {\n    var value = defaultValue;\n\n    if (sliderValue <= 50) {\n      var minValue = defaultValue / minDiv;\n      value -= (defaultValue - minValue) / 50 * (50 - sliderValue);\n    } else {\n      var maxValue = defaultValue * maxMul;\n      value += (maxValue - defaultValue) / 50 * (sliderValue - 50);\n    }\n\n    return value;\n  } else {\n    var a, b;\n\n    if (sliderValue <= 50) {\n      a = 9.0 * defaultValue / 500.0;\n      b = defaultValue / 10.0;\n    } else {\n      a = 9.0 * defaultValue / 50.0;\n      b = -8 * defaultValue;\n    }\n\n    return a * sliderValue + b;\n  }\n};\n\n/**\r\n * This method finds and returns the center of the given nodes, assuming\r\n * that the given nodes form a tree in themselves.\r\n */\nLayout.findCenterOfTree = function (nodes) {\n  var list = [];\n  list = list.concat(nodes);\n\n  var removedNodes = [];\n  var remainingDegrees = new Map();\n  var foundCenter = false;\n  var centerNode = null;\n\n  if (list.length == 1 || list.length == 2) {\n    foundCenter = true;\n    centerNode = list[0];\n  }\n\n  for (var i = 0; i < list.length; i++) {\n    var node = list[i];\n    var degree = node.getNeighborsList().size;\n    remainingDegrees.set(node, node.getNeighborsList().size);\n\n    if (degree == 1) {\n      removedNodes.push(node);\n    }\n  }\n\n  var tempList = [];\n  tempList = tempList.concat(removedNodes);\n\n  while (!foundCenter) {\n    var tempList2 = [];\n    tempList2 = tempList2.concat(tempList);\n    tempList = [];\n\n    for (var i = 0; i < list.length; i++) {\n      var node = list[i];\n\n      var index = list.indexOf(node);\n      if (index >= 0) {\n        list.splice(index, 1);\n      }\n\n      var neighbours = node.getNeighborsList();\n\n      neighbours.forEach(function (neighbour) {\n        if (removedNodes.indexOf(neighbour) < 0) {\n          var otherDegree = remainingDegrees.get(neighbour);\n          var newDegree = otherDegree - 1;\n\n          if (newDegree == 1) {\n            tempList.push(neighbour);\n          }\n\n          remainingDegrees.set(neighbour, newDegree);\n        }\n      });\n    }\n\n    removedNodes = removedNodes.concat(tempList);\n\n    if (list.length == 1 || list.length == 2) {\n      foundCenter = true;\n      centerNode = list[0];\n    }\n  }\n\n  return centerNode;\n};\n\n/**\r\n * During the coarsening process, this layout may be referenced by two graph managers\r\n * this setter function grants access to change the currently being used graph manager\r\n */\nLayout.prototype.setGraphManager = function (gm) {\n  this.graphManager = gm;\n};\n\nmodule.exports = Layout;\n\n/***/ }),\n/* 16 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nfunction RandomSeed() {}\n// adapted from: https://stackoverflow.com/a/19303725\nRandomSeed.seed = 1;\nRandomSeed.x = 0;\n\nRandomSeed.nextDouble = function () {\n  RandomSeed.x = Math.sin(RandomSeed.seed++) * 10000;\n  return RandomSeed.x - Math.floor(RandomSeed.x);\n};\n\nmodule.exports = RandomSeed;\n\n/***/ }),\n/* 17 */\n/***/ (function(module, exports, __nested_webpack_require_81860__) {\n\n\"use strict\";\n\n\nvar PointD = __nested_webpack_require_81860__(4);\n\nfunction Transform(x, y) {\n  this.lworldOrgX = 0.0;\n  this.lworldOrgY = 0.0;\n  this.ldeviceOrgX = 0.0;\n  this.ldeviceOrgY = 0.0;\n  this.lworldExtX = 1.0;\n  this.lworldExtY = 1.0;\n  this.ldeviceExtX = 1.0;\n  this.ldeviceExtY = 1.0;\n}\n\nTransform.prototype.getWorldOrgX = function () {\n  return this.lworldOrgX;\n};\n\nTransform.prototype.setWorldOrgX = function (wox) {\n  this.lworldOrgX = wox;\n};\n\nTransform.prototype.getWorldOrgY = function () {\n  return this.lworldOrgY;\n};\n\nTransform.prototype.setWorldOrgY = function (woy) {\n  this.lworldOrgY = woy;\n};\n\nTransform.prototype.getWorldExtX = function () {\n  return this.lworldExtX;\n};\n\nTransform.prototype.setWorldExtX = function (wex) {\n  this.lworldExtX = wex;\n};\n\nTransform.prototype.getWorldExtY = function () {\n  return this.lworldExtY;\n};\n\nTransform.prototype.setWorldExtY = function (wey) {\n  this.lworldExtY = wey;\n};\n\n/* Device related */\n\nTransform.prototype.getDeviceOrgX = function () {\n  return this.ldeviceOrgX;\n};\n\nTransform.prototype.setDeviceOrgX = function (dox) {\n  this.ldeviceOrgX = dox;\n};\n\nTransform.prototype.getDeviceOrgY = function () {\n  return this.ldeviceOrgY;\n};\n\nTransform.prototype.setDeviceOrgY = function (doy) {\n  this.ldeviceOrgY = doy;\n};\n\nTransform.prototype.getDeviceExtX = function () {\n  return this.ldeviceExtX;\n};\n\nTransform.prototype.setDeviceExtX = function (dex) {\n  this.ldeviceExtX = dex;\n};\n\nTransform.prototype.getDeviceExtY = function () {\n  return this.ldeviceExtY;\n};\n\nTransform.prototype.setDeviceExtY = function (dey) {\n  this.ldeviceExtY = dey;\n};\n\nTransform.prototype.transformX = function (x) {\n  var xDevice = 0.0;\n  var worldExtX = this.lworldExtX;\n  if (worldExtX != 0.0) {\n    xDevice = this.ldeviceOrgX + (x - this.lworldOrgX) * this.ldeviceExtX / worldExtX;\n  }\n\n  return xDevice;\n};\n\nTransform.prototype.transformY = function (y) {\n  var yDevice = 0.0;\n  var worldExtY = this.lworldExtY;\n  if (worldExtY != 0.0) {\n    yDevice = this.ldeviceOrgY + (y - this.lworldOrgY) * this.ldeviceExtY / worldExtY;\n  }\n\n  return yDevice;\n};\n\nTransform.prototype.inverseTransformX = function (x) {\n  var xWorld = 0.0;\n  var deviceExtX = this.ldeviceExtX;\n  if (deviceExtX != 0.0) {\n    xWorld = this.lworldOrgX + (x - this.ldeviceOrgX) * this.lworldExtX / deviceExtX;\n  }\n\n  return xWorld;\n};\n\nTransform.prototype.inverseTransformY = function (y) {\n  var yWorld = 0.0;\n  var deviceExtY = this.ldeviceExtY;\n  if (deviceExtY != 0.0) {\n    yWorld = this.lworldOrgY + (y - this.ldeviceOrgY) * this.lworldExtY / deviceExtY;\n  }\n  return yWorld;\n};\n\nTransform.prototype.inverseTransformPoint = function (inPoint) {\n  var outPoint = new PointD(this.inverseTransformX(inPoint.x), this.inverseTransformY(inPoint.y));\n  return outPoint;\n};\n\nmodule.exports = Transform;\n\n/***/ }),\n/* 18 */\n/***/ (function(module, exports, __nested_webpack_require_84747__) {\n\n\"use strict\";\n\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nvar Layout = __nested_webpack_require_84747__(15);\nvar FDLayoutConstants = __nested_webpack_require_84747__(7);\nvar LayoutConstants = __nested_webpack_require_84747__(0);\nvar IGeometry = __nested_webpack_require_84747__(8);\nvar IMath = __nested_webpack_require_84747__(9);\n\nfunction FDLayout() {\n  Layout.call(this);\n\n  this.useSmartIdealEdgeLengthCalculation = FDLayoutConstants.DEFAULT_USE_SMART_IDEAL_EDGE_LENGTH_CALCULATION;\n  this.idealEdgeLength = FDLayoutConstants.DEFAULT_EDGE_LENGTH;\n  this.springConstant = FDLayoutConstants.DEFAULT_SPRING_STRENGTH;\n  this.repulsionConstant = FDLayoutConstants.DEFAULT_REPULSION_STRENGTH;\n  this.gravityConstant = FDLayoutConstants.DEFAULT_GRAVITY_STRENGTH;\n  this.compoundGravityConstant = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_STRENGTH;\n  this.gravityRangeFactor = FDLayoutConstants.DEFAULT_GRAVITY_RANGE_FACTOR;\n  this.compoundGravityRangeFactor = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR;\n  this.displacementThresholdPerNode = 3.0 * FDLayoutConstants.DEFAULT_EDGE_LENGTH / 100;\n  this.coolingFactor = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL;\n  this.initialCoolingFactor = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL;\n  this.totalDisplacement = 0.0;\n  this.oldTotalDisplacement = 0.0;\n  this.maxIterations = FDLayoutConstants.MAX_ITERATIONS;\n}\n\nFDLayout.prototype = Object.create(Layout.prototype);\n\nfor (var prop in Layout) {\n  FDLayout[prop] = Layout[prop];\n}\n\nFDLayout.prototype.initParameters = function () {\n  Layout.prototype.initParameters.call(this, arguments);\n\n  this.totalIterations = 0;\n  this.notAnimatedIterations = 0;\n\n  this.useFRGridVariant = FDLayoutConstants.DEFAULT_USE_SMART_REPULSION_RANGE_CALCULATION;\n\n  this.grid = [];\n};\n\nFDLayout.prototype.calcIdealEdgeLengths = function () {\n  var edge;\n  var lcaDepth;\n  var source;\n  var target;\n  var sizeOfSourceInLca;\n  var sizeOfTargetInLca;\n\n  var allEdges = this.getGraphManager().getAllEdges();\n  for (var i = 0; i < allEdges.length; i++) {\n    edge = allEdges[i];\n\n    edge.idealLength = this.idealEdgeLength;\n\n    if (edge.isInterGraph) {\n      source = edge.getSource();\n      target = edge.getTarget();\n\n      sizeOfSourceInLca = edge.getSourceInLca().getEstimatedSize();\n      sizeOfTargetInLca = edge.getTargetInLca().getEstimatedSize();\n\n      if (this.useSmartIdealEdgeLengthCalculation) {\n        edge.idealLength += sizeOfSourceInLca + sizeOfTargetInLca - 2 * LayoutConstants.SIMPLE_NODE_SIZE;\n      }\n\n      lcaDepth = edge.getLca().getInclusionTreeDepth();\n\n      edge.idealLength += FDLayoutConstants.DEFAULT_EDGE_LENGTH * FDLayoutConstants.PER_LEVEL_IDEAL_EDGE_LENGTH_FACTOR * (source.getInclusionTreeDepth() + target.getInclusionTreeDepth() - 2 * lcaDepth);\n    }\n  }\n};\n\nFDLayout.prototype.initSpringEmbedder = function () {\n\n  var s = this.getAllNodes().length;\n  if (this.incremental) {\n    if (s > FDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT) {\n      this.coolingFactor = Math.max(this.coolingFactor * FDLayoutConstants.COOLING_ADAPTATION_FACTOR, this.coolingFactor - (s - FDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT) / (FDLayoutConstants.ADAPTATION_UPPER_NODE_LIMIT - FDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT) * this.coolingFactor * (1 - FDLayoutConstants.COOLING_ADAPTATION_FACTOR));\n    }\n    this.maxNodeDisplacement = FDLayoutConstants.MAX_NODE_DISPLACEMENT_INCREMENTAL;\n  } else {\n    if (s > FDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT) {\n      this.coolingFactor = Math.max(FDLayoutConstants.COOLING_ADAPTATION_FACTOR, 1.0 - (s - FDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT) / (FDLayoutConstants.ADAPTATION_UPPER_NODE_LIMIT - FDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT) * (1 - FDLayoutConstants.COOLING_ADAPTATION_FACTOR));\n    } else {\n      this.coolingFactor = 1.0;\n    }\n    this.initialCoolingFactor = this.coolingFactor;\n    this.maxNodeDisplacement = FDLayoutConstants.MAX_NODE_DISPLACEMENT;\n  }\n\n  this.maxIterations = Math.max(this.getAllNodes().length * 5, this.maxIterations);\n\n  this.totalDisplacementThreshold = this.displacementThresholdPerNode * this.getAllNodes().length;\n\n  this.repulsionRange = this.calcRepulsionRange();\n};\n\nFDLayout.prototype.calcSpringForces = function () {\n  var lEdges = this.getAllEdges();\n  var edge;\n\n  for (var i = 0; i < lEdges.length; i++) {\n    edge = lEdges[i];\n\n    this.calcSpringForce(edge, edge.idealLength);\n  }\n};\n\nFDLayout.prototype.calcRepulsionForces = function () {\n  var gridUpdateAllowed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n  var forceToNodeSurroundingUpdate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n  var i, j;\n  var nodeA, nodeB;\n  var lNodes = this.getAllNodes();\n  var processedNodeSet;\n\n  if (this.useFRGridVariant) {\n    if (this.totalIterations % FDLayoutConstants.GRID_CALCULATION_CHECK_PERIOD == 1 && gridUpdateAllowed) {\n      this.updateGrid();\n    }\n\n    processedNodeSet = new Set();\n\n    // calculate repulsion forces between each nodes and its surrounding\n    for (i = 0; i < lNodes.length; i++) {\n      nodeA = lNodes[i];\n      this.calculateRepulsionForceOfANode(nodeA, processedNodeSet, gridUpdateAllowed, forceToNodeSurroundingUpdate);\n      processedNodeSet.add(nodeA);\n    }\n  } else {\n    for (i = 0; i < lNodes.length; i++) {\n      nodeA = lNodes[i];\n\n      for (j = i + 1; j < lNodes.length; j++) {\n        nodeB = lNodes[j];\n\n        // If both nodes are not members of the same graph, skip.\n        if (nodeA.getOwner() != nodeB.getOwner()) {\n          continue;\n        }\n\n        this.calcRepulsionForce(nodeA, nodeB);\n      }\n    }\n  }\n};\n\nFDLayout.prototype.calcGravitationalForces = function () {\n  var node;\n  var lNodes = this.getAllNodesToApplyGravitation();\n\n  for (var i = 0; i < lNodes.length; i++) {\n    node = lNodes[i];\n    this.calcGravitationalForce(node);\n  }\n};\n\nFDLayout.prototype.moveNodes = function () {\n  var lNodes = this.getAllNodes();\n  var node;\n\n  for (var i = 0; i < lNodes.length; i++) {\n    node = lNodes[i];\n    node.move();\n  }\n};\n\nFDLayout.prototype.calcSpringForce = function (edge, idealLength) {\n  var sourceNode = edge.getSource();\n  var targetNode = edge.getTarget();\n\n  var length;\n  var springForce;\n  var springForceX;\n  var springForceY;\n\n  // Update edge length\n  if (this.uniformLeafNodeSizes && sourceNode.getChild() == null && targetNode.getChild() == null) {\n    edge.updateLengthSimple();\n  } else {\n    edge.updateLength();\n\n    if (edge.isOverlapingSourceAndTarget) {\n      return;\n    }\n  }\n\n  length = edge.getLength();\n\n  if (length == 0) return;\n\n  // Calculate spring forces\n  springForce = this.springConstant * (length - idealLength);\n\n  // Project force onto x and y axes\n  springForceX = springForce * (edge.lengthX / length);\n  springForceY = springForce * (edge.lengthY / length);\n\n  // Apply forces on the end nodes\n  sourceNode.springForceX += springForceX;\n  sourceNode.springForceY += springForceY;\n  targetNode.springForceX -= springForceX;\n  targetNode.springForceY -= springForceY;\n};\n\nFDLayout.prototype.calcRepulsionForce = function (nodeA, nodeB) {\n  var rectA = nodeA.getRect();\n  var rectB = nodeB.getRect();\n  var overlapAmount = new Array(2);\n  var clipPoints = new Array(4);\n  var distanceX;\n  var distanceY;\n  var distanceSquared;\n  var distance;\n  var repulsionForce;\n  var repulsionForceX;\n  var repulsionForceY;\n\n  if (rectA.intersects(rectB)) // two nodes overlap\n    {\n      // calculate separation amount in x and y directions\n      IGeometry.calcSeparationAmount(rectA, rectB, overlapAmount, FDLayoutConstants.DEFAULT_EDGE_LENGTH / 2.0);\n\n      repulsionForceX = 2 * overlapAmount[0];\n      repulsionForceY = 2 * overlapAmount[1];\n\n      var childrenConstant = nodeA.noOfChildren * nodeB.noOfChildren / (nodeA.noOfChildren + nodeB.noOfChildren);\n\n      // Apply forces on the two nodes\n      nodeA.repulsionForceX -= childrenConstant * repulsionForceX;\n      nodeA.repulsionForceY -= childrenConstant * repulsionForceY;\n      nodeB.repulsionForceX += childrenConstant * repulsionForceX;\n      nodeB.repulsionForceY += childrenConstant * repulsionForceY;\n    } else // no overlap\n    {\n      // calculate distance\n\n      if (this.uniformLeafNodeSizes && nodeA.getChild() == null && nodeB.getChild() == null) // simply base repulsion on distance of node centers\n        {\n          distanceX = rectB.getCenterX() - rectA.getCenterX();\n          distanceY = rectB.getCenterY() - rectA.getCenterY();\n        } else // use clipping points\n        {\n          IGeometry.getIntersection(rectA, rectB, clipPoints);\n\n          distanceX = clipPoints[2] - clipPoints[0];\n          distanceY = clipPoints[3] - clipPoints[1];\n        }\n\n      // No repulsion range. FR grid variant should take care of this.\n      if (Math.abs(distanceX) < FDLayoutConstants.MIN_REPULSION_DIST) {\n        distanceX = IMath.sign(distanceX) * FDLayoutConstants.MIN_REPULSION_DIST;\n      }\n\n      if (Math.abs(distanceY) < FDLayoutConstants.MIN_REPULSION_DIST) {\n        distanceY = IMath.sign(distanceY) * FDLayoutConstants.MIN_REPULSION_DIST;\n      }\n\n      distanceSquared = distanceX * distanceX + distanceY * distanceY;\n      distance = Math.sqrt(distanceSquared);\n\n      repulsionForce = this.repulsionConstant * nodeA.noOfChildren * nodeB.noOfChildren / distanceSquared;\n\n      // Project force onto x and y axes\n      repulsionForceX = repulsionForce * distanceX / distance;\n      repulsionForceY = repulsionForce * distanceY / distance;\n\n      // Apply forces on the two nodes    \n      nodeA.repulsionForceX -= repulsionForceX;\n      nodeA.repulsionForceY -= repulsionForceY;\n      nodeB.repulsionForceX += repulsionForceX;\n      nodeB.repulsionForceY += repulsionForceY;\n    }\n};\n\nFDLayout.prototype.calcGravitationalForce = function (node) {\n  var ownerGraph;\n  var ownerCenterX;\n  var ownerCenterY;\n  var distanceX;\n  var distanceY;\n  var absDistanceX;\n  var absDistanceY;\n  var estimatedSize;\n  ownerGraph = node.getOwner();\n\n  ownerCenterX = (ownerGraph.getRight() + ownerGraph.getLeft()) / 2;\n  ownerCenterY = (ownerGraph.getTop() + ownerGraph.getBottom()) / 2;\n  distanceX = node.getCenterX() - ownerCenterX;\n  distanceY = node.getCenterY() - ownerCenterY;\n  absDistanceX = Math.abs(distanceX) + node.getWidth() / 2;\n  absDistanceY = Math.abs(distanceY) + node.getHeight() / 2;\n\n  if (node.getOwner() == this.graphManager.getRoot()) // in the root graph\n    {\n      estimatedSize = ownerGraph.getEstimatedSize() * this.gravityRangeFactor;\n\n      if (absDistanceX > estimatedSize || absDistanceY > estimatedSize) {\n        node.gravitationForceX = -this.gravityConstant * distanceX;\n        node.gravitationForceY = -this.gravityConstant * distanceY;\n      }\n    } else // inside a compound\n    {\n      estimatedSize = ownerGraph.getEstimatedSize() * this.compoundGravityRangeFactor;\n\n      if (absDistanceX > estimatedSize || absDistanceY > estimatedSize) {\n        node.gravitationForceX = -this.gravityConstant * distanceX * this.compoundGravityConstant;\n        node.gravitationForceY = -this.gravityConstant * distanceY * this.compoundGravityConstant;\n      }\n    }\n};\n\nFDLayout.prototype.isConverged = function () {\n  var converged;\n  var oscilating = false;\n\n  if (this.totalIterations > this.maxIterations / 3) {\n    oscilating = Math.abs(this.totalDisplacement - this.oldTotalDisplacement) < 2;\n  }\n\n  converged = this.totalDisplacement < this.totalDisplacementThreshold;\n\n  this.oldTotalDisplacement = this.totalDisplacement;\n\n  return converged || oscilating;\n};\n\nFDLayout.prototype.animate = function () {\n  if (this.animationDuringLayout && !this.isSubLayout) {\n    if (this.notAnimatedIterations == this.animationPeriod) {\n      this.update();\n      this.notAnimatedIterations = 0;\n    } else {\n      this.notAnimatedIterations++;\n    }\n  }\n};\n\n//This method calculates the number of children (weight) for all nodes\nFDLayout.prototype.calcNoOfChildrenForAllNodes = function () {\n  var node;\n  var allNodes = this.graphManager.getAllNodes();\n\n  for (var i = 0; i < allNodes.length; i++) {\n    node = allNodes[i];\n    node.noOfChildren = node.getNoOfChildren();\n  }\n};\n\n// -----------------------------------------------------------------------------\n// Section: FR-Grid Variant Repulsion Force Calculation\n// -----------------------------------------------------------------------------\n\nFDLayout.prototype.calcGrid = function (graph) {\n\n  var sizeX = 0;\n  var sizeY = 0;\n\n  sizeX = parseInt(Math.ceil((graph.getRight() - graph.getLeft()) / this.repulsionRange));\n  sizeY = parseInt(Math.ceil((graph.getBottom() - graph.getTop()) / this.repulsionRange));\n\n  var grid = new Array(sizeX);\n\n  for (var i = 0; i < sizeX; i++) {\n    grid[i] = new Array(sizeY);\n  }\n\n  for (var i = 0; i < sizeX; i++) {\n    for (var j = 0; j < sizeY; j++) {\n      grid[i][j] = new Array();\n    }\n  }\n\n  return grid;\n};\n\nFDLayout.prototype.addNodeToGrid = function (v, left, top) {\n\n  var startX = 0;\n  var finishX = 0;\n  var startY = 0;\n  var finishY = 0;\n\n  startX = parseInt(Math.floor((v.getRect().x - left) / this.repulsionRange));\n  finishX = parseInt(Math.floor((v.getRect().width + v.getRect().x - left) / this.repulsionRange));\n  startY = parseInt(Math.floor((v.getRect().y - top) / this.repulsionRange));\n  finishY = parseInt(Math.floor((v.getRect().height + v.getRect().y - top) / this.repulsionRange));\n\n  for (var i = startX; i <= finishX; i++) {\n    for (var j = startY; j <= finishY; j++) {\n      this.grid[i][j].push(v);\n      v.setGridCoordinates(startX, finishX, startY, finishY);\n    }\n  }\n};\n\nFDLayout.prototype.updateGrid = function () {\n  var i;\n  var nodeA;\n  var lNodes = this.getAllNodes();\n\n  this.grid = this.calcGrid(this.graphManager.getRoot());\n\n  // put all nodes to proper grid cells\n  for (i = 0; i < lNodes.length; i++) {\n    nodeA = lNodes[i];\n    this.addNodeToGrid(nodeA, this.graphManager.getRoot().getLeft(), this.graphManager.getRoot().getTop());\n  }\n};\n\nFDLayout.prototype.calculateRepulsionForceOfANode = function (nodeA, processedNodeSet, gridUpdateAllowed, forceToNodeSurroundingUpdate) {\n\n  if (this.totalIterations % FDLayoutConstants.GRID_CALCULATION_CHECK_PERIOD == 1 && gridUpdateAllowed || forceToNodeSurroundingUpdate) {\n    var surrounding = new Set();\n    nodeA.surrounding = new Array();\n    var nodeB;\n    var grid = this.grid;\n\n    for (var i = nodeA.startX - 1; i < nodeA.finishX + 2; i++) {\n      for (var j = nodeA.startY - 1; j < nodeA.finishY + 2; j++) {\n        if (!(i < 0 || j < 0 || i >= grid.length || j >= grid[0].length)) {\n          for (var k = 0; k < grid[i][j].length; k++) {\n            nodeB = grid[i][j][k];\n\n            // If both nodes are not members of the same graph, \n            // or both nodes are the same, skip.\n            if (nodeA.getOwner() != nodeB.getOwner() || nodeA == nodeB) {\n              continue;\n            }\n\n            // check if the repulsion force between\n            // nodeA and nodeB has already been calculated\n            if (!processedNodeSet.has(nodeB) && !surrounding.has(nodeB)) {\n              var distanceX = Math.abs(nodeA.getCenterX() - nodeB.getCenterX()) - (nodeA.getWidth() / 2 + nodeB.getWidth() / 2);\n              var distanceY = Math.abs(nodeA.getCenterY() - nodeB.getCenterY()) - (nodeA.getHeight() / 2 + nodeB.getHeight() / 2);\n\n              // if the distance between nodeA and nodeB \n              // is less then calculation range\n              if (distanceX <= this.repulsionRange && distanceY <= this.repulsionRange) {\n                //then add nodeB to surrounding of nodeA\n                surrounding.add(nodeB);\n              }\n            }\n          }\n        }\n      }\n    }\n\n    nodeA.surrounding = [].concat(_toConsumableArray(surrounding));\n  }\n  for (i = 0; i < nodeA.surrounding.length; i++) {\n    this.calcRepulsionForce(nodeA, nodeA.surrounding[i]);\n  }\n};\n\nFDLayout.prototype.calcRepulsionRange = function () {\n  return 0.0;\n};\n\nmodule.exports = FDLayout;\n\n/***/ }),\n/* 19 */\n/***/ (function(module, exports, __nested_webpack_require_100902__) {\n\n\"use strict\";\n\n\nvar LEdge = __nested_webpack_require_100902__(1);\nvar FDLayoutConstants = __nested_webpack_require_100902__(7);\n\nfunction FDLayoutEdge(source, target, vEdge) {\n  LEdge.call(this, source, target, vEdge);\n  this.idealLength = FDLayoutConstants.DEFAULT_EDGE_LENGTH;\n}\n\nFDLayoutEdge.prototype = Object.create(LEdge.prototype);\n\nfor (var prop in LEdge) {\n  FDLayoutEdge[prop] = LEdge[prop];\n}\n\nmodule.exports = FDLayoutEdge;\n\n/***/ }),\n/* 20 */\n/***/ (function(module, exports, __nested_webpack_require_101387__) {\n\n\"use strict\";\n\n\nvar LNode = __nested_webpack_require_101387__(3);\n\nfunction FDLayoutNode(gm, loc, size, vNode) {\n  // alternative constructor is handled inside LNode\n  LNode.call(this, gm, loc, size, vNode);\n  //Spring, repulsion and gravitational forces acting on this node\n  this.springForceX = 0;\n  this.springForceY = 0;\n  this.repulsionForceX = 0;\n  this.repulsionForceY = 0;\n  this.gravitationForceX = 0;\n  this.gravitationForceY = 0;\n  //Amount by which this node is to be moved in this iteration\n  this.displacementX = 0;\n  this.displacementY = 0;\n\n  //Start and finish grid coordinates that this node is fallen into\n  this.startX = 0;\n  this.finishX = 0;\n  this.startY = 0;\n  this.finishY = 0;\n\n  //Geometric neighbors of this node\n  this.surrounding = [];\n}\n\nFDLayoutNode.prototype = Object.create(LNode.prototype);\n\nfor (var prop in LNode) {\n  FDLayoutNode[prop] = LNode[prop];\n}\n\nFDLayoutNode.prototype.setGridCoordinates = function (_startX, _finishX, _startY, _finishY) {\n  this.startX = _startX;\n  this.finishX = _finishX;\n  this.startY = _startY;\n  this.finishY = _finishY;\n};\n\nmodule.exports = FDLayoutNode;\n\n/***/ }),\n/* 21 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nfunction DimensionD(width, height) {\n  this.width = 0;\n  this.height = 0;\n  if (width !== null && height !== null) {\n    this.height = height;\n    this.width = width;\n  }\n}\n\nDimensionD.prototype.getWidth = function () {\n  return this.width;\n};\n\nDimensionD.prototype.setWidth = function (width) {\n  this.width = width;\n};\n\nDimensionD.prototype.getHeight = function () {\n  return this.height;\n};\n\nDimensionD.prototype.setHeight = function (height) {\n  this.height = height;\n};\n\nmodule.exports = DimensionD;\n\n/***/ }),\n/* 22 */\n/***/ (function(module, exports, __nested_webpack_require_103173__) {\n\n\"use strict\";\n\n\nvar UniqueIDGeneretor = __nested_webpack_require_103173__(14);\n\nfunction HashMap() {\n  this.map = {};\n  this.keys = [];\n}\n\nHashMap.prototype.put = function (key, value) {\n  var theId = UniqueIDGeneretor.createID(key);\n  if (!this.contains(theId)) {\n    this.map[theId] = value;\n    this.keys.push(key);\n  }\n};\n\nHashMap.prototype.contains = function (key) {\n  var theId = UniqueIDGeneretor.createID(key);\n  return this.map[key] != null;\n};\n\nHashMap.prototype.get = function (key) {\n  var theId = UniqueIDGeneretor.createID(key);\n  return this.map[theId];\n};\n\nHashMap.prototype.keySet = function () {\n  return this.keys;\n};\n\nmodule.exports = HashMap;\n\n/***/ }),\n/* 23 */\n/***/ (function(module, exports, __nested_webpack_require_103901__) {\n\n\"use strict\";\n\n\nvar UniqueIDGeneretor = __nested_webpack_require_103901__(14);\n\nfunction HashSet() {\n  this.set = {};\n}\n;\n\nHashSet.prototype.add = function (obj) {\n  var theId = UniqueIDGeneretor.createID(obj);\n  if (!this.contains(theId)) this.set[theId] = obj;\n};\n\nHashSet.prototype.remove = function (obj) {\n  delete this.set[UniqueIDGeneretor.createID(obj)];\n};\n\nHashSet.prototype.clear = function () {\n  this.set = {};\n};\n\nHashSet.prototype.contains = function (obj) {\n  return this.set[UniqueIDGeneretor.createID(obj)] == obj;\n};\n\nHashSet.prototype.isEmpty = function () {\n  return this.size() === 0;\n};\n\nHashSet.prototype.size = function () {\n  return Object.keys(this.set).length;\n};\n\n//concats this.set to the given list\nHashSet.prototype.addAllTo = function (list) {\n  var keys = Object.keys(this.set);\n  var length = keys.length;\n  for (var i = 0; i < length; i++) {\n    list.push(this.set[keys[i]]);\n  }\n};\n\nHashSet.prototype.size = function () {\n  return Object.keys(this.set).length;\n};\n\nHashSet.prototype.addAll = function (list) {\n  var s = list.length;\n  for (var i = 0; i < s; i++) {\n    var v = list[i];\n    this.add(v);\n  }\n};\n\nmodule.exports = HashSet;\n\n/***/ }),\n/* 24 */\n/***/ (function(module, exports, __nested_webpack_require_105138__) {\n\n\"use strict\";\n\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * A classic Quicksort algorithm with Hoare's partition\n * - Works also on LinkedList objects\n *\n * Copyright: i-Vis Research Group, Bilkent University, 2007 - present\n */\n\nvar LinkedList = __nested_webpack_require_105138__(11);\n\nvar Quicksort = function () {\n    function Quicksort(A, compareFunction) {\n        _classCallCheck(this, Quicksort);\n\n        if (compareFunction !== null || compareFunction !== undefined) this.compareFunction = this._defaultCompareFunction;\n\n        var length = void 0;\n        if (A instanceof LinkedList) length = A.size();else length = A.length;\n\n        this._quicksort(A, 0, length - 1);\n    }\n\n    _createClass(Quicksort, [{\n        key: '_quicksort',\n        value: function _quicksort(A, p, r) {\n            if (p < r) {\n                var q = this._partition(A, p, r);\n                this._quicksort(A, p, q);\n                this._quicksort(A, q + 1, r);\n            }\n        }\n    }, {\n        key: '_partition',\n        value: function _partition(A, p, r) {\n            var x = this._get(A, p);\n            var i = p;\n            var j = r;\n            while (true) {\n                while (this.compareFunction(x, this._get(A, j))) {\n                    j--;\n                }while (this.compareFunction(this._get(A, i), x)) {\n                    i++;\n                }if (i < j) {\n                    this._swap(A, i, j);\n                    i++;\n                    j--;\n                } else return j;\n            }\n        }\n    }, {\n        key: '_get',\n        value: function _get(object, index) {\n            if (object instanceof LinkedList) return object.get_object_at(index);else return object[index];\n        }\n    }, {\n        key: '_set',\n        value: function _set(object, index, value) {\n            if (object instanceof LinkedList) object.set_object_at(index, value);else object[index] = value;\n        }\n    }, {\n        key: '_swap',\n        value: function _swap(A, i, j) {\n            var temp = this._get(A, i);\n            this._set(A, i, this._get(A, j));\n            this._set(A, j, temp);\n        }\n    }, {\n        key: '_defaultCompareFunction',\n        value: function _defaultCompareFunction(a, b) {\n            return b > a;\n        }\n    }]);\n\n    return Quicksort;\n}();\n\nmodule.exports = Quicksort;\n\n/***/ }),\n/* 25 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n *   Needleman-Wunsch algorithm is an procedure to compute the optimal global alignment of two string\n *   sequences by S.B.Needleman and C.D.Wunsch (1970).\n *\n *   Aside from the inputs, you can assign the scores for,\n *   - Match: The two characters at the current index are same.\n *   - Mismatch: The two characters at the current index are different.\n *   - Insertion/Deletion(gaps): The best alignment involves one letter aligning to a gap in the other string.\n */\n\nvar NeedlemanWunsch = function () {\n    function NeedlemanWunsch(sequence1, sequence2) {\n        var match_score = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n        var mismatch_penalty = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : -1;\n        var gap_penalty = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : -1;\n\n        _classCallCheck(this, NeedlemanWunsch);\n\n        this.sequence1 = sequence1;\n        this.sequence2 = sequence2;\n        this.match_score = match_score;\n        this.mismatch_penalty = mismatch_penalty;\n        this.gap_penalty = gap_penalty;\n\n        // Just the remove redundancy\n        this.iMax = sequence1.length + 1;\n        this.jMax = sequence2.length + 1;\n\n        // Grid matrix of scores\n        this.grid = new Array(this.iMax);\n        for (var i = 0; i < this.iMax; i++) {\n            this.grid[i] = new Array(this.jMax);\n\n            for (var j = 0; j < this.jMax; j++) {\n                this.grid[i][j] = 0;\n            }\n        }\n\n        // Traceback matrix (2D array, each cell is an array of boolean values for [`Diag`, `Up`, `Left`] positions)\n        this.tracebackGrid = new Array(this.iMax);\n        for (var _i = 0; _i < this.iMax; _i++) {\n            this.tracebackGrid[_i] = new Array(this.jMax);\n\n            for (var _j = 0; _j < this.jMax; _j++) {\n                this.tracebackGrid[_i][_j] = [null, null, null];\n            }\n        }\n\n        // The aligned sequences (return multiple possibilities)\n        this.alignments = [];\n\n        // Final alignment score\n        this.score = -1;\n\n        // Calculate scores and tracebacks\n        this.computeGrids();\n    }\n\n    _createClass(NeedlemanWunsch, [{\n        key: \"getScore\",\n        value: function getScore() {\n            return this.score;\n        }\n    }, {\n        key: \"getAlignments\",\n        value: function getAlignments() {\n            return this.alignments;\n        }\n\n        // Main dynamic programming procedure\n\n    }, {\n        key: \"computeGrids\",\n        value: function computeGrids() {\n            // Fill in the first row\n            for (var j = 1; j < this.jMax; j++) {\n                this.grid[0][j] = this.grid[0][j - 1] + this.gap_penalty;\n                this.tracebackGrid[0][j] = [false, false, true];\n            }\n\n            // Fill in the first column\n            for (var i = 1; i < this.iMax; i++) {\n                this.grid[i][0] = this.grid[i - 1][0] + this.gap_penalty;\n                this.tracebackGrid[i][0] = [false, true, false];\n            }\n\n            // Fill the rest of the grid\n            for (var _i2 = 1; _i2 < this.iMax; _i2++) {\n                for (var _j2 = 1; _j2 < this.jMax; _j2++) {\n                    // Find the max score(s) among [`Diag`, `Up`, `Left`]\n                    var diag = void 0;\n                    if (this.sequence1[_i2 - 1] === this.sequence2[_j2 - 1]) diag = this.grid[_i2 - 1][_j2 - 1] + this.match_score;else diag = this.grid[_i2 - 1][_j2 - 1] + this.mismatch_penalty;\n\n                    var up = this.grid[_i2 - 1][_j2] + this.gap_penalty;\n                    var left = this.grid[_i2][_j2 - 1] + this.gap_penalty;\n\n                    // If there exists multiple max values, capture them for multiple paths\n                    var maxOf = [diag, up, left];\n                    var indices = this.arrayAllMaxIndexes(maxOf);\n\n                    // Update Grids\n                    this.grid[_i2][_j2] = maxOf[indices[0]];\n                    this.tracebackGrid[_i2][_j2] = [indices.includes(0), indices.includes(1), indices.includes(2)];\n                }\n            }\n\n            // Update alignment score\n            this.score = this.grid[this.iMax - 1][this.jMax - 1];\n        }\n\n        // Gets all possible valid sequence combinations\n\n    }, {\n        key: \"alignmentTraceback\",\n        value: function alignmentTraceback() {\n            var inProcessAlignments = [];\n\n            inProcessAlignments.push({ pos: [this.sequence1.length, this.sequence2.length],\n                seq1: \"\",\n                seq2: \"\"\n            });\n\n            while (inProcessAlignments[0]) {\n                var current = inProcessAlignments[0];\n                var directions = this.tracebackGrid[current.pos[0]][current.pos[1]];\n\n                if (directions[0]) {\n                    inProcessAlignments.push({ pos: [current.pos[0] - 1, current.pos[1] - 1],\n                        seq1: this.sequence1[current.pos[0] - 1] + current.seq1,\n                        seq2: this.sequence2[current.pos[1] - 1] + current.seq2\n                    });\n                }\n                if (directions[1]) {\n                    inProcessAlignments.push({ pos: [current.pos[0] - 1, current.pos[1]],\n                        seq1: this.sequence1[current.pos[0] - 1] + current.seq1,\n                        seq2: '-' + current.seq2\n                    });\n                }\n                if (directions[2]) {\n                    inProcessAlignments.push({ pos: [current.pos[0], current.pos[1] - 1],\n                        seq1: '-' + current.seq1,\n                        seq2: this.sequence2[current.pos[1] - 1] + current.seq2\n                    });\n                }\n\n                if (current.pos[0] === 0 && current.pos[1] === 0) this.alignments.push({ sequence1: current.seq1,\n                    sequence2: current.seq2\n                });\n\n                inProcessAlignments.shift();\n            }\n\n            return this.alignments;\n        }\n\n        // Helper Functions\n\n    }, {\n        key: \"getAllIndexes\",\n        value: function getAllIndexes(arr, val) {\n            var indexes = [],\n                i = -1;\n            while ((i = arr.indexOf(val, i + 1)) !== -1) {\n                indexes.push(i);\n            }\n            return indexes;\n        }\n    }, {\n        key: \"arrayAllMaxIndexes\",\n        value: function arrayAllMaxIndexes(array) {\n            return this.getAllIndexes(array, Math.max.apply(null, array));\n        }\n    }]);\n\n    return NeedlemanWunsch;\n}();\n\nmodule.exports = NeedlemanWunsch;\n\n/***/ }),\n/* 26 */\n/***/ (function(module, exports, __nested_webpack_require_115611__) {\n\n\"use strict\";\n\n\nvar layoutBase = function layoutBase() {\n  return;\n};\n\nlayoutBase.FDLayout = __nested_webpack_require_115611__(18);\nlayoutBase.FDLayoutConstants = __nested_webpack_require_115611__(7);\nlayoutBase.FDLayoutEdge = __nested_webpack_require_115611__(19);\nlayoutBase.FDLayoutNode = __nested_webpack_require_115611__(20);\nlayoutBase.DimensionD = __nested_webpack_require_115611__(21);\nlayoutBase.HashMap = __nested_webpack_require_115611__(22);\nlayoutBase.HashSet = __nested_webpack_require_115611__(23);\nlayoutBase.IGeometry = __nested_webpack_require_115611__(8);\nlayoutBase.IMath = __nested_webpack_require_115611__(9);\nlayoutBase.Integer = __nested_webpack_require_115611__(10);\nlayoutBase.Point = __nested_webpack_require_115611__(12);\nlayoutBase.PointD = __nested_webpack_require_115611__(4);\nlayoutBase.RandomSeed = __nested_webpack_require_115611__(16);\nlayoutBase.RectangleD = __nested_webpack_require_115611__(13);\nlayoutBase.Transform = __nested_webpack_require_115611__(17);\nlayoutBase.UniqueIDGeneretor = __nested_webpack_require_115611__(14);\nlayoutBase.Quicksort = __nested_webpack_require_115611__(24);\nlayoutBase.LinkedList = __nested_webpack_require_115611__(11);\nlayoutBase.LGraphObject = __nested_webpack_require_115611__(2);\nlayoutBase.LGraph = __nested_webpack_require_115611__(5);\nlayoutBase.LEdge = __nested_webpack_require_115611__(1);\nlayoutBase.LGraphManager = __nested_webpack_require_115611__(6);\nlayoutBase.LNode = __nested_webpack_require_115611__(3);\nlayoutBase.Layout = __nested_webpack_require_115611__(15);\nlayoutBase.LayoutConstants = __nested_webpack_require_115611__(0);\nlayoutBase.NeedlemanWunsch = __nested_webpack_require_115611__(25);\n\nmodule.exports = layoutBase;\n\n/***/ }),\n/* 27 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nfunction Emitter() {\n  this.listeners = [];\n}\n\nvar p = Emitter.prototype;\n\np.addListener = function (event, callback) {\n  this.listeners.push({\n    event: event,\n    callback: callback\n  });\n};\n\np.removeListener = function (event, callback) {\n  for (var i = this.listeners.length; i >= 0; i--) {\n    var l = this.listeners[i];\n\n    if (l.event === event && l.callback === callback) {\n      this.listeners.splice(i, 1);\n    }\n  }\n};\n\np.emit = function (event, data) {\n  for (var i = 0; i < this.listeners.length; i++) {\n    var l = this.listeners[i];\n\n    if (event === l.event) {\n      l.callback(data);\n    }\n  }\n};\n\nmodule.exports = Emitter;\n\n/***/ })\n/******/ ]);\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbGF5b3V0LWJhc2UvbGF5b3V0LWJhc2UuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxJQUFJLElBQXlEO0FBQzdEO0FBQ0EsTUFBTSxFQUsyQjtBQUNqQyxDQUFDO0FBQ0QscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDhCQUFtQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRSw4QkFBbUI7QUFDN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDhCQUFtQjtBQUM3QjtBQUNBO0FBQ0EsVUFBVSw4QkFBbUI7QUFDN0I7QUFDQTtBQUNBLFVBQVUsOEJBQW1CLHVCQUF1QjtBQUNwRDtBQUNBO0FBQ0EsVUFBVSw4QkFBbUI7QUFDN0IsZUFBZSw4QkFBbUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDhCQUFtQjtBQUM3QjtBQUNBLG9DQUFvQyw0QkFBNEI7QUFDaEUsMENBQTBDO0FBQzFDLFdBQVcsOEJBQW1CO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSw4QkFBbUIsa0NBQWtDO0FBQy9EO0FBQ0E7QUFDQSxVQUFVLDhCQUFtQjtBQUM3QjtBQUNBO0FBQ0EsaUJBQWlCLDhCQUFtQixDQUFDLDhCQUFtQjtBQUN4RCxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztB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Q0E7O0FBRUE7QUFDQTs7QUFFQSxrQkFBa0IsT0FBTztBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0IsT0FBTztBQUN6Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsa0JBQWtCLE9BQU87QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixPQUFPO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25COztBQUVBO0FBQ0E7QUFDQSwwQkFBMEIsS0FBSzs7QUFFL0I7QUFDQTtBQUNBLDBCQUEwQixLQUFLOztBQUUvQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLElBQUk7QUFDSixvQ0FBb0M7QUFDcEMsSUFBSTtBQUNKLDRCQUE0QjtBQUM1Qjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7O0FBR0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7O0FBR0EsaUNBQWlDLDJDQUEyQyxnQkFBZ0Isa0JBQWtCLE9BQU8sMkJBQTJCLHdEQUF3RCxnQ0FBZ0MsdURBQXVELCtEQUErRCx5REFBeUQscUVBQXFFLDZEQUE2RCx3QkFBd0I7O0FBRWpqQixrREFBa0QsMENBQTBDOztBQUU1RjtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNO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QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixxQkFBcUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxrQkFBa0IsV0FBVztBQUM3QjtB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QjtBQUMzQyx3QkFBd0IsaUNBQW1CO0FBQzNDLHVCQUF1QixpQ0FBbUI7QUFDMUMsK0JBQStCLGlDQUFtQjtBQUNsRCx1QkFBdUIsaUNBQW1CO0FBQzFDLHdCQUF3QixpQ0FBbUI7QUFDM0MsMEJBQTBCLGlDQUFtQjtBQUM3QyxvQkFBb0IsaUNBQW1CO0FBQ3ZDLG1CQUFtQixpQ0FBbUI7QUFDdEMsMkJBQTJCLGlDQUFtQjtBQUM5QyxtQkFBbUIsaUNBQW1CO0FBQ3RDLG9CQUFvQixpQ0FBbUI7QUFDdkMsNkJBQTZCLGlDQUFtQjtBQUNoRCw2QkFBNkIsaUNBQW1COztBQUVoRDs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0Esc0NBQXNDLFFBQVE7QUFDOUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQiwyQkFBMkI7QUFDN0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9sYXlvdXQtYmFzZS9sYXlvdXQtYmFzZS5qcz9hNWM0Il0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFtdLCBmYWN0b3J5KTtcblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG5cdFx0ZXhwb3J0c1tcImxheW91dEJhc2VcIl0gPSBmYWN0b3J5KCk7XG5cdGVsc2Vcblx0XHRyb290W1wibGF5b3V0QmFzZVwiXSA9IGZhY3RvcnkoKTtcbn0pKHRoaXMsIGZ1bmN0aW9uKCkge1xucmV0dXJuIC8qKioqKiovIChmdW5jdGlvbihtb2R1bGVzKSB7IC8vIHdlYnBhY2tCb290c3RyYXBcbi8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbi8qKioqKiovIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbi8qKioqKiovIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4vKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gXHRcdFx0aTogbW9kdWxlSWQsXG4vKioqKioqLyBcdFx0XHRsOiBmYWxzZSxcbi8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9XG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4vKioqKioqLyBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbi8qKioqKiovIFx0XHRtb2R1bGUubCA9IHRydWU7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4vKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHR9XG4vKioqKioqL1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBpZGVudGl0eSBmdW5jdGlvbiBmb3IgY2FsbGluZyBoYXJtb255IGltcG9ydHMgd2l0aCB0aGUgY29ycmVjdCBjb250ZXh0XG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uaSA9IGZ1bmN0aW9uKHZhbHVlKSB7IHJldHVybiB2YWx1ZTsgfTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbi8qKioqKiovIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4vKioqKioqLyBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwge1xuLyoqKioqKi8gXHRcdFx0XHRjb25maWd1cmFibGU6IGZhbHNlLFxuLyoqKioqKi8gXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuLyoqKioqKi8gXHRcdFx0XHRnZXQ6IGdldHRlclxuLyoqKioqKi8gXHRcdFx0fSk7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4vKioqKioqLyBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4vKioqKioqLyBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuLyoqKioqKi8gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4vKioqKioqLyBcdFx0cmV0dXJuIGdldHRlcjtcbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4vKioqKioqLyBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IDI2KTtcbi8qKioqKiovIH0pXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gKFtcbi8qIDAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuZnVuY3Rpb24gTGF5b3V0Q29uc3RhbnRzKCkge31cblxuLyoqXHJcbiAqIExheW91dCBRdWFsaXR5OiAwOmRyYWZ0LCAxOmRlZmF1bHQsIDI6cHJvb2ZcclxuICovXG5MYXlvdXRDb25zdGFudHMuUVVBTElUWSA9IDE7XG5cbi8qKlxyXG4gKiBEZWZhdWx0IHBhcmFtZXRlcnNcclxuICovXG5MYXlvdXRDb25zdGFudHMuREVGQVVMVF9DUkVBVEVfQkVORFNfQVNfTkVFREVEID0gZmFsc2U7XG5MYXlvdXRDb25zdGFudHMuREVGQVVMVF9JTkNSRU1FTlRBTCA9IGZhbHNlO1xuTGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfQU5JTUFUSU9OX09OX0xBWU9VVCA9IHRydWU7XG5MYXlvdXRDb25zdGFudHMuREVGQVVMVF9BTklNQVRJT05fRFVSSU5HX0xBWU9VVCA9IGZhbHNlO1xuTGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfQU5JTUFUSU9OX1BFUklPRCA9IDUwO1xuTGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfVU5JRk9STV9MRUFGX05PREVfU0laRVMgPSBmYWxzZTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFNlY3Rpb246IEdlbmVyYWwgb3RoZXIgY29uc3RhbnRzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLypcclxuICogTWFyZ2lucyBvZiBhIGdyYXBoIHRvIGJlIGFwcGxpZWQgb24gYm91ZGluZyByZWN0YW5nbGUgb2YgaXRzIGNvbnRlbnRzLiBXZVxyXG4gKiBhc3N1bWUgbWFyZ2lucyBvbiBhbGwgZm91ciBzaWRlcyB0byBiZSB1bmlmb3JtLlxyXG4gKi9cbkxheW91dENvbnN0YW50cy5ERUZBVUxUX0dSQVBIX01BUkdJTiA9IDE1O1xuXG4vKlxyXG4gKiBXaGV0aGVyIHRvIGNvbnNpZGVyIGxhYmVscyBpbiBub2RlIGRpbWVuc2lvbnMgb3Igbm90XHJcbiAqL1xuTGF5b3V0Q29uc3RhbnRzLk5PREVfRElNRU5TSU9OU19JTkNMVURFX0xBQkVMUyA9IGZhbHNlO1xuXG4vKlxyXG4gKiBEZWZhdWx0IGRpbWVuc2lvbiBvZiBhIG5vbi1jb21wb3VuZCBub2RlLlxyXG4gKi9cbkxheW91dENvbnN0YW50cy5TSU1QTEVfTk9ERV9TSVpFID0gNDA7XG5cbi8qXHJcbiAqIERlZmF1bHQgZGltZW5zaW9uIG9mIGEgbm9uLWNvbXBvdW5kIG5vZGUuXHJcbiAqL1xuTGF5b3V0Q29uc3RhbnRzLlNJTVBMRV9OT0RFX0hBTEZfU0laRSA9IExheW91dENvbnN0YW50cy5TSU1QTEVfTk9ERV9TSVpFIC8gMjtcblxuLypcclxuICogRW1wdHkgY29tcG91bmQgbm9kZSBzaXplLiBXaGVuIGEgY29tcG91bmQgbm9kZSBpcyBlbXB0eSwgaXRzIGJvdGhcclxuICogZGltZW5zaW9ucyBzaG91bGQgYmUgb2YgdGhpcyB2YWx1ZS5cclxuICovXG5MYXlvdXRDb25zdGFudHMuRU1QVFlfQ09NUE9VTkRfTk9ERV9TSVpFID0gNDA7XG5cbi8qXHJcbiAqIE1pbmltdW0gbGVuZ3RoIHRoYXQgYW4gZWRnZSBzaG91bGQgdGFrZSBkdXJpbmcgbGF5b3V0XHJcbiAqL1xuTGF5b3V0Q29uc3RhbnRzLk1JTl9FREdFX0xFTkdUSCA9IDE7XG5cbi8qXHJcbiAqIFdvcmxkIGJvdW5kYXJpZXMgdGhhdCBsYXlvdXQgb3BlcmF0ZXMgb25cclxuICovXG5MYXlvdXRDb25zdGFudHMuV09STERfQk9VTkRBUlkgPSAxMDAwMDAwO1xuXG4vKlxyXG4gKiBXb3JsZCBib3VuZGFyaWVzIHRoYXQgcmFuZG9tIHBvc2l0aW9uaW5nIGNhbiBiZSBwZXJmb3JtZWQgd2l0aFxyXG4gKi9cbkxheW91dENvbnN0YW50cy5JTklUSUFMX1dPUkxEX0JPVU5EQVJZID0gTGF5b3V0Q29uc3RhbnRzLldPUkxEX0JPVU5EQVJZIC8gMTAwMDtcblxuLypcclxuICogQ29vcmRpbmF0ZXMgb2YgdGhlIHdvcmxkIGNlbnRlclxyXG4gKi9cbkxheW91dENvbnN0YW50cy5XT1JMRF9DRU5URVJfWCA9IDEyMDA7XG5MYXlvdXRDb25zdGFudHMuV09STERfQ0VOVEVSX1kgPSA5MDA7XG5cbm1vZHVsZS5leHBvcnRzID0gTGF5b3V0Q29uc3RhbnRzO1xuXG4vKioqLyB9KSxcbi8qIDEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIExHcmFwaE9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG52YXIgSUdlb21ldHJ5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4KTtcbnZhciBJTWF0aCA9IF9fd2VicGFja19yZXF1aXJlX18oOSk7XG5cbmZ1bmN0aW9uIExFZGdlKHNvdXJjZSwgdGFyZ2V0LCB2RWRnZSkge1xuICBMR3JhcGhPYmplY3QuY2FsbCh0aGlzLCB2RWRnZSk7XG5cbiAgdGhpcy5pc092ZXJsYXBpbmdTb3VyY2VBbmRUYXJnZXQgPSBmYWxzZTtcbiAgdGhpcy52R3JhcGhPYmplY3QgPSB2RWRnZTtcbiAgdGhpcy5iZW5kcG9pbnRzID0gW107XG4gIHRoaXMuc291cmNlID0gc291cmNlO1xuICB0aGlzLnRhcmdldCA9IHRhcmdldDtcbn1cblxuTEVkZ2UucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShMR3JhcGhPYmplY3QucHJvdG90eXBlKTtcblxuZm9yICh2YXIgcHJvcCBpbiBMR3JhcGhPYmplY3QpIHtcbiAgTEVkZ2VbcHJvcF0gPSBMR3JhcGhPYmplY3RbcHJvcF07XG59XG5cbkxFZGdlLnByb3RvdHlwZS5nZXRTb3VyY2UgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnNvdXJjZTtcbn07XG5cbkxFZGdlLnByb3RvdHlwZS5nZXRUYXJnZXQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnRhcmdldDtcbn07XG5cbkxFZGdlLnByb3RvdHlwZS5pc0ludGVyR3JhcGggPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmlzSW50ZXJHcmFwaDtcbn07XG5cbkxFZGdlLnByb3RvdHlwZS5nZXRMZW5ndGggPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmxlbmd0aDtcbn07XG5cbkxFZGdlLnByb3RvdHlwZS5pc092ZXJsYXBpbmdTb3VyY2VBbmRUYXJnZXQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmlzT3ZlcmxhcGluZ1NvdXJjZUFuZFRhcmdldDtcbn07XG5cbkxFZGdlLnByb3RvdHlwZS5nZXRCZW5kcG9pbnRzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5iZW5kcG9pbnRzO1xufTtcblxuTEVkZ2UucHJvdG90eXBlLmdldExjYSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMubGNhO1xufTtcblxuTEVkZ2UucHJvdG90eXBlLmdldFNvdXJjZUluTGNhID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5zb3VyY2VJbkxjYTtcbn07XG5cbkxFZGdlLnByb3RvdHlwZS5nZXRUYXJnZXRJbkxjYSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMudGFyZ2V0SW5MY2E7XG59O1xuXG5MRWRnZS5wcm90b3R5cGUuZ2V0T3RoZXJFbmQgPSBmdW5jdGlvbiAobm9kZSkge1xuICBpZiAodGhpcy5zb3VyY2UgPT09IG5vZGUpIHtcbiAgICByZXR1cm4gdGhpcy50YXJnZXQ7XG4gIH0gZWxzZSBpZiAodGhpcy50YXJnZXQgPT09IG5vZGUpIHtcbiAgICByZXR1cm4gdGhpcy5zb3VyY2U7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgXCJOb2RlIGlzIG5vdCBpbmNpZGVudCB3aXRoIHRoaXMgZWRnZVwiO1xuICB9XG59O1xuXG5MRWRnZS5wcm90b3R5cGUuZ2V0T3RoZXJFbmRJbkdyYXBoID0gZnVuY3Rpb24gKG5vZGUsIGdyYXBoKSB7XG4gIHZhciBvdGhlckVuZCA9IHRoaXMuZ2V0T3RoZXJFbmQobm9kZSk7XG4gIHZhciByb290ID0gZ3JhcGguZ2V0R3JhcGhNYW5hZ2VyKCkuZ2V0Um9vdCgpO1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgaWYgKG90aGVyRW5kLmdldE93bmVyKCkgPT0gZ3JhcGgpIHtcbiAgICAgIHJldHVybiBvdGhlckVuZDtcbiAgICB9XG5cbiAgICBpZiAob3RoZXJFbmQuZ2V0T3duZXIoKSA9PSByb290KSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBvdGhlckVuZCA9IG90aGVyRW5kLmdldE93bmVyKCkuZ2V0UGFyZW50KCk7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn07XG5cbkxFZGdlLnByb3RvdHlwZS51cGRhdGVMZW5ndGggPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBjbGlwUG9pbnRDb29yZGluYXRlcyA9IG5ldyBBcnJheSg0KTtcblxuICB0aGlzLmlzT3ZlcmxhcGluZ1NvdXJjZUFuZFRhcmdldCA9IElHZW9tZXRyeS5nZXRJbnRlcnNlY3Rpb24odGhpcy50YXJnZXQuZ2V0UmVjdCgpLCB0aGlzLnNvdXJjZS5nZXRSZWN0KCksIGNsaXBQb2ludENvb3JkaW5hdGVzKTtcblxuICBpZiAoIXRoaXMuaXNPdmVybGFwaW5nU291cmNlQW5kVGFyZ2V0KSB7XG4gICAgdGhpcy5sZW5ndGhYID0gY2xpcFBvaW50Q29vcmRpbmF0ZXNbMF0gLSBjbGlwUG9pbnRDb29yZGluYXRlc1syXTtcbiAgICB0aGlzLmxlbmd0aFkgPSBjbGlwUG9pbnRDb29yZGluYXRlc1sxXSAtIGNsaXBQb2ludENvb3JkaW5hdGVzWzNdO1xuXG4gICAgaWYgKE1hdGguYWJzKHRoaXMubGVuZ3RoWCkgPCAxLjApIHtcbiAgICAgIHRoaXMubGVuZ3RoWCA9IElNYXRoLnNpZ24odGhpcy5sZW5ndGhYKTtcbiAgICB9XG5cbiAgICBpZiAoTWF0aC5hYnModGhpcy5sZW5ndGhZKSA8IDEuMCkge1xuICAgICAgdGhpcy5sZW5ndGhZID0gSU1hdGguc2lnbih0aGlzLmxlbmd0aFkpO1xuICAgIH1cblxuICAgIHRoaXMubGVuZ3RoID0gTWF0aC5zcXJ0KHRoaXMubGVuZ3RoWCAqIHRoaXMubGVuZ3RoWCArIHRoaXMubGVuZ3RoWSAqIHRoaXMubGVuZ3RoWSk7XG4gIH1cbn07XG5cbkxFZGdlLnByb3RvdHlwZS51cGRhdGVMZW5ndGhTaW1wbGUgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMubGVuZ3RoWCA9IHRoaXMudGFyZ2V0LmdldENlbnRlclgoKSAtIHRoaXMuc291cmNlLmdldENlbnRlclgoKTtcbiAgdGhpcy5sZW5ndGhZID0gdGhpcy50YXJnZXQuZ2V0Q2VudGVyWSgpIC0gdGhpcy5zb3VyY2UuZ2V0Q2VudGVyWSgpO1xuXG4gIGlmIChNYXRoLmFicyh0aGlzLmxlbmd0aFgpIDwgMS4wKSB7XG4gICAgdGhpcy5sZW5ndGhYID0gSU1hdGguc2lnbih0aGlzLmxlbmd0aFgpO1xuICB9XG5cbiAgaWYgKE1hdGguYWJzKHRoaXMubGVuZ3RoWSkgPCAxLjApIHtcbiAgICB0aGlzLmxlbmd0aFkgPSBJTWF0aC5zaWduKHRoaXMubGVuZ3RoWSk7XG4gIH1cblxuICB0aGlzLmxlbmd0aCA9IE1hdGguc3FydCh0aGlzLmxlbmd0aFggKiB0aGlzLmxlbmd0aFggKyB0aGlzLmxlbmd0aFkgKiB0aGlzLmxlbmd0aFkpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBMRWRnZTtcblxuLyoqKi8gfSksXG4vKiAyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbmZ1bmN0aW9uIExHcmFwaE9iamVjdCh2R3JhcGhPYmplY3QpIHtcbiAgdGhpcy52R3JhcGhPYmplY3QgPSB2R3JhcGhPYmplY3Q7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gTEdyYXBoT2JqZWN0O1xuXG4vKioqLyB9KSxcbi8qIDMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIExHcmFwaE9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG52YXIgSW50ZWdlciA9IF9fd2VicGFja19yZXF1aXJlX18oMTApO1xudmFyIFJlY3RhbmdsZUQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzKTtcbnZhciBMYXlvdXRDb25zdGFudHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xudmFyIFJhbmRvbVNlZWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE2KTtcbnZhciBQb2ludEQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuXG5mdW5jdGlvbiBMTm9kZShnbSwgbG9jLCBzaXplLCB2Tm9kZSkge1xuICAvL0FsdGVybmF0aXZlIGNvbnN0cnVjdG9yIDEgOiBMTm9kZShMR3JhcGhNYW5hZ2VyIGdtLCBQb2ludCBsb2MsIERpbWVuc2lvbiBzaXplLCBPYmplY3Qgdk5vZGUpXG4gIGlmIChzaXplID09IG51bGwgJiYgdk5vZGUgPT0gbnVsbCkge1xuICAgIHZOb2RlID0gbG9jO1xuICB9XG5cbiAgTEdyYXBoT2JqZWN0LmNhbGwodGhpcywgdk5vZGUpO1xuXG4gIC8vQWx0ZXJuYXRpdmUgY29uc3RydWN0b3IgMiA6IExOb2RlKExheW91dCBsYXlvdXQsIE9iamVjdCB2Tm9kZSlcbiAgaWYgKGdtLmdyYXBoTWFuYWdlciAhPSBudWxsKSBnbSA9IGdtLmdyYXBoTWFuYWdlcjtcblxuICB0aGlzLmVzdGltYXRlZFNpemUgPSBJbnRlZ2VyLk1JTl9WQUxVRTtcbiAgdGhpcy5pbmNsdXNpb25UcmVlRGVwdGggPSBJbnRlZ2VyLk1BWF9WQUxVRTtcbiAgdGhpcy52R3JhcGhPYmplY3QgPSB2Tm9kZTtcbiAgdGhpcy5lZGdlcyA9IFtdO1xuICB0aGlzLmdyYXBoTWFuYWdlciA9IGdtO1xuXG4gIGlmIChzaXplICE9IG51bGwgJiYgbG9jICE9IG51bGwpIHRoaXMucmVjdCA9IG5ldyBSZWN0YW5nbGVEKGxvYy54LCBsb2MueSwgc2l6ZS53aWR0aCwgc2l6ZS5oZWlnaHQpO2Vsc2UgdGhpcy5yZWN0ID0gbmV3IFJlY3RhbmdsZUQoKTtcbn1cblxuTE5vZGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShMR3JhcGhPYmplY3QucHJvdG90eXBlKTtcbmZvciAodmFyIHByb3AgaW4gTEdyYXBoT2JqZWN0KSB7XG4gIExOb2RlW3Byb3BdID0gTEdyYXBoT2JqZWN0W3Byb3BdO1xufVxuXG5MTm9kZS5wcm90b3R5cGUuZ2V0RWRnZXMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmVkZ2VzO1xufTtcblxuTE5vZGUucHJvdG90eXBlLmdldENoaWxkID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5jaGlsZDtcbn07XG5cbkxOb2RlLnByb3RvdHlwZS5nZXRPd25lciA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gIGlmICh0aGlzLm93bmVyICE9IG51bGwpIHtcbiAgLy8gICAgaWYgKCEodGhpcy5vd25lciA9PSBudWxsIHx8IHRoaXMub3duZXIuZ2V0Tm9kZXMoKS5pbmRleE9mKHRoaXMpID4gLTEpKSB7XG4gIC8vICAgICAgdGhyb3cgXCJhc3NlcnQgZmFpbGVkXCI7XG4gIC8vICAgIH1cbiAgLy8gIH1cblxuICByZXR1cm4gdGhpcy5vd25lcjtcbn07XG5cbkxOb2RlLnByb3RvdHlwZS5nZXRXaWR0aCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMucmVjdC53aWR0aDtcbn07XG5cbkxOb2RlLnByb3RvdHlwZS5zZXRXaWR0aCA9IGZ1bmN0aW9uICh3aWR0aCkge1xuICB0aGlzLnJlY3Qud2lkdGggPSB3aWR0aDtcbn07XG5cbkxOb2RlLnByb3RvdHlwZS5nZXRIZWlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnJlY3QuaGVpZ2h0O1xufTtcblxuTE5vZGUucHJvdG90eXBlLnNldEhlaWdodCA9IGZ1bmN0aW9uIChoZWlnaHQpIHtcbiAgdGhpcy5yZWN0LmhlaWdodCA9IGhlaWdodDtcbn07XG5cbkxOb2RlLnByb3RvdHlwZS5nZXRDZW50ZXJYID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5yZWN0LnggKyB0aGlzLnJlY3Qud2lkdGggLyAyO1xufTtcblxuTE5vZGUucHJvdG90eXBlLmdldENlbnRlclkgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnJlY3QueSArIHRoaXMucmVjdC5oZWlnaHQgLyAyO1xufTtcblxuTE5vZGUucHJvdG90eXBlLmdldENlbnRlciA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIG5ldyBQb2ludEQodGhpcy5yZWN0LnggKyB0aGlzLnJlY3Qud2lkdGggLyAyLCB0aGlzLnJlY3QueSArIHRoaXMucmVjdC5oZWlnaHQgLyAyKTtcbn07XG5cbkxOb2RlLnByb3RvdHlwZS5nZXRMb2NhdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIG5ldyBQb2ludEQodGhpcy5yZWN0LngsIHRoaXMucmVjdC55KTtcbn07XG5cbkxOb2RlLnByb3RvdHlwZS5nZXRSZWN0ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5yZWN0O1xufTtcblxuTE5vZGUucHJvdG90eXBlLmdldERpYWdvbmFsID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gTWF0aC5zcXJ0KHRoaXMucmVjdC53aWR0aCAqIHRoaXMucmVjdC53aWR0aCArIHRoaXMucmVjdC5oZWlnaHQgKiB0aGlzLnJlY3QuaGVpZ2h0KTtcbn07XG5cbi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyBoYWxmIHRoZSBkaWFnb25hbCBsZW5ndGggb2YgdGhpcyBub2RlLlxuICovXG5MTm9kZS5wcm90b3R5cGUuZ2V0SGFsZlRoZURpYWdvbmFsID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gTWF0aC5zcXJ0KHRoaXMucmVjdC5oZWlnaHQgKiB0aGlzLnJlY3QuaGVpZ2h0ICsgdGhpcy5yZWN0LndpZHRoICogdGhpcy5yZWN0LndpZHRoKSAvIDI7XG59O1xuXG5MTm9kZS5wcm90b3R5cGUuc2V0UmVjdCA9IGZ1bmN0aW9uICh1cHBlckxlZnQsIGRpbWVuc2lvbikge1xuICB0aGlzLnJlY3QueCA9IHVwcGVyTGVmdC54O1xuICB0aGlzLnJlY3QueSA9IHVwcGVyTGVmdC55O1xuICB0aGlzLnJlY3Qud2lkdGggPSBkaW1lbnNpb24ud2lkdGg7XG4gIHRoaXMucmVjdC5oZWlnaHQgPSBkaW1lbnNpb24uaGVpZ2h0O1xufTtcblxuTE5vZGUucHJvdG90eXBlLnNldENlbnRlciA9IGZ1bmN0aW9uIChjeCwgY3kpIHtcbiAgdGhpcy5yZWN0LnggPSBjeCAtIHRoaXMucmVjdC53aWR0aCAvIDI7XG4gIHRoaXMucmVjdC55ID0gY3kgLSB0aGlzLnJlY3QuaGVpZ2h0IC8gMjtcbn07XG5cbkxOb2RlLnByb3RvdHlwZS5zZXRMb2NhdGlvbiA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gIHRoaXMucmVjdC54ID0geDtcbiAgdGhpcy5yZWN0LnkgPSB5O1xufTtcblxuTE5vZGUucHJvdG90eXBlLm1vdmVCeSA9IGZ1bmN0aW9uIChkeCwgZHkpIHtcbiAgdGhpcy5yZWN0LnggKz0gZHg7XG4gIHRoaXMucmVjdC55ICs9IGR5O1xufTtcblxuTE5vZGUucHJvdG90eXBlLmdldEVkZ2VMaXN0VG9Ob2RlID0gZnVuY3Rpb24gKHRvKSB7XG4gIHZhciBlZGdlTGlzdCA9IFtdO1xuICB2YXIgZWRnZTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIHNlbGYuZWRnZXMuZm9yRWFjaChmdW5jdGlvbiAoZWRnZSkge1xuXG4gICAgaWYgKGVkZ2UudGFyZ2V0ID09IHRvKSB7XG4gICAgICBpZiAoZWRnZS5zb3VyY2UgIT0gc2VsZikgdGhyb3cgXCJJbmNvcnJlY3QgZWRnZSBzb3VyY2UhXCI7XG5cbiAgICAgIGVkZ2VMaXN0LnB1c2goZWRnZSk7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gZWRnZUxpc3Q7XG59O1xuXG5MTm9kZS5wcm90b3R5cGUuZ2V0RWRnZXNCZXR3ZWVuID0gZnVuY3Rpb24gKG90aGVyKSB7XG4gIHZhciBlZGdlTGlzdCA9IFtdO1xuICB2YXIgZWRnZTtcblxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHNlbGYuZWRnZXMuZm9yRWFjaChmdW5jdGlvbiAoZWRnZSkge1xuXG4gICAgaWYgKCEoZWRnZS5zb3VyY2UgPT0gc2VsZiB8fCBlZGdlLnRhcmdldCA9PSBzZWxmKSkgdGhyb3cgXCJJbmNvcnJlY3QgZWRnZSBzb3VyY2UgYW5kL29yIHRhcmdldFwiO1xuXG4gICAgaWYgKGVkZ2UudGFyZ2V0ID09IG90aGVyIHx8IGVkZ2Uuc291cmNlID09IG90aGVyKSB7XG4gICAgICBlZGdlTGlzdC5wdXNoKGVkZ2UpO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGVkZ2VMaXN0O1xufTtcblxuTE5vZGUucHJvdG90eXBlLmdldE5laWdoYm9yc0xpc3QgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBuZWlnaGJvcnMgPSBuZXcgU2V0KCk7XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBzZWxmLmVkZ2VzLmZvckVhY2goZnVuY3Rpb24gKGVkZ2UpIHtcblxuICAgIGlmIChlZGdlLnNvdXJjZSA9PSBzZWxmKSB7XG4gICAgICBuZWlnaGJvcnMuYWRkKGVkZ2UudGFyZ2V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGVkZ2UudGFyZ2V0ICE9IHNlbGYpIHtcbiAgICAgICAgdGhyb3cgXCJJbmNvcnJlY3QgaW5jaWRlbmN5IVwiO1xuICAgICAgfVxuXG4gICAgICBuZWlnaGJvcnMuYWRkKGVkZ2Uuc291cmNlKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBuZWlnaGJvcnM7XG59O1xuXG5MTm9kZS5wcm90b3R5cGUud2l0aENoaWxkcmVuID0gZnVuY3Rpb24gKCkge1xuICB2YXIgd2l0aE5laWdoYm9yc0xpc3QgPSBuZXcgU2V0KCk7XG4gIHZhciBjaGlsZE5vZGU7XG4gIHZhciBjaGlsZHJlbjtcblxuICB3aXRoTmVpZ2hib3JzTGlzdC5hZGQodGhpcyk7XG5cbiAgaWYgKHRoaXMuY2hpbGQgIT0gbnVsbCkge1xuICAgIHZhciBub2RlcyA9IHRoaXMuY2hpbGQuZ2V0Tm9kZXMoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGlsZE5vZGUgPSBub2Rlc1tpXTtcbiAgICAgIGNoaWxkcmVuID0gY2hpbGROb2RlLndpdGhDaGlsZHJlbigpO1xuICAgICAgY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICB3aXRoTmVpZ2hib3JzTGlzdC5hZGQobm9kZSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gd2l0aE5laWdoYm9yc0xpc3Q7XG59O1xuXG5MTm9kZS5wcm90b3R5cGUuZ2V0Tm9PZkNoaWxkcmVuID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbm9PZkNoaWxkcmVuID0gMDtcbiAgdmFyIGNoaWxkTm9kZTtcblxuICBpZiAodGhpcy5jaGlsZCA9PSBudWxsKSB7XG4gICAgbm9PZkNoaWxkcmVuID0gMTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbm9kZXMgPSB0aGlzLmNoaWxkLmdldE5vZGVzKCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgY2hpbGROb2RlID0gbm9kZXNbaV07XG5cbiAgICAgIG5vT2ZDaGlsZHJlbiArPSBjaGlsZE5vZGUuZ2V0Tm9PZkNoaWxkcmVuKCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKG5vT2ZDaGlsZHJlbiA9PSAwKSB7XG4gICAgbm9PZkNoaWxkcmVuID0gMTtcbiAgfVxuICByZXR1cm4gbm9PZkNoaWxkcmVuO1xufTtcblxuTE5vZGUucHJvdG90eXBlLmdldEVzdGltYXRlZFNpemUgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLmVzdGltYXRlZFNpemUgPT0gSW50ZWdlci5NSU5fVkFMVUUpIHtcbiAgICB0aHJvdyBcImFzc2VydCBmYWlsZWRcIjtcbiAgfVxuICByZXR1cm4gdGhpcy5lc3RpbWF0ZWRTaXplO1xufTtcblxuTE5vZGUucHJvdG90eXBlLmNhbGNFc3RpbWF0ZWRTaXplID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5jaGlsZCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHRoaXMuZXN0aW1hdGVkU2l6ZSA9ICh0aGlzLnJlY3Qud2lkdGggKyB0aGlzLnJlY3QuaGVpZ2h0KSAvIDI7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5lc3RpbWF0ZWRTaXplID0gdGhpcy5jaGlsZC5jYWxjRXN0aW1hdGVkU2l6ZSgpO1xuICAgIHRoaXMucmVjdC53aWR0aCA9IHRoaXMuZXN0aW1hdGVkU2l6ZTtcbiAgICB0aGlzLnJlY3QuaGVpZ2h0ID0gdGhpcy5lc3RpbWF0ZWRTaXplO1xuXG4gICAgcmV0dXJuIHRoaXMuZXN0aW1hdGVkU2l6ZTtcbiAgfVxufTtcblxuTE5vZGUucHJvdG90eXBlLnNjYXR0ZXIgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciByYW5kb21DZW50ZXJYO1xuICB2YXIgcmFuZG9tQ2VudGVyWTtcblxuICB2YXIgbWluWCA9IC1MYXlvdXRDb25zdGFudHMuSU5JVElBTF9XT1JMRF9CT1VOREFSWTtcbiAgdmFyIG1heFggPSBMYXlvdXRDb25zdGFudHMuSU5JVElBTF9XT1JMRF9CT1VOREFSWTtcbiAgcmFuZG9tQ2VudGVyWCA9IExheW91dENvbnN0YW50cy5XT1JMRF9DRU5URVJfWCArIFJhbmRvbVNlZWQubmV4dERvdWJsZSgpICogKG1heFggLSBtaW5YKSArIG1pblg7XG5cbiAgdmFyIG1pblkgPSAtTGF5b3V0Q29uc3RhbnRzLklOSVRJQUxfV09STERfQk9VTkRBUlk7XG4gIHZhciBtYXhZID0gTGF5b3V0Q29uc3RhbnRzLklOSVRJQUxfV09STERfQk9VTkRBUlk7XG4gIHJhbmRvbUNlbnRlclkgPSBMYXlvdXRDb25zdGFudHMuV09STERfQ0VOVEVSX1kgKyBSYW5kb21TZWVkLm5leHREb3VibGUoKSAqIChtYXhZIC0gbWluWSkgKyBtaW5ZO1xuXG4gIHRoaXMucmVjdC54ID0gcmFuZG9tQ2VudGVyWDtcbiAgdGhpcy5yZWN0LnkgPSByYW5kb21DZW50ZXJZO1xufTtcblxuTE5vZGUucHJvdG90eXBlLnVwZGF0ZUJvdW5kcyA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuZ2V0Q2hpbGQoKSA9PSBudWxsKSB7XG4gICAgdGhyb3cgXCJhc3NlcnQgZmFpbGVkXCI7XG4gIH1cbiAgaWYgKHRoaXMuZ2V0Q2hpbGQoKS5nZXROb2RlcygpLmxlbmd0aCAhPSAwKSB7XG4gICAgLy8gd3JhcCB0aGUgY2hpbGRyZW4gbm9kZXMgYnkgcmUtYXJyYW5naW5nIHRoZSBib3VuZGFyaWVzXG4gICAgdmFyIGNoaWxkR3JhcGggPSB0aGlzLmdldENoaWxkKCk7XG4gICAgY2hpbGRHcmFwaC51cGRhdGVCb3VuZHModHJ1ZSk7XG5cbiAgICB0aGlzLnJlY3QueCA9IGNoaWxkR3JhcGguZ2V0TGVmdCgpO1xuICAgIHRoaXMucmVjdC55ID0gY2hpbGRHcmFwaC5nZXRUb3AoKTtcblxuICAgIHRoaXMuc2V0V2lkdGgoY2hpbGRHcmFwaC5nZXRSaWdodCgpIC0gY2hpbGRHcmFwaC5nZXRMZWZ0KCkpO1xuICAgIHRoaXMuc2V0SGVpZ2h0KGNoaWxkR3JhcGguZ2V0Qm90dG9tKCkgLSBjaGlsZEdyYXBoLmdldFRvcCgpKTtcblxuICAgIC8vIFVwZGF0ZSBjb21wb3VuZCBib3VuZHMgY29uc2lkZXJpbmcgaXRzIGxhYmVsIHByb3BlcnRpZXMgICAgXG4gICAgaWYgKExheW91dENvbnN0YW50cy5OT0RFX0RJTUVOU0lPTlNfSU5DTFVERV9MQUJFTFMpIHtcblxuICAgICAgdmFyIHdpZHRoID0gY2hpbGRHcmFwaC5nZXRSaWdodCgpIC0gY2hpbGRHcmFwaC5nZXRMZWZ0KCk7XG4gICAgICB2YXIgaGVpZ2h0ID0gY2hpbGRHcmFwaC5nZXRCb3R0b20oKSAtIGNoaWxkR3JhcGguZ2V0VG9wKCk7XG5cbiAgICAgIGlmICh0aGlzLmxhYmVsV2lkdGggPiB3aWR0aCkge1xuICAgICAgICB0aGlzLnJlY3QueCAtPSAodGhpcy5sYWJlbFdpZHRoIC0gd2lkdGgpIC8gMjtcbiAgICAgICAgdGhpcy5zZXRXaWR0aCh0aGlzLmxhYmVsV2lkdGgpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5sYWJlbEhlaWdodCA+IGhlaWdodCkge1xuICAgICAgICBpZiAodGhpcy5sYWJlbFBvcyA9PSBcImNlbnRlclwiKSB7XG4gICAgICAgICAgdGhpcy5yZWN0LnkgLT0gKHRoaXMubGFiZWxIZWlnaHQgLSBoZWlnaHQpIC8gMjtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmxhYmVsUG9zID09IFwidG9wXCIpIHtcbiAgICAgICAgICB0aGlzLnJlY3QueSAtPSB0aGlzLmxhYmVsSGVpZ2h0IC0gaGVpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2V0SGVpZ2h0KHRoaXMubGFiZWxIZWlnaHQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuTE5vZGUucHJvdG90eXBlLmdldEluY2x1c2lvblRyZWVEZXB0aCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuaW5jbHVzaW9uVHJlZURlcHRoID09IEludGVnZXIuTUFYX1ZBTFVFKSB7XG4gICAgdGhyb3cgXCJhc3NlcnQgZmFpbGVkXCI7XG4gIH1cbiAgcmV0dXJuIHRoaXMuaW5jbHVzaW9uVHJlZURlcHRoO1xufTtcblxuTE5vZGUucHJvdG90eXBlLnRyYW5zZm9ybSA9IGZ1bmN0aW9uICh0cmFucykge1xuICB2YXIgbGVmdCA9IHRoaXMucmVjdC54O1xuXG4gIGlmIChsZWZ0ID4gTGF5b3V0Q29uc3RhbnRzLldPUkxEX0JPVU5EQVJZKSB7XG4gICAgbGVmdCA9IExheW91dENvbnN0YW50cy5XT1JMRF9CT1VOREFSWTtcbiAgfSBlbHNlIGlmIChsZWZ0IDwgLUxheW91dENvbnN0YW50cy5XT1JMRF9CT1VOREFSWSkge1xuICAgIGxlZnQgPSAtTGF5b3V0Q29uc3RhbnRzLldPUkxEX0JPVU5EQVJZO1xuICB9XG5cbiAgdmFyIHRvcCA9IHRoaXMucmVjdC55O1xuXG4gIGlmICh0b3AgPiBMYXlvdXRDb25zdGFudHMuV09STERfQk9VTkRBUlkpIHtcbiAgICB0b3AgPSBMYXlvdXRDb25zdGFudHMuV09STERfQk9VTkRBUlk7XG4gIH0gZWxzZSBpZiAodG9wIDwgLUxheW91dENvbnN0YW50cy5XT1JMRF9CT1VOREFSWSkge1xuICAgIHRvcCA9IC1MYXlvdXRDb25zdGFudHMuV09STERfQk9VTkRBUlk7XG4gIH1cblxuICB2YXIgbGVmdFRvcCA9IG5ldyBQb2ludEQobGVmdCwgdG9wKTtcbiAgdmFyIHZMZWZ0VG9wID0gdHJhbnMuaW52ZXJzZVRyYW5zZm9ybVBvaW50KGxlZnRUb3ApO1xuXG4gIHRoaXMuc2V0TG9jYXRpb24odkxlZnRUb3AueCwgdkxlZnRUb3AueSk7XG59O1xuXG5MTm9kZS5wcm90b3R5cGUuZ2V0TGVmdCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMucmVjdC54O1xufTtcblxuTE5vZGUucHJvdG90eXBlLmdldFJpZ2h0ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5yZWN0LnggKyB0aGlzLnJlY3Qud2lkdGg7XG59O1xuXG5MTm9kZS5wcm90b3R5cGUuZ2V0VG9wID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5yZWN0Lnk7XG59O1xuXG5MTm9kZS5wcm90b3R5cGUuZ2V0Qm90dG9tID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5yZWN0LnkgKyB0aGlzLnJlY3QuaGVpZ2h0O1xufTtcblxuTE5vZGUucHJvdG90eXBlLmdldFBhcmVudCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMub3duZXIgPT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMub3duZXIuZ2V0UGFyZW50KCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IExOb2RlO1xuXG4vKioqLyB9KSxcbi8qIDQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuZnVuY3Rpb24gUG9pbnREKHgsIHkpIHtcbiAgaWYgKHggPT0gbnVsbCAmJiB5ID09IG51bGwpIHtcbiAgICB0aGlzLnggPSAwO1xuICAgIHRoaXMueSA9IDA7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy54ID0geDtcbiAgICB0aGlzLnkgPSB5O1xuICB9XG59XG5cblBvaW50RC5wcm90b3R5cGUuZ2V0WCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMueDtcbn07XG5cblBvaW50RC5wcm90b3R5cGUuZ2V0WSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMueTtcbn07XG5cblBvaW50RC5wcm90b3R5cGUuc2V0WCA9IGZ1bmN0aW9uICh4KSB7XG4gIHRoaXMueCA9IHg7XG59O1xuXG5Qb2ludEQucHJvdG90eXBlLnNldFkgPSBmdW5jdGlvbiAoeSkge1xuICB0aGlzLnkgPSB5O1xufTtcblxuUG9pbnRELnByb3RvdHlwZS5nZXREaWZmZXJlbmNlID0gZnVuY3Rpb24gKHB0KSB7XG4gIHJldHVybiBuZXcgRGltZW5zaW9uRCh0aGlzLnggLSBwdC54LCB0aGlzLnkgLSBwdC55KTtcbn07XG5cblBvaW50RC5wcm90b3R5cGUuZ2V0Q29weSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIG5ldyBQb2ludEQodGhpcy54LCB0aGlzLnkpO1xufTtcblxuUG9pbnRELnByb3RvdHlwZS50cmFuc2xhdGUgPSBmdW5jdGlvbiAoZGltKSB7XG4gIHRoaXMueCArPSBkaW0ud2lkdGg7XG4gIHRoaXMueSArPSBkaW0uaGVpZ2h0O1xuICByZXR1cm4gdGhpcztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUG9pbnREO1xuXG4vKioqLyB9KSxcbi8qIDUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIExHcmFwaE9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG52YXIgSW50ZWdlciA9IF9fd2VicGFja19yZXF1aXJlX18oMTApO1xudmFyIExheW91dENvbnN0YW50cyA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG52YXIgTEdyYXBoTWFuYWdlciA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XG52YXIgTE5vZGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xudmFyIExFZGdlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcbnZhciBSZWN0YW5nbGVEID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMyk7XG52YXIgUG9pbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyKTtcbnZhciBMaW5rZWRMaXN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMSk7XG5cbmZ1bmN0aW9uIExHcmFwaChwYXJlbnQsIG9iajIsIHZHcmFwaCkge1xuICBMR3JhcGhPYmplY3QuY2FsbCh0aGlzLCB2R3JhcGgpO1xuICB0aGlzLmVzdGltYXRlZFNpemUgPSBJbnRlZ2VyLk1JTl9WQUxVRTtcbiAgdGhpcy5tYXJnaW4gPSBMYXlvdXRDb25zdGFudHMuREVGQVVMVF9HUkFQSF9NQVJHSU47XG4gIHRoaXMuZWRnZXMgPSBbXTtcbiAgdGhpcy5ub2RlcyA9IFtdO1xuICB0aGlzLmlzQ29ubmVjdGVkID0gZmFsc2U7XG4gIHRoaXMucGFyZW50ID0gcGFyZW50O1xuXG4gIGlmIChvYmoyICE9IG51bGwgJiYgb2JqMiBpbnN0YW5jZW9mIExHcmFwaE1hbmFnZXIpIHtcbiAgICB0aGlzLmdyYXBoTWFuYWdlciA9IG9iajI7XG4gIH0gZWxzZSBpZiAob2JqMiAhPSBudWxsICYmIG9iajIgaW5zdGFuY2VvZiBMYXlvdXQpIHtcbiAgICB0aGlzLmdyYXBoTWFuYWdlciA9IG9iajIuZ3JhcGhNYW5hZ2VyO1xuICB9XG59XG5cbkxHcmFwaC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKExHcmFwaE9iamVjdC5wcm90b3R5cGUpO1xuZm9yICh2YXIgcHJvcCBpbiBMR3JhcGhPYmplY3QpIHtcbiAgTEdyYXBoW3Byb3BdID0gTEdyYXBoT2JqZWN0W3Byb3BdO1xufVxuXG5MR3JhcGgucHJvdG90eXBlLmdldE5vZGVzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5ub2Rlcztcbn07XG5cbkxHcmFwaC5wcm90b3R5cGUuZ2V0RWRnZXMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmVkZ2VzO1xufTtcblxuTEdyYXBoLnByb3RvdHlwZS5nZXRHcmFwaE1hbmFnZXIgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmdyYXBoTWFuYWdlcjtcbn07XG5cbkxHcmFwaC5wcm90b3R5cGUuZ2V0UGFyZW50ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5wYXJlbnQ7XG59O1xuXG5MR3JhcGgucHJvdG90eXBlLmdldExlZnQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmxlZnQ7XG59O1xuXG5MR3JhcGgucHJvdG90eXBlLmdldFJpZ2h0ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5yaWdodDtcbn07XG5cbkxHcmFwaC5wcm90b3R5cGUuZ2V0VG9wID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy50b3A7XG59O1xuXG5MR3JhcGgucHJvdG90eXBlLmdldEJvdHRvbSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuYm90dG9tO1xufTtcblxuTEdyYXBoLnByb3RvdHlwZS5pc0Nvbm5lY3RlZCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuaXNDb25uZWN0ZWQ7XG59O1xuXG5MR3JhcGgucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChvYmoxLCBzb3VyY2VOb2RlLCB0YXJnZXROb2RlKSB7XG4gIGlmIChzb3VyY2VOb2RlID09IG51bGwgJiYgdGFyZ2V0Tm9kZSA9PSBudWxsKSB7XG4gICAgdmFyIG5ld05vZGUgPSBvYmoxO1xuICAgIGlmICh0aGlzLmdyYXBoTWFuYWdlciA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBcIkdyYXBoIGhhcyBubyBncmFwaCBtZ3IhXCI7XG4gICAgfVxuICAgIGlmICh0aGlzLmdldE5vZGVzKCkuaW5kZXhPZihuZXdOb2RlKSA+IC0xKSB7XG4gICAgICB0aHJvdyBcIk5vZGUgYWxyZWFkeSBpbiBncmFwaCFcIjtcbiAgICB9XG4gICAgbmV3Tm9kZS5vd25lciA9IHRoaXM7XG4gICAgdGhpcy5nZXROb2RlcygpLnB1c2gobmV3Tm9kZSk7XG5cbiAgICByZXR1cm4gbmV3Tm9kZTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbmV3RWRnZSA9IG9iajE7XG4gICAgaWYgKCEodGhpcy5nZXROb2RlcygpLmluZGV4T2Yoc291cmNlTm9kZSkgPiAtMSAmJiB0aGlzLmdldE5vZGVzKCkuaW5kZXhPZih0YXJnZXROb2RlKSA+IC0xKSkge1xuICAgICAgdGhyb3cgXCJTb3VyY2Ugb3IgdGFyZ2V0IG5vdCBpbiBncmFwaCFcIjtcbiAgICB9XG5cbiAgICBpZiAoIShzb3VyY2VOb2RlLm93bmVyID09IHRhcmdldE5vZGUub3duZXIgJiYgc291cmNlTm9kZS5vd25lciA9PSB0aGlzKSkge1xuICAgICAgdGhyb3cgXCJCb3RoIG93bmVycyBtdXN0IGJlIHRoaXMgZ3JhcGghXCI7XG4gICAgfVxuXG4gICAgaWYgKHNvdXJjZU5vZGUub3duZXIgIT0gdGFyZ2V0Tm9kZS5vd25lcikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLy8gc2V0IHNvdXJjZSBhbmQgdGFyZ2V0XG4gICAgbmV3RWRnZS5zb3VyY2UgPSBzb3VyY2VOb2RlO1xuICAgIG5ld0VkZ2UudGFyZ2V0ID0gdGFyZ2V0Tm9kZTtcblxuICAgIC8vIHNldCBhcyBpbnRyYS1ncmFwaCBlZGdlXG4gICAgbmV3RWRnZS5pc0ludGVyR3JhcGggPSBmYWxzZTtcblxuICAgIC8vIGFkZCB0byBncmFwaCBlZGdlIGxpc3RcbiAgICB0aGlzLmdldEVkZ2VzKCkucHVzaChuZXdFZGdlKTtcblxuICAgIC8vIGFkZCB0byBpbmNpZGVuY3kgbGlzdHNcbiAgICBzb3VyY2VOb2RlLmVkZ2VzLnB1c2gobmV3RWRnZSk7XG5cbiAgICBpZiAodGFyZ2V0Tm9kZSAhPSBzb3VyY2VOb2RlKSB7XG4gICAgICB0YXJnZXROb2RlLmVkZ2VzLnB1c2gobmV3RWRnZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ld0VkZ2U7XG4gIH1cbn07XG5cbkxHcmFwaC5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKG9iaikge1xuICB2YXIgbm9kZSA9IG9iajtcbiAgaWYgKG9iaiBpbnN0YW5jZW9mIExOb2RlKSB7XG4gICAgaWYgKG5vZGUgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgXCJOb2RlIGlzIG51bGwhXCI7XG4gICAgfVxuICAgIGlmICghKG5vZGUub3duZXIgIT0gbnVsbCAmJiBub2RlLm93bmVyID09IHRoaXMpKSB7XG4gICAgICB0aHJvdyBcIk93bmVyIGdyYXBoIGlzIGludmFsaWQhXCI7XG4gICAgfVxuICAgIGlmICh0aGlzLmdyYXBoTWFuYWdlciA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBcIk93bmVyIGdyYXBoIG1hbmFnZXIgaXMgaW52YWxpZCFcIjtcbiAgICB9XG4gICAgLy8gcmVtb3ZlIGluY2lkZW50IGVkZ2VzIGZpcnN0IChtYWtlIGEgY29weSB0byBkbyBpdCBzYWZlbHkpXG4gICAgdmFyIGVkZ2VzVG9CZVJlbW92ZWQgPSBub2RlLmVkZ2VzLnNsaWNlKCk7XG4gICAgdmFyIGVkZ2U7XG4gICAgdmFyIHMgPSBlZGdlc1RvQmVSZW1vdmVkLmxlbmd0aDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHM7IGkrKykge1xuICAgICAgZWRnZSA9IGVkZ2VzVG9CZVJlbW92ZWRbaV07XG5cbiAgICAgIGlmIChlZGdlLmlzSW50ZXJHcmFwaCkge1xuICAgICAgICB0aGlzLmdyYXBoTWFuYWdlci5yZW1vdmUoZWRnZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlZGdlLnNvdXJjZS5vd25lci5yZW1vdmUoZWRnZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gbm93IHRoZSBub2RlIGl0c2VsZlxuICAgIHZhciBpbmRleCA9IHRoaXMubm9kZXMuaW5kZXhPZihub2RlKTtcbiAgICBpZiAoaW5kZXggPT0gLTEpIHtcbiAgICAgIHRocm93IFwiTm9kZSBub3QgaW4gb3duZXIgbm9kZSBsaXN0IVwiO1xuICAgIH1cblxuICAgIHRoaXMubm9kZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgfSBlbHNlIGlmIChvYmogaW5zdGFuY2VvZiBMRWRnZSkge1xuICAgIHZhciBlZGdlID0gb2JqO1xuICAgIGlmIChlZGdlID09IG51bGwpIHtcbiAgICAgIHRocm93IFwiRWRnZSBpcyBudWxsIVwiO1xuICAgIH1cbiAgICBpZiAoIShlZGdlLnNvdXJjZSAhPSBudWxsICYmIGVkZ2UudGFyZ2V0ICE9IG51bGwpKSB7XG4gICAgICB0aHJvdyBcIlNvdXJjZSBhbmQvb3IgdGFyZ2V0IGlzIG51bGwhXCI7XG4gICAgfVxuICAgIGlmICghKGVkZ2Uuc291cmNlLm93bmVyICE9IG51bGwgJiYgZWRnZS50YXJnZXQub3duZXIgIT0gbnVsbCAmJiBlZGdlLnNvdXJjZS5vd25lciA9PSB0aGlzICYmIGVkZ2UudGFyZ2V0Lm93bmVyID09IHRoaXMpKSB7XG4gICAgICB0aHJvdyBcIlNvdXJjZSBhbmQvb3IgdGFyZ2V0IG93bmVyIGlzIGludmFsaWQhXCI7XG4gICAgfVxuXG4gICAgdmFyIHNvdXJjZUluZGV4ID0gZWRnZS5zb3VyY2UuZWRnZXMuaW5kZXhPZihlZGdlKTtcbiAgICB2YXIgdGFyZ2V0SW5kZXggPSBlZGdlLnRhcmdldC5lZGdlcy5pbmRleE9mKGVkZ2UpO1xuICAgIGlmICghKHNvdXJjZUluZGV4ID4gLTEgJiYgdGFyZ2V0SW5kZXggPiAtMSkpIHtcbiAgICAgIHRocm93IFwiU291cmNlIGFuZC9vciB0YXJnZXQgZG9lc24ndCBrbm93IHRoaXMgZWRnZSFcIjtcbiAgICB9XG5cbiAgICBlZGdlLnNvdXJjZS5lZGdlcy5zcGxpY2Uoc291cmNlSW5kZXgsIDEpO1xuXG4gICAgaWYgKGVkZ2UudGFyZ2V0ICE9IGVkZ2Uuc291cmNlKSB7XG4gICAgICBlZGdlLnRhcmdldC5lZGdlcy5zcGxpY2UodGFyZ2V0SW5kZXgsIDEpO1xuICAgIH1cblxuICAgIHZhciBpbmRleCA9IGVkZ2Uuc291cmNlLm93bmVyLmdldEVkZ2VzKCkuaW5kZXhPZihlZGdlKTtcbiAgICBpZiAoaW5kZXggPT0gLTEpIHtcbiAgICAgIHRocm93IFwiTm90IGluIG93bmVyJ3MgZWRnZSBsaXN0IVwiO1xuICAgIH1cblxuICAgIGVkZ2Uuc291cmNlLm93bmVyLmdldEVkZ2VzKCkuc3BsaWNlKGluZGV4LCAxKTtcbiAgfVxufTtcblxuTEdyYXBoLnByb3RvdHlwZS51cGRhdGVMZWZ0VG9wID0gZnVuY3Rpb24gKCkge1xuICB2YXIgdG9wID0gSW50ZWdlci5NQVhfVkFMVUU7XG4gIHZhciBsZWZ0ID0gSW50ZWdlci5NQVhfVkFMVUU7XG4gIHZhciBub2RlVG9wO1xuICB2YXIgbm9kZUxlZnQ7XG4gIHZhciBtYXJnaW47XG5cbiAgdmFyIG5vZGVzID0gdGhpcy5nZXROb2RlcygpO1xuICB2YXIgcyA9IG5vZGVzLmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHM7IGkrKykge1xuICAgIHZhciBsTm9kZSA9IG5vZGVzW2ldO1xuICAgIG5vZGVUb3AgPSBsTm9kZS5nZXRUb3AoKTtcbiAgICBub2RlTGVmdCA9IGxOb2RlLmdldExlZnQoKTtcblxuICAgIGlmICh0b3AgPiBub2RlVG9wKSB7XG4gICAgICB0b3AgPSBub2RlVG9wO1xuICAgIH1cblxuICAgIGlmIChsZWZ0ID4gbm9kZUxlZnQpIHtcbiAgICAgIGxlZnQgPSBub2RlTGVmdDtcbiAgICB9XG4gIH1cblxuICAvLyBEbyB3ZSBoYXZlIGFueSBub2RlcyBpbiB0aGlzIGdyYXBoP1xuICBpZiAodG9wID09IEludGVnZXIuTUFYX1ZBTFVFKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAobm9kZXNbMF0uZ2V0UGFyZW50KCkucGFkZGluZ0xlZnQgIT0gdW5kZWZpbmVkKSB7XG4gICAgbWFyZ2luID0gbm9kZXNbMF0uZ2V0UGFyZW50KCkucGFkZGluZ0xlZnQ7XG4gIH0gZWxzZSB7XG4gICAgbWFyZ2luID0gdGhpcy5tYXJnaW47XG4gIH1cblxuICB0aGlzLmxlZnQgPSBsZWZ0IC0gbWFyZ2luO1xuICB0aGlzLnRvcCA9IHRvcCAtIG1hcmdpbjtcblxuICAvLyBBcHBseSB0aGUgbWFyZ2lucyBhbmQgcmV0dXJuIHRoZSByZXN1bHRcbiAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLmxlZnQsIHRoaXMudG9wKTtcbn07XG5cbkxHcmFwaC5wcm90b3R5cGUudXBkYXRlQm91bmRzID0gZnVuY3Rpb24gKHJlY3Vyc2l2ZSkge1xuICAvLyBjYWxjdWxhdGUgYm91bmRzXG4gIHZhciBsZWZ0ID0gSW50ZWdlci5NQVhfVkFMVUU7XG4gIHZhciByaWdodCA9IC1JbnRlZ2VyLk1BWF9WQUxVRTtcbiAgdmFyIHRvcCA9IEludGVnZXIuTUFYX1ZBTFVFO1xuICB2YXIgYm90dG9tID0gLUludGVnZXIuTUFYX1ZBTFVFO1xuICB2YXIgbm9kZUxlZnQ7XG4gIHZhciBub2RlUmlnaHQ7XG4gIHZhciBub2RlVG9wO1xuICB2YXIgbm9kZUJvdHRvbTtcbiAgdmFyIG1hcmdpbjtcblxuICB2YXIgbm9kZXMgPSB0aGlzLm5vZGVzO1xuICB2YXIgcyA9IG5vZGVzLmxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzOyBpKyspIHtcbiAgICB2YXIgbE5vZGUgPSBub2Rlc1tpXTtcblxuICAgIGlmIChyZWN1cnNpdmUgJiYgbE5vZGUuY2hpbGQgIT0gbnVsbCkge1xuICAgICAgbE5vZGUudXBkYXRlQm91bmRzKCk7XG4gICAgfVxuICAgIG5vZGVMZWZ0ID0gbE5vZGUuZ2V0TGVmdCgpO1xuICAgIG5vZGVSaWdodCA9IGxOb2RlLmdldFJpZ2h0KCk7XG4gICAgbm9kZVRvcCA9IGxOb2RlLmdldFRvcCgpO1xuICAgIG5vZGVCb3R0b20gPSBsTm9kZS5nZXRCb3R0b20oKTtcblxuICAgIGlmIChsZWZ0ID4gbm9kZUxlZnQpIHtcbiAgICAgIGxlZnQgPSBub2RlTGVmdDtcbiAgICB9XG5cbiAgICBpZiAocmlnaHQgPCBub2RlUmlnaHQpIHtcbiAgICAgIHJpZ2h0ID0gbm9kZVJpZ2h0O1xuICAgIH1cblxuICAgIGlmICh0b3AgPiBub2RlVG9wKSB7XG4gICAgICB0b3AgPSBub2RlVG9wO1xuICAgIH1cblxuICAgIGlmIChib3R0b20gPCBub2RlQm90dG9tKSB7XG4gICAgICBib3R0b20gPSBub2RlQm90dG9tO1xuICAgIH1cbiAgfVxuXG4gIHZhciBib3VuZGluZ1JlY3QgPSBuZXcgUmVjdGFuZ2xlRChsZWZ0LCB0b3AsIHJpZ2h0IC0gbGVmdCwgYm90dG9tIC0gdG9wKTtcbiAgaWYgKGxlZnQgPT0gSW50ZWdlci5NQVhfVkFMVUUpIHtcbiAgICB0aGlzLmxlZnQgPSB0aGlzLnBhcmVudC5nZXRMZWZ0KCk7XG4gICAgdGhpcy5yaWdodCA9IHRoaXMucGFyZW50LmdldFJpZ2h0KCk7XG4gICAgdGhpcy50b3AgPSB0aGlzLnBhcmVudC5nZXRUb3AoKTtcbiAgICB0aGlzLmJvdHRvbSA9IHRoaXMucGFyZW50LmdldEJvdHRvbSgpO1xuICB9XG5cbiAgaWYgKG5vZGVzWzBdLmdldFBhcmVudCgpLnBhZGRpbmdMZWZ0ICE9IHVuZGVmaW5lZCkge1xuICAgIG1hcmdpbiA9IG5vZGVzWzBdLmdldFBhcmVudCgpLnBhZGRpbmdMZWZ0O1xuICB9IGVsc2Uge1xuICAgIG1hcmdpbiA9IHRoaXMubWFyZ2luO1xuICB9XG5cbiAgdGhpcy5sZWZ0ID0gYm91bmRpbmdSZWN0LnggLSBtYXJnaW47XG4gIHRoaXMucmlnaHQgPSBib3VuZGluZ1JlY3QueCArIGJvdW5kaW5nUmVjdC53aWR0aCArIG1hcmdpbjtcbiAgdGhpcy50b3AgPSBib3VuZGluZ1JlY3QueSAtIG1hcmdpbjtcbiAgdGhpcy5ib3R0b20gPSBib3VuZGluZ1JlY3QueSArIGJvdW5kaW5nUmVjdC5oZWlnaHQgKyBtYXJnaW47XG59O1xuXG5MR3JhcGguY2FsY3VsYXRlQm91bmRzID0gZnVuY3Rpb24gKG5vZGVzKSB7XG4gIHZhciBsZWZ0ID0gSW50ZWdlci5NQVhfVkFMVUU7XG4gIHZhciByaWdodCA9IC1JbnRlZ2VyLk1BWF9WQUxVRTtcbiAgdmFyIHRvcCA9IEludGVnZXIuTUFYX1ZBTFVFO1xuICB2YXIgYm90dG9tID0gLUludGVnZXIuTUFYX1ZBTFVFO1xuICB2YXIgbm9kZUxlZnQ7XG4gIHZhciBub2RlUmlnaHQ7XG4gIHZhciBub2RlVG9wO1xuICB2YXIgbm9kZUJvdHRvbTtcblxuICB2YXIgcyA9IG5vZGVzLmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHM7IGkrKykge1xuICAgIHZhciBsTm9kZSA9IG5vZGVzW2ldO1xuICAgIG5vZGVMZWZ0ID0gbE5vZGUuZ2V0TGVmdCgpO1xuICAgIG5vZGVSaWdodCA9IGxOb2RlLmdldFJpZ2h0KCk7XG4gICAgbm9kZVRvcCA9IGxOb2RlLmdldFRvcCgpO1xuICAgIG5vZGVCb3R0b20gPSBsTm9kZS5nZXRCb3R0b20oKTtcblxuICAgIGlmIChsZWZ0ID4gbm9kZUxlZnQpIHtcbiAgICAgIGxlZnQgPSBub2RlTGVmdDtcbiAgICB9XG5cbiAgICBpZiAocmlnaHQgPCBub2RlUmlnaHQpIHtcbiAgICAgIHJpZ2h0ID0gbm9kZVJpZ2h0O1xuICAgIH1cblxuICAgIGlmICh0b3AgPiBub2RlVG9wKSB7XG4gICAgICB0b3AgPSBub2RlVG9wO1xuICAgIH1cblxuICAgIGlmIChib3R0b20gPCBub2RlQm90dG9tKSB7XG4gICAgICBib3R0b20gPSBub2RlQm90dG9tO1xuICAgIH1cbiAgfVxuXG4gIHZhciBib3VuZGluZ1JlY3QgPSBuZXcgUmVjdGFuZ2xlRChsZWZ0LCB0b3AsIHJpZ2h0IC0gbGVmdCwgYm90dG9tIC0gdG9wKTtcblxuICByZXR1cm4gYm91bmRpbmdSZWN0O1xufTtcblxuTEdyYXBoLnByb3RvdHlwZS5nZXRJbmNsdXNpb25UcmVlRGVwdGggPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzID09IHRoaXMuZ3JhcGhNYW5hZ2VyLmdldFJvb3QoKSkge1xuICAgIHJldHVybiAxO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB0aGlzLnBhcmVudC5nZXRJbmNsdXNpb25UcmVlRGVwdGgoKTtcbiAgfVxufTtcblxuTEdyYXBoLnByb3RvdHlwZS5nZXRFc3RpbWF0ZWRTaXplID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5lc3RpbWF0ZWRTaXplID09IEludGVnZXIuTUlOX1ZBTFVFKSB7XG4gICAgdGhyb3cgXCJhc3NlcnQgZmFpbGVkXCI7XG4gIH1cbiAgcmV0dXJuIHRoaXMuZXN0aW1hdGVkU2l6ZTtcbn07XG5cbkxHcmFwaC5wcm90b3R5cGUuY2FsY0VzdGltYXRlZFNpemUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzaXplID0gMDtcbiAgdmFyIG5vZGVzID0gdGhpcy5ub2RlcztcbiAgdmFyIHMgPSBub2Rlcy5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzOyBpKyspIHtcbiAgICB2YXIgbE5vZGUgPSBub2Rlc1tpXTtcbiAgICBzaXplICs9IGxOb2RlLmNhbGNFc3RpbWF0ZWRTaXplKCk7XG4gIH1cblxuICBpZiAoc2l6ZSA9PSAwKSB7XG4gICAgdGhpcy5lc3RpbWF0ZWRTaXplID0gTGF5b3V0Q29uc3RhbnRzLkVNUFRZX0NPTVBPVU5EX05PREVfU0laRTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmVzdGltYXRlZFNpemUgPSBzaXplIC8gTWF0aC5zcXJ0KHRoaXMubm9kZXMubGVuZ3RoKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzLmVzdGltYXRlZFNpemU7XG59O1xuXG5MR3JhcGgucHJvdG90eXBlLnVwZGF0ZUNvbm5lY3RlZCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBpZiAodGhpcy5ub2Rlcy5sZW5ndGggPT0gMCkge1xuICAgIHRoaXMuaXNDb25uZWN0ZWQgPSB0cnVlO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBxdWV1ZSA9IG5ldyBMaW5rZWRMaXN0KCk7XG4gIHZhciB2aXNpdGVkID0gbmV3IFNldCgpO1xuICB2YXIgY3VycmVudE5vZGUgPSB0aGlzLm5vZGVzWzBdO1xuICB2YXIgbmVpZ2hib3JFZGdlcztcbiAgdmFyIGN1cnJlbnROZWlnaGJvcjtcbiAgdmFyIGNoaWxkcmVuT2ZOb2RlID0gY3VycmVudE5vZGUud2l0aENoaWxkcmVuKCk7XG4gIGNoaWxkcmVuT2ZOb2RlLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICBxdWV1ZS5wdXNoKG5vZGUpO1xuICAgIHZpc2l0ZWQuYWRkKG5vZGUpO1xuICB9KTtcblxuICB3aGlsZSAocXVldWUubGVuZ3RoICE9PSAwKSB7XG4gICAgY3VycmVudE5vZGUgPSBxdWV1ZS5zaGlmdCgpO1xuXG4gICAgLy8gVHJhdmVyc2UgYWxsIG5laWdoYm9ycyBvZiB0aGlzIG5vZGVcbiAgICBuZWlnaGJvckVkZ2VzID0gY3VycmVudE5vZGUuZ2V0RWRnZXMoKTtcbiAgICB2YXIgc2l6ZSA9IG5laWdoYm9yRWRnZXMubGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgICB2YXIgbmVpZ2hib3JFZGdlID0gbmVpZ2hib3JFZGdlc1tpXTtcbiAgICAgIGN1cnJlbnROZWlnaGJvciA9IG5laWdoYm9yRWRnZS5nZXRPdGhlckVuZEluR3JhcGgoY3VycmVudE5vZGUsIHRoaXMpO1xuXG4gICAgICAvLyBBZGQgdW52aXNpdGVkIG5laWdoYm9ycyB0byB0aGUgbGlzdCB0byB2aXNpdFxuICAgICAgaWYgKGN1cnJlbnROZWlnaGJvciAhPSBudWxsICYmICF2aXNpdGVkLmhhcyhjdXJyZW50TmVpZ2hib3IpKSB7XG4gICAgICAgIHZhciBjaGlsZHJlbk9mTmVpZ2hib3IgPSBjdXJyZW50TmVpZ2hib3Iud2l0aENoaWxkcmVuKCk7XG5cbiAgICAgICAgY2hpbGRyZW5PZk5laWdoYm9yLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICBxdWV1ZS5wdXNoKG5vZGUpO1xuICAgICAgICAgIHZpc2l0ZWQuYWRkKG5vZGUpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB0aGlzLmlzQ29ubmVjdGVkID0gZmFsc2U7XG5cbiAgaWYgKHZpc2l0ZWQuc2l6ZSA+PSB0aGlzLm5vZGVzLmxlbmd0aCkge1xuICAgIHZhciBub09mVmlzaXRlZEluVGhpc0dyYXBoID0gMDtcblxuICAgIHZpc2l0ZWQuZm9yRWFjaChmdW5jdGlvbiAodmlzaXRlZE5vZGUpIHtcbiAgICAgIGlmICh2aXNpdGVkTm9kZS5vd25lciA9PSBzZWxmKSB7XG4gICAgICAgIG5vT2ZWaXNpdGVkSW5UaGlzR3JhcGgrKztcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmIChub09mVmlzaXRlZEluVGhpc0dyYXBoID09IHRoaXMubm9kZXMubGVuZ3RoKSB7XG4gICAgICB0aGlzLmlzQ29ubmVjdGVkID0gdHJ1ZTtcbiAgICB9XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTEdyYXBoO1xuXG4vKioqLyB9KSxcbi8qIDYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIExHcmFwaDtcbnZhciBMRWRnZSA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbmZ1bmN0aW9uIExHcmFwaE1hbmFnZXIobGF5b3V0KSB7XG4gIExHcmFwaCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7IC8vIEl0IG1heSBiZSBiZXR0ZXIgdG8gaW5pdGlsaXplIHRoaXMgb3V0IG9mIHRoaXMgZnVuY3Rpb24gYnV0IGl0IGdpdmVzIGFuIGVycm9yIChSaWdodC1oYW5kIHNpZGUgb2YgJ2luc3RhbmNlb2YnIGlzIG5vdCBjYWxsYWJsZSkgbm93LlxuICB0aGlzLmxheW91dCA9IGxheW91dDtcblxuICB0aGlzLmdyYXBocyA9IFtdO1xuICB0aGlzLmVkZ2VzID0gW107XG59XG5cbkxHcmFwaE1hbmFnZXIucHJvdG90eXBlLmFkZFJvb3QgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBuZ3JhcGggPSB0aGlzLmxheW91dC5uZXdHcmFwaCgpO1xuICB2YXIgbm5vZGUgPSB0aGlzLmxheW91dC5uZXdOb2RlKG51bGwpO1xuICB2YXIgcm9vdCA9IHRoaXMuYWRkKG5ncmFwaCwgbm5vZGUpO1xuICB0aGlzLnNldFJvb3RHcmFwaChyb290KTtcbiAgcmV0dXJuIHRoaXMucm9vdEdyYXBoO1xufTtcblxuTEdyYXBoTWFuYWdlci5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKG5ld0dyYXBoLCBwYXJlbnROb2RlLCBuZXdFZGdlLCBzb3VyY2VOb2RlLCB0YXJnZXROb2RlKSB7XG4gIC8vdGhlcmUgYXJlIGp1c3QgMiBwYXJhbWV0ZXJzIGFyZSBwYXNzZWQgdGhlbiBpdCBhZGRzIGFuIExHcmFwaCBlbHNlIGl0IGFkZHMgYW4gTEVkZ2VcbiAgaWYgKG5ld0VkZ2UgPT0gbnVsbCAmJiBzb3VyY2VOb2RlID09IG51bGwgJiYgdGFyZ2V0Tm9kZSA9PSBudWxsKSB7XG4gICAgaWYgKG5ld0dyYXBoID09IG51bGwpIHtcbiAgICAgIHRocm93IFwiR3JhcGggaXMgbnVsbCFcIjtcbiAgICB9XG4gICAgaWYgKHBhcmVudE5vZGUgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgXCJQYXJlbnQgbm9kZSBpcyBudWxsIVwiO1xuICAgIH1cbiAgICBpZiAodGhpcy5ncmFwaHMuaW5kZXhPZihuZXdHcmFwaCkgPiAtMSkge1xuICAgICAgdGhyb3cgXCJHcmFwaCBhbHJlYWR5IGluIHRoaXMgZ3JhcGggbWdyIVwiO1xuICAgIH1cblxuICAgIHRoaXMuZ3JhcGhzLnB1c2gobmV3R3JhcGgpO1xuXG4gICAgaWYgKG5ld0dyYXBoLnBhcmVudCAhPSBudWxsKSB7XG4gICAgICB0aHJvdyBcIkFscmVhZHkgaGFzIGEgcGFyZW50IVwiO1xuICAgIH1cbiAgICBpZiAocGFyZW50Tm9kZS5jaGlsZCAhPSBudWxsKSB7XG4gICAgICB0aHJvdyBcIkFscmVhZHkgaGFzIGEgY2hpbGQhXCI7XG4gICAgfVxuXG4gICAgbmV3R3JhcGgucGFyZW50ID0gcGFyZW50Tm9kZTtcbiAgICBwYXJlbnROb2RlLmNoaWxkID0gbmV3R3JhcGg7XG5cbiAgICByZXR1cm4gbmV3R3JhcGg7XG4gIH0gZWxzZSB7XG4gICAgLy9jaGFuZ2UgdGhlIG9yZGVyIG9mIHRoZSBwYXJhbWV0ZXJzXG4gICAgdGFyZ2V0Tm9kZSA9IG5ld0VkZ2U7XG4gICAgc291cmNlTm9kZSA9IHBhcmVudE5vZGU7XG4gICAgbmV3RWRnZSA9IG5ld0dyYXBoO1xuICAgIHZhciBzb3VyY2VHcmFwaCA9IHNvdXJjZU5vZGUuZ2V0T3duZXIoKTtcbiAgICB2YXIgdGFyZ2V0R3JhcGggPSB0YXJnZXROb2RlLmdldE93bmVyKCk7XG5cbiAgICBpZiAoIShzb3VyY2VHcmFwaCAhPSBudWxsICYmIHNvdXJjZUdyYXBoLmdldEdyYXBoTWFuYWdlcigpID09IHRoaXMpKSB7XG4gICAgICB0aHJvdyBcIlNvdXJjZSBub3QgaW4gdGhpcyBncmFwaCBtZ3IhXCI7XG4gICAgfVxuICAgIGlmICghKHRhcmdldEdyYXBoICE9IG51bGwgJiYgdGFyZ2V0R3JhcGguZ2V0R3JhcGhNYW5hZ2VyKCkgPT0gdGhpcykpIHtcbiAgICAgIHRocm93IFwiVGFyZ2V0IG5vdCBpbiB0aGlzIGdyYXBoIG1nciFcIjtcbiAgICB9XG5cbiAgICBpZiAoc291cmNlR3JhcGggPT0gdGFyZ2V0R3JhcGgpIHtcbiAgICAgIG5ld0VkZ2UuaXNJbnRlckdyYXBoID0gZmFsc2U7XG4gICAgICByZXR1cm4gc291cmNlR3JhcGguYWRkKG5ld0VkZ2UsIHNvdXJjZU5vZGUsIHRhcmdldE5vZGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXdFZGdlLmlzSW50ZXJHcmFwaCA9IHRydWU7XG5cbiAgICAgIC8vIHNldCBzb3VyY2UgYW5kIHRhcmdldFxuICAgICAgbmV3RWRnZS5zb3VyY2UgPSBzb3VyY2VOb2RlO1xuICAgICAgbmV3RWRnZS50YXJnZXQgPSB0YXJnZXROb2RlO1xuXG4gICAgICAvLyBhZGQgZWRnZSB0byBpbnRlci1ncmFwaCBlZGdlIGxpc3RcbiAgICAgIGlmICh0aGlzLmVkZ2VzLmluZGV4T2YobmV3RWRnZSkgPiAtMSkge1xuICAgICAgICB0aHJvdyBcIkVkZ2UgYWxyZWFkeSBpbiBpbnRlci1ncmFwaCBlZGdlIGxpc3QhXCI7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZWRnZXMucHVzaChuZXdFZGdlKTtcblxuICAgICAgLy8gYWRkIGVkZ2UgdG8gc291cmNlIGFuZCB0YXJnZXQgaW5jaWRlbmN5IGxpc3RzXG4gICAgICBpZiAoIShuZXdFZGdlLnNvdXJjZSAhPSBudWxsICYmIG5ld0VkZ2UudGFyZ2V0ICE9IG51bGwpKSB7XG4gICAgICAgIHRocm93IFwiRWRnZSBzb3VyY2UgYW5kL29yIHRhcmdldCBpcyBudWxsIVwiO1xuICAgICAgfVxuXG4gICAgICBpZiAoIShuZXdFZGdlLnNvdXJjZS5lZGdlcy5pbmRleE9mKG5ld0VkZ2UpID09IC0xICYmIG5ld0VkZ2UudGFyZ2V0LmVkZ2VzLmluZGV4T2YobmV3RWRnZSkgPT0gLTEpKSB7XG4gICAgICAgIHRocm93IFwiRWRnZSBhbHJlYWR5IGluIHNvdXJjZSBhbmQvb3IgdGFyZ2V0IGluY2lkZW5jeSBsaXN0IVwiO1xuICAgICAgfVxuXG4gICAgICBuZXdFZGdlLnNvdXJjZS5lZGdlcy5wdXNoKG5ld0VkZ2UpO1xuICAgICAgbmV3RWRnZS50YXJnZXQuZWRnZXMucHVzaChuZXdFZGdlKTtcblxuICAgICAgcmV0dXJuIG5ld0VkZ2U7XG4gICAgfVxuICB9XG59O1xuXG5MR3JhcGhNYW5hZ2VyLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAobE9iaikge1xuICBpZiAobE9iaiBpbnN0YW5jZW9mIExHcmFwaCkge1xuICAgIHZhciBncmFwaCA9IGxPYmo7XG4gICAgaWYgKGdyYXBoLmdldEdyYXBoTWFuYWdlcigpICE9IHRoaXMpIHtcbiAgICAgIHRocm93IFwiR3JhcGggbm90IGluIHRoaXMgZ3JhcGggbWdyXCI7XG4gICAgfVxuICAgIGlmICghKGdyYXBoID09IHRoaXMucm9vdEdyYXBoIHx8IGdyYXBoLnBhcmVudCAhPSBudWxsICYmIGdyYXBoLnBhcmVudC5ncmFwaE1hbmFnZXIgPT0gdGhpcykpIHtcbiAgICAgIHRocm93IFwiSW52YWxpZCBwYXJlbnQgbm9kZSFcIjtcbiAgICB9XG5cbiAgICAvLyBmaXJzdCB0aGUgZWRnZXMgKG1ha2UgYSBjb3B5IHRvIGRvIGl0IHNhZmVseSlcbiAgICB2YXIgZWRnZXNUb0JlUmVtb3ZlZCA9IFtdO1xuXG4gICAgZWRnZXNUb0JlUmVtb3ZlZCA9IGVkZ2VzVG9CZVJlbW92ZWQuY29uY2F0KGdyYXBoLmdldEVkZ2VzKCkpO1xuXG4gICAgdmFyIGVkZ2U7XG4gICAgdmFyIHMgPSBlZGdlc1RvQmVSZW1vdmVkLmxlbmd0aDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHM7IGkrKykge1xuICAgICAgZWRnZSA9IGVkZ2VzVG9CZVJlbW92ZWRbaV07XG4gICAgICBncmFwaC5yZW1vdmUoZWRnZSk7XG4gICAgfVxuXG4gICAgLy8gdGhlbiB0aGUgbm9kZXMgKG1ha2UgYSBjb3B5IHRvIGRvIGl0IHNhZmVseSlcbiAgICB2YXIgbm9kZXNUb0JlUmVtb3ZlZCA9IFtdO1xuXG4gICAgbm9kZXNUb0JlUmVtb3ZlZCA9IG5vZGVzVG9CZVJlbW92ZWQuY29uY2F0KGdyYXBoLmdldE5vZGVzKCkpO1xuXG4gICAgdmFyIG5vZGU7XG4gICAgcyA9IG5vZGVzVG9CZVJlbW92ZWQubGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgczsgaSsrKSB7XG4gICAgICBub2RlID0gbm9kZXNUb0JlUmVtb3ZlZFtpXTtcbiAgICAgIGdyYXBoLnJlbW92ZShub2RlKTtcbiAgICB9XG5cbiAgICAvLyBjaGVjayBpZiBncmFwaCBpcyB0aGUgcm9vdFxuICAgIGlmIChncmFwaCA9PSB0aGlzLnJvb3RHcmFwaCkge1xuICAgICAgdGhpcy5zZXRSb290R3JhcGgobnVsbCk7XG4gICAgfVxuXG4gICAgLy8gbm93IHJlbW92ZSB0aGUgZ3JhcGggaXRzZWxmXG4gICAgdmFyIGluZGV4ID0gdGhpcy5ncmFwaHMuaW5kZXhPZihncmFwaCk7XG4gICAgdGhpcy5ncmFwaHMuc3BsaWNlKGluZGV4LCAxKTtcblxuICAgIC8vIGFsc28gcmVzZXQgdGhlIHBhcmVudCBvZiB0aGUgZ3JhcGhcbiAgICBncmFwaC5wYXJlbnQgPSBudWxsO1xuICB9IGVsc2UgaWYgKGxPYmogaW5zdGFuY2VvZiBMRWRnZSkge1xuICAgIGVkZ2UgPSBsT2JqO1xuICAgIGlmIChlZGdlID09IG51bGwpIHtcbiAgICAgIHRocm93IFwiRWRnZSBpcyBudWxsIVwiO1xuICAgIH1cbiAgICBpZiAoIWVkZ2UuaXNJbnRlckdyYXBoKSB7XG4gICAgICB0aHJvdyBcIk5vdCBhbiBpbnRlci1ncmFwaCBlZGdlIVwiO1xuICAgIH1cbiAgICBpZiAoIShlZGdlLnNvdXJjZSAhPSBudWxsICYmIGVkZ2UudGFyZ2V0ICE9IG51bGwpKSB7XG4gICAgICB0aHJvdyBcIlNvdXJjZSBhbmQvb3IgdGFyZ2V0IGlzIG51bGwhXCI7XG4gICAgfVxuXG4gICAgLy8gcmVtb3ZlIGVkZ2UgZnJvbSBzb3VyY2UgYW5kIHRhcmdldCBub2RlcycgaW5jaWRlbmN5IGxpc3RzXG5cbiAgICBpZiAoIShlZGdlLnNvdXJjZS5lZGdlcy5pbmRleE9mKGVkZ2UpICE9IC0xICYmIGVkZ2UudGFyZ2V0LmVkZ2VzLmluZGV4T2YoZWRnZSkgIT0gLTEpKSB7XG4gICAgICB0aHJvdyBcIlNvdXJjZSBhbmQvb3IgdGFyZ2V0IGRvZXNuJ3Qga25vdyB0aGlzIGVkZ2UhXCI7XG4gICAgfVxuXG4gICAgdmFyIGluZGV4ID0gZWRnZS5zb3VyY2UuZWRnZXMuaW5kZXhPZihlZGdlKTtcbiAgICBlZGdlLnNvdXJjZS5lZGdlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIGluZGV4ID0gZWRnZS50YXJnZXQuZWRnZXMuaW5kZXhPZihlZGdlKTtcbiAgICBlZGdlLnRhcmdldC5lZGdlcy5zcGxpY2UoaW5kZXgsIDEpO1xuXG4gICAgLy8gcmVtb3ZlIGVkZ2UgZnJvbSBvd25lciBncmFwaCBtYW5hZ2VyJ3MgaW50ZXItZ3JhcGggZWRnZSBsaXN0XG5cbiAgICBpZiAoIShlZGdlLnNvdXJjZS5vd25lciAhPSBudWxsICYmIGVkZ2Uuc291cmNlLm93bmVyLmdldEdyYXBoTWFuYWdlcigpICE9IG51bGwpKSB7XG4gICAgICB0aHJvdyBcIkVkZ2Ugb3duZXIgZ3JhcGggb3Igb3duZXIgZ3JhcGggbWFuYWdlciBpcyBudWxsIVwiO1xuICAgIH1cbiAgICBpZiAoZWRnZS5zb3VyY2Uub3duZXIuZ2V0R3JhcGhNYW5hZ2VyKCkuZWRnZXMuaW5kZXhPZihlZGdlKSA9PSAtMSkge1xuICAgICAgdGhyb3cgXCJOb3QgaW4gb3duZXIgZ3JhcGggbWFuYWdlcidzIGVkZ2UgbGlzdCFcIjtcbiAgICB9XG5cbiAgICB2YXIgaW5kZXggPSBlZGdlLnNvdXJjZS5vd25lci5nZXRHcmFwaE1hbmFnZXIoKS5lZGdlcy5pbmRleE9mKGVkZ2UpO1xuICAgIGVkZ2Uuc291cmNlLm93bmVyLmdldEdyYXBoTWFuYWdlcigpLmVkZ2VzLnNwbGljZShpbmRleCwgMSk7XG4gIH1cbn07XG5cbkxHcmFwaE1hbmFnZXIucHJvdG90eXBlLnVwZGF0ZUJvdW5kcyA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5yb290R3JhcGgudXBkYXRlQm91bmRzKHRydWUpO1xufTtcblxuTEdyYXBoTWFuYWdlci5wcm90b3R5cGUuZ2V0R3JhcGhzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5ncmFwaHM7XG59O1xuXG5MR3JhcGhNYW5hZ2VyLnByb3RvdHlwZS5nZXRBbGxOb2RlcyA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuYWxsTm9kZXMgPT0gbnVsbCkge1xuICAgIHZhciBub2RlTGlzdCA9IFtdO1xuICAgIHZhciBncmFwaHMgPSB0aGlzLmdldEdyYXBocygpO1xuICAgIHZhciBzID0gZ3JhcGhzLmxlbmd0aDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHM7IGkrKykge1xuICAgICAgbm9kZUxpc3QgPSBub2RlTGlzdC5jb25jYXQoZ3JhcGhzW2ldLmdldE5vZGVzKCkpO1xuICAgIH1cbiAgICB0aGlzLmFsbE5vZGVzID0gbm9kZUxpc3Q7XG4gIH1cbiAgcmV0dXJuIHRoaXMuYWxsTm9kZXM7XG59O1xuXG5MR3JhcGhNYW5hZ2VyLnByb3RvdHlwZS5yZXNldEFsbE5vZGVzID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmFsbE5vZGVzID0gbnVsbDtcbn07XG5cbkxHcmFwaE1hbmFnZXIucHJvdG90eXBlLnJlc2V0QWxsRWRnZXMgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuYWxsRWRnZXMgPSBudWxsO1xufTtcblxuTEdyYXBoTWFuYWdlci5wcm90b3R5cGUucmVzZXRBbGxOb2Rlc1RvQXBwbHlHcmF2aXRhdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5hbGxOb2Rlc1RvQXBwbHlHcmF2aXRhdGlvbiA9IG51bGw7XG59O1xuXG5MR3JhcGhNYW5hZ2VyLnByb3RvdHlwZS5nZXRBbGxFZGdlcyA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuYWxsRWRnZXMgPT0gbnVsbCkge1xuICAgIHZhciBlZGdlTGlzdCA9IFtdO1xuICAgIHZhciBncmFwaHMgPSB0aGlzLmdldEdyYXBocygpO1xuICAgIHZhciBzID0gZ3JhcGhzLmxlbmd0aDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdyYXBocy5sZW5ndGg7IGkrKykge1xuICAgICAgZWRnZUxpc3QgPSBlZGdlTGlzdC5jb25jYXQoZ3JhcGhzW2ldLmdldEVkZ2VzKCkpO1xuICAgIH1cblxuICAgIGVkZ2VMaXN0ID0gZWRnZUxpc3QuY29uY2F0KHRoaXMuZWRnZXMpO1xuXG4gICAgdGhpcy5hbGxFZGdlcyA9IGVkZ2VMaXN0O1xuICB9XG4gIHJldHVybiB0aGlzLmFsbEVkZ2VzO1xufTtcblxuTEdyYXBoTWFuYWdlci5wcm90b3R5cGUuZ2V0QWxsTm9kZXNUb0FwcGx5R3Jhdml0YXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmFsbE5vZGVzVG9BcHBseUdyYXZpdGF0aW9uO1xufTtcblxuTEdyYXBoTWFuYWdlci5wcm90b3R5cGUuc2V0QWxsTm9kZXNUb0FwcGx5R3Jhdml0YXRpb24gPSBmdW5jdGlvbiAobm9kZUxpc3QpIHtcbiAgaWYgKHRoaXMuYWxsTm9kZXNUb0FwcGx5R3Jhdml0YXRpb24gIT0gbnVsbCkge1xuICAgIHRocm93IFwiYXNzZXJ0IGZhaWxlZFwiO1xuICB9XG5cbiAgdGhpcy5hbGxOb2Rlc1RvQXBwbHlHcmF2aXRhdGlvbiA9IG5vZGVMaXN0O1xufTtcblxuTEdyYXBoTWFuYWdlci5wcm90b3R5cGUuZ2V0Um9vdCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMucm9vdEdyYXBoO1xufTtcblxuTEdyYXBoTWFuYWdlci5wcm90b3R5cGUuc2V0Um9vdEdyYXBoID0gZnVuY3Rpb24gKGdyYXBoKSB7XG4gIGlmIChncmFwaC5nZXRHcmFwaE1hbmFnZXIoKSAhPSB0aGlzKSB7XG4gICAgdGhyb3cgXCJSb290IG5vdCBpbiB0aGlzIGdyYXBoIG1nciFcIjtcbiAgfVxuXG4gIHRoaXMucm9vdEdyYXBoID0gZ3JhcGg7XG4gIC8vIHJvb3QgZ3JhcGggbXVzdCBoYXZlIGEgcm9vdCBub2RlIGFzc29jaWF0ZWQgd2l0aCBpdCBmb3IgY29udmVuaWVuY2VcbiAgaWYgKGdyYXBoLnBhcmVudCA9PSBudWxsKSB7XG4gICAgZ3JhcGgucGFyZW50ID0gdGhpcy5sYXlvdXQubmV3Tm9kZShcIlJvb3Qgbm9kZVwiKTtcbiAgfVxufTtcblxuTEdyYXBoTWFuYWdlci5wcm90b3R5cGUuZ2V0TGF5b3V0ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5sYXlvdXQ7XG59O1xuXG5MR3JhcGhNYW5hZ2VyLnByb3RvdHlwZS5pc09uZUFuY2VzdG9yT2ZPdGhlciA9IGZ1bmN0aW9uIChmaXJzdE5vZGUsIHNlY29uZE5vZGUpIHtcbiAgaWYgKCEoZmlyc3ROb2RlICE9IG51bGwgJiYgc2Vjb25kTm9kZSAhPSBudWxsKSkge1xuICAgIHRocm93IFwiYXNzZXJ0IGZhaWxlZFwiO1xuICB9XG5cbiAgaWYgKGZpcnN0Tm9kZSA9PSBzZWNvbmROb2RlKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgLy8gSXMgc2Vjb25kIG5vZGUgYW4gYW5jZXN0b3Igb2YgdGhlIGZpcnN0IG9uZT9cbiAgdmFyIG93bmVyR3JhcGggPSBmaXJzdE5vZGUuZ2V0T3duZXIoKTtcbiAgdmFyIHBhcmVudE5vZGU7XG5cbiAgZG8ge1xuICAgIHBhcmVudE5vZGUgPSBvd25lckdyYXBoLmdldFBhcmVudCgpO1xuXG4gICAgaWYgKHBhcmVudE5vZGUgPT0gbnVsbCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKHBhcmVudE5vZGUgPT0gc2Vjb25kTm9kZSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgb3duZXJHcmFwaCA9IHBhcmVudE5vZGUuZ2V0T3duZXIoKTtcbiAgICBpZiAob3duZXJHcmFwaCA9PSBudWxsKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH0gd2hpbGUgKHRydWUpO1xuICAvLyBJcyBmaXJzdCBub2RlIGFuIGFuY2VzdG9yIG9mIHRoZSBzZWNvbmQgb25lP1xuICBvd25lckdyYXBoID0gc2Vjb25kTm9kZS5nZXRPd25lcigpO1xuXG4gIGRvIHtcbiAgICBwYXJlbnROb2RlID0gb3duZXJHcmFwaC5nZXRQYXJlbnQoKTtcblxuICAgIGlmIChwYXJlbnROb2RlID09IG51bGwpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGlmIChwYXJlbnROb2RlID09IGZpcnN0Tm9kZSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgb3duZXJHcmFwaCA9IHBhcmVudE5vZGUuZ2V0T3duZXIoKTtcbiAgICBpZiAob3duZXJHcmFwaCA9PSBudWxsKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH0gd2hpbGUgKHRydWUpO1xuXG4gIHJldHVybiBmYWxzZTtcbn07XG5cbkxHcmFwaE1hbmFnZXIucHJvdG90eXBlLmNhbGNMb3dlc3RDb21tb25BbmNlc3RvcnMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBlZGdlO1xuICB2YXIgc291cmNlTm9kZTtcbiAgdmFyIHRhcmdldE5vZGU7XG4gIHZhciBzb3VyY2VBbmNlc3RvckdyYXBoO1xuICB2YXIgdGFyZ2V0QW5jZXN0b3JHcmFwaDtcblxuICB2YXIgZWRnZXMgPSB0aGlzLmdldEFsbEVkZ2VzKCk7XG4gIHZhciBzID0gZWRnZXMubGVuZ3RoO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHM7IGkrKykge1xuICAgIGVkZ2UgPSBlZGdlc1tpXTtcblxuICAgIHNvdXJjZU5vZGUgPSBlZGdlLnNvdXJjZTtcbiAgICB0YXJnZXROb2RlID0gZWRnZS50YXJnZXQ7XG4gICAgZWRnZS5sY2EgPSBudWxsO1xuICAgIGVkZ2Uuc291cmNlSW5MY2EgPSBzb3VyY2VOb2RlO1xuICAgIGVkZ2UudGFyZ2V0SW5MY2EgPSB0YXJnZXROb2RlO1xuXG4gICAgaWYgKHNvdXJjZU5vZGUgPT0gdGFyZ2V0Tm9kZSkge1xuICAgICAgZWRnZS5sY2EgPSBzb3VyY2VOb2RlLmdldE93bmVyKCk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBzb3VyY2VBbmNlc3RvckdyYXBoID0gc291cmNlTm9kZS5nZXRPd25lcigpO1xuXG4gICAgd2hpbGUgKGVkZ2UubGNhID09IG51bGwpIHtcbiAgICAgIGVkZ2UudGFyZ2V0SW5MY2EgPSB0YXJnZXROb2RlO1xuICAgICAgdGFyZ2V0QW5jZXN0b3JHcmFwaCA9IHRhcmdldE5vZGUuZ2V0T3duZXIoKTtcblxuICAgICAgd2hpbGUgKGVkZ2UubGNhID09IG51bGwpIHtcbiAgICAgICAgaWYgKHRhcmdldEFuY2VzdG9yR3JhcGggPT0gc291cmNlQW5jZXN0b3JHcmFwaCkge1xuICAgICAgICAgIGVkZ2UubGNhID0gdGFyZ2V0QW5jZXN0b3JHcmFwaDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0YXJnZXRBbmNlc3RvckdyYXBoID09IHRoaXMucm9vdEdyYXBoKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZWRnZS5sY2EgIT0gbnVsbCkge1xuICAgICAgICAgIHRocm93IFwiYXNzZXJ0IGZhaWxlZFwiO1xuICAgICAgICB9XG4gICAgICAgIGVkZ2UudGFyZ2V0SW5MY2EgPSB0YXJnZXRBbmNlc3RvckdyYXBoLmdldFBhcmVudCgpO1xuICAgICAgICB0YXJnZXRBbmNlc3RvckdyYXBoID0gZWRnZS50YXJnZXRJbkxjYS5nZXRPd25lcigpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc291cmNlQW5jZXN0b3JHcmFwaCA9PSB0aGlzLnJvb3RHcmFwaCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgaWYgKGVkZ2UubGNhID09IG51bGwpIHtcbiAgICAgICAgZWRnZS5zb3VyY2VJbkxjYSA9IHNvdXJjZUFuY2VzdG9yR3JhcGguZ2V0UGFyZW50KCk7XG4gICAgICAgIHNvdXJjZUFuY2VzdG9yR3JhcGggPSBlZGdlLnNvdXJjZUluTGNhLmdldE93bmVyKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGVkZ2UubGNhID09IG51bGwpIHtcbiAgICAgIHRocm93IFwiYXNzZXJ0IGZhaWxlZFwiO1xuICAgIH1cbiAgfVxufTtcblxuTEdyYXBoTWFuYWdlci5wcm90b3R5cGUuY2FsY0xvd2VzdENvbW1vbkFuY2VzdG9yID0gZnVuY3Rpb24gKGZpcnN0Tm9kZSwgc2Vjb25kTm9kZSkge1xuICBpZiAoZmlyc3ROb2RlID09IHNlY29uZE5vZGUpIHtcbiAgICByZXR1cm4gZmlyc3ROb2RlLmdldE93bmVyKCk7XG4gIH1cbiAgdmFyIGZpcnN0T3duZXJHcmFwaCA9IGZpcnN0Tm9kZS5nZXRPd25lcigpO1xuXG4gIGRvIHtcbiAgICBpZiAoZmlyc3RPd25lckdyYXBoID09IG51bGwpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICB2YXIgc2Vjb25kT3duZXJHcmFwaCA9IHNlY29uZE5vZGUuZ2V0T3duZXIoKTtcblxuICAgIGRvIHtcbiAgICAgIGlmIChzZWNvbmRPd25lckdyYXBoID09IG51bGwpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGlmIChzZWNvbmRPd25lckdyYXBoID09IGZpcnN0T3duZXJHcmFwaCkge1xuICAgICAgICByZXR1cm4gc2Vjb25kT3duZXJHcmFwaDtcbiAgICAgIH1cbiAgICAgIHNlY29uZE93bmVyR3JhcGggPSBzZWNvbmRPd25lckdyYXBoLmdldFBhcmVudCgpLmdldE93bmVyKCk7XG4gICAgfSB3aGlsZSAodHJ1ZSk7XG5cbiAgICBmaXJzdE93bmVyR3JhcGggPSBmaXJzdE93bmVyR3JhcGguZ2V0UGFyZW50KCkuZ2V0T3duZXIoKTtcbiAgfSB3aGlsZSAodHJ1ZSk7XG5cbiAgcmV0dXJuIGZpcnN0T3duZXJHcmFwaDtcbn07XG5cbkxHcmFwaE1hbmFnZXIucHJvdG90eXBlLmNhbGNJbmNsdXNpb25UcmVlRGVwdGhzID0gZnVuY3Rpb24gKGdyYXBoLCBkZXB0aCkge1xuICBpZiAoZ3JhcGggPT0gbnVsbCAmJiBkZXB0aCA9PSBudWxsKSB7XG4gICAgZ3JhcGggPSB0aGlzLnJvb3RHcmFwaDtcbiAgICBkZXB0aCA9IDE7XG4gIH1cbiAgdmFyIG5vZGU7XG5cbiAgdmFyIG5vZGVzID0gZ3JhcGguZ2V0Tm9kZXMoKTtcbiAgdmFyIHMgPSBub2Rlcy5sZW5ndGg7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgczsgaSsrKSB7XG4gICAgbm9kZSA9IG5vZGVzW2ldO1xuICAgIG5vZGUuaW5jbHVzaW9uVHJlZURlcHRoID0gZGVwdGg7XG5cbiAgICBpZiAobm9kZS5jaGlsZCAhPSBudWxsKSB7XG4gICAgICB0aGlzLmNhbGNJbmNsdXNpb25UcmVlRGVwdGhzKG5vZGUuY2hpbGQsIGRlcHRoICsgMSk7XG4gICAgfVxuICB9XG59O1xuXG5MR3JhcGhNYW5hZ2VyLnByb3RvdHlwZS5pbmNsdWRlc0ludmFsaWRFZGdlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgZWRnZTtcblxuICB2YXIgcyA9IHRoaXMuZWRnZXMubGVuZ3RoO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHM7IGkrKykge1xuICAgIGVkZ2UgPSB0aGlzLmVkZ2VzW2ldO1xuXG4gICAgaWYgKHRoaXMuaXNPbmVBbmNlc3Rvck9mT3RoZXIoZWRnZS5zb3VyY2UsIGVkZ2UudGFyZ2V0KSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTEdyYXBoTWFuYWdlcjtcblxuLyoqKi8gfSksXG4vKiA3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBMYXlvdXRDb25zdGFudHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG5mdW5jdGlvbiBGRExheW91dENvbnN0YW50cygpIHt9XG5cbi8vRkRMYXlvdXRDb25zdGFudHMgaW5oZXJpdHMgc3RhdGljIHByb3BzIGluIExheW91dENvbnN0YW50c1xuZm9yICh2YXIgcHJvcCBpbiBMYXlvdXRDb25zdGFudHMpIHtcbiAgRkRMYXlvdXRDb25zdGFudHNbcHJvcF0gPSBMYXlvdXRDb25zdGFudHNbcHJvcF07XG59XG5cbkZETGF5b3V0Q29uc3RhbnRzLk1BWF9JVEVSQVRJT05TID0gMjUwMDtcblxuRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9FREdFX0xFTkdUSCA9IDUwO1xuRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9TUFJJTkdfU1RSRU5HVEggPSAwLjQ1O1xuRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9SRVBVTFNJT05fU1RSRU5HVEggPSA0NTAwLjA7XG5GRExheW91dENvbnN0YW50cy5ERUZBVUxUX0dSQVZJVFlfU1RSRU5HVEggPSAwLjQ7XG5GRExheW91dENvbnN0YW50cy5ERUZBVUxUX0NPTVBPVU5EX0dSQVZJVFlfU1RSRU5HVEggPSAxLjA7XG5GRExheW91dENvbnN0YW50cy5ERUZBVUxUX0dSQVZJVFlfUkFOR0VfRkFDVE9SID0gMy44O1xuRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9DT01QT1VORF9HUkFWSVRZX1JBTkdFX0ZBQ1RPUiA9IDEuNTtcbkZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfVVNFX1NNQVJUX0lERUFMX0VER0VfTEVOR1RIX0NBTENVTEFUSU9OID0gdHJ1ZTtcbkZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfVVNFX1NNQVJUX1JFUFVMU0lPTl9SQU5HRV9DQUxDVUxBVElPTiA9IHRydWU7XG5GRExheW91dENvbnN0YW50cy5ERUZBVUxUX0NPT0xJTkdfRkFDVE9SX0lOQ1JFTUVOVEFMID0gMC4zO1xuRkRMYXlvdXRDb25zdGFudHMuQ09PTElOR19BREFQVEFUSU9OX0ZBQ1RPUiA9IDAuMzM7XG5GRExheW91dENvbnN0YW50cy5BREFQVEFUSU9OX0xPV0VSX05PREVfTElNSVQgPSAxMDAwO1xuRkRMYXlvdXRDb25zdGFudHMuQURBUFRBVElPTl9VUFBFUl9OT0RFX0xJTUlUID0gNTAwMDtcbkZETGF5b3V0Q29uc3RhbnRzLk1BWF9OT0RFX0RJU1BMQUNFTUVOVF9JTkNSRU1FTlRBTCA9IDEwMC4wO1xuRkRMYXlvdXRDb25zdGFudHMuTUFYX05PREVfRElTUExBQ0VNRU5UID0gRkRMYXlvdXRDb25zdGFudHMuTUFYX05PREVfRElTUExBQ0VNRU5UX0lOQ1JFTUVOVEFMICogMztcbkZETGF5b3V0Q29uc3RhbnRzLk1JTl9SRVBVTFNJT05fRElTVCA9IEZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfRURHRV9MRU5HVEggLyAxMC4wO1xuRkRMYXlvdXRDb25zdGFudHMuQ09OVkVSR0VOQ0VfQ0hFQ0tfUEVSSU9EID0gMTAwO1xuRkRMYXlvdXRDb25zdGFudHMuUEVSX0xFVkVMX0lERUFMX0VER0VfTEVOR1RIX0ZBQ1RPUiA9IDAuMTtcbkZETGF5b3V0Q29uc3RhbnRzLk1JTl9FREdFX0xFTkdUSCA9IDE7XG5GRExheW91dENvbnN0YW50cy5HUklEX0NBTENVTEFUSU9OX0NIRUNLX1BFUklPRCA9IDEwO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZETGF5b3V0Q29uc3RhbnRzO1xuXG4vKioqLyB9KSxcbi8qIDggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuLyoqXG4gKiBUaGlzIGNsYXNzIG1haW50YWlucyBhIGxpc3Qgb2Ygc3RhdGljIGdlb21ldHJ5IHJlbGF0ZWQgdXRpbGl0eSBtZXRob2RzLlxuICpcbiAqXG4gKiBDb3B5cmlnaHQ6IGktVmlzIFJlc2VhcmNoIEdyb3VwLCBCaWxrZW50IFVuaXZlcnNpdHksIDIwMDcgLSBwcmVzZW50XG4gKi9cblxudmFyIFBvaW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMik7XG5cbmZ1bmN0aW9uIElHZW9tZXRyeSgpIHt9XG5cbi8qKlxuICogVGhpcyBtZXRob2QgY2FsY3VsYXRlcyAqaGFsZiogdGhlIGFtb3VudCBpbiB4IGFuZCB5IGRpcmVjdGlvbnMgb2YgdGhlIHR3b1xuICogaW5wdXQgcmVjdGFuZ2xlcyBuZWVkZWQgdG8gc2VwYXJhdGUgdGhlbSBrZWVwaW5nIHRoZWlyIHJlc3BlY3RpdmVcbiAqIHBvc2l0aW9uaW5nLCBhbmQgcmV0dXJucyB0aGUgcmVzdWx0IGluIHRoZSBpbnB1dCBhcnJheS4gQW4gaW5wdXRcbiAqIHNlcGFyYXRpb24gYnVmZmVyIGFkZGVkIHRvIHRoZSBhbW91bnQgaW4gYm90aCBkaXJlY3Rpb25zLiBXZSBhc3N1bWUgdGhhdFxuICogdGhlIHR3byByZWN0YW5nbGVzIGRvIGludGVyc2VjdC5cbiAqL1xuSUdlb21ldHJ5LmNhbGNTZXBhcmF0aW9uQW1vdW50ID0gZnVuY3Rpb24gKHJlY3RBLCByZWN0Qiwgb3ZlcmxhcEFtb3VudCwgc2VwYXJhdGlvbkJ1ZmZlcikge1xuICBpZiAoIXJlY3RBLmludGVyc2VjdHMocmVjdEIpKSB7XG4gICAgdGhyb3cgXCJhc3NlcnQgZmFpbGVkXCI7XG4gIH1cblxuICB2YXIgZGlyZWN0aW9ucyA9IG5ldyBBcnJheSgyKTtcblxuICB0aGlzLmRlY2lkZURpcmVjdGlvbnNGb3JPdmVybGFwcGluZ05vZGVzKHJlY3RBLCByZWN0QiwgZGlyZWN0aW9ucyk7XG5cbiAgb3ZlcmxhcEFtb3VudFswXSA9IE1hdGgubWluKHJlY3RBLmdldFJpZ2h0KCksIHJlY3RCLmdldFJpZ2h0KCkpIC0gTWF0aC5tYXgocmVjdEEueCwgcmVjdEIueCk7XG4gIG92ZXJsYXBBbW91bnRbMV0gPSBNYXRoLm1pbihyZWN0QS5nZXRCb3R0b20oKSwgcmVjdEIuZ2V0Qm90dG9tKCkpIC0gTWF0aC5tYXgocmVjdEEueSwgcmVjdEIueSk7XG5cbiAgLy8gdXBkYXRlIHRoZSBvdmVybGFwcGluZyBhbW91bnRzIGZvciB0aGUgZm9sbG93aW5nIGNhc2VzOlxuICBpZiAocmVjdEEuZ2V0WCgpIDw9IHJlY3RCLmdldFgoKSAmJiByZWN0QS5nZXRSaWdodCgpID49IHJlY3RCLmdldFJpZ2h0KCkpIHtcbiAgICAvKiBDYXNlIHguMTpcbiAgICAqXG4gICAgKiByZWN0QVxuICAgICogXHR8ICAgICAgICAgICAgICAgICAgICAgICB8XG4gICAgKiBcdHwgICAgICAgIF9fX19fX19fXyAgICAgIHxcbiAgICAqIFx0fCAgICAgICAgfCAgICAgICB8ICAgICAgfFxuICAgICogXHR8X19fX19fX198X19fX19fX3xfX19fX198XG4gICAgKiBcdFx0XHQgfCAgICAgICB8XG4gICAgKiAgICAgICAgICAgfCAgICAgICB8XG4gICAgKiAgICAgICAgcmVjdEJcbiAgICAqL1xuICAgIG92ZXJsYXBBbW91bnRbMF0gKz0gTWF0aC5taW4ocmVjdEIuZ2V0WCgpIC0gcmVjdEEuZ2V0WCgpLCByZWN0QS5nZXRSaWdodCgpIC0gcmVjdEIuZ2V0UmlnaHQoKSk7XG4gIH0gZWxzZSBpZiAocmVjdEIuZ2V0WCgpIDw9IHJlY3RBLmdldFgoKSAmJiByZWN0Qi5nZXRSaWdodCgpID49IHJlY3RBLmdldFJpZ2h0KCkpIHtcbiAgICAvKiBDYXNlIHguMjpcbiAgICAqXG4gICAgKiByZWN0QlxuICAgICogXHR8ICAgICAgICAgICAgICAgICAgICAgICB8XG4gICAgKiBcdHwgICAgICAgIF9fX19fX19fXyAgICAgIHxcbiAgICAqIFx0fCAgICAgICAgfCAgICAgICB8ICAgICAgfFxuICAgICogXHR8X19fX19fX198X19fX19fX3xfX19fX198XG4gICAgKiBcdFx0XHQgfCAgICAgICB8XG4gICAgKiAgICAgICAgICAgfCAgICAgICB8XG4gICAgKiAgICAgICAgcmVjdEFcbiAgICAqL1xuICAgIG92ZXJsYXBBbW91bnRbMF0gKz0gTWF0aC5taW4ocmVjdEEuZ2V0WCgpIC0gcmVjdEIuZ2V0WCgpLCByZWN0Qi5nZXRSaWdodCgpIC0gcmVjdEEuZ2V0UmlnaHQoKSk7XG4gIH1cbiAgaWYgKHJlY3RBLmdldFkoKSA8PSByZWN0Qi5nZXRZKCkgJiYgcmVjdEEuZ2V0Qm90dG9tKCkgPj0gcmVjdEIuZ2V0Qm90dG9tKCkpIHtcbiAgICAvKiBDYXNlIHkuMTpcbiAgICAgKiAgICAgICAgICBfX19fX19fXyByZWN0QVxuICAgICAqICAgICAgICAgfFxuICAgICAqICAgICAgICAgfFxuICAgICAqICAgX19fX19ffF9fX18gIHJlY3RCXG4gICAgICogICAgICAgICB8ICAgIHxcbiAgICAgKiAgICAgICAgIHwgICAgfFxuICAgICAqICAgX19fX19ffF9fX198XG4gICAgICogICAgICAgICB8XG4gICAgICogICAgICAgICB8XG4gICAgICogICAgICAgICB8X19fX19fX19cbiAgICAgKlxuICAgICAqL1xuICAgIG92ZXJsYXBBbW91bnRbMV0gKz0gTWF0aC5taW4ocmVjdEIuZ2V0WSgpIC0gcmVjdEEuZ2V0WSgpLCByZWN0QS5nZXRCb3R0b20oKSAtIHJlY3RCLmdldEJvdHRvbSgpKTtcbiAgfSBlbHNlIGlmIChyZWN0Qi5nZXRZKCkgPD0gcmVjdEEuZ2V0WSgpICYmIHJlY3RCLmdldEJvdHRvbSgpID49IHJlY3RBLmdldEJvdHRvbSgpKSB7XG4gICAgLyogQ2FzZSB5LjI6XG4gICAgKiAgICAgICAgICBfX19fX19fXyByZWN0QlxuICAgICogICAgICAgICB8XG4gICAgKiAgICAgICAgIHxcbiAgICAqICAgX19fX19ffF9fX18gIHJlY3RBXG4gICAgKiAgICAgICAgIHwgICAgfFxuICAgICogICAgICAgICB8ICAgIHxcbiAgICAqICAgX19fX19ffF9fX198XG4gICAgKiAgICAgICAgIHxcbiAgICAqICAgICAgICAgfFxuICAgICogICAgICAgICB8X19fX19fX19cbiAgICAqXG4gICAgKi9cbiAgICBvdmVybGFwQW1vdW50WzFdICs9IE1hdGgubWluKHJlY3RBLmdldFkoKSAtIHJlY3RCLmdldFkoKSwgcmVjdEIuZ2V0Qm90dG9tKCkgLSByZWN0QS5nZXRCb3R0b20oKSk7XG4gIH1cblxuICAvLyBmaW5kIHNsb3BlIG9mIHRoZSBsaW5lIHBhc3NlcyB0d28gY2VudGVyc1xuICB2YXIgc2xvcGUgPSBNYXRoLmFicygocmVjdEIuZ2V0Q2VudGVyWSgpIC0gcmVjdEEuZ2V0Q2VudGVyWSgpKSAvIChyZWN0Qi5nZXRDZW50ZXJYKCkgLSByZWN0QS5nZXRDZW50ZXJYKCkpKTtcbiAgLy8gaWYgY2VudGVycyBhcmUgb3ZlcmxhcHBlZFxuICBpZiAocmVjdEIuZ2V0Q2VudGVyWSgpID09PSByZWN0QS5nZXRDZW50ZXJZKCkgJiYgcmVjdEIuZ2V0Q2VudGVyWCgpID09PSByZWN0QS5nZXRDZW50ZXJYKCkpIHtcbiAgICAvLyBhc3N1bWUgdGhlIHNsb3BlIGlzIDEgKDQ1IGRlZ3JlZSlcbiAgICBzbG9wZSA9IDEuMDtcbiAgfVxuXG4gIHZhciBtb3ZlQnlZID0gc2xvcGUgKiBvdmVybGFwQW1vdW50WzBdO1xuICB2YXIgbW92ZUJ5WCA9IG92ZXJsYXBBbW91bnRbMV0gLyBzbG9wZTtcbiAgaWYgKG92ZXJsYXBBbW91bnRbMF0gPCBtb3ZlQnlYKSB7XG4gICAgbW92ZUJ5WCA9IG92ZXJsYXBBbW91bnRbMF07XG4gIH0gZWxzZSB7XG4gICAgbW92ZUJ5WSA9IG92ZXJsYXBBbW91bnRbMV07XG4gIH1cbiAgLy8gcmV0dXJuIGhhbGYgdGhlIGFtb3VudCBzbyB0aGF0IGlmIGVhY2ggcmVjdGFuZ2xlIGlzIG1vdmVkIGJ5IHRoZXNlXG4gIC8vIGFtb3VudHMgaW4gb3Bwb3NpdGUgZGlyZWN0aW9ucywgb3ZlcmxhcCB3aWxsIGJlIHJlc29sdmVkXG4gIG92ZXJsYXBBbW91bnRbMF0gPSAtMSAqIGRpcmVjdGlvbnNbMF0gKiAobW92ZUJ5WCAvIDIgKyBzZXBhcmF0aW9uQnVmZmVyKTtcbiAgb3ZlcmxhcEFtb3VudFsxXSA9IC0xICogZGlyZWN0aW9uc1sxXSAqIChtb3ZlQnlZIC8gMiArIHNlcGFyYXRpb25CdWZmZXIpO1xufTtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBkZWNpZGVzIHRoZSBzZXBhcmF0aW9uIGRpcmVjdGlvbiBvZiBvdmVybGFwcGluZyBub2Rlc1xuICpcbiAqIGlmIGRpcmVjdGlvbnNbMF0gPSAtMSwgdGhlbiByZWN0QSBnb2VzIGxlZnRcbiAqIGlmIGRpcmVjdGlvbnNbMF0gPSAxLCAgdGhlbiByZWN0QSBnb2VzIHJpZ2h0XG4gKiBpZiBkaXJlY3Rpb25zWzFdID0gLTEsIHRoZW4gcmVjdEEgZ29lcyB1cFxuICogaWYgZGlyZWN0aW9uc1sxXSA9IDEsICB0aGVuIHJlY3RBIGdvZXMgZG93blxuICovXG5JR2VvbWV0cnkuZGVjaWRlRGlyZWN0aW9uc0Zvck92ZXJsYXBwaW5nTm9kZXMgPSBmdW5jdGlvbiAocmVjdEEsIHJlY3RCLCBkaXJlY3Rpb25zKSB7XG4gIGlmIChyZWN0QS5nZXRDZW50ZXJYKCkgPCByZWN0Qi5nZXRDZW50ZXJYKCkpIHtcbiAgICBkaXJlY3Rpb25zWzBdID0gLTE7XG4gIH0gZWxzZSB7XG4gICAgZGlyZWN0aW9uc1swXSA9IDE7XG4gIH1cblxuICBpZiAocmVjdEEuZ2V0Q2VudGVyWSgpIDwgcmVjdEIuZ2V0Q2VudGVyWSgpKSB7XG4gICAgZGlyZWN0aW9uc1sxXSA9IC0xO1xuICB9IGVsc2Uge1xuICAgIGRpcmVjdGlvbnNbMV0gPSAxO1xuICB9XG59O1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGNhbGN1bGF0ZXMgdGhlIGludGVyc2VjdGlvbiAoY2xpcHBpbmcpIHBvaW50cyBvZiB0aGUgdHdvXG4gKiBpbnB1dCByZWN0YW5nbGVzIHdpdGggbGluZSBzZWdtZW50IGRlZmluZWQgYnkgdGhlIGNlbnRlcnMgb2YgdGhlc2UgdHdvXG4gKiByZWN0YW5nbGVzLiBUaGUgY2xpcHBpbmcgcG9pbnRzIGFyZSBzYXZlZCBpbiB0aGUgaW5wdXQgZG91YmxlIGFycmF5IGFuZFxuICogd2hldGhlciBvciBub3QgdGhlIHR3byByZWN0YW5nbGVzIG92ZXJsYXAgaXMgcmV0dXJuZWQuXG4gKi9cbklHZW9tZXRyeS5nZXRJbnRlcnNlY3Rpb24yID0gZnVuY3Rpb24gKHJlY3RBLCByZWN0QiwgcmVzdWx0KSB7XG4gIC8vcmVzdWx0WzAtMV0gd2lsbCBjb250YWluIGNsaXBQb2ludCBvZiByZWN0QSwgcmVzdWx0WzItM10gd2lsbCBjb250YWluIGNsaXBQb2ludCBvZiByZWN0QlxuICB2YXIgcDF4ID0gcmVjdEEuZ2V0Q2VudGVyWCgpO1xuICB2YXIgcDF5ID0gcmVjdEEuZ2V0Q2VudGVyWSgpO1xuICB2YXIgcDJ4ID0gcmVjdEIuZ2V0Q2VudGVyWCgpO1xuICB2YXIgcDJ5ID0gcmVjdEIuZ2V0Q2VudGVyWSgpO1xuXG4gIC8vaWYgdHdvIHJlY3RhbmdsZXMgaW50ZXJzZWN0LCB0aGVuIGNsaXBwaW5nIHBvaW50cyBhcmUgY2VudGVyc1xuICBpZiAocmVjdEEuaW50ZXJzZWN0cyhyZWN0QikpIHtcbiAgICByZXN1bHRbMF0gPSBwMXg7XG4gICAgcmVzdWx0WzFdID0gcDF5O1xuICAgIHJlc3VsdFsyXSA9IHAyeDtcbiAgICByZXN1bHRbM10gPSBwMnk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgLy92YXJpYWJsZXMgZm9yIHJlY3RBXG4gIHZhciB0b3BMZWZ0QXggPSByZWN0QS5nZXRYKCk7XG4gIHZhciB0b3BMZWZ0QXkgPSByZWN0QS5nZXRZKCk7XG4gIHZhciB0b3BSaWdodEF4ID0gcmVjdEEuZ2V0UmlnaHQoKTtcbiAgdmFyIGJvdHRvbUxlZnRBeCA9IHJlY3RBLmdldFgoKTtcbiAgdmFyIGJvdHRvbUxlZnRBeSA9IHJlY3RBLmdldEJvdHRvbSgpO1xuICB2YXIgYm90dG9tUmlnaHRBeCA9IHJlY3RBLmdldFJpZ2h0KCk7XG4gIHZhciBoYWxmV2lkdGhBID0gcmVjdEEuZ2V0V2lkdGhIYWxmKCk7XG4gIHZhciBoYWxmSGVpZ2h0QSA9IHJlY3RBLmdldEhlaWdodEhhbGYoKTtcbiAgLy92YXJpYWJsZXMgZm9yIHJlY3RCXG4gIHZhciB0b3BMZWZ0QnggPSByZWN0Qi5nZXRYKCk7XG4gIHZhciB0b3BMZWZ0QnkgPSByZWN0Qi5nZXRZKCk7XG4gIHZhciB0b3BSaWdodEJ4ID0gcmVjdEIuZ2V0UmlnaHQoKTtcbiAgdmFyIGJvdHRvbUxlZnRCeCA9IHJlY3RCLmdldFgoKTtcbiAgdmFyIGJvdHRvbUxlZnRCeSA9IHJlY3RCLmdldEJvdHRvbSgpO1xuICB2YXIgYm90dG9tUmlnaHRCeCA9IHJlY3RCLmdldFJpZ2h0KCk7XG4gIHZhciBoYWxmV2lkdGhCID0gcmVjdEIuZ2V0V2lkdGhIYWxmKCk7XG4gIHZhciBoYWxmSGVpZ2h0QiA9IHJlY3RCLmdldEhlaWdodEhhbGYoKTtcblxuICAvL2ZsYWcgd2hldGhlciBjbGlwcGluZyBwb2ludHMgYXJlIGZvdW5kXG4gIHZhciBjbGlwUG9pbnRBRm91bmQgPSBmYWxzZTtcbiAgdmFyIGNsaXBQb2ludEJGb3VuZCA9IGZhbHNlO1xuXG4gIC8vIGxpbmUgaXMgdmVydGljYWxcbiAgaWYgKHAxeCA9PT0gcDJ4KSB7XG4gICAgaWYgKHAxeSA+IHAyeSkge1xuICAgICAgcmVzdWx0WzBdID0gcDF4O1xuICAgICAgcmVzdWx0WzFdID0gdG9wTGVmdEF5O1xuICAgICAgcmVzdWx0WzJdID0gcDJ4O1xuICAgICAgcmVzdWx0WzNdID0gYm90dG9tTGVmdEJ5O1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSBpZiAocDF5IDwgcDJ5KSB7XG4gICAgICByZXN1bHRbMF0gPSBwMXg7XG4gICAgICByZXN1bHRbMV0gPSBib3R0b21MZWZ0QXk7XG4gICAgICByZXN1bHRbMl0gPSBwMng7XG4gICAgICByZXN1bHRbM10gPSB0b3BMZWZ0Qnk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vbm90IGxpbmUsIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuICAvLyBsaW5lIGlzIGhvcml6b250YWxcbiAgZWxzZSBpZiAocDF5ID09PSBwMnkpIHtcbiAgICAgIGlmIChwMXggPiBwMngpIHtcbiAgICAgICAgcmVzdWx0WzBdID0gdG9wTGVmdEF4O1xuICAgICAgICByZXN1bHRbMV0gPSBwMXk7XG4gICAgICAgIHJlc3VsdFsyXSA9IHRvcFJpZ2h0Qng7XG4gICAgICAgIHJlc3VsdFszXSA9IHAyeTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIGlmIChwMXggPCBwMngpIHtcbiAgICAgICAgcmVzdWx0WzBdID0gdG9wUmlnaHRBeDtcbiAgICAgICAgcmVzdWx0WzFdID0gcDF5O1xuICAgICAgICByZXN1bHRbMl0gPSB0b3BMZWZ0Qng7XG4gICAgICAgIHJlc3VsdFszXSA9IHAyeTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy9ub3QgdmFsaWQgbGluZSwgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vc2xvcGVzIG9mIHJlY3RBJ3MgYW5kIHJlY3RCJ3MgZGlhZ29uYWxzXG4gICAgICB2YXIgc2xvcGVBID0gcmVjdEEuaGVpZ2h0IC8gcmVjdEEud2lkdGg7XG4gICAgICB2YXIgc2xvcGVCID0gcmVjdEIuaGVpZ2h0IC8gcmVjdEIud2lkdGg7XG5cbiAgICAgIC8vc2xvcGUgb2YgbGluZSBiZXR3ZWVuIGNlbnRlciBvZiByZWN0QSBhbmQgY2VudGVyIG9mIHJlY3RCXG4gICAgICB2YXIgc2xvcGVQcmltZSA9IChwMnkgLSBwMXkpIC8gKHAyeCAtIHAxeCk7XG4gICAgICB2YXIgY2FyZGluYWxEaXJlY3Rpb25BID0gdm9pZCAwO1xuICAgICAgdmFyIGNhcmRpbmFsRGlyZWN0aW9uQiA9IHZvaWQgMDtcbiAgICAgIHZhciB0ZW1wUG9pbnRBeCA9IHZvaWQgMDtcbiAgICAgIHZhciB0ZW1wUG9pbnRBeSA9IHZvaWQgMDtcbiAgICAgIHZhciB0ZW1wUG9pbnRCeCA9IHZvaWQgMDtcbiAgICAgIHZhciB0ZW1wUG9pbnRCeSA9IHZvaWQgMDtcblxuICAgICAgLy9kZXRlcm1pbmUgd2hldGhlciBjbGlwcGluZyBwb2ludCBpcyB0aGUgY29ybmVyIG9mIG5vZGVBXG4gICAgICBpZiAoLXNsb3BlQSA9PT0gc2xvcGVQcmltZSkge1xuICAgICAgICBpZiAocDF4ID4gcDJ4KSB7XG4gICAgICAgICAgcmVzdWx0WzBdID0gYm90dG9tTGVmdEF4O1xuICAgICAgICAgIHJlc3VsdFsxXSA9IGJvdHRvbUxlZnRBeTtcbiAgICAgICAgICBjbGlwUG9pbnRBRm91bmQgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdFswXSA9IHRvcFJpZ2h0QXg7XG4gICAgICAgICAgcmVzdWx0WzFdID0gdG9wTGVmdEF5O1xuICAgICAgICAgIGNsaXBQb2ludEFGb3VuZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoc2xvcGVBID09PSBzbG9wZVByaW1lKSB7XG4gICAgICAgIGlmIChwMXggPiBwMngpIHtcbiAgICAgICAgICByZXN1bHRbMF0gPSB0b3BMZWZ0QXg7XG4gICAgICAgICAgcmVzdWx0WzFdID0gdG9wTGVmdEF5O1xuICAgICAgICAgIGNsaXBQb2ludEFGb3VuZCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0WzBdID0gYm90dG9tUmlnaHRBeDtcbiAgICAgICAgICByZXN1bHRbMV0gPSBib3R0b21MZWZ0QXk7XG4gICAgICAgICAgY2xpcFBvaW50QUZvdW5kID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvL2RldGVybWluZSB3aGV0aGVyIGNsaXBwaW5nIHBvaW50IGlzIHRoZSBjb3JuZXIgb2Ygbm9kZUJcbiAgICAgIGlmICgtc2xvcGVCID09PSBzbG9wZVByaW1lKSB7XG4gICAgICAgIGlmIChwMnggPiBwMXgpIHtcbiAgICAgICAgICByZXN1bHRbMl0gPSBib3R0b21MZWZ0Qng7XG4gICAgICAgICAgcmVzdWx0WzNdID0gYm90dG9tTGVmdEJ5O1xuICAgICAgICAgIGNsaXBQb2ludEJGb3VuZCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0WzJdID0gdG9wUmlnaHRCeDtcbiAgICAgICAgICByZXN1bHRbM10gPSB0b3BMZWZ0Qnk7XG4gICAgICAgICAgY2xpcFBvaW50QkZvdW5kID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChzbG9wZUIgPT09IHNsb3BlUHJpbWUpIHtcbiAgICAgICAgaWYgKHAyeCA+IHAxeCkge1xuICAgICAgICAgIHJlc3VsdFsyXSA9IHRvcExlZnRCeDtcbiAgICAgICAgICByZXN1bHRbM10gPSB0b3BMZWZ0Qnk7XG4gICAgICAgICAgY2xpcFBvaW50QkZvdW5kID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHRbMl0gPSBib3R0b21SaWdodEJ4O1xuICAgICAgICAgIHJlc3VsdFszXSA9IGJvdHRvbUxlZnRCeTtcbiAgICAgICAgICBjbGlwUG9pbnRCRm91bmQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vaWYgYm90aCBjbGlwcGluZyBwb2ludHMgYXJlIGNvcm5lcnNcbiAgICAgIGlmIChjbGlwUG9pbnRBRm91bmQgJiYgY2xpcFBvaW50QkZvdW5kKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgLy9kZXRlcm1pbmUgQ2FyZGluYWwgRGlyZWN0aW9uIG9mIHJlY3RhbmdsZXNcbiAgICAgIGlmIChwMXggPiBwMngpIHtcbiAgICAgICAgaWYgKHAxeSA+IHAyeSkge1xuICAgICAgICAgIGNhcmRpbmFsRGlyZWN0aW9uQSA9IHRoaXMuZ2V0Q2FyZGluYWxEaXJlY3Rpb24oc2xvcGVBLCBzbG9wZVByaW1lLCA0KTtcbiAgICAgICAgICBjYXJkaW5hbERpcmVjdGlvbkIgPSB0aGlzLmdldENhcmRpbmFsRGlyZWN0aW9uKHNsb3BlQiwgc2xvcGVQcmltZSwgMik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2FyZGluYWxEaXJlY3Rpb25BID0gdGhpcy5nZXRDYXJkaW5hbERpcmVjdGlvbigtc2xvcGVBLCBzbG9wZVByaW1lLCAzKTtcbiAgICAgICAgICBjYXJkaW5hbERpcmVjdGlvbkIgPSB0aGlzLmdldENhcmRpbmFsRGlyZWN0aW9uKC1zbG9wZUIsIHNsb3BlUHJpbWUsIDEpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocDF5ID4gcDJ5KSB7XG4gICAgICAgICAgY2FyZGluYWxEaXJlY3Rpb25BID0gdGhpcy5nZXRDYXJkaW5hbERpcmVjdGlvbigtc2xvcGVBLCBzbG9wZVByaW1lLCAxKTtcbiAgICAgICAgICBjYXJkaW5hbERpcmVjdGlvbkIgPSB0aGlzLmdldENhcmRpbmFsRGlyZWN0aW9uKC1zbG9wZUIsIHNsb3BlUHJpbWUsIDMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNhcmRpbmFsRGlyZWN0aW9uQSA9IHRoaXMuZ2V0Q2FyZGluYWxEaXJlY3Rpb24oc2xvcGVBLCBzbG9wZVByaW1lLCAyKTtcbiAgICAgICAgICBjYXJkaW5hbERpcmVjdGlvbkIgPSB0aGlzLmdldENhcmRpbmFsRGlyZWN0aW9uKHNsb3BlQiwgc2xvcGVQcmltZSwgNCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vY2FsY3VsYXRlIGNsaXBwaW5nIFBvaW50IGlmIGl0IGlzIG5vdCBmb3VuZCBiZWZvcmVcbiAgICAgIGlmICghY2xpcFBvaW50QUZvdW5kKSB7XG4gICAgICAgIHN3aXRjaCAoY2FyZGluYWxEaXJlY3Rpb25BKSB7XG4gICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgdGVtcFBvaW50QXkgPSB0b3BMZWZ0QXk7XG4gICAgICAgICAgICB0ZW1wUG9pbnRBeCA9IHAxeCArIC1oYWxmSGVpZ2h0QSAvIHNsb3BlUHJpbWU7XG4gICAgICAgICAgICByZXN1bHRbMF0gPSB0ZW1wUG9pbnRBeDtcbiAgICAgICAgICAgIHJlc3VsdFsxXSA9IHRlbXBQb2ludEF5O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgdGVtcFBvaW50QXggPSBib3R0b21SaWdodEF4O1xuICAgICAgICAgICAgdGVtcFBvaW50QXkgPSBwMXkgKyBoYWxmV2lkdGhBICogc2xvcGVQcmltZTtcbiAgICAgICAgICAgIHJlc3VsdFswXSA9IHRlbXBQb2ludEF4O1xuICAgICAgICAgICAgcmVzdWx0WzFdID0gdGVtcFBvaW50QXk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICB0ZW1wUG9pbnRBeSA9IGJvdHRvbUxlZnRBeTtcbiAgICAgICAgICAgIHRlbXBQb2ludEF4ID0gcDF4ICsgaGFsZkhlaWdodEEgLyBzbG9wZVByaW1lO1xuICAgICAgICAgICAgcmVzdWx0WzBdID0gdGVtcFBvaW50QXg7XG4gICAgICAgICAgICByZXN1bHRbMV0gPSB0ZW1wUG9pbnRBeTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIHRlbXBQb2ludEF4ID0gYm90dG9tTGVmdEF4O1xuICAgICAgICAgICAgdGVtcFBvaW50QXkgPSBwMXkgKyAtaGFsZldpZHRoQSAqIHNsb3BlUHJpbWU7XG4gICAgICAgICAgICByZXN1bHRbMF0gPSB0ZW1wUG9pbnRBeDtcbiAgICAgICAgICAgIHJlc3VsdFsxXSA9IHRlbXBQb2ludEF5O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghY2xpcFBvaW50QkZvdW5kKSB7XG4gICAgICAgIHN3aXRjaCAoY2FyZGluYWxEaXJlY3Rpb25CKSB7XG4gICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgdGVtcFBvaW50QnkgPSB0b3BMZWZ0Qnk7XG4gICAgICAgICAgICB0ZW1wUG9pbnRCeCA9IHAyeCArIC1oYWxmSGVpZ2h0QiAvIHNsb3BlUHJpbWU7XG4gICAgICAgICAgICByZXN1bHRbMl0gPSB0ZW1wUG9pbnRCeDtcbiAgICAgICAgICAgIHJlc3VsdFszXSA9IHRlbXBQb2ludEJ5O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgdGVtcFBvaW50QnggPSBib3R0b21SaWdodEJ4O1xuICAgICAgICAgICAgdGVtcFBvaW50QnkgPSBwMnkgKyBoYWxmV2lkdGhCICogc2xvcGVQcmltZTtcbiAgICAgICAgICAgIHJlc3VsdFsyXSA9IHRlbXBQb2ludEJ4O1xuICAgICAgICAgICAgcmVzdWx0WzNdID0gdGVtcFBvaW50Qnk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICB0ZW1wUG9pbnRCeSA9IGJvdHRvbUxlZnRCeTtcbiAgICAgICAgICAgIHRlbXBQb2ludEJ4ID0gcDJ4ICsgaGFsZkhlaWdodEIgLyBzbG9wZVByaW1lO1xuICAgICAgICAgICAgcmVzdWx0WzJdID0gdGVtcFBvaW50Qng7XG4gICAgICAgICAgICByZXN1bHRbM10gPSB0ZW1wUG9pbnRCeTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIHRlbXBQb2ludEJ4ID0gYm90dG9tTGVmdEJ4O1xuICAgICAgICAgICAgdGVtcFBvaW50QnkgPSBwMnkgKyAtaGFsZldpZHRoQiAqIHNsb3BlUHJpbWU7XG4gICAgICAgICAgICByZXN1bHRbMl0gPSB0ZW1wUG9pbnRCeDtcbiAgICAgICAgICAgIHJlc3VsdFszXSA9IHRlbXBQb2ludEJ5O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyBpbiB3aGljaCBjYXJkaW5hbCBkaXJlY3Rpb24gZG9lcyBpbnB1dCBwb2ludCBzdGF5c1xuICogMTogTm9ydGhcbiAqIDI6IEVhc3RcbiAqIDM6IFNvdXRoXG4gKiA0OiBXZXN0XG4gKi9cbklHZW9tZXRyeS5nZXRDYXJkaW5hbERpcmVjdGlvbiA9IGZ1bmN0aW9uIChzbG9wZSwgc2xvcGVQcmltZSwgbGluZSkge1xuICBpZiAoc2xvcGUgPiBzbG9wZVByaW1lKSB7XG4gICAgcmV0dXJuIGxpbmU7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIDEgKyBsaW5lICUgNDtcbiAgfVxufTtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBjYWxjdWxhdGVzIHRoZSBpbnRlcnNlY3Rpb24gb2YgdGhlIHR3byBsaW5lcyBkZWZpbmVkIGJ5XG4gKiBwb2ludCBwYWlycyAoczEsczIpIGFuZCAoZjEsZjIpLlxuICovXG5JR2VvbWV0cnkuZ2V0SW50ZXJzZWN0aW9uID0gZnVuY3Rpb24gKHMxLCBzMiwgZjEsIGYyKSB7XG4gIGlmIChmMiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0SW50ZXJzZWN0aW9uMihzMSwgczIsIGYxKTtcbiAgfVxuXG4gIHZhciB4MSA9IHMxLng7XG4gIHZhciB5MSA9IHMxLnk7XG4gIHZhciB4MiA9IHMyLng7XG4gIHZhciB5MiA9IHMyLnk7XG4gIHZhciB4MyA9IGYxLng7XG4gIHZhciB5MyA9IGYxLnk7XG4gIHZhciB4NCA9IGYyLng7XG4gIHZhciB5NCA9IGYyLnk7XG4gIHZhciB4ID0gdm9pZCAwLFxuICAgICAgeSA9IHZvaWQgMDsgLy8gaW50ZXJzZWN0aW9uIHBvaW50XG4gIHZhciBhMSA9IHZvaWQgMCxcbiAgICAgIGEyID0gdm9pZCAwLFxuICAgICAgYjEgPSB2b2lkIDAsXG4gICAgICBiMiA9IHZvaWQgMCxcbiAgICAgIGMxID0gdm9pZCAwLFxuICAgICAgYzIgPSB2b2lkIDA7IC8vIGNvZWZmaWNpZW50cyBvZiBsaW5lIGVxbnMuXG4gIHZhciBkZW5vbSA9IHZvaWQgMDtcblxuICBhMSA9IHkyIC0geTE7XG4gIGIxID0geDEgLSB4MjtcbiAgYzEgPSB4MiAqIHkxIC0geDEgKiB5MjsgLy8geyBhMSp4ICsgYjEqeSArIGMxID0gMCBpcyBsaW5lIDEgfVxuXG4gIGEyID0geTQgLSB5MztcbiAgYjIgPSB4MyAtIHg0O1xuICBjMiA9IHg0ICogeTMgLSB4MyAqIHk0OyAvLyB7IGEyKnggKyBiMip5ICsgYzIgPSAwIGlzIGxpbmUgMiB9XG5cbiAgZGVub20gPSBhMSAqIGIyIC0gYTIgKiBiMTtcblxuICBpZiAoZGVub20gPT09IDApIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHggPSAoYjEgKiBjMiAtIGIyICogYzEpIC8gZGVub207XG4gIHkgPSAoYTIgKiBjMSAtIGExICogYzIpIC8gZGVub207XG5cbiAgcmV0dXJuIG5ldyBQb2ludCh4LCB5KTtcbn07XG5cbi8qKlxuICogVGhpcyBtZXRob2QgZmluZHMgYW5kIHJldHVybnMgdGhlIGFuZ2xlIG9mIHRoZSB2ZWN0b3IgZnJvbSB0aGUgKyB4LWF4aXNcbiAqIGluIGNsb2Nrd2lzZSBkaXJlY3Rpb24gKGNvbXBhdGlibGUgdy8gSmF2YSBjb29yZGluYXRlIHN5c3RlbSEpLlxuICovXG5JR2VvbWV0cnkuYW5nbGVPZlZlY3RvciA9IGZ1bmN0aW9uIChDeCwgQ3ksIE54LCBOeSkge1xuICB2YXIgQ19hbmdsZSA9IHZvaWQgMDtcblxuICBpZiAoQ3ggIT09IE54KSB7XG4gICAgQ19hbmdsZSA9IE1hdGguYXRhbigoTnkgLSBDeSkgLyAoTnggLSBDeCkpO1xuXG4gICAgaWYgKE54IDwgQ3gpIHtcbiAgICAgIENfYW5nbGUgKz0gTWF0aC5QSTtcbiAgICB9IGVsc2UgaWYgKE55IDwgQ3kpIHtcbiAgICAgIENfYW5nbGUgKz0gdGhpcy5UV09fUEk7XG4gICAgfVxuICB9IGVsc2UgaWYgKE55IDwgQ3kpIHtcbiAgICBDX2FuZ2xlID0gdGhpcy5PTkVfQU5EX0hBTEZfUEk7IC8vIDI3MCBkZWdyZWVzXG4gIH0gZWxzZSB7XG4gICAgQ19hbmdsZSA9IHRoaXMuSEFMRl9QSTsgLy8gOTAgZGVncmVlc1xuICB9XG5cbiAgcmV0dXJuIENfYW5nbGU7XG59O1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGNoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiB0d28gbGluZSBzZWdtZW50cyAob25lIHdpdGggcG9pbnRcbiAqIHAxIGFuZCBwMiwgdGhlIG90aGVyIHdpdGggcG9pbnQgcDMgYW5kIHA0KSBpbnRlcnNlY3QgYXQgYSBwb2ludCBvdGhlclxuICogdGhhbiB0aGVzZSBwb2ludHMuXG4gKi9cbklHZW9tZXRyeS5kb0ludGVyc2VjdCA9IGZ1bmN0aW9uIChwMSwgcDIsIHAzLCBwNCkge1xuICB2YXIgYSA9IHAxLng7XG4gIHZhciBiID0gcDEueTtcbiAgdmFyIGMgPSBwMi54O1xuICB2YXIgZCA9IHAyLnk7XG4gIHZhciBwID0gcDMueDtcbiAgdmFyIHEgPSBwMy55O1xuICB2YXIgciA9IHA0Lng7XG4gIHZhciBzID0gcDQueTtcbiAgdmFyIGRldCA9IChjIC0gYSkgKiAocyAtIHEpIC0gKHIgLSBwKSAqIChkIC0gYik7XG5cbiAgaWYgKGRldCA9PT0gMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbGFtYmRhID0gKChzIC0gcSkgKiAociAtIGEpICsgKHAgLSByKSAqIChzIC0gYikpIC8gZGV0O1xuICAgIHZhciBnYW1tYSA9ICgoYiAtIGQpICogKHIgLSBhKSArIChjIC0gYSkgKiAocyAtIGIpKSAvIGRldDtcbiAgICByZXR1cm4gMCA8IGxhbWJkYSAmJiBsYW1iZGEgPCAxICYmIDAgPCBnYW1tYSAmJiBnYW1tYSA8IDE7XG4gIH1cbn07XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBTZWN0aW9uOiBDbGFzcyBDb25zdGFudHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vKipcbiAqIFNvbWUgdXNlZnVsIHByZS1jYWxjdWxhdGVkIGNvbnN0YW50c1xuICovXG5JR2VvbWV0cnkuSEFMRl9QSSA9IDAuNSAqIE1hdGguUEk7XG5JR2VvbWV0cnkuT05FX0FORF9IQUxGX1BJID0gMS41ICogTWF0aC5QSTtcbklHZW9tZXRyeS5UV09fUEkgPSAyLjAgKiBNYXRoLlBJO1xuSUdlb21ldHJ5LlRIUkVFX1BJID0gMy4wICogTWF0aC5QSTtcblxubW9kdWxlLmV4cG9ydHMgPSBJR2VvbWV0cnk7XG5cbi8qKiovIH0pLFxuLyogOSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5mdW5jdGlvbiBJTWF0aCgpIHt9XG5cbi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyB0aGUgc2lnbiBvZiB0aGUgaW5wdXQgdmFsdWUuXG4gKi9cbklNYXRoLnNpZ24gPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgaWYgKHZhbHVlID4gMCkge1xuICAgIHJldHVybiAxO1xuICB9IGVsc2UgaWYgKHZhbHVlIDwgMCkge1xuICAgIHJldHVybiAtMTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gMDtcbiAgfVxufTtcblxuSU1hdGguZmxvb3IgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlIDwgMCA/IE1hdGguY2VpbCh2YWx1ZSkgOiBNYXRoLmZsb29yKHZhbHVlKTtcbn07XG5cbklNYXRoLmNlaWwgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlIDwgMCA/IE1hdGguZmxvb3IodmFsdWUpIDogTWF0aC5jZWlsKHZhbHVlKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gSU1hdGg7XG5cbi8qKiovIH0pLFxuLyogMTAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuZnVuY3Rpb24gSW50ZWdlcigpIHt9XG5cbkludGVnZXIuTUFYX1ZBTFVFID0gMjE0NzQ4MzY0NztcbkludGVnZXIuTUlOX1ZBTFVFID0gLTIxNDc0ODM2NDg7XG5cbm1vZHVsZS5leHBvcnRzID0gSW50ZWdlcjtcblxuLyoqKi8gfSksXG4vKiAxMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgbm9kZUZyb20gPSBmdW5jdGlvbiBub2RlRnJvbSh2YWx1ZSkge1xuICByZXR1cm4geyB2YWx1ZTogdmFsdWUsIG5leHQ6IG51bGwsIHByZXY6IG51bGwgfTtcbn07XG5cbnZhciBhZGQgPSBmdW5jdGlvbiBhZGQocHJldiwgbm9kZSwgbmV4dCwgbGlzdCkge1xuICBpZiAocHJldiAhPT0gbnVsbCkge1xuICAgIHByZXYubmV4dCA9IG5vZGU7XG4gIH0gZWxzZSB7XG4gICAgbGlzdC5oZWFkID0gbm9kZTtcbiAgfVxuXG4gIGlmIChuZXh0ICE9PSBudWxsKSB7XG4gICAgbmV4dC5wcmV2ID0gbm9kZTtcbiAgfSBlbHNlIHtcbiAgICBsaXN0LnRhaWwgPSBub2RlO1xuICB9XG5cbiAgbm9kZS5wcmV2ID0gcHJldjtcbiAgbm9kZS5uZXh0ID0gbmV4dDtcblxuICBsaXN0Lmxlbmd0aCsrO1xuXG4gIHJldHVybiBub2RlO1xufTtcblxudmFyIF9yZW1vdmUgPSBmdW5jdGlvbiBfcmVtb3ZlKG5vZGUsIGxpc3QpIHtcbiAgdmFyIHByZXYgPSBub2RlLnByZXYsXG4gICAgICBuZXh0ID0gbm9kZS5uZXh0O1xuXG5cbiAgaWYgKHByZXYgIT09IG51bGwpIHtcbiAgICBwcmV2Lm5leHQgPSBuZXh0O1xuICB9IGVsc2Uge1xuICAgIGxpc3QuaGVhZCA9IG5leHQ7XG4gIH1cblxuICBpZiAobmV4dCAhPT0gbnVsbCkge1xuICAgIG5leHQucHJldiA9IHByZXY7XG4gIH0gZWxzZSB7XG4gICAgbGlzdC50YWlsID0gcHJldjtcbiAgfVxuXG4gIG5vZGUucHJldiA9IG5vZGUubmV4dCA9IG51bGw7XG5cbiAgbGlzdC5sZW5ndGgtLTtcblxuICByZXR1cm4gbm9kZTtcbn07XG5cbnZhciBMaW5rZWRMaXN0ID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBMaW5rZWRMaXN0KHZhbHMpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIExpbmtlZExpc3QpO1xuXG4gICAgdGhpcy5sZW5ndGggPSAwO1xuICAgIHRoaXMuaGVhZCA9IG51bGw7XG4gICAgdGhpcy50YWlsID0gbnVsbDtcblxuICAgIGlmICh2YWxzICE9IG51bGwpIHtcbiAgICAgIHZhbHMuZm9yRWFjaChmdW5jdGlvbiAodikge1xuICAgICAgICByZXR1cm4gX3RoaXMucHVzaCh2KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhMaW5rZWRMaXN0LCBbe1xuICAgIGtleTogXCJzaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNpemUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5sZW5ndGg7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImluc2VydEJlZm9yZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbnNlcnRCZWZvcmUodmFsLCBvdGhlck5vZGUpIHtcbiAgICAgIHJldHVybiBhZGQob3RoZXJOb2RlLnByZXYsIG5vZGVGcm9tKHZhbCksIG90aGVyTm9kZSwgdGhpcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImluc2VydEFmdGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluc2VydEFmdGVyKHZhbCwgb3RoZXJOb2RlKSB7XG4gICAgICByZXR1cm4gYWRkKG90aGVyTm9kZSwgbm9kZUZyb20odmFsKSwgb3RoZXJOb2RlLm5leHQsIHRoaXMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpbnNlcnROb2RlQmVmb3JlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluc2VydE5vZGVCZWZvcmUobmV3Tm9kZSwgb3RoZXJOb2RlKSB7XG4gICAgICByZXR1cm4gYWRkKG90aGVyTm9kZS5wcmV2LCBuZXdOb2RlLCBvdGhlck5vZGUsIHRoaXMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpbnNlcnROb2RlQWZ0ZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5zZXJ0Tm9kZUFmdGVyKG5ld05vZGUsIG90aGVyTm9kZSkge1xuICAgICAgcmV0dXJuIGFkZChvdGhlck5vZGUsIG5ld05vZGUsIG90aGVyTm9kZS5uZXh0LCB0aGlzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicHVzaFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwdXNoKHZhbCkge1xuICAgICAgcmV0dXJuIGFkZCh0aGlzLnRhaWwsIG5vZGVGcm9tKHZhbCksIG51bGwsIHRoaXMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ1bnNoaWZ0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVuc2hpZnQodmFsKSB7XG4gICAgICByZXR1cm4gYWRkKG51bGwsIG5vZGVGcm9tKHZhbCksIHRoaXMuaGVhZCwgdGhpcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbW92ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmUobm9kZSkge1xuICAgICAgcmV0dXJuIF9yZW1vdmUobm9kZSwgdGhpcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInBvcFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwb3AoKSB7XG4gICAgICByZXR1cm4gX3JlbW92ZSh0aGlzLnRhaWwsIHRoaXMpLnZhbHVlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwb3BOb2RlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBvcE5vZGUoKSB7XG4gICAgICByZXR1cm4gX3JlbW92ZSh0aGlzLnRhaWwsIHRoaXMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzaGlmdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzaGlmdCgpIHtcbiAgICAgIHJldHVybiBfcmVtb3ZlKHRoaXMuaGVhZCwgdGhpcykudmFsdWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNoaWZ0Tm9kZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzaGlmdE5vZGUoKSB7XG4gICAgICByZXR1cm4gX3JlbW92ZSh0aGlzLmhlYWQsIHRoaXMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRfb2JqZWN0X2F0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldF9vYmplY3RfYXQoaW5kZXgpIHtcbiAgICAgIGlmIChpbmRleCA8PSB0aGlzLmxlbmd0aCgpKSB7XG4gICAgICAgIHZhciBpID0gMTtcbiAgICAgICAgdmFyIGN1cnJlbnQgPSB0aGlzLmhlYWQ7XG4gICAgICAgIHdoaWxlIChpIDwgaW5kZXgpIHtcbiAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5uZXh0O1xuICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3VycmVudC52YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0X29iamVjdF9hdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRfb2JqZWN0X2F0KGluZGV4LCB2YWx1ZSkge1xuICAgICAgaWYgKGluZGV4IDw9IHRoaXMubGVuZ3RoKCkpIHtcbiAgICAgICAgdmFyIGkgPSAxO1xuICAgICAgICB2YXIgY3VycmVudCA9IHRoaXMuaGVhZDtcbiAgICAgICAgd2hpbGUgKGkgPCBpbmRleCkge1xuICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5leHQ7XG4gICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnQudmFsdWUgPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gTGlua2VkTGlzdDtcbn0oKTtcblxubW9kdWxlLmV4cG9ydHMgPSBMaW5rZWRMaXN0O1xuXG4vKioqLyB9KSxcbi8qIDEyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbi8qXHJcbiAqVGhpcyBjbGFzcyBpcyB0aGUgamF2YXNjcmlwdCBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgUG9pbnQuamF2YSBjbGFzcyBpbiBqZGtcclxuICovXG5mdW5jdGlvbiBQb2ludCh4LCB5LCBwKSB7XG4gIHRoaXMueCA9IG51bGw7XG4gIHRoaXMueSA9IG51bGw7XG4gIGlmICh4ID09IG51bGwgJiYgeSA9PSBudWxsICYmIHAgPT0gbnVsbCkge1xuICAgIHRoaXMueCA9IDA7XG4gICAgdGhpcy55ID0gMDtcbiAgfSBlbHNlIGlmICh0eXBlb2YgeCA9PSAnbnVtYmVyJyAmJiB0eXBlb2YgeSA9PSAnbnVtYmVyJyAmJiBwID09IG51bGwpIHtcbiAgICB0aGlzLnggPSB4O1xuICAgIHRoaXMueSA9IHk7XG4gIH0gZWxzZSBpZiAoeC5jb25zdHJ1Y3Rvci5uYW1lID09ICdQb2ludCcgJiYgeSA9PSBudWxsICYmIHAgPT0gbnVsbCkge1xuICAgIHAgPSB4O1xuICAgIHRoaXMueCA9IHAueDtcbiAgICB0aGlzLnkgPSBwLnk7XG4gIH1cbn1cblxuUG9pbnQucHJvdG90eXBlLmdldFggPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLng7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuZ2V0WSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMueTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5nZXRMb2NhdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLngsIHRoaXMueSk7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuc2V0TG9jYXRpb24gPSBmdW5jdGlvbiAoeCwgeSwgcCkge1xuICBpZiAoeC5jb25zdHJ1Y3Rvci5uYW1lID09ICdQb2ludCcgJiYgeSA9PSBudWxsICYmIHAgPT0gbnVsbCkge1xuICAgIHAgPSB4O1xuICAgIHRoaXMuc2V0TG9jYXRpb24ocC54LCBwLnkpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiB4ID09ICdudW1iZXInICYmIHR5cGVvZiB5ID09ICdudW1iZXInICYmIHAgPT0gbnVsbCkge1xuICAgIC8vaWYgYm90aCBwYXJhbWV0ZXJzIGFyZSBpbnRlZ2VyIGp1c3QgbW92ZSAoeCx5KSBsb2NhdGlvblxuICAgIGlmIChwYXJzZUludCh4KSA9PSB4ICYmIHBhcnNlSW50KHkpID09IHkpIHtcbiAgICAgIHRoaXMubW92ZSh4LCB5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy54ID0gTWF0aC5mbG9vcih4ICsgMC41KTtcbiAgICAgIHRoaXMueSA9IE1hdGguZmxvb3IoeSArIDAuNSk7XG4gICAgfVxuICB9XG59O1xuXG5Qb2ludC5wcm90b3R5cGUubW92ZSA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gIHRoaXMueCA9IHg7XG4gIHRoaXMueSA9IHk7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUudHJhbnNsYXRlID0gZnVuY3Rpb24gKGR4LCBkeSkge1xuICB0aGlzLnggKz0gZHg7XG4gIHRoaXMueSArPSBkeTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiAob2JqKSB7XG4gIGlmIChvYmouY29uc3RydWN0b3IubmFtZSA9PSBcIlBvaW50XCIpIHtcbiAgICB2YXIgcHQgPSBvYmo7XG4gICAgcmV0dXJuIHRoaXMueCA9PSBwdC54ICYmIHRoaXMueSA9PSBwdC55O1xuICB9XG4gIHJldHVybiB0aGlzID09IG9iajtcbn07XG5cblBvaW50LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIG5ldyBQb2ludCgpLmNvbnN0cnVjdG9yLm5hbWUgKyBcIlt4PVwiICsgdGhpcy54ICsgXCIseT1cIiArIHRoaXMueSArIFwiXVwiO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBQb2ludDtcblxuLyoqKi8gfSksXG4vKiAxMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5mdW5jdGlvbiBSZWN0YW5nbGVEKHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcbiAgdGhpcy54ID0gMDtcbiAgdGhpcy55ID0gMDtcbiAgdGhpcy53aWR0aCA9IDA7XG4gIHRoaXMuaGVpZ2h0ID0gMDtcblxuICBpZiAoeCAhPSBudWxsICYmIHkgIT0gbnVsbCAmJiB3aWR0aCAhPSBudWxsICYmIGhlaWdodCAhPSBudWxsKSB7XG4gICAgdGhpcy54ID0geDtcbiAgICB0aGlzLnkgPSB5O1xuICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgfVxufVxuXG5SZWN0YW5nbGVELnByb3RvdHlwZS5nZXRYID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy54O1xufTtcblxuUmVjdGFuZ2xlRC5wcm90b3R5cGUuc2V0WCA9IGZ1bmN0aW9uICh4KSB7XG4gIHRoaXMueCA9IHg7XG59O1xuXG5SZWN0YW5nbGVELnByb3RvdHlwZS5nZXRZID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy55O1xufTtcblxuUmVjdGFuZ2xlRC5wcm90b3R5cGUuc2V0WSA9IGZ1bmN0aW9uICh5KSB7XG4gIHRoaXMueSA9IHk7XG59O1xuXG5SZWN0YW5nbGVELnByb3RvdHlwZS5nZXRXaWR0aCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMud2lkdGg7XG59O1xuXG5SZWN0YW5nbGVELnByb3RvdHlwZS5zZXRXaWR0aCA9IGZ1bmN0aW9uICh3aWR0aCkge1xuICB0aGlzLndpZHRoID0gd2lkdGg7XG59O1xuXG5SZWN0YW5nbGVELnByb3RvdHlwZS5nZXRIZWlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmhlaWdodDtcbn07XG5cblJlY3RhbmdsZUQucHJvdG90eXBlLnNldEhlaWdodCA9IGZ1bmN0aW9uIChoZWlnaHQpIHtcbiAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG59O1xuXG5SZWN0YW5nbGVELnByb3RvdHlwZS5nZXRSaWdodCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMueCArIHRoaXMud2lkdGg7XG59O1xuXG5SZWN0YW5nbGVELnByb3RvdHlwZS5nZXRCb3R0b20gPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnkgKyB0aGlzLmhlaWdodDtcbn07XG5cblJlY3RhbmdsZUQucHJvdG90eXBlLmludGVyc2VjdHMgPSBmdW5jdGlvbiAoYSkge1xuICBpZiAodGhpcy5nZXRSaWdodCgpIDwgYS54KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKHRoaXMuZ2V0Qm90dG9tKCkgPCBhLnkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoYS5nZXRSaWdodCgpIDwgdGhpcy54KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKGEuZ2V0Qm90dG9tKCkgPCB0aGlzLnkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cblJlY3RhbmdsZUQucHJvdG90eXBlLmdldENlbnRlclggPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnggKyB0aGlzLndpZHRoIC8gMjtcbn07XG5cblJlY3RhbmdsZUQucHJvdG90eXBlLmdldE1pblggPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmdldFgoKTtcbn07XG5cblJlY3RhbmdsZUQucHJvdG90eXBlLmdldE1heFggPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmdldFgoKSArIHRoaXMud2lkdGg7XG59O1xuXG5SZWN0YW5nbGVELnByb3RvdHlwZS5nZXRDZW50ZXJZID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy55ICsgdGhpcy5oZWlnaHQgLyAyO1xufTtcblxuUmVjdGFuZ2xlRC5wcm90b3R5cGUuZ2V0TWluWSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuZ2V0WSgpO1xufTtcblxuUmVjdGFuZ2xlRC5wcm90b3R5cGUuZ2V0TWF4WSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuZ2V0WSgpICsgdGhpcy5oZWlnaHQ7XG59O1xuXG5SZWN0YW5nbGVELnByb3RvdHlwZS5nZXRXaWR0aEhhbGYgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLndpZHRoIC8gMjtcbn07XG5cblJlY3RhbmdsZUQucHJvdG90eXBlLmdldEhlaWdodEhhbGYgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmhlaWdodCAvIDI7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlY3RhbmdsZUQ7XG5cbi8qKiovIH0pLFxuLyogMTQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG5mdW5jdGlvbiBVbmlxdWVJREdlbmVyZXRvcigpIHt9XG5cblVuaXF1ZUlER2VuZXJldG9yLmxhc3RJRCA9IDA7XG5cblVuaXF1ZUlER2VuZXJldG9yLmNyZWF0ZUlEID0gZnVuY3Rpb24gKG9iaikge1xuICBpZiAoVW5pcXVlSURHZW5lcmV0b3IuaXNQcmltaXRpdmUob2JqKSkge1xuICAgIHJldHVybiBvYmo7XG4gIH1cbiAgaWYgKG9iai51bmlxdWVJRCAhPSBudWxsKSB7XG4gICAgcmV0dXJuIG9iai51bmlxdWVJRDtcbiAgfVxuICBvYmoudW5pcXVlSUQgPSBVbmlxdWVJREdlbmVyZXRvci5nZXRTdHJpbmcoKTtcbiAgVW5pcXVlSURHZW5lcmV0b3IubGFzdElEKys7XG4gIHJldHVybiBvYmoudW5pcXVlSUQ7XG59O1xuXG5VbmlxdWVJREdlbmVyZXRvci5nZXRTdHJpbmcgPSBmdW5jdGlvbiAoaWQpIHtcbiAgaWYgKGlkID09IG51bGwpIGlkID0gVW5pcXVlSURHZW5lcmV0b3IubGFzdElEO1xuICByZXR1cm4gXCJPYmplY3QjXCIgKyBpZCArIFwiXCI7XG59O1xuXG5VbmlxdWVJREdlbmVyZXRvci5pc1ByaW1pdGl2ZSA9IGZ1bmN0aW9uIChhcmcpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgYXJnID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2YoYXJnKTtcbiAgcmV0dXJuIGFyZyA9PSBudWxsIHx8IHR5cGUgIT0gXCJvYmplY3RcIiAmJiB0eXBlICE9IFwiZnVuY3Rpb25cIjtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gVW5pcXVlSURHZW5lcmV0b3I7XG5cbi8qKiovIH0pLFxuLyogMTUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gQXJyYXkoYXJyLmxlbmd0aCk7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfSBlbHNlIHsgcmV0dXJuIEFycmF5LmZyb20oYXJyKTsgfSB9XG5cbnZhciBMYXlvdXRDb25zdGFudHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xudmFyIExHcmFwaE1hbmFnZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xudmFyIExOb2RlID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcbnZhciBMRWRnZSA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG52YXIgTEdyYXBoID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbnZhciBQb2ludEQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xudmFyIFRyYW5zZm9ybSA9IF9fd2VicGFja19yZXF1aXJlX18oMTcpO1xudmFyIEVtaXR0ZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI3KTtcblxuZnVuY3Rpb24gTGF5b3V0KGlzUmVtb3RlVXNlKSB7XG4gIEVtaXR0ZXIuY2FsbCh0aGlzKTtcblxuICAvL0xheW91dCBRdWFsaXR5OiAwOmRyYWZ0LCAxOmRlZmF1bHQsIDI6cHJvb2ZcbiAgdGhpcy5sYXlvdXRRdWFsaXR5ID0gTGF5b3V0Q29uc3RhbnRzLlFVQUxJVFk7XG4gIC8vV2hldGhlciBsYXlvdXQgc2hvdWxkIGNyZWF0ZSBiZW5kcG9pbnRzIGFzIG5lZWRlZCBvciBub3RcbiAgdGhpcy5jcmVhdGVCZW5kc0FzTmVlZGVkID0gTGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfQ1JFQVRFX0JFTkRTX0FTX05FRURFRDtcbiAgLy9XaGV0aGVyIGxheW91dCBzaG91bGQgYmUgaW5jcmVtZW50YWwgb3Igbm90XG4gIHRoaXMuaW5jcmVtZW50YWwgPSBMYXlvdXRDb25zdGFudHMuREVGQVVMVF9JTkNSRU1FTlRBTDtcbiAgLy9XaGV0aGVyIHdlIGFuaW1hdGUgZnJvbSBiZWZvcmUgdG8gYWZ0ZXIgbGF5b3V0IG5vZGUgcG9zaXRpb25zXG4gIHRoaXMuYW5pbWF0aW9uT25MYXlvdXQgPSBMYXlvdXRDb25zdGFudHMuREVGQVVMVF9BTklNQVRJT05fT05fTEFZT1VUO1xuICAvL1doZXRoZXIgd2UgYW5pbWF0ZSB0aGUgbGF5b3V0IHByb2Nlc3Mgb3Igbm90XG4gIHRoaXMuYW5pbWF0aW9uRHVyaW5nTGF5b3V0ID0gTGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfQU5JTUFUSU9OX0RVUklOR19MQVlPVVQ7XG4gIC8vTnVtYmVyIGl0ZXJhdGlvbnMgdGhhdCBzaG91bGQgYmUgZG9uZSBiZXR3ZWVuIHR3byBzdWNjZXNzaXZlIGFuaW1hdGlvbnNcbiAgdGhpcy5hbmltYXRpb25QZXJpb2QgPSBMYXlvdXRDb25zdGFudHMuREVGQVVMVF9BTklNQVRJT05fUEVSSU9EO1xuICAvKipcclxuICAgKiBXaGV0aGVyIG9yIG5vdCBsZWFmIG5vZGVzIChub24tY29tcG91bmQgbm9kZXMpIGFyZSBvZiB1bmlmb3JtIHNpemVzLiBXaGVuXHJcbiAgICogdGhleSBhcmUsIGJvdGggc3ByaW5nIGFuZCByZXB1bHNpb24gZm9yY2VzIGJldHdlZW4gdHdvIGxlYWYgbm9kZXMgY2FuIGJlXHJcbiAgICogY2FsY3VsYXRlZCB3aXRob3V0IHRoZSBleHBlbnNpdmUgY2xpcHBpbmcgcG9pbnQgY2FsY3VsYXRpb25zLCByZXN1bHRpbmdcclxuICAgKiBpbiBtYWpvciBzcGVlZC11cC5cclxuICAgKi9cbiAgdGhpcy51bmlmb3JtTGVhZk5vZGVTaXplcyA9IExheW91dENvbnN0YW50cy5ERUZBVUxUX1VOSUZPUk1fTEVBRl9OT0RFX1NJWkVTO1xuICAvKipcclxuICAgKiBUaGlzIGlzIHVzZWQgZm9yIGNyZWF0aW9uIG9mIGJlbmRwb2ludHMgYnkgdXNpbmcgZHVtbXkgbm9kZXMgYW5kIGVkZ2VzLlxyXG4gICAqIE1hcHMgYW4gTEVkZ2UgdG8gaXRzIGR1bW15IGJlbmRwb2ludCBwYXRoLlxyXG4gICAqL1xuICB0aGlzLmVkZ2VUb0R1bW15Tm9kZXMgPSBuZXcgTWFwKCk7XG4gIHRoaXMuZ3JhcGhNYW5hZ2VyID0gbmV3IExHcmFwaE1hbmFnZXIodGhpcyk7XG4gIHRoaXMuaXNMYXlvdXRGaW5pc2hlZCA9IGZhbHNlO1xuICB0aGlzLmlzU3ViTGF5b3V0ID0gZmFsc2U7XG4gIHRoaXMuaXNSZW1vdGVVc2UgPSBmYWxzZTtcblxuICBpZiAoaXNSZW1vdGVVc2UgIT0gbnVsbCkge1xuICAgIHRoaXMuaXNSZW1vdGVVc2UgPSBpc1JlbW90ZVVzZTtcbiAgfVxufVxuXG5MYXlvdXQuUkFORE9NX1NFRUQgPSAxO1xuXG5MYXlvdXQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFbWl0dGVyLnByb3RvdHlwZSk7XG5cbkxheW91dC5wcm90b3R5cGUuZ2V0R3JhcGhNYW5hZ2VyID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5ncmFwaE1hbmFnZXI7XG59O1xuXG5MYXlvdXQucHJvdG90eXBlLmdldEFsbE5vZGVzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5ncmFwaE1hbmFnZXIuZ2V0QWxsTm9kZXMoKTtcbn07XG5cbkxheW91dC5wcm90b3R5cGUuZ2V0QWxsRWRnZXMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmdyYXBoTWFuYWdlci5nZXRBbGxFZGdlcygpO1xufTtcblxuTGF5b3V0LnByb3RvdHlwZS5nZXRBbGxOb2Rlc1RvQXBwbHlHcmF2aXRhdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuZ3JhcGhNYW5hZ2VyLmdldEFsbE5vZGVzVG9BcHBseUdyYXZpdGF0aW9uKCk7XG59O1xuXG5MYXlvdXQucHJvdG90eXBlLm5ld0dyYXBoTWFuYWdlciA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGdtID0gbmV3IExHcmFwaE1hbmFnZXIodGhpcyk7XG4gIHRoaXMuZ3JhcGhNYW5hZ2VyID0gZ207XG4gIHJldHVybiBnbTtcbn07XG5cbkxheW91dC5wcm90b3R5cGUubmV3R3JhcGggPSBmdW5jdGlvbiAodkdyYXBoKSB7XG4gIHJldHVybiBuZXcgTEdyYXBoKG51bGwsIHRoaXMuZ3JhcGhNYW5hZ2VyLCB2R3JhcGgpO1xufTtcblxuTGF5b3V0LnByb3RvdHlwZS5uZXdOb2RlID0gZnVuY3Rpb24gKHZOb2RlKSB7XG4gIHJldHVybiBuZXcgTE5vZGUodGhpcy5ncmFwaE1hbmFnZXIsIHZOb2RlKTtcbn07XG5cbkxheW91dC5wcm90b3R5cGUubmV3RWRnZSA9IGZ1bmN0aW9uICh2RWRnZSkge1xuICByZXR1cm4gbmV3IExFZGdlKG51bGwsIG51bGwsIHZFZGdlKTtcbn07XG5cbkxheW91dC5wcm90b3R5cGUuY2hlY2tMYXlvdXRTdWNjZXNzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5ncmFwaE1hbmFnZXIuZ2V0Um9vdCgpID09IG51bGwgfHwgdGhpcy5ncmFwaE1hbmFnZXIuZ2V0Um9vdCgpLmdldE5vZGVzKCkubGVuZ3RoID09IDAgfHwgdGhpcy5ncmFwaE1hbmFnZXIuaW5jbHVkZXNJbnZhbGlkRWRnZSgpO1xufTtcblxuTGF5b3V0LnByb3RvdHlwZS5ydW5MYXlvdXQgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuaXNMYXlvdXRGaW5pc2hlZCA9IGZhbHNlO1xuXG4gIGlmICh0aGlzLnRpbGluZ1ByZUxheW91dCkge1xuICAgIHRoaXMudGlsaW5nUHJlTGF5b3V0KCk7XG4gIH1cblxuICB0aGlzLmluaXRQYXJhbWV0ZXJzKCk7XG4gIHZhciBpc0xheW91dFN1Y2Nlc3NmdWxsO1xuXG4gIGlmICh0aGlzLmNoZWNrTGF5b3V0U3VjY2VzcygpKSB7XG4gICAgaXNMYXlvdXRTdWNjZXNzZnVsbCA9IGZhbHNlO1xuICB9IGVsc2Uge1xuICAgIGlzTGF5b3V0U3VjY2Vzc2Z1bGwgPSB0aGlzLmxheW91dCgpO1xuICB9XG5cbiAgaWYgKExheW91dENvbnN0YW50cy5BTklNQVRFID09PSAnZHVyaW5nJykge1xuICAgIC8vIElmIHRoaXMgaXMgYSAnZHVyaW5nJyBsYXlvdXQgYW5pbWF0aW9uLiBMYXlvdXQgaXMgbm90IGZpbmlzaGVkIHlldC4gXG4gICAgLy8gV2UgbmVlZCB0byBwZXJmb3JtIHRoZXNlIGluIGluZGV4LmpzIHdoZW4gbGF5b3V0IGlzIHJlYWxseSBmaW5pc2hlZC5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoaXNMYXlvdXRTdWNjZXNzZnVsbCkge1xuICAgIGlmICghdGhpcy5pc1N1YkxheW91dCkge1xuICAgICAgdGhpcy5kb1Bvc3RMYXlvdXQoKTtcbiAgICB9XG4gIH1cblxuICBpZiAodGhpcy50aWxpbmdQb3N0TGF5b3V0KSB7XG4gICAgdGhpcy50aWxpbmdQb3N0TGF5b3V0KCk7XG4gIH1cblxuICB0aGlzLmlzTGF5b3V0RmluaXNoZWQgPSB0cnVlO1xuXG4gIHJldHVybiBpc0xheW91dFN1Y2Nlc3NmdWxsO1xufTtcblxuLyoqXHJcbiAqIFRoaXMgbWV0aG9kIHBlcmZvcm1zIHRoZSBvcGVyYXRpb25zIHJlcXVpcmVkIGFmdGVyIGxheW91dC5cclxuICovXG5MYXlvdXQucHJvdG90eXBlLmRvUG9zdExheW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgLy9hc3NlcnQgIWlzU3ViTGF5b3V0IDogXCJTaG91bGQgbm90IGJlIGNhbGxlZCBvbiBzdWItbGF5b3V0IVwiO1xuICAvLyBQcm9wYWdhdGUgZ2VvbWV0cmljIGNoYW5nZXMgdG8gdi1sZXZlbCBvYmplY3RzXG4gIGlmICghdGhpcy5pbmNyZW1lbnRhbCkge1xuICAgIHRoaXMudHJhbnNmb3JtKCk7XG4gIH1cbiAgdGhpcy51cGRhdGUoKTtcbn07XG5cbi8qKlxyXG4gKiBUaGlzIG1ldGhvZCB1cGRhdGVzIHRoZSBnZW9tZXRyeSBvZiB0aGUgdGFyZ2V0IGdyYXBoIGFjY29yZGluZyB0b1xyXG4gKiBjYWxjdWxhdGVkIGxheW91dC5cclxuICovXG5MYXlvdXQucHJvdG90eXBlLnVwZGF0ZTIgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIHVwZGF0ZSBiZW5kIHBvaW50c1xuICBpZiAodGhpcy5jcmVhdGVCZW5kc0FzTmVlZGVkKSB7XG4gICAgdGhpcy5jcmVhdGVCZW5kcG9pbnRzRnJvbUR1bW15Tm9kZXMoKTtcblxuICAgIC8vIHJlc2V0IGFsbCBlZGdlcywgc2luY2UgdGhlIHRvcG9sb2d5IGhhcyBjaGFuZ2VkXG4gICAgdGhpcy5ncmFwaE1hbmFnZXIucmVzZXRBbGxFZGdlcygpO1xuICB9XG5cbiAgLy8gcGVyZm9ybSBlZGdlLCBub2RlIGFuZCByb290IHVwZGF0ZXMgaWYgbGF5b3V0IGlzIG5vdCBjYWxsZWRcbiAgLy8gcmVtb3RlbHlcbiAgaWYgKCF0aGlzLmlzUmVtb3RlVXNlKSB7XG4gICAgLy8gdXBkYXRlIGFsbCBlZGdlc1xuICAgIHZhciBlZGdlO1xuICAgIHZhciBhbGxFZGdlcyA9IHRoaXMuZ3JhcGhNYW5hZ2VyLmdldEFsbEVkZ2VzKCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbGxFZGdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgZWRnZSA9IGFsbEVkZ2VzW2ldO1xuICAgICAgLy8gICAgICB0aGlzLnVwZGF0ZShlZGdlKTtcbiAgICB9XG5cbiAgICAvLyByZWN1cnNpdmVseSB1cGRhdGUgbm9kZXNcbiAgICB2YXIgbm9kZTtcbiAgICB2YXIgbm9kZXMgPSB0aGlzLmdyYXBoTWFuYWdlci5nZXRSb290KCkuZ2V0Tm9kZXMoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBub2RlID0gbm9kZXNbaV07XG4gICAgICAvLyAgICAgIHRoaXMudXBkYXRlKG5vZGUpO1xuICAgIH1cblxuICAgIC8vIHVwZGF0ZSByb290IGdyYXBoXG4gICAgdGhpcy51cGRhdGUodGhpcy5ncmFwaE1hbmFnZXIuZ2V0Um9vdCgpKTtcbiAgfVxufTtcblxuTGF5b3V0LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAob2JqKSB7XG4gIGlmIChvYmogPT0gbnVsbCkge1xuICAgIHRoaXMudXBkYXRlMigpO1xuICB9IGVsc2UgaWYgKG9iaiBpbnN0YW5jZW9mIExOb2RlKSB7XG4gICAgdmFyIG5vZGUgPSBvYmo7XG4gICAgaWYgKG5vZGUuZ2V0Q2hpbGQoKSAhPSBudWxsKSB7XG4gICAgICAvLyBzaW5jZSBub2RlIGlzIGNvbXBvdW5kLCByZWN1cnNpdmVseSB1cGRhdGUgY2hpbGQgbm9kZXNcbiAgICAgIHZhciBub2RlcyA9IG5vZGUuZ2V0Q2hpbGQoKS5nZXROb2RlcygpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB1cGRhdGUobm9kZXNbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGlmIHRoZSBsLWxldmVsIG5vZGUgaXMgYXNzb2NpYXRlZCB3aXRoIGEgdi1sZXZlbCBncmFwaCBvYmplY3QsXG4gICAgLy8gdGhlbiBpdCBpcyBhc3N1bWVkIHRoYXQgdGhlIHYtbGV2ZWwgbm9kZSBpbXBsZW1lbnRzIHRoZVxuICAgIC8vIGludGVyZmFjZSBVcGRhdGFibGUuXG4gICAgaWYgKG5vZGUudkdyYXBoT2JqZWN0ICE9IG51bGwpIHtcbiAgICAgIC8vIGNhc3QgdG8gVXBkYXRhYmxlIHdpdGhvdXQgYW55IHR5cGUgY2hlY2tcbiAgICAgIHZhciB2Tm9kZSA9IG5vZGUudkdyYXBoT2JqZWN0O1xuXG4gICAgICAvLyBjYWxsIHRoZSB1cGRhdGUgbWV0aG9kIG9mIHRoZSBpbnRlcmZhY2VcbiAgICAgIHZOb2RlLnVwZGF0ZShub2RlKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAob2JqIGluc3RhbmNlb2YgTEVkZ2UpIHtcbiAgICB2YXIgZWRnZSA9IG9iajtcbiAgICAvLyBpZiB0aGUgbC1sZXZlbCBlZGdlIGlzIGFzc29jaWF0ZWQgd2l0aCBhIHYtbGV2ZWwgZ3JhcGggb2JqZWN0LFxuICAgIC8vIHRoZW4gaXQgaXMgYXNzdW1lZCB0aGF0IHRoZSB2LWxldmVsIGVkZ2UgaW1wbGVtZW50cyB0aGVcbiAgICAvLyBpbnRlcmZhY2UgVXBkYXRhYmxlLlxuXG4gICAgaWYgKGVkZ2UudkdyYXBoT2JqZWN0ICE9IG51bGwpIHtcbiAgICAgIC8vIGNhc3QgdG8gVXBkYXRhYmxlIHdpdGhvdXQgYW55IHR5cGUgY2hlY2tcbiAgICAgIHZhciB2RWRnZSA9IGVkZ2UudkdyYXBoT2JqZWN0O1xuXG4gICAgICAvLyBjYWxsIHRoZSB1cGRhdGUgbWV0aG9kIG9mIHRoZSBpbnRlcmZhY2VcbiAgICAgIHZFZGdlLnVwZGF0ZShlZGdlKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAob2JqIGluc3RhbmNlb2YgTEdyYXBoKSB7XG4gICAgdmFyIGdyYXBoID0gb2JqO1xuICAgIC8vIGlmIHRoZSBsLWxldmVsIGdyYXBoIGlzIGFzc29jaWF0ZWQgd2l0aCBhIHYtbGV2ZWwgZ3JhcGggb2JqZWN0LFxuICAgIC8vIHRoZW4gaXQgaXMgYXNzdW1lZCB0aGF0IHRoZSB2LWxldmVsIG9iamVjdCBpbXBsZW1lbnRzIHRoZVxuICAgIC8vIGludGVyZmFjZSBVcGRhdGFibGUuXG5cbiAgICBpZiAoZ3JhcGgudkdyYXBoT2JqZWN0ICE9IG51bGwpIHtcbiAgICAgIC8vIGNhc3QgdG8gVXBkYXRhYmxlIHdpdGhvdXQgYW55IHR5cGUgY2hlY2tcbiAgICAgIHZhciB2R3JhcGggPSBncmFwaC52R3JhcGhPYmplY3Q7XG5cbiAgICAgIC8vIGNhbGwgdGhlIHVwZGF0ZSBtZXRob2Qgb2YgdGhlIGludGVyZmFjZVxuICAgICAgdkdyYXBoLnVwZGF0ZShncmFwaCk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcclxuICogVGhpcyBtZXRob2QgaXMgdXNlZCB0byBzZXQgYWxsIGxheW91dCBwYXJhbWV0ZXJzIHRvIGRlZmF1bHQgdmFsdWVzXHJcbiAqIGRldGVybWluZWQgYXQgY29tcGlsZSB0aW1lLlxyXG4gKi9cbkxheW91dC5wcm90b3R5cGUuaW5pdFBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICghdGhpcy5pc1N1YkxheW91dCkge1xuICAgIHRoaXMubGF5b3V0UXVhbGl0eSA9IExheW91dENvbnN0YW50cy5RVUFMSVRZO1xuICAgIHRoaXMuYW5pbWF0aW9uRHVyaW5nTGF5b3V0ID0gTGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfQU5JTUFUSU9OX0RVUklOR19MQVlPVVQ7XG4gICAgdGhpcy5hbmltYXRpb25QZXJpb2QgPSBMYXlvdXRDb25zdGFudHMuREVGQVVMVF9BTklNQVRJT05fUEVSSU9EO1xuICAgIHRoaXMuYW5pbWF0aW9uT25MYXlvdXQgPSBMYXlvdXRDb25zdGFudHMuREVGQVVMVF9BTklNQVRJT05fT05fTEFZT1VUO1xuICAgIHRoaXMuaW5jcmVtZW50YWwgPSBMYXlvdXRDb25zdGFudHMuREVGQVVMVF9JTkNSRU1FTlRBTDtcbiAgICB0aGlzLmNyZWF0ZUJlbmRzQXNOZWVkZWQgPSBMYXlvdXRDb25zdGFudHMuREVGQVVMVF9DUkVBVEVfQkVORFNfQVNfTkVFREVEO1xuICAgIHRoaXMudW5pZm9ybUxlYWZOb2RlU2l6ZXMgPSBMYXlvdXRDb25zdGFudHMuREVGQVVMVF9VTklGT1JNX0xFQUZfTk9ERV9TSVpFUztcbiAgfVxuXG4gIGlmICh0aGlzLmFuaW1hdGlvbkR1cmluZ0xheW91dCkge1xuICAgIHRoaXMuYW5pbWF0aW9uT25MYXlvdXQgPSBmYWxzZTtcbiAgfVxufTtcblxuTGF5b3V0LnByb3RvdHlwZS50cmFuc2Zvcm0gPSBmdW5jdGlvbiAobmV3TGVmdFRvcCkge1xuICBpZiAobmV3TGVmdFRvcCA9PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzLnRyYW5zZm9ybShuZXcgUG9pbnREKDAsIDApKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBjcmVhdGUgYSB0cmFuc2Zvcm1hdGlvbiBvYmplY3QgKGZyb20gRWNsaXBzZSB0byBsYXlvdXQpLiBXaGVuIGFuXG4gICAgLy8gaW52ZXJzZSB0cmFuc2Zvcm0gaXMgYXBwbGllZCwgd2UgZ2V0IHVwcGVyLWxlZnQgY29vcmRpbmF0ZSBvZiB0aGVcbiAgICAvLyBkcmF3aW5nIG9yIHRoZSByb290IGdyYXBoIGF0IGdpdmVuIGlucHV0IGNvb3JkaW5hdGUgKHNvbWUgbWFyZ2luc1xuICAgIC8vIGFscmVhZHkgaW5jbHVkZWQgaW4gY2FsY3VsYXRpb24gb2YgbGVmdC10b3ApLlxuXG4gICAgdmFyIHRyYW5zID0gbmV3IFRyYW5zZm9ybSgpO1xuICAgIHZhciBsZWZ0VG9wID0gdGhpcy5ncmFwaE1hbmFnZXIuZ2V0Um9vdCgpLnVwZGF0ZUxlZnRUb3AoKTtcblxuICAgIGlmIChsZWZ0VG9wICE9IG51bGwpIHtcbiAgICAgIHRyYW5zLnNldFdvcmxkT3JnWChuZXdMZWZ0VG9wLngpO1xuICAgICAgdHJhbnMuc2V0V29ybGRPcmdZKG5ld0xlZnRUb3AueSk7XG5cbiAgICAgIHRyYW5zLnNldERldmljZU9yZ1gobGVmdFRvcC54KTtcbiAgICAgIHRyYW5zLnNldERldmljZU9yZ1kobGVmdFRvcC55KTtcblxuICAgICAgdmFyIG5vZGVzID0gdGhpcy5nZXRBbGxOb2RlcygpO1xuICAgICAgdmFyIG5vZGU7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICBub2RlLnRyYW5zZm9ybSh0cmFucyk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5MYXlvdXQucHJvdG90eXBlLnBvc2l0aW9uTm9kZXNSYW5kb21seSA9IGZ1bmN0aW9uIChncmFwaCkge1xuXG4gIGlmIChncmFwaCA9PSB1bmRlZmluZWQpIHtcbiAgICAvL2Fzc2VydCAhdGhpcy5pbmNyZW1lbnRhbDtcbiAgICB0aGlzLnBvc2l0aW9uTm9kZXNSYW5kb21seSh0aGlzLmdldEdyYXBoTWFuYWdlcigpLmdldFJvb3QoKSk7XG4gICAgdGhpcy5nZXRHcmFwaE1hbmFnZXIoKS5nZXRSb290KCkudXBkYXRlQm91bmRzKHRydWUpO1xuICB9IGVsc2Uge1xuICAgIHZhciBsTm9kZTtcbiAgICB2YXIgY2hpbGRHcmFwaDtcblxuICAgIHZhciBub2RlcyA9IGdyYXBoLmdldE5vZGVzKCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgbE5vZGUgPSBub2Rlc1tpXTtcbiAgICAgIGNoaWxkR3JhcGggPSBsTm9kZS5nZXRDaGlsZCgpO1xuXG4gICAgICBpZiAoY2hpbGRHcmFwaCA9PSBudWxsKSB7XG4gICAgICAgIGxOb2RlLnNjYXR0ZXIoKTtcbiAgICAgIH0gZWxzZSBpZiAoY2hpbGRHcmFwaC5nZXROb2RlcygpLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgIGxOb2RlLnNjYXR0ZXIoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucG9zaXRpb25Ob2Rlc1JhbmRvbWx5KGNoaWxkR3JhcGgpO1xuICAgICAgICBsTm9kZS51cGRhdGVCb3VuZHMoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8qKlxyXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIGEgbGlzdCBvZiB0cmVlcyB3aGVyZSBlYWNoIHRyZWUgaXMgcmVwcmVzZW50ZWQgYXMgYVxyXG4gKiBsaXN0IG9mIGwtbm9kZXMuIFRoZSBtZXRob2QgcmV0dXJucyBhIGxpc3Qgb2Ygc2l6ZSAwIHdoZW46XHJcbiAqIC0gVGhlIGdyYXBoIGlzIG5vdCBmbGF0IG9yXHJcbiAqIC0gT25lIG9mIHRoZSBjb21wb25lbnQocykgb2YgdGhlIGdyYXBoIGlzIG5vdCBhIHRyZWUuXHJcbiAqL1xuTGF5b3V0LnByb3RvdHlwZS5nZXRGbGF0Rm9yZXN0ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgZmxhdEZvcmVzdCA9IFtdO1xuICB2YXIgaXNGb3Jlc3QgPSB0cnVlO1xuXG4gIC8vIFF1aWNrIHJlZmVyZW5jZSBmb3IgYWxsIG5vZGVzIGluIHRoZSBncmFwaCBtYW5hZ2VyIGFzc29jaWF0ZWQgd2l0aFxuICAvLyB0aGlzIGxheW91dC4gVGhlIGxpc3Qgc2hvdWxkIG5vdCBiZSBjaGFuZ2VkLlxuICB2YXIgYWxsTm9kZXMgPSB0aGlzLmdyYXBoTWFuYWdlci5nZXRSb290KCkuZ2V0Tm9kZXMoKTtcblxuICAvLyBGaXJzdCBiZSBzdXJlIHRoYXQgdGhlIGdyYXBoIGlzIGZsYXRcbiAgdmFyIGlzRmxhdCA9IHRydWU7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbGxOb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChhbGxOb2Rlc1tpXS5nZXRDaGlsZCgpICE9IG51bGwpIHtcbiAgICAgIGlzRmxhdCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIC8vIFJldHVybiBlbXB0eSBmb3Jlc3QgaWYgdGhlIGdyYXBoIGlzIG5vdCBmbGF0LlxuICBpZiAoIWlzRmxhdCkge1xuICAgIHJldHVybiBmbGF0Rm9yZXN0O1xuICB9XG5cbiAgLy8gUnVuIEJGUyBmb3IgZWFjaCBjb21wb25lbnQgb2YgdGhlIGdyYXBoLlxuXG4gIHZhciB2aXNpdGVkID0gbmV3IFNldCgpO1xuICB2YXIgdG9CZVZpc2l0ZWQgPSBbXTtcbiAgdmFyIHBhcmVudHMgPSBuZXcgTWFwKCk7XG4gIHZhciB1blByb2Nlc3NlZE5vZGVzID0gW107XG5cbiAgdW5Qcm9jZXNzZWROb2RlcyA9IHVuUHJvY2Vzc2VkTm9kZXMuY29uY2F0KGFsbE5vZGVzKTtcblxuICAvLyBFYWNoIGl0ZXJhdGlvbiBvZiB0aGlzIGxvb3AgZmluZHMgYSBjb21wb25lbnQgb2YgdGhlIGdyYXBoIGFuZFxuICAvLyBkZWNpZGVzIHdoZXRoZXIgaXQgaXMgYSB0cmVlIG9yIG5vdC4gSWYgaXQgaXMgYSB0cmVlLCBhZGRzIGl0IHRvIHRoZVxuICAvLyBmb3Jlc3QgYW5kIGNvbnRpbnVlZCB3aXRoIHRoZSBuZXh0IGNvbXBvbmVudC5cblxuICB3aGlsZSAodW5Qcm9jZXNzZWROb2Rlcy5sZW5ndGggPiAwICYmIGlzRm9yZXN0KSB7XG4gICAgdG9CZVZpc2l0ZWQucHVzaCh1blByb2Nlc3NlZE5vZGVzWzBdKTtcblxuICAgIC8vIFN0YXJ0IHRoZSBCRlMuIEVhY2ggaXRlcmF0aW9uIG9mIHRoaXMgbG9vcCB2aXNpdHMgYSBub2RlIGluIGFcbiAgICAvLyBCRlMgbWFubmVyLlxuICAgIHdoaWxlICh0b0JlVmlzaXRlZC5sZW5ndGggPiAwICYmIGlzRm9yZXN0KSB7XG4gICAgICAvL3Bvb2wgb3BlcmF0aW9uXG4gICAgICB2YXIgY3VycmVudE5vZGUgPSB0b0JlVmlzaXRlZFswXTtcbiAgICAgIHRvQmVWaXNpdGVkLnNwbGljZSgwLCAxKTtcbiAgICAgIHZpc2l0ZWQuYWRkKGN1cnJlbnROb2RlKTtcblxuICAgICAgLy8gVHJhdmVyc2UgYWxsIG5laWdoYm9ycyBvZiB0aGlzIG5vZGVcbiAgICAgIHZhciBuZWlnaGJvckVkZ2VzID0gY3VycmVudE5vZGUuZ2V0RWRnZXMoKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuZWlnaGJvckVkZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjdXJyZW50TmVpZ2hib3IgPSBuZWlnaGJvckVkZ2VzW2ldLmdldE90aGVyRW5kKGN1cnJlbnROb2RlKTtcblxuICAgICAgICAvLyBJZiBCRlMgaXMgbm90IGdyb3dpbmcgZnJvbSB0aGlzIG5laWdoYm9yLlxuICAgICAgICBpZiAocGFyZW50cy5nZXQoY3VycmVudE5vZGUpICE9IGN1cnJlbnROZWlnaGJvcikge1xuICAgICAgICAgIC8vIFdlIGhhdmVuJ3QgcHJldmlvdXNseSB2aXNpdGVkIHRoaXMgbmVpZ2hib3IuXG4gICAgICAgICAgaWYgKCF2aXNpdGVkLmhhcyhjdXJyZW50TmVpZ2hib3IpKSB7XG4gICAgICAgICAgICB0b0JlVmlzaXRlZC5wdXNoKGN1cnJlbnROZWlnaGJvcik7XG4gICAgICAgICAgICBwYXJlbnRzLnNldChjdXJyZW50TmVpZ2hib3IsIGN1cnJlbnROb2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gU2luY2Ugd2UgaGF2ZSBwcmV2aW91c2x5IHZpc2l0ZWQgdGhpcyBuZWlnaGJvciBhbmRcbiAgICAgICAgICAvLyB0aGlzIG5laWdoYm9yIGlzIG5vdCBwYXJlbnQgb2YgY3VycmVudE5vZGUsIGdpdmVuXG4gICAgICAgICAgLy8gZ3JhcGggY29udGFpbnMgYSBjb21wb25lbnQgdGhhdCBpcyBub3QgdHJlZSwgaGVuY2VcbiAgICAgICAgICAvLyBpdCBpcyBub3QgYSBmb3Jlc3QuXG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIGlzRm9yZXN0ID0gZmFsc2U7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gVGhlIGdyYXBoIGNvbnRhaW5zIGEgY29tcG9uZW50IHRoYXQgaXMgbm90IGEgdHJlZS4gRW1wdHlcbiAgICAvLyBwcmV2aW91c2x5IGZvdW5kIHRyZWVzLiBUaGUgbWV0aG9kIHdpbGwgZW5kLlxuICAgIGlmICghaXNGb3Jlc3QpIHtcbiAgICAgIGZsYXRGb3Jlc3QgPSBbXTtcbiAgICB9XG4gICAgLy8gU2F2ZSBjdXJyZW50bHkgdmlzaXRlZCBub2RlcyBhcyBhIHRyZWUgaW4gb3VyIGZvcmVzdC4gUmVzZXRcbiAgICAvLyB2aXNpdGVkIGFuZCBwYXJlbnRzIGxpc3RzLiBDb250aW51ZSB3aXRoIHRoZSBuZXh0IGNvbXBvbmVudCBvZlxuICAgIC8vIHRoZSBncmFwaCwgaWYgYW55LlxuICAgIGVsc2Uge1xuICAgICAgICB2YXIgdGVtcCA9IFtdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkodmlzaXRlZCkpO1xuICAgICAgICBmbGF0Rm9yZXN0LnB1c2godGVtcCk7XG4gICAgICAgIC8vZmxhdEZvcmVzdCA9IGZsYXRGb3Jlc3QuY29uY2F0KHRlbXApO1xuICAgICAgICAvL3VuUHJvY2Vzc2VkTm9kZXMucmVtb3ZlQWxsKHZpc2l0ZWQpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRlbXAubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSB0ZW1wW2ldO1xuICAgICAgICAgIHZhciBpbmRleCA9IHVuUHJvY2Vzc2VkTm9kZXMuaW5kZXhPZih2YWx1ZSk7XG4gICAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgIHVuUHJvY2Vzc2VkTm9kZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmlzaXRlZCA9IG5ldyBTZXQoKTtcbiAgICAgICAgcGFyZW50cyA9IG5ldyBNYXAoKTtcbiAgICAgIH1cbiAgfVxuXG4gIHJldHVybiBmbGF0Rm9yZXN0O1xufTtcblxuLyoqXHJcbiAqIFRoaXMgbWV0aG9kIGNyZWF0ZXMgZHVtbXkgbm9kZXMgKGFuIGwtbGV2ZWwgbm9kZSB3aXRoIG1pbmltYWwgZGltZW5zaW9ucylcclxuICogZm9yIHRoZSBnaXZlbiBlZGdlIChvbmUgcGVyIGJlbmRwb2ludCkuIFRoZSBleGlzdGluZyBsLWxldmVsIHN0cnVjdHVyZVxyXG4gKiBpcyB1cGRhdGVkIGFjY29yZGluZ2x5LlxyXG4gKi9cbkxheW91dC5wcm90b3R5cGUuY3JlYXRlRHVtbXlOb2Rlc0ZvckJlbmRwb2ludHMgPSBmdW5jdGlvbiAoZWRnZSkge1xuICB2YXIgZHVtbXlOb2RlcyA9IFtdO1xuICB2YXIgcHJldiA9IGVkZ2Uuc291cmNlO1xuXG4gIHZhciBncmFwaCA9IHRoaXMuZ3JhcGhNYW5hZ2VyLmNhbGNMb3dlc3RDb21tb25BbmNlc3RvcihlZGdlLnNvdXJjZSwgZWRnZS50YXJnZXQpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZWRnZS5iZW5kcG9pbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgLy8gY3JlYXRlIG5ldyBkdW1teSBub2RlXG4gICAgdmFyIGR1bW15Tm9kZSA9IHRoaXMubmV3Tm9kZShudWxsKTtcbiAgICBkdW1teU5vZGUuc2V0UmVjdChuZXcgUG9pbnQoMCwgMCksIG5ldyBEaW1lbnNpb24oMSwgMSkpO1xuXG4gICAgZ3JhcGguYWRkKGR1bW15Tm9kZSk7XG5cbiAgICAvLyBjcmVhdGUgbmV3IGR1bW15IGVkZ2UgYmV0d2VlbiBwcmV2IGFuZCBkdW1teSBub2RlXG4gICAgdmFyIGR1bW15RWRnZSA9IHRoaXMubmV3RWRnZShudWxsKTtcbiAgICB0aGlzLmdyYXBoTWFuYWdlci5hZGQoZHVtbXlFZGdlLCBwcmV2LCBkdW1teU5vZGUpO1xuXG4gICAgZHVtbXlOb2Rlcy5hZGQoZHVtbXlOb2RlKTtcbiAgICBwcmV2ID0gZHVtbXlOb2RlO1xuICB9XG5cbiAgdmFyIGR1bW15RWRnZSA9IHRoaXMubmV3RWRnZShudWxsKTtcbiAgdGhpcy5ncmFwaE1hbmFnZXIuYWRkKGR1bW15RWRnZSwgcHJldiwgZWRnZS50YXJnZXQpO1xuXG4gIHRoaXMuZWRnZVRvRHVtbXlOb2Rlcy5zZXQoZWRnZSwgZHVtbXlOb2Rlcyk7XG5cbiAgLy8gcmVtb3ZlIHJlYWwgZWRnZSBmcm9tIGdyYXBoIG1hbmFnZXIgaWYgaXQgaXMgaW50ZXItZ3JhcGhcbiAgaWYgKGVkZ2UuaXNJbnRlckdyYXBoKCkpIHtcbiAgICB0aGlzLmdyYXBoTWFuYWdlci5yZW1vdmUoZWRnZSk7XG4gIH1cbiAgLy8gZWxzZSwgcmVtb3ZlIHRoZSBlZGdlIGZyb20gdGhlIGN1cnJlbnQgZ3JhcGhcbiAgZWxzZSB7XG4gICAgICBncmFwaC5yZW1vdmUoZWRnZSk7XG4gICAgfVxuXG4gIHJldHVybiBkdW1teU5vZGVzO1xufTtcblxuLyoqXHJcbiAqIFRoaXMgbWV0aG9kIGNyZWF0ZXMgYmVuZHBvaW50cyBmb3IgZWRnZXMgZnJvbSB0aGUgZHVtbXkgbm9kZXNcclxuICogYXQgbC1sZXZlbC5cclxuICovXG5MYXlvdXQucHJvdG90eXBlLmNyZWF0ZUJlbmRwb2ludHNGcm9tRHVtbXlOb2RlcyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGVkZ2VzID0gW107XG4gIGVkZ2VzID0gZWRnZXMuY29uY2F0KHRoaXMuZ3JhcGhNYW5hZ2VyLmdldEFsbEVkZ2VzKCkpO1xuICBlZGdlcyA9IFtdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkodGhpcy5lZGdlVG9EdW1teU5vZGVzLmtleXMoKSkpLmNvbmNhdChlZGdlcyk7XG5cbiAgZm9yICh2YXIgayA9IDA7IGsgPCBlZGdlcy5sZW5ndGg7IGsrKykge1xuICAgIHZhciBsRWRnZSA9IGVkZ2VzW2tdO1xuXG4gICAgaWYgKGxFZGdlLmJlbmRwb2ludHMubGVuZ3RoID4gMCkge1xuICAgICAgdmFyIHBhdGggPSB0aGlzLmVkZ2VUb0R1bW15Tm9kZXMuZ2V0KGxFZGdlKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBkdW1teU5vZGUgPSBwYXRoW2ldO1xuICAgICAgICB2YXIgcCA9IG5ldyBQb2ludEQoZHVtbXlOb2RlLmdldENlbnRlclgoKSwgZHVtbXlOb2RlLmdldENlbnRlclkoKSk7XG5cbiAgICAgICAgLy8gdXBkYXRlIGJlbmRwb2ludCdzIGxvY2F0aW9uIGFjY29yZGluZyB0byBkdW1teSBub2RlXG4gICAgICAgIHZhciBlYnAgPSBsRWRnZS5iZW5kcG9pbnRzLmdldChpKTtcbiAgICAgICAgZWJwLnggPSBwLng7XG4gICAgICAgIGVicC55ID0gcC55O1xuXG4gICAgICAgIC8vIHJlbW92ZSB0aGUgZHVtbXkgbm9kZSwgZHVtbXkgZWRnZXMgaW5jaWRlbnQgd2l0aCB0aGlzXG4gICAgICAgIC8vIGR1bW15IG5vZGUgaXMgYWxzbyByZW1vdmVkICh3aXRoaW4gdGhlIHJlbW92ZSBtZXRob2QpXG4gICAgICAgIGR1bW15Tm9kZS5nZXRPd25lcigpLnJlbW92ZShkdW1teU5vZGUpO1xuICAgICAgfVxuXG4gICAgICAvLyBhZGQgdGhlIHJlYWwgZWRnZSB0byBncmFwaFxuICAgICAgdGhpcy5ncmFwaE1hbmFnZXIuYWRkKGxFZGdlLCBsRWRnZS5zb3VyY2UsIGxFZGdlLnRhcmdldCk7XG4gICAgfVxuICB9XG59O1xuXG5MYXlvdXQudHJhbnNmb3JtID0gZnVuY3Rpb24gKHNsaWRlclZhbHVlLCBkZWZhdWx0VmFsdWUsIG1pbkRpdiwgbWF4TXVsKSB7XG4gIGlmIChtaW5EaXYgIT0gdW5kZWZpbmVkICYmIG1heE11bCAhPSB1bmRlZmluZWQpIHtcbiAgICB2YXIgdmFsdWUgPSBkZWZhdWx0VmFsdWU7XG5cbiAgICBpZiAoc2xpZGVyVmFsdWUgPD0gNTApIHtcbiAgICAgIHZhciBtaW5WYWx1ZSA9IGRlZmF1bHRWYWx1ZSAvIG1pbkRpdjtcbiAgICAgIHZhbHVlIC09IChkZWZhdWx0VmFsdWUgLSBtaW5WYWx1ZSkgLyA1MCAqICg1MCAtIHNsaWRlclZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIG1heFZhbHVlID0gZGVmYXVsdFZhbHVlICogbWF4TXVsO1xuICAgICAgdmFsdWUgKz0gKG1heFZhbHVlIC0gZGVmYXVsdFZhbHVlKSAvIDUwICogKHNsaWRlclZhbHVlIC0gNTApO1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgYSwgYjtcblxuICAgIGlmIChzbGlkZXJWYWx1ZSA8PSA1MCkge1xuICAgICAgYSA9IDkuMCAqIGRlZmF1bHRWYWx1ZSAvIDUwMC4wO1xuICAgICAgYiA9IGRlZmF1bHRWYWx1ZSAvIDEwLjA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGEgPSA5LjAgKiBkZWZhdWx0VmFsdWUgLyA1MC4wO1xuICAgICAgYiA9IC04ICogZGVmYXVsdFZhbHVlO1xuICAgIH1cblxuICAgIHJldHVybiBhICogc2xpZGVyVmFsdWUgKyBiO1xuICB9XG59O1xuXG4vKipcclxuICogVGhpcyBtZXRob2QgZmluZHMgYW5kIHJldHVybnMgdGhlIGNlbnRlciBvZiB0aGUgZ2l2ZW4gbm9kZXMsIGFzc3VtaW5nXHJcbiAqIHRoYXQgdGhlIGdpdmVuIG5vZGVzIGZvcm0gYSB0cmVlIGluIHRoZW1zZWx2ZXMuXHJcbiAqL1xuTGF5b3V0LmZpbmRDZW50ZXJPZlRyZWUgPSBmdW5jdGlvbiAobm9kZXMpIHtcbiAgdmFyIGxpc3QgPSBbXTtcbiAgbGlzdCA9IGxpc3QuY29uY2F0KG5vZGVzKTtcblxuICB2YXIgcmVtb3ZlZE5vZGVzID0gW107XG4gIHZhciByZW1haW5pbmdEZWdyZWVzID0gbmV3IE1hcCgpO1xuICB2YXIgZm91bmRDZW50ZXIgPSBmYWxzZTtcbiAgdmFyIGNlbnRlck5vZGUgPSBudWxsO1xuXG4gIGlmIChsaXN0Lmxlbmd0aCA9PSAxIHx8IGxpc3QubGVuZ3RoID09IDIpIHtcbiAgICBmb3VuZENlbnRlciA9IHRydWU7XG4gICAgY2VudGVyTm9kZSA9IGxpc3RbMF07XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbm9kZSA9IGxpc3RbaV07XG4gICAgdmFyIGRlZ3JlZSA9IG5vZGUuZ2V0TmVpZ2hib3JzTGlzdCgpLnNpemU7XG4gICAgcmVtYWluaW5nRGVncmVlcy5zZXQobm9kZSwgbm9kZS5nZXROZWlnaGJvcnNMaXN0KCkuc2l6ZSk7XG5cbiAgICBpZiAoZGVncmVlID09IDEpIHtcbiAgICAgIHJlbW92ZWROb2Rlcy5wdXNoKG5vZGUpO1xuICAgIH1cbiAgfVxuXG4gIHZhciB0ZW1wTGlzdCA9IFtdO1xuICB0ZW1wTGlzdCA9IHRlbXBMaXN0LmNvbmNhdChyZW1vdmVkTm9kZXMpO1xuXG4gIHdoaWxlICghZm91bmRDZW50ZXIpIHtcbiAgICB2YXIgdGVtcExpc3QyID0gW107XG4gICAgdGVtcExpc3QyID0gdGVtcExpc3QyLmNvbmNhdCh0ZW1wTGlzdCk7XG4gICAgdGVtcExpc3QgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIG5vZGUgPSBsaXN0W2ldO1xuXG4gICAgICB2YXIgaW5kZXggPSBsaXN0LmluZGV4T2Yobm9kZSk7XG4gICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICBsaXN0LnNwbGljZShpbmRleCwgMSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBuZWlnaGJvdXJzID0gbm9kZS5nZXROZWlnaGJvcnNMaXN0KCk7XG5cbiAgICAgIG5laWdoYm91cnMuZm9yRWFjaChmdW5jdGlvbiAobmVpZ2hib3VyKSB7XG4gICAgICAgIGlmIChyZW1vdmVkTm9kZXMuaW5kZXhPZihuZWlnaGJvdXIpIDwgMCkge1xuICAgICAgICAgIHZhciBvdGhlckRlZ3JlZSA9IHJlbWFpbmluZ0RlZ3JlZXMuZ2V0KG5laWdoYm91cik7XG4gICAgICAgICAgdmFyIG5ld0RlZ3JlZSA9IG90aGVyRGVncmVlIC0gMTtcblxuICAgICAgICAgIGlmIChuZXdEZWdyZWUgPT0gMSkge1xuICAgICAgICAgICAgdGVtcExpc3QucHVzaChuZWlnaGJvdXIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJlbWFpbmluZ0RlZ3JlZXMuc2V0KG5laWdoYm91ciwgbmV3RGVncmVlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmVtb3ZlZE5vZGVzID0gcmVtb3ZlZE5vZGVzLmNvbmNhdCh0ZW1wTGlzdCk7XG5cbiAgICBpZiAobGlzdC5sZW5ndGggPT0gMSB8fCBsaXN0Lmxlbmd0aCA9PSAyKSB7XG4gICAgICBmb3VuZENlbnRlciA9IHRydWU7XG4gICAgICBjZW50ZXJOb2RlID0gbGlzdFswXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gY2VudGVyTm9kZTtcbn07XG5cbi8qKlxyXG4gKiBEdXJpbmcgdGhlIGNvYXJzZW5pbmcgcHJvY2VzcywgdGhpcyBsYXlvdXQgbWF5IGJlIHJlZmVyZW5jZWQgYnkgdHdvIGdyYXBoIG1hbmFnZXJzXHJcbiAqIHRoaXMgc2V0dGVyIGZ1bmN0aW9uIGdyYW50cyBhY2Nlc3MgdG8gY2hhbmdlIHRoZSBjdXJyZW50bHkgYmVpbmcgdXNlZCBncmFwaCBtYW5hZ2VyXHJcbiAqL1xuTGF5b3V0LnByb3RvdHlwZS5zZXRHcmFwaE1hbmFnZXIgPSBmdW5jdGlvbiAoZ20pIHtcbiAgdGhpcy5ncmFwaE1hbmFnZXIgPSBnbTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTGF5b3V0O1xuXG4vKioqLyB9KSxcbi8qIDE2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbmZ1bmN0aW9uIFJhbmRvbVNlZWQoKSB7fVxuLy8gYWRhcHRlZCBmcm9tOiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTkzMDM3MjVcblJhbmRvbVNlZWQuc2VlZCA9IDE7XG5SYW5kb21TZWVkLnggPSAwO1xuXG5SYW5kb21TZWVkLm5leHREb3VibGUgPSBmdW5jdGlvbiAoKSB7XG4gIFJhbmRvbVNlZWQueCA9IE1hdGguc2luKFJhbmRvbVNlZWQuc2VlZCsrKSAqIDEwMDAwO1xuICByZXR1cm4gUmFuZG9tU2VlZC54IC0gTWF0aC5mbG9vcihSYW5kb21TZWVkLngpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSYW5kb21TZWVkO1xuXG4vKioqLyB9KSxcbi8qIDE3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBQb2ludEQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuXG5mdW5jdGlvbiBUcmFuc2Zvcm0oeCwgeSkge1xuICB0aGlzLmx3b3JsZE9yZ1ggPSAwLjA7XG4gIHRoaXMubHdvcmxkT3JnWSA9IDAuMDtcbiAgdGhpcy5sZGV2aWNlT3JnWCA9IDAuMDtcbiAgdGhpcy5sZGV2aWNlT3JnWSA9IDAuMDtcbiAgdGhpcy5sd29ybGRFeHRYID0gMS4wO1xuICB0aGlzLmx3b3JsZEV4dFkgPSAxLjA7XG4gIHRoaXMubGRldmljZUV4dFggPSAxLjA7XG4gIHRoaXMubGRldmljZUV4dFkgPSAxLjA7XG59XG5cblRyYW5zZm9ybS5wcm90b3R5cGUuZ2V0V29ybGRPcmdYID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5sd29ybGRPcmdYO1xufTtcblxuVHJhbnNmb3JtLnByb3RvdHlwZS5zZXRXb3JsZE9yZ1ggPSBmdW5jdGlvbiAod294KSB7XG4gIHRoaXMubHdvcmxkT3JnWCA9IHdveDtcbn07XG5cblRyYW5zZm9ybS5wcm90b3R5cGUuZ2V0V29ybGRPcmdZID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5sd29ybGRPcmdZO1xufTtcblxuVHJhbnNmb3JtLnByb3RvdHlwZS5zZXRXb3JsZE9yZ1kgPSBmdW5jdGlvbiAod295KSB7XG4gIHRoaXMubHdvcmxkT3JnWSA9IHdveTtcbn07XG5cblRyYW5zZm9ybS5wcm90b3R5cGUuZ2V0V29ybGRFeHRYID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5sd29ybGRFeHRYO1xufTtcblxuVHJhbnNmb3JtLnByb3RvdHlwZS5zZXRXb3JsZEV4dFggPSBmdW5jdGlvbiAod2V4KSB7XG4gIHRoaXMubHdvcmxkRXh0WCA9IHdleDtcbn07XG5cblRyYW5zZm9ybS5wcm90b3R5cGUuZ2V0V29ybGRFeHRZID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5sd29ybGRFeHRZO1xufTtcblxuVHJhbnNmb3JtLnByb3RvdHlwZS5zZXRXb3JsZEV4dFkgPSBmdW5jdGlvbiAod2V5KSB7XG4gIHRoaXMubHdvcmxkRXh0WSA9IHdleTtcbn07XG5cbi8qIERldmljZSByZWxhdGVkICovXG5cblRyYW5zZm9ybS5wcm90b3R5cGUuZ2V0RGV2aWNlT3JnWCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMubGRldmljZU9yZ1g7XG59O1xuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLnNldERldmljZU9yZ1ggPSBmdW5jdGlvbiAoZG94KSB7XG4gIHRoaXMubGRldmljZU9yZ1ggPSBkb3g7XG59O1xuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLmdldERldmljZU9yZ1kgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmxkZXZpY2VPcmdZO1xufTtcblxuVHJhbnNmb3JtLnByb3RvdHlwZS5zZXREZXZpY2VPcmdZID0gZnVuY3Rpb24gKGRveSkge1xuICB0aGlzLmxkZXZpY2VPcmdZID0gZG95O1xufTtcblxuVHJhbnNmb3JtLnByb3RvdHlwZS5nZXREZXZpY2VFeHRYID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5sZGV2aWNlRXh0WDtcbn07XG5cblRyYW5zZm9ybS5wcm90b3R5cGUuc2V0RGV2aWNlRXh0WCA9IGZ1bmN0aW9uIChkZXgpIHtcbiAgdGhpcy5sZGV2aWNlRXh0WCA9IGRleDtcbn07XG5cblRyYW5zZm9ybS5wcm90b3R5cGUuZ2V0RGV2aWNlRXh0WSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMubGRldmljZUV4dFk7XG59O1xuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLnNldERldmljZUV4dFkgPSBmdW5jdGlvbiAoZGV5KSB7XG4gIHRoaXMubGRldmljZUV4dFkgPSBkZXk7XG59O1xuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLnRyYW5zZm9ybVggPSBmdW5jdGlvbiAoeCkge1xuICB2YXIgeERldmljZSA9IDAuMDtcbiAgdmFyIHdvcmxkRXh0WCA9IHRoaXMubHdvcmxkRXh0WDtcbiAgaWYgKHdvcmxkRXh0WCAhPSAwLjApIHtcbiAgICB4RGV2aWNlID0gdGhpcy5sZGV2aWNlT3JnWCArICh4IC0gdGhpcy5sd29ybGRPcmdYKSAqIHRoaXMubGRldmljZUV4dFggLyB3b3JsZEV4dFg7XG4gIH1cblxuICByZXR1cm4geERldmljZTtcbn07XG5cblRyYW5zZm9ybS5wcm90b3R5cGUudHJhbnNmb3JtWSA9IGZ1bmN0aW9uICh5KSB7XG4gIHZhciB5RGV2aWNlID0gMC4wO1xuICB2YXIgd29ybGRFeHRZID0gdGhpcy5sd29ybGRFeHRZO1xuICBpZiAod29ybGRFeHRZICE9IDAuMCkge1xuICAgIHlEZXZpY2UgPSB0aGlzLmxkZXZpY2VPcmdZICsgKHkgLSB0aGlzLmx3b3JsZE9yZ1kpICogdGhpcy5sZGV2aWNlRXh0WSAvIHdvcmxkRXh0WTtcbiAgfVxuXG4gIHJldHVybiB5RGV2aWNlO1xufTtcblxuVHJhbnNmb3JtLnByb3RvdHlwZS5pbnZlcnNlVHJhbnNmb3JtWCA9IGZ1bmN0aW9uICh4KSB7XG4gIHZhciB4V29ybGQgPSAwLjA7XG4gIHZhciBkZXZpY2VFeHRYID0gdGhpcy5sZGV2aWNlRXh0WDtcbiAgaWYgKGRldmljZUV4dFggIT0gMC4wKSB7XG4gICAgeFdvcmxkID0gdGhpcy5sd29ybGRPcmdYICsgKHggLSB0aGlzLmxkZXZpY2VPcmdYKSAqIHRoaXMubHdvcmxkRXh0WCAvIGRldmljZUV4dFg7XG4gIH1cblxuICByZXR1cm4geFdvcmxkO1xufTtcblxuVHJhbnNmb3JtLnByb3RvdHlwZS5pbnZlcnNlVHJhbnNmb3JtWSA9IGZ1bmN0aW9uICh5KSB7XG4gIHZhciB5V29ybGQgPSAwLjA7XG4gIHZhciBkZXZpY2VFeHRZID0gdGhpcy5sZGV2aWNlRXh0WTtcbiAgaWYgKGRldmljZUV4dFkgIT0gMC4wKSB7XG4gICAgeVdvcmxkID0gdGhpcy5sd29ybGRPcmdZICsgKHkgLSB0aGlzLmxkZXZpY2VPcmdZKSAqIHRoaXMubHdvcmxkRXh0WSAvIGRldmljZUV4dFk7XG4gIH1cbiAgcmV0dXJuIHlXb3JsZDtcbn07XG5cblRyYW5zZm9ybS5wcm90b3R5cGUuaW52ZXJzZVRyYW5zZm9ybVBvaW50ID0gZnVuY3Rpb24gKGluUG9pbnQpIHtcbiAgdmFyIG91dFBvaW50ID0gbmV3IFBvaW50RCh0aGlzLmludmVyc2VUcmFuc2Zvcm1YKGluUG9pbnQueCksIHRoaXMuaW52ZXJzZVRyYW5zZm9ybVkoaW5Qb2ludC55KSk7XG4gIHJldHVybiBvdXRQb2ludDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gVHJhbnNmb3JtO1xuXG4vKioqLyB9KSxcbi8qIDE4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbmZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShhcnIpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgeyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IEFycmF5KGFyci5sZW5ndGgpOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH0gZWxzZSB7IHJldHVybiBBcnJheS5mcm9tKGFycik7IH0gfVxuXG52YXIgTGF5b3V0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNSk7XG52YXIgRkRMYXlvdXRDb25zdGFudHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpO1xudmFyIExheW91dENvbnN0YW50cyA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG52YXIgSUdlb21ldHJ5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4KTtcbnZhciBJTWF0aCA9IF9fd2VicGFja19yZXF1aXJlX18oOSk7XG5cbmZ1bmN0aW9uIEZETGF5b3V0KCkge1xuICBMYXlvdXQuY2FsbCh0aGlzKTtcblxuICB0aGlzLnVzZVNtYXJ0SWRlYWxFZGdlTGVuZ3RoQ2FsY3VsYXRpb24gPSBGRExheW91dENvbnN0YW50cy5ERUZBVUxUX1VTRV9TTUFSVF9JREVBTF9FREdFX0xFTkdUSF9DQUxDVUxBVElPTjtcbiAgdGhpcy5pZGVhbEVkZ2VMZW5ndGggPSBGRExheW91dENvbnN0YW50cy5ERUZBVUxUX0VER0VfTEVOR1RIO1xuICB0aGlzLnNwcmluZ0NvbnN0YW50ID0gRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9TUFJJTkdfU1RSRU5HVEg7XG4gIHRoaXMucmVwdWxzaW9uQ29uc3RhbnQgPSBGRExheW91dENvbnN0YW50cy5ERUZBVUxUX1JFUFVMU0lPTl9TVFJFTkdUSDtcbiAgdGhpcy5ncmF2aXR5Q29uc3RhbnQgPSBGRExheW91dENvbnN0YW50cy5ERUZBVUxUX0dSQVZJVFlfU1RSRU5HVEg7XG4gIHRoaXMuY29tcG91bmRHcmF2aXR5Q29uc3RhbnQgPSBGRExheW91dENvbnN0YW50cy5ERUZBVUxUX0NPTVBPVU5EX0dSQVZJVFlfU1RSRU5HVEg7XG4gIHRoaXMuZ3Jhdml0eVJhbmdlRmFjdG9yID0gRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9HUkFWSVRZX1JBTkdFX0ZBQ1RPUjtcbiAgdGhpcy5jb21wb3VuZEdyYXZpdHlSYW5nZUZhY3RvciA9IEZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfQ09NUE9VTkRfR1JBVklUWV9SQU5HRV9GQUNUT1I7XG4gIHRoaXMuZGlzcGxhY2VtZW50VGhyZXNob2xkUGVyTm9kZSA9IDMuMCAqIEZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfRURHRV9MRU5HVEggLyAxMDA7XG4gIHRoaXMuY29vbGluZ0ZhY3RvciA9IEZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfQ09PTElOR19GQUNUT1JfSU5DUkVNRU5UQUw7XG4gIHRoaXMuaW5pdGlhbENvb2xpbmdGYWN0b3IgPSBGRExheW91dENvbnN0YW50cy5ERUZBVUxUX0NPT0xJTkdfRkFDVE9SX0lOQ1JFTUVOVEFMO1xuICB0aGlzLnRvdGFsRGlzcGxhY2VtZW50ID0gMC4wO1xuICB0aGlzLm9sZFRvdGFsRGlzcGxhY2VtZW50ID0gMC4wO1xuICB0aGlzLm1heEl0ZXJhdGlvbnMgPSBGRExheW91dENvbnN0YW50cy5NQVhfSVRFUkFUSU9OUztcbn1cblxuRkRMYXlvdXQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShMYXlvdXQucHJvdG90eXBlKTtcblxuZm9yICh2YXIgcHJvcCBpbiBMYXlvdXQpIHtcbiAgRkRMYXlvdXRbcHJvcF0gPSBMYXlvdXRbcHJvcF07XG59XG5cbkZETGF5b3V0LnByb3RvdHlwZS5pbml0UGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHtcbiAgTGF5b3V0LnByb3RvdHlwZS5pbml0UGFyYW1ldGVycy5jYWxsKHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgdGhpcy50b3RhbEl0ZXJhdGlvbnMgPSAwO1xuICB0aGlzLm5vdEFuaW1hdGVkSXRlcmF0aW9ucyA9IDA7XG5cbiAgdGhpcy51c2VGUkdyaWRWYXJpYW50ID0gRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9VU0VfU01BUlRfUkVQVUxTSU9OX1JBTkdFX0NBTENVTEFUSU9OO1xuXG4gIHRoaXMuZ3JpZCA9IFtdO1xufTtcblxuRkRMYXlvdXQucHJvdG90eXBlLmNhbGNJZGVhbEVkZ2VMZW5ndGhzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgZWRnZTtcbiAgdmFyIGxjYURlcHRoO1xuICB2YXIgc291cmNlO1xuICB2YXIgdGFyZ2V0O1xuICB2YXIgc2l6ZU9mU291cmNlSW5MY2E7XG4gIHZhciBzaXplT2ZUYXJnZXRJbkxjYTtcblxuICB2YXIgYWxsRWRnZXMgPSB0aGlzLmdldEdyYXBoTWFuYWdlcigpLmdldEFsbEVkZ2VzKCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYWxsRWRnZXMubGVuZ3RoOyBpKyspIHtcbiAgICBlZGdlID0gYWxsRWRnZXNbaV07XG5cbiAgICBlZGdlLmlkZWFsTGVuZ3RoID0gdGhpcy5pZGVhbEVkZ2VMZW5ndGg7XG5cbiAgICBpZiAoZWRnZS5pc0ludGVyR3JhcGgpIHtcbiAgICAgIHNvdXJjZSA9IGVkZ2UuZ2V0U291cmNlKCk7XG4gICAgICB0YXJnZXQgPSBlZGdlLmdldFRhcmdldCgpO1xuXG4gICAgICBzaXplT2ZTb3VyY2VJbkxjYSA9IGVkZ2UuZ2V0U291cmNlSW5MY2EoKS5nZXRFc3RpbWF0ZWRTaXplKCk7XG4gICAgICBzaXplT2ZUYXJnZXRJbkxjYSA9IGVkZ2UuZ2V0VGFyZ2V0SW5MY2EoKS5nZXRFc3RpbWF0ZWRTaXplKCk7XG5cbiAgICAgIGlmICh0aGlzLnVzZVNtYXJ0SWRlYWxFZGdlTGVuZ3RoQ2FsY3VsYXRpb24pIHtcbiAgICAgICAgZWRnZS5pZGVhbExlbmd0aCArPSBzaXplT2ZTb3VyY2VJbkxjYSArIHNpemVPZlRhcmdldEluTGNhIC0gMiAqIExheW91dENvbnN0YW50cy5TSU1QTEVfTk9ERV9TSVpFO1xuICAgICAgfVxuXG4gICAgICBsY2FEZXB0aCA9IGVkZ2UuZ2V0TGNhKCkuZ2V0SW5jbHVzaW9uVHJlZURlcHRoKCk7XG5cbiAgICAgIGVkZ2UuaWRlYWxMZW5ndGggKz0gRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9FREdFX0xFTkdUSCAqIEZETGF5b3V0Q29uc3RhbnRzLlBFUl9MRVZFTF9JREVBTF9FREdFX0xFTkdUSF9GQUNUT1IgKiAoc291cmNlLmdldEluY2x1c2lvblRyZWVEZXB0aCgpICsgdGFyZ2V0LmdldEluY2x1c2lvblRyZWVEZXB0aCgpIC0gMiAqIGxjYURlcHRoKTtcbiAgICB9XG4gIH1cbn07XG5cbkZETGF5b3V0LnByb3RvdHlwZS5pbml0U3ByaW5nRW1iZWRkZXIgPSBmdW5jdGlvbiAoKSB7XG5cbiAgdmFyIHMgPSB0aGlzLmdldEFsbE5vZGVzKCkubGVuZ3RoO1xuICBpZiAodGhpcy5pbmNyZW1lbnRhbCkge1xuICAgIGlmIChzID4gRkRMYXlvdXRDb25zdGFudHMuQURBUFRBVElPTl9MT1dFUl9OT0RFX0xJTUlUKSB7XG4gICAgICB0aGlzLmNvb2xpbmdGYWN0b3IgPSBNYXRoLm1heCh0aGlzLmNvb2xpbmdGYWN0b3IgKiBGRExheW91dENvbnN0YW50cy5DT09MSU5HX0FEQVBUQVRJT05fRkFDVE9SLCB0aGlzLmNvb2xpbmdGYWN0b3IgLSAocyAtIEZETGF5b3V0Q29uc3RhbnRzLkFEQVBUQVRJT05fTE9XRVJfTk9ERV9MSU1JVCkgLyAoRkRMYXlvdXRDb25zdGFudHMuQURBUFRBVElPTl9VUFBFUl9OT0RFX0xJTUlUIC0gRkRMYXlvdXRDb25zdGFudHMuQURBUFRBVElPTl9MT1dFUl9OT0RFX0xJTUlUKSAqIHRoaXMuY29vbGluZ0ZhY3RvciAqICgxIC0gRkRMYXlvdXRDb25zdGFudHMuQ09PTElOR19BREFQVEFUSU9OX0ZBQ1RPUikpO1xuICAgIH1cbiAgICB0aGlzLm1heE5vZGVEaXNwbGFjZW1lbnQgPSBGRExheW91dENvbnN0YW50cy5NQVhfTk9ERV9ESVNQTEFDRU1FTlRfSU5DUkVNRU5UQUw7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHMgPiBGRExheW91dENvbnN0YW50cy5BREFQVEFUSU9OX0xPV0VSX05PREVfTElNSVQpIHtcbiAgICAgIHRoaXMuY29vbGluZ0ZhY3RvciA9IE1hdGgubWF4KEZETGF5b3V0Q29uc3RhbnRzLkNPT0xJTkdfQURBUFRBVElPTl9GQUNUT1IsIDEuMCAtIChzIC0gRkRMYXlvdXRDb25zdGFudHMuQURBUFRBVElPTl9MT1dFUl9OT0RFX0xJTUlUKSAvIChGRExheW91dENvbnN0YW50cy5BREFQVEFUSU9OX1VQUEVSX05PREVfTElNSVQgLSBGRExheW91dENvbnN0YW50cy5BREFQVEFUSU9OX0xPV0VSX05PREVfTElNSVQpICogKDEgLSBGRExheW91dENvbnN0YW50cy5DT09MSU5HX0FEQVBUQVRJT05fRkFDVE9SKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY29vbGluZ0ZhY3RvciA9IDEuMDtcbiAgICB9XG4gICAgdGhpcy5pbml0aWFsQ29vbGluZ0ZhY3RvciA9IHRoaXMuY29vbGluZ0ZhY3RvcjtcbiAgICB0aGlzLm1heE5vZGVEaXNwbGFjZW1lbnQgPSBGRExheW91dENvbnN0YW50cy5NQVhfTk9ERV9ESVNQTEFDRU1FTlQ7XG4gIH1cblxuICB0aGlzLm1heEl0ZXJhdGlvbnMgPSBNYXRoLm1heCh0aGlzLmdldEFsbE5vZGVzKCkubGVuZ3RoICogNSwgdGhpcy5tYXhJdGVyYXRpb25zKTtcblxuICB0aGlzLnRvdGFsRGlzcGxhY2VtZW50VGhyZXNob2xkID0gdGhpcy5kaXNwbGFjZW1lbnRUaHJlc2hvbGRQZXJOb2RlICogdGhpcy5nZXRBbGxOb2RlcygpLmxlbmd0aDtcblxuICB0aGlzLnJlcHVsc2lvblJhbmdlID0gdGhpcy5jYWxjUmVwdWxzaW9uUmFuZ2UoKTtcbn07XG5cbkZETGF5b3V0LnByb3RvdHlwZS5jYWxjU3ByaW5nRm9yY2VzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbEVkZ2VzID0gdGhpcy5nZXRBbGxFZGdlcygpO1xuICB2YXIgZWRnZTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxFZGdlcy5sZW5ndGg7IGkrKykge1xuICAgIGVkZ2UgPSBsRWRnZXNbaV07XG5cbiAgICB0aGlzLmNhbGNTcHJpbmdGb3JjZShlZGdlLCBlZGdlLmlkZWFsTGVuZ3RoKTtcbiAgfVxufTtcblxuRkRMYXlvdXQucHJvdG90eXBlLmNhbGNSZXB1bHNpb25Gb3JjZXMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBncmlkVXBkYXRlQWxsb3dlZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogdHJ1ZTtcbiAgdmFyIGZvcmNlVG9Ob2RlU3Vycm91bmRpbmdVcGRhdGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuXG4gIHZhciBpLCBqO1xuICB2YXIgbm9kZUEsIG5vZGVCO1xuICB2YXIgbE5vZGVzID0gdGhpcy5nZXRBbGxOb2RlcygpO1xuICB2YXIgcHJvY2Vzc2VkTm9kZVNldDtcblxuICBpZiAodGhpcy51c2VGUkdyaWRWYXJpYW50KSB7XG4gICAgaWYgKHRoaXMudG90YWxJdGVyYXRpb25zICUgRkRMYXlvdXRDb25zdGFudHMuR1JJRF9DQUxDVUxBVElPTl9DSEVDS19QRVJJT0QgPT0gMSAmJiBncmlkVXBkYXRlQWxsb3dlZCkge1xuICAgICAgdGhpcy51cGRhdGVHcmlkKCk7XG4gICAgfVxuXG4gICAgcHJvY2Vzc2VkTm9kZVNldCA9IG5ldyBTZXQoKTtcblxuICAgIC8vIGNhbGN1bGF0ZSByZXB1bHNpb24gZm9yY2VzIGJldHdlZW4gZWFjaCBub2RlcyBhbmQgaXRzIHN1cnJvdW5kaW5nXG4gICAgZm9yIChpID0gMDsgaSA8IGxOb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgbm9kZUEgPSBsTm9kZXNbaV07XG4gICAgICB0aGlzLmNhbGN1bGF0ZVJlcHVsc2lvbkZvcmNlT2ZBTm9kZShub2RlQSwgcHJvY2Vzc2VkTm9kZVNldCwgZ3JpZFVwZGF0ZUFsbG93ZWQsIGZvcmNlVG9Ob2RlU3Vycm91bmRpbmdVcGRhdGUpO1xuICAgICAgcHJvY2Vzc2VkTm9kZVNldC5hZGQobm9kZUEpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBub2RlQSA9IGxOb2Rlc1tpXTtcblxuICAgICAgZm9yIChqID0gaSArIDE7IGogPCBsTm9kZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgbm9kZUIgPSBsTm9kZXNbal07XG5cbiAgICAgICAgLy8gSWYgYm90aCBub2RlcyBhcmUgbm90IG1lbWJlcnMgb2YgdGhlIHNhbWUgZ3JhcGgsIHNraXAuXG4gICAgICAgIGlmIChub2RlQS5nZXRPd25lcigpICE9IG5vZGVCLmdldE93bmVyKCkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY2FsY1JlcHVsc2lvbkZvcmNlKG5vZGVBLCBub2RlQik7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5GRExheW91dC5wcm90b3R5cGUuY2FsY0dyYXZpdGF0aW9uYWxGb3JjZXMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBub2RlO1xuICB2YXIgbE5vZGVzID0gdGhpcy5nZXRBbGxOb2Rlc1RvQXBwbHlHcmF2aXRhdGlvbigpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgbm9kZSA9IGxOb2Rlc1tpXTtcbiAgICB0aGlzLmNhbGNHcmF2aXRhdGlvbmFsRm9yY2Uobm9kZSk7XG4gIH1cbn07XG5cbkZETGF5b3V0LnByb3RvdHlwZS5tb3ZlTm9kZXMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBsTm9kZXMgPSB0aGlzLmdldEFsbE5vZGVzKCk7XG4gIHZhciBub2RlO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgbm9kZSA9IGxOb2Rlc1tpXTtcbiAgICBub2RlLm1vdmUoKTtcbiAgfVxufTtcblxuRkRMYXlvdXQucHJvdG90eXBlLmNhbGNTcHJpbmdGb3JjZSA9IGZ1bmN0aW9uIChlZGdlLCBpZGVhbExlbmd0aCkge1xuICB2YXIgc291cmNlTm9kZSA9IGVkZ2UuZ2V0U291cmNlKCk7XG4gIHZhciB0YXJnZXROb2RlID0gZWRnZS5nZXRUYXJnZXQoKTtcblxuICB2YXIgbGVuZ3RoO1xuICB2YXIgc3ByaW5nRm9yY2U7XG4gIHZhciBzcHJpbmdGb3JjZVg7XG4gIHZhciBzcHJpbmdGb3JjZVk7XG5cbiAgLy8gVXBkYXRlIGVkZ2UgbGVuZ3RoXG4gIGlmICh0aGlzLnVuaWZvcm1MZWFmTm9kZVNpemVzICYmIHNvdXJjZU5vZGUuZ2V0Q2hpbGQoKSA9PSBudWxsICYmIHRhcmdldE5vZGUuZ2V0Q2hpbGQoKSA9PSBudWxsKSB7XG4gICAgZWRnZS51cGRhdGVMZW5ndGhTaW1wbGUoKTtcbiAgfSBlbHNlIHtcbiAgICBlZGdlLnVwZGF0ZUxlbmd0aCgpO1xuXG4gICAgaWYgKGVkZ2UuaXNPdmVybGFwaW5nU291cmNlQW5kVGFyZ2V0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG5cbiAgbGVuZ3RoID0gZWRnZS5nZXRMZW5ndGgoKTtcblxuICBpZiAobGVuZ3RoID09IDApIHJldHVybjtcblxuICAvLyBDYWxjdWxhdGUgc3ByaW5nIGZvcmNlc1xuICBzcHJpbmdGb3JjZSA9IHRoaXMuc3ByaW5nQ29uc3RhbnQgKiAobGVuZ3RoIC0gaWRlYWxMZW5ndGgpO1xuXG4gIC8vIFByb2plY3QgZm9yY2Ugb250byB4IGFuZCB5IGF4ZXNcbiAgc3ByaW5nRm9yY2VYID0gc3ByaW5nRm9yY2UgKiAoZWRnZS5sZW5ndGhYIC8gbGVuZ3RoKTtcbiAgc3ByaW5nRm9yY2VZID0gc3ByaW5nRm9yY2UgKiAoZWRnZS5sZW5ndGhZIC8gbGVuZ3RoKTtcblxuICAvLyBBcHBseSBmb3JjZXMgb24gdGhlIGVuZCBub2Rlc1xuICBzb3VyY2VOb2RlLnNwcmluZ0ZvcmNlWCArPSBzcHJpbmdGb3JjZVg7XG4gIHNvdXJjZU5vZGUuc3ByaW5nRm9yY2VZICs9IHNwcmluZ0ZvcmNlWTtcbiAgdGFyZ2V0Tm9kZS5zcHJpbmdGb3JjZVggLT0gc3ByaW5nRm9yY2VYO1xuICB0YXJnZXROb2RlLnNwcmluZ0ZvcmNlWSAtPSBzcHJpbmdGb3JjZVk7XG59O1xuXG5GRExheW91dC5wcm90b3R5cGUuY2FsY1JlcHVsc2lvbkZvcmNlID0gZnVuY3Rpb24gKG5vZGVBLCBub2RlQikge1xuICB2YXIgcmVjdEEgPSBub2RlQS5nZXRSZWN0KCk7XG4gIHZhciByZWN0QiA9IG5vZGVCLmdldFJlY3QoKTtcbiAgdmFyIG92ZXJsYXBBbW91bnQgPSBuZXcgQXJyYXkoMik7XG4gIHZhciBjbGlwUG9pbnRzID0gbmV3IEFycmF5KDQpO1xuICB2YXIgZGlzdGFuY2VYO1xuICB2YXIgZGlzdGFuY2VZO1xuICB2YXIgZGlzdGFuY2VTcXVhcmVkO1xuICB2YXIgZGlzdGFuY2U7XG4gIHZhciByZXB1bHNpb25Gb3JjZTtcbiAgdmFyIHJlcHVsc2lvbkZvcmNlWDtcbiAgdmFyIHJlcHVsc2lvbkZvcmNlWTtcblxuICBpZiAocmVjdEEuaW50ZXJzZWN0cyhyZWN0QikpIC8vIHR3byBub2RlcyBvdmVybGFwXG4gICAge1xuICAgICAgLy8gY2FsY3VsYXRlIHNlcGFyYXRpb24gYW1vdW50IGluIHggYW5kIHkgZGlyZWN0aW9uc1xuICAgICAgSUdlb21ldHJ5LmNhbGNTZXBhcmF0aW9uQW1vdW50KHJlY3RBLCByZWN0Qiwgb3ZlcmxhcEFtb3VudCwgRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9FREdFX0xFTkdUSCAvIDIuMCk7XG5cbiAgICAgIHJlcHVsc2lvbkZvcmNlWCA9IDIgKiBvdmVybGFwQW1vdW50WzBdO1xuICAgICAgcmVwdWxzaW9uRm9yY2VZID0gMiAqIG92ZXJsYXBBbW91bnRbMV07XG5cbiAgICAgIHZhciBjaGlsZHJlbkNvbnN0YW50ID0gbm9kZUEubm9PZkNoaWxkcmVuICogbm9kZUIubm9PZkNoaWxkcmVuIC8gKG5vZGVBLm5vT2ZDaGlsZHJlbiArIG5vZGVCLm5vT2ZDaGlsZHJlbik7XG5cbiAgICAgIC8vIEFwcGx5IGZvcmNlcyBvbiB0aGUgdHdvIG5vZGVzXG4gICAgICBub2RlQS5yZXB1bHNpb25Gb3JjZVggLT0gY2hpbGRyZW5Db25zdGFudCAqIHJlcHVsc2lvbkZvcmNlWDtcbiAgICAgIG5vZGVBLnJlcHVsc2lvbkZvcmNlWSAtPSBjaGlsZHJlbkNvbnN0YW50ICogcmVwdWxzaW9uRm9yY2VZO1xuICAgICAgbm9kZUIucmVwdWxzaW9uRm9yY2VYICs9IGNoaWxkcmVuQ29uc3RhbnQgKiByZXB1bHNpb25Gb3JjZVg7XG4gICAgICBub2RlQi5yZXB1bHNpb25Gb3JjZVkgKz0gY2hpbGRyZW5Db25zdGFudCAqIHJlcHVsc2lvbkZvcmNlWTtcbiAgICB9IGVsc2UgLy8gbm8gb3ZlcmxhcFxuICAgIHtcbiAgICAgIC8vIGNhbGN1bGF0ZSBkaXN0YW5jZVxuXG4gICAgICBpZiAodGhpcy51bmlmb3JtTGVhZk5vZGVTaXplcyAmJiBub2RlQS5nZXRDaGlsZCgpID09IG51bGwgJiYgbm9kZUIuZ2V0Q2hpbGQoKSA9PSBudWxsKSAvLyBzaW1wbHkgYmFzZSByZXB1bHNpb24gb24gZGlzdGFuY2Ugb2Ygbm9kZSBjZW50ZXJzXG4gICAgICAgIHtcbiAgICAgICAgICBkaXN0YW5jZVggPSByZWN0Qi5nZXRDZW50ZXJYKCkgLSByZWN0QS5nZXRDZW50ZXJYKCk7XG4gICAgICAgICAgZGlzdGFuY2VZID0gcmVjdEIuZ2V0Q2VudGVyWSgpIC0gcmVjdEEuZ2V0Q2VudGVyWSgpO1xuICAgICAgICB9IGVsc2UgLy8gdXNlIGNsaXBwaW5nIHBvaW50c1xuICAgICAgICB7XG4gICAgICAgICAgSUdlb21ldHJ5LmdldEludGVyc2VjdGlvbihyZWN0QSwgcmVjdEIsIGNsaXBQb2ludHMpO1xuXG4gICAgICAgICAgZGlzdGFuY2VYID0gY2xpcFBvaW50c1syXSAtIGNsaXBQb2ludHNbMF07XG4gICAgICAgICAgZGlzdGFuY2VZID0gY2xpcFBvaW50c1szXSAtIGNsaXBQb2ludHNbMV07XG4gICAgICAgIH1cblxuICAgICAgLy8gTm8gcmVwdWxzaW9uIHJhbmdlLiBGUiBncmlkIHZhcmlhbnQgc2hvdWxkIHRha2UgY2FyZSBvZiB0aGlzLlxuICAgICAgaWYgKE1hdGguYWJzKGRpc3RhbmNlWCkgPCBGRExheW91dENvbnN0YW50cy5NSU5fUkVQVUxTSU9OX0RJU1QpIHtcbiAgICAgICAgZGlzdGFuY2VYID0gSU1hdGguc2lnbihkaXN0YW5jZVgpICogRkRMYXlvdXRDb25zdGFudHMuTUlOX1JFUFVMU0lPTl9ESVNUO1xuICAgICAgfVxuXG4gICAgICBpZiAoTWF0aC5hYnMoZGlzdGFuY2VZKSA8IEZETGF5b3V0Q29uc3RhbnRzLk1JTl9SRVBVTFNJT05fRElTVCkge1xuICAgICAgICBkaXN0YW5jZVkgPSBJTWF0aC5zaWduKGRpc3RhbmNlWSkgKiBGRExheW91dENvbnN0YW50cy5NSU5fUkVQVUxTSU9OX0RJU1Q7XG4gICAgICB9XG5cbiAgICAgIGRpc3RhbmNlU3F1YXJlZCA9IGRpc3RhbmNlWCAqIGRpc3RhbmNlWCArIGRpc3RhbmNlWSAqIGRpc3RhbmNlWTtcbiAgICAgIGRpc3RhbmNlID0gTWF0aC5zcXJ0KGRpc3RhbmNlU3F1YXJlZCk7XG5cbiAgICAgIHJlcHVsc2lvbkZvcmNlID0gdGhpcy5yZXB1bHNpb25Db25zdGFudCAqIG5vZGVBLm5vT2ZDaGlsZHJlbiAqIG5vZGVCLm5vT2ZDaGlsZHJlbiAvIGRpc3RhbmNlU3F1YXJlZDtcblxuICAgICAgLy8gUHJvamVjdCBmb3JjZSBvbnRvIHggYW5kIHkgYXhlc1xuICAgICAgcmVwdWxzaW9uRm9yY2VYID0gcmVwdWxzaW9uRm9yY2UgKiBkaXN0YW5jZVggLyBkaXN0YW5jZTtcbiAgICAgIHJlcHVsc2lvbkZvcmNlWSA9IHJlcHVsc2lvbkZvcmNlICogZGlzdGFuY2VZIC8gZGlzdGFuY2U7XG5cbiAgICAgIC8vIEFwcGx5IGZvcmNlcyBvbiB0aGUgdHdvIG5vZGVzICAgIFxuICAgICAgbm9kZUEucmVwdWxzaW9uRm9yY2VYIC09IHJlcHVsc2lvbkZvcmNlWDtcbiAgICAgIG5vZGVBLnJlcHVsc2lvbkZvcmNlWSAtPSByZXB1bHNpb25Gb3JjZVk7XG4gICAgICBub2RlQi5yZXB1bHNpb25Gb3JjZVggKz0gcmVwdWxzaW9uRm9yY2VYO1xuICAgICAgbm9kZUIucmVwdWxzaW9uRm9yY2VZICs9IHJlcHVsc2lvbkZvcmNlWTtcbiAgICB9XG59O1xuXG5GRExheW91dC5wcm90b3R5cGUuY2FsY0dyYXZpdGF0aW9uYWxGb3JjZSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIHZhciBvd25lckdyYXBoO1xuICB2YXIgb3duZXJDZW50ZXJYO1xuICB2YXIgb3duZXJDZW50ZXJZO1xuICB2YXIgZGlzdGFuY2VYO1xuICB2YXIgZGlzdGFuY2VZO1xuICB2YXIgYWJzRGlzdGFuY2VYO1xuICB2YXIgYWJzRGlzdGFuY2VZO1xuICB2YXIgZXN0aW1hdGVkU2l6ZTtcbiAgb3duZXJHcmFwaCA9IG5vZGUuZ2V0T3duZXIoKTtcblxuICBvd25lckNlbnRlclggPSAob3duZXJHcmFwaC5nZXRSaWdodCgpICsgb3duZXJHcmFwaC5nZXRMZWZ0KCkpIC8gMjtcbiAgb3duZXJDZW50ZXJZID0gKG93bmVyR3JhcGguZ2V0VG9wKCkgKyBvd25lckdyYXBoLmdldEJvdHRvbSgpKSAvIDI7XG4gIGRpc3RhbmNlWCA9IG5vZGUuZ2V0Q2VudGVyWCgpIC0gb3duZXJDZW50ZXJYO1xuICBkaXN0YW5jZVkgPSBub2RlLmdldENlbnRlclkoKSAtIG93bmVyQ2VudGVyWTtcbiAgYWJzRGlzdGFuY2VYID0gTWF0aC5hYnMoZGlzdGFuY2VYKSArIG5vZGUuZ2V0V2lkdGgoKSAvIDI7XG4gIGFic0Rpc3RhbmNlWSA9IE1hdGguYWJzKGRpc3RhbmNlWSkgKyBub2RlLmdldEhlaWdodCgpIC8gMjtcblxuICBpZiAobm9kZS5nZXRPd25lcigpID09IHRoaXMuZ3JhcGhNYW5hZ2VyLmdldFJvb3QoKSkgLy8gaW4gdGhlIHJvb3QgZ3JhcGhcbiAgICB7XG4gICAgICBlc3RpbWF0ZWRTaXplID0gb3duZXJHcmFwaC5nZXRFc3RpbWF0ZWRTaXplKCkgKiB0aGlzLmdyYXZpdHlSYW5nZUZhY3RvcjtcblxuICAgICAgaWYgKGFic0Rpc3RhbmNlWCA+IGVzdGltYXRlZFNpemUgfHwgYWJzRGlzdGFuY2VZID4gZXN0aW1hdGVkU2l6ZSkge1xuICAgICAgICBub2RlLmdyYXZpdGF0aW9uRm9yY2VYID0gLXRoaXMuZ3Jhdml0eUNvbnN0YW50ICogZGlzdGFuY2VYO1xuICAgICAgICBub2RlLmdyYXZpdGF0aW9uRm9yY2VZID0gLXRoaXMuZ3Jhdml0eUNvbnN0YW50ICogZGlzdGFuY2VZO1xuICAgICAgfVxuICAgIH0gZWxzZSAvLyBpbnNpZGUgYSBjb21wb3VuZFxuICAgIHtcbiAgICAgIGVzdGltYXRlZFNpemUgPSBvd25lckdyYXBoLmdldEVzdGltYXRlZFNpemUoKSAqIHRoaXMuY29tcG91bmRHcmF2aXR5UmFuZ2VGYWN0b3I7XG5cbiAgICAgIGlmIChhYnNEaXN0YW5jZVggPiBlc3RpbWF0ZWRTaXplIHx8IGFic0Rpc3RhbmNlWSA+IGVzdGltYXRlZFNpemUpIHtcbiAgICAgICAgbm9kZS5ncmF2aXRhdGlvbkZvcmNlWCA9IC10aGlzLmdyYXZpdHlDb25zdGFudCAqIGRpc3RhbmNlWCAqIHRoaXMuY29tcG91bmRHcmF2aXR5Q29uc3RhbnQ7XG4gICAgICAgIG5vZGUuZ3Jhdml0YXRpb25Gb3JjZVkgPSAtdGhpcy5ncmF2aXR5Q29uc3RhbnQgKiBkaXN0YW5jZVkgKiB0aGlzLmNvbXBvdW5kR3Jhdml0eUNvbnN0YW50O1xuICAgICAgfVxuICAgIH1cbn07XG5cbkZETGF5b3V0LnByb3RvdHlwZS5pc0NvbnZlcmdlZCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGNvbnZlcmdlZDtcbiAgdmFyIG9zY2lsYXRpbmcgPSBmYWxzZTtcblxuICBpZiAodGhpcy50b3RhbEl0ZXJhdGlvbnMgPiB0aGlzLm1heEl0ZXJhdGlvbnMgLyAzKSB7XG4gICAgb3NjaWxhdGluZyA9IE1hdGguYWJzKHRoaXMudG90YWxEaXNwbGFjZW1lbnQgLSB0aGlzLm9sZFRvdGFsRGlzcGxhY2VtZW50KSA8IDI7XG4gIH1cblxuICBjb252ZXJnZWQgPSB0aGlzLnRvdGFsRGlzcGxhY2VtZW50IDwgdGhpcy50b3RhbERpc3BsYWNlbWVudFRocmVzaG9sZDtcblxuICB0aGlzLm9sZFRvdGFsRGlzcGxhY2VtZW50ID0gdGhpcy50b3RhbERpc3BsYWNlbWVudDtcblxuICByZXR1cm4gY29udmVyZ2VkIHx8IG9zY2lsYXRpbmc7XG59O1xuXG5GRExheW91dC5wcm90b3R5cGUuYW5pbWF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuYW5pbWF0aW9uRHVyaW5nTGF5b3V0ICYmICF0aGlzLmlzU3ViTGF5b3V0KSB7XG4gICAgaWYgKHRoaXMubm90QW5pbWF0ZWRJdGVyYXRpb25zID09IHRoaXMuYW5pbWF0aW9uUGVyaW9kKSB7XG4gICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgICAgdGhpcy5ub3RBbmltYXRlZEl0ZXJhdGlvbnMgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm5vdEFuaW1hdGVkSXRlcmF0aW9ucysrO1xuICAgIH1cbiAgfVxufTtcblxuLy9UaGlzIG1ldGhvZCBjYWxjdWxhdGVzIHRoZSBudW1iZXIgb2YgY2hpbGRyZW4gKHdlaWdodCkgZm9yIGFsbCBub2Rlc1xuRkRMYXlvdXQucHJvdG90eXBlLmNhbGNOb09mQ2hpbGRyZW5Gb3JBbGxOb2RlcyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIG5vZGU7XG4gIHZhciBhbGxOb2RlcyA9IHRoaXMuZ3JhcGhNYW5hZ2VyLmdldEFsbE5vZGVzKCk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbGxOb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIG5vZGUgPSBhbGxOb2Rlc1tpXTtcbiAgICBub2RlLm5vT2ZDaGlsZHJlbiA9IG5vZGUuZ2V0Tm9PZkNoaWxkcmVuKCk7XG4gIH1cbn07XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBTZWN0aW9uOiBGUi1HcmlkIFZhcmlhbnQgUmVwdWxzaW9uIEZvcmNlIENhbGN1bGF0aW9uXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5GRExheW91dC5wcm90b3R5cGUuY2FsY0dyaWQgPSBmdW5jdGlvbiAoZ3JhcGgpIHtcblxuICB2YXIgc2l6ZVggPSAwO1xuICB2YXIgc2l6ZVkgPSAwO1xuXG4gIHNpemVYID0gcGFyc2VJbnQoTWF0aC5jZWlsKChncmFwaC5nZXRSaWdodCgpIC0gZ3JhcGguZ2V0TGVmdCgpKSAvIHRoaXMucmVwdWxzaW9uUmFuZ2UpKTtcbiAgc2l6ZVkgPSBwYXJzZUludChNYXRoLmNlaWwoKGdyYXBoLmdldEJvdHRvbSgpIC0gZ3JhcGguZ2V0VG9wKCkpIC8gdGhpcy5yZXB1bHNpb25SYW5nZSkpO1xuXG4gIHZhciBncmlkID0gbmV3IEFycmF5KHNpemVYKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHNpemVYOyBpKyspIHtcbiAgICBncmlkW2ldID0gbmV3IEFycmF5KHNpemVZKTtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZVg7IGkrKykge1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgc2l6ZVk7IGorKykge1xuICAgICAgZ3JpZFtpXVtqXSA9IG5ldyBBcnJheSgpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBncmlkO1xufTtcblxuRkRMYXlvdXQucHJvdG90eXBlLmFkZE5vZGVUb0dyaWQgPSBmdW5jdGlvbiAodiwgbGVmdCwgdG9wKSB7XG5cbiAgdmFyIHN0YXJ0WCA9IDA7XG4gIHZhciBmaW5pc2hYID0gMDtcbiAgdmFyIHN0YXJ0WSA9IDA7XG4gIHZhciBmaW5pc2hZID0gMDtcblxuICBzdGFydFggPSBwYXJzZUludChNYXRoLmZsb29yKCh2LmdldFJlY3QoKS54IC0gbGVmdCkgLyB0aGlzLnJlcHVsc2lvblJhbmdlKSk7XG4gIGZpbmlzaFggPSBwYXJzZUludChNYXRoLmZsb29yKCh2LmdldFJlY3QoKS53aWR0aCArIHYuZ2V0UmVjdCgpLnggLSBsZWZ0KSAvIHRoaXMucmVwdWxzaW9uUmFuZ2UpKTtcbiAgc3RhcnRZID0gcGFyc2VJbnQoTWF0aC5mbG9vcigodi5nZXRSZWN0KCkueSAtIHRvcCkgLyB0aGlzLnJlcHVsc2lvblJhbmdlKSk7XG4gIGZpbmlzaFkgPSBwYXJzZUludChNYXRoLmZsb29yKCh2LmdldFJlY3QoKS5oZWlnaHQgKyB2LmdldFJlY3QoKS55IC0gdG9wKSAvIHRoaXMucmVwdWxzaW9uUmFuZ2UpKTtcblxuICBmb3IgKHZhciBpID0gc3RhcnRYOyBpIDw9IGZpbmlzaFg7IGkrKykge1xuICAgIGZvciAodmFyIGogPSBzdGFydFk7IGogPD0gZmluaXNoWTsgaisrKSB7XG4gICAgICB0aGlzLmdyaWRbaV1bal0ucHVzaCh2KTtcbiAgICAgIHYuc2V0R3JpZENvb3JkaW5hdGVzKHN0YXJ0WCwgZmluaXNoWCwgc3RhcnRZLCBmaW5pc2hZKTtcbiAgICB9XG4gIH1cbn07XG5cbkZETGF5b3V0LnByb3RvdHlwZS51cGRhdGVHcmlkID0gZnVuY3Rpb24gKCkge1xuICB2YXIgaTtcbiAgdmFyIG5vZGVBO1xuICB2YXIgbE5vZGVzID0gdGhpcy5nZXRBbGxOb2RlcygpO1xuXG4gIHRoaXMuZ3JpZCA9IHRoaXMuY2FsY0dyaWQodGhpcy5ncmFwaE1hbmFnZXIuZ2V0Um9vdCgpKTtcblxuICAvLyBwdXQgYWxsIG5vZGVzIHRvIHByb3BlciBncmlkIGNlbGxzXG4gIGZvciAoaSA9IDA7IGkgPCBsTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICBub2RlQSA9IGxOb2Rlc1tpXTtcbiAgICB0aGlzLmFkZE5vZGVUb0dyaWQobm9kZUEsIHRoaXMuZ3JhcGhNYW5hZ2VyLmdldFJvb3QoKS5nZXRMZWZ0KCksIHRoaXMuZ3JhcGhNYW5hZ2VyLmdldFJvb3QoKS5nZXRUb3AoKSk7XG4gIH1cbn07XG5cbkZETGF5b3V0LnByb3RvdHlwZS5jYWxjdWxhdGVSZXB1bHNpb25Gb3JjZU9mQU5vZGUgPSBmdW5jdGlvbiAobm9kZUEsIHByb2Nlc3NlZE5vZGVTZXQsIGdyaWRVcGRhdGVBbGxvd2VkLCBmb3JjZVRvTm9kZVN1cnJvdW5kaW5nVXBkYXRlKSB7XG5cbiAgaWYgKHRoaXMudG90YWxJdGVyYXRpb25zICUgRkRMYXlvdXRDb25zdGFudHMuR1JJRF9DQUxDVUxBVElPTl9DSEVDS19QRVJJT0QgPT0gMSAmJiBncmlkVXBkYXRlQWxsb3dlZCB8fCBmb3JjZVRvTm9kZVN1cnJvdW5kaW5nVXBkYXRlKSB7XG4gICAgdmFyIHN1cnJvdW5kaW5nID0gbmV3IFNldCgpO1xuICAgIG5vZGVBLnN1cnJvdW5kaW5nID0gbmV3IEFycmF5KCk7XG4gICAgdmFyIG5vZGVCO1xuICAgIHZhciBncmlkID0gdGhpcy5ncmlkO1xuXG4gICAgZm9yICh2YXIgaSA9IG5vZGVBLnN0YXJ0WCAtIDE7IGkgPCBub2RlQS5maW5pc2hYICsgMjsgaSsrKSB7XG4gICAgICBmb3IgKHZhciBqID0gbm9kZUEuc3RhcnRZIC0gMTsgaiA8IG5vZGVBLmZpbmlzaFkgKyAyOyBqKyspIHtcbiAgICAgICAgaWYgKCEoaSA8IDAgfHwgaiA8IDAgfHwgaSA+PSBncmlkLmxlbmd0aCB8fCBqID49IGdyaWRbMF0ubGVuZ3RoKSkge1xuICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgZ3JpZFtpXVtqXS5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgbm9kZUIgPSBncmlkW2ldW2pdW2tdO1xuXG4gICAgICAgICAgICAvLyBJZiBib3RoIG5vZGVzIGFyZSBub3QgbWVtYmVycyBvZiB0aGUgc2FtZSBncmFwaCwgXG4gICAgICAgICAgICAvLyBvciBib3RoIG5vZGVzIGFyZSB0aGUgc2FtZSwgc2tpcC5cbiAgICAgICAgICAgIGlmIChub2RlQS5nZXRPd25lcigpICE9IG5vZGVCLmdldE93bmVyKCkgfHwgbm9kZUEgPT0gbm9kZUIpIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGNoZWNrIGlmIHRoZSByZXB1bHNpb24gZm9yY2UgYmV0d2VlblxuICAgICAgICAgICAgLy8gbm9kZUEgYW5kIG5vZGVCIGhhcyBhbHJlYWR5IGJlZW4gY2FsY3VsYXRlZFxuICAgICAgICAgICAgaWYgKCFwcm9jZXNzZWROb2RlU2V0Lmhhcyhub2RlQikgJiYgIXN1cnJvdW5kaW5nLmhhcyhub2RlQikpIHtcbiAgICAgICAgICAgICAgdmFyIGRpc3RhbmNlWCA9IE1hdGguYWJzKG5vZGVBLmdldENlbnRlclgoKSAtIG5vZGVCLmdldENlbnRlclgoKSkgLSAobm9kZUEuZ2V0V2lkdGgoKSAvIDIgKyBub2RlQi5nZXRXaWR0aCgpIC8gMik7XG4gICAgICAgICAgICAgIHZhciBkaXN0YW5jZVkgPSBNYXRoLmFicyhub2RlQS5nZXRDZW50ZXJZKCkgLSBub2RlQi5nZXRDZW50ZXJZKCkpIC0gKG5vZGVBLmdldEhlaWdodCgpIC8gMiArIG5vZGVCLmdldEhlaWdodCgpIC8gMik7XG5cbiAgICAgICAgICAgICAgLy8gaWYgdGhlIGRpc3RhbmNlIGJldHdlZW4gbm9kZUEgYW5kIG5vZGVCIFxuICAgICAgICAgICAgICAvLyBpcyBsZXNzIHRoZW4gY2FsY3VsYXRpb24gcmFuZ2VcbiAgICAgICAgICAgICAgaWYgKGRpc3RhbmNlWCA8PSB0aGlzLnJlcHVsc2lvblJhbmdlICYmIGRpc3RhbmNlWSA8PSB0aGlzLnJlcHVsc2lvblJhbmdlKSB7XG4gICAgICAgICAgICAgICAgLy90aGVuIGFkZCBub2RlQiB0byBzdXJyb3VuZGluZyBvZiBub2RlQVxuICAgICAgICAgICAgICAgIHN1cnJvdW5kaW5nLmFkZChub2RlQik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBub2RlQS5zdXJyb3VuZGluZyA9IFtdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkoc3Vycm91bmRpbmcpKTtcbiAgfVxuICBmb3IgKGkgPSAwOyBpIDwgbm9kZUEuc3Vycm91bmRpbmcubGVuZ3RoOyBpKyspIHtcbiAgICB0aGlzLmNhbGNSZXB1bHNpb25Gb3JjZShub2RlQSwgbm9kZUEuc3Vycm91bmRpbmdbaV0pO1xuICB9XG59O1xuXG5GRExheW91dC5wcm90b3R5cGUuY2FsY1JlcHVsc2lvblJhbmdlID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gMC4wO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBGRExheW91dDtcblxuLyoqKi8gfSksXG4vKiAxOSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgTEVkZ2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xudmFyIEZETGF5b3V0Q29uc3RhbnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KTtcblxuZnVuY3Rpb24gRkRMYXlvdXRFZGdlKHNvdXJjZSwgdGFyZ2V0LCB2RWRnZSkge1xuICBMRWRnZS5jYWxsKHRoaXMsIHNvdXJjZSwgdGFyZ2V0LCB2RWRnZSk7XG4gIHRoaXMuaWRlYWxMZW5ndGggPSBGRExheW91dENvbnN0YW50cy5ERUZBVUxUX0VER0VfTEVOR1RIO1xufVxuXG5GRExheW91dEVkZ2UucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShMRWRnZS5wcm90b3R5cGUpO1xuXG5mb3IgKHZhciBwcm9wIGluIExFZGdlKSB7XG4gIEZETGF5b3V0RWRnZVtwcm9wXSA9IExFZGdlW3Byb3BdO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEZETGF5b3V0RWRnZTtcblxuLyoqKi8gfSksXG4vKiAyMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgTE5vZGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXG5mdW5jdGlvbiBGRExheW91dE5vZGUoZ20sIGxvYywgc2l6ZSwgdk5vZGUpIHtcbiAgLy8gYWx0ZXJuYXRpdmUgY29uc3RydWN0b3IgaXMgaGFuZGxlZCBpbnNpZGUgTE5vZGVcbiAgTE5vZGUuY2FsbCh0aGlzLCBnbSwgbG9jLCBzaXplLCB2Tm9kZSk7XG4gIC8vU3ByaW5nLCByZXB1bHNpb24gYW5kIGdyYXZpdGF0aW9uYWwgZm9yY2VzIGFjdGluZyBvbiB0aGlzIG5vZGVcbiAgdGhpcy5zcHJpbmdGb3JjZVggPSAwO1xuICB0aGlzLnNwcmluZ0ZvcmNlWSA9IDA7XG4gIHRoaXMucmVwdWxzaW9uRm9yY2VYID0gMDtcbiAgdGhpcy5yZXB1bHNpb25Gb3JjZVkgPSAwO1xuICB0aGlzLmdyYXZpdGF0aW9uRm9yY2VYID0gMDtcbiAgdGhpcy5ncmF2aXRhdGlvbkZvcmNlWSA9IDA7XG4gIC8vQW1vdW50IGJ5IHdoaWNoIHRoaXMgbm9kZSBpcyB0byBiZSBtb3ZlZCBpbiB0aGlzIGl0ZXJhdGlvblxuICB0aGlzLmRpc3BsYWNlbWVudFggPSAwO1xuICB0aGlzLmRpc3BsYWNlbWVudFkgPSAwO1xuXG4gIC8vU3RhcnQgYW5kIGZpbmlzaCBncmlkIGNvb3JkaW5hdGVzIHRoYXQgdGhpcyBub2RlIGlzIGZhbGxlbiBpbnRvXG4gIHRoaXMuc3RhcnRYID0gMDtcbiAgdGhpcy5maW5pc2hYID0gMDtcbiAgdGhpcy5zdGFydFkgPSAwO1xuICB0aGlzLmZpbmlzaFkgPSAwO1xuXG4gIC8vR2VvbWV0cmljIG5laWdoYm9ycyBvZiB0aGlzIG5vZGVcbiAgdGhpcy5zdXJyb3VuZGluZyA9IFtdO1xufVxuXG5GRExheW91dE5vZGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShMTm9kZS5wcm90b3R5cGUpO1xuXG5mb3IgKHZhciBwcm9wIGluIExOb2RlKSB7XG4gIEZETGF5b3V0Tm9kZVtwcm9wXSA9IExOb2RlW3Byb3BdO1xufVxuXG5GRExheW91dE5vZGUucHJvdG90eXBlLnNldEdyaWRDb29yZGluYXRlcyA9IGZ1bmN0aW9uIChfc3RhcnRYLCBfZmluaXNoWCwgX3N0YXJ0WSwgX2ZpbmlzaFkpIHtcbiAgdGhpcy5zdGFydFggPSBfc3RhcnRYO1xuICB0aGlzLmZpbmlzaFggPSBfZmluaXNoWDtcbiAgdGhpcy5zdGFydFkgPSBfc3RhcnRZO1xuICB0aGlzLmZpbmlzaFkgPSBfZmluaXNoWTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRkRMYXlvdXROb2RlO1xuXG4vKioqLyB9KSxcbi8qIDIxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbmZ1bmN0aW9uIERpbWVuc2lvbkQod2lkdGgsIGhlaWdodCkge1xuICB0aGlzLndpZHRoID0gMDtcbiAgdGhpcy5oZWlnaHQgPSAwO1xuICBpZiAod2lkdGggIT09IG51bGwgJiYgaGVpZ2h0ICE9PSBudWxsKSB7XG4gICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICB9XG59XG5cbkRpbWVuc2lvbkQucHJvdG90eXBlLmdldFdpZHRoID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy53aWR0aDtcbn07XG5cbkRpbWVuc2lvbkQucHJvdG90eXBlLnNldFdpZHRoID0gZnVuY3Rpb24gKHdpZHRoKSB7XG4gIHRoaXMud2lkdGggPSB3aWR0aDtcbn07XG5cbkRpbWVuc2lvbkQucHJvdG90eXBlLmdldEhlaWdodCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuaGVpZ2h0O1xufTtcblxuRGltZW5zaW9uRC5wcm90b3R5cGUuc2V0SGVpZ2h0ID0gZnVuY3Rpb24gKGhlaWdodCkge1xuICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRGltZW5zaW9uRDtcblxuLyoqKi8gfSksXG4vKiAyMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgVW5pcXVlSURHZW5lcmV0b3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0KTtcblxuZnVuY3Rpb24gSGFzaE1hcCgpIHtcbiAgdGhpcy5tYXAgPSB7fTtcbiAgdGhpcy5rZXlzID0gW107XG59XG5cbkhhc2hNYXAucHJvdG90eXBlLnB1dCA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gIHZhciB0aGVJZCA9IFVuaXF1ZUlER2VuZXJldG9yLmNyZWF0ZUlEKGtleSk7XG4gIGlmICghdGhpcy5jb250YWlucyh0aGVJZCkpIHtcbiAgICB0aGlzLm1hcFt0aGVJZF0gPSB2YWx1ZTtcbiAgICB0aGlzLmtleXMucHVzaChrZXkpO1xuICB9XG59O1xuXG5IYXNoTWFwLnByb3RvdHlwZS5jb250YWlucyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgdmFyIHRoZUlkID0gVW5pcXVlSURHZW5lcmV0b3IuY3JlYXRlSUQoa2V5KTtcbiAgcmV0dXJuIHRoaXMubWFwW2tleV0gIT0gbnVsbDtcbn07XG5cbkhhc2hNYXAucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgdmFyIHRoZUlkID0gVW5pcXVlSURHZW5lcmV0b3IuY3JlYXRlSUQoa2V5KTtcbiAgcmV0dXJuIHRoaXMubWFwW3RoZUlkXTtcbn07XG5cbkhhc2hNYXAucHJvdG90eXBlLmtleVNldCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMua2V5cztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gSGFzaE1hcDtcblxuLyoqKi8gfSksXG4vKiAyMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgVW5pcXVlSURHZW5lcmV0b3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0KTtcblxuZnVuY3Rpb24gSGFzaFNldCgpIHtcbiAgdGhpcy5zZXQgPSB7fTtcbn1cbjtcblxuSGFzaFNldC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKG9iaikge1xuICB2YXIgdGhlSWQgPSBVbmlxdWVJREdlbmVyZXRvci5jcmVhdGVJRChvYmopO1xuICBpZiAoIXRoaXMuY29udGFpbnModGhlSWQpKSB0aGlzLnNldFt0aGVJZF0gPSBvYmo7XG59O1xuXG5IYXNoU2V0LnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAob2JqKSB7XG4gIGRlbGV0ZSB0aGlzLnNldFtVbmlxdWVJREdlbmVyZXRvci5jcmVhdGVJRChvYmopXTtcbn07XG5cbkhhc2hTZXQucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLnNldCA9IHt9O1xufTtcblxuSGFzaFNldC5wcm90b3R5cGUuY29udGFpbnMgPSBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiB0aGlzLnNldFtVbmlxdWVJREdlbmVyZXRvci5jcmVhdGVJRChvYmopXSA9PSBvYmo7XG59O1xuXG5IYXNoU2V0LnByb3RvdHlwZS5pc0VtcHR5ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5zaXplKCkgPT09IDA7XG59O1xuXG5IYXNoU2V0LnByb3RvdHlwZS5zaXplID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5zZXQpLmxlbmd0aDtcbn07XG5cbi8vY29uY2F0cyB0aGlzLnNldCB0byB0aGUgZ2l2ZW4gbGlzdFxuSGFzaFNldC5wcm90b3R5cGUuYWRkQWxsVG8gPSBmdW5jdGlvbiAobGlzdCkge1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHRoaXMuc2V0KTtcbiAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgbGlzdC5wdXNoKHRoaXMuc2V0W2tleXNbaV1dKTtcbiAgfVxufTtcblxuSGFzaFNldC5wcm90b3R5cGUuc2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuc2V0KS5sZW5ndGg7XG59O1xuXG5IYXNoU2V0LnByb3RvdHlwZS5hZGRBbGwgPSBmdW5jdGlvbiAobGlzdCkge1xuICB2YXIgcyA9IGxpc3QubGVuZ3RoO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHM7IGkrKykge1xuICAgIHZhciB2ID0gbGlzdFtpXTtcbiAgICB0aGlzLmFkZCh2KTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBIYXNoU2V0O1xuXG4vKioqLyB9KSxcbi8qIDI0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbi8qKlxuICogQSBjbGFzc2ljIFF1aWNrc29ydCBhbGdvcml0aG0gd2l0aCBIb2FyZSdzIHBhcnRpdGlvblxuICogLSBXb3JrcyBhbHNvIG9uIExpbmtlZExpc3Qgb2JqZWN0c1xuICpcbiAqIENvcHlyaWdodDogaS1WaXMgUmVzZWFyY2ggR3JvdXAsIEJpbGtlbnQgVW5pdmVyc2l0eSwgMjAwNyAtIHByZXNlbnRcbiAqL1xuXG52YXIgTGlua2VkTGlzdCA9IF9fd2VicGFja19yZXF1aXJlX18oMTEpO1xuXG52YXIgUXVpY2tzb3J0ID0gZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFF1aWNrc29ydChBLCBjb21wYXJlRnVuY3Rpb24pIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFF1aWNrc29ydCk7XG5cbiAgICAgICAgaWYgKGNvbXBhcmVGdW5jdGlvbiAhPT0gbnVsbCB8fCBjb21wYXJlRnVuY3Rpb24gIT09IHVuZGVmaW5lZCkgdGhpcy5jb21wYXJlRnVuY3Rpb24gPSB0aGlzLl9kZWZhdWx0Q29tcGFyZUZ1bmN0aW9uO1xuXG4gICAgICAgIHZhciBsZW5ndGggPSB2b2lkIDA7XG4gICAgICAgIGlmIChBIGluc3RhbmNlb2YgTGlua2VkTGlzdCkgbGVuZ3RoID0gQS5zaXplKCk7ZWxzZSBsZW5ndGggPSBBLmxlbmd0aDtcblxuICAgICAgICB0aGlzLl9xdWlja3NvcnQoQSwgMCwgbGVuZ3RoIC0gMSk7XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKFF1aWNrc29ydCwgW3tcbiAgICAgICAga2V5OiAnX3F1aWNrc29ydCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfcXVpY2tzb3J0KEEsIHAsIHIpIHtcbiAgICAgICAgICAgIGlmIChwIDwgcikge1xuICAgICAgICAgICAgICAgIHZhciBxID0gdGhpcy5fcGFydGl0aW9uKEEsIHAsIHIpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3F1aWNrc29ydChBLCBwLCBxKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9xdWlja3NvcnQoQSwgcSArIDEsIHIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdfcGFydGl0aW9uJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9wYXJ0aXRpb24oQSwgcCwgcikge1xuICAgICAgICAgICAgdmFyIHggPSB0aGlzLl9nZXQoQSwgcCk7XG4gICAgICAgICAgICB2YXIgaSA9IHA7XG4gICAgICAgICAgICB2YXIgaiA9IHI7XG4gICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgICAgIHdoaWxlICh0aGlzLmNvbXBhcmVGdW5jdGlvbih4LCB0aGlzLl9nZXQoQSwgaikpKSB7XG4gICAgICAgICAgICAgICAgICAgIGotLTtcbiAgICAgICAgICAgICAgICB9d2hpbGUgKHRoaXMuY29tcGFyZUZ1bmN0aW9uKHRoaXMuX2dldChBLCBpKSwgeCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgIH1pZiAoaSA8IGopIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3dhcChBLCBpLCBqKTtcbiAgICAgICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgICAgICBqLS07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHJldHVybiBqO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdfZ2V0JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXQob2JqZWN0LCBpbmRleCkge1xuICAgICAgICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIExpbmtlZExpc3QpIHJldHVybiBvYmplY3QuZ2V0X29iamVjdF9hdChpbmRleCk7ZWxzZSByZXR1cm4gb2JqZWN0W2luZGV4XTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnX3NldCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0KG9iamVjdCwgaW5kZXgsIHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgTGlua2VkTGlzdCkgb2JqZWN0LnNldF9vYmplY3RfYXQoaW5kZXgsIHZhbHVlKTtlbHNlIG9iamVjdFtpbmRleF0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnX3N3YXAnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX3N3YXAoQSwgaSwgaikge1xuICAgICAgICAgICAgdmFyIHRlbXAgPSB0aGlzLl9nZXQoQSwgaSk7XG4gICAgICAgICAgICB0aGlzLl9zZXQoQSwgaSwgdGhpcy5fZ2V0KEEsIGopKTtcbiAgICAgICAgICAgIHRoaXMuX3NldChBLCBqLCB0ZW1wKTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnX2RlZmF1bHRDb21wYXJlRnVuY3Rpb24nLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2RlZmF1bHRDb21wYXJlRnVuY3Rpb24oYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuIGIgPiBhO1xuICAgICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIFF1aWNrc29ydDtcbn0oKTtcblxubW9kdWxlLmV4cG9ydHMgPSBRdWlja3NvcnQ7XG5cbi8qKiovIH0pLFxuLyogMjUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuLyoqXG4gKiAgIE5lZWRsZW1hbi1XdW5zY2ggYWxnb3JpdGhtIGlzIGFuIHByb2NlZHVyZSB0byBjb21wdXRlIHRoZSBvcHRpbWFsIGdsb2JhbCBhbGlnbm1lbnQgb2YgdHdvIHN0cmluZ1xuICogICBzZXF1ZW5jZXMgYnkgUy5CLk5lZWRsZW1hbiBhbmQgQy5ELld1bnNjaCAoMTk3MCkuXG4gKlxuICogICBBc2lkZSBmcm9tIHRoZSBpbnB1dHMsIHlvdSBjYW4gYXNzaWduIHRoZSBzY29yZXMgZm9yLFxuICogICAtIE1hdGNoOiBUaGUgdHdvIGNoYXJhY3RlcnMgYXQgdGhlIGN1cnJlbnQgaW5kZXggYXJlIHNhbWUuXG4gKiAgIC0gTWlzbWF0Y2g6IFRoZSB0d28gY2hhcmFjdGVycyBhdCB0aGUgY3VycmVudCBpbmRleCBhcmUgZGlmZmVyZW50LlxuICogICAtIEluc2VydGlvbi9EZWxldGlvbihnYXBzKTogVGhlIGJlc3QgYWxpZ25tZW50IGludm9sdmVzIG9uZSBsZXR0ZXIgYWxpZ25pbmcgdG8gYSBnYXAgaW4gdGhlIG90aGVyIHN0cmluZy5cbiAqL1xuXG52YXIgTmVlZGxlbWFuV3Vuc2NoID0gZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE5lZWRsZW1hbld1bnNjaChzZXF1ZW5jZTEsIHNlcXVlbmNlMikge1xuICAgICAgICB2YXIgbWF0Y2hfc2NvcmUgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IDE7XG4gICAgICAgIHZhciBtaXNtYXRjaF9wZW5hbHR5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiAtMTtcbiAgICAgICAgdmFyIGdhcF9wZW5hbHR5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgJiYgYXJndW1lbnRzWzRdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNF0gOiAtMTtcblxuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTmVlZGxlbWFuV3Vuc2NoKTtcblxuICAgICAgICB0aGlzLnNlcXVlbmNlMSA9IHNlcXVlbmNlMTtcbiAgICAgICAgdGhpcy5zZXF1ZW5jZTIgPSBzZXF1ZW5jZTI7XG4gICAgICAgIHRoaXMubWF0Y2hfc2NvcmUgPSBtYXRjaF9zY29yZTtcbiAgICAgICAgdGhpcy5taXNtYXRjaF9wZW5hbHR5ID0gbWlzbWF0Y2hfcGVuYWx0eTtcbiAgICAgICAgdGhpcy5nYXBfcGVuYWx0eSA9IGdhcF9wZW5hbHR5O1xuXG4gICAgICAgIC8vIEp1c3QgdGhlIHJlbW92ZSByZWR1bmRhbmN5XG4gICAgICAgIHRoaXMuaU1heCA9IHNlcXVlbmNlMS5sZW5ndGggKyAxO1xuICAgICAgICB0aGlzLmpNYXggPSBzZXF1ZW5jZTIubGVuZ3RoICsgMTtcblxuICAgICAgICAvLyBHcmlkIG1hdHJpeCBvZiBzY29yZXNcbiAgICAgICAgdGhpcy5ncmlkID0gbmV3IEFycmF5KHRoaXMuaU1heCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5pTWF4OyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuZ3JpZFtpXSA9IG5ldyBBcnJheSh0aGlzLmpNYXgpO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRoaXMuak1heDsgaisrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ncmlkW2ldW2pdID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRyYWNlYmFjayBtYXRyaXggKDJEIGFycmF5LCBlYWNoIGNlbGwgaXMgYW4gYXJyYXkgb2YgYm9vbGVhbiB2YWx1ZXMgZm9yIFtgRGlhZ2AsIGBVcGAsIGBMZWZ0YF0gcG9zaXRpb25zKVxuICAgICAgICB0aGlzLnRyYWNlYmFja0dyaWQgPSBuZXcgQXJyYXkodGhpcy5pTWF4KTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IHRoaXMuaU1heDsgX2krKykge1xuICAgICAgICAgICAgdGhpcy50cmFjZWJhY2tHcmlkW19pXSA9IG5ldyBBcnJheSh0aGlzLmpNYXgpO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBfaiA9IDA7IF9qIDwgdGhpcy5qTWF4OyBfaisrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50cmFjZWJhY2tHcmlkW19pXVtfal0gPSBbbnVsbCwgbnVsbCwgbnVsbF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUaGUgYWxpZ25lZCBzZXF1ZW5jZXMgKHJldHVybiBtdWx0aXBsZSBwb3NzaWJpbGl0aWVzKVxuICAgICAgICB0aGlzLmFsaWdubWVudHMgPSBbXTtcblxuICAgICAgICAvLyBGaW5hbCBhbGlnbm1lbnQgc2NvcmVcbiAgICAgICAgdGhpcy5zY29yZSA9IC0xO1xuXG4gICAgICAgIC8vIENhbGN1bGF0ZSBzY29yZXMgYW5kIHRyYWNlYmFja3NcbiAgICAgICAgdGhpcy5jb21wdXRlR3JpZHMoKTtcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoTmVlZGxlbWFuV3Vuc2NoLCBbe1xuICAgICAgICBrZXk6IFwiZ2V0U2NvcmVcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldFNjb3JlKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2NvcmU7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogXCJnZXRBbGlnbm1lbnRzXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRBbGlnbm1lbnRzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWxpZ25tZW50cztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE1haW4gZHluYW1pYyBwcm9ncmFtbWluZyBwcm9jZWR1cmVcblxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcImNvbXB1dGVHcmlkc1wiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY29tcHV0ZUdyaWRzKCkge1xuICAgICAgICAgICAgLy8gRmlsbCBpbiB0aGUgZmlyc3Qgcm93XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMTsgaiA8IHRoaXMuak1heDsgaisrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ncmlkWzBdW2pdID0gdGhpcy5ncmlkWzBdW2ogLSAxXSArIHRoaXMuZ2FwX3BlbmFsdHk7XG4gICAgICAgICAgICAgICAgdGhpcy50cmFjZWJhY2tHcmlkWzBdW2pdID0gW2ZhbHNlLCBmYWxzZSwgdHJ1ZV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEZpbGwgaW4gdGhlIGZpcnN0IGNvbHVtblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCB0aGlzLmlNYXg7IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JpZFtpXVswXSA9IHRoaXMuZ3JpZFtpIC0gMV1bMF0gKyB0aGlzLmdhcF9wZW5hbHR5O1xuICAgICAgICAgICAgICAgIHRoaXMudHJhY2ViYWNrR3JpZFtpXVswXSA9IFtmYWxzZSwgdHJ1ZSwgZmFsc2VdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBGaWxsIHRoZSByZXN0IG9mIHRoZSBncmlkXG4gICAgICAgICAgICBmb3IgKHZhciBfaTIgPSAxOyBfaTIgPCB0aGlzLmlNYXg7IF9pMisrKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2oyID0gMTsgX2oyIDwgdGhpcy5qTWF4OyBfajIrKykge1xuICAgICAgICAgICAgICAgICAgICAvLyBGaW5kIHRoZSBtYXggc2NvcmUocykgYW1vbmcgW2BEaWFnYCwgYFVwYCwgYExlZnRgXVxuICAgICAgICAgICAgICAgICAgICB2YXIgZGlhZyA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc2VxdWVuY2UxW19pMiAtIDFdID09PSB0aGlzLnNlcXVlbmNlMltfajIgLSAxXSkgZGlhZyA9IHRoaXMuZ3JpZFtfaTIgLSAxXVtfajIgLSAxXSArIHRoaXMubWF0Y2hfc2NvcmU7ZWxzZSBkaWFnID0gdGhpcy5ncmlkW19pMiAtIDFdW19qMiAtIDFdICsgdGhpcy5taXNtYXRjaF9wZW5hbHR5O1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciB1cCA9IHRoaXMuZ3JpZFtfaTIgLSAxXVtfajJdICsgdGhpcy5nYXBfcGVuYWx0eTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxlZnQgPSB0aGlzLmdyaWRbX2kyXVtfajIgLSAxXSArIHRoaXMuZ2FwX3BlbmFsdHk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlcmUgZXhpc3RzIG11bHRpcGxlIG1heCB2YWx1ZXMsIGNhcHR1cmUgdGhlbSBmb3IgbXVsdGlwbGUgcGF0aHNcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1heE9mID0gW2RpYWcsIHVwLCBsZWZ0XTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluZGljZXMgPSB0aGlzLmFycmF5QWxsTWF4SW5kZXhlcyhtYXhPZik7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gVXBkYXRlIEdyaWRzXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ3JpZFtfaTJdW19qMl0gPSBtYXhPZltpbmRpY2VzWzBdXTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50cmFjZWJhY2tHcmlkW19pMl1bX2oyXSA9IFtpbmRpY2VzLmluY2x1ZGVzKDApLCBpbmRpY2VzLmluY2x1ZGVzKDEpLCBpbmRpY2VzLmluY2x1ZGVzKDIpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFVwZGF0ZSBhbGlnbm1lbnQgc2NvcmVcbiAgICAgICAgICAgIHRoaXMuc2NvcmUgPSB0aGlzLmdyaWRbdGhpcy5pTWF4IC0gMV1bdGhpcy5qTWF4IC0gMV07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBHZXRzIGFsbCBwb3NzaWJsZSB2YWxpZCBzZXF1ZW5jZSBjb21iaW5hdGlvbnNcblxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcImFsaWdubWVudFRyYWNlYmFja1wiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gYWxpZ25tZW50VHJhY2ViYWNrKCkge1xuICAgICAgICAgICAgdmFyIGluUHJvY2Vzc0FsaWdubWVudHMgPSBbXTtcblxuICAgICAgICAgICAgaW5Qcm9jZXNzQWxpZ25tZW50cy5wdXNoKHsgcG9zOiBbdGhpcy5zZXF1ZW5jZTEubGVuZ3RoLCB0aGlzLnNlcXVlbmNlMi5sZW5ndGhdLFxuICAgICAgICAgICAgICAgIHNlcTE6IFwiXCIsXG4gICAgICAgICAgICAgICAgc2VxMjogXCJcIlxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHdoaWxlIChpblByb2Nlc3NBbGlnbm1lbnRzWzBdKSB7XG4gICAgICAgICAgICAgICAgdmFyIGN1cnJlbnQgPSBpblByb2Nlc3NBbGlnbm1lbnRzWzBdO1xuICAgICAgICAgICAgICAgIHZhciBkaXJlY3Rpb25zID0gdGhpcy50cmFjZWJhY2tHcmlkW2N1cnJlbnQucG9zWzBdXVtjdXJyZW50LnBvc1sxXV07XG5cbiAgICAgICAgICAgICAgICBpZiAoZGlyZWN0aW9uc1swXSkge1xuICAgICAgICAgICAgICAgICAgICBpblByb2Nlc3NBbGlnbm1lbnRzLnB1c2goeyBwb3M6IFtjdXJyZW50LnBvc1swXSAtIDEsIGN1cnJlbnQucG9zWzFdIC0gMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXExOiB0aGlzLnNlcXVlbmNlMVtjdXJyZW50LnBvc1swXSAtIDFdICsgY3VycmVudC5zZXExLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VxMjogdGhpcy5zZXF1ZW5jZTJbY3VycmVudC5wb3NbMV0gLSAxXSArIGN1cnJlbnQuc2VxMlxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGRpcmVjdGlvbnNbMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgaW5Qcm9jZXNzQWxpZ25tZW50cy5wdXNoKHsgcG9zOiBbY3VycmVudC5wb3NbMF0gLSAxLCBjdXJyZW50LnBvc1sxXV0sXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXExOiB0aGlzLnNlcXVlbmNlMVtjdXJyZW50LnBvc1swXSAtIDFdICsgY3VycmVudC5zZXExLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VxMjogJy0nICsgY3VycmVudC5zZXEyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZGlyZWN0aW9uc1syXSkge1xuICAgICAgICAgICAgICAgICAgICBpblByb2Nlc3NBbGlnbm1lbnRzLnB1c2goeyBwb3M6IFtjdXJyZW50LnBvc1swXSwgY3VycmVudC5wb3NbMV0gLSAxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcTE6ICctJyArIGN1cnJlbnQuc2VxMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcTI6IHRoaXMuc2VxdWVuY2UyW2N1cnJlbnQucG9zWzFdIC0gMV0gKyBjdXJyZW50LnNlcTJcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnQucG9zWzBdID09PSAwICYmIGN1cnJlbnQucG9zWzFdID09PSAwKSB0aGlzLmFsaWdubWVudHMucHVzaCh7IHNlcXVlbmNlMTogY3VycmVudC5zZXExLFxuICAgICAgICAgICAgICAgICAgICBzZXF1ZW5jZTI6IGN1cnJlbnQuc2VxMlxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgaW5Qcm9jZXNzQWxpZ25tZW50cy5zaGlmdCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hbGlnbm1lbnRzO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSGVscGVyIEZ1bmN0aW9uc1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6IFwiZ2V0QWxsSW5kZXhlc1wiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0QWxsSW5kZXhlcyhhcnIsIHZhbCkge1xuICAgICAgICAgICAgdmFyIGluZGV4ZXMgPSBbXSxcbiAgICAgICAgICAgICAgICBpID0gLTE7XG4gICAgICAgICAgICB3aGlsZSAoKGkgPSBhcnIuaW5kZXhPZih2YWwsIGkgKyAxKSkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgaW5kZXhlcy5wdXNoKGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGluZGV4ZXM7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogXCJhcnJheUFsbE1heEluZGV4ZXNcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGFycmF5QWxsTWF4SW5kZXhlcyhhcnJheSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QWxsSW5kZXhlcyhhcnJheSwgTWF0aC5tYXguYXBwbHkobnVsbCwgYXJyYXkpKTtcbiAgICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBOZWVkbGVtYW5XdW5zY2g7XG59KCk7XG5cbm1vZHVsZS5leHBvcnRzID0gTmVlZGxlbWFuV3Vuc2NoO1xuXG4vKioqLyB9KSxcbi8qIDI2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBsYXlvdXRCYXNlID0gZnVuY3Rpb24gbGF5b3V0QmFzZSgpIHtcbiAgcmV0dXJuO1xufTtcblxubGF5b3V0QmFzZS5GRExheW91dCA9IF9fd2VicGFja19yZXF1aXJlX18oMTgpO1xubGF5b3V0QmFzZS5GRExheW91dENvbnN0YW50cyA9IF9fd2VicGFja19yZXF1aXJlX18oNyk7XG5sYXlvdXRCYXNlLkZETGF5b3V0RWRnZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTkpO1xubGF5b3V0QmFzZS5GRExheW91dE5vZGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIwKTtcbmxheW91dEJhc2UuRGltZW5zaW9uRCA9IF9fd2VicGFja19yZXF1aXJlX18oMjEpO1xubGF5b3V0QmFzZS5IYXNoTWFwID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMik7XG5sYXlvdXRCYXNlLkhhc2hTZXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIzKTtcbmxheW91dEJhc2UuSUdlb21ldHJ5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4KTtcbmxheW91dEJhc2UuSU1hdGggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkpO1xubGF5b3V0QmFzZS5JbnRlZ2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMCk7XG5sYXlvdXRCYXNlLlBvaW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMik7XG5sYXlvdXRCYXNlLlBvaW50RCA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG5sYXlvdXRCYXNlLlJhbmRvbVNlZWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE2KTtcbmxheW91dEJhc2UuUmVjdGFuZ2xlRCA9IF9fd2VicGFja19yZXF1aXJlX18oMTMpO1xubGF5b3V0QmFzZS5UcmFuc2Zvcm0gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE3KTtcbmxheW91dEJhc2UuVW5pcXVlSURHZW5lcmV0b3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0KTtcbmxheW91dEJhc2UuUXVpY2tzb3J0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNCk7XG5sYXlvdXRCYXNlLkxpbmtlZExpc3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKTtcbmxheW91dEJhc2UuTEdyYXBoT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcbmxheW91dEJhc2UuTEdyYXBoID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbmxheW91dEJhc2UuTEVkZ2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xubGF5b3V0QmFzZS5MR3JhcGhNYW5hZ2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcbmxheW91dEJhc2UuTE5vZGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xubGF5b3V0QmFzZS5MYXlvdXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE1KTtcbmxheW91dEJhc2UuTGF5b3V0Q29uc3RhbnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbmxheW91dEJhc2UuTmVlZGxlbWFuV3Vuc2NoID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNSk7XG5cbm1vZHVsZS5leHBvcnRzID0gbGF5b3V0QmFzZTtcblxuLyoqKi8gfSksXG4vKiAyNyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5mdW5jdGlvbiBFbWl0dGVyKCkge1xuICB0aGlzLmxpc3RlbmVycyA9IFtdO1xufVxuXG52YXIgcCA9IEVtaXR0ZXIucHJvdG90eXBlO1xuXG5wLmFkZExpc3RlbmVyID0gZnVuY3Rpb24gKGV2ZW50LCBjYWxsYmFjaykge1xuICB0aGlzLmxpc3RlbmVycy5wdXNoKHtcbiAgICBldmVudDogZXZlbnQsXG4gICAgY2FsbGJhY2s6IGNhbGxiYWNrXG4gIH0pO1xufTtcblxucC5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uIChldmVudCwgY2FsbGJhY2spIHtcbiAgZm9yICh2YXIgaSA9IHRoaXMubGlzdGVuZXJzLmxlbmd0aDsgaSA+PSAwOyBpLS0pIHtcbiAgICB2YXIgbCA9IHRoaXMubGlzdGVuZXJzW2ldO1xuXG4gICAgaWYgKGwuZXZlbnQgPT09IGV2ZW50ICYmIGwuY2FsbGJhY2sgPT09IGNhbGxiYWNrKSB7XG4gICAgICB0aGlzLmxpc3RlbmVycy5zcGxpY2UoaSwgMSk7XG4gICAgfVxuICB9XG59O1xuXG5wLmVtaXQgPSBmdW5jdGlvbiAoZXZlbnQsIGRhdGEpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxpc3RlbmVycy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBsID0gdGhpcy5saXN0ZW5lcnNbaV07XG5cbiAgICBpZiAoZXZlbnQgPT09IGwuZXZlbnQpIHtcbiAgICAgIGwuY2FsbGJhY2soZGF0YSk7XG4gICAgfVxuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEVtaXR0ZXI7XG5cbi8qKiovIH0pXG4vKioqKioqLyBdKTtcbn0pOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/layout-base/layout-base.js\n"));

/***/ }),

/***/ "./node_modules/cytoscape/dist/cytoscape.esm.mjs":
/*!*******************************************************!*\
  !*** ./node_modules/cytoscape/dist/cytoscape.esm.mjs ***!
  \*******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ cytoscape; }\n/* harmony export */ });\n/**\n * Copyright (c) 2016-2024, The Cytoscape Consortium.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of\n * this software and associated documentation files (the Software), to deal in\n * the Software without restriction, including without limitation the rights to\n * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\n * of the Software, and to permit persons to whom the Software is furnished to do\n * so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED AS IS, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  }, _typeof(obj);\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}\nfunction _defineProperty$1(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\nfunction _iterableToArrayLimit(arr, i) {\n  var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n  if (_i == null) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _s, _e;\n  try {\n    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n  return _arr;\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n  return arr2;\n}\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n  if (!it) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n      var F = function () {};\n      return {\n        s: F,\n        n: function () {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function (e) {\n          throw e;\n        },\n        f: F\n      };\n    }\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n  var normalCompletion = true,\n    didErr = false,\n    err;\n  return {\n    s: function () {\n      it = it.call(o);\n    },\n    n: function () {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function (e) {\n      didErr = true;\n      err = e;\n    },\n    f: function () {\n      try {\n        if (!normalCompletion && it.return != null) it.return();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nvar _window = typeof window === 'undefined' ? null : window; // eslint-disable-line no-undef\n\nvar navigator = _window ? _window.navigator : null;\n_window ? _window.document : null;\nvar typeofstr = _typeof('');\nvar typeofobj = _typeof({});\nvar typeoffn = _typeof(function () {});\nvar typeofhtmlele = typeof HTMLElement === \"undefined\" ? \"undefined\" : _typeof(HTMLElement);\nvar instanceStr = function instanceStr(obj) {\n  return obj && obj.instanceString && fn$6(obj.instanceString) ? obj.instanceString() : null;\n};\n\nvar string = function string(obj) {\n  return obj != null && _typeof(obj) == typeofstr;\n};\nvar fn$6 = function fn(obj) {\n  return obj != null && _typeof(obj) === typeoffn;\n};\nvar array = function array(obj) {\n  return !elementOrCollection(obj) && (Array.isArray ? Array.isArray(obj) : obj != null && obj instanceof Array);\n};\nvar plainObject = function plainObject(obj) {\n  return obj != null && _typeof(obj) === typeofobj && !array(obj) && obj.constructor === Object;\n};\nvar object = function object(obj) {\n  return obj != null && _typeof(obj) === typeofobj;\n};\nvar number$1 = function number(obj) {\n  return obj != null && _typeof(obj) === _typeof(1) && !isNaN(obj);\n};\nvar integer = function integer(obj) {\n  return number$1(obj) && Math.floor(obj) === obj;\n};\nvar htmlElement = function htmlElement(obj) {\n  if ('undefined' === typeofhtmlele) {\n    return undefined;\n  } else {\n    return null != obj && obj instanceof HTMLElement;\n  }\n};\nvar elementOrCollection = function elementOrCollection(obj) {\n  return element(obj) || collection(obj);\n};\nvar element = function element(obj) {\n  return instanceStr(obj) === 'collection' && obj._private.single;\n};\nvar collection = function collection(obj) {\n  return instanceStr(obj) === 'collection' && !obj._private.single;\n};\nvar core = function core(obj) {\n  return instanceStr(obj) === 'core';\n};\nvar stylesheet = function stylesheet(obj) {\n  return instanceStr(obj) === 'stylesheet';\n};\nvar event = function event(obj) {\n  return instanceStr(obj) === 'event';\n};\nvar emptyString = function emptyString(obj) {\n  if (obj === undefined || obj === null) {\n    // null is empty\n    return true;\n  } else if (obj === '' || obj.match(/^\\s+$/)) {\n    return true; // empty string is empty\n  }\n\n  return false; // otherwise, we don't know what we've got\n};\nvar domElement = function domElement(obj) {\n  if (typeof HTMLElement === 'undefined') {\n    return false; // we're not in a browser so it doesn't matter\n  } else {\n    return obj instanceof HTMLElement;\n  }\n};\nvar boundingBox = function boundingBox(obj) {\n  return plainObject(obj) && number$1(obj.x1) && number$1(obj.x2) && number$1(obj.y1) && number$1(obj.y2);\n};\nvar promise = function promise(obj) {\n  return object(obj) && fn$6(obj.then);\n};\nvar ms = function ms() {\n  return navigator && navigator.userAgent.match(/msie|trident|edge/i);\n}; // probably a better way to detect this...\n\nvar memoize$1 = function memoize(fn, keyFn) {\n  if (!keyFn) {\n    keyFn = function keyFn() {\n      if (arguments.length === 1) {\n        return arguments[0];\n      } else if (arguments.length === 0) {\n        return 'undefined';\n      }\n      var args = [];\n      for (var i = 0; i < arguments.length; i++) {\n        args.push(arguments[i]);\n      }\n      return args.join('$');\n    };\n  }\n  var memoizedFn = function memoizedFn() {\n    var self = this;\n    var args = arguments;\n    var ret;\n    var k = keyFn.apply(self, args);\n    var cache = memoizedFn.cache;\n    if (!(ret = cache[k])) {\n      ret = cache[k] = fn.apply(self, args);\n    }\n    return ret;\n  };\n  memoizedFn.cache = {};\n  return memoizedFn;\n};\n\nvar camel2dash = memoize$1(function (str) {\n  return str.replace(/([A-Z])/g, function (v) {\n    return '-' + v.toLowerCase();\n  });\n});\nvar dash2camel = memoize$1(function (str) {\n  return str.replace(/(-\\w)/g, function (v) {\n    return v[1].toUpperCase();\n  });\n});\nvar prependCamel = memoize$1(function (prefix, str) {\n  return prefix + str[0].toUpperCase() + str.substring(1);\n}, function (prefix, str) {\n  return prefix + '$' + str;\n});\nvar capitalize = function capitalize(str) {\n  if (emptyString(str)) {\n    return str;\n  }\n  return str.charAt(0).toUpperCase() + str.substring(1);\n};\n\nvar number = '(?:[-+]?(?:(?:\\\\d+|\\\\d*\\\\.\\\\d+)(?:[Ee][+-]?\\\\d+)?))';\nvar rgba = 'rgb[a]?\\\\((' + number + '[%]?)\\\\s*,\\\\s*(' + number + '[%]?)\\\\s*,\\\\s*(' + number + '[%]?)(?:\\\\s*,\\\\s*(' + number + '))?\\\\)';\nvar rgbaNoBackRefs = 'rgb[a]?\\\\((?:' + number + '[%]?)\\\\s*,\\\\s*(?:' + number + '[%]?)\\\\s*,\\\\s*(?:' + number + '[%]?)(?:\\\\s*,\\\\s*(?:' + number + '))?\\\\)';\nvar hsla = 'hsl[a]?\\\\((' + number + ')\\\\s*,\\\\s*(' + number + '[%])\\\\s*,\\\\s*(' + number + '[%])(?:\\\\s*,\\\\s*(' + number + '))?\\\\)';\nvar hslaNoBackRefs = 'hsl[a]?\\\\((?:' + number + ')\\\\s*,\\\\s*(?:' + number + '[%])\\\\s*,\\\\s*(?:' + number + '[%])(?:\\\\s*,\\\\s*(?:' + number + '))?\\\\)';\nvar hex3 = '\\\\#[0-9a-fA-F]{3}';\nvar hex6 = '\\\\#[0-9a-fA-F]{6}';\n\nvar ascending = function ascending(a, b) {\n  if (a < b) {\n    return -1;\n  } else if (a > b) {\n    return 1;\n  } else {\n    return 0;\n  }\n};\nvar descending = function descending(a, b) {\n  return -1 * ascending(a, b);\n};\n\nvar extend = Object.assign != null ? Object.assign.bind(Object) : function (tgt) {\n  var args = arguments;\n  for (var i = 1; i < args.length; i++) {\n    var obj = args[i];\n    if (obj == null) {\n      continue;\n    }\n    var keys = Object.keys(obj);\n    for (var j = 0; j < keys.length; j++) {\n      var k = keys[j];\n      tgt[k] = obj[k];\n    }\n  }\n  return tgt;\n};\n\n// get [r, g, b] from #abc or #aabbcc\nvar hex2tuple = function hex2tuple(hex) {\n  if (!(hex.length === 4 || hex.length === 7) || hex[0] !== '#') {\n    return;\n  }\n  var shortHex = hex.length === 4;\n  var r, g, b;\n  var base = 16;\n  if (shortHex) {\n    r = parseInt(hex[1] + hex[1], base);\n    g = parseInt(hex[2] + hex[2], base);\n    b = parseInt(hex[3] + hex[3], base);\n  } else {\n    r = parseInt(hex[1] + hex[2], base);\n    g = parseInt(hex[3] + hex[4], base);\n    b = parseInt(hex[5] + hex[6], base);\n  }\n  return [r, g, b];\n};\n\n// get [r, g, b, a] from hsl(0, 0, 0) or hsla(0, 0, 0, 0)\nvar hsl2tuple = function hsl2tuple(hsl) {\n  var ret;\n  var h, s, l, a, r, g, b;\n  function hue2rgb(p, q, t) {\n    if (t < 0) t += 1;\n    if (t > 1) t -= 1;\n    if (t < 1 / 6) return p + (q - p) * 6 * t;\n    if (t < 1 / 2) return q;\n    if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;\n    return p;\n  }\n  var m = new RegExp('^' + hsla + '$').exec(hsl);\n  if (m) {\n    // get hue\n    h = parseInt(m[1]);\n    if (h < 0) {\n      h = (360 - -1 * h % 360) % 360;\n    } else if (h > 360) {\n      h = h % 360;\n    }\n    h /= 360; // normalise on [0, 1]\n\n    s = parseFloat(m[2]);\n    if (s < 0 || s > 100) {\n      return;\n    } // saturation is [0, 100]\n    s = s / 100; // normalise on [0, 1]\n\n    l = parseFloat(m[3]);\n    if (l < 0 || l > 100) {\n      return;\n    } // lightness is [0, 100]\n    l = l / 100; // normalise on [0, 1]\n\n    a = m[4];\n    if (a !== undefined) {\n      a = parseFloat(a);\n      if (a < 0 || a > 1) {\n        return;\n      } // alpha is [0, 1]\n    }\n\n    // now, convert to rgb\n    // code from http://mjijackson.com/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript\n    if (s === 0) {\n      r = g = b = Math.round(l * 255); // achromatic\n    } else {\n      var q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n      var p = 2 * l - q;\n      r = Math.round(255 * hue2rgb(p, q, h + 1 / 3));\n      g = Math.round(255 * hue2rgb(p, q, h));\n      b = Math.round(255 * hue2rgb(p, q, h - 1 / 3));\n    }\n    ret = [r, g, b, a];\n  }\n  return ret;\n};\n\n// get [r, g, b, a] from rgb(0, 0, 0) or rgba(0, 0, 0, 0)\nvar rgb2tuple = function rgb2tuple(rgb) {\n  var ret;\n  var m = new RegExp('^' + rgba + '$').exec(rgb);\n  if (m) {\n    ret = [];\n    var isPct = [];\n    for (var i = 1; i <= 3; i++) {\n      var channel = m[i];\n      if (channel[channel.length - 1] === '%') {\n        isPct[i] = true;\n      }\n      channel = parseFloat(channel);\n      if (isPct[i]) {\n        channel = channel / 100 * 255; // normalise to [0, 255]\n      }\n\n      if (channel < 0 || channel > 255) {\n        return;\n      } // invalid channel value\n\n      ret.push(Math.floor(channel));\n    }\n    var atLeastOneIsPct = isPct[1] || isPct[2] || isPct[3];\n    var allArePct = isPct[1] && isPct[2] && isPct[3];\n    if (atLeastOneIsPct && !allArePct) {\n      return;\n    } // must all be percent values if one is\n\n    var alpha = m[4];\n    if (alpha !== undefined) {\n      alpha = parseFloat(alpha);\n      if (alpha < 0 || alpha > 1) {\n        return;\n      } // invalid alpha value\n\n      ret.push(alpha);\n    }\n  }\n  return ret;\n};\nvar colorname2tuple = function colorname2tuple(color) {\n  return colors[color.toLowerCase()];\n};\nvar color2tuple = function color2tuple(color) {\n  return (array(color) ? color : null) || colorname2tuple(color) || hex2tuple(color) || rgb2tuple(color) || hsl2tuple(color);\n};\nvar colors = {\n  // special colour names\n  transparent: [0, 0, 0, 0],\n  // NB alpha === 0\n\n  // regular colours\n  aliceblue: [240, 248, 255],\n  antiquewhite: [250, 235, 215],\n  aqua: [0, 255, 255],\n  aquamarine: [127, 255, 212],\n  azure: [240, 255, 255],\n  beige: [245, 245, 220],\n  bisque: [255, 228, 196],\n  black: [0, 0, 0],\n  blanchedalmond: [255, 235, 205],\n  blue: [0, 0, 255],\n  blueviolet: [138, 43, 226],\n  brown: [165, 42, 42],\n  burlywood: [222, 184, 135],\n  cadetblue: [95, 158, 160],\n  chartreuse: [127, 255, 0],\n  chocolate: [210, 105, 30],\n  coral: [255, 127, 80],\n  cornflowerblue: [100, 149, 237],\n  cornsilk: [255, 248, 220],\n  crimson: [220, 20, 60],\n  cyan: [0, 255, 255],\n  darkblue: [0, 0, 139],\n  darkcyan: [0, 139, 139],\n  darkgoldenrod: [184, 134, 11],\n  darkgray: [169, 169, 169],\n  darkgreen: [0, 100, 0],\n  darkgrey: [169, 169, 169],\n  darkkhaki: [189, 183, 107],\n  darkmagenta: [139, 0, 139],\n  darkolivegreen: [85, 107, 47],\n  darkorange: [255, 140, 0],\n  darkorchid: [153, 50, 204],\n  darkred: [139, 0, 0],\n  darksalmon: [233, 150, 122],\n  darkseagreen: [143, 188, 143],\n  darkslateblue: [72, 61, 139],\n  darkslategray: [47, 79, 79],\n  darkslategrey: [47, 79, 79],\n  darkturquoise: [0, 206, 209],\n  darkviolet: [148, 0, 211],\n  deeppink: [255, 20, 147],\n  deepskyblue: [0, 191, 255],\n  dimgray: [105, 105, 105],\n  dimgrey: [105, 105, 105],\n  dodgerblue: [30, 144, 255],\n  firebrick: [178, 34, 34],\n  floralwhite: [255, 250, 240],\n  forestgreen: [34, 139, 34],\n  fuchsia: [255, 0, 255],\n  gainsboro: [220, 220, 220],\n  ghostwhite: [248, 248, 255],\n  gold: [255, 215, 0],\n  goldenrod: [218, 165, 32],\n  gray: [128, 128, 128],\n  grey: [128, 128, 128],\n  green: [0, 128, 0],\n  greenyellow: [173, 255, 47],\n  honeydew: [240, 255, 240],\n  hotpink: [255, 105, 180],\n  indianred: [205, 92, 92],\n  indigo: [75, 0, 130],\n  ivory: [255, 255, 240],\n  khaki: [240, 230, 140],\n  lavender: [230, 230, 250],\n  lavenderblush: [255, 240, 245],\n  lawngreen: [124, 252, 0],\n  lemonchiffon: [255, 250, 205],\n  lightblue: [173, 216, 230],\n  lightcoral: [240, 128, 128],\n  lightcyan: [224, 255, 255],\n  lightgoldenrodyellow: [250, 250, 210],\n  lightgray: [211, 211, 211],\n  lightgreen: [144, 238, 144],\n  lightgrey: [211, 211, 211],\n  lightpink: [255, 182, 193],\n  lightsalmon: [255, 160, 122],\n  lightseagreen: [32, 178, 170],\n  lightskyblue: [135, 206, 250],\n  lightslategray: [119, 136, 153],\n  lightslategrey: [119, 136, 153],\n  lightsteelblue: [176, 196, 222],\n  lightyellow: [255, 255, 224],\n  lime: [0, 255, 0],\n  limegreen: [50, 205, 50],\n  linen: [250, 240, 230],\n  magenta: [255, 0, 255],\n  maroon: [128, 0, 0],\n  mediumaquamarine: [102, 205, 170],\n  mediumblue: [0, 0, 205],\n  mediumorchid: [186, 85, 211],\n  mediumpurple: [147, 112, 219],\n  mediumseagreen: [60, 179, 113],\n  mediumslateblue: [123, 104, 238],\n  mediumspringgreen: [0, 250, 154],\n  mediumturquoise: [72, 209, 204],\n  mediumvioletred: [199, 21, 133],\n  midnightblue: [25, 25, 112],\n  mintcream: [245, 255, 250],\n  mistyrose: [255, 228, 225],\n  moccasin: [255, 228, 181],\n  navajowhite: [255, 222, 173],\n  navy: [0, 0, 128],\n  oldlace: [253, 245, 230],\n  olive: [128, 128, 0],\n  olivedrab: [107, 142, 35],\n  orange: [255, 165, 0],\n  orangered: [255, 69, 0],\n  orchid: [218, 112, 214],\n  palegoldenrod: [238, 232, 170],\n  palegreen: [152, 251, 152],\n  paleturquoise: [175, 238, 238],\n  palevioletred: [219, 112, 147],\n  papayawhip: [255, 239, 213],\n  peachpuff: [255, 218, 185],\n  peru: [205, 133, 63],\n  pink: [255, 192, 203],\n  plum: [221, 160, 221],\n  powderblue: [176, 224, 230],\n  purple: [128, 0, 128],\n  red: [255, 0, 0],\n  rosybrown: [188, 143, 143],\n  royalblue: [65, 105, 225],\n  saddlebrown: [139, 69, 19],\n  salmon: [250, 128, 114],\n  sandybrown: [244, 164, 96],\n  seagreen: [46, 139, 87],\n  seashell: [255, 245, 238],\n  sienna: [160, 82, 45],\n  silver: [192, 192, 192],\n  skyblue: [135, 206, 235],\n  slateblue: [106, 90, 205],\n  slategray: [112, 128, 144],\n  slategrey: [112, 128, 144],\n  snow: [255, 250, 250],\n  springgreen: [0, 255, 127],\n  steelblue: [70, 130, 180],\n  tan: [210, 180, 140],\n  teal: [0, 128, 128],\n  thistle: [216, 191, 216],\n  tomato: [255, 99, 71],\n  turquoise: [64, 224, 208],\n  violet: [238, 130, 238],\n  wheat: [245, 222, 179],\n  white: [255, 255, 255],\n  whitesmoke: [245, 245, 245],\n  yellow: [255, 255, 0],\n  yellowgreen: [154, 205, 50]\n};\n\n// sets the value in a map (map may not be built)\nvar setMap = function setMap(options) {\n  var obj = options.map;\n  var keys = options.keys;\n  var l = keys.length;\n  for (var i = 0; i < l; i++) {\n    var key = keys[i];\n    if (plainObject(key)) {\n      throw Error('Tried to set map with object key');\n    }\n    if (i < keys.length - 1) {\n      // extend the map if necessary\n      if (obj[key] == null) {\n        obj[key] = {};\n      }\n      obj = obj[key];\n    } else {\n      // set the value\n      obj[key] = options.value;\n    }\n  }\n};\n\n// gets the value in a map even if it's not built in places\nvar getMap = function getMap(options) {\n  var obj = options.map;\n  var keys = options.keys;\n  var l = keys.length;\n  for (var i = 0; i < l; i++) {\n    var key = keys[i];\n    if (plainObject(key)) {\n      throw Error('Tried to get map with object key');\n    }\n    obj = obj[key];\n    if (obj == null) {\n      return obj;\n    }\n  }\n  return obj;\n};\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return value != null && (type == 'object' || type == 'function');\n}\n\nvar isObject_1 = isObject;\n\nvar commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\n\nfunction createCommonjsModule(fn, module) {\n\treturn module = { exports: {} }, fn(module, module.exports), module.exports;\n}\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;\n\nvar _freeGlobal = freeGlobal;\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = _freeGlobal || freeSelf || Function('return this')();\n\nvar _root = root;\n\n/**\n * Gets the timestamp of the number of milliseconds that have elapsed since\n * the Unix epoch (1 January 1970 00:00:00 UTC).\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Date\n * @returns {number} Returns the timestamp.\n * @example\n *\n * _.defer(function(stamp) {\n *   console.log(_.now() - stamp);\n * }, _.now());\n * // => Logs the number of milliseconds it took for the deferred invocation.\n */\nvar now = function() {\n  return _root.Date.now();\n};\n\nvar now_1 = now;\n\n/** Used to match a single whitespace character. */\nvar reWhitespace = /\\s/;\n\n/**\n * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace\n * character of `string`.\n *\n * @private\n * @param {string} string The string to inspect.\n * @returns {number} Returns the index of the last non-whitespace character.\n */\nfunction trimmedEndIndex(string) {\n  var index = string.length;\n\n  while (index-- && reWhitespace.test(string.charAt(index))) {}\n  return index;\n}\n\nvar _trimmedEndIndex = trimmedEndIndex;\n\n/** Used to match leading whitespace. */\nvar reTrimStart = /^\\s+/;\n\n/**\n * The base implementation of `_.trim`.\n *\n * @private\n * @param {string} string The string to trim.\n * @returns {string} Returns the trimmed string.\n */\nfunction baseTrim(string) {\n  return string\n    ? string.slice(0, _trimmedEndIndex(string) + 1).replace(reTrimStart, '')\n    : string;\n}\n\nvar _baseTrim = baseTrim;\n\n/** Built-in value references. */\nvar Symbol$1 = _root.Symbol;\n\nvar _Symbol = Symbol$1;\n\n/** Used for built-in method references. */\nvar objectProto$5 = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty$4 = objectProto$5.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString$1 = objectProto$5.toString;\n\n/** Built-in value references. */\nvar symToStringTag$1 = _Symbol ? _Symbol.toStringTag : undefined;\n\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */\nfunction getRawTag(value) {\n  var isOwn = hasOwnProperty$4.call(value, symToStringTag$1),\n      tag = value[symToStringTag$1];\n\n  try {\n    value[symToStringTag$1] = undefined;\n    var unmasked = true;\n  } catch (e) {}\n\n  var result = nativeObjectToString$1.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag$1] = tag;\n    } else {\n      delete value[symToStringTag$1];\n    }\n  }\n  return result;\n}\n\nvar _getRawTag = getRawTag;\n\n/** Used for built-in method references. */\nvar objectProto$4 = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto$4.toString;\n\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */\nfunction objectToString(value) {\n  return nativeObjectToString.call(value);\n}\n\nvar _objectToString = objectToString;\n\n/** `Object#toString` result references. */\nvar nullTag = '[object Null]',\n    undefinedTag = '[object Undefined]';\n\n/** Built-in value references. */\nvar symToStringTag = _Symbol ? _Symbol.toStringTag : undefined;\n\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === undefined ? undefinedTag : nullTag;\n  }\n  return (symToStringTag && symToStringTag in Object(value))\n    ? _getRawTag(value)\n    : _objectToString(value);\n}\n\nvar _baseGetTag = baseGetTag;\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return value != null && typeof value == 'object';\n}\n\nvar isObjectLike_1 = isObjectLike;\n\n/** `Object#toString` result references. */\nvar symbolTag = '[object Symbol]';\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike_1(value) && _baseGetTag(value) == symbolTag);\n}\n\nvar isSymbol_1 = isSymbol;\n\n/** Used as references for various `Number` constants. */\nvar NAN = 0 / 0;\n\n/** Used to detect bad signed hexadecimal string values. */\nvar reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n\n/** Used to detect binary string values. */\nvar reIsBinary = /^0b[01]+$/i;\n\n/** Used to detect octal string values. */\nvar reIsOctal = /^0o[0-7]+$/i;\n\n/** Built-in method references without a dependency on `root`. */\nvar freeParseInt = parseInt;\n\n/**\n * Converts `value` to a number.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {number} Returns the number.\n * @example\n *\n * _.toNumber(3.2);\n * // => 3.2\n *\n * _.toNumber(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toNumber(Infinity);\n * // => Infinity\n *\n * _.toNumber('3.2');\n * // => 3.2\n */\nfunction toNumber(value) {\n  if (typeof value == 'number') {\n    return value;\n  }\n  if (isSymbol_1(value)) {\n    return NAN;\n  }\n  if (isObject_1(value)) {\n    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;\n    value = isObject_1(other) ? (other + '') : other;\n  }\n  if (typeof value != 'string') {\n    return value === 0 ? value : +value;\n  }\n  value = _baseTrim(value);\n  var isBinary = reIsBinary.test(value);\n  return (isBinary || reIsOctal.test(value))\n    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)\n    : (reIsBadHex.test(value) ? NAN : +value);\n}\n\nvar toNumber_1 = toNumber;\n\n/** Error message constants. */\nvar FUNC_ERROR_TEXT$1 = 'Expected a function';\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max,\n    nativeMin = Math.min;\n\n/**\n * Creates a debounced function that delays invoking `func` until after `wait`\n * milliseconds have elapsed since the last time the debounced function was\n * invoked. The debounced function comes with a `cancel` method to cancel\n * delayed `func` invocations and a `flush` method to immediately invoke them.\n * Provide `options` to indicate whether `func` should be invoked on the\n * leading and/or trailing edge of the `wait` timeout. The `func` is invoked\n * with the last arguments provided to the debounced function. Subsequent\n * calls to the debounced function return the result of the last `func`\n * invocation.\n *\n * **Note:** If `leading` and `trailing` options are `true`, `func` is\n * invoked on the trailing edge of the timeout only if the debounced function\n * is invoked more than once during the `wait` timeout.\n *\n * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n *\n * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n * for details over the differences between `_.debounce` and `_.throttle`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to debounce.\n * @param {number} [wait=0] The number of milliseconds to delay.\n * @param {Object} [options={}] The options object.\n * @param {boolean} [options.leading=false]\n *  Specify invoking on the leading edge of the timeout.\n * @param {number} [options.maxWait]\n *  The maximum time `func` is allowed to be delayed before it's invoked.\n * @param {boolean} [options.trailing=true]\n *  Specify invoking on the trailing edge of the timeout.\n * @returns {Function} Returns the new debounced function.\n * @example\n *\n * // Avoid costly calculations while the window size is in flux.\n * jQuery(window).on('resize', _.debounce(calculateLayout, 150));\n *\n * // Invoke `sendMail` when clicked, debouncing subsequent calls.\n * jQuery(element).on('click', _.debounce(sendMail, 300, {\n *   'leading': true,\n *   'trailing': false\n * }));\n *\n * // Ensure `batchLog` is invoked once after 1 second of debounced calls.\n * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });\n * var source = new EventSource('/stream');\n * jQuery(source).on('message', debounced);\n *\n * // Cancel the trailing debounced invocation.\n * jQuery(window).on('popstate', debounced.cancel);\n */\nfunction debounce(func, wait, options) {\n  var lastArgs,\n      lastThis,\n      maxWait,\n      result,\n      timerId,\n      lastCallTime,\n      lastInvokeTime = 0,\n      leading = false,\n      maxing = false,\n      trailing = true;\n\n  if (typeof func != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT$1);\n  }\n  wait = toNumber_1(wait) || 0;\n  if (isObject_1(options)) {\n    leading = !!options.leading;\n    maxing = 'maxWait' in options;\n    maxWait = maxing ? nativeMax(toNumber_1(options.maxWait) || 0, wait) : maxWait;\n    trailing = 'trailing' in options ? !!options.trailing : trailing;\n  }\n\n  function invokeFunc(time) {\n    var args = lastArgs,\n        thisArg = lastThis;\n\n    lastArgs = lastThis = undefined;\n    lastInvokeTime = time;\n    result = func.apply(thisArg, args);\n    return result;\n  }\n\n  function leadingEdge(time) {\n    // Reset any `maxWait` timer.\n    lastInvokeTime = time;\n    // Start the timer for the trailing edge.\n    timerId = setTimeout(timerExpired, wait);\n    // Invoke the leading edge.\n    return leading ? invokeFunc(time) : result;\n  }\n\n  function remainingWait(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime,\n        timeWaiting = wait - timeSinceLastCall;\n\n    return maxing\n      ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)\n      : timeWaiting;\n  }\n\n  function shouldInvoke(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime;\n\n    // Either this is the first call, activity has stopped and we're at the\n    // trailing edge, the system time has gone backwards and we're treating\n    // it as the trailing edge, or we've hit the `maxWait` limit.\n    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||\n      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));\n  }\n\n  function timerExpired() {\n    var time = now_1();\n    if (shouldInvoke(time)) {\n      return trailingEdge(time);\n    }\n    // Restart the timer.\n    timerId = setTimeout(timerExpired, remainingWait(time));\n  }\n\n  function trailingEdge(time) {\n    timerId = undefined;\n\n    // Only invoke if we have `lastArgs` which means `func` has been\n    // debounced at least once.\n    if (trailing && lastArgs) {\n      return invokeFunc(time);\n    }\n    lastArgs = lastThis = undefined;\n    return result;\n  }\n\n  function cancel() {\n    if (timerId !== undefined) {\n      clearTimeout(timerId);\n    }\n    lastInvokeTime = 0;\n    lastArgs = lastCallTime = lastThis = timerId = undefined;\n  }\n\n  function flush() {\n    return timerId === undefined ? result : trailingEdge(now_1());\n  }\n\n  function debounced() {\n    var time = now_1(),\n        isInvoking = shouldInvoke(time);\n\n    lastArgs = arguments;\n    lastThis = this;\n    lastCallTime = time;\n\n    if (isInvoking) {\n      if (timerId === undefined) {\n        return leadingEdge(lastCallTime);\n      }\n      if (maxing) {\n        // Handle invocations in a tight loop.\n        clearTimeout(timerId);\n        timerId = setTimeout(timerExpired, wait);\n        return invokeFunc(lastCallTime);\n      }\n    }\n    if (timerId === undefined) {\n      timerId = setTimeout(timerExpired, wait);\n    }\n    return result;\n  }\n  debounced.cancel = cancel;\n  debounced.flush = flush;\n  return debounced;\n}\n\nvar debounce_1 = debounce;\n\nvar performance = _window ? _window.performance : null;\nvar pnow = performance && performance.now ? function () {\n  return performance.now();\n} : function () {\n  return Date.now();\n};\nvar raf = function () {\n  if (_window) {\n    if (_window.requestAnimationFrame) {\n      return function (fn) {\n        _window.requestAnimationFrame(fn);\n      };\n    } else if (_window.mozRequestAnimationFrame) {\n      return function (fn) {\n        _window.mozRequestAnimationFrame(fn);\n      };\n    } else if (_window.webkitRequestAnimationFrame) {\n      return function (fn) {\n        _window.webkitRequestAnimationFrame(fn);\n      };\n    } else if (_window.msRequestAnimationFrame) {\n      return function (fn) {\n        _window.msRequestAnimationFrame(fn);\n      };\n    }\n  }\n  return function (fn) {\n    if (fn) {\n      setTimeout(function () {\n        fn(pnow());\n      }, 1000 / 60);\n    }\n  };\n}();\nvar requestAnimationFrame = function requestAnimationFrame(fn) {\n  return raf(fn);\n};\nvar performanceNow = pnow;\n\nvar DEFAULT_HASH_SEED = 9261;\nvar K = 65599; // 37 also works pretty well\nvar DEFAULT_HASH_SEED_ALT = 5381;\nvar hashIterableInts = function hashIterableInts(iterator) {\n  var seed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_HASH_SEED;\n  // sdbm/string-hash\n  var hash = seed;\n  var entry;\n  for (;;) {\n    entry = iterator.next();\n    if (entry.done) {\n      break;\n    }\n    hash = hash * K + entry.value | 0;\n  }\n  return hash;\n};\nvar hashInt = function hashInt(num) {\n  var seed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_HASH_SEED;\n  // sdbm/string-hash\n  return seed * K + num | 0;\n};\nvar hashIntAlt = function hashIntAlt(num) {\n  var seed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_HASH_SEED_ALT;\n  // djb2/string-hash\n  return (seed << 5) + seed + num | 0;\n};\nvar combineHashes = function combineHashes(hash1, hash2) {\n  return hash1 * 0x200000 + hash2;\n};\nvar combineHashesArray = function combineHashesArray(hashes) {\n  return hashes[0] * 0x200000 + hashes[1];\n};\nvar hashArrays = function hashArrays(hashes1, hashes2) {\n  return [hashInt(hashes1[0], hashes2[0]), hashIntAlt(hashes1[1], hashes2[1])];\n};\nvar hashIntsArray = function hashIntsArray(ints, seed) {\n  var entry = {\n    value: 0,\n    done: false\n  };\n  var i = 0;\n  var length = ints.length;\n  var iterator = {\n    next: function next() {\n      if (i < length) {\n        entry.value = ints[i++];\n      } else {\n        entry.done = true;\n      }\n      return entry;\n    }\n  };\n  return hashIterableInts(iterator, seed);\n};\nvar hashString = function hashString(str, seed) {\n  var entry = {\n    value: 0,\n    done: false\n  };\n  var i = 0;\n  var length = str.length;\n  var iterator = {\n    next: function next() {\n      if (i < length) {\n        entry.value = str.charCodeAt(i++);\n      } else {\n        entry.done = true;\n      }\n      return entry;\n    }\n  };\n  return hashIterableInts(iterator, seed);\n};\nvar hashStrings = function hashStrings() {\n  return hashStringsArray(arguments);\n};\nvar hashStringsArray = function hashStringsArray(strs) {\n  var hash;\n  for (var i = 0; i < strs.length; i++) {\n    var str = strs[i];\n    if (i === 0) {\n      hash = hashString(str);\n    } else {\n      hash = hashString(str, hash);\n    }\n  }\n  return hash;\n};\n\n/*global console */\nvar warningsEnabled = true;\nvar warnSupported = console.warn != null; // eslint-disable-line no-console\nvar traceSupported = console.trace != null; // eslint-disable-line no-console\n\nvar MAX_INT$1 = Number.MAX_SAFE_INTEGER || 9007199254740991;\nvar trueify = function trueify() {\n  return true;\n};\nvar falsify = function falsify() {\n  return false;\n};\nvar zeroify = function zeroify() {\n  return 0;\n};\nvar noop$1 = function noop() {};\nvar error = function error(msg) {\n  throw new Error(msg);\n};\nvar warnings = function warnings(enabled) {\n  if (enabled !== undefined) {\n    warningsEnabled = !!enabled;\n  } else {\n    return warningsEnabled;\n  }\n};\nvar warn = function warn(msg) {\n  /* eslint-disable no-console */\n  if (!warnings()) {\n    return;\n  }\n  if (warnSupported) {\n    console.warn(msg);\n  } else {\n    console.log(msg);\n    if (traceSupported) {\n      console.trace();\n    }\n  }\n}; /* eslint-enable */\n\nvar clone = function clone(obj) {\n  return extend({}, obj);\n};\n\n// gets a shallow copy of the argument\nvar copy = function copy(obj) {\n  if (obj == null) {\n    return obj;\n  }\n  if (array(obj)) {\n    return obj.slice();\n  } else if (plainObject(obj)) {\n    return clone(obj);\n  } else {\n    return obj;\n  }\n};\nvar copyArray$1 = function copyArray(arr) {\n  return arr.slice();\n};\nvar uuid = function uuid(a, b /* placeholders */) {\n  for (\n  // loop :)\n  b = a = '';\n  // b - result , a - numeric letiable\n  a++ < 36;\n  //\n  b += a * 51 & 52 // if \"a\" is not 9 or 14 or 19 or 24\n  ?\n  //  return a random number or 4\n  (a ^ 15 // if \"a\" is not 15\n  ?\n  // generate a random number from 0 to 15\n  8 ^ Math.random() * (a ^ 20 ? 16 : 4) // unless \"a\" is 20, in which case a random number from 8 to 11\n  : 4 //  otherwise 4\n  ).toString(16) : '-' //  in other cases (if \"a\" is 9,14,19,24) insert \"-\"\n  ) {\n  }\n  return b;\n};\nvar _staticEmptyObject = {};\nvar staticEmptyObject = function staticEmptyObject() {\n  return _staticEmptyObject;\n};\nvar defaults$g = function defaults(_defaults) {\n  var keys = Object.keys(_defaults);\n  return function (opts) {\n    var filledOpts = {};\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n      var optVal = opts == null ? undefined : opts[key];\n      filledOpts[key] = optVal === undefined ? _defaults[key] : optVal;\n    }\n    return filledOpts;\n  };\n};\nvar removeFromArray = function removeFromArray(arr, ele, oneCopy) {\n  for (var i = arr.length - 1; i >= 0; i--) {\n    if (arr[i] === ele) {\n      arr.splice(i, 1);\n      if (oneCopy) {\n        break;\n      }\n    }\n  }\n};\nvar clearArray = function clearArray(arr) {\n  arr.splice(0, arr.length);\n};\nvar push = function push(arr, otherArr) {\n  for (var i = 0; i < otherArr.length; i++) {\n    var el = otherArr[i];\n    arr.push(el);\n  }\n};\nvar getPrefixedProperty = function getPrefixedProperty(obj, propName, prefix) {\n  if (prefix) {\n    propName = prependCamel(prefix, propName); // e.g. (labelWidth, source) => sourceLabelWidth\n  }\n\n  return obj[propName];\n};\nvar setPrefixedProperty = function setPrefixedProperty(obj, propName, prefix, value) {\n  if (prefix) {\n    propName = prependCamel(prefix, propName); // e.g. (labelWidth, source) => sourceLabelWidth\n  }\n\n  obj[propName] = value;\n};\n\n/* global Map */\nvar ObjectMap = /*#__PURE__*/function () {\n  function ObjectMap() {\n    _classCallCheck(this, ObjectMap);\n    this._obj = {};\n  }\n  _createClass(ObjectMap, [{\n    key: \"set\",\n    value: function set(key, val) {\n      this._obj[key] = val;\n      return this;\n    }\n  }, {\n    key: \"delete\",\n    value: function _delete(key) {\n      this._obj[key] = undefined;\n      return this;\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this._obj = {};\n    }\n  }, {\n    key: \"has\",\n    value: function has(key) {\n      return this._obj[key] !== undefined;\n    }\n  }, {\n    key: \"get\",\n    value: function get(key) {\n      return this._obj[key];\n    }\n  }]);\n  return ObjectMap;\n}();\nvar Map$2 = typeof Map !== 'undefined' ? Map : ObjectMap;\n\n/* global Set */\n\nvar undef = \"undefined\" ;\nvar ObjectSet = /*#__PURE__*/function () {\n  function ObjectSet(arrayOrObjectSet) {\n    _classCallCheck(this, ObjectSet);\n    this._obj = Object.create(null);\n    this.size = 0;\n    if (arrayOrObjectSet != null) {\n      var arr;\n      if (arrayOrObjectSet.instanceString != null && arrayOrObjectSet.instanceString() === this.instanceString()) {\n        arr = arrayOrObjectSet.toArray();\n      } else {\n        arr = arrayOrObjectSet;\n      }\n      for (var i = 0; i < arr.length; i++) {\n        this.add(arr[i]);\n      }\n    }\n  }\n  _createClass(ObjectSet, [{\n    key: \"instanceString\",\n    value: function instanceString() {\n      return 'set';\n    }\n  }, {\n    key: \"add\",\n    value: function add(val) {\n      var o = this._obj;\n      if (o[val] !== 1) {\n        o[val] = 1;\n        this.size++;\n      }\n    }\n  }, {\n    key: \"delete\",\n    value: function _delete(val) {\n      var o = this._obj;\n      if (o[val] === 1) {\n        o[val] = 0;\n        this.size--;\n      }\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this._obj = Object.create(null);\n    }\n  }, {\n    key: \"has\",\n    value: function has(val) {\n      return this._obj[val] === 1;\n    }\n  }, {\n    key: \"toArray\",\n    value: function toArray() {\n      var _this = this;\n      return Object.keys(this._obj).filter(function (key) {\n        return _this.has(key);\n      });\n    }\n  }, {\n    key: \"forEach\",\n    value: function forEach(callback, thisArg) {\n      return this.toArray().forEach(callback, thisArg);\n    }\n  }]);\n  return ObjectSet;\n}();\nvar Set$1 = (typeof Set === \"undefined\" ? \"undefined\" : _typeof(Set)) !== undef ? Set : ObjectSet;\n\n// represents a node or an edge\nvar Element = function Element(cy, params) {\n  var restore = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  if (cy === undefined || params === undefined || !core(cy)) {\n    error('An element must have a core reference and parameters set');\n    return;\n  }\n  var group = params.group;\n\n  // try to automatically infer the group if unspecified\n  if (group == null) {\n    if (params.data && params.data.source != null && params.data.target != null) {\n      group = 'edges';\n    } else {\n      group = 'nodes';\n    }\n  }\n\n  // validate group\n  if (group !== 'nodes' && group !== 'edges') {\n    error('An element must be of type `nodes` or `edges`; you specified `' + group + '`');\n    return;\n  }\n\n  // make the element array-like, just like a collection\n  this.length = 1;\n  this[0] = this;\n\n  // NOTE: when something is added here, add also to ele.json()\n  var _p = this._private = {\n    cy: cy,\n    single: true,\n    // indicates this is an element\n    data: params.data || {},\n    // data object\n    position: params.position || {\n      x: 0,\n      y: 0\n    },\n    // (x, y) position pair\n    autoWidth: undefined,\n    // width and height of nodes calculated by the renderer when set to special 'auto' value\n    autoHeight: undefined,\n    autoPadding: undefined,\n    compoundBoundsClean: false,\n    // whether the compound dimensions need to be recalculated the next time dimensions are read\n    listeners: [],\n    // array of bound listeners\n    group: group,\n    // string; 'nodes' or 'edges'\n    style: {},\n    // properties as set by the style\n    rstyle: {},\n    // properties for style sent from the renderer to the core\n    styleCxts: [],\n    // applied style contexts from the styler\n    styleKeys: {},\n    // per-group keys of style property values\n    removed: true,\n    // whether it's inside the vis; true if removed (set true here since we call restore)\n    selected: params.selected ? true : false,\n    // whether it's selected\n    selectable: params.selectable === undefined ? true : params.selectable ? true : false,\n    // whether it's selectable\n    locked: params.locked ? true : false,\n    // whether the element is locked (cannot be moved)\n    grabbed: false,\n    // whether the element is grabbed by the mouse; renderer sets this privately\n    grabbable: params.grabbable === undefined ? true : params.grabbable ? true : false,\n    // whether the element can be grabbed\n    pannable: params.pannable === undefined ? group === 'edges' ? true : false : params.pannable ? true : false,\n    // whether the element has passthrough panning enabled\n    active: false,\n    // whether the element is active from user interaction\n    classes: new Set$1(),\n    // map ( className => true )\n    animation: {\n      // object for currently-running animations\n      current: [],\n      queue: []\n    },\n    rscratch: {},\n    // object in which the renderer can store information\n    scratch: params.scratch || {},\n    // scratch objects\n    edges: [],\n    // array of connected edges\n    children: [],\n    // array of children\n    parent: params.parent && params.parent.isNode() ? params.parent : null,\n    // parent ref\n    traversalCache: {},\n    // cache of output of traversal functions\n    backgrounding: false,\n    // whether background images are loading\n    bbCache: null,\n    // cache of the current bounding box\n    bbCacheShift: {\n      x: 0,\n      y: 0\n    },\n    // shift applied to cached bb to be applied on next get\n    bodyBounds: null,\n    // bounds cache of element body, w/o overlay\n    overlayBounds: null,\n    // bounds cache of element body, including overlay\n    labelBounds: {\n      // bounds cache of labels\n      all: null,\n      source: null,\n      target: null,\n      main: null\n    },\n    arrowBounds: {\n      // bounds cache of edge arrows\n      source: null,\n      target: null,\n      'mid-source': null,\n      'mid-target': null\n    }\n  };\n  if (_p.position.x == null) {\n    _p.position.x = 0;\n  }\n  if (_p.position.y == null) {\n    _p.position.y = 0;\n  }\n\n  // renderedPosition overrides if specified\n  if (params.renderedPosition) {\n    var rpos = params.renderedPosition;\n    var pan = cy.pan();\n    var zoom = cy.zoom();\n    _p.position = {\n      x: (rpos.x - pan.x) / zoom,\n      y: (rpos.y - pan.y) / zoom\n    };\n  }\n  var classes = [];\n  if (array(params.classes)) {\n    classes = params.classes;\n  } else if (string(params.classes)) {\n    classes = params.classes.split(/\\s+/);\n  }\n  for (var i = 0, l = classes.length; i < l; i++) {\n    var cls = classes[i];\n    if (!cls || cls === '') {\n      continue;\n    }\n    _p.classes.add(cls);\n  }\n  this.createEmitter();\n  var bypass = params.style || params.css;\n  if (bypass) {\n    warn('Setting a `style` bypass at element creation should be done only when absolutely necessary.  Try to use the stylesheet instead.');\n    this.style(bypass);\n  }\n  if (restore === undefined || restore) {\n    this.restore();\n  }\n};\n\nvar defineSearch = function defineSearch(params) {\n  params = {\n    bfs: params.bfs || !params.dfs,\n    dfs: params.dfs || !params.bfs\n  };\n\n  // from pseudocode on wikipedia\n  return function searchFn(roots, fn, directed) {\n    var options;\n    if (plainObject(roots) && !elementOrCollection(roots)) {\n      options = roots;\n      roots = options.roots || options.root;\n      fn = options.visit;\n      directed = options.directed;\n    }\n    directed = arguments.length === 2 && !fn$6(fn) ? fn : directed;\n    fn = fn$6(fn) ? fn : function () {};\n    var cy = this._private.cy;\n    var v = roots = string(roots) ? this.filter(roots) : roots;\n    var Q = [];\n    var connectedNodes = [];\n    var connectedBy = {};\n    var id2depth = {};\n    var V = {};\n    var j = 0;\n    var found;\n    var _this$byGroup = this.byGroup(),\n      nodes = _this$byGroup.nodes,\n      edges = _this$byGroup.edges;\n\n    // enqueue v\n    for (var i = 0; i < v.length; i++) {\n      var vi = v[i];\n      var viId = vi.id();\n      if (vi.isNode()) {\n        Q.unshift(vi);\n        if (params.bfs) {\n          V[viId] = true;\n          connectedNodes.push(vi);\n        }\n        id2depth[viId] = 0;\n      }\n    }\n    var _loop = function _loop() {\n      var v = params.bfs ? Q.shift() : Q.pop();\n      var vId = v.id();\n      if (params.dfs) {\n        if (V[vId]) {\n          return \"continue\";\n        }\n        V[vId] = true;\n        connectedNodes.push(v);\n      }\n      var depth = id2depth[vId];\n      var prevEdge = connectedBy[vId];\n      var src = prevEdge != null ? prevEdge.source() : null;\n      var tgt = prevEdge != null ? prevEdge.target() : null;\n      var prevNode = prevEdge == null ? undefined : v.same(src) ? tgt[0] : src[0];\n      var ret = void 0;\n      ret = fn(v, prevEdge, prevNode, j++, depth);\n      if (ret === true) {\n        found = v;\n        return \"break\";\n      }\n      if (ret === false) {\n        return \"break\";\n      }\n      var vwEdges = v.connectedEdges().filter(function (e) {\n        return (!directed || e.source().same(v)) && edges.has(e);\n      });\n      for (var _i2 = 0; _i2 < vwEdges.length; _i2++) {\n        var e = vwEdges[_i2];\n        var w = e.connectedNodes().filter(function (n) {\n          return !n.same(v) && nodes.has(n);\n        });\n        var wId = w.id();\n        if (w.length !== 0 && !V[wId]) {\n          w = w[0];\n          Q.push(w);\n          if (params.bfs) {\n            V[wId] = true;\n            connectedNodes.push(w);\n          }\n          connectedBy[wId] = e;\n          id2depth[wId] = id2depth[vId] + 1;\n        }\n      }\n    };\n    while (Q.length !== 0) {\n      var _ret = _loop();\n      if (_ret === \"continue\") continue;\n      if (_ret === \"break\") break;\n    }\n    var connectedEles = cy.collection();\n    for (var _i = 0; _i < connectedNodes.length; _i++) {\n      var node = connectedNodes[_i];\n      var edge = connectedBy[node.id()];\n      if (edge != null) {\n        connectedEles.push(edge);\n      }\n      connectedEles.push(node);\n    }\n    return {\n      path: cy.collection(connectedEles),\n      found: cy.collection(found)\n    };\n  };\n};\n\n// search, spanning trees, etc\nvar elesfn$v = {\n  breadthFirstSearch: defineSearch({\n    bfs: true\n  }),\n  depthFirstSearch: defineSearch({\n    dfs: true\n  })\n};\n\n// nice, short mathematical alias\nelesfn$v.bfs = elesfn$v.breadthFirstSearch;\nelesfn$v.dfs = elesfn$v.depthFirstSearch;\n\nvar heap$1 = createCommonjsModule(function (module, exports) {\n// Generated by CoffeeScript 1.8.0\n(function() {\n  var Heap, defaultCmp, floor, heapify, heappop, heappush, heappushpop, heapreplace, insort, min, nlargest, nsmallest, updateItem, _siftdown, _siftup;\n\n  floor = Math.floor, min = Math.min;\n\n\n  /*\n  Default comparison function to be used\n   */\n\n  defaultCmp = function(x, y) {\n    if (x < y) {\n      return -1;\n    }\n    if (x > y) {\n      return 1;\n    }\n    return 0;\n  };\n\n\n  /*\n  Insert item x in list a, and keep it sorted assuming a is sorted.\n  \n  If x is already in a, insert it to the right of the rightmost x.\n  \n  Optional args lo (default 0) and hi (default a.length) bound the slice\n  of a to be searched.\n   */\n\n  insort = function(a, x, lo, hi, cmp) {\n    var mid;\n    if (lo == null) {\n      lo = 0;\n    }\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    if (lo < 0) {\n      throw new Error('lo must be non-negative');\n    }\n    if (hi == null) {\n      hi = a.length;\n    }\n    while (lo < hi) {\n      mid = floor((lo + hi) / 2);\n      if (cmp(x, a[mid]) < 0) {\n        hi = mid;\n      } else {\n        lo = mid + 1;\n      }\n    }\n    return ([].splice.apply(a, [lo, lo - lo].concat(x)), x);\n  };\n\n\n  /*\n  Push item onto heap, maintaining the heap invariant.\n   */\n\n  heappush = function(array, item, cmp) {\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    array.push(item);\n    return _siftdown(array, 0, array.length - 1, cmp);\n  };\n\n\n  /*\n  Pop the smallest item off the heap, maintaining the heap invariant.\n   */\n\n  heappop = function(array, cmp) {\n    var lastelt, returnitem;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    lastelt = array.pop();\n    if (array.length) {\n      returnitem = array[0];\n      array[0] = lastelt;\n      _siftup(array, 0, cmp);\n    } else {\n      returnitem = lastelt;\n    }\n    return returnitem;\n  };\n\n\n  /*\n  Pop and return the current smallest value, and add the new item.\n  \n  This is more efficient than heappop() followed by heappush(), and can be\n  more appropriate when using a fixed size heap. Note that the value\n  returned may be larger than item! That constrains reasonable use of\n  this routine unless written as part of a conditional replacement:\n      if item > array[0]\n        item = heapreplace(array, item)\n   */\n\n  heapreplace = function(array, item, cmp) {\n    var returnitem;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    returnitem = array[0];\n    array[0] = item;\n    _siftup(array, 0, cmp);\n    return returnitem;\n  };\n\n\n  /*\n  Fast version of a heappush followed by a heappop.\n   */\n\n  heappushpop = function(array, item, cmp) {\n    var _ref;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    if (array.length && cmp(array[0], item) < 0) {\n      _ref = [array[0], item], item = _ref[0], array[0] = _ref[1];\n      _siftup(array, 0, cmp);\n    }\n    return item;\n  };\n\n\n  /*\n  Transform list into a heap, in-place, in O(array.length) time.\n   */\n\n  heapify = function(array, cmp) {\n    var i, _i, _len, _ref1, _results, _results1;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    _ref1 = (function() {\n      _results1 = [];\n      for (var _j = 0, _ref = floor(array.length / 2); 0 <= _ref ? _j < _ref : _j > _ref; 0 <= _ref ? _j++ : _j--){ _results1.push(_j); }\n      return _results1;\n    }).apply(this).reverse();\n    _results = [];\n    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n      i = _ref1[_i];\n      _results.push(_siftup(array, i, cmp));\n    }\n    return _results;\n  };\n\n\n  /*\n  Update the position of the given item in the heap.\n  This function should be called every time the item is being modified.\n   */\n\n  updateItem = function(array, item, cmp) {\n    var pos;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    pos = array.indexOf(item);\n    if (pos === -1) {\n      return;\n    }\n    _siftdown(array, 0, pos, cmp);\n    return _siftup(array, pos, cmp);\n  };\n\n\n  /*\n  Find the n largest elements in a dataset.\n   */\n\n  nlargest = function(array, n, cmp) {\n    var elem, result, _i, _len, _ref;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    result = array.slice(0, n);\n    if (!result.length) {\n      return result;\n    }\n    heapify(result, cmp);\n    _ref = array.slice(n);\n    for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n      elem = _ref[_i];\n      heappushpop(result, elem, cmp);\n    }\n    return result.sort(cmp).reverse();\n  };\n\n\n  /*\n  Find the n smallest elements in a dataset.\n   */\n\n  nsmallest = function(array, n, cmp) {\n    var elem, los, result, _i, _j, _len, _ref, _ref1, _results;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    if (n * 10 <= array.length) {\n      result = array.slice(0, n).sort(cmp);\n      if (!result.length) {\n        return result;\n      }\n      los = result[result.length - 1];\n      _ref = array.slice(n);\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        elem = _ref[_i];\n        if (cmp(elem, los) < 0) {\n          insort(result, elem, 0, null, cmp);\n          result.pop();\n          los = result[result.length - 1];\n        }\n      }\n      return result;\n    }\n    heapify(array, cmp);\n    _results = [];\n    for (_j = 0, _ref1 = min(n, array.length); 0 <= _ref1 ? _j < _ref1 : _j > _ref1; 0 <= _ref1 ? ++_j : --_j) {\n      _results.push(heappop(array, cmp));\n    }\n    return _results;\n  };\n\n  _siftdown = function(array, startpos, pos, cmp) {\n    var newitem, parent, parentpos;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    newitem = array[pos];\n    while (pos > startpos) {\n      parentpos = (pos - 1) >> 1;\n      parent = array[parentpos];\n      if (cmp(newitem, parent) < 0) {\n        array[pos] = parent;\n        pos = parentpos;\n        continue;\n      }\n      break;\n    }\n    return array[pos] = newitem;\n  };\n\n  _siftup = function(array, pos, cmp) {\n    var childpos, endpos, newitem, rightpos, startpos;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    endpos = array.length;\n    startpos = pos;\n    newitem = array[pos];\n    childpos = 2 * pos + 1;\n    while (childpos < endpos) {\n      rightpos = childpos + 1;\n      if (rightpos < endpos && !(cmp(array[childpos], array[rightpos]) < 0)) {\n        childpos = rightpos;\n      }\n      array[pos] = array[childpos];\n      pos = childpos;\n      childpos = 2 * pos + 1;\n    }\n    array[pos] = newitem;\n    return _siftdown(array, startpos, pos, cmp);\n  };\n\n  Heap = (function() {\n    Heap.push = heappush;\n\n    Heap.pop = heappop;\n\n    Heap.replace = heapreplace;\n\n    Heap.pushpop = heappushpop;\n\n    Heap.heapify = heapify;\n\n    Heap.updateItem = updateItem;\n\n    Heap.nlargest = nlargest;\n\n    Heap.nsmallest = nsmallest;\n\n    function Heap(cmp) {\n      this.cmp = cmp != null ? cmp : defaultCmp;\n      this.nodes = [];\n    }\n\n    Heap.prototype.push = function(x) {\n      return heappush(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.pop = function() {\n      return heappop(this.nodes, this.cmp);\n    };\n\n    Heap.prototype.peek = function() {\n      return this.nodes[0];\n    };\n\n    Heap.prototype.contains = function(x) {\n      return this.nodes.indexOf(x) !== -1;\n    };\n\n    Heap.prototype.replace = function(x) {\n      return heapreplace(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.pushpop = function(x) {\n      return heappushpop(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.heapify = function() {\n      return heapify(this.nodes, this.cmp);\n    };\n\n    Heap.prototype.updateItem = function(x) {\n      return updateItem(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.clear = function() {\n      return this.nodes = [];\n    };\n\n    Heap.prototype.empty = function() {\n      return this.nodes.length === 0;\n    };\n\n    Heap.prototype.size = function() {\n      return this.nodes.length;\n    };\n\n    Heap.prototype.clone = function() {\n      var heap;\n      heap = new Heap();\n      heap.nodes = this.nodes.slice(0);\n      return heap;\n    };\n\n    Heap.prototype.toArray = function() {\n      return this.nodes.slice(0);\n    };\n\n    Heap.prototype.insert = Heap.prototype.push;\n\n    Heap.prototype.top = Heap.prototype.peek;\n\n    Heap.prototype.front = Heap.prototype.peek;\n\n    Heap.prototype.has = Heap.prototype.contains;\n\n    Heap.prototype.copy = Heap.prototype.clone;\n\n    return Heap;\n\n  })();\n\n  (function(root, factory) {\n    {\n      return module.exports = factory();\n    }\n  })(this, function() {\n    return Heap;\n  });\n\n}).call(commonjsGlobal);\n});\n\nvar heap = heap$1;\n\nvar dijkstraDefaults = defaults$g({\n  root: null,\n  weight: function weight(edge) {\n    return 1;\n  },\n  directed: false\n});\nvar elesfn$u = {\n  dijkstra: function dijkstra(options) {\n    if (!plainObject(options)) {\n      var args = arguments;\n      options = {\n        root: args[0],\n        weight: args[1],\n        directed: args[2]\n      };\n    }\n    var _dijkstraDefaults = dijkstraDefaults(options),\n      root = _dijkstraDefaults.root,\n      weight = _dijkstraDefaults.weight,\n      directed = _dijkstraDefaults.directed;\n    var eles = this;\n    var weightFn = weight;\n    var source = string(root) ? this.filter(root)[0] : root[0];\n    var dist = {};\n    var prev = {};\n    var knownDist = {};\n    var _this$byGroup = this.byGroup(),\n      nodes = _this$byGroup.nodes,\n      edges = _this$byGroup.edges;\n    edges.unmergeBy(function (ele) {\n      return ele.isLoop();\n    });\n    var getDist = function getDist(node) {\n      return dist[node.id()];\n    };\n    var setDist = function setDist(node, d) {\n      dist[node.id()] = d;\n      Q.updateItem(node);\n    };\n    var Q = new heap(function (a, b) {\n      return getDist(a) - getDist(b);\n    });\n    for (var i = 0; i < nodes.length; i++) {\n      var node = nodes[i];\n      dist[node.id()] = node.same(source) ? 0 : Infinity;\n      Q.push(node);\n    }\n    var distBetween = function distBetween(u, v) {\n      var uvs = (directed ? u.edgesTo(v) : u.edgesWith(v)).intersect(edges);\n      var smallestDistance = Infinity;\n      var smallestEdge;\n      for (var _i = 0; _i < uvs.length; _i++) {\n        var edge = uvs[_i];\n        var _weight = weightFn(edge);\n        if (_weight < smallestDistance || !smallestEdge) {\n          smallestDistance = _weight;\n          smallestEdge = edge;\n        }\n      }\n      return {\n        edge: smallestEdge,\n        dist: smallestDistance\n      };\n    };\n    while (Q.size() > 0) {\n      var u = Q.pop();\n      var smalletsDist = getDist(u);\n      var uid = u.id();\n      knownDist[uid] = smalletsDist;\n      if (smalletsDist === Infinity) {\n        continue;\n      }\n      var neighbors = u.neighborhood().intersect(nodes);\n      for (var _i2 = 0; _i2 < neighbors.length; _i2++) {\n        var v = neighbors[_i2];\n        var vid = v.id();\n        var vDist = distBetween(u, v);\n        var alt = smalletsDist + vDist.dist;\n        if (alt < getDist(v)) {\n          setDist(v, alt);\n          prev[vid] = {\n            node: u,\n            edge: vDist.edge\n          };\n        }\n      } // for\n    } // while\n\n    return {\n      distanceTo: function distanceTo(node) {\n        var target = string(node) ? nodes.filter(node)[0] : node[0];\n        return knownDist[target.id()];\n      },\n      pathTo: function pathTo(node) {\n        var target = string(node) ? nodes.filter(node)[0] : node[0];\n        var S = [];\n        var u = target;\n        var uid = u.id();\n        if (target.length > 0) {\n          S.unshift(target);\n          while (prev[uid]) {\n            var p = prev[uid];\n            S.unshift(p.edge);\n            S.unshift(p.node);\n            u = p.node;\n            uid = u.id();\n          }\n        }\n        return eles.spawn(S);\n      }\n    };\n  }\n};\n\nvar elesfn$t = {\n  // kruskal's algorithm (finds min spanning tree, assuming undirected graph)\n  // implemented from pseudocode from wikipedia\n  kruskal: function kruskal(weightFn) {\n    weightFn = weightFn || function (edge) {\n      return 1;\n    };\n    var _this$byGroup = this.byGroup(),\n      nodes = _this$byGroup.nodes,\n      edges = _this$byGroup.edges;\n    var numNodes = nodes.length;\n    var forest = new Array(numNodes);\n    var A = nodes; // assumes byGroup() creates new collections that can be safely mutated\n\n    var findSetIndex = function findSetIndex(ele) {\n      for (var i = 0; i < forest.length; i++) {\n        var eles = forest[i];\n        if (eles.has(ele)) {\n          return i;\n        }\n      }\n    };\n\n    // start with one forest per node\n    for (var i = 0; i < numNodes; i++) {\n      forest[i] = this.spawn(nodes[i]);\n    }\n    var S = edges.sort(function (a, b) {\n      return weightFn(a) - weightFn(b);\n    });\n    for (var _i = 0; _i < S.length; _i++) {\n      var edge = S[_i];\n      var u = edge.source()[0];\n      var v = edge.target()[0];\n      var setUIndex = findSetIndex(u);\n      var setVIndex = findSetIndex(v);\n      var setU = forest[setUIndex];\n      var setV = forest[setVIndex];\n      if (setUIndex !== setVIndex) {\n        A.merge(edge);\n\n        // combine forests for u and v\n        setU.merge(setV);\n        forest.splice(setVIndex, 1);\n      }\n    }\n    return A;\n  }\n};\n\nvar aStarDefaults = defaults$g({\n  root: null,\n  goal: null,\n  weight: function weight(edge) {\n    return 1;\n  },\n  heuristic: function heuristic(edge) {\n    return 0;\n  },\n  directed: false\n});\nvar elesfn$s = {\n  // Implemented from pseudocode from wikipedia\n  aStar: function aStar(options) {\n    var cy = this.cy();\n    var _aStarDefaults = aStarDefaults(options),\n      root = _aStarDefaults.root,\n      goal = _aStarDefaults.goal,\n      heuristic = _aStarDefaults.heuristic,\n      directed = _aStarDefaults.directed,\n      weight = _aStarDefaults.weight;\n    root = cy.collection(root)[0];\n    goal = cy.collection(goal)[0];\n    var sid = root.id();\n    var tid = goal.id();\n    var gScore = {};\n    var fScore = {};\n    var closedSetIds = {};\n    var openSet = new heap(function (a, b) {\n      return fScore[a.id()] - fScore[b.id()];\n    });\n    var openSetIds = new Set$1();\n    var cameFrom = {};\n    var cameFromEdge = {};\n    var addToOpenSet = function addToOpenSet(ele, id) {\n      openSet.push(ele);\n      openSetIds.add(id);\n    };\n    var cMin, cMinId;\n    var popFromOpenSet = function popFromOpenSet() {\n      cMin = openSet.pop();\n      cMinId = cMin.id();\n      openSetIds[\"delete\"](cMinId);\n    };\n    var isInOpenSet = function isInOpenSet(id) {\n      return openSetIds.has(id);\n    };\n    addToOpenSet(root, sid);\n    gScore[sid] = 0;\n    fScore[sid] = heuristic(root);\n\n    // Counter\n    var steps = 0;\n\n    // Main loop\n    while (openSet.size() > 0) {\n      popFromOpenSet();\n      steps++;\n\n      // If we've found our goal, then we are done\n      if (cMinId === tid) {\n        var path = [];\n        var pathNode = goal;\n        var pathNodeId = tid;\n        var pathEdge = cameFromEdge[pathNodeId];\n        for (;;) {\n          path.unshift(pathNode);\n          if (pathEdge != null) {\n            path.unshift(pathEdge);\n          }\n          pathNode = cameFrom[pathNodeId];\n          if (pathNode == null) {\n            break;\n          }\n          pathNodeId = pathNode.id();\n          pathEdge = cameFromEdge[pathNodeId];\n        }\n        return {\n          found: true,\n          distance: gScore[cMinId],\n          path: this.spawn(path),\n          steps: steps\n        };\n      }\n\n      // Add cMin to processed nodes\n      closedSetIds[cMinId] = true;\n\n      // Update scores for neighbors of cMin\n      // Take into account if graph is directed or not\n      var vwEdges = cMin._private.edges;\n      for (var i = 0; i < vwEdges.length; i++) {\n        var e = vwEdges[i];\n\n        // edge must be in set of calling eles\n        if (!this.hasElementWithId(e.id())) {\n          continue;\n        }\n\n        // cMin must be the source of edge if directed\n        if (directed && e.data('source') !== cMinId) {\n          continue;\n        }\n        var wSrc = e.source();\n        var wTgt = e.target();\n        var w = wSrc.id() !== cMinId ? wSrc : wTgt;\n        var wid = w.id();\n\n        // node must be in set of calling eles\n        if (!this.hasElementWithId(wid)) {\n          continue;\n        }\n\n        // if node is in closedSet, ignore it\n        if (closedSetIds[wid]) {\n          continue;\n        }\n\n        // New tentative score for node w\n        var tempScore = gScore[cMinId] + weight(e);\n\n        // Update gScore for node w if:\n        //   w not present in openSet\n        // OR\n        //   tentative gScore is less than previous value\n\n        // w not in openSet\n        if (!isInOpenSet(wid)) {\n          gScore[wid] = tempScore;\n          fScore[wid] = tempScore + heuristic(w);\n          addToOpenSet(w, wid);\n          cameFrom[wid] = cMin;\n          cameFromEdge[wid] = e;\n          continue;\n        }\n\n        // w already in openSet, but with greater gScore\n        if (tempScore < gScore[wid]) {\n          gScore[wid] = tempScore;\n          fScore[wid] = tempScore + heuristic(w);\n          cameFrom[wid] = cMin;\n          cameFromEdge[wid] = e;\n        }\n      } // End of neighbors update\n    } // End of main loop\n\n    // If we've reached here, then we've not reached our goal\n    return {\n      found: false,\n      distance: undefined,\n      path: undefined,\n      steps: steps\n    };\n  }\n}; // elesfn\n\nvar floydWarshallDefaults = defaults$g({\n  weight: function weight(edge) {\n    return 1;\n  },\n  directed: false\n});\nvar elesfn$r = {\n  // Implemented from pseudocode from wikipedia\n  floydWarshall: function floydWarshall(options) {\n    var cy = this.cy();\n    var _floydWarshallDefault = floydWarshallDefaults(options),\n      weight = _floydWarshallDefault.weight,\n      directed = _floydWarshallDefault.directed;\n    var weightFn = weight;\n    var _this$byGroup = this.byGroup(),\n      nodes = _this$byGroup.nodes,\n      edges = _this$byGroup.edges;\n    var N = nodes.length;\n    var Nsq = N * N;\n    var indexOf = function indexOf(node) {\n      return nodes.indexOf(node);\n    };\n    var atIndex = function atIndex(i) {\n      return nodes[i];\n    };\n\n    // Initialize distance matrix\n    var dist = new Array(Nsq);\n    for (var n = 0; n < Nsq; n++) {\n      var j = n % N;\n      var i = (n - j) / N;\n      if (i === j) {\n        dist[n] = 0;\n      } else {\n        dist[n] = Infinity;\n      }\n    }\n\n    // Initialize matrix used for path reconstruction\n    // Initialize distance matrix\n    var next = new Array(Nsq);\n    var edgeNext = new Array(Nsq);\n\n    // Process edges\n    for (var _i = 0; _i < edges.length; _i++) {\n      var edge = edges[_i];\n      var src = edge.source()[0];\n      var tgt = edge.target()[0];\n      if (src === tgt) {\n        continue;\n      } // exclude loops\n\n      var s = indexOf(src);\n      var t = indexOf(tgt);\n      var st = s * N + t; // source to target index\n      var _weight = weightFn(edge);\n\n      // Check if already process another edge between same 2 nodes\n      if (dist[st] > _weight) {\n        dist[st] = _weight;\n        next[st] = t;\n        edgeNext[st] = edge;\n      }\n\n      // If undirected graph, process 'reversed' edge\n      if (!directed) {\n        var ts = t * N + s; // target to source index\n\n        if (!directed && dist[ts] > _weight) {\n          dist[ts] = _weight;\n          next[ts] = s;\n          edgeNext[ts] = edge;\n        }\n      }\n    }\n\n    // Main loop\n    for (var k = 0; k < N; k++) {\n      for (var _i2 = 0; _i2 < N; _i2++) {\n        var ik = _i2 * N + k;\n        for (var _j = 0; _j < N; _j++) {\n          var ij = _i2 * N + _j;\n          var kj = k * N + _j;\n          if (dist[ik] + dist[kj] < dist[ij]) {\n            dist[ij] = dist[ik] + dist[kj];\n            next[ij] = next[ik];\n          }\n        }\n      }\n    }\n    var getArgEle = function getArgEle(ele) {\n      return (string(ele) ? cy.filter(ele) : ele)[0];\n    };\n    var indexOfArgEle = function indexOfArgEle(ele) {\n      return indexOf(getArgEle(ele));\n    };\n    var res = {\n      distance: function distance(from, to) {\n        var i = indexOfArgEle(from);\n        var j = indexOfArgEle(to);\n        return dist[i * N + j];\n      },\n      path: function path(from, to) {\n        var i = indexOfArgEle(from);\n        var j = indexOfArgEle(to);\n        var fromNode = atIndex(i);\n        if (i === j) {\n          return fromNode.collection();\n        }\n        if (next[i * N + j] == null) {\n          return cy.collection();\n        }\n        var path = cy.collection();\n        var prev = i;\n        var edge;\n        path.merge(fromNode);\n        while (i !== j) {\n          prev = i;\n          i = next[i * N + j];\n          edge = edgeNext[prev * N + i];\n          path.merge(edge);\n          path.merge(atIndex(i));\n        }\n        return path;\n      }\n    };\n    return res;\n  } // floydWarshall\n}; // elesfn\n\nvar bellmanFordDefaults = defaults$g({\n  weight: function weight(edge) {\n    return 1;\n  },\n  directed: false,\n  root: null\n});\nvar elesfn$q = {\n  // Implemented from pseudocode from wikipedia\n  bellmanFord: function bellmanFord(options) {\n    var _this = this;\n    var _bellmanFordDefaults = bellmanFordDefaults(options),\n      weight = _bellmanFordDefaults.weight,\n      directed = _bellmanFordDefaults.directed,\n      root = _bellmanFordDefaults.root;\n    var weightFn = weight;\n    var eles = this;\n    var cy = this.cy();\n    var _this$byGroup = this.byGroup(),\n      edges = _this$byGroup.edges,\n      nodes = _this$byGroup.nodes;\n    var numNodes = nodes.length;\n    var infoMap = new Map$2();\n    var hasNegativeWeightCycle = false;\n    var negativeWeightCycles = [];\n    root = cy.collection(root)[0]; // in case selector passed\n\n    edges.unmergeBy(function (edge) {\n      return edge.isLoop();\n    });\n    var numEdges = edges.length;\n    var getInfo = function getInfo(node) {\n      var obj = infoMap.get(node.id());\n      if (!obj) {\n        obj = {};\n        infoMap.set(node.id(), obj);\n      }\n      return obj;\n    };\n    var getNodeFromTo = function getNodeFromTo(to) {\n      return (string(to) ? cy.$(to) : to)[0];\n    };\n    var distanceTo = function distanceTo(to) {\n      return getInfo(getNodeFromTo(to)).dist;\n    };\n    var pathTo = function pathTo(to) {\n      var thisStart = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : root;\n      var end = getNodeFromTo(to);\n      var path = [];\n      var node = end;\n      for (;;) {\n        if (node == null) {\n          return _this.spawn();\n        }\n        var _getInfo = getInfo(node),\n          edge = _getInfo.edge,\n          pred = _getInfo.pred;\n        path.unshift(node[0]);\n        if (node.same(thisStart) && path.length > 0) {\n          break;\n        }\n        if (edge != null) {\n          path.unshift(edge);\n        }\n        node = pred;\n      }\n      return eles.spawn(path);\n    };\n\n    // Initializations { dist, pred, edge }\n    for (var i = 0; i < numNodes; i++) {\n      var node = nodes[i];\n      var info = getInfo(node);\n      if (node.same(root)) {\n        info.dist = 0;\n      } else {\n        info.dist = Infinity;\n      }\n      info.pred = null;\n      info.edge = null;\n    }\n\n    // Edges relaxation\n    var replacedEdge = false;\n    var checkForEdgeReplacement = function checkForEdgeReplacement(node1, node2, edge, info1, info2, weight) {\n      var dist = info1.dist + weight;\n      if (dist < info2.dist && !edge.same(info1.edge)) {\n        info2.dist = dist;\n        info2.pred = node1;\n        info2.edge = edge;\n        replacedEdge = true;\n      }\n    };\n    for (var _i = 1; _i < numNodes; _i++) {\n      replacedEdge = false;\n      for (var e = 0; e < numEdges; e++) {\n        var edge = edges[e];\n        var src = edge.source();\n        var tgt = edge.target();\n        var _weight = weightFn(edge);\n        var srcInfo = getInfo(src);\n        var tgtInfo = getInfo(tgt);\n        checkForEdgeReplacement(src, tgt, edge, srcInfo, tgtInfo, _weight);\n\n        // If undirected graph, we need to take into account the 'reverse' edge\n        if (!directed) {\n          checkForEdgeReplacement(tgt, src, edge, tgtInfo, srcInfo, _weight);\n        }\n      }\n      if (!replacedEdge) {\n        break;\n      }\n    }\n    if (replacedEdge) {\n      // Check for negative weight cycles\n      var negativeWeightCycleIds = [];\n      for (var _e = 0; _e < numEdges; _e++) {\n        var _edge = edges[_e];\n        var _src = _edge.source();\n        var _tgt = _edge.target();\n        var _weight2 = weightFn(_edge);\n        var srcDist = getInfo(_src).dist;\n        var tgtDist = getInfo(_tgt).dist;\n        if (srcDist + _weight2 < tgtDist || !directed && tgtDist + _weight2 < srcDist) {\n          if (!hasNegativeWeightCycle) {\n            warn('Graph contains a negative weight cycle for Bellman-Ford');\n            hasNegativeWeightCycle = true;\n          }\n          if (options.findNegativeWeightCycles !== false) {\n            var negativeNodes = [];\n            if (srcDist + _weight2 < tgtDist) {\n              negativeNodes.push(_src);\n            }\n            if (!directed && tgtDist + _weight2 < srcDist) {\n              negativeNodes.push(_tgt);\n            }\n            var numNegativeNodes = negativeNodes.length;\n            for (var n = 0; n < numNegativeNodes; n++) {\n              var start = negativeNodes[n];\n              var cycle = [start];\n              cycle.push(getInfo(start).edge);\n              var _node = getInfo(start).pred;\n              while (cycle.indexOf(_node) === -1) {\n                cycle.push(_node);\n                cycle.push(getInfo(_node).edge);\n                _node = getInfo(_node).pred;\n              }\n              cycle = cycle.slice(cycle.indexOf(_node));\n              var smallestId = cycle[0].id();\n              var smallestIndex = 0;\n              for (var c = 2; c < cycle.length; c += 2) {\n                if (cycle[c].id() < smallestId) {\n                  smallestId = cycle[c].id();\n                  smallestIndex = c;\n                }\n              }\n              cycle = cycle.slice(smallestIndex).concat(cycle.slice(0, smallestIndex));\n              cycle.push(cycle[0]);\n              var cycleId = cycle.map(function (el) {\n                return el.id();\n              }).join(\",\");\n              if (negativeWeightCycleIds.indexOf(cycleId) === -1) {\n                negativeWeightCycles.push(eles.spawn(cycle));\n                negativeWeightCycleIds.push(cycleId);\n              }\n            }\n          } else {\n            break;\n          }\n        }\n      }\n    }\n    return {\n      distanceTo: distanceTo,\n      pathTo: pathTo,\n      hasNegativeWeightCycle: hasNegativeWeightCycle,\n      negativeWeightCycles: negativeWeightCycles\n    };\n  } // bellmanFord\n}; // elesfn\n\nvar sqrt2 = Math.sqrt(2);\n\n// Function which colapses 2 (meta) nodes into one\n// Updates the remaining edge lists\n// Receives as a paramater the edge which causes the collapse\nvar collapse = function collapse(edgeIndex, nodeMap, remainingEdges) {\n  if (remainingEdges.length === 0) {\n    error(\"Karger-Stein must be run on a connected (sub)graph\");\n  }\n  var edgeInfo = remainingEdges[edgeIndex];\n  var sourceIn = edgeInfo[1];\n  var targetIn = edgeInfo[2];\n  var partition1 = nodeMap[sourceIn];\n  var partition2 = nodeMap[targetIn];\n  var newEdges = remainingEdges; // re-use array\n\n  // Delete all edges between partition1 and partition2\n  for (var i = newEdges.length - 1; i >= 0; i--) {\n    var edge = newEdges[i];\n    var src = edge[1];\n    var tgt = edge[2];\n    if (nodeMap[src] === partition1 && nodeMap[tgt] === partition2 || nodeMap[src] === partition2 && nodeMap[tgt] === partition1) {\n      newEdges.splice(i, 1);\n    }\n  }\n\n  // All edges pointing to partition2 should now point to partition1\n  for (var _i = 0; _i < newEdges.length; _i++) {\n    var _edge = newEdges[_i];\n    if (_edge[1] === partition2) {\n      // Check source\n      newEdges[_i] = _edge.slice(); // copy\n      newEdges[_i][1] = partition1;\n    } else if (_edge[2] === partition2) {\n      // Check target\n      newEdges[_i] = _edge.slice(); // copy\n      newEdges[_i][2] = partition1;\n    }\n  }\n\n  // Move all nodes from partition2 to partition1\n  for (var _i2 = 0; _i2 < nodeMap.length; _i2++) {\n    if (nodeMap[_i2] === partition2) {\n      nodeMap[_i2] = partition1;\n    }\n  }\n  return newEdges;\n};\n\n// Contracts a graph until we reach a certain number of meta nodes\nvar contractUntil = function contractUntil(metaNodeMap, remainingEdges, size, sizeLimit) {\n  while (size > sizeLimit) {\n    // Choose an edge randomly\n    var edgeIndex = Math.floor(Math.random() * remainingEdges.length);\n\n    // Collapse graph based on edge\n    remainingEdges = collapse(edgeIndex, metaNodeMap, remainingEdges);\n    size--;\n  }\n  return remainingEdges;\n};\nvar elesfn$p = {\n  // Computes the minimum cut of an undirected graph\n  // Returns the correct answer with high probability\n  kargerStein: function kargerStein() {\n    var _this = this;\n    var _this$byGroup = this.byGroup(),\n      nodes = _this$byGroup.nodes,\n      edges = _this$byGroup.edges;\n    edges.unmergeBy(function (edge) {\n      return edge.isLoop();\n    });\n    var numNodes = nodes.length;\n    var numEdges = edges.length;\n    var numIter = Math.ceil(Math.pow(Math.log(numNodes) / Math.LN2, 2));\n    var stopSize = Math.floor(numNodes / sqrt2);\n    if (numNodes < 2) {\n      error('At least 2 nodes are required for Karger-Stein algorithm');\n      return undefined;\n    }\n\n    // Now store edge destination as indexes\n    // Format for each edge (edge index, source node index, target node index)\n    var edgeIndexes = [];\n    for (var i = 0; i < numEdges; i++) {\n      var e = edges[i];\n      edgeIndexes.push([i, nodes.indexOf(e.source()), nodes.indexOf(e.target())]);\n    }\n\n    // We will store the best cut found here\n    var minCutSize = Infinity;\n    var minCutEdgeIndexes = [];\n    var minCutNodeMap = new Array(numNodes);\n\n    // Initial meta node partition\n    var metaNodeMap = new Array(numNodes);\n    var metaNodeMap2 = new Array(numNodes);\n    var copyNodesMap = function copyNodesMap(from, to) {\n      for (var _i3 = 0; _i3 < numNodes; _i3++) {\n        to[_i3] = from[_i3];\n      }\n    };\n\n    // Main loop\n    for (var iter = 0; iter <= numIter; iter++) {\n      // Reset meta node partition\n      for (var _i4 = 0; _i4 < numNodes; _i4++) {\n        metaNodeMap[_i4] = _i4;\n      }\n\n      // Contract until stop point (stopSize nodes)\n      var edgesState = contractUntil(metaNodeMap, edgeIndexes.slice(), numNodes, stopSize);\n      var edgesState2 = edgesState.slice(); // copy\n\n      // Create a copy of the colapsed nodes state\n      copyNodesMap(metaNodeMap, metaNodeMap2);\n\n      // Run 2 iterations starting in the stop state\n      var res1 = contractUntil(metaNodeMap, edgesState, stopSize, 2);\n      var res2 = contractUntil(metaNodeMap2, edgesState2, stopSize, 2);\n\n      // Is any of the 2 results the best cut so far?\n      if (res1.length <= res2.length && res1.length < minCutSize) {\n        minCutSize = res1.length;\n        minCutEdgeIndexes = res1;\n        copyNodesMap(metaNodeMap, minCutNodeMap);\n      } else if (res2.length <= res1.length && res2.length < minCutSize) {\n        minCutSize = res2.length;\n        minCutEdgeIndexes = res2;\n        copyNodesMap(metaNodeMap2, minCutNodeMap);\n      }\n    } // end of main loop\n\n    // Construct result\n    var cut = this.spawn(minCutEdgeIndexes.map(function (e) {\n      return edges[e[0]];\n    }));\n    var partition1 = this.spawn();\n    var partition2 = this.spawn();\n\n    // traverse metaNodeMap for best cut\n    var witnessNodePartition = minCutNodeMap[0];\n    for (var _i5 = 0; _i5 < minCutNodeMap.length; _i5++) {\n      var partitionId = minCutNodeMap[_i5];\n      var node = nodes[_i5];\n      if (partitionId === witnessNodePartition) {\n        partition1.merge(node);\n      } else {\n        partition2.merge(node);\n      }\n    }\n\n    // construct components corresponding to each disjoint subset of nodes\n    var constructComponent = function constructComponent(subset) {\n      var component = _this.spawn();\n      subset.forEach(function (node) {\n        component.merge(node);\n        node.connectedEdges().forEach(function (edge) {\n          // ensure edge is within calling collection and edge is not in cut\n          if (_this.contains(edge) && !cut.contains(edge)) {\n            component.merge(edge);\n          }\n        });\n      });\n      return component;\n    };\n    var components = [constructComponent(partition1), constructComponent(partition2)];\n    var ret = {\n      cut: cut,\n      components: components,\n      // n.b. partitions are included to be compatible with the old api spec\n      // (could be removed in a future major version)\n      partition1: partition1,\n      partition2: partition2\n    };\n    return ret;\n  }\n}; // elesfn\n\nvar copyPosition = function copyPosition(p) {\n  return {\n    x: p.x,\n    y: p.y\n  };\n};\nvar modelToRenderedPosition = function modelToRenderedPosition(p, zoom, pan) {\n  return {\n    x: p.x * zoom + pan.x,\n    y: p.y * zoom + pan.y\n  };\n};\nvar renderedToModelPosition = function renderedToModelPosition(p, zoom, pan) {\n  return {\n    x: (p.x - pan.x) / zoom,\n    y: (p.y - pan.y) / zoom\n  };\n};\nvar array2point = function array2point(arr) {\n  return {\n    x: arr[0],\n    y: arr[1]\n  };\n};\nvar min = function min(arr) {\n  var begin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  var end = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : arr.length;\n  var min = Infinity;\n  for (var i = begin; i < end; i++) {\n    var val = arr[i];\n    if (isFinite(val)) {\n      min = Math.min(val, min);\n    }\n  }\n  return min;\n};\nvar max = function max(arr) {\n  var begin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  var end = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : arr.length;\n  var max = -Infinity;\n  for (var i = begin; i < end; i++) {\n    var val = arr[i];\n    if (isFinite(val)) {\n      max = Math.max(val, max);\n    }\n  }\n  return max;\n};\nvar mean = function mean(arr) {\n  var begin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  var end = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : arr.length;\n  var total = 0;\n  var n = 0;\n  for (var i = begin; i < end; i++) {\n    var val = arr[i];\n    if (isFinite(val)) {\n      total += val;\n      n++;\n    }\n  }\n  return total / n;\n};\nvar median = function median(arr) {\n  var begin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  var end = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : arr.length;\n  var copy = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n  var sort = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n  var includeHoles = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;\n  if (copy) {\n    arr = arr.slice(begin, end);\n  } else {\n    if (end < arr.length) {\n      arr.splice(end, arr.length - end);\n    }\n    if (begin > 0) {\n      arr.splice(0, begin);\n    }\n  }\n\n  // all non finite (e.g. Infinity, NaN) elements must be -Infinity so they go to the start\n  var off = 0; // offset from non-finite values\n  for (var i = arr.length - 1; i >= 0; i--) {\n    var v = arr[i];\n    if (includeHoles) {\n      if (!isFinite(v)) {\n        arr[i] = -Infinity;\n        off++;\n      }\n    } else {\n      // just remove it if we don't want to consider holes\n      arr.splice(i, 1);\n    }\n  }\n  if (sort) {\n    arr.sort(function (a, b) {\n      return a - b;\n    }); // requires copy = true if you don't want to change the orig\n  }\n\n  var len = arr.length;\n  var mid = Math.floor(len / 2);\n  if (len % 2 !== 0) {\n    return arr[mid + 1 + off];\n  } else {\n    return (arr[mid - 1 + off] + arr[mid + off]) / 2;\n  }\n};\nvar deg2rad = function deg2rad(deg) {\n  return Math.PI * deg / 180;\n};\nvar getAngleFromDisp = function getAngleFromDisp(dispX, dispY) {\n  return Math.atan2(dispY, dispX) - Math.PI / 2;\n};\nvar log2 = Math.log2 || function (n) {\n  return Math.log(n) / Math.log(2);\n};\nvar signum = function signum(x) {\n  if (x > 0) {\n    return 1;\n  } else if (x < 0) {\n    return -1;\n  } else {\n    return 0;\n  }\n};\nvar dist = function dist(p1, p2) {\n  return Math.sqrt(sqdist(p1, p2));\n};\nvar sqdist = function sqdist(p1, p2) {\n  var dx = p2.x - p1.x;\n  var dy = p2.y - p1.y;\n  return dx * dx + dy * dy;\n};\nvar inPlaceSumNormalize = function inPlaceSumNormalize(v) {\n  var length = v.length;\n\n  // First, get sum of all elements\n  var total = 0;\n  for (var i = 0; i < length; i++) {\n    total += v[i];\n  }\n\n  // Now, divide each by the sum of all elements\n  for (var _i = 0; _i < length; _i++) {\n    v[_i] = v[_i] / total;\n  }\n  return v;\n};\n\n// from http://en.wikipedia.org/wiki/Bzier_curve#Quadratic_curves\nvar qbezierAt = function qbezierAt(p0, p1, p2, t) {\n  return (1 - t) * (1 - t) * p0 + 2 * (1 - t) * t * p1 + t * t * p2;\n};\nvar qbezierPtAt = function qbezierPtAt(p0, p1, p2, t) {\n  return {\n    x: qbezierAt(p0.x, p1.x, p2.x, t),\n    y: qbezierAt(p0.y, p1.y, p2.y, t)\n  };\n};\nvar lineAt = function lineAt(p0, p1, t, d) {\n  var vec = {\n    x: p1.x - p0.x,\n    y: p1.y - p0.y\n  };\n  var vecDist = dist(p0, p1);\n  var normVec = {\n    x: vec.x / vecDist,\n    y: vec.y / vecDist\n  };\n  t = t == null ? 0 : t;\n  d = d != null ? d : t * vecDist;\n  return {\n    x: p0.x + normVec.x * d,\n    y: p0.y + normVec.y * d\n  };\n};\nvar bound = function bound(min, val, max) {\n  return Math.max(min, Math.min(max, val));\n};\n\n// makes a full bb (x1, y1, x2, y2, w, h) from implicit params\nvar makeBoundingBox = function makeBoundingBox(bb) {\n  if (bb == null) {\n    return {\n      x1: Infinity,\n      y1: Infinity,\n      x2: -Infinity,\n      y2: -Infinity,\n      w: 0,\n      h: 0\n    };\n  } else if (bb.x1 != null && bb.y1 != null) {\n    if (bb.x2 != null && bb.y2 != null && bb.x2 >= bb.x1 && bb.y2 >= bb.y1) {\n      return {\n        x1: bb.x1,\n        y1: bb.y1,\n        x2: bb.x2,\n        y2: bb.y2,\n        w: bb.x2 - bb.x1,\n        h: bb.y2 - bb.y1\n      };\n    } else if (bb.w != null && bb.h != null && bb.w >= 0 && bb.h >= 0) {\n      return {\n        x1: bb.x1,\n        y1: bb.y1,\n        x2: bb.x1 + bb.w,\n        y2: bb.y1 + bb.h,\n        w: bb.w,\n        h: bb.h\n      };\n    }\n  }\n};\nvar copyBoundingBox = function copyBoundingBox(bb) {\n  return {\n    x1: bb.x1,\n    x2: bb.x2,\n    w: bb.w,\n    y1: bb.y1,\n    y2: bb.y2,\n    h: bb.h\n  };\n};\nvar clearBoundingBox = function clearBoundingBox(bb) {\n  bb.x1 = Infinity;\n  bb.y1 = Infinity;\n  bb.x2 = -Infinity;\n  bb.y2 = -Infinity;\n  bb.w = 0;\n  bb.h = 0;\n};\nvar shiftBoundingBox = function shiftBoundingBox(bb, dx, dy) {\n  return {\n    x1: bb.x1 + dx,\n    x2: bb.x2 + dx,\n    y1: bb.y1 + dy,\n    y2: bb.y2 + dy,\n    w: bb.w,\n    h: bb.h\n  };\n};\nvar updateBoundingBox = function updateBoundingBox(bb1, bb2) {\n  // update bb1 with bb2 bounds\n\n  bb1.x1 = Math.min(bb1.x1, bb2.x1);\n  bb1.x2 = Math.max(bb1.x2, bb2.x2);\n  bb1.w = bb1.x2 - bb1.x1;\n  bb1.y1 = Math.min(bb1.y1, bb2.y1);\n  bb1.y2 = Math.max(bb1.y2, bb2.y2);\n  bb1.h = bb1.y2 - bb1.y1;\n};\nvar expandBoundingBoxByPoint = function expandBoundingBoxByPoint(bb, x, y) {\n  bb.x1 = Math.min(bb.x1, x);\n  bb.x2 = Math.max(bb.x2, x);\n  bb.w = bb.x2 - bb.x1;\n  bb.y1 = Math.min(bb.y1, y);\n  bb.y2 = Math.max(bb.y2, y);\n  bb.h = bb.y2 - bb.y1;\n};\nvar expandBoundingBox = function expandBoundingBox(bb) {\n  var padding = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  bb.x1 -= padding;\n  bb.x2 += padding;\n  bb.y1 -= padding;\n  bb.y2 += padding;\n  bb.w = bb.x2 - bb.x1;\n  bb.h = bb.y2 - bb.y1;\n  return bb;\n};\nvar expandBoundingBoxSides = function expandBoundingBoxSides(bb) {\n  var padding = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [0];\n  var top, right, bottom, left;\n  if (padding.length === 1) {\n    top = right = bottom = left = padding[0];\n  } else if (padding.length === 2) {\n    top = bottom = padding[0];\n    left = right = padding[1];\n  } else if (padding.length === 4) {\n    var _padding = _slicedToArray(padding, 4);\n    top = _padding[0];\n    right = _padding[1];\n    bottom = _padding[2];\n    left = _padding[3];\n  }\n  bb.x1 -= left;\n  bb.x2 += right;\n  bb.y1 -= top;\n  bb.y2 += bottom;\n  bb.w = bb.x2 - bb.x1;\n  bb.h = bb.y2 - bb.y1;\n  return bb;\n};\n\n// assign the values of bb2 into bb1\nvar assignBoundingBox = function assignBoundingBox(bb1, bb2) {\n  bb1.x1 = bb2.x1;\n  bb1.y1 = bb2.y1;\n  bb1.x2 = bb2.x2;\n  bb1.y2 = bb2.y2;\n  bb1.w = bb1.x2 - bb1.x1;\n  bb1.h = bb1.y2 - bb1.y1;\n};\nvar boundingBoxesIntersect = function boundingBoxesIntersect(bb1, bb2) {\n  // case: one bb to right of other\n  if (bb1.x1 > bb2.x2) {\n    return false;\n  }\n  if (bb2.x1 > bb1.x2) {\n    return false;\n  }\n\n  // case: one bb to left of other\n  if (bb1.x2 < bb2.x1) {\n    return false;\n  }\n  if (bb2.x2 < bb1.x1) {\n    return false;\n  }\n\n  // case: one bb above other\n  if (bb1.y2 < bb2.y1) {\n    return false;\n  }\n  if (bb2.y2 < bb1.y1) {\n    return false;\n  }\n\n  // case: one bb below other\n  if (bb1.y1 > bb2.y2) {\n    return false;\n  }\n  if (bb2.y1 > bb1.y2) {\n    return false;\n  }\n\n  // otherwise, must have some overlap\n  return true;\n};\nvar inBoundingBox = function inBoundingBox(bb, x, y) {\n  return bb.x1 <= x && x <= bb.x2 && bb.y1 <= y && y <= bb.y2;\n};\nvar pointInBoundingBox = function pointInBoundingBox(bb, pt) {\n  return inBoundingBox(bb, pt.x, pt.y);\n};\nvar boundingBoxInBoundingBox = function boundingBoxInBoundingBox(bb1, bb2) {\n  return inBoundingBox(bb1, bb2.x1, bb2.y1) && inBoundingBox(bb1, bb2.x2, bb2.y2);\n};\nvar roundRectangleIntersectLine = function roundRectangleIntersectLine(x, y, nodeX, nodeY, width, height, padding) {\n  var radius = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 'auto';\n  var cornerRadius = radius === 'auto' ? getRoundRectangleRadius(width, height) : radius;\n  var halfWidth = width / 2;\n  var halfHeight = height / 2;\n  cornerRadius = Math.min(cornerRadius, halfWidth, halfHeight);\n  var doWidth = cornerRadius !== halfWidth,\n    doHeight = cornerRadius !== halfHeight;\n\n  // Check intersections with straight line segments\n  var straightLineIntersections;\n\n  // Top segment, left to right\n  if (doWidth) {\n    var topStartX = nodeX - halfWidth + cornerRadius - padding;\n    var topStartY = nodeY - halfHeight - padding;\n    var topEndX = nodeX + halfWidth - cornerRadius + padding;\n    var topEndY = topStartY;\n    straightLineIntersections = finiteLinesIntersect(x, y, nodeX, nodeY, topStartX, topStartY, topEndX, topEndY, false);\n    if (straightLineIntersections.length > 0) {\n      return straightLineIntersections;\n    }\n  }\n\n  // Right segment, top to bottom\n  if (doHeight) {\n    var rightStartX = nodeX + halfWidth + padding;\n    var rightStartY = nodeY - halfHeight + cornerRadius - padding;\n    var rightEndX = rightStartX;\n    var rightEndY = nodeY + halfHeight - cornerRadius + padding;\n    straightLineIntersections = finiteLinesIntersect(x, y, nodeX, nodeY, rightStartX, rightStartY, rightEndX, rightEndY, false);\n    if (straightLineIntersections.length > 0) {\n      return straightLineIntersections;\n    }\n  }\n\n  // Bottom segment, left to right\n  if (doWidth) {\n    var bottomStartX = nodeX - halfWidth + cornerRadius - padding;\n    var bottomStartY = nodeY + halfHeight + padding;\n    var bottomEndX = nodeX + halfWidth - cornerRadius + padding;\n    var bottomEndY = bottomStartY;\n    straightLineIntersections = finiteLinesIntersect(x, y, nodeX, nodeY, bottomStartX, bottomStartY, bottomEndX, bottomEndY, false);\n    if (straightLineIntersections.length > 0) {\n      return straightLineIntersections;\n    }\n  }\n\n  // Left segment, top to bottom\n  if (doHeight) {\n    var leftStartX = nodeX - halfWidth - padding;\n    var leftStartY = nodeY - halfHeight + cornerRadius - padding;\n    var leftEndX = leftStartX;\n    var leftEndY = nodeY + halfHeight - cornerRadius + padding;\n    straightLineIntersections = finiteLinesIntersect(x, y, nodeX, nodeY, leftStartX, leftStartY, leftEndX, leftEndY, false);\n    if (straightLineIntersections.length > 0) {\n      return straightLineIntersections;\n    }\n  }\n\n  // Check intersections with arc segments\n  var arcIntersections;\n\n  // Top Left\n  {\n    var topLeftCenterX = nodeX - halfWidth + cornerRadius;\n    var topLeftCenterY = nodeY - halfHeight + cornerRadius;\n    arcIntersections = intersectLineCircle(x, y, nodeX, nodeY, topLeftCenterX, topLeftCenterY, cornerRadius + padding);\n\n    // Ensure the intersection is on the desired quarter of the circle\n    if (arcIntersections.length > 0 && arcIntersections[0] <= topLeftCenterX && arcIntersections[1] <= topLeftCenterY) {\n      return [arcIntersections[0], arcIntersections[1]];\n    }\n  }\n\n  // Top Right\n  {\n    var topRightCenterX = nodeX + halfWidth - cornerRadius;\n    var topRightCenterY = nodeY - halfHeight + cornerRadius;\n    arcIntersections = intersectLineCircle(x, y, nodeX, nodeY, topRightCenterX, topRightCenterY, cornerRadius + padding);\n\n    // Ensure the intersection is on the desired quarter of the circle\n    if (arcIntersections.length > 0 && arcIntersections[0] >= topRightCenterX && arcIntersections[1] <= topRightCenterY) {\n      return [arcIntersections[0], arcIntersections[1]];\n    }\n  }\n\n  // Bottom Right\n  {\n    var bottomRightCenterX = nodeX + halfWidth - cornerRadius;\n    var bottomRightCenterY = nodeY + halfHeight - cornerRadius;\n    arcIntersections = intersectLineCircle(x, y, nodeX, nodeY, bottomRightCenterX, bottomRightCenterY, cornerRadius + padding);\n\n    // Ensure the intersection is on the desired quarter of the circle\n    if (arcIntersections.length > 0 && arcIntersections[0] >= bottomRightCenterX && arcIntersections[1] >= bottomRightCenterY) {\n      return [arcIntersections[0], arcIntersections[1]];\n    }\n  }\n\n  // Bottom Left\n  {\n    var bottomLeftCenterX = nodeX - halfWidth + cornerRadius;\n    var bottomLeftCenterY = nodeY + halfHeight - cornerRadius;\n    arcIntersections = intersectLineCircle(x, y, nodeX, nodeY, bottomLeftCenterX, bottomLeftCenterY, cornerRadius + padding);\n\n    // Ensure the intersection is on the desired quarter of the circle\n    if (arcIntersections.length > 0 && arcIntersections[0] <= bottomLeftCenterX && arcIntersections[1] >= bottomLeftCenterY) {\n      return [arcIntersections[0], arcIntersections[1]];\n    }\n  }\n  return []; // if nothing\n};\n\nvar inLineVicinity = function inLineVicinity(x, y, lx1, ly1, lx2, ly2, tolerance) {\n  var t = tolerance;\n  var x1 = Math.min(lx1, lx2);\n  var x2 = Math.max(lx1, lx2);\n  var y1 = Math.min(ly1, ly2);\n  var y2 = Math.max(ly1, ly2);\n  return x1 - t <= x && x <= x2 + t && y1 - t <= y && y <= y2 + t;\n};\nvar inBezierVicinity = function inBezierVicinity(x, y, x1, y1, x2, y2, x3, y3, tolerance) {\n  var bb = {\n    x1: Math.min(x1, x3, x2) - tolerance,\n    x2: Math.max(x1, x3, x2) + tolerance,\n    y1: Math.min(y1, y3, y2) - tolerance,\n    y2: Math.max(y1, y3, y2) + tolerance\n  };\n\n  // if outside the rough bounding box for the bezier, then it can't be a hit\n  if (x < bb.x1 || x > bb.x2 || y < bb.y1 || y > bb.y2) {\n    // console.log('bezier out of rough bb')\n    return false;\n  } else {\n    // console.log('do more expensive check');\n    return true;\n  }\n};\nvar solveQuadratic = function solveQuadratic(a, b, c, val) {\n  c -= val;\n  var r = b * b - 4 * a * c;\n  if (r < 0) {\n    return [];\n  }\n  var sqrtR = Math.sqrt(r);\n  var denom = 2 * a;\n  var root1 = (-b + sqrtR) / denom;\n  var root2 = (-b - sqrtR) / denom;\n  return [root1, root2];\n};\nvar solveCubic = function solveCubic(a, b, c, d, result) {\n  // Solves a cubic function, returns root in form [r1, i1, r2, i2, r3, i3], where\n  // r is the real component, i is the imaginary component\n\n  // An implementation of the Cardano method from the year 1545\n  // http://en.wikipedia.org/wiki/Cubic_function#The_nature_of_the_roots\n\n  var epsilon = 0.00001;\n\n  // avoid division by zero while keeping the overall expression close in value\n  if (a === 0) {\n    a = epsilon;\n  }\n  b /= a;\n  c /= a;\n  d /= a;\n  var discriminant, q, r, dum1, s, t, term1, r13;\n  q = (3.0 * c - b * b) / 9.0;\n  r = -(27.0 * d) + b * (9.0 * c - 2.0 * (b * b));\n  r /= 54.0;\n  discriminant = q * q * q + r * r;\n  result[1] = 0;\n  term1 = b / 3.0;\n  if (discriminant > 0) {\n    s = r + Math.sqrt(discriminant);\n    s = s < 0 ? -Math.pow(-s, 1.0 / 3.0) : Math.pow(s, 1.0 / 3.0);\n    t = r - Math.sqrt(discriminant);\n    t = t < 0 ? -Math.pow(-t, 1.0 / 3.0) : Math.pow(t, 1.0 / 3.0);\n    result[0] = -term1 + s + t;\n    term1 += (s + t) / 2.0;\n    result[4] = result[2] = -term1;\n    term1 = Math.sqrt(3.0) * (-t + s) / 2;\n    result[3] = term1;\n    result[5] = -term1;\n    return;\n  }\n  result[5] = result[3] = 0;\n  if (discriminant === 0) {\n    r13 = r < 0 ? -Math.pow(-r, 1.0 / 3.0) : Math.pow(r, 1.0 / 3.0);\n    result[0] = -term1 + 2.0 * r13;\n    result[4] = result[2] = -(r13 + term1);\n    return;\n  }\n  q = -q;\n  dum1 = q * q * q;\n  dum1 = Math.acos(r / Math.sqrt(dum1));\n  r13 = 2.0 * Math.sqrt(q);\n  result[0] = -term1 + r13 * Math.cos(dum1 / 3.0);\n  result[2] = -term1 + r13 * Math.cos((dum1 + 2.0 * Math.PI) / 3.0);\n  result[4] = -term1 + r13 * Math.cos((dum1 + 4.0 * Math.PI) / 3.0);\n  return;\n};\nvar sqdistToQuadraticBezier = function sqdistToQuadraticBezier(x, y, x1, y1, x2, y2, x3, y3) {\n  // Find minimum distance by using the minimum of the distance\n  // function between the given point and the curve\n\n  // This gives the coefficients of the resulting cubic equation\n  // whose roots tell us where a possible minimum is\n  // (Coefficients are divided by 4)\n\n  var a = 1.0 * x1 * x1 - 4 * x1 * x2 + 2 * x1 * x3 + 4 * x2 * x2 - 4 * x2 * x3 + x3 * x3 + y1 * y1 - 4 * y1 * y2 + 2 * y1 * y3 + 4 * y2 * y2 - 4 * y2 * y3 + y3 * y3;\n  var b = 1.0 * 9 * x1 * x2 - 3 * x1 * x1 - 3 * x1 * x3 - 6 * x2 * x2 + 3 * x2 * x3 + 9 * y1 * y2 - 3 * y1 * y1 - 3 * y1 * y3 - 6 * y2 * y2 + 3 * y2 * y3;\n  var c = 1.0 * 3 * x1 * x1 - 6 * x1 * x2 + x1 * x3 - x1 * x + 2 * x2 * x2 + 2 * x2 * x - x3 * x + 3 * y1 * y1 - 6 * y1 * y2 + y1 * y3 - y1 * y + 2 * y2 * y2 + 2 * y2 * y - y3 * y;\n  var d = 1.0 * x1 * x2 - x1 * x1 + x1 * x - x2 * x + y1 * y2 - y1 * y1 + y1 * y - y2 * y;\n\n  // debug(\"coefficients: \" + a / a + \", \" + b / a + \", \" + c / a + \", \" + d / a);\n\n  var roots = [];\n\n  // Use the cubic solving algorithm\n  solveCubic(a, b, c, d, roots);\n  var zeroThreshold = 0.0000001;\n  var params = [];\n  for (var index = 0; index < 6; index += 2) {\n    if (Math.abs(roots[index + 1]) < zeroThreshold && roots[index] >= 0 && roots[index] <= 1.0) {\n      params.push(roots[index]);\n    }\n  }\n  params.push(1.0);\n  params.push(0.0);\n  var minDistanceSquared = -1;\n  var curX, curY, distSquared;\n  for (var i = 0; i < params.length; i++) {\n    curX = Math.pow(1.0 - params[i], 2.0) * x1 + 2.0 * (1 - params[i]) * params[i] * x2 + params[i] * params[i] * x3;\n    curY = Math.pow(1 - params[i], 2.0) * y1 + 2 * (1.0 - params[i]) * params[i] * y2 + params[i] * params[i] * y3;\n    distSquared = Math.pow(curX - x, 2) + Math.pow(curY - y, 2);\n    // debug('distance for param ' + params[i] + \": \" + Math.sqrt(distSquared));\n    if (minDistanceSquared >= 0) {\n      if (distSquared < minDistanceSquared) {\n        minDistanceSquared = distSquared;\n      }\n    } else {\n      minDistanceSquared = distSquared;\n    }\n  }\n  return minDistanceSquared;\n};\nvar sqdistToFiniteLine = function sqdistToFiniteLine(x, y, x1, y1, x2, y2) {\n  var offset = [x - x1, y - y1];\n  var line = [x2 - x1, y2 - y1];\n  var lineSq = line[0] * line[0] + line[1] * line[1];\n  var hypSq = offset[0] * offset[0] + offset[1] * offset[1];\n  var dotProduct = offset[0] * line[0] + offset[1] * line[1];\n  var adjSq = dotProduct * dotProduct / lineSq;\n  if (dotProduct < 0) {\n    return hypSq;\n  }\n  if (adjSq > lineSq) {\n    return (x - x2) * (x - x2) + (y - y2) * (y - y2);\n  }\n  return hypSq - adjSq;\n};\nvar pointInsidePolygonPoints = function pointInsidePolygonPoints(x, y, points) {\n  var x1, y1, x2, y2;\n  var y3;\n\n  // Intersect with vertical line through (x, y)\n  var up = 0;\n  // let down = 0;\n  for (var i = 0; i < points.length / 2; i++) {\n    x1 = points[i * 2];\n    y1 = points[i * 2 + 1];\n    if (i + 1 < points.length / 2) {\n      x2 = points[(i + 1) * 2];\n      y2 = points[(i + 1) * 2 + 1];\n    } else {\n      x2 = points[(i + 1 - points.length / 2) * 2];\n      y2 = points[(i + 1 - points.length / 2) * 2 + 1];\n    }\n    if (x1 == x && x2 == x) ; else if (x1 >= x && x >= x2 || x1 <= x && x <= x2) {\n      y3 = (x - x1) / (x2 - x1) * (y2 - y1) + y1;\n      if (y3 > y) {\n        up++;\n      }\n\n      // if( y3 < y ){\n      // down++;\n      // }\n    } else {\n      continue;\n    }\n  }\n  if (up % 2 === 0) {\n    return false;\n  } else {\n    return true;\n  }\n};\nvar pointInsidePolygon = function pointInsidePolygon(x, y, basePoints, centerX, centerY, width, height, direction, padding) {\n  var transformedPoints = new Array(basePoints.length);\n\n  // Gives negative angle\n  var angle;\n  if (direction[0] != null) {\n    angle = Math.atan(direction[1] / direction[0]);\n    if (direction[0] < 0) {\n      angle = angle + Math.PI / 2;\n    } else {\n      angle = -angle - Math.PI / 2;\n    }\n  } else {\n    angle = direction;\n  }\n  var cos = Math.cos(-angle);\n  var sin = Math.sin(-angle);\n\n  //    console.log(\"base: \" + basePoints);\n  for (var i = 0; i < transformedPoints.length / 2; i++) {\n    transformedPoints[i * 2] = width / 2 * (basePoints[i * 2] * cos - basePoints[i * 2 + 1] * sin);\n    transformedPoints[i * 2 + 1] = height / 2 * (basePoints[i * 2 + 1] * cos + basePoints[i * 2] * sin);\n    transformedPoints[i * 2] += centerX;\n    transformedPoints[i * 2 + 1] += centerY;\n  }\n  var points;\n  if (padding > 0) {\n    var expandedLineSet = expandPolygon(transformedPoints, -padding);\n    points = joinLines(expandedLineSet);\n  } else {\n    points = transformedPoints;\n  }\n  return pointInsidePolygonPoints(x, y, points);\n};\nvar pointInsideRoundPolygon = function pointInsideRoundPolygon(x, y, basePoints, centerX, centerY, width, height, corners) {\n  var cutPolygonPoints = new Array(basePoints.length * 2);\n  for (var i = 0; i < corners.length; i++) {\n    var corner = corners[i];\n    cutPolygonPoints[i * 4 + 0] = corner.startX;\n    cutPolygonPoints[i * 4 + 1] = corner.startY;\n    cutPolygonPoints[i * 4 + 2] = corner.stopX;\n    cutPolygonPoints[i * 4 + 3] = corner.stopY;\n    var squaredDistance = Math.pow(corner.cx - x, 2) + Math.pow(corner.cy - y, 2);\n    if (squaredDistance <= Math.pow(corner.radius, 2)) {\n      return true;\n    }\n  }\n  return pointInsidePolygonPoints(x, y, cutPolygonPoints);\n};\nvar joinLines = function joinLines(lineSet) {\n  var vertices = new Array(lineSet.length / 2);\n  var currentLineStartX, currentLineStartY, currentLineEndX, currentLineEndY;\n  var nextLineStartX, nextLineStartY, nextLineEndX, nextLineEndY;\n  for (var i = 0; i < lineSet.length / 4; i++) {\n    currentLineStartX = lineSet[i * 4];\n    currentLineStartY = lineSet[i * 4 + 1];\n    currentLineEndX = lineSet[i * 4 + 2];\n    currentLineEndY = lineSet[i * 4 + 3];\n    if (i < lineSet.length / 4 - 1) {\n      nextLineStartX = lineSet[(i + 1) * 4];\n      nextLineStartY = lineSet[(i + 1) * 4 + 1];\n      nextLineEndX = lineSet[(i + 1) * 4 + 2];\n      nextLineEndY = lineSet[(i + 1) * 4 + 3];\n    } else {\n      nextLineStartX = lineSet[0];\n      nextLineStartY = lineSet[1];\n      nextLineEndX = lineSet[2];\n      nextLineEndY = lineSet[3];\n    }\n    var intersection = finiteLinesIntersect(currentLineStartX, currentLineStartY, currentLineEndX, currentLineEndY, nextLineStartX, nextLineStartY, nextLineEndX, nextLineEndY, true);\n    vertices[i * 2] = intersection[0];\n    vertices[i * 2 + 1] = intersection[1];\n  }\n  return vertices;\n};\nvar expandPolygon = function expandPolygon(points, pad) {\n  var expandedLineSet = new Array(points.length * 2);\n  var currentPointX, currentPointY, nextPointX, nextPointY;\n  for (var i = 0; i < points.length / 2; i++) {\n    currentPointX = points[i * 2];\n    currentPointY = points[i * 2 + 1];\n    if (i < points.length / 2 - 1) {\n      nextPointX = points[(i + 1) * 2];\n      nextPointY = points[(i + 1) * 2 + 1];\n    } else {\n      nextPointX = points[0];\n      nextPointY = points[1];\n    }\n\n    // Current line: [currentPointX, currentPointY] to [nextPointX, nextPointY]\n\n    // Assume CCW polygon winding\n\n    var offsetX = nextPointY - currentPointY;\n    var offsetY = -(nextPointX - currentPointX);\n\n    // Normalize\n    var offsetLength = Math.sqrt(offsetX * offsetX + offsetY * offsetY);\n    var normalizedOffsetX = offsetX / offsetLength;\n    var normalizedOffsetY = offsetY / offsetLength;\n    expandedLineSet[i * 4] = currentPointX + normalizedOffsetX * pad;\n    expandedLineSet[i * 4 + 1] = currentPointY + normalizedOffsetY * pad;\n    expandedLineSet[i * 4 + 2] = nextPointX + normalizedOffsetX * pad;\n    expandedLineSet[i * 4 + 3] = nextPointY + normalizedOffsetY * pad;\n  }\n  return expandedLineSet;\n};\nvar intersectLineEllipse = function intersectLineEllipse(x, y, centerX, centerY, ellipseWradius, ellipseHradius) {\n  var dispX = centerX - x;\n  var dispY = centerY - y;\n  dispX /= ellipseWradius;\n  dispY /= ellipseHradius;\n  var len = Math.sqrt(dispX * dispX + dispY * dispY);\n  var newLength = len - 1;\n  if (newLength < 0) {\n    return [];\n  }\n  var lenProportion = newLength / len;\n  return [(centerX - x) * lenProportion + x, (centerY - y) * lenProportion + y];\n};\nvar checkInEllipse = function checkInEllipse(x, y, width, height, centerX, centerY, padding) {\n  x -= centerX;\n  y -= centerY;\n  x /= width / 2 + padding;\n  y /= height / 2 + padding;\n  return x * x + y * y <= 1;\n};\n\n// Returns intersections of increasing distance from line's start point\nvar intersectLineCircle = function intersectLineCircle(x1, y1, x2, y2, centerX, centerY, radius) {\n  // Calculate d, direction vector of line\n  var d = [x2 - x1, y2 - y1]; // Direction vector of line\n  var f = [x1 - centerX, y1 - centerY];\n  var a = d[0] * d[0] + d[1] * d[1];\n  var b = 2 * (f[0] * d[0] + f[1] * d[1]);\n  var c = f[0] * f[0] + f[1] * f[1] - radius * radius;\n  var discriminant = b * b - 4 * a * c;\n  if (discriminant < 0) {\n    return [];\n  }\n  var t1 = (-b + Math.sqrt(discriminant)) / (2 * a);\n  var t2 = (-b - Math.sqrt(discriminant)) / (2 * a);\n  var tMin = Math.min(t1, t2);\n  var tMax = Math.max(t1, t2);\n  var inRangeParams = [];\n  if (tMin >= 0 && tMin <= 1) {\n    inRangeParams.push(tMin);\n  }\n  if (tMax >= 0 && tMax <= 1) {\n    inRangeParams.push(tMax);\n  }\n  if (inRangeParams.length === 0) {\n    return [];\n  }\n  var nearIntersectionX = inRangeParams[0] * d[0] + x1;\n  var nearIntersectionY = inRangeParams[0] * d[1] + y1;\n  if (inRangeParams.length > 1) {\n    if (inRangeParams[0] == inRangeParams[1]) {\n      return [nearIntersectionX, nearIntersectionY];\n    } else {\n      var farIntersectionX = inRangeParams[1] * d[0] + x1;\n      var farIntersectionY = inRangeParams[1] * d[1] + y1;\n      return [nearIntersectionX, nearIntersectionY, farIntersectionX, farIntersectionY];\n    }\n  } else {\n    return [nearIntersectionX, nearIntersectionY];\n  }\n};\nvar midOfThree = function midOfThree(a, b, c) {\n  if (b <= a && a <= c || c <= a && a <= b) {\n    return a;\n  } else if (a <= b && b <= c || c <= b && b <= a) {\n    return b;\n  } else {\n    return c;\n  }\n};\n\n// (x1,y1)=>(x2,y2) intersect with (x3,y3)=>(x4,y4)\nvar finiteLinesIntersect = function finiteLinesIntersect(x1, y1, x2, y2, x3, y3, x4, y4, infiniteLines) {\n  var dx13 = x1 - x3;\n  var dx21 = x2 - x1;\n  var dx43 = x4 - x3;\n  var dy13 = y1 - y3;\n  var dy21 = y2 - y1;\n  var dy43 = y4 - y3;\n  var ua_t = dx43 * dy13 - dy43 * dx13;\n  var ub_t = dx21 * dy13 - dy21 * dx13;\n  var u_b = dy43 * dx21 - dx43 * dy21;\n  if (u_b !== 0) {\n    var ua = ua_t / u_b;\n    var ub = ub_t / u_b;\n    var flptThreshold = 0.001;\n    var _min = 0 - flptThreshold;\n    var _max = 1 + flptThreshold;\n    if (_min <= ua && ua <= _max && _min <= ub && ub <= _max) {\n      return [x1 + ua * dx21, y1 + ua * dy21];\n    } else {\n      if (!infiniteLines) {\n        return [];\n      } else {\n        return [x1 + ua * dx21, y1 + ua * dy21];\n      }\n    }\n  } else {\n    if (ua_t === 0 || ub_t === 0) {\n      // Parallel, coincident lines. Check if overlap\n\n      // Check endpoint of second line\n      if (midOfThree(x1, x2, x4) === x4) {\n        return [x4, y4];\n      }\n\n      // Check start point of second line\n      if (midOfThree(x1, x2, x3) === x3) {\n        return [x3, y3];\n      }\n\n      // Endpoint of first line\n      if (midOfThree(x3, x4, x2) === x2) {\n        return [x2, y2];\n      }\n      return [];\n    } else {\n      // Parallel, non-coincident\n      return [];\n    }\n  }\n};\n\n// math.polygonIntersectLine( x, y, basePoints, centerX, centerY, width, height, padding )\n// intersect a node polygon (pts transformed)\n//\n// math.polygonIntersectLine( x, y, basePoints, centerX, centerY )\n// intersect the points (no transform)\nvar polygonIntersectLine = function polygonIntersectLine(x, y, basePoints, centerX, centerY, width, height, padding) {\n  var intersections = [];\n  var intersection;\n  var transformedPoints = new Array(basePoints.length);\n  var doTransform = true;\n  if (width == null) {\n    doTransform = false;\n  }\n  var points;\n  if (doTransform) {\n    for (var i = 0; i < transformedPoints.length / 2; i++) {\n      transformedPoints[i * 2] = basePoints[i * 2] * width + centerX;\n      transformedPoints[i * 2 + 1] = basePoints[i * 2 + 1] * height + centerY;\n    }\n    if (padding > 0) {\n      var expandedLineSet = expandPolygon(transformedPoints, -padding);\n      points = joinLines(expandedLineSet);\n    } else {\n      points = transformedPoints;\n    }\n  } else {\n    points = basePoints;\n  }\n  var currentX, currentY, nextX, nextY;\n  for (var _i2 = 0; _i2 < points.length / 2; _i2++) {\n    currentX = points[_i2 * 2];\n    currentY = points[_i2 * 2 + 1];\n    if (_i2 < points.length / 2 - 1) {\n      nextX = points[(_i2 + 1) * 2];\n      nextY = points[(_i2 + 1) * 2 + 1];\n    } else {\n      nextX = points[0];\n      nextY = points[1];\n    }\n    intersection = finiteLinesIntersect(x, y, centerX, centerY, currentX, currentY, nextX, nextY);\n    if (intersection.length !== 0) {\n      intersections.push(intersection[0], intersection[1]);\n    }\n  }\n  return intersections;\n};\nvar roundPolygonIntersectLine = function roundPolygonIntersectLine(x, y, basePoints, centerX, centerY, width, height, padding, corners) {\n  var intersections = [];\n  var intersection;\n  var lines = new Array(basePoints.length * 2);\n  corners.forEach(function (corner, i) {\n    if (i === 0) {\n      lines[lines.length - 2] = corner.startX;\n      lines[lines.length - 1] = corner.startY;\n    } else {\n      lines[i * 4 - 2] = corner.startX;\n      lines[i * 4 - 1] = corner.startY;\n    }\n    lines[i * 4] = corner.stopX;\n    lines[i * 4 + 1] = corner.stopY;\n    intersection = intersectLineCircle(x, y, centerX, centerY, corner.cx, corner.cy, corner.radius);\n    if (intersection.length !== 0) {\n      intersections.push(intersection[0], intersection[1]);\n    }\n  });\n  for (var i = 0; i < lines.length / 4; i++) {\n    intersection = finiteLinesIntersect(x, y, centerX, centerY, lines[i * 4], lines[i * 4 + 1], lines[i * 4 + 2], lines[i * 4 + 3], false);\n    if (intersection.length !== 0) {\n      intersections.push(intersection[0], intersection[1]);\n    }\n  }\n  if (intersections.length > 2) {\n    var lowestIntersection = [intersections[0], intersections[1]];\n    var lowestSquaredDistance = Math.pow(lowestIntersection[0] - x, 2) + Math.pow(lowestIntersection[1] - y, 2);\n    for (var _i3 = 1; _i3 < intersections.length / 2; _i3++) {\n      var squaredDistance = Math.pow(intersections[_i3 * 2] - x, 2) + Math.pow(intersections[_i3 * 2 + 1] - y, 2);\n      if (squaredDistance <= lowestSquaredDistance) {\n        lowestIntersection[0] = intersections[_i3 * 2];\n        lowestIntersection[1] = intersections[_i3 * 2 + 1];\n        lowestSquaredDistance = squaredDistance;\n      }\n    }\n    return lowestIntersection;\n  }\n  return intersections;\n};\nvar shortenIntersection = function shortenIntersection(intersection, offset, amount) {\n  var disp = [intersection[0] - offset[0], intersection[1] - offset[1]];\n  var length = Math.sqrt(disp[0] * disp[0] + disp[1] * disp[1]);\n  var lenRatio = (length - amount) / length;\n  if (lenRatio < 0) {\n    lenRatio = 0.00001;\n  }\n  return [offset[0] + lenRatio * disp[0], offset[1] + lenRatio * disp[1]];\n};\nvar generateUnitNgonPointsFitToSquare = function generateUnitNgonPointsFitToSquare(sides, rotationRadians) {\n  var points = generateUnitNgonPoints(sides, rotationRadians);\n  points = fitPolygonToSquare(points);\n  return points;\n};\nvar fitPolygonToSquare = function fitPolygonToSquare(points) {\n  var x, y;\n  var sides = points.length / 2;\n  var minX = Infinity,\n    minY = Infinity,\n    maxX = -Infinity,\n    maxY = -Infinity;\n  for (var i = 0; i < sides; i++) {\n    x = points[2 * i];\n    y = points[2 * i + 1];\n    minX = Math.min(minX, x);\n    maxX = Math.max(maxX, x);\n    minY = Math.min(minY, y);\n    maxY = Math.max(maxY, y);\n  }\n\n  // stretch factors\n  var sx = 2 / (maxX - minX);\n  var sy = 2 / (maxY - minY);\n  for (var _i4 = 0; _i4 < sides; _i4++) {\n    x = points[2 * _i4] = points[2 * _i4] * sx;\n    y = points[2 * _i4 + 1] = points[2 * _i4 + 1] * sy;\n    minX = Math.min(minX, x);\n    maxX = Math.max(maxX, x);\n    minY = Math.min(minY, y);\n    maxY = Math.max(maxY, y);\n  }\n  if (minY < -1) {\n    for (var _i5 = 0; _i5 < sides; _i5++) {\n      y = points[2 * _i5 + 1] = points[2 * _i5 + 1] + (-1 - minY);\n    }\n  }\n  return points;\n};\nvar generateUnitNgonPoints = function generateUnitNgonPoints(sides, rotationRadians) {\n  var increment = 1.0 / sides * 2 * Math.PI;\n  var startAngle = sides % 2 === 0 ? Math.PI / 2.0 + increment / 2.0 : Math.PI / 2.0;\n  startAngle += rotationRadians;\n  var points = new Array(sides * 2);\n  var currentAngle;\n  for (var i = 0; i < sides; i++) {\n    currentAngle = i * increment + startAngle;\n    points[2 * i] = Math.cos(currentAngle); // x\n    points[2 * i + 1] = Math.sin(-currentAngle); // y\n  }\n\n  return points;\n};\n\n// Set the default radius, unless half of width or height is smaller than default\nvar getRoundRectangleRadius = function getRoundRectangleRadius(width, height) {\n  return Math.min(width / 4, height / 4, 8);\n};\n\n// Set the default radius\nvar getRoundPolygonRadius = function getRoundPolygonRadius(width, height) {\n  return Math.min(width / 10, height / 10, 8);\n};\nvar getCutRectangleCornerLength = function getCutRectangleCornerLength() {\n  return 8;\n};\nvar bezierPtsToQuadCoeff = function bezierPtsToQuadCoeff(p0, p1, p2) {\n  return [p0 - 2 * p1 + p2, 2 * (p1 - p0), p0];\n};\n\n// get curve width, height, and control point position offsets as a percentage of node height / width\nvar getBarrelCurveConstants = function getBarrelCurveConstants(width, height) {\n  return {\n    heightOffset: Math.min(15, 0.05 * height),\n    widthOffset: Math.min(100, 0.25 * width),\n    ctrlPtOffsetPct: 0.05\n  };\n};\n\nvar pageRankDefaults = defaults$g({\n  dampingFactor: 0.8,\n  precision: 0.000001,\n  iterations: 200,\n  weight: function weight(edge) {\n    return 1;\n  }\n});\nvar elesfn$o = {\n  pageRank: function pageRank(options) {\n    var _pageRankDefaults = pageRankDefaults(options),\n      dampingFactor = _pageRankDefaults.dampingFactor,\n      precision = _pageRankDefaults.precision,\n      iterations = _pageRankDefaults.iterations,\n      weight = _pageRankDefaults.weight;\n    var cy = this._private.cy;\n    var _this$byGroup = this.byGroup(),\n      nodes = _this$byGroup.nodes,\n      edges = _this$byGroup.edges;\n    var numNodes = nodes.length;\n    var numNodesSqd = numNodes * numNodes;\n    var numEdges = edges.length;\n\n    // Construct transposed adjacency matrix\n    // First lets have a zeroed matrix of the right size\n    // We'll also keep track of the sum of each column\n    var matrix = new Array(numNodesSqd);\n    var columnSum = new Array(numNodes);\n    var additionalProb = (1 - dampingFactor) / numNodes;\n\n    // Create null matrix\n    for (var i = 0; i < numNodes; i++) {\n      for (var j = 0; j < numNodes; j++) {\n        var n = i * numNodes + j;\n        matrix[n] = 0;\n      }\n      columnSum[i] = 0;\n    }\n\n    // Now, process edges\n    for (var _i = 0; _i < numEdges; _i++) {\n      var edge = edges[_i];\n      var srcId = edge.data('source');\n      var tgtId = edge.data('target');\n\n      // Don't include loops in the matrix\n      if (srcId === tgtId) {\n        continue;\n      }\n      var s = nodes.indexOfId(srcId);\n      var t = nodes.indexOfId(tgtId);\n      var w = weight(edge);\n      var _n = t * numNodes + s;\n\n      // Update matrix\n      matrix[_n] += w;\n\n      // Update column sum\n      columnSum[s] += w;\n    }\n\n    // Add additional probability based on damping factor\n    // Also, take into account columns that have sum = 0\n    var p = 1.0 / numNodes + additionalProb; // Shorthand\n\n    // Traverse matrix, column by column\n    for (var _j = 0; _j < numNodes; _j++) {\n      if (columnSum[_j] === 0) {\n        // No 'links' out from node jth, assume equal probability for each possible node\n        for (var _i2 = 0; _i2 < numNodes; _i2++) {\n          var _n2 = _i2 * numNodes + _j;\n          matrix[_n2] = p;\n        }\n      } else {\n        // Node jth has outgoing link, compute normalized probabilities\n        for (var _i3 = 0; _i3 < numNodes; _i3++) {\n          var _n3 = _i3 * numNodes + _j;\n          matrix[_n3] = matrix[_n3] / columnSum[_j] + additionalProb;\n        }\n      }\n    }\n\n    // Compute dominant eigenvector using power method\n    var eigenvector = new Array(numNodes);\n    var temp = new Array(numNodes);\n    var previous;\n\n    // Start with a vector of all 1's\n    // Also, initialize a null vector which will be used as shorthand\n    for (var _i4 = 0; _i4 < numNodes; _i4++) {\n      eigenvector[_i4] = 1;\n    }\n    for (var iter = 0; iter < iterations; iter++) {\n      // Temp array with all 0's\n      for (var _i5 = 0; _i5 < numNodes; _i5++) {\n        temp[_i5] = 0;\n      }\n\n      // Multiply matrix with previous result\n      for (var _i6 = 0; _i6 < numNodes; _i6++) {\n        for (var _j2 = 0; _j2 < numNodes; _j2++) {\n          var _n4 = _i6 * numNodes + _j2;\n          temp[_i6] += matrix[_n4] * eigenvector[_j2];\n        }\n      }\n      inPlaceSumNormalize(temp);\n      previous = eigenvector;\n      eigenvector = temp;\n      temp = previous;\n      var diff = 0;\n      // Compute difference (squared module) of both vectors\n      for (var _i7 = 0; _i7 < numNodes; _i7++) {\n        var delta = previous[_i7] - eigenvector[_i7];\n        diff += delta * delta;\n      }\n\n      // If difference is less than the desired threshold, stop iterating\n      if (diff < precision) {\n        break;\n      }\n    }\n\n    // Construct result\n    var res = {\n      rank: function rank(node) {\n        node = cy.collection(node)[0];\n        return eigenvector[nodes.indexOf(node)];\n      }\n    };\n    return res;\n  } // pageRank\n}; // elesfn\n\nvar defaults$f = defaults$g({\n  root: null,\n  weight: function weight(edge) {\n    return 1;\n  },\n  directed: false,\n  alpha: 0\n});\nvar elesfn$n = {\n  degreeCentralityNormalized: function degreeCentralityNormalized(options) {\n    options = defaults$f(options);\n    var cy = this.cy();\n    var nodes = this.nodes();\n    var numNodes = nodes.length;\n    if (!options.directed) {\n      var degrees = {};\n      var maxDegree = 0;\n      for (var i = 0; i < numNodes; i++) {\n        var node = nodes[i];\n\n        // add current node to the current options object and call degreeCentrality\n        options.root = node;\n        var currDegree = this.degreeCentrality(options);\n        if (maxDegree < currDegree.degree) {\n          maxDegree = currDegree.degree;\n        }\n        degrees[node.id()] = currDegree.degree;\n      }\n      return {\n        degree: function degree(node) {\n          if (maxDegree === 0) {\n            return 0;\n          }\n          if (string(node)) {\n            // from is a selector string\n            node = cy.filter(node);\n          }\n          return degrees[node.id()] / maxDegree;\n        }\n      };\n    } else {\n      var indegrees = {};\n      var outdegrees = {};\n      var maxIndegree = 0;\n      var maxOutdegree = 0;\n      for (var _i = 0; _i < numNodes; _i++) {\n        var _node = nodes[_i];\n        var id = _node.id();\n\n        // add current node to the current options object and call degreeCentrality\n        options.root = _node;\n        var _currDegree = this.degreeCentrality(options);\n        if (maxIndegree < _currDegree.indegree) maxIndegree = _currDegree.indegree;\n        if (maxOutdegree < _currDegree.outdegree) maxOutdegree = _currDegree.outdegree;\n        indegrees[id] = _currDegree.indegree;\n        outdegrees[id] = _currDegree.outdegree;\n      }\n      return {\n        indegree: function indegree(node) {\n          if (maxIndegree == 0) {\n            return 0;\n          }\n          if (string(node)) {\n            // from is a selector string\n            node = cy.filter(node);\n          }\n          return indegrees[node.id()] / maxIndegree;\n        },\n        outdegree: function outdegree(node) {\n          if (maxOutdegree === 0) {\n            return 0;\n          }\n          if (string(node)) {\n            // from is a selector string\n            node = cy.filter(node);\n          }\n          return outdegrees[node.id()] / maxOutdegree;\n        }\n      };\n    }\n  },\n  // degreeCentralityNormalized\n\n  // Implemented from the algorithm in Opsahl's paper\n  // \"Node centrality in weighted networks: Generalizing degree and shortest paths\"\n  // check the heading 2 \"Degree\"\n  degreeCentrality: function degreeCentrality(options) {\n    options = defaults$f(options);\n    var cy = this.cy();\n    var callingEles = this;\n    var _options = options,\n      root = _options.root,\n      weight = _options.weight,\n      directed = _options.directed,\n      alpha = _options.alpha;\n    root = cy.collection(root)[0];\n    if (!directed) {\n      var connEdges = root.connectedEdges().intersection(callingEles);\n      var k = connEdges.length;\n      var s = 0;\n\n      // Now, sum edge weights\n      for (var i = 0; i < connEdges.length; i++) {\n        s += weight(connEdges[i]);\n      }\n      return {\n        degree: Math.pow(k, 1 - alpha) * Math.pow(s, alpha)\n      };\n    } else {\n      var edges = root.connectedEdges();\n      var incoming = edges.filter(function (edge) {\n        return edge.target().same(root) && callingEles.has(edge);\n      });\n      var outgoing = edges.filter(function (edge) {\n        return edge.source().same(root) && callingEles.has(edge);\n      });\n      var k_in = incoming.length;\n      var k_out = outgoing.length;\n      var s_in = 0;\n      var s_out = 0;\n\n      // Now, sum incoming edge weights\n      for (var _i2 = 0; _i2 < incoming.length; _i2++) {\n        s_in += weight(incoming[_i2]);\n      }\n\n      // Now, sum outgoing edge weights\n      for (var _i3 = 0; _i3 < outgoing.length; _i3++) {\n        s_out += weight(outgoing[_i3]);\n      }\n      return {\n        indegree: Math.pow(k_in, 1 - alpha) * Math.pow(s_in, alpha),\n        outdegree: Math.pow(k_out, 1 - alpha) * Math.pow(s_out, alpha)\n      };\n    }\n  } // degreeCentrality\n}; // elesfn\n\n// nice, short mathematical alias\nelesfn$n.dc = elesfn$n.degreeCentrality;\nelesfn$n.dcn = elesfn$n.degreeCentralityNormalised = elesfn$n.degreeCentralityNormalized;\n\nvar defaults$e = defaults$g({\n  harmonic: true,\n  weight: function weight() {\n    return 1;\n  },\n  directed: false,\n  root: null\n});\nvar elesfn$m = {\n  closenessCentralityNormalized: function closenessCentralityNormalized(options) {\n    var _defaults = defaults$e(options),\n      harmonic = _defaults.harmonic,\n      weight = _defaults.weight,\n      directed = _defaults.directed;\n    var cy = this.cy();\n    var closenesses = {};\n    var maxCloseness = 0;\n    var nodes = this.nodes();\n    var fw = this.floydWarshall({\n      weight: weight,\n      directed: directed\n    });\n\n    // Compute closeness for every node and find the maximum closeness\n    for (var i = 0; i < nodes.length; i++) {\n      var currCloseness = 0;\n      var node_i = nodes[i];\n      for (var j = 0; j < nodes.length; j++) {\n        if (i !== j) {\n          var d = fw.distance(node_i, nodes[j]);\n          if (harmonic) {\n            currCloseness += 1 / d;\n          } else {\n            currCloseness += d;\n          }\n        }\n      }\n      if (!harmonic) {\n        currCloseness = 1 / currCloseness;\n      }\n      if (maxCloseness < currCloseness) {\n        maxCloseness = currCloseness;\n      }\n      closenesses[node_i.id()] = currCloseness;\n    }\n    return {\n      closeness: function closeness(node) {\n        if (maxCloseness == 0) {\n          return 0;\n        }\n        if (string(node)) {\n          // from is a selector string\n          node = cy.filter(node)[0].id();\n        } else {\n          // from is a node\n          node = node.id();\n        }\n        return closenesses[node] / maxCloseness;\n      }\n    };\n  },\n  // Implemented from pseudocode from wikipedia\n  closenessCentrality: function closenessCentrality(options) {\n    var _defaults2 = defaults$e(options),\n      root = _defaults2.root,\n      weight = _defaults2.weight,\n      directed = _defaults2.directed,\n      harmonic = _defaults2.harmonic;\n    root = this.filter(root)[0];\n\n    // we need distance from this node to every other node\n    var dijkstra = this.dijkstra({\n      root: root,\n      weight: weight,\n      directed: directed\n    });\n    var totalDistance = 0;\n    var nodes = this.nodes();\n    for (var i = 0; i < nodes.length; i++) {\n      var n = nodes[i];\n      if (!n.same(root)) {\n        var d = dijkstra.distanceTo(n);\n        if (harmonic) {\n          totalDistance += 1 / d;\n        } else {\n          totalDistance += d;\n        }\n      }\n    }\n    return harmonic ? totalDistance : 1 / totalDistance;\n  } // closenessCentrality\n}; // elesfn\n\n// nice, short mathematical alias\nelesfn$m.cc = elesfn$m.closenessCentrality;\nelesfn$m.ccn = elesfn$m.closenessCentralityNormalised = elesfn$m.closenessCentralityNormalized;\n\nvar defaults$d = defaults$g({\n  weight: null,\n  directed: false\n});\nvar elesfn$l = {\n  // Implemented from the algorithm in the paper \"On Variants of Shortest-Path Betweenness Centrality and their Generic Computation\" by Ulrik Brandes\n  betweennessCentrality: function betweennessCentrality(options) {\n    var _defaults = defaults$d(options),\n      directed = _defaults.directed,\n      weight = _defaults.weight;\n    var weighted = weight != null;\n    var cy = this.cy();\n\n    // starting\n    var V = this.nodes();\n    var A = {};\n    var _C = {};\n    var max = 0;\n    var C = {\n      set: function set(key, val) {\n        _C[key] = val;\n        if (val > max) {\n          max = val;\n        }\n      },\n      get: function get(key) {\n        return _C[key];\n      }\n    };\n\n    // A contains the neighborhoods of every node\n    for (var i = 0; i < V.length; i++) {\n      var v = V[i];\n      var vid = v.id();\n      if (directed) {\n        A[vid] = v.outgoers().nodes(); // get outgoers of every node\n      } else {\n        A[vid] = v.openNeighborhood().nodes(); // get neighbors of every node\n      }\n\n      C.set(vid, 0);\n    }\n    var _loop = function _loop(s) {\n      var sid = V[s].id();\n      var S = []; // stack\n      var P = {};\n      var g = {};\n      var d = {};\n      var Q = new heap(function (a, b) {\n        return d[a] - d[b];\n      }); // queue\n\n      // init dictionaries\n      for (var _i = 0; _i < V.length; _i++) {\n        var _vid = V[_i].id();\n        P[_vid] = [];\n        g[_vid] = 0;\n        d[_vid] = Infinity;\n      }\n      g[sid] = 1; // sigma\n      d[sid] = 0; // distance to s\n\n      Q.push(sid);\n      while (!Q.empty()) {\n        var _v = Q.pop();\n        S.push(_v);\n        if (weighted) {\n          for (var j = 0; j < A[_v].length; j++) {\n            var w = A[_v][j];\n            var vEle = cy.getElementById(_v);\n            var edge = void 0;\n            if (vEle.edgesTo(w).length > 0) {\n              edge = vEle.edgesTo(w)[0];\n            } else {\n              edge = w.edgesTo(vEle)[0];\n            }\n            var edgeWeight = weight(edge);\n            w = w.id();\n            if (d[w] > d[_v] + edgeWeight) {\n              d[w] = d[_v] + edgeWeight;\n              if (Q.nodes.indexOf(w) < 0) {\n                //if w is not in Q\n                Q.push(w);\n              } else {\n                // update position if w is in Q\n                Q.updateItem(w);\n              }\n              g[w] = 0;\n              P[w] = [];\n            }\n            if (d[w] == d[_v] + edgeWeight) {\n              g[w] = g[w] + g[_v];\n              P[w].push(_v);\n            }\n          }\n        } else {\n          for (var _j = 0; _j < A[_v].length; _j++) {\n            var _w = A[_v][_j].id();\n            if (d[_w] == Infinity) {\n              Q.push(_w);\n              d[_w] = d[_v] + 1;\n            }\n            if (d[_w] == d[_v] + 1) {\n              g[_w] = g[_w] + g[_v];\n              P[_w].push(_v);\n            }\n          }\n        }\n      }\n      var e = {};\n      for (var _i2 = 0; _i2 < V.length; _i2++) {\n        e[V[_i2].id()] = 0;\n      }\n      while (S.length > 0) {\n        var _w2 = S.pop();\n        for (var _j2 = 0; _j2 < P[_w2].length; _j2++) {\n          var _v2 = P[_w2][_j2];\n          e[_v2] = e[_v2] + g[_v2] / g[_w2] * (1 + e[_w2]);\n        }\n        if (_w2 != V[s].id()) {\n          C.set(_w2, C.get(_w2) + e[_w2]);\n        }\n      }\n    };\n    for (var s = 0; s < V.length; s++) {\n      _loop(s);\n    }\n    var ret = {\n      betweenness: function betweenness(node) {\n        var id = cy.collection(node).id();\n        return C.get(id);\n      },\n      betweennessNormalized: function betweennessNormalized(node) {\n        if (max == 0) {\n          return 0;\n        }\n        var id = cy.collection(node).id();\n        return C.get(id) / max;\n      }\n    };\n\n    // alias\n    ret.betweennessNormalised = ret.betweennessNormalized;\n    return ret;\n  } // betweennessCentrality\n}; // elesfn\n\n// nice, short mathematical alias\nelesfn$l.bc = elesfn$l.betweennessCentrality;\n\n// Implemented by Zoe Xi @zoexi for GSOC 2016\n\n/* eslint-disable no-unused-vars */\nvar defaults$c = defaults$g({\n  expandFactor: 2,\n  // affects time of computation and cluster granularity to some extent: M * M\n  inflateFactor: 2,\n  // affects cluster granularity (the greater the value, the more clusters): M(i,j) / E(j)\n  multFactor: 1,\n  // optional self loops for each node. Use a neutral value to improve cluster computations.\n  maxIterations: 20,\n  // maximum number of iterations of the MCL algorithm in a single run\n  attributes: [\n  // attributes/features used to group nodes, ie. similarity values between nodes\n  function (edge) {\n    return 1;\n  }]\n});\n/* eslint-enable */\n\nvar setOptions$3 = function setOptions(options) {\n  return defaults$c(options);\n};\n/* eslint-enable */\n\nvar getSimilarity$1 = function getSimilarity(edge, attributes) {\n  var total = 0;\n  for (var i = 0; i < attributes.length; i++) {\n    total += attributes[i](edge);\n  }\n  return total;\n};\nvar addLoops = function addLoops(M, n, val) {\n  for (var i = 0; i < n; i++) {\n    M[i * n + i] = val;\n  }\n};\nvar normalize = function normalize(M, n) {\n  var sum;\n  for (var col = 0; col < n; col++) {\n    sum = 0;\n    for (var row = 0; row < n; row++) {\n      sum += M[row * n + col];\n    }\n    for (var _row = 0; _row < n; _row++) {\n      M[_row * n + col] = M[_row * n + col] / sum;\n    }\n  }\n};\n\n// TODO: blocked matrix multiplication?\nvar mmult = function mmult(A, B, n) {\n  var C = new Array(n * n);\n  for (var i = 0; i < n; i++) {\n    for (var j = 0; j < n; j++) {\n      C[i * n + j] = 0;\n    }\n    for (var k = 0; k < n; k++) {\n      for (var _j = 0; _j < n; _j++) {\n        C[i * n + _j] += A[i * n + k] * B[k * n + _j];\n      }\n    }\n  }\n  return C;\n};\nvar expand = function expand(M, n, expandFactor /** power **/) {\n  var _M = M.slice(0);\n  for (var p = 1; p < expandFactor; p++) {\n    M = mmult(M, _M, n);\n  }\n  return M;\n};\nvar inflate = function inflate(M, n, inflateFactor /** r **/) {\n  var _M = new Array(n * n);\n\n  // M(i,j) ^ inflatePower\n  for (var i = 0; i < n * n; i++) {\n    _M[i] = Math.pow(M[i], inflateFactor);\n  }\n  normalize(_M, n);\n  return _M;\n};\nvar hasConverged = function hasConverged(M, _M, n2, roundFactor) {\n  // Check that both matrices have the same elements (i,j)\n  for (var i = 0; i < n2; i++) {\n    var v1 = Math.round(M[i] * Math.pow(10, roundFactor)) / Math.pow(10, roundFactor); // truncate to 'roundFactor' decimal places\n    var v2 = Math.round(_M[i] * Math.pow(10, roundFactor)) / Math.pow(10, roundFactor);\n    if (v1 !== v2) {\n      return false;\n    }\n  }\n  return true;\n};\nvar assign$2 = function assign(M, n, nodes, cy) {\n  var clusters = [];\n  for (var i = 0; i < n; i++) {\n    var cluster = [];\n    for (var j = 0; j < n; j++) {\n      // Row-wise attractors and elements that they attract belong in same cluster\n      if (Math.round(M[i * n + j] * 1000) / 1000 > 0) {\n        cluster.push(nodes[j]);\n      }\n    }\n    if (cluster.length !== 0) {\n      clusters.push(cy.collection(cluster));\n    }\n  }\n  return clusters;\n};\nvar isDuplicate = function isDuplicate(c1, c2) {\n  for (var i = 0; i < c1.length; i++) {\n    if (!c2[i] || c1[i].id() !== c2[i].id()) {\n      return false;\n    }\n  }\n  return true;\n};\nvar removeDuplicates = function removeDuplicates(clusters) {\n  for (var i = 0; i < clusters.length; i++) {\n    for (var j = 0; j < clusters.length; j++) {\n      if (i != j && isDuplicate(clusters[i], clusters[j])) {\n        clusters.splice(j, 1);\n      }\n    }\n  }\n  return clusters;\n};\nvar markovClustering = function markovClustering(options) {\n  var nodes = this.nodes();\n  var edges = this.edges();\n  var cy = this.cy();\n\n  // Set parameters of algorithm:\n  var opts = setOptions$3(options);\n\n  // Map each node to its position in node array\n  var id2position = {};\n  for (var i = 0; i < nodes.length; i++) {\n    id2position[nodes[i].id()] = i;\n  }\n\n  // Generate stochastic matrix M from input graph G (should be symmetric/undirected)\n  var n = nodes.length,\n    n2 = n * n;\n  var M = new Array(n2),\n    _M;\n  for (var _i = 0; _i < n2; _i++) {\n    M[_i] = 0;\n  }\n  for (var e = 0; e < edges.length; e++) {\n    var edge = edges[e];\n    var _i2 = id2position[edge.source().id()];\n    var j = id2position[edge.target().id()];\n    var sim = getSimilarity$1(edge, opts.attributes);\n    M[_i2 * n + j] += sim; // G should be symmetric and undirected\n    M[j * n + _i2] += sim;\n  }\n\n  // Begin Markov cluster algorithm\n\n  // Step 1: Add self loops to each node, ie. add multFactor to matrix diagonal\n  addLoops(M, n, opts.multFactor);\n\n  // Step 2: M = normalize( M );\n  normalize(M, n);\n  var isStillMoving = true;\n  var iterations = 0;\n  while (isStillMoving && iterations < opts.maxIterations) {\n    isStillMoving = false;\n\n    // Step 3:\n    _M = expand(M, n, opts.expandFactor);\n\n    // Step 4:\n    M = inflate(_M, n, opts.inflateFactor);\n\n    // Step 5: check to see if ~steady state has been reached\n    if (!hasConverged(M, _M, n2, 4)) {\n      isStillMoving = true;\n    }\n    iterations++;\n  }\n\n  // Build clusters from matrix\n  var clusters = assign$2(M, n, nodes, cy);\n\n  // Remove duplicate clusters due to symmetry of graph and M matrix\n  clusters = removeDuplicates(clusters);\n  return clusters;\n};\nvar markovClustering$1 = {\n  markovClustering: markovClustering,\n  mcl: markovClustering\n};\n\n// Common distance metrics for clustering algorithms\nvar identity = function identity(x) {\n  return x;\n};\nvar absDiff = function absDiff(p, q) {\n  return Math.abs(q - p);\n};\nvar addAbsDiff = function addAbsDiff(total, p, q) {\n  return total + absDiff(p, q);\n};\nvar addSquaredDiff = function addSquaredDiff(total, p, q) {\n  return total + Math.pow(q - p, 2);\n};\nvar sqrt = function sqrt(x) {\n  return Math.sqrt(x);\n};\nvar maxAbsDiff = function maxAbsDiff(currentMax, p, q) {\n  return Math.max(currentMax, absDiff(p, q));\n};\nvar getDistance = function getDistance(length, getP, getQ, init, visit) {\n  var post = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : identity;\n  var ret = init;\n  var p, q;\n  for (var dim = 0; dim < length; dim++) {\n    p = getP(dim);\n    q = getQ(dim);\n    ret = visit(ret, p, q);\n  }\n  return post(ret);\n};\nvar distances = {\n  euclidean: function euclidean(length, getP, getQ) {\n    if (length >= 2) {\n      return getDistance(length, getP, getQ, 0, addSquaredDiff, sqrt);\n    } else {\n      // for single attr case, more efficient to avoid sqrt\n      return getDistance(length, getP, getQ, 0, addAbsDiff);\n    }\n  },\n  squaredEuclidean: function squaredEuclidean(length, getP, getQ) {\n    return getDistance(length, getP, getQ, 0, addSquaredDiff);\n  },\n  manhattan: function manhattan(length, getP, getQ) {\n    return getDistance(length, getP, getQ, 0, addAbsDiff);\n  },\n  max: function max(length, getP, getQ) {\n    return getDistance(length, getP, getQ, -Infinity, maxAbsDiff);\n  }\n};\n\n// in case the user accidentally doesn't use camel case\ndistances['squared-euclidean'] = distances['squaredEuclidean'];\ndistances['squaredeuclidean'] = distances['squaredEuclidean'];\nfunction clusteringDistance (method, length, getP, getQ, nodeP, nodeQ) {\n  var impl;\n  if (fn$6(method)) {\n    impl = method;\n  } else {\n    impl = distances[method] || distances.euclidean;\n  }\n  if (length === 0 && fn$6(method)) {\n    return impl(nodeP, nodeQ);\n  } else {\n    return impl(length, getP, getQ, nodeP, nodeQ);\n  }\n}\n\nvar defaults$b = defaults$g({\n  k: 2,\n  m: 2,\n  sensitivityThreshold: 0.0001,\n  distance: 'euclidean',\n  maxIterations: 10,\n  attributes: [],\n  testMode: false,\n  testCentroids: null\n});\nvar setOptions$2 = function setOptions(options) {\n  return defaults$b(options);\n};\n\nvar getDist = function getDist(type, node, centroid, attributes, mode) {\n  var noNodeP = mode !== 'kMedoids';\n  var getP = noNodeP ? function (i) {\n    return centroid[i];\n  } : function (i) {\n    return attributes[i](centroid);\n  };\n  var getQ = function getQ(i) {\n    return attributes[i](node);\n  };\n  var nodeP = centroid;\n  var nodeQ = node;\n  return clusteringDistance(type, attributes.length, getP, getQ, nodeP, nodeQ);\n};\nvar randomCentroids = function randomCentroids(nodes, k, attributes) {\n  var ndim = attributes.length;\n  var min = new Array(ndim);\n  var max = new Array(ndim);\n  var centroids = new Array(k);\n  var centroid = null;\n\n  // Find min, max values for each attribute dimension\n  for (var i = 0; i < ndim; i++) {\n    min[i] = nodes.min(attributes[i]).value;\n    max[i] = nodes.max(attributes[i]).value;\n  }\n\n  // Build k centroids, each represented as an n-dim feature vector\n  for (var c = 0; c < k; c++) {\n    centroid = [];\n    for (var _i = 0; _i < ndim; _i++) {\n      centroid[_i] = Math.random() * (max[_i] - min[_i]) + min[_i]; // random initial value\n    }\n\n    centroids[c] = centroid;\n  }\n  return centroids;\n};\nvar classify = function classify(node, centroids, distance, attributes, type) {\n  var min = Infinity;\n  var index = 0;\n  for (var i = 0; i < centroids.length; i++) {\n    var dist = getDist(distance, node, centroids[i], attributes, type);\n    if (dist < min) {\n      min = dist;\n      index = i;\n    }\n  }\n  return index;\n};\nvar buildCluster = function buildCluster(centroid, nodes, assignment) {\n  var cluster = [];\n  var node = null;\n  for (var n = 0; n < nodes.length; n++) {\n    node = nodes[n];\n    if (assignment[node.id()] === centroid) {\n      //console.log(\"Node \" + node.id() + \" is associated with medoid #: \" + m);\n      cluster.push(node);\n    }\n  }\n  return cluster;\n};\nvar haveValuesConverged = function haveValuesConverged(v1, v2, sensitivityThreshold) {\n  return Math.abs(v2 - v1) <= sensitivityThreshold;\n};\nvar haveMatricesConverged = function haveMatricesConverged(v1, v2, sensitivityThreshold) {\n  for (var i = 0; i < v1.length; i++) {\n    for (var j = 0; j < v1[i].length; j++) {\n      var diff = Math.abs(v1[i][j] - v2[i][j]);\n      if (diff > sensitivityThreshold) {\n        return false;\n      }\n    }\n  }\n  return true;\n};\nvar seenBefore = function seenBefore(node, medoids, n) {\n  for (var i = 0; i < n; i++) {\n    if (node === medoids[i]) return true;\n  }\n  return false;\n};\nvar randomMedoids = function randomMedoids(nodes, k) {\n  var medoids = new Array(k);\n\n  // For small data sets, the probability of medoid conflict is greater,\n  // so we need to check to see if we've already seen or chose this node before.\n  if (nodes.length < 50) {\n    // Randomly select k medoids from the n nodes\n    for (var i = 0; i < k; i++) {\n      var node = nodes[Math.floor(Math.random() * nodes.length)];\n\n      // If we've already chosen this node to be a medoid, don't choose it again (for small data sets).\n      // Instead choose a different random node.\n      while (seenBefore(node, medoids, i)) {\n        node = nodes[Math.floor(Math.random() * nodes.length)];\n      }\n      medoids[i] = node;\n    }\n  } else {\n    // Relatively large data set, so pretty safe to not check and just select random nodes\n    for (var _i2 = 0; _i2 < k; _i2++) {\n      medoids[_i2] = nodes[Math.floor(Math.random() * nodes.length)];\n    }\n  }\n  return medoids;\n};\nvar findCost = function findCost(potentialNewMedoid, cluster, attributes) {\n  var cost = 0;\n  for (var n = 0; n < cluster.length; n++) {\n    cost += getDist('manhattan', cluster[n], potentialNewMedoid, attributes, 'kMedoids');\n  }\n  return cost;\n};\nvar kMeans = function kMeans(options) {\n  var cy = this.cy();\n  var nodes = this.nodes();\n  var node = null;\n\n  // Set parameters of algorithm: # of clusters, distance metric, etc.\n  var opts = setOptions$2(options);\n\n  // Begin k-means algorithm\n  var clusters = new Array(opts.k);\n  var assignment = {};\n  var centroids;\n\n  // Step 1: Initialize centroid positions\n  if (opts.testMode) {\n    if (typeof opts.testCentroids === 'number') {\n      // TODO: implement a seeded random number generator.\n      opts.testCentroids;\n      centroids = randomCentroids(nodes, opts.k, opts.attributes);\n    } else if (_typeof(opts.testCentroids) === 'object') {\n      centroids = opts.testCentroids;\n    } else {\n      centroids = randomCentroids(nodes, opts.k, opts.attributes);\n    }\n  } else {\n    centroids = randomCentroids(nodes, opts.k, opts.attributes);\n  }\n  var isStillMoving = true;\n  var iterations = 0;\n  while (isStillMoving && iterations < opts.maxIterations) {\n    // Step 2: Assign nodes to the nearest centroid\n    for (var n = 0; n < nodes.length; n++) {\n      node = nodes[n];\n      // Determine which cluster this node belongs to: node id => cluster #\n      assignment[node.id()] = classify(node, centroids, opts.distance, opts.attributes, 'kMeans');\n    }\n\n    // Step 3: For each of the k clusters, update its centroid\n    isStillMoving = false;\n    for (var c = 0; c < opts.k; c++) {\n      // Get all nodes that belong to this cluster\n      var cluster = buildCluster(c, nodes, assignment);\n      if (cluster.length === 0) {\n        // If cluster is empty, break out early & move to next cluster\n        continue;\n      }\n\n      // Update centroids by calculating avg of all nodes within the cluster.\n      var ndim = opts.attributes.length;\n      var centroid = centroids[c]; // [ dim_1, dim_2, dim_3, ... , dim_n ]\n      var newCentroid = new Array(ndim);\n      var sum = new Array(ndim);\n      for (var d = 0; d < ndim; d++) {\n        sum[d] = 0.0;\n        for (var i = 0; i < cluster.length; i++) {\n          node = cluster[i];\n          sum[d] += opts.attributes[d](node);\n        }\n        newCentroid[d] = sum[d] / cluster.length;\n\n        // Check to see if algorithm has converged, i.e. when centroids no longer change\n        if (!haveValuesConverged(newCentroid[d], centroid[d], opts.sensitivityThreshold)) {\n          isStillMoving = true;\n        }\n      }\n      centroids[c] = newCentroid;\n      clusters[c] = cy.collection(cluster);\n    }\n    iterations++;\n  }\n  return clusters;\n};\nvar kMedoids = function kMedoids(options) {\n  var cy = this.cy();\n  var nodes = this.nodes();\n  var node = null;\n  var opts = setOptions$2(options);\n\n  // Begin k-medoids algorithm\n  var clusters = new Array(opts.k);\n  var medoids;\n  var assignment = {};\n  var curCost;\n  var minCosts = new Array(opts.k); // minimum cost configuration for each cluster\n\n  // Step 1: Initialize k medoids\n  if (opts.testMode) {\n    if (typeof opts.testCentroids === 'number') ; else if (_typeof(opts.testCentroids) === 'object') {\n      medoids = opts.testCentroids;\n    } else {\n      medoids = randomMedoids(nodes, opts.k);\n    }\n  } else {\n    medoids = randomMedoids(nodes, opts.k);\n  }\n  var isStillMoving = true;\n  var iterations = 0;\n  while (isStillMoving && iterations < opts.maxIterations) {\n    // Step 2: Assign nodes to the nearest medoid\n    for (var n = 0; n < nodes.length; n++) {\n      node = nodes[n];\n      // Determine which cluster this node belongs to: node id => cluster #\n      assignment[node.id()] = classify(node, medoids, opts.distance, opts.attributes, 'kMedoids');\n    }\n    isStillMoving = false;\n    // Step 3: For each medoid m, and for each node associated with mediod m,\n    // select the node with the lowest configuration cost as new medoid.\n    for (var m = 0; m < medoids.length; m++) {\n      // Get all nodes that belong to this medoid\n      var cluster = buildCluster(m, nodes, assignment);\n      if (cluster.length === 0) {\n        // If cluster is empty, break out early & move to next cluster\n        continue;\n      }\n      minCosts[m] = findCost(medoids[m], cluster, opts.attributes); // original cost\n\n      // Select different medoid if its configuration has the lowest cost\n      for (var _n = 0; _n < cluster.length; _n++) {\n        curCost = findCost(cluster[_n], cluster, opts.attributes);\n        if (curCost < minCosts[m]) {\n          minCosts[m] = curCost;\n          medoids[m] = cluster[_n];\n          isStillMoving = true;\n        }\n      }\n      clusters[m] = cy.collection(cluster);\n    }\n    iterations++;\n  }\n  return clusters;\n};\nvar updateCentroids = function updateCentroids(centroids, nodes, U, weight, opts) {\n  var numerator, denominator;\n  for (var n = 0; n < nodes.length; n++) {\n    for (var c = 0; c < centroids.length; c++) {\n      weight[n][c] = Math.pow(U[n][c], opts.m);\n    }\n  }\n  for (var _c = 0; _c < centroids.length; _c++) {\n    for (var dim = 0; dim < opts.attributes.length; dim++) {\n      numerator = 0;\n      denominator = 0;\n      for (var _n2 = 0; _n2 < nodes.length; _n2++) {\n        numerator += weight[_n2][_c] * opts.attributes[dim](nodes[_n2]);\n        denominator += weight[_n2][_c];\n      }\n      centroids[_c][dim] = numerator / denominator;\n    }\n  }\n};\nvar updateMembership = function updateMembership(U, _U, centroids, nodes, opts) {\n  // Save previous step\n  for (var i = 0; i < U.length; i++) {\n    _U[i] = U[i].slice();\n  }\n  var sum, numerator, denominator;\n  var pow = 2 / (opts.m - 1);\n  for (var c = 0; c < centroids.length; c++) {\n    for (var n = 0; n < nodes.length; n++) {\n      sum = 0;\n      for (var k = 0; k < centroids.length; k++) {\n        // against all other centroids\n        numerator = getDist(opts.distance, nodes[n], centroids[c], opts.attributes, 'cmeans');\n        denominator = getDist(opts.distance, nodes[n], centroids[k], opts.attributes, 'cmeans');\n        sum += Math.pow(numerator / denominator, pow);\n      }\n      U[n][c] = 1 / sum;\n    }\n  }\n};\nvar assign$1 = function assign(nodes, U, opts, cy) {\n  var clusters = new Array(opts.k);\n  for (var c = 0; c < clusters.length; c++) {\n    clusters[c] = [];\n  }\n  var max;\n  var index;\n  for (var n = 0; n < U.length; n++) {\n    // for each node (U is N x C matrix)\n    max = -Infinity;\n    index = -1;\n    // Determine which cluster the node is most likely to belong in\n    for (var _c2 = 0; _c2 < U[0].length; _c2++) {\n      if (U[n][_c2] > max) {\n        max = U[n][_c2];\n        index = _c2;\n      }\n    }\n    clusters[index].push(nodes[n]);\n  }\n\n  // Turn every array into a collection of nodes\n  for (var _c3 = 0; _c3 < clusters.length; _c3++) {\n    clusters[_c3] = cy.collection(clusters[_c3]);\n  }\n  return clusters;\n};\nvar fuzzyCMeans = function fuzzyCMeans(options) {\n  var cy = this.cy();\n  var nodes = this.nodes();\n  var opts = setOptions$2(options);\n\n  // Begin fuzzy c-means algorithm\n  var clusters;\n  var centroids;\n  var U;\n  var _U;\n  var weight;\n\n  // Step 1: Initialize letiables.\n  _U = new Array(nodes.length);\n  for (var i = 0; i < nodes.length; i++) {\n    // N x C matrix\n    _U[i] = new Array(opts.k);\n  }\n  U = new Array(nodes.length);\n  for (var _i3 = 0; _i3 < nodes.length; _i3++) {\n    // N x C matrix\n    U[_i3] = new Array(opts.k);\n  }\n  for (var _i4 = 0; _i4 < nodes.length; _i4++) {\n    var total = 0;\n    for (var j = 0; j < opts.k; j++) {\n      U[_i4][j] = Math.random();\n      total += U[_i4][j];\n    }\n    for (var _j = 0; _j < opts.k; _j++) {\n      U[_i4][_j] = U[_i4][_j] / total;\n    }\n  }\n  centroids = new Array(opts.k);\n  for (var _i5 = 0; _i5 < opts.k; _i5++) {\n    centroids[_i5] = new Array(opts.attributes.length);\n  }\n  weight = new Array(nodes.length);\n  for (var _i6 = 0; _i6 < nodes.length; _i6++) {\n    // N x C matrix\n    weight[_i6] = new Array(opts.k);\n  }\n  // end init FCM\n\n  var isStillMoving = true;\n  var iterations = 0;\n  while (isStillMoving && iterations < opts.maxIterations) {\n    isStillMoving = false;\n\n    // Step 2: Calculate the centroids for each step.\n    updateCentroids(centroids, nodes, U, weight, opts);\n\n    // Step 3: Update the partition matrix U.\n    updateMembership(U, _U, centroids, nodes, opts);\n\n    // Step 4: Check for convergence.\n    if (!haveMatricesConverged(U, _U, opts.sensitivityThreshold)) {\n      isStillMoving = true;\n    }\n    iterations++;\n  }\n\n  // Assign nodes to clusters with highest probability.\n  clusters = assign$1(nodes, U, opts, cy);\n  return {\n    clusters: clusters,\n    degreeOfMembership: U\n  };\n};\nvar kClustering = {\n  kMeans: kMeans,\n  kMedoids: kMedoids,\n  fuzzyCMeans: fuzzyCMeans,\n  fcm: fuzzyCMeans\n};\n\n// Implemented by Zoe Xi @zoexi for GSOC 2016\nvar defaults$a = defaults$g({\n  distance: 'euclidean',\n  // distance metric to compare nodes\n  linkage: 'min',\n  // linkage criterion : how to determine the distance between clusters of nodes\n  mode: 'threshold',\n  // mode:'threshold' => clusters must be threshold distance apart\n  threshold: Infinity,\n  // the distance threshold\n  // mode:'dendrogram' => the nodes are organised as leaves in a tree (siblings are close), merging makes clusters\n  addDendrogram: false,\n  // whether to add the dendrogram to the graph for viz\n  dendrogramDepth: 0,\n  // depth at which dendrogram branches are merged into the returned clusters\n  attributes: [] // array of attr functions\n});\n\nvar linkageAliases = {\n  'single': 'min',\n  'complete': 'max'\n};\nvar setOptions$1 = function setOptions(options) {\n  var opts = defaults$a(options);\n  var preferredAlias = linkageAliases[opts.linkage];\n  if (preferredAlias != null) {\n    opts.linkage = preferredAlias;\n  }\n  return opts;\n};\nvar mergeClosest = function mergeClosest(clusters, index, dists, mins, opts) {\n  // Find two closest clusters from cached mins\n  var minKey = 0;\n  var min = Infinity;\n  var dist;\n  var attrs = opts.attributes;\n  var getDist = function getDist(n1, n2) {\n    return clusteringDistance(opts.distance, attrs.length, function (i) {\n      return attrs[i](n1);\n    }, function (i) {\n      return attrs[i](n2);\n    }, n1, n2);\n  };\n  for (var i = 0; i < clusters.length; i++) {\n    var key = clusters[i].key;\n    var _dist = dists[key][mins[key]];\n    if (_dist < min) {\n      minKey = key;\n      min = _dist;\n    }\n  }\n  if (opts.mode === 'threshold' && min >= opts.threshold || opts.mode === 'dendrogram' && clusters.length === 1) {\n    return false;\n  }\n  var c1 = index[minKey];\n  var c2 = index[mins[minKey]];\n  var merged;\n\n  // Merge two closest clusters\n  if (opts.mode === 'dendrogram') {\n    merged = {\n      left: c1,\n      right: c2,\n      key: c1.key\n    };\n  } else {\n    merged = {\n      value: c1.value.concat(c2.value),\n      key: c1.key\n    };\n  }\n  clusters[c1.index] = merged;\n  clusters.splice(c2.index, 1);\n  index[c1.key] = merged;\n\n  // Update distances with new merged cluster\n  for (var _i = 0; _i < clusters.length; _i++) {\n    var cur = clusters[_i];\n    if (c1.key === cur.key) {\n      dist = Infinity;\n    } else if (opts.linkage === 'min') {\n      dist = dists[c1.key][cur.key];\n      if (dists[c1.key][cur.key] > dists[c2.key][cur.key]) {\n        dist = dists[c2.key][cur.key];\n      }\n    } else if (opts.linkage === 'max') {\n      dist = dists[c1.key][cur.key];\n      if (dists[c1.key][cur.key] < dists[c2.key][cur.key]) {\n        dist = dists[c2.key][cur.key];\n      }\n    } else if (opts.linkage === 'mean') {\n      dist = (dists[c1.key][cur.key] * c1.size + dists[c2.key][cur.key] * c2.size) / (c1.size + c2.size);\n    } else {\n      if (opts.mode === 'dendrogram') dist = getDist(cur.value, c1.value);else dist = getDist(cur.value[0], c1.value[0]);\n    }\n    dists[c1.key][cur.key] = dists[cur.key][c1.key] = dist; // distance matrix is symmetric\n  }\n\n  // Update cached mins\n  for (var _i2 = 0; _i2 < clusters.length; _i2++) {\n    var key1 = clusters[_i2].key;\n    if (mins[key1] === c1.key || mins[key1] === c2.key) {\n      var _min = key1;\n      for (var j = 0; j < clusters.length; j++) {\n        var key2 = clusters[j].key;\n        if (dists[key1][key2] < dists[key1][_min]) {\n          _min = key2;\n        }\n      }\n      mins[key1] = _min;\n    }\n    clusters[_i2].index = _i2;\n  }\n\n  // Clean up meta data used for clustering\n  c1.key = c2.key = c1.index = c2.index = null;\n  return true;\n};\nvar getAllChildren = function getAllChildren(root, arr, cy) {\n  if (!root) return;\n  if (root.value) {\n    arr.push(root.value);\n  } else {\n    if (root.left) getAllChildren(root.left, arr);\n    if (root.right) getAllChildren(root.right, arr);\n  }\n};\nvar buildDendrogram = function buildDendrogram(root, cy) {\n  if (!root) return '';\n  if (root.left && root.right) {\n    var leftStr = buildDendrogram(root.left, cy);\n    var rightStr = buildDendrogram(root.right, cy);\n    var node = cy.add({\n      group: 'nodes',\n      data: {\n        id: leftStr + ',' + rightStr\n      }\n    });\n    cy.add({\n      group: 'edges',\n      data: {\n        source: leftStr,\n        target: node.id()\n      }\n    });\n    cy.add({\n      group: 'edges',\n      data: {\n        source: rightStr,\n        target: node.id()\n      }\n    });\n    return node.id();\n  } else if (root.value) {\n    return root.value.id();\n  }\n};\nvar buildClustersFromTree = function buildClustersFromTree(root, k, cy) {\n  if (!root) return [];\n  var left = [],\n    right = [],\n    leaves = [];\n  if (k === 0) {\n    // don't cut tree, simply return all nodes as 1 single cluster\n    if (root.left) getAllChildren(root.left, left);\n    if (root.right) getAllChildren(root.right, right);\n    leaves = left.concat(right);\n    return [cy.collection(leaves)];\n  } else if (k === 1) {\n    // cut at root\n\n    if (root.value) {\n      // leaf node\n      return [cy.collection(root.value)];\n    } else {\n      if (root.left) getAllChildren(root.left, left);\n      if (root.right) getAllChildren(root.right, right);\n      return [cy.collection(left), cy.collection(right)];\n    }\n  } else {\n    if (root.value) {\n      return [cy.collection(root.value)];\n    } else {\n      if (root.left) left = buildClustersFromTree(root.left, k - 1, cy);\n      if (root.right) right = buildClustersFromTree(root.right, k - 1, cy);\n      return left.concat(right);\n    }\n  }\n};\n\nvar hierarchicalClustering = function hierarchicalClustering(options) {\n  var cy = this.cy();\n  var nodes = this.nodes();\n\n  // Set parameters of algorithm: linkage type, distance metric, etc.\n  var opts = setOptions$1(options);\n  var attrs = opts.attributes;\n  var getDist = function getDist(n1, n2) {\n    return clusteringDistance(opts.distance, attrs.length, function (i) {\n      return attrs[i](n1);\n    }, function (i) {\n      return attrs[i](n2);\n    }, n1, n2);\n  };\n\n  // Begin hierarchical algorithm\n  var clusters = [];\n  var dists = []; // distances between each pair of clusters\n  var mins = []; // closest cluster for each cluster\n  var index = []; // hash of all clusters by key\n\n  // In agglomerative (bottom-up) clustering, each node starts as its own cluster\n  for (var n = 0; n < nodes.length; n++) {\n    var cluster = {\n      value: opts.mode === 'dendrogram' ? nodes[n] : [nodes[n]],\n      key: n,\n      index: n\n    };\n    clusters[n] = cluster;\n    index[n] = cluster;\n    dists[n] = [];\n    mins[n] = 0;\n  }\n\n  // Calculate the distance between each pair of clusters\n  for (var i = 0; i < clusters.length; i++) {\n    for (var j = 0; j <= i; j++) {\n      var dist = void 0;\n      if (opts.mode === 'dendrogram') {\n        // modes store cluster values differently\n        dist = i === j ? Infinity : getDist(clusters[i].value, clusters[j].value);\n      } else {\n        dist = i === j ? Infinity : getDist(clusters[i].value[0], clusters[j].value[0]);\n      }\n      dists[i][j] = dist;\n      dists[j][i] = dist;\n      if (dist < dists[i][mins[i]]) {\n        mins[i] = j; // Cache mins: closest cluster to cluster i is cluster j\n      }\n    }\n  }\n\n  // Find the closest pair of clusters and merge them into a single cluster.\n  // Update distances between new cluster and each of the old clusters, and loop until threshold reached.\n  var merged = mergeClosest(clusters, index, dists, mins, opts);\n  while (merged) {\n    merged = mergeClosest(clusters, index, dists, mins, opts);\n  }\n  var retClusters;\n\n  // Dendrogram mode builds the hierarchy and adds intermediary nodes + edges\n  // in addition to returning the clusters.\n  if (opts.mode === 'dendrogram') {\n    retClusters = buildClustersFromTree(clusters[0], opts.dendrogramDepth, cy);\n    if (opts.addDendrogram) buildDendrogram(clusters[0], cy);\n  } else {\n    // Regular mode simply returns the clusters\n\n    retClusters = new Array(clusters.length);\n    clusters.forEach(function (cluster, i) {\n      // Clean up meta data used for clustering\n      cluster.key = cluster.index = null;\n      retClusters[i] = cy.collection(cluster.value);\n    });\n  }\n  return retClusters;\n};\nvar hierarchicalClustering$1 = {\n  hierarchicalClustering: hierarchicalClustering,\n  hca: hierarchicalClustering\n};\n\n// Implemented by Zoe Xi @zoexi for GSOC 2016\nvar defaults$9 = defaults$g({\n  distance: 'euclidean',\n  // distance metric to compare attributes between two nodes\n  preference: 'median',\n  // suitability of a data point to serve as an exemplar\n  damping: 0.8,\n  // damping factor between [0.5, 1)\n  maxIterations: 1000,\n  // max number of iterations to run\n  minIterations: 100,\n  // min number of iterations to run in order for clustering to stop\n  attributes: [// functions to quantify the similarity between any two points\n    // e.g. node => node.data('weight')\n  ]\n});\nvar setOptions = function setOptions(options) {\n  var dmp = options.damping;\n  var pref = options.preference;\n  if (!(0.5 <= dmp && dmp < 1)) {\n    error(\"Damping must range on [0.5, 1).  Got: \".concat(dmp));\n  }\n  var validPrefs = ['median', 'mean', 'min', 'max'];\n  if (!(validPrefs.some(function (v) {\n    return v === pref;\n  }) || number$1(pref))) {\n    error(\"Preference must be one of [\".concat(validPrefs.map(function (p) {\n      return \"'\".concat(p, \"'\");\n    }).join(', '), \"] or a number.  Got: \").concat(pref));\n  }\n  return defaults$9(options);\n};\n\nvar getSimilarity = function getSimilarity(type, n1, n2, attributes) {\n  var attr = function attr(n, i) {\n    return attributes[i](n);\n  };\n\n  // nb negative because similarity should have an inverse relationship to distance\n  return -clusteringDistance(type, attributes.length, function (i) {\n    return attr(n1, i);\n  }, function (i) {\n    return attr(n2, i);\n  }, n1, n2);\n};\nvar getPreference = function getPreference(S, preference) {\n  // larger preference = greater # of clusters\n  var p = null;\n  if (preference === 'median') {\n    p = median(S);\n  } else if (preference === 'mean') {\n    p = mean(S);\n  } else if (preference === 'min') {\n    p = min(S);\n  } else if (preference === 'max') {\n    p = max(S);\n  } else {\n    // Custom preference number, as set by user\n    p = preference;\n  }\n  return p;\n};\nvar findExemplars = function findExemplars(n, R, A) {\n  var indices = [];\n  for (var i = 0; i < n; i++) {\n    if (R[i * n + i] + A[i * n + i] > 0) {\n      indices.push(i);\n    }\n  }\n  return indices;\n};\nvar assignClusters = function assignClusters(n, S, exemplars) {\n  var clusters = [];\n  for (var i = 0; i < n; i++) {\n    var index = -1;\n    var max = -Infinity;\n    for (var ei = 0; ei < exemplars.length; ei++) {\n      var e = exemplars[ei];\n      if (S[i * n + e] > max) {\n        index = e;\n        max = S[i * n + e];\n      }\n    }\n    if (index > 0) {\n      clusters.push(index);\n    }\n  }\n  for (var _ei = 0; _ei < exemplars.length; _ei++) {\n    clusters[exemplars[_ei]] = exemplars[_ei];\n  }\n  return clusters;\n};\nvar assign = function assign(n, S, exemplars) {\n  var clusters = assignClusters(n, S, exemplars);\n  for (var ei = 0; ei < exemplars.length; ei++) {\n    var ii = [];\n    for (var c = 0; c < clusters.length; c++) {\n      if (clusters[c] === exemplars[ei]) {\n        ii.push(c);\n      }\n    }\n    var maxI = -1;\n    var maxSum = -Infinity;\n    for (var i = 0; i < ii.length; i++) {\n      var sum = 0;\n      for (var j = 0; j < ii.length; j++) {\n        sum += S[ii[j] * n + ii[i]];\n      }\n      if (sum > maxSum) {\n        maxI = i;\n        maxSum = sum;\n      }\n    }\n    exemplars[ei] = ii[maxI];\n  }\n  clusters = assignClusters(n, S, exemplars);\n  return clusters;\n};\nvar affinityPropagation = function affinityPropagation(options) {\n  var cy = this.cy();\n  var nodes = this.nodes();\n  var opts = setOptions(options);\n\n  // Map each node to its position in node array\n  var id2position = {};\n  for (var i = 0; i < nodes.length; i++) {\n    id2position[nodes[i].id()] = i;\n  }\n\n  // Begin affinity propagation algorithm\n\n  var n; // number of data points\n  var n2; // size of matrices\n  var S; // similarity matrix (1D array)\n  var p; // preference/suitability of a data point to serve as an exemplar\n  var R; // responsibility matrix (1D array)\n  var A; // availability matrix (1D array)\n\n  n = nodes.length;\n  n2 = n * n;\n\n  // Initialize and build S similarity matrix\n  S = new Array(n2);\n  for (var _i = 0; _i < n2; _i++) {\n    S[_i] = -Infinity; // for cases where two data points shouldn't be linked together\n  }\n\n  for (var _i2 = 0; _i2 < n; _i2++) {\n    for (var j = 0; j < n; j++) {\n      if (_i2 !== j) {\n        S[_i2 * n + j] = getSimilarity(opts.distance, nodes[_i2], nodes[j], opts.attributes);\n      }\n    }\n  }\n\n  // Place preferences on the diagonal of S\n  p = getPreference(S, opts.preference);\n  for (var _i3 = 0; _i3 < n; _i3++) {\n    S[_i3 * n + _i3] = p;\n  }\n\n  // Initialize R responsibility matrix\n  R = new Array(n2);\n  for (var _i4 = 0; _i4 < n2; _i4++) {\n    R[_i4] = 0.0;\n  }\n\n  // Initialize A availability matrix\n  A = new Array(n2);\n  for (var _i5 = 0; _i5 < n2; _i5++) {\n    A[_i5] = 0.0;\n  }\n  var old = new Array(n);\n  var Rp = new Array(n);\n  var se = new Array(n);\n  for (var _i6 = 0; _i6 < n; _i6++) {\n    old[_i6] = 0.0;\n    Rp[_i6] = 0.0;\n    se[_i6] = 0;\n  }\n  var e = new Array(n * opts.minIterations);\n  for (var _i7 = 0; _i7 < e.length; _i7++) {\n    e[_i7] = 0;\n  }\n  var iter;\n  for (iter = 0; iter < opts.maxIterations; iter++) {\n    // main algorithmic loop\n\n    // Update R responsibility matrix\n    for (var _i8 = 0; _i8 < n; _i8++) {\n      var max = -Infinity,\n        max2 = -Infinity,\n        maxI = -1,\n        AS = 0.0;\n      for (var _j = 0; _j < n; _j++) {\n        old[_j] = R[_i8 * n + _j];\n        AS = A[_i8 * n + _j] + S[_i8 * n + _j];\n        if (AS >= max) {\n          max2 = max;\n          max = AS;\n          maxI = _j;\n        } else if (AS > max2) {\n          max2 = AS;\n        }\n      }\n      for (var _j2 = 0; _j2 < n; _j2++) {\n        R[_i8 * n + _j2] = (1 - opts.damping) * (S[_i8 * n + _j2] - max) + opts.damping * old[_j2];\n      }\n      R[_i8 * n + maxI] = (1 - opts.damping) * (S[_i8 * n + maxI] - max2) + opts.damping * old[maxI];\n    }\n\n    // Update A availability matrix\n    for (var _i9 = 0; _i9 < n; _i9++) {\n      var sum = 0;\n      for (var _j3 = 0; _j3 < n; _j3++) {\n        old[_j3] = A[_j3 * n + _i9];\n        Rp[_j3] = Math.max(0, R[_j3 * n + _i9]);\n        sum += Rp[_j3];\n      }\n      sum -= Rp[_i9];\n      Rp[_i9] = R[_i9 * n + _i9];\n      sum += Rp[_i9];\n      for (var _j4 = 0; _j4 < n; _j4++) {\n        A[_j4 * n + _i9] = (1 - opts.damping) * Math.min(0, sum - Rp[_j4]) + opts.damping * old[_j4];\n      }\n      A[_i9 * n + _i9] = (1 - opts.damping) * (sum - Rp[_i9]) + opts.damping * old[_i9];\n    }\n\n    // Check for convergence\n    var K = 0;\n    for (var _i10 = 0; _i10 < n; _i10++) {\n      var E = A[_i10 * n + _i10] + R[_i10 * n + _i10] > 0 ? 1 : 0;\n      e[iter % opts.minIterations * n + _i10] = E;\n      K += E;\n    }\n    if (K > 0 && (iter >= opts.minIterations - 1 || iter == opts.maxIterations - 1)) {\n      var _sum = 0;\n      for (var _i11 = 0; _i11 < n; _i11++) {\n        se[_i11] = 0;\n        for (var _j5 = 0; _j5 < opts.minIterations; _j5++) {\n          se[_i11] += e[_j5 * n + _i11];\n        }\n        if (se[_i11] === 0 || se[_i11] === opts.minIterations) {\n          _sum++;\n        }\n      }\n      if (_sum === n) {\n        // then we have convergence\n        break;\n      }\n    }\n  }\n\n  // Identify exemplars (cluster centers)\n  var exemplarsIndices = findExemplars(n, R, A);\n\n  // Assign nodes to clusters\n  var clusterIndices = assign(n, S, exemplarsIndices);\n  var clusters = {};\n  for (var c = 0; c < exemplarsIndices.length; c++) {\n    clusters[exemplarsIndices[c]] = [];\n  }\n  for (var _i12 = 0; _i12 < nodes.length; _i12++) {\n    var pos = id2position[nodes[_i12].id()];\n    var clusterIndex = clusterIndices[pos];\n    if (clusterIndex != null) {\n      // the node may have not been assigned a cluster if no valid attributes were specified\n      clusters[clusterIndex].push(nodes[_i12]);\n    }\n  }\n  var retClusters = new Array(exemplarsIndices.length);\n  for (var _c = 0; _c < exemplarsIndices.length; _c++) {\n    retClusters[_c] = cy.collection(clusters[exemplarsIndices[_c]]);\n  }\n  return retClusters;\n};\nvar affinityPropagation$1 = {\n  affinityPropagation: affinityPropagation,\n  ap: affinityPropagation\n};\n\nvar hierholzerDefaults = defaults$g({\n  root: undefined,\n  directed: false\n});\nvar elesfn$k = {\n  hierholzer: function hierholzer(options) {\n    if (!plainObject(options)) {\n      var args = arguments;\n      options = {\n        root: args[0],\n        directed: args[1]\n      };\n    }\n    var _hierholzerDefaults = hierholzerDefaults(options),\n      root = _hierholzerDefaults.root,\n      directed = _hierholzerDefaults.directed;\n    var eles = this;\n    var dflag = false;\n    var oddIn;\n    var oddOut;\n    var startVertex;\n    if (root) startVertex = string(root) ? this.filter(root)[0].id() : root[0].id();\n    var nodes = {};\n    var edges = {};\n    if (directed) {\n      eles.forEach(function (ele) {\n        var id = ele.id();\n        if (ele.isNode()) {\n          var ind = ele.indegree(true);\n          var outd = ele.outdegree(true);\n          var d1 = ind - outd;\n          var d2 = outd - ind;\n          if (d1 == 1) {\n            if (oddIn) dflag = true;else oddIn = id;\n          } else if (d2 == 1) {\n            if (oddOut) dflag = true;else oddOut = id;\n          } else if (d2 > 1 || d1 > 1) {\n            dflag = true;\n          }\n          nodes[id] = [];\n          ele.outgoers().forEach(function (e) {\n            if (e.isEdge()) nodes[id].push(e.id());\n          });\n        } else {\n          edges[id] = [undefined, ele.target().id()];\n        }\n      });\n    } else {\n      eles.forEach(function (ele) {\n        var id = ele.id();\n        if (ele.isNode()) {\n          var d = ele.degree(true);\n          if (d % 2) {\n            if (!oddIn) oddIn = id;else if (!oddOut) oddOut = id;else dflag = true;\n          }\n          nodes[id] = [];\n          ele.connectedEdges().forEach(function (e) {\n            return nodes[id].push(e.id());\n          });\n        } else {\n          edges[id] = [ele.source().id(), ele.target().id()];\n        }\n      });\n    }\n    var result = {\n      found: false,\n      trail: undefined\n    };\n    if (dflag) return result;else if (oddOut && oddIn) {\n      if (directed) {\n        if (startVertex && oddOut != startVertex) {\n          return result;\n        }\n        startVertex = oddOut;\n      } else {\n        if (startVertex && oddOut != startVertex && oddIn != startVertex) {\n          return result;\n        } else if (!startVertex) {\n          startVertex = oddOut;\n        }\n      }\n    } else {\n      if (!startVertex) startVertex = eles[0].id();\n    }\n    var walk = function walk(v) {\n      var currentNode = v;\n      var subtour = [v];\n      var adj, adjTail, adjHead;\n      while (nodes[currentNode].length) {\n        adj = nodes[currentNode].shift();\n        adjTail = edges[adj][0];\n        adjHead = edges[adj][1];\n        if (currentNode != adjHead) {\n          nodes[adjHead] = nodes[adjHead].filter(function (e) {\n            return e != adj;\n          });\n          currentNode = adjHead;\n        } else if (!directed && currentNode != adjTail) {\n          nodes[adjTail] = nodes[adjTail].filter(function (e) {\n            return e != adj;\n          });\n          currentNode = adjTail;\n        }\n        subtour.unshift(adj);\n        subtour.unshift(currentNode);\n      }\n      return subtour;\n    };\n    var trail = [];\n    var subtour = [];\n    subtour = walk(startVertex);\n    while (subtour.length != 1) {\n      if (nodes[subtour[0]].length == 0) {\n        trail.unshift(eles.getElementById(subtour.shift()));\n        trail.unshift(eles.getElementById(subtour.shift()));\n      } else {\n        subtour = walk(subtour.shift()).concat(subtour);\n      }\n    }\n    trail.unshift(eles.getElementById(subtour.shift())); // final node\n\n    for (var d in nodes) {\n      if (nodes[d].length) {\n        return result;\n      }\n    }\n    result.found = true;\n    result.trail = this.spawn(trail, true);\n    return result;\n  }\n};\n\nvar hopcroftTarjanBiconnected = function hopcroftTarjanBiconnected() {\n  var eles = this;\n  var nodes = {};\n  var id = 0;\n  var edgeCount = 0;\n  var components = [];\n  var stack = [];\n  var visitedEdges = {};\n  var buildComponent = function buildComponent(x, y) {\n    var i = stack.length - 1;\n    var cutset = [];\n    var component = eles.spawn();\n    while (stack[i].x != x || stack[i].y != y) {\n      cutset.push(stack.pop().edge);\n      i--;\n    }\n    cutset.push(stack.pop().edge);\n    cutset.forEach(function (edge) {\n      var connectedNodes = edge.connectedNodes().intersection(eles);\n      component.merge(edge);\n      connectedNodes.forEach(function (node) {\n        var nodeId = node.id();\n        var connectedEdges = node.connectedEdges().intersection(eles);\n        component.merge(node);\n        if (!nodes[nodeId].cutVertex) {\n          component.merge(connectedEdges);\n        } else {\n          component.merge(connectedEdges.filter(function (edge) {\n            return edge.isLoop();\n          }));\n        }\n      });\n    });\n    components.push(component);\n  };\n  var biconnectedSearch = function biconnectedSearch(root, currentNode, parent) {\n    if (root === parent) edgeCount += 1;\n    nodes[currentNode] = {\n      id: id,\n      low: id++,\n      cutVertex: false\n    };\n    var edges = eles.getElementById(currentNode).connectedEdges().intersection(eles);\n    if (edges.size() === 0) {\n      components.push(eles.spawn(eles.getElementById(currentNode)));\n    } else {\n      var sourceId, targetId, otherNodeId, edgeId;\n      edges.forEach(function (edge) {\n        sourceId = edge.source().id();\n        targetId = edge.target().id();\n        otherNodeId = sourceId === currentNode ? targetId : sourceId;\n        if (otherNodeId !== parent) {\n          edgeId = edge.id();\n          if (!visitedEdges[edgeId]) {\n            visitedEdges[edgeId] = true;\n            stack.push({\n              x: currentNode,\n              y: otherNodeId,\n              edge: edge\n            });\n          }\n          if (!(otherNodeId in nodes)) {\n            biconnectedSearch(root, otherNodeId, currentNode);\n            nodes[currentNode].low = Math.min(nodes[currentNode].low, nodes[otherNodeId].low);\n            if (nodes[currentNode].id <= nodes[otherNodeId].low) {\n              nodes[currentNode].cutVertex = true;\n              buildComponent(currentNode, otherNodeId);\n            }\n          } else {\n            nodes[currentNode].low = Math.min(nodes[currentNode].low, nodes[otherNodeId].id);\n          }\n        }\n      });\n    }\n  };\n  eles.forEach(function (ele) {\n    if (ele.isNode()) {\n      var nodeId = ele.id();\n      if (!(nodeId in nodes)) {\n        edgeCount = 0;\n        biconnectedSearch(nodeId, nodeId);\n        nodes[nodeId].cutVertex = edgeCount > 1;\n      }\n    }\n  });\n  var cutVertices = Object.keys(nodes).filter(function (id) {\n    return nodes[id].cutVertex;\n  }).map(function (id) {\n    return eles.getElementById(id);\n  });\n  return {\n    cut: eles.spawn(cutVertices),\n    components: components\n  };\n};\nvar hopcroftTarjanBiconnected$1 = {\n  hopcroftTarjanBiconnected: hopcroftTarjanBiconnected,\n  htbc: hopcroftTarjanBiconnected,\n  htb: hopcroftTarjanBiconnected,\n  hopcroftTarjanBiconnectedComponents: hopcroftTarjanBiconnected\n};\n\nvar tarjanStronglyConnected = function tarjanStronglyConnected() {\n  var eles = this;\n  var nodes = {};\n  var index = 0;\n  var components = [];\n  var stack = [];\n  var cut = eles.spawn(eles);\n  var stronglyConnectedSearch = function stronglyConnectedSearch(sourceNodeId) {\n    stack.push(sourceNodeId);\n    nodes[sourceNodeId] = {\n      index: index,\n      low: index++,\n      explored: false\n    };\n    var connectedEdges = eles.getElementById(sourceNodeId).connectedEdges().intersection(eles);\n    connectedEdges.forEach(function (edge) {\n      var targetNodeId = edge.target().id();\n      if (targetNodeId !== sourceNodeId) {\n        if (!(targetNodeId in nodes)) {\n          stronglyConnectedSearch(targetNodeId);\n        }\n        if (!nodes[targetNodeId].explored) {\n          nodes[sourceNodeId].low = Math.min(nodes[sourceNodeId].low, nodes[targetNodeId].low);\n        }\n      }\n    });\n    if (nodes[sourceNodeId].index === nodes[sourceNodeId].low) {\n      var componentNodes = eles.spawn();\n      for (;;) {\n        var nodeId = stack.pop();\n        componentNodes.merge(eles.getElementById(nodeId));\n        nodes[nodeId].low = nodes[sourceNodeId].index;\n        nodes[nodeId].explored = true;\n        if (nodeId === sourceNodeId) {\n          break;\n        }\n      }\n      var componentEdges = componentNodes.edgesWith(componentNodes);\n      var component = componentNodes.merge(componentEdges);\n      components.push(component);\n      cut = cut.difference(component);\n    }\n  };\n  eles.forEach(function (ele) {\n    if (ele.isNode()) {\n      var nodeId = ele.id();\n      if (!(nodeId in nodes)) {\n        stronglyConnectedSearch(nodeId);\n      }\n    }\n  });\n  return {\n    cut: cut,\n    components: components\n  };\n};\nvar tarjanStronglyConnected$1 = {\n  tarjanStronglyConnected: tarjanStronglyConnected,\n  tsc: tarjanStronglyConnected,\n  tscc: tarjanStronglyConnected,\n  tarjanStronglyConnectedComponents: tarjanStronglyConnected\n};\n\nvar elesfn$j = {};\n[elesfn$v, elesfn$u, elesfn$t, elesfn$s, elesfn$r, elesfn$q, elesfn$p, elesfn$o, elesfn$n, elesfn$m, elesfn$l, markovClustering$1, kClustering, hierarchicalClustering$1, affinityPropagation$1, elesfn$k, hopcroftTarjanBiconnected$1, tarjanStronglyConnected$1].forEach(function (props) {\n  extend(elesfn$j, props);\n});\n\n/*!\nEmbeddable Minimum Strictly-Compliant Promises/A+ 1.1.1 Thenable\nCopyright (c) 2013-2014 Ralf S. Engelschall (http://engelschall.com)\nLicensed under The MIT License (http://opensource.org/licenses/MIT)\n*/\n\n/*  promise states [Promises/A+ 2.1]  */\nvar STATE_PENDING = 0; /*  [Promises/A+ 2.1.1]  */\nvar STATE_FULFILLED = 1; /*  [Promises/A+ 2.1.2]  */\nvar STATE_REJECTED = 2; /*  [Promises/A+ 2.1.3]  */\n\n/*  promise object constructor  */\nvar api = function api(executor) {\n  /*  optionally support non-constructor/plain-function call  */\n  if (!(this instanceof api)) return new api(executor);\n\n  /*  initialize object  */\n  this.id = 'Thenable/1.0.7';\n  this.state = STATE_PENDING; /*  initial state  */\n  this.fulfillValue = undefined; /*  initial value  */ /*  [Promises/A+ 1.3, 2.1.2.2]  */\n  this.rejectReason = undefined; /*  initial reason */ /*  [Promises/A+ 1.5, 2.1.3.2]  */\n  this.onFulfilled = []; /*  initial handlers  */\n  this.onRejected = []; /*  initial handlers  */\n\n  /*  provide optional information-hiding proxy  */\n  this.proxy = {\n    then: this.then.bind(this)\n  };\n\n  /*  support optional executor function  */\n  if (typeof executor === 'function') executor.call(this, this.fulfill.bind(this), this.reject.bind(this));\n};\n\n/*  promise API methods  */\napi.prototype = {\n  /*  promise resolving methods  */\n  fulfill: function fulfill(value) {\n    return deliver(this, STATE_FULFILLED, 'fulfillValue', value);\n  },\n  reject: function reject(value) {\n    return deliver(this, STATE_REJECTED, 'rejectReason', value);\n  },\n  /*  \"The then Method\" [Promises/A+ 1.1, 1.2, 2.2]  */\n  then: function then(onFulfilled, onRejected) {\n    var curr = this;\n    var next = new api(); /*  [Promises/A+ 2.2.7]  */\n    curr.onFulfilled.push(resolver(onFulfilled, next, 'fulfill')); /*  [Promises/A+ 2.2.2/2.2.6]  */\n    curr.onRejected.push(resolver(onRejected, next, 'reject')); /*  [Promises/A+ 2.2.3/2.2.6]  */\n    execute(curr);\n    return next.proxy; /*  [Promises/A+ 2.2.7, 3.3]  */\n  }\n};\n\n/*  deliver an action  */\nvar deliver = function deliver(curr, state, name, value) {\n  if (curr.state === STATE_PENDING) {\n    curr.state = state; /*  [Promises/A+ 2.1.2.1, 2.1.3.1]  */\n    curr[name] = value; /*  [Promises/A+ 2.1.2.2, 2.1.3.2]  */\n    execute(curr);\n  }\n  return curr;\n};\n\n/*  execute all handlers  */\nvar execute = function execute(curr) {\n  if (curr.state === STATE_FULFILLED) execute_handlers(curr, 'onFulfilled', curr.fulfillValue);else if (curr.state === STATE_REJECTED) execute_handlers(curr, 'onRejected', curr.rejectReason);\n};\n\n/*  execute particular set of handlers  */\nvar execute_handlers = function execute_handlers(curr, name, value) {\n  /* global setImmediate: true */\n  /* global setTimeout: true */\n\n  /*  short-circuit processing  */\n  if (curr[name].length === 0) return;\n\n  /*  iterate over all handlers, exactly once  */\n  var handlers = curr[name];\n  curr[name] = []; /*  [Promises/A+ 2.2.2.3, 2.2.3.3]  */\n  var func = function func() {\n    for (var i = 0; i < handlers.length; i++) {\n      handlers[i](value);\n    } /*  [Promises/A+ 2.2.5]  */\n  };\n\n  /*  execute procedure asynchronously  */ /*  [Promises/A+ 2.2.4, 3.1]  */\n  if (typeof setImmediate === 'function') setImmediate(func);else setTimeout(func, 0);\n};\n\n/*  generate a resolver function  */\nvar resolver = function resolver(cb, next, method) {\n  return function (value) {\n    if (typeof cb !== 'function') /*  [Promises/A+ 2.2.1, 2.2.7.3, 2.2.7.4]  */\n      next[method].call(next, value); /*  [Promises/A+ 2.2.7.3, 2.2.7.4]  */else {\n      var result;\n      try {\n        result = cb(value);\n      } /*  [Promises/A+ 2.2.2.1, 2.2.3.1, 2.2.5, 3.2]  */ catch (e) {\n        next.reject(e); /*  [Promises/A+ 2.2.7.2]  */\n        return;\n      }\n      resolve(next, result); /*  [Promises/A+ 2.2.7.1]  */\n    }\n  };\n};\n\n/*  \"Promise Resolution Procedure\"  */ /*  [Promises/A+ 2.3]  */\nvar resolve = function resolve(promise, x) {\n  /*  sanity check arguments  */ /*  [Promises/A+ 2.3.1]  */\n  if (promise === x || promise.proxy === x) {\n    promise.reject(new TypeError('cannot resolve promise with itself'));\n    return;\n  }\n\n  /*  surgically check for a \"then\" method\n    (mainly to just call the \"getter\" of \"then\" only once)  */\n  var then;\n  if (_typeof(x) === 'object' && x !== null || typeof x === 'function') {\n    try {\n      then = x.then;\n    } /*  [Promises/A+ 2.3.3.1, 3.5]  */ catch (e) {\n      promise.reject(e); /*  [Promises/A+ 2.3.3.2]  */\n      return;\n    }\n  }\n\n  /*  handle own Thenables    [Promises/A+ 2.3.2]\n    and similar \"thenables\" [Promises/A+ 2.3.3]  */\n  if (typeof then === 'function') {\n    var resolved = false;\n    try {\n      /*  call retrieved \"then\" method */ /*  [Promises/A+ 2.3.3.3]  */\n      then.call(x, /*  resolvePromise  */ /*  [Promises/A+ 2.3.3.3.1]  */\n      function (y) {\n        if (resolved) return;\n        resolved = true; /*  [Promises/A+ 2.3.3.3.3]  */\n        if (y === x) /*  [Promises/A+ 3.6]  */\n          promise.reject(new TypeError('circular thenable chain'));else resolve(promise, y);\n      }, /*  rejectPromise  */ /*  [Promises/A+ 2.3.3.3.2]  */\n      function (r) {\n        if (resolved) return;\n        resolved = true; /*  [Promises/A+ 2.3.3.3.3]  */\n        promise.reject(r);\n      });\n    } catch (e) {\n      if (!resolved) /*  [Promises/A+ 2.3.3.3.3]  */\n        promise.reject(e); /*  [Promises/A+ 2.3.3.3.4]  */\n    }\n\n    return;\n  }\n\n  /*  handle other values  */\n  promise.fulfill(x); /*  [Promises/A+ 2.3.4, 2.3.3.4]  */\n};\n\n// so we always have Promise.all()\napi.all = function (ps) {\n  return new api(function (resolveAll, rejectAll) {\n    var vals = new Array(ps.length);\n    var doneCount = 0;\n    var fulfill = function fulfill(i, val) {\n      vals[i] = val;\n      doneCount++;\n      if (doneCount === ps.length) {\n        resolveAll(vals);\n      }\n    };\n    for (var i = 0; i < ps.length; i++) {\n      (function (i) {\n        var p = ps[i];\n        var isPromise = p != null && p.then != null;\n        if (isPromise) {\n          p.then(function (val) {\n            fulfill(i, val);\n          }, function (err) {\n            rejectAll(err);\n          });\n        } else {\n          var val = p;\n          fulfill(i, val);\n        }\n      })(i);\n    }\n  });\n};\napi.resolve = function (val) {\n  return new api(function (resolve, reject) {\n    resolve(val);\n  });\n};\napi.reject = function (val) {\n  return new api(function (resolve, reject) {\n    reject(val);\n  });\n};\nvar Promise$1 = typeof Promise !== 'undefined' ? Promise : api; // eslint-disable-line no-undef\n\nvar Animation = function Animation(target, opts, opts2) {\n  var isCore = core(target);\n  var isEle = !isCore;\n  var _p = this._private = extend({\n    duration: 1000\n  }, opts, opts2);\n  _p.target = target;\n  _p.style = _p.style || _p.css;\n  _p.started = false;\n  _p.playing = false;\n  _p.hooked = false;\n  _p.applying = false;\n  _p.progress = 0;\n  _p.completes = [];\n  _p.frames = [];\n  if (_p.complete && fn$6(_p.complete)) {\n    _p.completes.push(_p.complete);\n  }\n  if (isEle) {\n    var pos = target.position();\n    _p.startPosition = _p.startPosition || {\n      x: pos.x,\n      y: pos.y\n    };\n    _p.startStyle = _p.startStyle || target.cy().style().getAnimationStartStyle(target, _p.style);\n  }\n  if (isCore) {\n    var pan = target.pan();\n    _p.startPan = {\n      x: pan.x,\n      y: pan.y\n    };\n    _p.startZoom = target.zoom();\n  }\n\n  // for future timeline/animations impl\n  this.length = 1;\n  this[0] = this;\n};\nvar anifn = Animation.prototype;\nextend(anifn, {\n  instanceString: function instanceString() {\n    return 'animation';\n  },\n  hook: function hook() {\n    var _p = this._private;\n    if (!_p.hooked) {\n      // add to target's animation queue\n      var q;\n      var tAni = _p.target._private.animation;\n      if (_p.queue) {\n        q = tAni.queue;\n      } else {\n        q = tAni.current;\n      }\n      q.push(this);\n\n      // add to the animation loop pool\n      if (elementOrCollection(_p.target)) {\n        _p.target.cy().addToAnimationPool(_p.target);\n      }\n      _p.hooked = true;\n    }\n    return this;\n  },\n  play: function play() {\n    var _p = this._private;\n\n    // autorewind\n    if (_p.progress === 1) {\n      _p.progress = 0;\n    }\n    _p.playing = true;\n    _p.started = false; // needs to be started by animation loop\n    _p.stopped = false;\n    this.hook();\n\n    // the animation loop will start the animation...\n\n    return this;\n  },\n  playing: function playing() {\n    return this._private.playing;\n  },\n  apply: function apply() {\n    var _p = this._private;\n    _p.applying = true;\n    _p.started = false; // needs to be started by animation loop\n    _p.stopped = false;\n    this.hook();\n\n    // the animation loop will apply the animation at this progress\n\n    return this;\n  },\n  applying: function applying() {\n    return this._private.applying;\n  },\n  pause: function pause() {\n    var _p = this._private;\n    _p.playing = false;\n    _p.started = false;\n    return this;\n  },\n  stop: function stop() {\n    var _p = this._private;\n    _p.playing = false;\n    _p.started = false;\n    _p.stopped = true; // to be removed from animation queues\n\n    return this;\n  },\n  rewind: function rewind() {\n    return this.progress(0);\n  },\n  fastforward: function fastforward() {\n    return this.progress(1);\n  },\n  time: function time(t) {\n    var _p = this._private;\n    if (t === undefined) {\n      return _p.progress * _p.duration;\n    } else {\n      return this.progress(t / _p.duration);\n    }\n  },\n  progress: function progress(p) {\n    var _p = this._private;\n    var wasPlaying = _p.playing;\n    if (p === undefined) {\n      return _p.progress;\n    } else {\n      if (wasPlaying) {\n        this.pause();\n      }\n      _p.progress = p;\n      _p.started = false;\n      if (wasPlaying) {\n        this.play();\n      }\n    }\n    return this;\n  },\n  completed: function completed() {\n    return this._private.progress === 1;\n  },\n  reverse: function reverse() {\n    var _p = this._private;\n    var wasPlaying = _p.playing;\n    if (wasPlaying) {\n      this.pause();\n    }\n    _p.progress = 1 - _p.progress;\n    _p.started = false;\n    var swap = function swap(a, b) {\n      var _pa = _p[a];\n      if (_pa == null) {\n        return;\n      }\n      _p[a] = _p[b];\n      _p[b] = _pa;\n    };\n    swap('zoom', 'startZoom');\n    swap('pan', 'startPan');\n    swap('position', 'startPosition');\n\n    // swap styles\n    if (_p.style) {\n      for (var i = 0; i < _p.style.length; i++) {\n        var prop = _p.style[i];\n        var name = prop.name;\n        var startStyleProp = _p.startStyle[name];\n        _p.startStyle[name] = prop;\n        _p.style[i] = startStyleProp;\n      }\n    }\n    if (wasPlaying) {\n      this.play();\n    }\n    return this;\n  },\n  promise: function promise(type) {\n    var _p = this._private;\n    var arr;\n    switch (type) {\n      case 'frame':\n        arr = _p.frames;\n        break;\n      default:\n      case 'complete':\n      case 'completed':\n        arr = _p.completes;\n    }\n    return new Promise$1(function (resolve, reject) {\n      arr.push(function () {\n        resolve();\n      });\n    });\n  }\n});\nanifn.complete = anifn.completed;\nanifn.run = anifn.play;\nanifn.running = anifn.playing;\n\nvar define$3 = {\n  animated: function animated() {\n    return function animatedImpl() {\n      var self = this;\n      var selfIsArrayLike = self.length !== undefined;\n      var all = selfIsArrayLike ? self : [self]; // put in array if not array-like\n      var cy = this._private.cy || this;\n      if (!cy.styleEnabled()) {\n        return false;\n      }\n      var ele = all[0];\n      if (ele) {\n        return ele._private.animation.current.length > 0;\n      }\n    };\n  },\n  // animated\n\n  clearQueue: function clearQueue() {\n    return function clearQueueImpl() {\n      var self = this;\n      var selfIsArrayLike = self.length !== undefined;\n      var all = selfIsArrayLike ? self : [self]; // put in array if not array-like\n      var cy = this._private.cy || this;\n      if (!cy.styleEnabled()) {\n        return this;\n      }\n      for (var i = 0; i < all.length; i++) {\n        var ele = all[i];\n        ele._private.animation.queue = [];\n      }\n      return this;\n    };\n  },\n  // clearQueue\n\n  delay: function delay() {\n    return function delayImpl(time, complete) {\n      var cy = this._private.cy || this;\n      if (!cy.styleEnabled()) {\n        return this;\n      }\n      return this.animate({\n        delay: time,\n        duration: time,\n        complete: complete\n      });\n    };\n  },\n  // delay\n\n  delayAnimation: function delayAnimation() {\n    return function delayAnimationImpl(time, complete) {\n      var cy = this._private.cy || this;\n      if (!cy.styleEnabled()) {\n        return this;\n      }\n      return this.animation({\n        delay: time,\n        duration: time,\n        complete: complete\n      });\n    };\n  },\n  // delay\n\n  animation: function animation() {\n    return function animationImpl(properties, params) {\n      var self = this;\n      var selfIsArrayLike = self.length !== undefined;\n      var all = selfIsArrayLike ? self : [self]; // put in array if not array-like\n      var cy = this._private.cy || this;\n      var isCore = !selfIsArrayLike;\n      var isEles = !isCore;\n      if (!cy.styleEnabled()) {\n        return this;\n      }\n      var style = cy.style();\n      properties = extend({}, properties, params);\n      var propertiesEmpty = Object.keys(properties).length === 0;\n      if (propertiesEmpty) {\n        return new Animation(all[0], properties); // nothing to animate\n      }\n\n      if (properties.duration === undefined) {\n        properties.duration = 400;\n      }\n      switch (properties.duration) {\n        case 'slow':\n          properties.duration = 600;\n          break;\n        case 'fast':\n          properties.duration = 200;\n          break;\n      }\n      if (isEles) {\n        properties.style = style.getPropsList(properties.style || properties.css);\n        properties.css = undefined;\n      }\n      if (isEles && properties.renderedPosition != null) {\n        var rpos = properties.renderedPosition;\n        var pan = cy.pan();\n        var zoom = cy.zoom();\n        properties.position = renderedToModelPosition(rpos, zoom, pan);\n      }\n\n      // override pan w/ panBy if set\n      if (isCore && properties.panBy != null) {\n        var panBy = properties.panBy;\n        var cyPan = cy.pan();\n        properties.pan = {\n          x: cyPan.x + panBy.x,\n          y: cyPan.y + panBy.y\n        };\n      }\n\n      // override pan w/ center if set\n      var center = properties.center || properties.centre;\n      if (isCore && center != null) {\n        var centerPan = cy.getCenterPan(center.eles, properties.zoom);\n        if (centerPan != null) {\n          properties.pan = centerPan;\n        }\n      }\n\n      // override pan & zoom w/ fit if set\n      if (isCore && properties.fit != null) {\n        var fit = properties.fit;\n        var fitVp = cy.getFitViewport(fit.eles || fit.boundingBox, fit.padding);\n        if (fitVp != null) {\n          properties.pan = fitVp.pan;\n          properties.zoom = fitVp.zoom;\n        }\n      }\n\n      // override zoom (& potentially pan) w/ zoom obj if set\n      if (isCore && plainObject(properties.zoom)) {\n        var vp = cy.getZoomedViewport(properties.zoom);\n        if (vp != null) {\n          if (vp.zoomed) {\n            properties.zoom = vp.zoom;\n          }\n          if (vp.panned) {\n            properties.pan = vp.pan;\n          }\n        } else {\n          properties.zoom = null; // an inavalid zoom (e.g. no delta) gets automatically destroyed\n        }\n      }\n\n      return new Animation(all[0], properties);\n    };\n  },\n  // animate\n\n  animate: function animate() {\n    return function animateImpl(properties, params) {\n      var self = this;\n      var selfIsArrayLike = self.length !== undefined;\n      var all = selfIsArrayLike ? self : [self]; // put in array if not array-like\n      var cy = this._private.cy || this;\n      if (!cy.styleEnabled()) {\n        return this;\n      }\n      if (params) {\n        properties = extend({}, properties, params);\n      }\n\n      // manually hook and run the animation\n      for (var i = 0; i < all.length; i++) {\n        var ele = all[i];\n        var queue = ele.animated() && (properties.queue === undefined || properties.queue);\n        var ani = ele.animation(properties, queue ? {\n          queue: true\n        } : undefined);\n        ani.play();\n      }\n      return this; // chaining\n    };\n  },\n\n  // animate\n\n  stop: function stop() {\n    return function stopImpl(clearQueue, jumpToEnd) {\n      var self = this;\n      var selfIsArrayLike = self.length !== undefined;\n      var all = selfIsArrayLike ? self : [self]; // put in array if not array-like\n      var cy = this._private.cy || this;\n      if (!cy.styleEnabled()) {\n        return this;\n      }\n      for (var i = 0; i < all.length; i++) {\n        var ele = all[i];\n        var _p = ele._private;\n        var anis = _p.animation.current;\n        for (var j = 0; j < anis.length; j++) {\n          var ani = anis[j];\n          var ani_p = ani._private;\n          if (jumpToEnd) {\n            // next iteration of the animation loop, the animation\n            // will go straight to the end and be removed\n            ani_p.duration = 0;\n          }\n        }\n\n        // clear the queue of future animations\n        if (clearQueue) {\n          _p.animation.queue = [];\n        }\n        if (!jumpToEnd) {\n          _p.animation.current = [];\n        }\n      }\n\n      // we have to notify (the animation loop doesn't do it for us on `stop`)\n      cy.notify('draw');\n      return this;\n    };\n  } // stop\n}; // define\n\n/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\nvar isArray_1 = isArray;\n\n/** Used to match property names within property paths. */\nvar reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/,\n    reIsPlainProp = /^\\w*$/;\n\n/**\n * Checks if `value` is a property name and not a property path.\n *\n * @private\n * @param {*} value The value to check.\n * @param {Object} [object] The object to query keys on.\n * @returns {boolean} Returns `true` if `value` is a property name, else `false`.\n */\nfunction isKey(value, object) {\n  if (isArray_1(value)) {\n    return false;\n  }\n  var type = typeof value;\n  if (type == 'number' || type == 'symbol' || type == 'boolean' ||\n      value == null || isSymbol_1(value)) {\n    return true;\n  }\n  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||\n    (object != null && value in Object(object));\n}\n\nvar _isKey = isKey;\n\n/** `Object#toString` result references. */\nvar asyncTag = '[object AsyncFunction]',\n    funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    proxyTag = '[object Proxy]';\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  if (!isObject_1(value)) {\n    return false;\n  }\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 9 which returns 'object' for typed arrays and other constructors.\n  var tag = _baseGetTag(value);\n  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\n}\n\nvar isFunction_1 = isFunction;\n\n/** Used to detect overreaching core-js shims. */\nvar coreJsData = _root['__core-js_shared__'];\n\nvar _coreJsData = coreJsData;\n\n/** Used to detect methods masquerading as native. */\nvar maskSrcKey = (function() {\n  var uid = /[^.]+$/.exec(_coreJsData && _coreJsData.keys && _coreJsData.keys.IE_PROTO || '');\n  return uid ? ('Symbol(src)_1.' + uid) : '';\n}());\n\n/**\n * Checks if `func` has its source masked.\n *\n * @private\n * @param {Function} func The function to check.\n * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n */\nfunction isMasked(func) {\n  return !!maskSrcKey && (maskSrcKey in func);\n}\n\nvar _isMasked = isMasked;\n\n/** Used for built-in method references. */\nvar funcProto$1 = Function.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString$1 = funcProto$1.toString;\n\n/**\n * Converts `func` to its source code.\n *\n * @private\n * @param {Function} func The function to convert.\n * @returns {string} Returns the source code.\n */\nfunction toSource(func) {\n  if (func != null) {\n    try {\n      return funcToString$1.call(func);\n    } catch (e) {}\n    try {\n      return (func + '');\n    } catch (e) {}\n  }\n  return '';\n}\n\nvar _toSource = toSource;\n\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n */\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\n/** Used to detect host constructors (Safari). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/** Used for built-in method references. */\nvar funcProto = Function.prototype,\n    objectProto$3 = Object.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty$3 = objectProto$3.hasOwnProperty;\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  funcToString.call(hasOwnProperty$3).replace(reRegExpChar, '\\\\$&')\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/**\n * The base implementation of `_.isNative` without bad shim checks.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function,\n *  else `false`.\n */\nfunction baseIsNative(value) {\n  if (!isObject_1(value) || _isMasked(value)) {\n    return false;\n  }\n  var pattern = isFunction_1(value) ? reIsNative : reIsHostCtor;\n  return pattern.test(_toSource(value));\n}\n\nvar _baseIsNative = baseIsNative;\n\n/**\n * Gets the value at `key` of `object`.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction getValue$1(object, key) {\n  return object == null ? undefined : object[key];\n}\n\nvar _getValue = getValue$1;\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = _getValue(object, key);\n  return _baseIsNative(value) ? value : undefined;\n}\n\nvar _getNative = getNative;\n\n/* Built-in method references that are verified to be native. */\nvar nativeCreate = _getNative(Object, 'create');\n\nvar _nativeCreate = nativeCreate;\n\n/**\n * Removes all key-value entries from the hash.\n *\n * @private\n * @name clear\n * @memberOf Hash\n */\nfunction hashClear() {\n  this.__data__ = _nativeCreate ? _nativeCreate(null) : {};\n  this.size = 0;\n}\n\nvar _hashClear = hashClear;\n\n/**\n * Removes `key` and its value from the hash.\n *\n * @private\n * @name delete\n * @memberOf Hash\n * @param {Object} hash The hash to modify.\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction hashDelete(key) {\n  var result = this.has(key) && delete this.__data__[key];\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\nvar _hashDelete = hashDelete;\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED$1 = '__lodash_hash_undefined__';\n\n/** Used for built-in method references. */\nvar objectProto$2 = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty$2 = objectProto$2.hasOwnProperty;\n\n/**\n * Gets the hash value for `key`.\n *\n * @private\n * @name get\n * @memberOf Hash\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction hashGet(key) {\n  var data = this.__data__;\n  if (_nativeCreate) {\n    var result = data[key];\n    return result === HASH_UNDEFINED$1 ? undefined : result;\n  }\n  return hasOwnProperty$2.call(data, key) ? data[key] : undefined;\n}\n\nvar _hashGet = hashGet;\n\n/** Used for built-in method references. */\nvar objectProto$1 = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty$1 = objectProto$1.hasOwnProperty;\n\n/**\n * Checks if a hash value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Hash\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction hashHas(key) {\n  var data = this.__data__;\n  return _nativeCreate ? (data[key] !== undefined) : hasOwnProperty$1.call(data, key);\n}\n\nvar _hashHas = hashHas;\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/**\n * Sets the hash `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Hash\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the hash instance.\n */\nfunction hashSet(key, value) {\n  var data = this.__data__;\n  this.size += this.has(key) ? 0 : 1;\n  data[key] = (_nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n  return this;\n}\n\nvar _hashSet = hashSet;\n\n/**\n * Creates a hash object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Hash(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n// Add methods to `Hash`.\nHash.prototype.clear = _hashClear;\nHash.prototype['delete'] = _hashDelete;\nHash.prototype.get = _hashGet;\nHash.prototype.has = _hashHas;\nHash.prototype.set = _hashSet;\n\nvar _Hash = Hash;\n\n/**\n * Removes all key-value entries from the list cache.\n *\n * @private\n * @name clear\n * @memberOf ListCache\n */\nfunction listCacheClear() {\n  this.__data__ = [];\n  this.size = 0;\n}\n\nvar _listCacheClear = listCacheClear;\n\n/**\n * Performs a\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * comparison between two values to determine if they are equivalent.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.eq(object, object);\n * // => true\n *\n * _.eq(object, other);\n * // => false\n *\n * _.eq('a', 'a');\n * // => true\n *\n * _.eq('a', Object('a'));\n * // => false\n *\n * _.eq(NaN, NaN);\n * // => true\n */\nfunction eq(value, other) {\n  return value === other || (value !== value && other !== other);\n}\n\nvar eq_1 = eq;\n\n/**\n * Gets the index at which the `key` is found in `array` of key-value pairs.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} key The key to search for.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction assocIndexOf(array, key) {\n  var length = array.length;\n  while (length--) {\n    if (eq_1(array[length][0], key)) {\n      return length;\n    }\n  }\n  return -1;\n}\n\nvar _assocIndexOf = assocIndexOf;\n\n/** Used for built-in method references. */\nvar arrayProto = Array.prototype;\n\n/** Built-in value references. */\nvar splice = arrayProto.splice;\n\n/**\n * Removes `key` and its value from the list cache.\n *\n * @private\n * @name delete\n * @memberOf ListCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction listCacheDelete(key) {\n  var data = this.__data__,\n      index = _assocIndexOf(data, key);\n\n  if (index < 0) {\n    return false;\n  }\n  var lastIndex = data.length - 1;\n  if (index == lastIndex) {\n    data.pop();\n  } else {\n    splice.call(data, index, 1);\n  }\n  --this.size;\n  return true;\n}\n\nvar _listCacheDelete = listCacheDelete;\n\n/**\n * Gets the list cache value for `key`.\n *\n * @private\n * @name get\n * @memberOf ListCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction listCacheGet(key) {\n  var data = this.__data__,\n      index = _assocIndexOf(data, key);\n\n  return index < 0 ? undefined : data[index][1];\n}\n\nvar _listCacheGet = listCacheGet;\n\n/**\n * Checks if a list cache value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf ListCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction listCacheHas(key) {\n  return _assocIndexOf(this.__data__, key) > -1;\n}\n\nvar _listCacheHas = listCacheHas;\n\n/**\n * Sets the list cache `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf ListCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the list cache instance.\n */\nfunction listCacheSet(key, value) {\n  var data = this.__data__,\n      index = _assocIndexOf(data, key);\n\n  if (index < 0) {\n    ++this.size;\n    data.push([key, value]);\n  } else {\n    data[index][1] = value;\n  }\n  return this;\n}\n\nvar _listCacheSet = listCacheSet;\n\n/**\n * Creates an list cache object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction ListCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n// Add methods to `ListCache`.\nListCache.prototype.clear = _listCacheClear;\nListCache.prototype['delete'] = _listCacheDelete;\nListCache.prototype.get = _listCacheGet;\nListCache.prototype.has = _listCacheHas;\nListCache.prototype.set = _listCacheSet;\n\nvar _ListCache = ListCache;\n\n/* Built-in method references that are verified to be native. */\nvar Map$1 = _getNative(_root, 'Map');\n\nvar _Map = Map$1;\n\n/**\n * Removes all key-value entries from the map.\n *\n * @private\n * @name clear\n * @memberOf MapCache\n */\nfunction mapCacheClear() {\n  this.size = 0;\n  this.__data__ = {\n    'hash': new _Hash,\n    'map': new (_Map || _ListCache),\n    'string': new _Hash\n  };\n}\n\nvar _mapCacheClear = mapCacheClear;\n\n/**\n * Checks if `value` is suitable for use as unique object key.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n */\nfunction isKeyable(value) {\n  var type = typeof value;\n  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n    ? (value !== '__proto__')\n    : (value === null);\n}\n\nvar _isKeyable = isKeyable;\n\n/**\n * Gets the data for `map`.\n *\n * @private\n * @param {Object} map The map to query.\n * @param {string} key The reference key.\n * @returns {*} Returns the map data.\n */\nfunction getMapData(map, key) {\n  var data = map.__data__;\n  return _isKeyable(key)\n    ? data[typeof key == 'string' ? 'string' : 'hash']\n    : data.map;\n}\n\nvar _getMapData = getMapData;\n\n/**\n * Removes `key` and its value from the map.\n *\n * @private\n * @name delete\n * @memberOf MapCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction mapCacheDelete(key) {\n  var result = _getMapData(this, key)['delete'](key);\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\nvar _mapCacheDelete = mapCacheDelete;\n\n/**\n * Gets the map value for `key`.\n *\n * @private\n * @name get\n * @memberOf MapCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction mapCacheGet(key) {\n  return _getMapData(this, key).get(key);\n}\n\nvar _mapCacheGet = mapCacheGet;\n\n/**\n * Checks if a map value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf MapCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction mapCacheHas(key) {\n  return _getMapData(this, key).has(key);\n}\n\nvar _mapCacheHas = mapCacheHas;\n\n/**\n * Sets the map `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf MapCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the map cache instance.\n */\nfunction mapCacheSet(key, value) {\n  var data = _getMapData(this, key),\n      size = data.size;\n\n  data.set(key, value);\n  this.size += data.size == size ? 0 : 1;\n  return this;\n}\n\nvar _mapCacheSet = mapCacheSet;\n\n/**\n * Creates a map cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction MapCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n// Add methods to `MapCache`.\nMapCache.prototype.clear = _mapCacheClear;\nMapCache.prototype['delete'] = _mapCacheDelete;\nMapCache.prototype.get = _mapCacheGet;\nMapCache.prototype.has = _mapCacheHas;\nMapCache.prototype.set = _mapCacheSet;\n\nvar _MapCache = MapCache;\n\n/** Error message constants. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/**\n * Creates a function that memoizes the result of `func`. If `resolver` is\n * provided, it determines the cache key for storing the result based on the\n * arguments provided to the memoized function. By default, the first argument\n * provided to the memoized function is used as the map cache key. The `func`\n * is invoked with the `this` binding of the memoized function.\n *\n * **Note:** The cache is exposed as the `cache` property on the memoized\n * function. Its creation may be customized by replacing the `_.memoize.Cache`\n * constructor with one whose instances implement the\n * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)\n * method interface of `clear`, `delete`, `get`, `has`, and `set`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to have its output memoized.\n * @param {Function} [resolver] The function to resolve the cache key.\n * @returns {Function} Returns the new memoized function.\n * @example\n *\n * var object = { 'a': 1, 'b': 2 };\n * var other = { 'c': 3, 'd': 4 };\n *\n * var values = _.memoize(_.values);\n * values(object);\n * // => [1, 2]\n *\n * values(other);\n * // => [3, 4]\n *\n * object.a = 2;\n * values(object);\n * // => [1, 2]\n *\n * // Modify the result cache.\n * values.cache.set(object, ['a', 'b']);\n * values(object);\n * // => ['a', 'b']\n *\n * // Replace `_.memoize.Cache`.\n * _.memoize.Cache = WeakMap;\n */\nfunction memoize(func, resolver) {\n  if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  var memoized = function() {\n    var args = arguments,\n        key = resolver ? resolver.apply(this, args) : args[0],\n        cache = memoized.cache;\n\n    if (cache.has(key)) {\n      return cache.get(key);\n    }\n    var result = func.apply(this, args);\n    memoized.cache = cache.set(key, result) || cache;\n    return result;\n  };\n  memoized.cache = new (memoize.Cache || _MapCache);\n  return memoized;\n}\n\n// Expose `MapCache`.\nmemoize.Cache = _MapCache;\n\nvar memoize_1 = memoize;\n\n/** Used as the maximum memoize cache size. */\nvar MAX_MEMOIZE_SIZE = 500;\n\n/**\n * A specialized version of `_.memoize` which clears the memoized function's\n * cache when it exceeds `MAX_MEMOIZE_SIZE`.\n *\n * @private\n * @param {Function} func The function to have its output memoized.\n * @returns {Function} Returns the new memoized function.\n */\nfunction memoizeCapped(func) {\n  var result = memoize_1(func, function(key) {\n    if (cache.size === MAX_MEMOIZE_SIZE) {\n      cache.clear();\n    }\n    return key;\n  });\n\n  var cache = result.cache;\n  return result;\n}\n\nvar _memoizeCapped = memoizeCapped;\n\n/** Used to match property names within property paths. */\nvar rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g;\n\n/** Used to match backslashes in property paths. */\nvar reEscapeChar = /\\\\(\\\\)?/g;\n\n/**\n * Converts `string` to a property path array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the property path array.\n */\nvar stringToPath = _memoizeCapped(function(string) {\n  var result = [];\n  if (string.charCodeAt(0) === 46 /* . */) {\n    result.push('');\n  }\n  string.replace(rePropName, function(match, number, quote, subString) {\n    result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));\n  });\n  return result;\n});\n\nvar _stringToPath = stringToPath;\n\n/**\n * A specialized version of `_.map` for arrays without support for iteratee\n * shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the new mapped array.\n */\nfunction arrayMap(array, iteratee) {\n  var index = -1,\n      length = array == null ? 0 : array.length,\n      result = Array(length);\n\n  while (++index < length) {\n    result[index] = iteratee(array[index], index, array);\n  }\n  return result;\n}\n\nvar _arrayMap = arrayMap;\n\n/** Used as references for various `Number` constants. */\nvar INFINITY$1 = 1 / 0;\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = _Symbol ? _Symbol.prototype : undefined,\n    symbolToString = symbolProto ? symbolProto.toString : undefined;\n\n/**\n * The base implementation of `_.toString` which doesn't convert nullish\n * values to empty strings.\n *\n * @private\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n */\nfunction baseToString(value) {\n  // Exit early for strings to avoid a performance hit in some environments.\n  if (typeof value == 'string') {\n    return value;\n  }\n  if (isArray_1(value)) {\n    // Recursively convert values (susceptible to call stack limits).\n    return _arrayMap(value, baseToString) + '';\n  }\n  if (isSymbol_1(value)) {\n    return symbolToString ? symbolToString.call(value) : '';\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY$1) ? '-0' : result;\n}\n\nvar _baseToString = baseToString;\n\n/**\n * Converts `value` to a string. An empty string is returned for `null`\n * and `undefined` values. The sign of `-0` is preserved.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n * @example\n *\n * _.toString(null);\n * // => ''\n *\n * _.toString(-0);\n * // => '-0'\n *\n * _.toString([1, 2, 3]);\n * // => '1,2,3'\n */\nfunction toString$1(value) {\n  return value == null ? '' : _baseToString(value);\n}\n\nvar toString_1 = toString$1;\n\n/**\n * Casts `value` to a path array if it's not one.\n *\n * @private\n * @param {*} value The value to inspect.\n * @param {Object} [object] The object to query keys on.\n * @returns {Array} Returns the cast property path array.\n */\nfunction castPath(value, object) {\n  if (isArray_1(value)) {\n    return value;\n  }\n  return _isKey(value, object) ? [value] : _stringToPath(toString_1(value));\n}\n\nvar _castPath = castPath;\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0;\n\n/**\n * Converts `value` to a string key if it's not a string or symbol.\n *\n * @private\n * @param {*} value The value to inspect.\n * @returns {string|symbol} Returns the key.\n */\nfunction toKey(value) {\n  if (typeof value == 'string' || isSymbol_1(value)) {\n    return value;\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\nvar _toKey = toKey;\n\n/**\n * The base implementation of `_.get` without support for default values.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @returns {*} Returns the resolved value.\n */\nfunction baseGet(object, path) {\n  path = _castPath(path, object);\n\n  var index = 0,\n      length = path.length;\n\n  while (object != null && index < length) {\n    object = object[_toKey(path[index++])];\n  }\n  return (index && index == length) ? object : undefined;\n}\n\nvar _baseGet = baseGet;\n\n/**\n * Gets the value at `path` of `object`. If the resolved value is\n * `undefined`, the `defaultValue` is returned in its place.\n *\n * @static\n * @memberOf _\n * @since 3.7.0\n * @category Object\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @param {*} [defaultValue] The value returned for `undefined` resolved values.\n * @returns {*} Returns the resolved value.\n * @example\n *\n * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n *\n * _.get(object, 'a[0].b.c');\n * // => 3\n *\n * _.get(object, ['a', '0', 'b', 'c']);\n * // => 3\n *\n * _.get(object, 'a.b.c', 'default');\n * // => 'default'\n */\nfunction get(object, path, defaultValue) {\n  var result = object == null ? undefined : _baseGet(object, path);\n  return result === undefined ? defaultValue : result;\n}\n\nvar get_1 = get;\n\nvar defineProperty = (function() {\n  try {\n    var func = _getNative(Object, 'defineProperty');\n    func({}, '', {});\n    return func;\n  } catch (e) {}\n}());\n\nvar _defineProperty = defineProperty;\n\n/**\n * The base implementation of `assignValue` and `assignMergeValue` without\n * value checks.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {string} key The key of the property to assign.\n * @param {*} value The value to assign.\n */\nfunction baseAssignValue(object, key, value) {\n  if (key == '__proto__' && _defineProperty) {\n    _defineProperty(object, key, {\n      'configurable': true,\n      'enumerable': true,\n      'value': value,\n      'writable': true\n    });\n  } else {\n    object[key] = value;\n  }\n}\n\nvar _baseAssignValue = baseAssignValue;\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Assigns `value` to `key` of `object` if the existing value is not equivalent\n * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * for equality comparisons.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {string} key The key of the property to assign.\n * @param {*} value The value to assign.\n */\nfunction assignValue(object, key, value) {\n  var objValue = object[key];\n  if (!(hasOwnProperty.call(object, key) && eq_1(objValue, value)) ||\n      (value === undefined && !(key in object))) {\n    _baseAssignValue(object, key, value);\n  }\n}\n\nvar _assignValue = assignValue;\n\n/** Used as references for various `Number` constants. */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/** Used to detect unsigned integer values. */\nvar reIsUint = /^(?:0|[1-9]\\d*)$/;\n\n/**\n * Checks if `value` is a valid array-like index.\n *\n * @private\n * @param {*} value The value to check.\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n */\nfunction isIndex(value, length) {\n  var type = typeof value;\n  length = length == null ? MAX_SAFE_INTEGER : length;\n\n  return !!length &&\n    (type == 'number' ||\n      (type != 'symbol' && reIsUint.test(value))) &&\n        (value > -1 && value % 1 == 0 && value < length);\n}\n\nvar _isIndex = isIndex;\n\n/**\n * The base implementation of `_.set`.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {Array|string} path The path of the property to set.\n * @param {*} value The value to set.\n * @param {Function} [customizer] The function to customize path creation.\n * @returns {Object} Returns `object`.\n */\nfunction baseSet(object, path, value, customizer) {\n  if (!isObject_1(object)) {\n    return object;\n  }\n  path = _castPath(path, object);\n\n  var index = -1,\n      length = path.length,\n      lastIndex = length - 1,\n      nested = object;\n\n  while (nested != null && ++index < length) {\n    var key = _toKey(path[index]),\n        newValue = value;\n\n    if (key === '__proto__' || key === 'constructor' || key === 'prototype') {\n      return object;\n    }\n\n    if (index != lastIndex) {\n      var objValue = nested[key];\n      newValue = customizer ? customizer(objValue, key, nested) : undefined;\n      if (newValue === undefined) {\n        newValue = isObject_1(objValue)\n          ? objValue\n          : (_isIndex(path[index + 1]) ? [] : {});\n      }\n    }\n    _assignValue(nested, key, newValue);\n    nested = nested[key];\n  }\n  return object;\n}\n\nvar _baseSet = baseSet;\n\n/**\n * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,\n * it's created. Arrays are created for missing index properties while objects\n * are created for all other missing properties. Use `_.setWith` to customize\n * `path` creation.\n *\n * **Note:** This method mutates `object`.\n *\n * @static\n * @memberOf _\n * @since 3.7.0\n * @category Object\n * @param {Object} object The object to modify.\n * @param {Array|string} path The path of the property to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns `object`.\n * @example\n *\n * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n *\n * _.set(object, 'a[0].b.c', 4);\n * console.log(object.a[0].b.c);\n * // => 4\n *\n * _.set(object, ['x', '0', 'y', 'z'], 5);\n * console.log(object.x[0].y.z);\n * // => 5\n */\nfunction set(object, path, value) {\n  return object == null ? object : _baseSet(object, path, value);\n}\n\nvar set_1 = set;\n\n/**\n * Copies the values of `source` to `array`.\n *\n * @private\n * @param {Array} source The array to copy values from.\n * @param {Array} [array=[]] The array to copy values to.\n * @returns {Array} Returns `array`.\n */\nfunction copyArray(source, array) {\n  var index = -1,\n      length = source.length;\n\n  array || (array = Array(length));\n  while (++index < length) {\n    array[index] = source[index];\n  }\n  return array;\n}\n\nvar _copyArray = copyArray;\n\n/**\n * Converts `value` to a property path array.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Util\n * @param {*} value The value to convert.\n * @returns {Array} Returns the new property path array.\n * @example\n *\n * _.toPath('a.b.c');\n * // => ['a', 'b', 'c']\n *\n * _.toPath('a[0].b.c');\n * // => ['a', '0', 'b', 'c']\n */\nfunction toPath(value) {\n  if (isArray_1(value)) {\n    return _arrayMap(value, _toKey);\n  }\n  return isSymbol_1(value) ? [value] : _copyArray(_stringToPath(toString_1(value)));\n}\n\nvar toPath_1 = toPath;\n\nvar define$2 = {\n  // access data field\n  data: function data(params) {\n    var defaults = {\n      field: 'data',\n      bindingEvent: 'data',\n      allowBinding: false,\n      allowSetting: false,\n      allowGetting: false,\n      settingEvent: 'data',\n      settingTriggersEvent: false,\n      triggerFnName: 'trigger',\n      immutableKeys: {},\n      // key => true if immutable\n      updateStyle: false,\n      beforeGet: function beforeGet(self) {},\n      beforeSet: function beforeSet(self, obj) {},\n      onSet: function onSet(self) {},\n      canSet: function canSet(self) {\n        return true;\n      }\n    };\n    params = extend({}, defaults, params);\n    return function dataImpl(name, value) {\n      var p = params;\n      var self = this;\n      var selfIsArrayLike = self.length !== undefined;\n      var all = selfIsArrayLike ? self : [self]; // put in array if not array-like\n      var single = selfIsArrayLike ? self[0] : self;\n\n      // .data('foo', ...)\n      if (string(name)) {\n        // set or get property\n        var isPathLike = name.indexOf('.') !== -1; // there might be a normal field with a dot \n        var path = isPathLike && toPath_1(name);\n\n        // .data('foo')\n        if (p.allowGetting && value === undefined) {\n          // get\n\n          var ret;\n          if (single) {\n            p.beforeGet(single);\n\n            // check if it's path and a field with the same name doesn't exist\n            if (path && single._private[p.field][name] === undefined) {\n              ret = get_1(single._private[p.field], path);\n            } else {\n              ret = single._private[p.field][name];\n            }\n          }\n          return ret;\n\n          // .data('foo', 'bar')\n        } else if (p.allowSetting && value !== undefined) {\n          // set\n          var valid = !p.immutableKeys[name];\n          if (valid) {\n            var change = _defineProperty$1({}, name, value);\n            p.beforeSet(self, change);\n            for (var i = 0, l = all.length; i < l; i++) {\n              var ele = all[i];\n              if (p.canSet(ele)) {\n                if (path && single._private[p.field][name] === undefined) {\n                  set_1(ele._private[p.field], path, value);\n                } else {\n                  ele._private[p.field][name] = value;\n                }\n              }\n            }\n\n            // update mappers if asked\n            if (p.updateStyle) {\n              self.updateStyle();\n            }\n\n            // call onSet callback\n            p.onSet(self);\n            if (p.settingTriggersEvent) {\n              self[p.triggerFnName](p.settingEvent);\n            }\n          }\n        }\n\n        // .data({ 'foo': 'bar' })\n      } else if (p.allowSetting && plainObject(name)) {\n        // extend\n        var obj = name;\n        var k, v;\n        var keys = Object.keys(obj);\n        p.beforeSet(self, obj);\n        for (var _i = 0; _i < keys.length; _i++) {\n          k = keys[_i];\n          v = obj[k];\n          var _valid = !p.immutableKeys[k];\n          if (_valid) {\n            for (var j = 0; j < all.length; j++) {\n              var _ele = all[j];\n              if (p.canSet(_ele)) {\n                _ele._private[p.field][k] = v;\n              }\n            }\n          }\n        }\n\n        // update mappers if asked\n        if (p.updateStyle) {\n          self.updateStyle();\n        }\n\n        // call onSet callback\n        p.onSet(self);\n        if (p.settingTriggersEvent) {\n          self[p.triggerFnName](p.settingEvent);\n        }\n\n        // .data(function(){ ... })\n      } else if (p.allowBinding && fn$6(name)) {\n        // bind to event\n        var fn = name;\n        self.on(p.bindingEvent, fn);\n\n        // .data()\n      } else if (p.allowGetting && name === undefined) {\n        // get whole object\n        var _ret;\n        if (single) {\n          p.beforeGet(single);\n          _ret = single._private[p.field];\n        }\n        return _ret;\n      }\n      return self; // maintain chainability\n    }; // function\n  },\n\n  // data\n\n  // remove data field\n  removeData: function removeData(params) {\n    var defaults = {\n      field: 'data',\n      event: 'data',\n      triggerFnName: 'trigger',\n      triggerEvent: false,\n      immutableKeys: {} // key => true if immutable\n    };\n\n    params = extend({}, defaults, params);\n    return function removeDataImpl(names) {\n      var p = params;\n      var self = this;\n      var selfIsArrayLike = self.length !== undefined;\n      var all = selfIsArrayLike ? self : [self]; // put in array if not array-like\n\n      // .removeData('foo bar')\n      if (string(names)) {\n        // then get the list of keys, and delete them\n        var keys = names.split(/\\s+/);\n        var l = keys.length;\n        for (var i = 0; i < l; i++) {\n          // delete each non-empty key\n          var key = keys[i];\n          if (emptyString(key)) {\n            continue;\n          }\n          var valid = !p.immutableKeys[key]; // not valid if immutable\n          if (valid) {\n            for (var i_a = 0, l_a = all.length; i_a < l_a; i_a++) {\n              all[i_a]._private[p.field][key] = undefined;\n            }\n          }\n        }\n        if (p.triggerEvent) {\n          self[p.triggerFnName](p.event);\n        }\n\n        // .removeData()\n      } else if (names === undefined) {\n        // then delete all keys\n\n        for (var _i_a = 0, _l_a = all.length; _i_a < _l_a; _i_a++) {\n          var _privateFields = all[_i_a]._private[p.field];\n          var _keys = Object.keys(_privateFields);\n          for (var _i2 = 0; _i2 < _keys.length; _i2++) {\n            var _key = _keys[_i2];\n            var validKeyToDelete = !p.immutableKeys[_key];\n            if (validKeyToDelete) {\n              _privateFields[_key] = undefined;\n            }\n          }\n        }\n        if (p.triggerEvent) {\n          self[p.triggerFnName](p.event);\n        }\n      }\n      return self; // maintain chaining\n    }; // function\n  } // removeData\n}; // define\n\nvar define$1 = {\n  eventAliasesOn: function eventAliasesOn(proto) {\n    var p = proto;\n    p.addListener = p.listen = p.bind = p.on;\n    p.unlisten = p.unbind = p.off = p.removeListener;\n    p.trigger = p.emit;\n\n    // this is just a wrapper alias of .on()\n    p.pon = p.promiseOn = function (events, selector) {\n      var self = this;\n      var args = Array.prototype.slice.call(arguments, 0);\n      return new Promise$1(function (resolve, reject) {\n        var callback = function callback(e) {\n          self.off.apply(self, offArgs);\n          resolve(e);\n        };\n        var onArgs = args.concat([callback]);\n        var offArgs = onArgs.concat([]);\n        self.on.apply(self, onArgs);\n      });\n    };\n  }\n}; // define\n\n// use this module to cherry pick functions into your prototype\nvar define = {};\n[define$3, define$2, define$1].forEach(function (m) {\n  extend(define, m);\n});\n\nvar elesfn$i = {\n  animate: define.animate(),\n  animation: define.animation(),\n  animated: define.animated(),\n  clearQueue: define.clearQueue(),\n  delay: define.delay(),\n  delayAnimation: define.delayAnimation(),\n  stop: define.stop()\n};\n\nvar elesfn$h = {\n  classes: function classes(_classes) {\n    var self = this;\n    if (_classes === undefined) {\n      var ret = [];\n      self[0]._private.classes.forEach(function (cls) {\n        return ret.push(cls);\n      });\n      return ret;\n    } else if (!array(_classes)) {\n      // extract classes from string\n      _classes = (_classes || '').match(/\\S+/g) || [];\n    }\n    var changed = [];\n    var classesSet = new Set$1(_classes);\n\n    // check and update each ele\n    for (var j = 0; j < self.length; j++) {\n      var ele = self[j];\n      var _p = ele._private;\n      var eleClasses = _p.classes;\n      var changedEle = false;\n\n      // check if ele has all of the passed classes\n      for (var i = 0; i < _classes.length; i++) {\n        var cls = _classes[i];\n        var eleHasClass = eleClasses.has(cls);\n        if (!eleHasClass) {\n          changedEle = true;\n          break;\n        }\n      }\n\n      // check if ele has classes outside of those passed\n      if (!changedEle) {\n        changedEle = eleClasses.size !== _classes.length;\n      }\n      if (changedEle) {\n        _p.classes = classesSet;\n        changed.push(ele);\n      }\n    }\n\n    // trigger update style on those eles that had class changes\n    if (changed.length > 0) {\n      this.spawn(changed).updateStyle().emit('class');\n    }\n    return self;\n  },\n  addClass: function addClass(classes) {\n    return this.toggleClass(classes, true);\n  },\n  hasClass: function hasClass(className) {\n    var ele = this[0];\n    return ele != null && ele._private.classes.has(className);\n  },\n  toggleClass: function toggleClass(classes, toggle) {\n    if (!array(classes)) {\n      // extract classes from string\n      classes = classes.match(/\\S+/g) || [];\n    }\n    var self = this;\n    var toggleUndefd = toggle === undefined;\n    var changed = []; // eles who had classes changed\n\n    for (var i = 0, il = self.length; i < il; i++) {\n      var ele = self[i];\n      var eleClasses = ele._private.classes;\n      var changedEle = false;\n      for (var j = 0; j < classes.length; j++) {\n        var cls = classes[j];\n        var hasClass = eleClasses.has(cls);\n        var changedNow = false;\n        if (toggle || toggleUndefd && !hasClass) {\n          eleClasses.add(cls);\n          changedNow = true;\n        } else if (!toggle || toggleUndefd && hasClass) {\n          eleClasses[\"delete\"](cls);\n          changedNow = true;\n        }\n        if (!changedEle && changedNow) {\n          changed.push(ele);\n          changedEle = true;\n        }\n      } // for j classes\n    } // for i eles\n\n    // trigger update style on those eles that had class changes\n    if (changed.length > 0) {\n      this.spawn(changed).updateStyle().emit('class');\n    }\n    return self;\n  },\n  removeClass: function removeClass(classes) {\n    return this.toggleClass(classes, false);\n  },\n  flashClass: function flashClass(classes, duration) {\n    var self = this;\n    if (duration == null) {\n      duration = 250;\n    } else if (duration === 0) {\n      return self; // nothing to do really\n    }\n\n    self.addClass(classes);\n    setTimeout(function () {\n      self.removeClass(classes);\n    }, duration);\n    return self;\n  }\n};\nelesfn$h.className = elesfn$h.classNames = elesfn$h.classes;\n\n// tokens in the query language\nvar tokens = {\n  metaChar: '[\\\\!\\\\\"\\\\#\\\\$\\\\%\\\\&\\\\\\'\\\\(\\\\)\\\\*\\\\+\\\\,\\\\.\\\\/\\\\:\\\\;\\\\<\\\\=\\\\>\\\\?\\\\@\\\\[\\\\]\\\\^\\\\`\\\\{\\\\|\\\\}\\\\~]',\n  // chars we need to escape in let names, etc\n  comparatorOp: '=|\\\\!=|>|>=|<|<=|\\\\$=|\\\\^=|\\\\*=',\n  // binary comparison op (used in data selectors)\n  boolOp: '\\\\?|\\\\!|\\\\^',\n  // boolean (unary) operators (used in data selectors)\n  string: '\"(?:\\\\\\\\\"|[^\"])*\"' + '|' + \"'(?:\\\\\\\\'|[^'])*'\",\n  // string literals (used in data selectors) -- doublequotes | singlequotes\n  number: number,\n  // number literal (used in data selectors) --- e.g. 0.1234, 1234, 12e123\n  meta: 'degree|indegree|outdegree',\n  // allowed metadata fields (i.e. allowed functions to use from Collection)\n  separator: '\\\\s*,\\\\s*',\n  // queries are separated by commas, e.g. edge[foo = 'bar'], node.someClass\n  descendant: '\\\\s+',\n  child: '\\\\s+>\\\\s+',\n  subject: '\\\\$',\n  group: 'node|edge|\\\\*',\n  directedEdge: '\\\\s+->\\\\s+',\n  undirectedEdge: '\\\\s+<->\\\\s+'\n};\ntokens.variable = '(?:[\\\\w-.]|(?:\\\\\\\\' + tokens.metaChar + '))+'; // a variable name can have letters, numbers, dashes, and periods\ntokens.className = '(?:[\\\\w-]|(?:\\\\\\\\' + tokens.metaChar + '))+'; // a class name has the same rules as a variable except it can't have a '.' in the name\ntokens.value = tokens.string + '|' + tokens.number; // a value literal, either a string or number\ntokens.id = tokens.variable; // an element id (follows variable conventions)\n\n(function () {\n  var ops, op, i;\n\n  // add @ variants to comparatorOp\n  ops = tokens.comparatorOp.split('|');\n  for (i = 0; i < ops.length; i++) {\n    op = ops[i];\n    tokens.comparatorOp += '|@' + op;\n  }\n\n  // add ! variants to comparatorOp\n  ops = tokens.comparatorOp.split('|');\n  for (i = 0; i < ops.length; i++) {\n    op = ops[i];\n    if (op.indexOf('!') >= 0) {\n      continue;\n    } // skip ops that explicitly contain !\n    if (op === '=') {\n      continue;\n    } // skip = b/c != is explicitly defined\n\n    tokens.comparatorOp += '|\\\\!' + op;\n  }\n})();\n\n/**\n * Make a new query object\n *\n * @prop type {Type} The type enum (int) of the query\n * @prop checks List of checks to make against an ele to test for a match\n */\nvar newQuery = function newQuery() {\n  return {\n    checks: []\n  };\n};\n\n/**\n * A check type enum-like object.  Uses integer values for fast match() lookup.\n * The ordering does not matter as long as the ints are unique.\n */\nvar Type = {\n  /** E.g. node */\n  GROUP: 0,\n  /** A collection of elements */\n  COLLECTION: 1,\n  /** A filter(ele) function */\n  FILTER: 2,\n  /** E.g. [foo > 1] */\n  DATA_COMPARE: 3,\n  /** E.g. [foo] */\n  DATA_EXIST: 4,\n  /** E.g. [?foo] */\n  DATA_BOOL: 5,\n  /** E.g. [[degree > 2]] */\n  META_COMPARE: 6,\n  /** E.g. :selected */\n  STATE: 7,\n  /** E.g. #foo */\n  ID: 8,\n  /** E.g. .foo */\n  CLASS: 9,\n  /** E.g. #foo <-> #bar */\n  UNDIRECTED_EDGE: 10,\n  /** E.g. #foo -> #bar */\n  DIRECTED_EDGE: 11,\n  /** E.g. $#foo -> #bar */\n  NODE_SOURCE: 12,\n  /** E.g. #foo -> $#bar */\n  NODE_TARGET: 13,\n  /** E.g. $#foo <-> #bar */\n  NODE_NEIGHBOR: 14,\n  /** E.g. #foo > #bar */\n  CHILD: 15,\n  /** E.g. #foo #bar */\n  DESCENDANT: 16,\n  /** E.g. $#foo > #bar */\n  PARENT: 17,\n  /** E.g. $#foo #bar */\n  ANCESTOR: 18,\n  /** E.g. #foo > $bar > #baz */\n  COMPOUND_SPLIT: 19,\n  /** Always matches, useful placeholder for subject in `COMPOUND_SPLIT` */\n  TRUE: 20\n};\n\nvar stateSelectors = [{\n  selector: ':selected',\n  matches: function matches(ele) {\n    return ele.selected();\n  }\n}, {\n  selector: ':unselected',\n  matches: function matches(ele) {\n    return !ele.selected();\n  }\n}, {\n  selector: ':selectable',\n  matches: function matches(ele) {\n    return ele.selectable();\n  }\n}, {\n  selector: ':unselectable',\n  matches: function matches(ele) {\n    return !ele.selectable();\n  }\n}, {\n  selector: ':locked',\n  matches: function matches(ele) {\n    return ele.locked();\n  }\n}, {\n  selector: ':unlocked',\n  matches: function matches(ele) {\n    return !ele.locked();\n  }\n}, {\n  selector: ':visible',\n  matches: function matches(ele) {\n    return ele.visible();\n  }\n}, {\n  selector: ':hidden',\n  matches: function matches(ele) {\n    return !ele.visible();\n  }\n}, {\n  selector: ':transparent',\n  matches: function matches(ele) {\n    return ele.transparent();\n  }\n}, {\n  selector: ':grabbed',\n  matches: function matches(ele) {\n    return ele.grabbed();\n  }\n}, {\n  selector: ':free',\n  matches: function matches(ele) {\n    return !ele.grabbed();\n  }\n}, {\n  selector: ':removed',\n  matches: function matches(ele) {\n    return ele.removed();\n  }\n}, {\n  selector: ':inside',\n  matches: function matches(ele) {\n    return !ele.removed();\n  }\n}, {\n  selector: ':grabbable',\n  matches: function matches(ele) {\n    return ele.grabbable();\n  }\n}, {\n  selector: ':ungrabbable',\n  matches: function matches(ele) {\n    return !ele.grabbable();\n  }\n}, {\n  selector: ':animated',\n  matches: function matches(ele) {\n    return ele.animated();\n  }\n}, {\n  selector: ':unanimated',\n  matches: function matches(ele) {\n    return !ele.animated();\n  }\n}, {\n  selector: ':parent',\n  matches: function matches(ele) {\n    return ele.isParent();\n  }\n}, {\n  selector: ':childless',\n  matches: function matches(ele) {\n    return ele.isChildless();\n  }\n}, {\n  selector: ':child',\n  matches: function matches(ele) {\n    return ele.isChild();\n  }\n}, {\n  selector: ':orphan',\n  matches: function matches(ele) {\n    return ele.isOrphan();\n  }\n}, {\n  selector: ':nonorphan',\n  matches: function matches(ele) {\n    return ele.isChild();\n  }\n}, {\n  selector: ':compound',\n  matches: function matches(ele) {\n    if (ele.isNode()) {\n      return ele.isParent();\n    } else {\n      return ele.source().isParent() || ele.target().isParent();\n    }\n  }\n}, {\n  selector: ':loop',\n  matches: function matches(ele) {\n    return ele.isLoop();\n  }\n}, {\n  selector: ':simple',\n  matches: function matches(ele) {\n    return ele.isSimple();\n  }\n}, {\n  selector: ':active',\n  matches: function matches(ele) {\n    return ele.active();\n  }\n}, {\n  selector: ':inactive',\n  matches: function matches(ele) {\n    return !ele.active();\n  }\n}, {\n  selector: ':backgrounding',\n  matches: function matches(ele) {\n    return ele.backgrounding();\n  }\n}, {\n  selector: ':nonbackgrounding',\n  matches: function matches(ele) {\n    return !ele.backgrounding();\n  }\n}].sort(function (a, b) {\n  // n.b. selectors that are starting substrings of others must have the longer ones first\n  return descending(a.selector, b.selector);\n});\nvar lookup = function () {\n  var selToFn = {};\n  var s;\n  for (var i = 0; i < stateSelectors.length; i++) {\n    s = stateSelectors[i];\n    selToFn[s.selector] = s.matches;\n  }\n  return selToFn;\n}();\nvar stateSelectorMatches = function stateSelectorMatches(sel, ele) {\n  return lookup[sel](ele);\n};\nvar stateSelectorRegex = '(' + stateSelectors.map(function (s) {\n  return s.selector;\n}).join('|') + ')';\n\n// when a token like a variable has escaped meta characters, we need to clean the backslashes out\n// so that values get compared properly in Selector.filter()\nvar cleanMetaChars = function cleanMetaChars(str) {\n  return str.replace(new RegExp('\\\\\\\\(' + tokens.metaChar + ')', 'g'), function (match, $1) {\n    return $1;\n  });\n};\nvar replaceLastQuery = function replaceLastQuery(selector, examiningQuery, replacementQuery) {\n  selector[selector.length - 1] = replacementQuery;\n};\n\n// NOTE: add new expression syntax here to have it recognised by the parser;\n// - a query contains all adjacent (i.e. no separator in between) expressions;\n// - the current query is stored in selector[i]\n// - you need to check the query objects in match() for it actually filter properly, but that's pretty straight forward\nvar exprs = [{\n  name: 'group',\n  // just used for identifying when debugging\n  query: true,\n  regex: '(' + tokens.group + ')',\n  populate: function populate(selector, query, _ref) {\n    var _ref2 = _slicedToArray(_ref, 1),\n      group = _ref2[0];\n    query.checks.push({\n      type: Type.GROUP,\n      value: group === '*' ? group : group + 's'\n    });\n  }\n}, {\n  name: 'state',\n  query: true,\n  regex: stateSelectorRegex,\n  populate: function populate(selector, query, _ref3) {\n    var _ref4 = _slicedToArray(_ref3, 1),\n      state = _ref4[0];\n    query.checks.push({\n      type: Type.STATE,\n      value: state\n    });\n  }\n}, {\n  name: 'id',\n  query: true,\n  regex: '\\\\#(' + tokens.id + ')',\n  populate: function populate(selector, query, _ref5) {\n    var _ref6 = _slicedToArray(_ref5, 1),\n      id = _ref6[0];\n    query.checks.push({\n      type: Type.ID,\n      value: cleanMetaChars(id)\n    });\n  }\n}, {\n  name: 'className',\n  query: true,\n  regex: '\\\\.(' + tokens.className + ')',\n  populate: function populate(selector, query, _ref7) {\n    var _ref8 = _slicedToArray(_ref7, 1),\n      className = _ref8[0];\n    query.checks.push({\n      type: Type.CLASS,\n      value: cleanMetaChars(className)\n    });\n  }\n}, {\n  name: 'dataExists',\n  query: true,\n  regex: '\\\\[\\\\s*(' + tokens.variable + ')\\\\s*\\\\]',\n  populate: function populate(selector, query, _ref9) {\n    var _ref10 = _slicedToArray(_ref9, 1),\n      variable = _ref10[0];\n    query.checks.push({\n      type: Type.DATA_EXIST,\n      field: cleanMetaChars(variable)\n    });\n  }\n}, {\n  name: 'dataCompare',\n  query: true,\n  regex: '\\\\[\\\\s*(' + tokens.variable + ')\\\\s*(' + tokens.comparatorOp + ')\\\\s*(' + tokens.value + ')\\\\s*\\\\]',\n  populate: function populate(selector, query, _ref11) {\n    var _ref12 = _slicedToArray(_ref11, 3),\n      variable = _ref12[0],\n      comparatorOp = _ref12[1],\n      value = _ref12[2];\n    var valueIsString = new RegExp('^' + tokens.string + '$').exec(value) != null;\n    if (valueIsString) {\n      value = value.substring(1, value.length - 1);\n    } else {\n      value = parseFloat(value);\n    }\n    query.checks.push({\n      type: Type.DATA_COMPARE,\n      field: cleanMetaChars(variable),\n      operator: comparatorOp,\n      value: value\n    });\n  }\n}, {\n  name: 'dataBool',\n  query: true,\n  regex: '\\\\[\\\\s*(' + tokens.boolOp + ')\\\\s*(' + tokens.variable + ')\\\\s*\\\\]',\n  populate: function populate(selector, query, _ref13) {\n    var _ref14 = _slicedToArray(_ref13, 2),\n      boolOp = _ref14[0],\n      variable = _ref14[1];\n    query.checks.push({\n      type: Type.DATA_BOOL,\n      field: cleanMetaChars(variable),\n      operator: boolOp\n    });\n  }\n}, {\n  name: 'metaCompare',\n  query: true,\n  regex: '\\\\[\\\\[\\\\s*(' + tokens.meta + ')\\\\s*(' + tokens.comparatorOp + ')\\\\s*(' + tokens.number + ')\\\\s*\\\\]\\\\]',\n  populate: function populate(selector, query, _ref15) {\n    var _ref16 = _slicedToArray(_ref15, 3),\n      meta = _ref16[0],\n      comparatorOp = _ref16[1],\n      number = _ref16[2];\n    query.checks.push({\n      type: Type.META_COMPARE,\n      field: cleanMetaChars(meta),\n      operator: comparatorOp,\n      value: parseFloat(number)\n    });\n  }\n}, {\n  name: 'nextQuery',\n  separator: true,\n  regex: tokens.separator,\n  populate: function populate(selector, query) {\n    var currentSubject = selector.currentSubject;\n    var edgeCount = selector.edgeCount;\n    var compoundCount = selector.compoundCount;\n    var lastQ = selector[selector.length - 1];\n    if (currentSubject != null) {\n      lastQ.subject = currentSubject;\n      selector.currentSubject = null;\n    }\n    lastQ.edgeCount = edgeCount;\n    lastQ.compoundCount = compoundCount;\n    selector.edgeCount = 0;\n    selector.compoundCount = 0;\n\n    // go on to next query\n    var nextQuery = selector[selector.length++] = newQuery();\n    return nextQuery; // this is the new query to be filled by the following exprs\n  }\n}, {\n  name: 'directedEdge',\n  separator: true,\n  regex: tokens.directedEdge,\n  populate: function populate(selector, query) {\n    if (selector.currentSubject == null) {\n      // undirected edge\n      var edgeQuery = newQuery();\n      var source = query;\n      var target = newQuery();\n      edgeQuery.checks.push({\n        type: Type.DIRECTED_EDGE,\n        source: source,\n        target: target\n      });\n\n      // the query in the selector should be the edge rather than the source\n      replaceLastQuery(selector, query, edgeQuery);\n      selector.edgeCount++;\n\n      // we're now populating the target query with expressions that follow\n      return target;\n    } else {\n      // source/target\n      var srcTgtQ = newQuery();\n      var _source = query;\n      var _target = newQuery();\n      srcTgtQ.checks.push({\n        type: Type.NODE_SOURCE,\n        source: _source,\n        target: _target\n      });\n\n      // the query in the selector should be the neighbourhood rather than the node\n      replaceLastQuery(selector, query, srcTgtQ);\n      selector.edgeCount++;\n      return _target; // now populating the target with the following expressions\n    }\n  }\n}, {\n  name: 'undirectedEdge',\n  separator: true,\n  regex: tokens.undirectedEdge,\n  populate: function populate(selector, query) {\n    if (selector.currentSubject == null) {\n      // undirected edge\n      var edgeQuery = newQuery();\n      var source = query;\n      var target = newQuery();\n      edgeQuery.checks.push({\n        type: Type.UNDIRECTED_EDGE,\n        nodes: [source, target]\n      });\n\n      // the query in the selector should be the edge rather than the source\n      replaceLastQuery(selector, query, edgeQuery);\n      selector.edgeCount++;\n\n      // we're now populating the target query with expressions that follow\n      return target;\n    } else {\n      // neighbourhood\n      var nhoodQ = newQuery();\n      var node = query;\n      var neighbor = newQuery();\n      nhoodQ.checks.push({\n        type: Type.NODE_NEIGHBOR,\n        node: node,\n        neighbor: neighbor\n      });\n\n      // the query in the selector should be the neighbourhood rather than the node\n      replaceLastQuery(selector, query, nhoodQ);\n      return neighbor; // now populating the neighbor with following expressions\n    }\n  }\n}, {\n  name: 'child',\n  separator: true,\n  regex: tokens.child,\n  populate: function populate(selector, query) {\n    if (selector.currentSubject == null) {\n      // default: child query\n      var parentChildQuery = newQuery();\n      var child = newQuery();\n      var parent = selector[selector.length - 1];\n      parentChildQuery.checks.push({\n        type: Type.CHILD,\n        parent: parent,\n        child: child\n      });\n\n      // the query in the selector should be the '>' itself\n      replaceLastQuery(selector, query, parentChildQuery);\n      selector.compoundCount++;\n\n      // we're now populating the child query with expressions that follow\n      return child;\n    } else if (selector.currentSubject === query) {\n      // compound split query\n      var compound = newQuery();\n      var left = selector[selector.length - 1];\n      var right = newQuery();\n      var subject = newQuery();\n      var _child = newQuery();\n      var _parent = newQuery();\n\n      // set up the root compound q\n      compound.checks.push({\n        type: Type.COMPOUND_SPLIT,\n        left: left,\n        right: right,\n        subject: subject\n      });\n\n      // populate the subject and replace the q at the old spot (within left) with TRUE\n      subject.checks = query.checks; // take the checks from the left\n      query.checks = [{\n        type: Type.TRUE\n      }]; // checks under left refs the subject implicitly\n\n      // set up the right q\n      _parent.checks.push({\n        type: Type.TRUE\n      }); // parent implicitly refs the subject\n      right.checks.push({\n        type: Type.PARENT,\n        // type is swapped on right side queries\n        parent: _parent,\n        child: _child // empty for now\n      });\n\n      replaceLastQuery(selector, left, compound);\n\n      // update the ref since we moved things around for `query`\n      selector.currentSubject = subject;\n      selector.compoundCount++;\n      return _child; // now populating the right side's child\n    } else {\n      // parent query\n      // info for parent query\n      var _parent2 = newQuery();\n      var _child2 = newQuery();\n      var pcQChecks = [{\n        type: Type.PARENT,\n        parent: _parent2,\n        child: _child2\n      }];\n\n      // the parent-child query takes the place of the query previously being populated\n      _parent2.checks = query.checks; // the previous query contains the checks for the parent\n      query.checks = pcQChecks; // pc query takes over\n\n      selector.compoundCount++;\n      return _child2; // we're now populating the child\n    }\n  }\n}, {\n  name: 'descendant',\n  separator: true,\n  regex: tokens.descendant,\n  populate: function populate(selector, query) {\n    if (selector.currentSubject == null) {\n      // default: descendant query\n      var ancChQuery = newQuery();\n      var descendant = newQuery();\n      var ancestor = selector[selector.length - 1];\n      ancChQuery.checks.push({\n        type: Type.DESCENDANT,\n        ancestor: ancestor,\n        descendant: descendant\n      });\n\n      // the query in the selector should be the '>' itself\n      replaceLastQuery(selector, query, ancChQuery);\n      selector.compoundCount++;\n\n      // we're now populating the descendant query with expressions that follow\n      return descendant;\n    } else if (selector.currentSubject === query) {\n      // compound split query\n      var compound = newQuery();\n      var left = selector[selector.length - 1];\n      var right = newQuery();\n      var subject = newQuery();\n      var _descendant = newQuery();\n      var _ancestor = newQuery();\n\n      // set up the root compound q\n      compound.checks.push({\n        type: Type.COMPOUND_SPLIT,\n        left: left,\n        right: right,\n        subject: subject\n      });\n\n      // populate the subject and replace the q at the old spot (within left) with TRUE\n      subject.checks = query.checks; // take the checks from the left\n      query.checks = [{\n        type: Type.TRUE\n      }]; // checks under left refs the subject implicitly\n\n      // set up the right q\n      _ancestor.checks.push({\n        type: Type.TRUE\n      }); // ancestor implicitly refs the subject\n      right.checks.push({\n        type: Type.ANCESTOR,\n        // type is swapped on right side queries\n        ancestor: _ancestor,\n        descendant: _descendant // empty for now\n      });\n\n      replaceLastQuery(selector, left, compound);\n\n      // update the ref since we moved things around for `query`\n      selector.currentSubject = subject;\n      selector.compoundCount++;\n      return _descendant; // now populating the right side's descendant\n    } else {\n      // ancestor query\n      // info for parent query\n      var _ancestor2 = newQuery();\n      var _descendant2 = newQuery();\n      var adQChecks = [{\n        type: Type.ANCESTOR,\n        ancestor: _ancestor2,\n        descendant: _descendant2\n      }];\n\n      // the parent-child query takes the place of the query previously being populated\n      _ancestor2.checks = query.checks; // the previous query contains the checks for the parent\n      query.checks = adQChecks; // pc query takes over\n\n      selector.compoundCount++;\n      return _descendant2; // we're now populating the child\n    }\n  }\n}, {\n  name: 'subject',\n  modifier: true,\n  regex: tokens.subject,\n  populate: function populate(selector, query) {\n    if (selector.currentSubject != null && selector.currentSubject !== query) {\n      warn('Redefinition of subject in selector `' + selector.toString() + '`');\n      return false;\n    }\n    selector.currentSubject = query;\n    var topQ = selector[selector.length - 1];\n    var topChk = topQ.checks[0];\n    var topType = topChk == null ? null : topChk.type;\n    if (topType === Type.DIRECTED_EDGE) {\n      // directed edge with subject on the target\n\n      // change to target node check\n      topChk.type = Type.NODE_TARGET;\n    } else if (topType === Type.UNDIRECTED_EDGE) {\n      // undirected edge with subject on the second node\n\n      // change to neighbor check\n      topChk.type = Type.NODE_NEIGHBOR;\n      topChk.node = topChk.nodes[1]; // second node is subject\n      topChk.neighbor = topChk.nodes[0];\n\n      // clean up unused fields for new type\n      topChk.nodes = null;\n    }\n  }\n}];\nexprs.forEach(function (e) {\n  return e.regexObj = new RegExp('^' + e.regex);\n});\n\n/**\n * Of all the expressions, find the first match in the remaining text.\n * @param {string} remaining The remaining text to parse\n * @returns The matched expression and the newly remaining text `{ expr, match, name, remaining }`\n */\nvar consumeExpr = function consumeExpr(remaining) {\n  var expr;\n  var match;\n  var name;\n  for (var j = 0; j < exprs.length; j++) {\n    var e = exprs[j];\n    var n = e.name;\n    var m = remaining.match(e.regexObj);\n    if (m != null) {\n      match = m;\n      expr = e;\n      name = n;\n      var consumed = m[0];\n      remaining = remaining.substring(consumed.length);\n      break; // we've consumed one expr, so we can return now\n    }\n  }\n\n  return {\n    expr: expr,\n    match: match,\n    name: name,\n    remaining: remaining\n  };\n};\n\n/**\n * Consume all the leading whitespace\n * @param {string} remaining The text to consume\n * @returns The text with the leading whitespace removed\n */\nvar consumeWhitespace = function consumeWhitespace(remaining) {\n  var match = remaining.match(/^\\s+/);\n  if (match) {\n    var consumed = match[0];\n    remaining = remaining.substring(consumed.length);\n  }\n  return remaining;\n};\n\n/**\n * Parse the string and store the parsed representation in the Selector.\n * @param {string} selector The selector string\n * @returns `true` if the selector was successfully parsed, `false` otherwise\n */\nvar parse = function parse(selector) {\n  var self = this;\n  var remaining = self.inputText = selector;\n  var currentQuery = self[0] = newQuery();\n  self.length = 1;\n  remaining = consumeWhitespace(remaining); // get rid of leading whitespace\n\n  for (;;) {\n    var exprInfo = consumeExpr(remaining);\n    if (exprInfo.expr == null) {\n      warn('The selector `' + selector + '`is invalid');\n      return false;\n    } else {\n      var args = exprInfo.match.slice(1);\n\n      // let the token populate the selector object in currentQuery\n      var ret = exprInfo.expr.populate(self, currentQuery, args);\n      if (ret === false) {\n        return false; // exit if population failed\n      } else if (ret != null) {\n        currentQuery = ret; // change the current query to be filled if the expr specifies\n      }\n    }\n\n    remaining = exprInfo.remaining;\n\n    // we're done when there's nothing left to parse\n    if (remaining.match(/^\\s*$/)) {\n      break;\n    }\n  }\n  var lastQ = self[self.length - 1];\n  if (self.currentSubject != null) {\n    lastQ.subject = self.currentSubject;\n  }\n  lastQ.edgeCount = self.edgeCount;\n  lastQ.compoundCount = self.compoundCount;\n  for (var i = 0; i < self.length; i++) {\n    var q = self[i];\n\n    // in future, this could potentially be allowed if there were operator precedence and detection of invalid combinations\n    if (q.compoundCount > 0 && q.edgeCount > 0) {\n      warn('The selector `' + selector + '` is invalid because it uses both a compound selector and an edge selector');\n      return false;\n    }\n    if (q.edgeCount > 1) {\n      warn('The selector `' + selector + '` is invalid because it uses multiple edge selectors');\n      return false;\n    } else if (q.edgeCount === 1) {\n      warn('The selector `' + selector + '` is deprecated.  Edge selectors do not take effect on changes to source and target nodes after an edge is added, for performance reasons.  Use a class or data selector on edges instead, updating the class or data of an edge when your app detects a change in source or target nodes.');\n    }\n  }\n  return true; // success\n};\n\n/**\n * Get the selector represented as a string.  This value uses default formatting,\n * so things like spacing may differ from the input text passed to the constructor.\n * @returns {string} The selector string\n */\nvar toString = function toString() {\n  if (this.toStringCache != null) {\n    return this.toStringCache;\n  }\n  var clean = function clean(obj) {\n    if (obj == null) {\n      return '';\n    } else {\n      return obj;\n    }\n  };\n  var cleanVal = function cleanVal(val) {\n    if (string(val)) {\n      return '\"' + val + '\"';\n    } else {\n      return clean(val);\n    }\n  };\n  var space = function space(val) {\n    return ' ' + val + ' ';\n  };\n  var checkToString = function checkToString(check, subject) {\n    var type = check.type,\n      value = check.value;\n    switch (type) {\n      case Type.GROUP:\n        {\n          var group = clean(value);\n          return group.substring(0, group.length - 1);\n        }\n      case Type.DATA_COMPARE:\n        {\n          var field = check.field,\n            operator = check.operator;\n          return '[' + field + space(clean(operator)) + cleanVal(value) + ']';\n        }\n      case Type.DATA_BOOL:\n        {\n          var _operator = check.operator,\n            _field = check.field;\n          return '[' + clean(_operator) + _field + ']';\n        }\n      case Type.DATA_EXIST:\n        {\n          var _field2 = check.field;\n          return '[' + _field2 + ']';\n        }\n      case Type.META_COMPARE:\n        {\n          var _operator2 = check.operator,\n            _field3 = check.field;\n          return '[[' + _field3 + space(clean(_operator2)) + cleanVal(value) + ']]';\n        }\n      case Type.STATE:\n        {\n          return value;\n        }\n      case Type.ID:\n        {\n          return '#' + value;\n        }\n      case Type.CLASS:\n        {\n          return '.' + value;\n        }\n      case Type.PARENT:\n      case Type.CHILD:\n        {\n          return queryToString(check.parent, subject) + space('>') + queryToString(check.child, subject);\n        }\n      case Type.ANCESTOR:\n      case Type.DESCENDANT:\n        {\n          return queryToString(check.ancestor, subject) + ' ' + queryToString(check.descendant, subject);\n        }\n      case Type.COMPOUND_SPLIT:\n        {\n          var lhs = queryToString(check.left, subject);\n          var sub = queryToString(check.subject, subject);\n          var rhs = queryToString(check.right, subject);\n          return lhs + (lhs.length > 0 ? ' ' : '') + sub + rhs;\n        }\n      case Type.TRUE:\n        {\n          return '';\n        }\n    }\n  };\n  var queryToString = function queryToString(query, subject) {\n    return query.checks.reduce(function (str, chk, i) {\n      return str + (subject === query && i === 0 ? '$' : '') + checkToString(chk, subject);\n    }, '');\n  };\n  var str = '';\n  for (var i = 0; i < this.length; i++) {\n    var query = this[i];\n    str += queryToString(query, query.subject);\n    if (this.length > 1 && i < this.length - 1) {\n      str += ', ';\n    }\n  }\n  this.toStringCache = str;\n  return str;\n};\nvar parse$1 = {\n  parse: parse,\n  toString: toString\n};\n\nvar valCmp = function valCmp(fieldVal, operator, value) {\n  var matches;\n  var isFieldStr = string(fieldVal);\n  var isFieldNum = number$1(fieldVal);\n  var isValStr = string(value);\n  var fieldStr, valStr;\n  var caseInsensitive = false;\n  var notExpr = false;\n  var isIneqCmp = false;\n  if (operator.indexOf('!') >= 0) {\n    operator = operator.replace('!', '');\n    notExpr = true;\n  }\n  if (operator.indexOf('@') >= 0) {\n    operator = operator.replace('@', '');\n    caseInsensitive = true;\n  }\n  if (isFieldStr || isValStr || caseInsensitive) {\n    fieldStr = !isFieldStr && !isFieldNum ? '' : '' + fieldVal;\n    valStr = '' + value;\n  }\n\n  // if we're doing a case insensitive comparison, then we're using a STRING comparison\n  // even if we're comparing numbers\n  if (caseInsensitive) {\n    fieldVal = fieldStr = fieldStr.toLowerCase();\n    value = valStr = valStr.toLowerCase();\n  }\n  switch (operator) {\n    case '*=':\n      matches = fieldStr.indexOf(valStr) >= 0;\n      break;\n    case '$=':\n      matches = fieldStr.indexOf(valStr, fieldStr.length - valStr.length) >= 0;\n      break;\n    case '^=':\n      matches = fieldStr.indexOf(valStr) === 0;\n      break;\n    case '=':\n      matches = fieldVal === value;\n      break;\n    case '>':\n      isIneqCmp = true;\n      matches = fieldVal > value;\n      break;\n    case '>=':\n      isIneqCmp = true;\n      matches = fieldVal >= value;\n      break;\n    case '<':\n      isIneqCmp = true;\n      matches = fieldVal < value;\n      break;\n    case '<=':\n      isIneqCmp = true;\n      matches = fieldVal <= value;\n      break;\n    default:\n      matches = false;\n      break;\n  }\n\n  // apply the not op, but null vals for inequalities should always stay non-matching\n  if (notExpr && (fieldVal != null || !isIneqCmp)) {\n    matches = !matches;\n  }\n  return matches;\n};\nvar boolCmp = function boolCmp(fieldVal, operator) {\n  switch (operator) {\n    case '?':\n      return fieldVal ? true : false;\n    case '!':\n      return fieldVal ? false : true;\n    case '^':\n      return fieldVal === undefined;\n  }\n};\nvar existCmp = function existCmp(fieldVal) {\n  return fieldVal !== undefined;\n};\nvar data$1 = function data(ele, field) {\n  return ele.data(field);\n};\nvar meta = function meta(ele, field) {\n  return ele[field]();\n};\n\n/** A lookup of `match(check, ele)` functions by `Type` int */\nvar match = [];\n\n/**\n * Returns whether the query matches for the element\n * @param query The `{ type, value, ... }` query object\n * @param ele The element to compare against\n*/\nvar matches$1 = function matches(query, ele) {\n  return query.checks.every(function (chk) {\n    return match[chk.type](chk, ele);\n  });\n};\nmatch[Type.GROUP] = function (check, ele) {\n  var group = check.value;\n  return group === '*' || group === ele.group();\n};\nmatch[Type.STATE] = function (check, ele) {\n  var stateSelector = check.value;\n  return stateSelectorMatches(stateSelector, ele);\n};\nmatch[Type.ID] = function (check, ele) {\n  var id = check.value;\n  return ele.id() === id;\n};\nmatch[Type.CLASS] = function (check, ele) {\n  var cls = check.value;\n  return ele.hasClass(cls);\n};\nmatch[Type.META_COMPARE] = function (check, ele) {\n  var field = check.field,\n    operator = check.operator,\n    value = check.value;\n  return valCmp(meta(ele, field), operator, value);\n};\nmatch[Type.DATA_COMPARE] = function (check, ele) {\n  var field = check.field,\n    operator = check.operator,\n    value = check.value;\n  return valCmp(data$1(ele, field), operator, value);\n};\nmatch[Type.DATA_BOOL] = function (check, ele) {\n  var field = check.field,\n    operator = check.operator;\n  return boolCmp(data$1(ele, field), operator);\n};\nmatch[Type.DATA_EXIST] = function (check, ele) {\n  var field = check.field;\n    check.operator;\n  return existCmp(data$1(ele, field));\n};\nmatch[Type.UNDIRECTED_EDGE] = function (check, ele) {\n  var qA = check.nodes[0];\n  var qB = check.nodes[1];\n  var src = ele.source();\n  var tgt = ele.target();\n  return matches$1(qA, src) && matches$1(qB, tgt) || matches$1(qB, src) && matches$1(qA, tgt);\n};\nmatch[Type.NODE_NEIGHBOR] = function (check, ele) {\n  return matches$1(check.node, ele) && ele.neighborhood().some(function (n) {\n    return n.isNode() && matches$1(check.neighbor, n);\n  });\n};\nmatch[Type.DIRECTED_EDGE] = function (check, ele) {\n  return matches$1(check.source, ele.source()) && matches$1(check.target, ele.target());\n};\nmatch[Type.NODE_SOURCE] = function (check, ele) {\n  return matches$1(check.source, ele) && ele.outgoers().some(function (n) {\n    return n.isNode() && matches$1(check.target, n);\n  });\n};\nmatch[Type.NODE_TARGET] = function (check, ele) {\n  return matches$1(check.target, ele) && ele.incomers().some(function (n) {\n    return n.isNode() && matches$1(check.source, n);\n  });\n};\nmatch[Type.CHILD] = function (check, ele) {\n  return matches$1(check.child, ele) && matches$1(check.parent, ele.parent());\n};\nmatch[Type.PARENT] = function (check, ele) {\n  return matches$1(check.parent, ele) && ele.children().some(function (c) {\n    return matches$1(check.child, c);\n  });\n};\nmatch[Type.DESCENDANT] = function (check, ele) {\n  return matches$1(check.descendant, ele) && ele.ancestors().some(function (a) {\n    return matches$1(check.ancestor, a);\n  });\n};\nmatch[Type.ANCESTOR] = function (check, ele) {\n  return matches$1(check.ancestor, ele) && ele.descendants().some(function (d) {\n    return matches$1(check.descendant, d);\n  });\n};\nmatch[Type.COMPOUND_SPLIT] = function (check, ele) {\n  return matches$1(check.subject, ele) && matches$1(check.left, ele) && matches$1(check.right, ele);\n};\nmatch[Type.TRUE] = function () {\n  return true;\n};\nmatch[Type.COLLECTION] = function (check, ele) {\n  var collection = check.value;\n  return collection.has(ele);\n};\nmatch[Type.FILTER] = function (check, ele) {\n  var filter = check.value;\n  return filter(ele);\n};\n\n// filter an existing collection\nvar filter = function filter(collection) {\n  var self = this;\n\n  // for 1 id #foo queries, just get the element\n  if (self.length === 1 && self[0].checks.length === 1 && self[0].checks[0].type === Type.ID) {\n    return collection.getElementById(self[0].checks[0].value).collection();\n  }\n  var selectorFunction = function selectorFunction(element) {\n    for (var j = 0; j < self.length; j++) {\n      var query = self[j];\n      if (matches$1(query, element)) {\n        return true;\n      }\n    }\n    return false;\n  };\n  if (self.text() == null) {\n    selectorFunction = function selectorFunction() {\n      return true;\n    };\n  }\n  return collection.filter(selectorFunction);\n}; // filter\n\n// does selector match a single element?\nvar matches = function matches(ele) {\n  var self = this;\n  for (var j = 0; j < self.length; j++) {\n    var query = self[j];\n    if (matches$1(query, ele)) {\n      return true;\n    }\n  }\n  return false;\n}; // matches\n\nvar matching = {\n  matches: matches,\n  filter: filter\n};\n\nvar Selector = function Selector(selector) {\n  this.inputText = selector;\n  this.currentSubject = null;\n  this.compoundCount = 0;\n  this.edgeCount = 0;\n  this.length = 0;\n  if (selector == null || string(selector) && selector.match(/^\\s*$/)) ; else if (elementOrCollection(selector)) {\n    this.addQuery({\n      checks: [{\n        type: Type.COLLECTION,\n        value: selector.collection()\n      }]\n    });\n  } else if (fn$6(selector)) {\n    this.addQuery({\n      checks: [{\n        type: Type.FILTER,\n        value: selector\n      }]\n    });\n  } else if (string(selector)) {\n    if (!this.parse(selector)) {\n      this.invalid = true;\n    }\n  } else {\n    error('A selector must be created from a string; found ');\n  }\n};\nvar selfn = Selector.prototype;\n[parse$1, matching].forEach(function (p) {\n  return extend(selfn, p);\n});\nselfn.text = function () {\n  return this.inputText;\n};\nselfn.size = function () {\n  return this.length;\n};\nselfn.eq = function (i) {\n  return this[i];\n};\nselfn.sameText = function (otherSel) {\n  return !this.invalid && !otherSel.invalid && this.text() === otherSel.text();\n};\nselfn.addQuery = function (q) {\n  this[this.length++] = q;\n};\nselfn.selector = selfn.toString;\n\nvar elesfn$g = {\n  allAre: function allAre(selector) {\n    var selObj = new Selector(selector);\n    return this.every(function (ele) {\n      return selObj.matches(ele);\n    });\n  },\n  is: function is(selector) {\n    var selObj = new Selector(selector);\n    return this.some(function (ele) {\n      return selObj.matches(ele);\n    });\n  },\n  some: function some(fn, thisArg) {\n    for (var i = 0; i < this.length; i++) {\n      var ret = !thisArg ? fn(this[i], i, this) : fn.apply(thisArg, [this[i], i, this]);\n      if (ret) {\n        return true;\n      }\n    }\n    return false;\n  },\n  every: function every(fn, thisArg) {\n    for (var i = 0; i < this.length; i++) {\n      var ret = !thisArg ? fn(this[i], i, this) : fn.apply(thisArg, [this[i], i, this]);\n      if (!ret) {\n        return false;\n      }\n    }\n    return true;\n  },\n  same: function same(collection) {\n    // cheap collection ref check\n    if (this === collection) {\n      return true;\n    }\n    collection = this.cy().collection(collection);\n    var thisLength = this.length;\n    var collectionLength = collection.length;\n\n    // cheap length check\n    if (thisLength !== collectionLength) {\n      return false;\n    }\n\n    // cheap element ref check\n    if (thisLength === 1) {\n      return this[0] === collection[0];\n    }\n    return this.every(function (ele) {\n      return collection.hasElementWithId(ele.id());\n    });\n  },\n  anySame: function anySame(collection) {\n    collection = this.cy().collection(collection);\n    return this.some(function (ele) {\n      return collection.hasElementWithId(ele.id());\n    });\n  },\n  allAreNeighbors: function allAreNeighbors(collection) {\n    collection = this.cy().collection(collection);\n    var nhood = this.neighborhood();\n    return collection.every(function (ele) {\n      return nhood.hasElementWithId(ele.id());\n    });\n  },\n  contains: function contains(collection) {\n    collection = this.cy().collection(collection);\n    var self = this;\n    return collection.every(function (ele) {\n      return self.hasElementWithId(ele.id());\n    });\n  }\n};\nelesfn$g.allAreNeighbours = elesfn$g.allAreNeighbors;\nelesfn$g.has = elesfn$g.contains;\nelesfn$g.equal = elesfn$g.equals = elesfn$g.same;\n\nvar cache = function cache(fn, name) {\n  return function traversalCache(arg1, arg2, arg3, arg4) {\n    var selectorOrEles = arg1;\n    var eles = this;\n    var key;\n    if (selectorOrEles == null) {\n      key = '';\n    } else if (elementOrCollection(selectorOrEles) && selectorOrEles.length === 1) {\n      key = selectorOrEles.id();\n    }\n    if (eles.length === 1 && key) {\n      var _p = eles[0]._private;\n      var tch = _p.traversalCache = _p.traversalCache || {};\n      var ch = tch[name] = tch[name] || [];\n      var hash = hashString(key);\n      var cacheHit = ch[hash];\n      if (cacheHit) {\n        return cacheHit;\n      } else {\n        return ch[hash] = fn.call(eles, arg1, arg2, arg3, arg4);\n      }\n    } else {\n      return fn.call(eles, arg1, arg2, arg3, arg4);\n    }\n  };\n};\n\nvar elesfn$f = {\n  parent: function parent(selector) {\n    var parents = [];\n\n    // optimisation for single ele call\n    if (this.length === 1) {\n      var parent = this[0]._private.parent;\n      if (parent) {\n        return parent;\n      }\n    }\n    for (var i = 0; i < this.length; i++) {\n      var ele = this[i];\n      var _parent = ele._private.parent;\n      if (_parent) {\n        parents.push(_parent);\n      }\n    }\n    return this.spawn(parents, true).filter(selector);\n  },\n  parents: function parents(selector) {\n    var parents = [];\n    var eles = this.parent();\n    while (eles.nonempty()) {\n      for (var i = 0; i < eles.length; i++) {\n        var ele = eles[i];\n        parents.push(ele);\n      }\n      eles = eles.parent();\n    }\n    return this.spawn(parents, true).filter(selector);\n  },\n  commonAncestors: function commonAncestors(selector) {\n    var ancestors;\n    for (var i = 0; i < this.length; i++) {\n      var ele = this[i];\n      var parents = ele.parents();\n      ancestors = ancestors || parents;\n      ancestors = ancestors.intersect(parents); // current list must be common with current ele parents set\n    }\n\n    return ancestors.filter(selector);\n  },\n  orphans: function orphans(selector) {\n    return this.stdFilter(function (ele) {\n      return ele.isOrphan();\n    }).filter(selector);\n  },\n  nonorphans: function nonorphans(selector) {\n    return this.stdFilter(function (ele) {\n      return ele.isChild();\n    }).filter(selector);\n  },\n  children: cache(function (selector) {\n    var children = [];\n    for (var i = 0; i < this.length; i++) {\n      var ele = this[i];\n      var eleChildren = ele._private.children;\n      for (var j = 0; j < eleChildren.length; j++) {\n        children.push(eleChildren[j]);\n      }\n    }\n    return this.spawn(children, true).filter(selector);\n  }, 'children'),\n  siblings: function siblings(selector) {\n    return this.parent().children().not(this).filter(selector);\n  },\n  isParent: function isParent() {\n    var ele = this[0];\n    if (ele) {\n      return ele.isNode() && ele._private.children.length !== 0;\n    }\n  },\n  isChildless: function isChildless() {\n    var ele = this[0];\n    if (ele) {\n      return ele.isNode() && ele._private.children.length === 0;\n    }\n  },\n  isChild: function isChild() {\n    var ele = this[0];\n    if (ele) {\n      return ele.isNode() && ele._private.parent != null;\n    }\n  },\n  isOrphan: function isOrphan() {\n    var ele = this[0];\n    if (ele) {\n      return ele.isNode() && ele._private.parent == null;\n    }\n  },\n  descendants: function descendants(selector) {\n    var elements = [];\n    function add(eles) {\n      for (var i = 0; i < eles.length; i++) {\n        var ele = eles[i];\n        elements.push(ele);\n        if (ele.children().nonempty()) {\n          add(ele.children());\n        }\n      }\n    }\n    add(this.children());\n    return this.spawn(elements, true).filter(selector);\n  }\n};\nfunction forEachCompound(eles, fn, includeSelf, recursiveStep) {\n  var q = [];\n  var did = new Set$1();\n  var cy = eles.cy();\n  var hasCompounds = cy.hasCompoundNodes();\n  for (var i = 0; i < eles.length; i++) {\n    var ele = eles[i];\n    if (includeSelf) {\n      q.push(ele);\n    } else if (hasCompounds) {\n      recursiveStep(q, did, ele);\n    }\n  }\n  while (q.length > 0) {\n    var _ele = q.shift();\n    fn(_ele);\n    did.add(_ele.id());\n    if (hasCompounds) {\n      recursiveStep(q, did, _ele);\n    }\n  }\n  return eles;\n}\nfunction addChildren(q, did, ele) {\n  if (ele.isParent()) {\n    var children = ele._private.children;\n    for (var i = 0; i < children.length; i++) {\n      var child = children[i];\n      if (!did.has(child.id())) {\n        q.push(child);\n      }\n    }\n  }\n}\n\n// very efficient version of eles.add( eles.descendants() ).forEach()\n// for internal use\nelesfn$f.forEachDown = function (fn) {\n  var includeSelf = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  return forEachCompound(this, fn, includeSelf, addChildren);\n};\nfunction addParent(q, did, ele) {\n  if (ele.isChild()) {\n    var parent = ele._private.parent;\n    if (!did.has(parent.id())) {\n      q.push(parent);\n    }\n  }\n}\nelesfn$f.forEachUp = function (fn) {\n  var includeSelf = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  return forEachCompound(this, fn, includeSelf, addParent);\n};\nfunction addParentAndChildren(q, did, ele) {\n  addParent(q, did, ele);\n  addChildren(q, did, ele);\n}\nelesfn$f.forEachUpAndDown = function (fn) {\n  var includeSelf = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  return forEachCompound(this, fn, includeSelf, addParentAndChildren);\n};\n\n// aliases\nelesfn$f.ancestors = elesfn$f.parents;\n\nvar fn$5, elesfn$e;\nfn$5 = elesfn$e = {\n  data: define.data({\n    field: 'data',\n    bindingEvent: 'data',\n    allowBinding: true,\n    allowSetting: true,\n    settingEvent: 'data',\n    settingTriggersEvent: true,\n    triggerFnName: 'trigger',\n    allowGetting: true,\n    immutableKeys: {\n      'id': true,\n      'source': true,\n      'target': true,\n      'parent': true\n    },\n    updateStyle: true\n  }),\n  removeData: define.removeData({\n    field: 'data',\n    event: 'data',\n    triggerFnName: 'trigger',\n    triggerEvent: true,\n    immutableKeys: {\n      'id': true,\n      'source': true,\n      'target': true,\n      'parent': true\n    },\n    updateStyle: true\n  }),\n  scratch: define.data({\n    field: 'scratch',\n    bindingEvent: 'scratch',\n    allowBinding: true,\n    allowSetting: true,\n    settingEvent: 'scratch',\n    settingTriggersEvent: true,\n    triggerFnName: 'trigger',\n    allowGetting: true,\n    updateStyle: true\n  }),\n  removeScratch: define.removeData({\n    field: 'scratch',\n    event: 'scratch',\n    triggerFnName: 'trigger',\n    triggerEvent: true,\n    updateStyle: true\n  }),\n  rscratch: define.data({\n    field: 'rscratch',\n    allowBinding: false,\n    allowSetting: true,\n    settingTriggersEvent: false,\n    allowGetting: true\n  }),\n  removeRscratch: define.removeData({\n    field: 'rscratch',\n    triggerEvent: false\n  }),\n  id: function id() {\n    var ele = this[0];\n    if (ele) {\n      return ele._private.data.id;\n    }\n  }\n};\n\n// aliases\nfn$5.attr = fn$5.data;\nfn$5.removeAttr = fn$5.removeData;\nvar data = elesfn$e;\n\nvar elesfn$d = {};\nfunction defineDegreeFunction(callback) {\n  return function (includeLoops) {\n    var self = this;\n    if (includeLoops === undefined) {\n      includeLoops = true;\n    }\n    if (self.length === 0) {\n      return;\n    }\n    if (self.isNode() && !self.removed()) {\n      var degree = 0;\n      var node = self[0];\n      var connectedEdges = node._private.edges;\n      for (var i = 0; i < connectedEdges.length; i++) {\n        var edge = connectedEdges[i];\n        if (!includeLoops && edge.isLoop()) {\n          continue;\n        }\n        degree += callback(node, edge);\n      }\n      return degree;\n    } else {\n      return;\n    }\n  };\n}\nextend(elesfn$d, {\n  degree: defineDegreeFunction(function (node, edge) {\n    if (edge.source().same(edge.target())) {\n      return 2;\n    } else {\n      return 1;\n    }\n  }),\n  indegree: defineDegreeFunction(function (node, edge) {\n    if (edge.target().same(node)) {\n      return 1;\n    } else {\n      return 0;\n    }\n  }),\n  outdegree: defineDegreeFunction(function (node, edge) {\n    if (edge.source().same(node)) {\n      return 1;\n    } else {\n      return 0;\n    }\n  })\n});\nfunction defineDegreeBoundsFunction(degreeFn, callback) {\n  return function (includeLoops) {\n    var ret;\n    var nodes = this.nodes();\n    for (var i = 0; i < nodes.length; i++) {\n      var ele = nodes[i];\n      var degree = ele[degreeFn](includeLoops);\n      if (degree !== undefined && (ret === undefined || callback(degree, ret))) {\n        ret = degree;\n      }\n    }\n    return ret;\n  };\n}\nextend(elesfn$d, {\n  minDegree: defineDegreeBoundsFunction('degree', function (degree, min) {\n    return degree < min;\n  }),\n  maxDegree: defineDegreeBoundsFunction('degree', function (degree, max) {\n    return degree > max;\n  }),\n  minIndegree: defineDegreeBoundsFunction('indegree', function (degree, min) {\n    return degree < min;\n  }),\n  maxIndegree: defineDegreeBoundsFunction('indegree', function (degree, max) {\n    return degree > max;\n  }),\n  minOutdegree: defineDegreeBoundsFunction('outdegree', function (degree, min) {\n    return degree < min;\n  }),\n  maxOutdegree: defineDegreeBoundsFunction('outdegree', function (degree, max) {\n    return degree > max;\n  })\n});\nextend(elesfn$d, {\n  totalDegree: function totalDegree(includeLoops) {\n    var total = 0;\n    var nodes = this.nodes();\n    for (var i = 0; i < nodes.length; i++) {\n      total += nodes[i].degree(includeLoops);\n    }\n    return total;\n  }\n});\n\nvar fn$4, elesfn$c;\nvar beforePositionSet = function beforePositionSet(eles, newPos, silent) {\n  for (var i = 0; i < eles.length; i++) {\n    var ele = eles[i];\n    if (!ele.locked()) {\n      var oldPos = ele._private.position;\n      var delta = {\n        x: newPos.x != null ? newPos.x - oldPos.x : 0,\n        y: newPos.y != null ? newPos.y - oldPos.y : 0\n      };\n      if (ele.isParent() && !(delta.x === 0 && delta.y === 0)) {\n        ele.children().shift(delta, silent);\n      }\n      ele.dirtyBoundingBoxCache();\n    }\n  }\n};\nvar positionDef = {\n  field: 'position',\n  bindingEvent: 'position',\n  allowBinding: true,\n  allowSetting: true,\n  settingEvent: 'position',\n  settingTriggersEvent: true,\n  triggerFnName: 'emitAndNotify',\n  allowGetting: true,\n  validKeys: ['x', 'y'],\n  beforeGet: function beforeGet(ele) {\n    ele.updateCompoundBounds();\n  },\n  beforeSet: function beforeSet(eles, newPos) {\n    beforePositionSet(eles, newPos, false);\n  },\n  onSet: function onSet(eles) {\n    eles.dirtyCompoundBoundsCache();\n  },\n  canSet: function canSet(ele) {\n    return !ele.locked();\n  }\n};\nfn$4 = elesfn$c = {\n  position: define.data(positionDef),\n  // position but no notification to renderer\n  silentPosition: define.data(extend({}, positionDef, {\n    allowBinding: false,\n    allowSetting: true,\n    settingTriggersEvent: false,\n    allowGetting: false,\n    beforeSet: function beforeSet(eles, newPos) {\n      beforePositionSet(eles, newPos, true);\n    },\n    onSet: function onSet(eles) {\n      eles.dirtyCompoundBoundsCache();\n    }\n  })),\n  positions: function positions(pos, silent) {\n    if (plainObject(pos)) {\n      if (silent) {\n        this.silentPosition(pos);\n      } else {\n        this.position(pos);\n      }\n    } else if (fn$6(pos)) {\n      var _fn = pos;\n      var cy = this.cy();\n      cy.startBatch();\n      for (var i = 0; i < this.length; i++) {\n        var ele = this[i];\n        var _pos = void 0;\n        if (_pos = _fn(ele, i)) {\n          if (silent) {\n            ele.silentPosition(_pos);\n          } else {\n            ele.position(_pos);\n          }\n        }\n      }\n      cy.endBatch();\n    }\n    return this; // chaining\n  },\n\n  silentPositions: function silentPositions(pos) {\n    return this.positions(pos, true);\n  },\n  shift: function shift(dim, val, silent) {\n    var delta;\n    if (plainObject(dim)) {\n      delta = {\n        x: number$1(dim.x) ? dim.x : 0,\n        y: number$1(dim.y) ? dim.y : 0\n      };\n      silent = val;\n    } else if (string(dim) && number$1(val)) {\n      delta = {\n        x: 0,\n        y: 0\n      };\n      delta[dim] = val;\n    }\n    if (delta != null) {\n      var cy = this.cy();\n      cy.startBatch();\n      for (var i = 0; i < this.length; i++) {\n        var ele = this[i];\n\n        // exclude any node that is a descendant of the calling collection\n        if (cy.hasCompoundNodes() && ele.isChild() && ele.ancestors().anySame(this)) {\n          continue;\n        }\n        var pos = ele.position();\n        var newPos = {\n          x: pos.x + delta.x,\n          y: pos.y + delta.y\n        };\n        if (silent) {\n          ele.silentPosition(newPos);\n        } else {\n          ele.position(newPos);\n        }\n      }\n      cy.endBatch();\n    }\n    return this;\n  },\n  silentShift: function silentShift(dim, val) {\n    if (plainObject(dim)) {\n      this.shift(dim, true);\n    } else if (string(dim) && number$1(val)) {\n      this.shift(dim, val, true);\n    }\n    return this;\n  },\n  // get/set the rendered (i.e. on screen) positon of the element\n  renderedPosition: function renderedPosition(dim, val) {\n    var ele = this[0];\n    var cy = this.cy();\n    var zoom = cy.zoom();\n    var pan = cy.pan();\n    var rpos = plainObject(dim) ? dim : undefined;\n    var setting = rpos !== undefined || val !== undefined && string(dim);\n    if (ele && ele.isNode()) {\n      // must have an element and must be a node to return position\n      if (setting) {\n        for (var i = 0; i < this.length; i++) {\n          var _ele = this[i];\n          if (val !== undefined) {\n            // set one dimension\n            _ele.position(dim, (val - pan[dim]) / zoom);\n          } else if (rpos !== undefined) {\n            // set whole position\n            _ele.position(renderedToModelPosition(rpos, zoom, pan));\n          }\n        }\n      } else {\n        // getting\n        var pos = ele.position();\n        rpos = modelToRenderedPosition(pos, zoom, pan);\n        if (dim === undefined) {\n          // then return the whole rendered position\n          return rpos;\n        } else {\n          // then return the specified dimension\n          return rpos[dim];\n        }\n      }\n    } else if (!setting) {\n      return undefined; // for empty collection case\n    }\n\n    return this; // chaining\n  },\n\n  // get/set the position relative to the parent\n  relativePosition: function relativePosition(dim, val) {\n    var ele = this[0];\n    var cy = this.cy();\n    var ppos = plainObject(dim) ? dim : undefined;\n    var setting = ppos !== undefined || val !== undefined && string(dim);\n    var hasCompoundNodes = cy.hasCompoundNodes();\n    if (ele && ele.isNode()) {\n      // must have an element and must be a node to return position\n      if (setting) {\n        for (var i = 0; i < this.length; i++) {\n          var _ele2 = this[i];\n          var parent = hasCompoundNodes ? _ele2.parent() : null;\n          var hasParent = parent && parent.length > 0;\n          var relativeToParent = hasParent;\n          if (hasParent) {\n            parent = parent[0];\n          }\n          var origin = relativeToParent ? parent.position() : {\n            x: 0,\n            y: 0\n          };\n          if (val !== undefined) {\n            // set one dimension\n            _ele2.position(dim, val + origin[dim]);\n          } else if (ppos !== undefined) {\n            // set whole position\n            _ele2.position({\n              x: ppos.x + origin.x,\n              y: ppos.y + origin.y\n            });\n          }\n        }\n      } else {\n        // getting\n        var pos = ele.position();\n        var _parent = hasCompoundNodes ? ele.parent() : null;\n        var _hasParent = _parent && _parent.length > 0;\n        var _relativeToParent = _hasParent;\n        if (_hasParent) {\n          _parent = _parent[0];\n        }\n        var _origin = _relativeToParent ? _parent.position() : {\n          x: 0,\n          y: 0\n        };\n        ppos = {\n          x: pos.x - _origin.x,\n          y: pos.y - _origin.y\n        };\n        if (dim === undefined) {\n          // then return the whole rendered position\n          return ppos;\n        } else {\n          // then return the specified dimension\n          return ppos[dim];\n        }\n      }\n    } else if (!setting) {\n      return undefined; // for empty collection case\n    }\n\n    return this; // chaining\n  }\n};\n\n// aliases\nfn$4.modelPosition = fn$4.point = fn$4.position;\nfn$4.modelPositions = fn$4.points = fn$4.positions;\nfn$4.renderedPoint = fn$4.renderedPosition;\nfn$4.relativePoint = fn$4.relativePosition;\nvar position = elesfn$c;\n\nvar fn$3, elesfn$b;\nfn$3 = elesfn$b = {};\nelesfn$b.renderedBoundingBox = function (options) {\n  var bb = this.boundingBox(options);\n  var cy = this.cy();\n  var zoom = cy.zoom();\n  var pan = cy.pan();\n  var x1 = bb.x1 * zoom + pan.x;\n  var x2 = bb.x2 * zoom + pan.x;\n  var y1 = bb.y1 * zoom + pan.y;\n  var y2 = bb.y2 * zoom + pan.y;\n  return {\n    x1: x1,\n    x2: x2,\n    y1: y1,\n    y2: y2,\n    w: x2 - x1,\n    h: y2 - y1\n  };\n};\nelesfn$b.dirtyCompoundBoundsCache = function () {\n  var silent = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n  var cy = this.cy();\n  if (!cy.styleEnabled() || !cy.hasCompoundNodes()) {\n    return this;\n  }\n  this.forEachUp(function (ele) {\n    if (ele.isParent()) {\n      var _p = ele._private;\n      _p.compoundBoundsClean = false;\n      _p.bbCache = null;\n      if (!silent) {\n        ele.emitAndNotify('bounds');\n      }\n    }\n  });\n  return this;\n};\nelesfn$b.updateCompoundBounds = function () {\n  var force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n  var cy = this.cy();\n\n  // not possible to do on non-compound graphs or with the style disabled\n  if (!cy.styleEnabled() || !cy.hasCompoundNodes()) {\n    return this;\n  }\n\n  // save cycles when batching -- but bounds will be stale (or not exist yet)\n  if (!force && cy.batching()) {\n    return this;\n  }\n  function update(parent) {\n    if (!parent.isParent()) {\n      return;\n    }\n    var _p = parent._private;\n    var children = parent.children();\n    var includeLabels = parent.pstyle('compound-sizing-wrt-labels').value === 'include';\n    var min = {\n      width: {\n        val: parent.pstyle('min-width').pfValue,\n        left: parent.pstyle('min-width-bias-left'),\n        right: parent.pstyle('min-width-bias-right')\n      },\n      height: {\n        val: parent.pstyle('min-height').pfValue,\n        top: parent.pstyle('min-height-bias-top'),\n        bottom: parent.pstyle('min-height-bias-bottom')\n      }\n    };\n    var bb = children.boundingBox({\n      includeLabels: includeLabels,\n      includeOverlays: false,\n      // updating the compound bounds happens outside of the regular\n      // cache cycle (i.e. before fired events)\n      useCache: false\n    });\n    var pos = _p.position;\n\n    // if children take up zero area then keep position and fall back on stylesheet w/h\n    if (bb.w === 0 || bb.h === 0) {\n      bb = {\n        w: parent.pstyle('width').pfValue,\n        h: parent.pstyle('height').pfValue\n      };\n      bb.x1 = pos.x - bb.w / 2;\n      bb.x2 = pos.x + bb.w / 2;\n      bb.y1 = pos.y - bb.h / 2;\n      bb.y2 = pos.y + bb.h / 2;\n    }\n    function computeBiasValues(propDiff, propBias, propBiasComplement) {\n      var biasDiff = 0;\n      var biasComplementDiff = 0;\n      var biasTotal = propBias + propBiasComplement;\n      if (propDiff > 0 && biasTotal > 0) {\n        biasDiff = propBias / biasTotal * propDiff;\n        biasComplementDiff = propBiasComplement / biasTotal * propDiff;\n      }\n      return {\n        biasDiff: biasDiff,\n        biasComplementDiff: biasComplementDiff\n      };\n    }\n    function computePaddingValues(width, height, paddingObject, relativeTo) {\n      // Assuming percentage is number from 0 to 1\n      if (paddingObject.units === '%') {\n        switch (relativeTo) {\n          case 'width':\n            return width > 0 ? paddingObject.pfValue * width : 0;\n          case 'height':\n            return height > 0 ? paddingObject.pfValue * height : 0;\n          case 'average':\n            return width > 0 && height > 0 ? paddingObject.pfValue * (width + height) / 2 : 0;\n          case 'min':\n            return width > 0 && height > 0 ? width > height ? paddingObject.pfValue * height : paddingObject.pfValue * width : 0;\n          case 'max':\n            return width > 0 && height > 0 ? width > height ? paddingObject.pfValue * width : paddingObject.pfValue * height : 0;\n          default:\n            return 0;\n        }\n      } else if (paddingObject.units === 'px') {\n        return paddingObject.pfValue;\n      } else {\n        return 0;\n      }\n    }\n    var leftVal = min.width.left.value;\n    if (min.width.left.units === 'px' && min.width.val > 0) {\n      leftVal = leftVal * 100 / min.width.val;\n    }\n    var rightVal = min.width.right.value;\n    if (min.width.right.units === 'px' && min.width.val > 0) {\n      rightVal = rightVal * 100 / min.width.val;\n    }\n    var topVal = min.height.top.value;\n    if (min.height.top.units === 'px' && min.height.val > 0) {\n      topVal = topVal * 100 / min.height.val;\n    }\n    var bottomVal = min.height.bottom.value;\n    if (min.height.bottom.units === 'px' && min.height.val > 0) {\n      bottomVal = bottomVal * 100 / min.height.val;\n    }\n    var widthBiasDiffs = computeBiasValues(min.width.val - bb.w, leftVal, rightVal);\n    var diffLeft = widthBiasDiffs.biasDiff;\n    var diffRight = widthBiasDiffs.biasComplementDiff;\n    var heightBiasDiffs = computeBiasValues(min.height.val - bb.h, topVal, bottomVal);\n    var diffTop = heightBiasDiffs.biasDiff;\n    var diffBottom = heightBiasDiffs.biasComplementDiff;\n    _p.autoPadding = computePaddingValues(bb.w, bb.h, parent.pstyle('padding'), parent.pstyle('padding-relative-to').value);\n    _p.autoWidth = Math.max(bb.w, min.width.val);\n    pos.x = (-diffLeft + bb.x1 + bb.x2 + diffRight) / 2;\n    _p.autoHeight = Math.max(bb.h, min.height.val);\n    pos.y = (-diffTop + bb.y1 + bb.y2 + diffBottom) / 2;\n  }\n  for (var i = 0; i < this.length; i++) {\n    var ele = this[i];\n    var _p = ele._private;\n    if (!_p.compoundBoundsClean || force) {\n      update(ele);\n      if (!cy.batching()) {\n        _p.compoundBoundsClean = true;\n      }\n    }\n  }\n  return this;\n};\nvar noninf = function noninf(x) {\n  if (x === Infinity || x === -Infinity) {\n    return 0;\n  }\n  return x;\n};\nvar updateBounds = function updateBounds(b, x1, y1, x2, y2) {\n  // don't update with zero area boxes\n  if (x2 - x1 === 0 || y2 - y1 === 0) {\n    return;\n  }\n\n  // don't update with null dim\n  if (x1 == null || y1 == null || x2 == null || y2 == null) {\n    return;\n  }\n  b.x1 = x1 < b.x1 ? x1 : b.x1;\n  b.x2 = x2 > b.x2 ? x2 : b.x2;\n  b.y1 = y1 < b.y1 ? y1 : b.y1;\n  b.y2 = y2 > b.y2 ? y2 : b.y2;\n  b.w = b.x2 - b.x1;\n  b.h = b.y2 - b.y1;\n};\nvar updateBoundsFromBox = function updateBoundsFromBox(b, b2) {\n  if (b2 == null) {\n    return b;\n  }\n  return updateBounds(b, b2.x1, b2.y1, b2.x2, b2.y2);\n};\nvar prefixedProperty = function prefixedProperty(obj, field, prefix) {\n  return getPrefixedProperty(obj, field, prefix);\n};\nvar updateBoundsFromArrow = function updateBoundsFromArrow(bounds, ele, prefix) {\n  if (ele.cy().headless()) {\n    return;\n  }\n  var _p = ele._private;\n  var rstyle = _p.rstyle;\n  var halfArW = rstyle.arrowWidth / 2;\n  var arrowType = ele.pstyle(prefix + '-arrow-shape').value;\n  var x;\n  var y;\n  if (arrowType !== 'none') {\n    if (prefix === 'source') {\n      x = rstyle.srcX;\n      y = rstyle.srcY;\n    } else if (prefix === 'target') {\n      x = rstyle.tgtX;\n      y = rstyle.tgtY;\n    } else {\n      x = rstyle.midX;\n      y = rstyle.midY;\n    }\n\n    // always store the individual arrow bounds\n    var bbs = _p.arrowBounds = _p.arrowBounds || {};\n    var bb = bbs[prefix] = bbs[prefix] || {};\n    bb.x1 = x - halfArW;\n    bb.y1 = y - halfArW;\n    bb.x2 = x + halfArW;\n    bb.y2 = y + halfArW;\n    bb.w = bb.x2 - bb.x1;\n    bb.h = bb.y2 - bb.y1;\n    expandBoundingBox(bb, 1);\n    updateBounds(bounds, bb.x1, bb.y1, bb.x2, bb.y2);\n  }\n};\nvar updateBoundsFromLabel = function updateBoundsFromLabel(bounds, ele, prefix) {\n  if (ele.cy().headless()) {\n    return;\n  }\n  var prefixDash;\n  if (prefix) {\n    prefixDash = prefix + '-';\n  } else {\n    prefixDash = '';\n  }\n  var _p = ele._private;\n  var rstyle = _p.rstyle;\n  var label = ele.pstyle(prefixDash + 'label').strValue;\n  if (label) {\n    var halign = ele.pstyle('text-halign');\n    var valign = ele.pstyle('text-valign');\n    var labelWidth = prefixedProperty(rstyle, 'labelWidth', prefix);\n    var labelHeight = prefixedProperty(rstyle, 'labelHeight', prefix);\n    var labelX = prefixedProperty(rstyle, 'labelX', prefix);\n    var labelY = prefixedProperty(rstyle, 'labelY', prefix);\n    var marginX = ele.pstyle(prefixDash + 'text-margin-x').pfValue;\n    var marginY = ele.pstyle(prefixDash + 'text-margin-y').pfValue;\n    var isEdge = ele.isEdge();\n    var rotation = ele.pstyle(prefixDash + 'text-rotation');\n    var outlineWidth = ele.pstyle('text-outline-width').pfValue;\n    var borderWidth = ele.pstyle('text-border-width').pfValue;\n    var halfBorderWidth = borderWidth / 2;\n    var padding = ele.pstyle('text-background-padding').pfValue;\n    var marginOfError = 2; // expand to work around browser dimension inaccuracies\n\n    var lh = labelHeight;\n    var lw = labelWidth;\n    var lw_2 = lw / 2;\n    var lh_2 = lh / 2;\n    var lx1, lx2, ly1, ly2;\n    if (isEdge) {\n      lx1 = labelX - lw_2;\n      lx2 = labelX + lw_2;\n      ly1 = labelY - lh_2;\n      ly2 = labelY + lh_2;\n    } else {\n      switch (halign.value) {\n        case 'left':\n          lx1 = labelX - lw;\n          lx2 = labelX;\n          break;\n        case 'center':\n          lx1 = labelX - lw_2;\n          lx2 = labelX + lw_2;\n          break;\n        case 'right':\n          lx1 = labelX;\n          lx2 = labelX + lw;\n          break;\n      }\n      switch (valign.value) {\n        case 'top':\n          ly1 = labelY - lh;\n          ly2 = labelY;\n          break;\n        case 'center':\n          ly1 = labelY - lh_2;\n          ly2 = labelY + lh_2;\n          break;\n        case 'bottom':\n          ly1 = labelY;\n          ly2 = labelY + lh;\n          break;\n      }\n    }\n\n    // shift by margin and expand by outline and border\n    var leftPad = marginX - Math.max(outlineWidth, halfBorderWidth) - padding - marginOfError;\n    var rightPad = marginX + Math.max(outlineWidth, halfBorderWidth) + padding + marginOfError;\n    var topPad = marginY - Math.max(outlineWidth, halfBorderWidth) - padding - marginOfError;\n    var botPad = marginY + Math.max(outlineWidth, halfBorderWidth) + padding + marginOfError;\n    lx1 += leftPad;\n    lx2 += rightPad;\n    ly1 += topPad;\n    ly2 += botPad;\n\n    // always store the unrotated label bounds separately\n    var bbPrefix = prefix || 'main';\n    var bbs = _p.labelBounds;\n    var bb = bbs[bbPrefix] = bbs[bbPrefix] || {};\n    bb.x1 = lx1;\n    bb.y1 = ly1;\n    bb.x2 = lx2;\n    bb.y2 = ly2;\n    bb.w = lx2 - lx1;\n    bb.h = ly2 - ly1;\n    bb.leftPad = leftPad;\n    bb.rightPad = rightPad;\n    bb.topPad = topPad;\n    bb.botPad = botPad;\n    var isAutorotate = isEdge && rotation.strValue === 'autorotate';\n    var isPfValue = rotation.pfValue != null && rotation.pfValue !== 0;\n    if (isAutorotate || isPfValue) {\n      var theta = isAutorotate ? prefixedProperty(_p.rstyle, 'labelAngle', prefix) : rotation.pfValue;\n      var cos = Math.cos(theta);\n      var sin = Math.sin(theta);\n\n      // rotation point (default value for center-center)\n      var xo = (lx1 + lx2) / 2;\n      var yo = (ly1 + ly2) / 2;\n      if (!isEdge) {\n        switch (halign.value) {\n          case 'left':\n            xo = lx2;\n            break;\n          case 'right':\n            xo = lx1;\n            break;\n        }\n        switch (valign.value) {\n          case 'top':\n            yo = ly2;\n            break;\n          case 'bottom':\n            yo = ly1;\n            break;\n        }\n      }\n      var rotate = function rotate(x, y) {\n        x = x - xo;\n        y = y - yo;\n        return {\n          x: x * cos - y * sin + xo,\n          y: x * sin + y * cos + yo\n        };\n      };\n      var px1y1 = rotate(lx1, ly1);\n      var px1y2 = rotate(lx1, ly2);\n      var px2y1 = rotate(lx2, ly1);\n      var px2y2 = rotate(lx2, ly2);\n      lx1 = Math.min(px1y1.x, px1y2.x, px2y1.x, px2y2.x);\n      lx2 = Math.max(px1y1.x, px1y2.x, px2y1.x, px2y2.x);\n      ly1 = Math.min(px1y1.y, px1y2.y, px2y1.y, px2y2.y);\n      ly2 = Math.max(px1y1.y, px1y2.y, px2y1.y, px2y2.y);\n    }\n    var bbPrefixRot = bbPrefix + 'Rot';\n    var bbRot = bbs[bbPrefixRot] = bbs[bbPrefixRot] || {};\n    bbRot.x1 = lx1;\n    bbRot.y1 = ly1;\n    bbRot.x2 = lx2;\n    bbRot.y2 = ly2;\n    bbRot.w = lx2 - lx1;\n    bbRot.h = ly2 - ly1;\n    updateBounds(bounds, lx1, ly1, lx2, ly2);\n    updateBounds(_p.labelBounds.all, lx1, ly1, lx2, ly2);\n  }\n  return bounds;\n};\nvar updateBoundsFromOutline = function updateBoundsFromOutline(bounds, ele) {\n  if (ele.cy().headless()) {\n    return;\n  }\n  var outlineOpacity = ele.pstyle('outline-opacity').value;\n  var outlineWidth = ele.pstyle('outline-width').value;\n  if (outlineOpacity > 0 && outlineWidth > 0) {\n    var outlineOffset = ele.pstyle('outline-offset').value;\n    var nodeShape = ele.pstyle('shape').value;\n    var outlineSize = outlineWidth + outlineOffset;\n    var scaleX = (bounds.w + outlineSize * 2) / bounds.w;\n    var scaleY = (bounds.h + outlineSize * 2) / bounds.h;\n    var xOffset = 0;\n    var yOffset = 0;\n    if ([\"diamond\", \"pentagon\", \"round-triangle\"].includes(nodeShape)) {\n      scaleX = (bounds.w + outlineSize * 2.4) / bounds.w;\n      yOffset = -outlineSize / 3.6;\n    } else if ([\"concave-hexagon\", \"rhomboid\", \"right-rhomboid\"].includes(nodeShape)) {\n      scaleX = (bounds.w + outlineSize * 2.4) / bounds.w;\n    } else if (nodeShape === \"star\") {\n      scaleX = (bounds.w + outlineSize * 2.8) / bounds.w;\n      scaleY = (bounds.h + outlineSize * 2.6) / bounds.h;\n      yOffset = -outlineSize / 3.8;\n    } else if (nodeShape === \"triangle\") {\n      scaleX = (bounds.w + outlineSize * 2.8) / bounds.w;\n      scaleY = (bounds.h + outlineSize * 2.4) / bounds.h;\n      yOffset = -outlineSize / 1.4;\n    } else if (nodeShape === \"vee\") {\n      scaleX = (bounds.w + outlineSize * 4.4) / bounds.w;\n      scaleY = (bounds.h + outlineSize * 3.8) / bounds.h;\n      yOffset = -outlineSize * .5;\n    }\n    var hDelta = bounds.h * scaleY - bounds.h;\n    var wDelta = bounds.w * scaleX - bounds.w;\n    expandBoundingBoxSides(bounds, [Math.ceil(hDelta / 2), Math.ceil(wDelta / 2)]);\n    if (xOffset != 0 || yOffset !== 0) {\n      var oBounds = shiftBoundingBox(bounds, xOffset, yOffset);\n      updateBoundingBox(bounds, oBounds);\n    }\n  }\n};\n\n// get the bounding box of the elements (in raw model position)\nvar boundingBoxImpl = function boundingBoxImpl(ele, options) {\n  var cy = ele._private.cy;\n  var styleEnabled = cy.styleEnabled();\n  var headless = cy.headless();\n  var bounds = makeBoundingBox();\n  var _p = ele._private;\n  var isNode = ele.isNode();\n  var isEdge = ele.isEdge();\n  var ex1, ex2, ey1, ey2; // extrema of body / lines\n  var x, y; // node pos\n  var rstyle = _p.rstyle;\n  var manualExpansion = isNode && styleEnabled ? ele.pstyle('bounds-expansion').pfValue : [0];\n\n  // must use `display` prop only, as reading `compound.width()` causes recursion\n  // (other factors like width values will be considered later in this function anyway)\n  var isDisplayed = function isDisplayed(ele) {\n    return ele.pstyle('display').value !== 'none';\n  };\n  var displayed = !styleEnabled || isDisplayed(ele)\n\n  // must take into account connected nodes b/c of implicit edge hiding on display:none node\n  && (!isEdge || isDisplayed(ele.source()) && isDisplayed(ele.target()));\n  if (displayed) {\n    // displayed suffices, since we will find zero area eles anyway\n    var overlayOpacity = 0;\n    var overlayPadding = 0;\n    if (styleEnabled && options.includeOverlays) {\n      overlayOpacity = ele.pstyle('overlay-opacity').value;\n      if (overlayOpacity !== 0) {\n        overlayPadding = ele.pstyle('overlay-padding').value;\n      }\n    }\n    var underlayOpacity = 0;\n    var underlayPadding = 0;\n    if (styleEnabled && options.includeUnderlays) {\n      underlayOpacity = ele.pstyle('underlay-opacity').value;\n      if (underlayOpacity !== 0) {\n        underlayPadding = ele.pstyle('underlay-padding').value;\n      }\n    }\n    var padding = Math.max(overlayPadding, underlayPadding);\n    var w = 0;\n    var wHalf = 0;\n    if (styleEnabled) {\n      w = ele.pstyle('width').pfValue;\n      wHalf = w / 2;\n    }\n    if (isNode && options.includeNodes) {\n      var pos = ele.position();\n      x = pos.x;\n      y = pos.y;\n      var _w = ele.outerWidth();\n      var halfW = _w / 2;\n      var h = ele.outerHeight();\n      var halfH = h / 2;\n\n      // handle node dimensions\n      /////////////////////////\n\n      ex1 = x - halfW;\n      ex2 = x + halfW;\n      ey1 = y - halfH;\n      ey2 = y + halfH;\n      updateBounds(bounds, ex1, ey1, ex2, ey2);\n      if (styleEnabled && options.includeOutlines) {\n        updateBoundsFromOutline(bounds, ele);\n      }\n    } else if (isEdge && options.includeEdges) {\n      if (styleEnabled && !headless) {\n        var curveStyle = ele.pstyle('curve-style').strValue;\n\n        // handle edge dimensions (rough box estimate)\n        //////////////////////////////////////////////\n\n        ex1 = Math.min(rstyle.srcX, rstyle.midX, rstyle.tgtX);\n        ex2 = Math.max(rstyle.srcX, rstyle.midX, rstyle.tgtX);\n        ey1 = Math.min(rstyle.srcY, rstyle.midY, rstyle.tgtY);\n        ey2 = Math.max(rstyle.srcY, rstyle.midY, rstyle.tgtY);\n\n        // take into account edge width\n        ex1 -= wHalf;\n        ex2 += wHalf;\n        ey1 -= wHalf;\n        ey2 += wHalf;\n        updateBounds(bounds, ex1, ey1, ex2, ey2);\n\n        // precise edges\n        ////////////////\n\n        if (curveStyle === 'haystack') {\n          var hpts = rstyle.haystackPts;\n          if (hpts && hpts.length === 2) {\n            ex1 = hpts[0].x;\n            ey1 = hpts[0].y;\n            ex2 = hpts[1].x;\n            ey2 = hpts[1].y;\n            if (ex1 > ex2) {\n              var temp = ex1;\n              ex1 = ex2;\n              ex2 = temp;\n            }\n            if (ey1 > ey2) {\n              var _temp = ey1;\n              ey1 = ey2;\n              ey2 = _temp;\n            }\n            updateBounds(bounds, ex1 - wHalf, ey1 - wHalf, ex2 + wHalf, ey2 + wHalf);\n          }\n        } else if (curveStyle === 'bezier' || curveStyle === 'unbundled-bezier' || curveStyle.endsWith('segments') || curveStyle.endsWith('taxi')) {\n          var pts;\n          switch (curveStyle) {\n            case 'bezier':\n            case 'unbundled-bezier':\n              pts = rstyle.bezierPts;\n              break;\n            case 'segments':\n            case 'taxi':\n            case 'round-segments':\n            case 'round-taxi':\n              pts = rstyle.linePts;\n              break;\n          }\n          if (pts != null) {\n            for (var j = 0; j < pts.length; j++) {\n              var pt = pts[j];\n              ex1 = pt.x - wHalf;\n              ex2 = pt.x + wHalf;\n              ey1 = pt.y - wHalf;\n              ey2 = pt.y + wHalf;\n              updateBounds(bounds, ex1, ey1, ex2, ey2);\n            }\n          }\n        } // bezier-like or segment-like edge\n      } else {\n        // headless or style disabled\n\n        // fallback on source and target positions\n        //////////////////////////////////////////\n\n        var n1 = ele.source();\n        var n1pos = n1.position();\n        var n2 = ele.target();\n        var n2pos = n2.position();\n        ex1 = n1pos.x;\n        ex2 = n2pos.x;\n        ey1 = n1pos.y;\n        ey2 = n2pos.y;\n        if (ex1 > ex2) {\n          var _temp2 = ex1;\n          ex1 = ex2;\n          ex2 = _temp2;\n        }\n        if (ey1 > ey2) {\n          var _temp3 = ey1;\n          ey1 = ey2;\n          ey2 = _temp3;\n        }\n\n        // take into account edge width\n        ex1 -= wHalf;\n        ex2 += wHalf;\n        ey1 -= wHalf;\n        ey2 += wHalf;\n        updateBounds(bounds, ex1, ey1, ex2, ey2);\n      } // headless or style disabled\n    } // edges\n\n    // handle edge arrow size\n    /////////////////////////\n\n    if (styleEnabled && options.includeEdges && isEdge) {\n      updateBoundsFromArrow(bounds, ele, 'mid-source');\n      updateBoundsFromArrow(bounds, ele, 'mid-target');\n      updateBoundsFromArrow(bounds, ele, 'source');\n      updateBoundsFromArrow(bounds, ele, 'target');\n    }\n\n    // ghost\n    ////////\n\n    if (styleEnabled) {\n      var ghost = ele.pstyle('ghost').value === 'yes';\n      if (ghost) {\n        var gx = ele.pstyle('ghost-offset-x').pfValue;\n        var gy = ele.pstyle('ghost-offset-y').pfValue;\n        updateBounds(bounds, bounds.x1 + gx, bounds.y1 + gy, bounds.x2 + gx, bounds.y2 + gy);\n      }\n    }\n\n    // always store the body bounds separately from the labels\n    var bbBody = _p.bodyBounds = _p.bodyBounds || {};\n    assignBoundingBox(bbBody, bounds);\n    expandBoundingBoxSides(bbBody, manualExpansion);\n    expandBoundingBox(bbBody, 1); // expand to work around browser dimension inaccuracies\n\n    // overlay\n    //////////\n\n    if (styleEnabled) {\n      ex1 = bounds.x1;\n      ex2 = bounds.x2;\n      ey1 = bounds.y1;\n      ey2 = bounds.y2;\n      updateBounds(bounds, ex1 - padding, ey1 - padding, ex2 + padding, ey2 + padding);\n    }\n\n    // always store the body bounds separately from the labels\n    var bbOverlay = _p.overlayBounds = _p.overlayBounds || {};\n    assignBoundingBox(bbOverlay, bounds);\n    expandBoundingBoxSides(bbOverlay, manualExpansion);\n    expandBoundingBox(bbOverlay, 1); // expand to work around browser dimension inaccuracies\n\n    // handle label dimensions\n    //////////////////////////\n\n    var bbLabels = _p.labelBounds = _p.labelBounds || {};\n    if (bbLabels.all != null) {\n      clearBoundingBox(bbLabels.all);\n    } else {\n      bbLabels.all = makeBoundingBox();\n    }\n    if (styleEnabled && options.includeLabels) {\n      if (options.includeMainLabels) {\n        updateBoundsFromLabel(bounds, ele, null);\n      }\n      if (isEdge) {\n        if (options.includeSourceLabels) {\n          updateBoundsFromLabel(bounds, ele, 'source');\n        }\n        if (options.includeTargetLabels) {\n          updateBoundsFromLabel(bounds, ele, 'target');\n        }\n      }\n    } // style enabled for labels\n  } // if displayed\n\n  bounds.x1 = noninf(bounds.x1);\n  bounds.y1 = noninf(bounds.y1);\n  bounds.x2 = noninf(bounds.x2);\n  bounds.y2 = noninf(bounds.y2);\n  bounds.w = noninf(bounds.x2 - bounds.x1);\n  bounds.h = noninf(bounds.y2 - bounds.y1);\n  if (bounds.w > 0 && bounds.h > 0 && displayed) {\n    expandBoundingBoxSides(bounds, manualExpansion);\n\n    // expand bounds by 1 because antialiasing can increase the visual/effective size by 1 on all sides\n    expandBoundingBox(bounds, 1);\n  }\n  return bounds;\n};\nvar getKey = function getKey(opts) {\n  var i = 0;\n  var tf = function tf(val) {\n    return (val ? 1 : 0) << i++;\n  };\n  var key = 0;\n  key += tf(opts.incudeNodes);\n  key += tf(opts.includeEdges);\n  key += tf(opts.includeLabels);\n  key += tf(opts.includeMainLabels);\n  key += tf(opts.includeSourceLabels);\n  key += tf(opts.includeTargetLabels);\n  key += tf(opts.includeOverlays);\n  key += tf(opts.includeOutlines);\n  return key;\n};\nvar getBoundingBoxPosKey = function getBoundingBoxPosKey(ele) {\n  if (ele.isEdge()) {\n    var p1 = ele.source().position();\n    var p2 = ele.target().position();\n    var r = function r(x) {\n      return Math.round(x);\n    };\n    return hashIntsArray([r(p1.x), r(p1.y), r(p2.x), r(p2.y)]);\n  } else {\n    return 0;\n  }\n};\nvar cachedBoundingBoxImpl = function cachedBoundingBoxImpl(ele, opts) {\n  var _p = ele._private;\n  var bb;\n  var isEdge = ele.isEdge();\n  var key = opts == null ? defBbOptsKey : getKey(opts);\n  var usingDefOpts = key === defBbOptsKey;\n  var currPosKey = getBoundingBoxPosKey(ele);\n  var isPosKeySame = _p.bbCachePosKey === currPosKey;\n  var useCache = opts.useCache && isPosKeySame;\n  var isDirty = function isDirty(ele) {\n    return ele._private.bbCache == null || ele._private.styleDirty;\n  };\n  var needRecalc = !useCache || isDirty(ele) || isEdge && (isDirty(ele.source()) || isDirty(ele.target()));\n  if (needRecalc) {\n    if (!isPosKeySame) {\n      ele.recalculateRenderedStyle(useCache);\n    }\n    bb = boundingBoxImpl(ele, defBbOpts);\n    _p.bbCache = bb;\n    _p.bbCachePosKey = currPosKey;\n  } else {\n    bb = _p.bbCache;\n  }\n\n  // not using def opts => need to build up bb from combination of sub bbs\n  if (!usingDefOpts) {\n    var isNode = ele.isNode();\n    bb = makeBoundingBox();\n    if (opts.includeNodes && isNode || opts.includeEdges && !isNode) {\n      if (opts.includeOverlays) {\n        updateBoundsFromBox(bb, _p.overlayBounds);\n      } else {\n        updateBoundsFromBox(bb, _p.bodyBounds);\n      }\n    }\n    if (opts.includeLabels) {\n      if (opts.includeMainLabels && (!isEdge || opts.includeSourceLabels && opts.includeTargetLabels)) {\n        updateBoundsFromBox(bb, _p.labelBounds.all);\n      } else {\n        if (opts.includeMainLabels) {\n          updateBoundsFromBox(bb, _p.labelBounds.mainRot);\n        }\n        if (opts.includeSourceLabels) {\n          updateBoundsFromBox(bb, _p.labelBounds.sourceRot);\n        }\n        if (opts.includeTargetLabels) {\n          updateBoundsFromBox(bb, _p.labelBounds.targetRot);\n        }\n      }\n    }\n    bb.w = bb.x2 - bb.x1;\n    bb.h = bb.y2 - bb.y1;\n  }\n  return bb;\n};\nvar defBbOpts = {\n  includeNodes: true,\n  includeEdges: true,\n  includeLabels: true,\n  includeMainLabels: true,\n  includeSourceLabels: true,\n  includeTargetLabels: true,\n  includeOverlays: true,\n  includeUnderlays: true,\n  includeOutlines: true,\n  useCache: true\n};\nvar defBbOptsKey = getKey(defBbOpts);\nvar filledBbOpts = defaults$g(defBbOpts);\nelesfn$b.boundingBox = function (options) {\n  var bounds;\n\n  // the main usecase is ele.boundingBox() for a single element with no/def options\n  // specified s.t. the cache is used, so check for this case to make it faster by\n  // avoiding the overhead of the rest of the function\n  if (this.length === 1 && this[0]._private.bbCache != null && !this[0]._private.styleDirty && (options === undefined || options.useCache === undefined || options.useCache === true)) {\n    if (options === undefined) {\n      options = defBbOpts;\n    } else {\n      options = filledBbOpts(options);\n    }\n    bounds = cachedBoundingBoxImpl(this[0], options);\n  } else {\n    bounds = makeBoundingBox();\n    options = options || defBbOpts;\n    var opts = filledBbOpts(options);\n    var eles = this;\n    var cy = eles.cy();\n    var styleEnabled = cy.styleEnabled();\n    if (styleEnabled) {\n      for (var i = 0; i < eles.length; i++) {\n        var ele = eles[i];\n        var _p = ele._private;\n        var currPosKey = getBoundingBoxPosKey(ele);\n        var isPosKeySame = _p.bbCachePosKey === currPosKey;\n        var useCache = opts.useCache && isPosKeySame && !_p.styleDirty;\n        ele.recalculateRenderedStyle(useCache);\n      }\n    }\n    this.updateCompoundBounds(!options.useCache);\n    for (var _i = 0; _i < eles.length; _i++) {\n      var _ele = eles[_i];\n      updateBoundsFromBox(bounds, cachedBoundingBoxImpl(_ele, opts));\n    }\n  }\n  bounds.x1 = noninf(bounds.x1);\n  bounds.y1 = noninf(bounds.y1);\n  bounds.x2 = noninf(bounds.x2);\n  bounds.y2 = noninf(bounds.y2);\n  bounds.w = noninf(bounds.x2 - bounds.x1);\n  bounds.h = noninf(bounds.y2 - bounds.y1);\n  return bounds;\n};\nelesfn$b.dirtyBoundingBoxCache = function () {\n  for (var i = 0; i < this.length; i++) {\n    var _p = this[i]._private;\n    _p.bbCache = null;\n    _p.bbCachePosKey = null;\n    _p.bodyBounds = null;\n    _p.overlayBounds = null;\n    _p.labelBounds.all = null;\n    _p.labelBounds.source = null;\n    _p.labelBounds.target = null;\n    _p.labelBounds.main = null;\n    _p.labelBounds.sourceRot = null;\n    _p.labelBounds.targetRot = null;\n    _p.labelBounds.mainRot = null;\n    _p.arrowBounds.source = null;\n    _p.arrowBounds.target = null;\n    _p.arrowBounds['mid-source'] = null;\n    _p.arrowBounds['mid-target'] = null;\n  }\n  this.emitAndNotify('bounds');\n  return this;\n};\n\n// private helper to get bounding box for custom node positions\n// - good for perf in certain cases but currently requires dirtying the rendered style\n// - would be better to not modify the nodes but the nodes are read directly everywhere in the renderer...\n// - try to use for only things like discrete layouts where the node position would change anyway\nelesfn$b.boundingBoxAt = function (fn) {\n  var nodes = this.nodes();\n  var cy = this.cy();\n  var hasCompoundNodes = cy.hasCompoundNodes();\n  var parents = cy.collection();\n  if (hasCompoundNodes) {\n    parents = nodes.filter(function (node) {\n      return node.isParent();\n    });\n    nodes = nodes.not(parents);\n  }\n  if (plainObject(fn)) {\n    var obj = fn;\n    fn = function fn() {\n      return obj;\n    };\n  }\n  var storeOldPos = function storeOldPos(node, i) {\n    return node._private.bbAtOldPos = fn(node, i);\n  };\n  var getOldPos = function getOldPos(node) {\n    return node._private.bbAtOldPos;\n  };\n  cy.startBatch();\n  nodes.forEach(storeOldPos).silentPositions(fn);\n  if (hasCompoundNodes) {\n    parents.dirtyCompoundBoundsCache();\n    parents.dirtyBoundingBoxCache();\n    parents.updateCompoundBounds(true); // force update b/c we're inside a batch cycle\n  }\n\n  var bb = copyBoundingBox(this.boundingBox({\n    useCache: false\n  }));\n  nodes.silentPositions(getOldPos);\n  if (hasCompoundNodes) {\n    parents.dirtyCompoundBoundsCache();\n    parents.dirtyBoundingBoxCache();\n    parents.updateCompoundBounds(true); // force update b/c we're inside a batch cycle\n  }\n\n  cy.endBatch();\n  return bb;\n};\nfn$3.boundingbox = fn$3.bb = fn$3.boundingBox;\nfn$3.renderedBoundingbox = fn$3.renderedBoundingBox;\nvar bounds = elesfn$b;\n\nvar fn$2, elesfn$a;\nfn$2 = elesfn$a = {};\nvar defineDimFns = function defineDimFns(opts) {\n  opts.uppercaseName = capitalize(opts.name);\n  opts.autoName = 'auto' + opts.uppercaseName;\n  opts.labelName = 'label' + opts.uppercaseName;\n  opts.outerName = 'outer' + opts.uppercaseName;\n  opts.uppercaseOuterName = capitalize(opts.outerName);\n  fn$2[opts.name] = function dimImpl() {\n    var ele = this[0];\n    var _p = ele._private;\n    var cy = _p.cy;\n    var styleEnabled = cy._private.styleEnabled;\n    if (ele) {\n      if (styleEnabled) {\n        if (ele.isParent()) {\n          ele.updateCompoundBounds();\n          return _p[opts.autoName] || 0;\n        }\n        var d = ele.pstyle(opts.name);\n        switch (d.strValue) {\n          case 'label':\n            ele.recalculateRenderedStyle();\n            return _p.rstyle[opts.labelName] || 0;\n          default:\n            return d.pfValue;\n        }\n      } else {\n        return 1;\n      }\n    }\n  };\n  fn$2['outer' + opts.uppercaseName] = function outerDimImpl() {\n    var ele = this[0];\n    var _p = ele._private;\n    var cy = _p.cy;\n    var styleEnabled = cy._private.styleEnabled;\n    if (ele) {\n      if (styleEnabled) {\n        var dim = ele[opts.name]();\n        var border = ele.pstyle('border-width').pfValue; // n.b. 1/2 each side\n        var padding = 2 * ele.padding();\n        return dim + border + padding;\n      } else {\n        return 1;\n      }\n    }\n  };\n  fn$2['rendered' + opts.uppercaseName] = function renderedDimImpl() {\n    var ele = this[0];\n    if (ele) {\n      var d = ele[opts.name]();\n      return d * this.cy().zoom();\n    }\n  };\n  fn$2['rendered' + opts.uppercaseOuterName] = function renderedOuterDimImpl() {\n    var ele = this[0];\n    if (ele) {\n      var od = ele[opts.outerName]();\n      return od * this.cy().zoom();\n    }\n  };\n};\ndefineDimFns({\n  name: 'width'\n});\ndefineDimFns({\n  name: 'height'\n});\nelesfn$a.padding = function () {\n  var ele = this[0];\n  var _p = ele._private;\n  if (ele.isParent()) {\n    ele.updateCompoundBounds();\n    if (_p.autoPadding !== undefined) {\n      return _p.autoPadding;\n    } else {\n      return ele.pstyle('padding').pfValue;\n    }\n  } else {\n    return ele.pstyle('padding').pfValue;\n  }\n};\nelesfn$a.paddedHeight = function () {\n  var ele = this[0];\n  return ele.height() + 2 * ele.padding();\n};\nelesfn$a.paddedWidth = function () {\n  var ele = this[0];\n  return ele.width() + 2 * ele.padding();\n};\nvar widthHeight = elesfn$a;\n\nvar ifEdge = function ifEdge(ele, getValue) {\n  if (ele.isEdge()) {\n    return getValue(ele);\n  }\n};\nvar ifEdgeRenderedPosition = function ifEdgeRenderedPosition(ele, getPoint) {\n  if (ele.isEdge()) {\n    var cy = ele.cy();\n    return modelToRenderedPosition(getPoint(ele), cy.zoom(), cy.pan());\n  }\n};\nvar ifEdgeRenderedPositions = function ifEdgeRenderedPositions(ele, getPoints) {\n  if (ele.isEdge()) {\n    var cy = ele.cy();\n    var pan = cy.pan();\n    var zoom = cy.zoom();\n    return getPoints(ele).map(function (p) {\n      return modelToRenderedPosition(p, zoom, pan);\n    });\n  }\n};\nvar controlPoints = function controlPoints(ele) {\n  return ele.renderer().getControlPoints(ele);\n};\nvar segmentPoints = function segmentPoints(ele) {\n  return ele.renderer().getSegmentPoints(ele);\n};\nvar sourceEndpoint = function sourceEndpoint(ele) {\n  return ele.renderer().getSourceEndpoint(ele);\n};\nvar targetEndpoint = function targetEndpoint(ele) {\n  return ele.renderer().getTargetEndpoint(ele);\n};\nvar midpoint = function midpoint(ele) {\n  return ele.renderer().getEdgeMidpoint(ele);\n};\nvar pts = {\n  controlPoints: {\n    get: controlPoints,\n    mult: true\n  },\n  segmentPoints: {\n    get: segmentPoints,\n    mult: true\n  },\n  sourceEndpoint: {\n    get: sourceEndpoint\n  },\n  targetEndpoint: {\n    get: targetEndpoint\n  },\n  midpoint: {\n    get: midpoint\n  }\n};\nvar renderedName = function renderedName(name) {\n  return 'rendered' + name[0].toUpperCase() + name.substr(1);\n};\nvar edgePoints = Object.keys(pts).reduce(function (obj, name) {\n  var spec = pts[name];\n  var rName = renderedName(name);\n  obj[name] = function () {\n    return ifEdge(this, spec.get);\n  };\n  if (spec.mult) {\n    obj[rName] = function () {\n      return ifEdgeRenderedPositions(this, spec.get);\n    };\n  } else {\n    obj[rName] = function () {\n      return ifEdgeRenderedPosition(this, spec.get);\n    };\n  }\n  return obj;\n}, {});\n\nvar dimensions = extend({}, position, bounds, widthHeight, edgePoints);\n\n/*!\nEvent object based on jQuery events, MIT license\n\nhttps://jquery.org/license/\nhttps://tldrlegal.com/license/mit-license\nhttps://github.com/jquery/jquery/blob/master/src/event.js\n*/\n\nvar Event = function Event(src, props) {\n  this.recycle(src, props);\n};\nfunction returnFalse() {\n  return false;\n}\nfunction returnTrue() {\n  return true;\n}\n\n// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html\nEvent.prototype = {\n  instanceString: function instanceString() {\n    return 'event';\n  },\n  recycle: function recycle(src, props) {\n    this.isImmediatePropagationStopped = this.isPropagationStopped = this.isDefaultPrevented = returnFalse;\n    if (src != null && src.preventDefault) {\n      // Browser Event object\n      this.type = src.type;\n\n      // Events bubbling up the document may have been marked as prevented\n      // by a handler lower down the tree; reflect the correct value.\n      this.isDefaultPrevented = src.defaultPrevented ? returnTrue : returnFalse;\n    } else if (src != null && src.type) {\n      // Plain object containing all event details\n      props = src;\n    } else {\n      // Event string\n      this.type = src;\n    }\n\n    // Put explicitly provided properties onto the event object\n    if (props != null) {\n      // more efficient to manually copy fields we use\n      this.originalEvent = props.originalEvent;\n      this.type = props.type != null ? props.type : this.type;\n      this.cy = props.cy;\n      this.target = props.target;\n      this.position = props.position;\n      this.renderedPosition = props.renderedPosition;\n      this.namespace = props.namespace;\n      this.layout = props.layout;\n    }\n    if (this.cy != null && this.position != null && this.renderedPosition == null) {\n      // create a rendered position based on the passed position\n      var pos = this.position;\n      var zoom = this.cy.zoom();\n      var pan = this.cy.pan();\n      this.renderedPosition = {\n        x: pos.x * zoom + pan.x,\n        y: pos.y * zoom + pan.y\n      };\n    }\n\n    // Create a timestamp if incoming event doesn't have one\n    this.timeStamp = src && src.timeStamp || Date.now();\n  },\n  preventDefault: function preventDefault() {\n    this.isDefaultPrevented = returnTrue;\n    var e = this.originalEvent;\n    if (!e) {\n      return;\n    }\n\n    // if preventDefault exists run it on the original event\n    if (e.preventDefault) {\n      e.preventDefault();\n    }\n  },\n  stopPropagation: function stopPropagation() {\n    this.isPropagationStopped = returnTrue;\n    var e = this.originalEvent;\n    if (!e) {\n      return;\n    }\n\n    // if stopPropagation exists run it on the original event\n    if (e.stopPropagation) {\n      e.stopPropagation();\n    }\n  },\n  stopImmediatePropagation: function stopImmediatePropagation() {\n    this.isImmediatePropagationStopped = returnTrue;\n    this.stopPropagation();\n  },\n  isDefaultPrevented: returnFalse,\n  isPropagationStopped: returnFalse,\n  isImmediatePropagationStopped: returnFalse\n};\n\nvar eventRegex = /^([^.]+)(\\.(?:[^.]+))?$/; // regex for matching event strings (e.g. \"click.namespace\")\nvar universalNamespace = '.*'; // matches as if no namespace specified and prevents users from unbinding accidentally\n\nvar defaults$8 = {\n  qualifierCompare: function qualifierCompare(q1, q2) {\n    return q1 === q2;\n  },\n  eventMatches: function eventMatches( /*context, listener, eventObj*/\n  ) {\n    return true;\n  },\n  addEventFields: function addEventFields( /*context, evt*/\n  ) {},\n  callbackContext: function callbackContext(context /*, listener, eventObj*/) {\n    return context;\n  },\n  beforeEmit: function beforeEmit( /* context, listener, eventObj */\n  ) {},\n  afterEmit: function afterEmit( /* context, listener, eventObj */\n  ) {},\n  bubble: function bubble( /*context*/\n  ) {\n    return false;\n  },\n  parent: function parent( /*context*/\n  ) {\n    return null;\n  },\n  context: null\n};\nvar defaultsKeys = Object.keys(defaults$8);\nvar emptyOpts = {};\nfunction Emitter() {\n  var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : emptyOpts;\n  var context = arguments.length > 1 ? arguments[1] : undefined;\n  // micro-optimisation vs Object.assign() -- reduces Element instantiation time\n  for (var i = 0; i < defaultsKeys.length; i++) {\n    var key = defaultsKeys[i];\n    this[key] = opts[key] || defaults$8[key];\n  }\n  this.context = context || this.context;\n  this.listeners = [];\n  this.emitting = 0;\n}\nvar p = Emitter.prototype;\nvar forEachEvent = function forEachEvent(self, handler, events, qualifier, callback, conf, confOverrides) {\n  if (fn$6(qualifier)) {\n    callback = qualifier;\n    qualifier = null;\n  }\n  if (confOverrides) {\n    if (conf == null) {\n      conf = confOverrides;\n    } else {\n      conf = extend({}, conf, confOverrides);\n    }\n  }\n  var eventList = array(events) ? events : events.split(/\\s+/);\n  for (var i = 0; i < eventList.length; i++) {\n    var evt = eventList[i];\n    if (emptyString(evt)) {\n      continue;\n    }\n    var match = evt.match(eventRegex); // type[.namespace]\n\n    if (match) {\n      var type = match[1];\n      var namespace = match[2] ? match[2] : null;\n      var ret = handler(self, evt, type, namespace, qualifier, callback, conf);\n      if (ret === false) {\n        break;\n      } // allow exiting early\n    }\n  }\n};\n\nvar makeEventObj = function makeEventObj(self, obj) {\n  self.addEventFields(self.context, obj);\n  return new Event(obj.type, obj);\n};\nvar forEachEventObj = function forEachEventObj(self, handler, events) {\n  if (event(events)) {\n    handler(self, events);\n    return;\n  } else if (plainObject(events)) {\n    handler(self, makeEventObj(self, events));\n    return;\n  }\n  var eventList = array(events) ? events : events.split(/\\s+/);\n  for (var i = 0; i < eventList.length; i++) {\n    var evt = eventList[i];\n    if (emptyString(evt)) {\n      continue;\n    }\n    var match = evt.match(eventRegex); // type[.namespace]\n\n    if (match) {\n      var type = match[1];\n      var namespace = match[2] ? match[2] : null;\n      var eventObj = makeEventObj(self, {\n        type: type,\n        namespace: namespace,\n        target: self.context\n      });\n      handler(self, eventObj);\n    }\n  }\n};\np.on = p.addListener = function (events, qualifier, callback, conf, confOverrides) {\n  forEachEvent(this, function (self, event, type, namespace, qualifier, callback, conf) {\n    if (fn$6(callback)) {\n      self.listeners.push({\n        event: event,\n        // full event string\n        callback: callback,\n        // callback to run\n        type: type,\n        // the event type (e.g. 'click')\n        namespace: namespace,\n        // the event namespace (e.g. \".foo\")\n        qualifier: qualifier,\n        // a restriction on whether to match this emitter\n        conf: conf // additional configuration\n      });\n    }\n  }, events, qualifier, callback, conf, confOverrides);\n  return this;\n};\np.one = function (events, qualifier, callback, conf) {\n  return this.on(events, qualifier, callback, conf, {\n    one: true\n  });\n};\np.removeListener = p.off = function (events, qualifier, callback, conf) {\n  var _this = this;\n  if (this.emitting !== 0) {\n    this.listeners = copyArray$1(this.listeners);\n  }\n  var listeners = this.listeners;\n  var _loop = function _loop(i) {\n    var listener = listeners[i];\n    forEachEvent(_this, function (self, event, type, namespace, qualifier, callback /*, conf*/) {\n      if ((listener.type === type || events === '*') && (!namespace && listener.namespace !== '.*' || listener.namespace === namespace) && (!qualifier || self.qualifierCompare(listener.qualifier, qualifier)) && (!callback || listener.callback === callback)) {\n        listeners.splice(i, 1);\n        return false;\n      }\n    }, events, qualifier, callback, conf);\n  };\n  for (var i = listeners.length - 1; i >= 0; i--) {\n    _loop(i);\n  }\n  return this;\n};\np.removeAllListeners = function () {\n  return this.removeListener('*');\n};\np.emit = p.trigger = function (events, extraParams, manualCallback) {\n  var listeners = this.listeners;\n  var numListenersBeforeEmit = listeners.length;\n  this.emitting++;\n  if (!array(extraParams)) {\n    extraParams = [extraParams];\n  }\n  forEachEventObj(this, function (self, eventObj) {\n    if (manualCallback != null) {\n      listeners = [{\n        event: eventObj.event,\n        type: eventObj.type,\n        namespace: eventObj.namespace,\n        callback: manualCallback\n      }];\n      numListenersBeforeEmit = listeners.length;\n    }\n    var _loop2 = function _loop2(i) {\n      var listener = listeners[i];\n      if (listener.type === eventObj.type && (!listener.namespace || listener.namespace === eventObj.namespace || listener.namespace === universalNamespace) && self.eventMatches(self.context, listener, eventObj)) {\n        var args = [eventObj];\n        if (extraParams != null) {\n          push(args, extraParams);\n        }\n        self.beforeEmit(self.context, listener, eventObj);\n        if (listener.conf && listener.conf.one) {\n          self.listeners = self.listeners.filter(function (l) {\n            return l !== listener;\n          });\n        }\n        var context = self.callbackContext(self.context, listener, eventObj);\n        var ret = listener.callback.apply(context, args);\n        self.afterEmit(self.context, listener, eventObj);\n        if (ret === false) {\n          eventObj.stopPropagation();\n          eventObj.preventDefault();\n        }\n      } // if listener matches\n    };\n    for (var i = 0; i < numListenersBeforeEmit; i++) {\n      _loop2(i);\n    } // for listener\n\n    if (self.bubble(self.context) && !eventObj.isPropagationStopped()) {\n      self.parent(self.context).emit(eventObj, extraParams);\n    }\n  }, events);\n  this.emitting--;\n  return this;\n};\n\nvar emitterOptions$1 = {\n  qualifierCompare: function qualifierCompare(selector1, selector2) {\n    if (selector1 == null || selector2 == null) {\n      return selector1 == null && selector2 == null;\n    } else {\n      return selector1.sameText(selector2);\n    }\n  },\n  eventMatches: function eventMatches(ele, listener, eventObj) {\n    var selector = listener.qualifier;\n    if (selector != null) {\n      return ele !== eventObj.target && element(eventObj.target) && selector.matches(eventObj.target);\n    }\n    return true;\n  },\n  addEventFields: function addEventFields(ele, evt) {\n    evt.cy = ele.cy();\n    evt.target = ele;\n  },\n  callbackContext: function callbackContext(ele, listener, eventObj) {\n    return listener.qualifier != null ? eventObj.target : ele;\n  },\n  beforeEmit: function beforeEmit(context, listener /*, eventObj*/) {\n    if (listener.conf && listener.conf.once) {\n      listener.conf.onceCollection.removeListener(listener.event, listener.qualifier, listener.callback);\n    }\n  },\n  bubble: function bubble() {\n    return true;\n  },\n  parent: function parent(ele) {\n    return ele.isChild() ? ele.parent() : ele.cy();\n  }\n};\nvar argSelector$1 = function argSelector(arg) {\n  if (string(arg)) {\n    return new Selector(arg);\n  } else {\n    return arg;\n  }\n};\nvar elesfn$9 = {\n  createEmitter: function createEmitter() {\n    for (var i = 0; i < this.length; i++) {\n      var ele = this[i];\n      var _p = ele._private;\n      if (!_p.emitter) {\n        _p.emitter = new Emitter(emitterOptions$1, ele);\n      }\n    }\n    return this;\n  },\n  emitter: function emitter() {\n    return this._private.emitter;\n  },\n  on: function on(events, selector, callback) {\n    var argSel = argSelector$1(selector);\n    for (var i = 0; i < this.length; i++) {\n      var ele = this[i];\n      ele.emitter().on(events, argSel, callback);\n    }\n    return this;\n  },\n  removeListener: function removeListener(events, selector, callback) {\n    var argSel = argSelector$1(selector);\n    for (var i = 0; i < this.length; i++) {\n      var ele = this[i];\n      ele.emitter().removeListener(events, argSel, callback);\n    }\n    return this;\n  },\n  removeAllListeners: function removeAllListeners() {\n    for (var i = 0; i < this.length; i++) {\n      var ele = this[i];\n      ele.emitter().removeAllListeners();\n    }\n    return this;\n  },\n  one: function one(events, selector, callback) {\n    var argSel = argSelector$1(selector);\n    for (var i = 0; i < this.length; i++) {\n      var ele = this[i];\n      ele.emitter().one(events, argSel, callback);\n    }\n    return this;\n  },\n  once: function once(events, selector, callback) {\n    var argSel = argSelector$1(selector);\n    for (var i = 0; i < this.length; i++) {\n      var ele = this[i];\n      ele.emitter().on(events, argSel, callback, {\n        once: true,\n        onceCollection: this\n      });\n    }\n  },\n  emit: function emit(events, extraParams) {\n    for (var i = 0; i < this.length; i++) {\n      var ele = this[i];\n      ele.emitter().emit(events, extraParams);\n    }\n    return this;\n  },\n  emitAndNotify: function emitAndNotify(event, extraParams) {\n    // for internal use only\n    if (this.length === 0) {\n      return;\n    } // empty collections don't need to notify anything\n\n    // notify renderer\n    this.cy().notify(event, this);\n    this.emit(event, extraParams);\n    return this;\n  }\n};\ndefine.eventAliasesOn(elesfn$9);\n\nvar elesfn$8 = {\n  nodes: function nodes(selector) {\n    return this.filter(function (ele) {\n      return ele.isNode();\n    }).filter(selector);\n  },\n  edges: function edges(selector) {\n    return this.filter(function (ele) {\n      return ele.isEdge();\n    }).filter(selector);\n  },\n  // internal helper to get nodes and edges as separate collections with single iteration over elements\n  byGroup: function byGroup() {\n    var nodes = this.spawn();\n    var edges = this.spawn();\n    for (var i = 0; i < this.length; i++) {\n      var ele = this[i];\n      if (ele.isNode()) {\n        nodes.push(ele);\n      } else {\n        edges.push(ele);\n      }\n    }\n    return {\n      nodes: nodes,\n      edges: edges\n    };\n  },\n  filter: function filter(_filter, thisArg) {\n    if (_filter === undefined) {\n      // check this first b/c it's the most common/performant case\n      return this;\n    } else if (string(_filter) || elementOrCollection(_filter)) {\n      return new Selector(_filter).filter(this);\n    } else if (fn$6(_filter)) {\n      var filterEles = this.spawn();\n      var eles = this;\n      for (var i = 0; i < eles.length; i++) {\n        var ele = eles[i];\n        var include = thisArg ? _filter.apply(thisArg, [ele, i, eles]) : _filter(ele, i, eles);\n        if (include) {\n          filterEles.push(ele);\n        }\n      }\n      return filterEles;\n    }\n    return this.spawn(); // if not handled by above, give 'em an empty collection\n  },\n\n  not: function not(toRemove) {\n    if (!toRemove) {\n      return this;\n    } else {\n      if (string(toRemove)) {\n        toRemove = this.filter(toRemove);\n      }\n      var elements = this.spawn();\n      for (var i = 0; i < this.length; i++) {\n        var element = this[i];\n        var remove = toRemove.has(element);\n        if (!remove) {\n          elements.push(element);\n        }\n      }\n      return elements;\n    }\n  },\n  absoluteComplement: function absoluteComplement() {\n    var cy = this.cy();\n    return cy.mutableElements().not(this);\n  },\n  intersect: function intersect(other) {\n    // if a selector is specified, then filter by it instead\n    if (string(other)) {\n      var selector = other;\n      return this.filter(selector);\n    }\n    var elements = this.spawn();\n    var col1 = this;\n    var col2 = other;\n    var col1Smaller = this.length < other.length;\n    var colS = col1Smaller ? col1 : col2;\n    var colL = col1Smaller ? col2 : col1;\n    for (var i = 0; i < colS.length; i++) {\n      var ele = colS[i];\n      if (colL.has(ele)) {\n        elements.push(ele);\n      }\n    }\n    return elements;\n  },\n  xor: function xor(other) {\n    var cy = this._private.cy;\n    if (string(other)) {\n      other = cy.$(other);\n    }\n    var elements = this.spawn();\n    var col1 = this;\n    var col2 = other;\n    var add = function add(col, other) {\n      for (var i = 0; i < col.length; i++) {\n        var ele = col[i];\n        var id = ele._private.data.id;\n        var inOther = other.hasElementWithId(id);\n        if (!inOther) {\n          elements.push(ele);\n        }\n      }\n    };\n    add(col1, col2);\n    add(col2, col1);\n    return elements;\n  },\n  diff: function diff(other) {\n    var cy = this._private.cy;\n    if (string(other)) {\n      other = cy.$(other);\n    }\n    var left = this.spawn();\n    var right = this.spawn();\n    var both = this.spawn();\n    var col1 = this;\n    var col2 = other;\n    var add = function add(col, other, retEles) {\n      for (var i = 0; i < col.length; i++) {\n        var ele = col[i];\n        var id = ele._private.data.id;\n        var inOther = other.hasElementWithId(id);\n        if (inOther) {\n          both.merge(ele);\n        } else {\n          retEles.push(ele);\n        }\n      }\n    };\n    add(col1, col2, left);\n    add(col2, col1, right);\n    return {\n      left: left,\n      right: right,\n      both: both\n    };\n  },\n  add: function add(toAdd) {\n    var cy = this._private.cy;\n    if (!toAdd) {\n      return this;\n    }\n    if (string(toAdd)) {\n      var selector = toAdd;\n      toAdd = cy.mutableElements().filter(selector);\n    }\n    var elements = this.spawnSelf();\n    for (var i = 0; i < toAdd.length; i++) {\n      var ele = toAdd[i];\n      var add = !this.has(ele);\n      if (add) {\n        elements.push(ele);\n      }\n    }\n    return elements;\n  },\n  // in place merge on calling collection\n  merge: function merge(toAdd) {\n    var _p = this._private;\n    var cy = _p.cy;\n    if (!toAdd) {\n      return this;\n    }\n    if (toAdd && string(toAdd)) {\n      var selector = toAdd;\n      toAdd = cy.mutableElements().filter(selector);\n    }\n    var map = _p.map;\n    for (var i = 0; i < toAdd.length; i++) {\n      var toAddEle = toAdd[i];\n      var id = toAddEle._private.data.id;\n      var add = !map.has(id);\n      if (add) {\n        var index = this.length++;\n        this[index] = toAddEle;\n        map.set(id, {\n          ele: toAddEle,\n          index: index\n        });\n      }\n    }\n    return this; // chaining\n  },\n\n  unmergeAt: function unmergeAt(i) {\n    var ele = this[i];\n    var id = ele.id();\n    var _p = this._private;\n    var map = _p.map;\n\n    // remove ele\n    this[i] = undefined;\n    map[\"delete\"](id);\n    var unmergedLastEle = i === this.length - 1;\n\n    // replace empty spot with last ele in collection\n    if (this.length > 1 && !unmergedLastEle) {\n      var lastEleI = this.length - 1;\n      var lastEle = this[lastEleI];\n      var lastEleId = lastEle._private.data.id;\n      this[lastEleI] = undefined;\n      this[i] = lastEle;\n      map.set(lastEleId, {\n        ele: lastEle,\n        index: i\n      });\n    }\n\n    // the collection is now 1 ele smaller\n    this.length--;\n    return this;\n  },\n  // remove single ele in place in calling collection\n  unmergeOne: function unmergeOne(ele) {\n    ele = ele[0];\n    var _p = this._private;\n    var id = ele._private.data.id;\n    var map = _p.map;\n    var entry = map.get(id);\n    if (!entry) {\n      return this; // no need to remove\n    }\n\n    var i = entry.index;\n    this.unmergeAt(i);\n    return this;\n  },\n  // remove eles in place on calling collection\n  unmerge: function unmerge(toRemove) {\n    var cy = this._private.cy;\n    if (!toRemove) {\n      return this;\n    }\n    if (toRemove && string(toRemove)) {\n      var selector = toRemove;\n      toRemove = cy.mutableElements().filter(selector);\n    }\n    for (var i = 0; i < toRemove.length; i++) {\n      this.unmergeOne(toRemove[i]);\n    }\n    return this; // chaining\n  },\n\n  unmergeBy: function unmergeBy(toRmFn) {\n    for (var i = this.length - 1; i >= 0; i--) {\n      var ele = this[i];\n      if (toRmFn(ele)) {\n        this.unmergeAt(i);\n      }\n    }\n    return this;\n  },\n  map: function map(mapFn, thisArg) {\n    var arr = [];\n    var eles = this;\n    for (var i = 0; i < eles.length; i++) {\n      var ele = eles[i];\n      var ret = thisArg ? mapFn.apply(thisArg, [ele, i, eles]) : mapFn(ele, i, eles);\n      arr.push(ret);\n    }\n    return arr;\n  },\n  reduce: function reduce(fn, initialValue) {\n    var val = initialValue;\n    var eles = this;\n    for (var i = 0; i < eles.length; i++) {\n      val = fn(val, eles[i], i, eles);\n    }\n    return val;\n  },\n  max: function max(valFn, thisArg) {\n    var max = -Infinity;\n    var maxEle;\n    var eles = this;\n    for (var i = 0; i < eles.length; i++) {\n      var ele = eles[i];\n      var val = thisArg ? valFn.apply(thisArg, [ele, i, eles]) : valFn(ele, i, eles);\n      if (val > max) {\n        max = val;\n        maxEle = ele;\n      }\n    }\n    return {\n      value: max,\n      ele: maxEle\n    };\n  },\n  min: function min(valFn, thisArg) {\n    var min = Infinity;\n    var minEle;\n    var eles = this;\n    for (var i = 0; i < eles.length; i++) {\n      var ele = eles[i];\n      var val = thisArg ? valFn.apply(thisArg, [ele, i, eles]) : valFn(ele, i, eles);\n      if (val < min) {\n        min = val;\n        minEle = ele;\n      }\n    }\n    return {\n      value: min,\n      ele: minEle\n    };\n  }\n};\n\n// aliases\nvar fn$1 = elesfn$8;\nfn$1['u'] = fn$1['|'] = fn$1['+'] = fn$1.union = fn$1.or = fn$1.add;\nfn$1['\\\\'] = fn$1['!'] = fn$1['-'] = fn$1.difference = fn$1.relativeComplement = fn$1.subtract = fn$1.not;\nfn$1['n'] = fn$1['&'] = fn$1['.'] = fn$1.and = fn$1.intersection = fn$1.intersect;\nfn$1['^'] = fn$1['(+)'] = fn$1['(-)'] = fn$1.symmetricDifference = fn$1.symdiff = fn$1.xor;\nfn$1.fnFilter = fn$1.filterFn = fn$1.stdFilter = fn$1.filter;\nfn$1.complement = fn$1.abscomp = fn$1.absoluteComplement;\n\nvar elesfn$7 = {\n  isNode: function isNode() {\n    return this.group() === 'nodes';\n  },\n  isEdge: function isEdge() {\n    return this.group() === 'edges';\n  },\n  isLoop: function isLoop() {\n    return this.isEdge() && this.source()[0] === this.target()[0];\n  },\n  isSimple: function isSimple() {\n    return this.isEdge() && this.source()[0] !== this.target()[0];\n  },\n  group: function group() {\n    var ele = this[0];\n    if (ele) {\n      return ele._private.group;\n    }\n  }\n};\n\n/**\n *  Elements are drawn in a specific order based on compound depth (low to high), the element type (nodes above edges),\n *  and z-index (low to high).  These styles affect how this applies:\n *\n *  z-compound-depth: May be `bottom | orphan | auto | top`.  The first drawn is `bottom`, then `orphan` which is the\n *      same depth as the root of the compound graph, followed by the default value `auto` which draws in order from\n *      root to leaves of the compound graph.  The last drawn is `top`.\n *  z-index-compare: May be `auto | manual`.  The default value is `auto` which always draws edges under nodes.\n *      `manual` ignores this convention and draws based on the `z-index` value setting.\n *  z-index: An integer value that affects the relative draw order of elements.  In general, an element with a higher\n *      `z-index` will be drawn on top of an element with a lower `z-index`.\n */\nvar zIndexSort = function zIndexSort(a, b) {\n  var cy = a.cy();\n  var hasCompoundNodes = cy.hasCompoundNodes();\n  function getDepth(ele) {\n    var style = ele.pstyle('z-compound-depth');\n    if (style.value === 'auto') {\n      return hasCompoundNodes ? ele.zDepth() : 0;\n    } else if (style.value === 'bottom') {\n      return -1;\n    } else if (style.value === 'top') {\n      return MAX_INT$1;\n    }\n    // 'orphan'\n    return 0;\n  }\n  var depthDiff = getDepth(a) - getDepth(b);\n  if (depthDiff !== 0) {\n    return depthDiff;\n  }\n  function getEleDepth(ele) {\n    var style = ele.pstyle('z-index-compare');\n    if (style.value === 'auto') {\n      return ele.isNode() ? 1 : 0;\n    }\n    // 'manual'\n    return 0;\n  }\n  var eleDiff = getEleDepth(a) - getEleDepth(b);\n  if (eleDiff !== 0) {\n    return eleDiff;\n  }\n  var zDiff = a.pstyle('z-index').value - b.pstyle('z-index').value;\n  if (zDiff !== 0) {\n    return zDiff;\n  }\n  // compare indices in the core (order added to graph w/ last on top)\n  return a.poolIndex() - b.poolIndex();\n};\n\nvar elesfn$6 = {\n  forEach: function forEach(fn, thisArg) {\n    if (fn$6(fn)) {\n      var N = this.length;\n      for (var i = 0; i < N; i++) {\n        var ele = this[i];\n        var ret = thisArg ? fn.apply(thisArg, [ele, i, this]) : fn(ele, i, this);\n        if (ret === false) {\n          break;\n        } // exit each early on return false\n      }\n    }\n\n    return this;\n  },\n  toArray: function toArray() {\n    var array = [];\n    for (var i = 0; i < this.length; i++) {\n      array.push(this[i]);\n    }\n    return array;\n  },\n  slice: function slice(start, end) {\n    var array = [];\n    var thisSize = this.length;\n    if (end == null) {\n      end = thisSize;\n    }\n    if (start == null) {\n      start = 0;\n    }\n    if (start < 0) {\n      start = thisSize + start;\n    }\n    if (end < 0) {\n      end = thisSize + end;\n    }\n    for (var i = start; i >= 0 && i < end && i < thisSize; i++) {\n      array.push(this[i]);\n    }\n    return this.spawn(array);\n  },\n  size: function size() {\n    return this.length;\n  },\n  eq: function eq(i) {\n    return this[i] || this.spawn();\n  },\n  first: function first() {\n    return this[0] || this.spawn();\n  },\n  last: function last() {\n    return this[this.length - 1] || this.spawn();\n  },\n  empty: function empty() {\n    return this.length === 0;\n  },\n  nonempty: function nonempty() {\n    return !this.empty();\n  },\n  sort: function sort(sortFn) {\n    if (!fn$6(sortFn)) {\n      return this;\n    }\n    var sorted = this.toArray().sort(sortFn);\n    return this.spawn(sorted);\n  },\n  sortByZIndex: function sortByZIndex() {\n    return this.sort(zIndexSort);\n  },\n  zDepth: function zDepth() {\n    var ele = this[0];\n    if (!ele) {\n      return undefined;\n    }\n\n    // let cy = ele.cy();\n    var _p = ele._private;\n    var group = _p.group;\n    if (group === 'nodes') {\n      var depth = _p.data.parent ? ele.parents().size() : 0;\n      if (!ele.isParent()) {\n        return MAX_INT$1 - 1; // childless nodes always on top\n      }\n\n      return depth;\n    } else {\n      var src = _p.source;\n      var tgt = _p.target;\n      var srcDepth = src.zDepth();\n      var tgtDepth = tgt.zDepth();\n      return Math.max(srcDepth, tgtDepth, 0); // depth of deepest parent\n    }\n  }\n};\n\nelesfn$6.each = elesfn$6.forEach;\nvar defineSymbolIterator = function defineSymbolIterator() {\n  var typeofUndef = \"undefined\" ;\n  var isIteratorSupported = (typeof Symbol === \"undefined\" ? \"undefined\" : _typeof(Symbol)) != typeofUndef && _typeof(Symbol.iterator) != typeofUndef; // eslint-disable-line no-undef\n\n  if (isIteratorSupported) {\n    elesfn$6[Symbol.iterator] = function () {\n      var _this = this;\n      // eslint-disable-line no-undef\n      var entry = {\n        value: undefined,\n        done: false\n      };\n      var i = 0;\n      var length = this.length;\n      return _defineProperty$1({\n        next: function next() {\n          if (i < length) {\n            entry.value = _this[i++];\n          } else {\n            entry.value = undefined;\n            entry.done = true;\n          }\n          return entry;\n        }\n      }, Symbol.iterator, function () {\n        // eslint-disable-line no-undef\n        return this;\n      });\n    };\n  }\n};\ndefineSymbolIterator();\n\nvar getLayoutDimensionOptions = defaults$g({\n  nodeDimensionsIncludeLabels: false\n});\nvar elesfn$5 = {\n  // Calculates and returns node dimensions { x, y } based on options given\n  layoutDimensions: function layoutDimensions(options) {\n    options = getLayoutDimensionOptions(options);\n    var dims;\n    if (!this.takesUpSpace()) {\n      dims = {\n        w: 0,\n        h: 0\n      };\n    } else if (options.nodeDimensionsIncludeLabels) {\n      var bbDim = this.boundingBox();\n      dims = {\n        w: bbDim.w,\n        h: bbDim.h\n      };\n    } else {\n      dims = {\n        w: this.outerWidth(),\n        h: this.outerHeight()\n      };\n    }\n\n    // sanitise the dimensions for external layouts (avoid division by zero)\n    if (dims.w === 0 || dims.h === 0) {\n      dims.w = dims.h = 1;\n    }\n    return dims;\n  },\n  // using standard layout options, apply position function (w/ or w/o animation)\n  layoutPositions: function layoutPositions(layout, options, fn) {\n    var nodes = this.nodes().filter(function (n) {\n      return !n.isParent();\n    });\n    var cy = this.cy();\n    var layoutEles = options.eles; // nodes & edges\n    var getMemoizeKey = function getMemoizeKey(node) {\n      return node.id();\n    };\n    var fnMem = memoize$1(fn, getMemoizeKey); // memoized version of position function\n\n    layout.emit({\n      type: 'layoutstart',\n      layout: layout\n    });\n    layout.animations = [];\n    var calculateSpacing = function calculateSpacing(spacing, nodesBb, pos) {\n      var center = {\n        x: nodesBb.x1 + nodesBb.w / 2,\n        y: nodesBb.y1 + nodesBb.h / 2\n      };\n      var spacingVector = {\n        // scale from center of bounding box (not necessarily 0,0)\n        x: (pos.x - center.x) * spacing,\n        y: (pos.y - center.y) * spacing\n      };\n      return {\n        x: center.x + spacingVector.x,\n        y: center.y + spacingVector.y\n      };\n    };\n    var useSpacingFactor = options.spacingFactor && options.spacingFactor !== 1;\n    var spacingBb = function spacingBb() {\n      if (!useSpacingFactor) {\n        return null;\n      }\n      var bb = makeBoundingBox();\n      for (var i = 0; i < nodes.length; i++) {\n        var node = nodes[i];\n        var pos = fnMem(node, i);\n        expandBoundingBoxByPoint(bb, pos.x, pos.y);\n      }\n      return bb;\n    };\n    var bb = spacingBb();\n    var getFinalPos = memoize$1(function (node, i) {\n      var newPos = fnMem(node, i);\n      if (useSpacingFactor) {\n        var spacing = Math.abs(options.spacingFactor);\n        newPos = calculateSpacing(spacing, bb, newPos);\n      }\n      if (options.transform != null) {\n        newPos = options.transform(node, newPos);\n      }\n      return newPos;\n    }, getMemoizeKey);\n    if (options.animate) {\n      for (var i = 0; i < nodes.length; i++) {\n        var node = nodes[i];\n        var newPos = getFinalPos(node, i);\n        var animateNode = options.animateFilter == null || options.animateFilter(node, i);\n        if (animateNode) {\n          var ani = node.animation({\n            position: newPos,\n            duration: options.animationDuration,\n            easing: options.animationEasing\n          });\n          layout.animations.push(ani);\n        } else {\n          node.position(newPos);\n        }\n      }\n      if (options.fit) {\n        var fitAni = cy.animation({\n          fit: {\n            boundingBox: layoutEles.boundingBoxAt(getFinalPos),\n            padding: options.padding\n          },\n          duration: options.animationDuration,\n          easing: options.animationEasing\n        });\n        layout.animations.push(fitAni);\n      } else if (options.zoom !== undefined && options.pan !== undefined) {\n        var zoomPanAni = cy.animation({\n          zoom: options.zoom,\n          pan: options.pan,\n          duration: options.animationDuration,\n          easing: options.animationEasing\n        });\n        layout.animations.push(zoomPanAni);\n      }\n      layout.animations.forEach(function (ani) {\n        return ani.play();\n      });\n      layout.one('layoutready', options.ready);\n      layout.emit({\n        type: 'layoutready',\n        layout: layout\n      });\n      Promise$1.all(layout.animations.map(function (ani) {\n        return ani.promise();\n      })).then(function () {\n        layout.one('layoutstop', options.stop);\n        layout.emit({\n          type: 'layoutstop',\n          layout: layout\n        });\n      });\n    } else {\n      nodes.positions(getFinalPos);\n      if (options.fit) {\n        cy.fit(options.eles, options.padding);\n      }\n      if (options.zoom != null) {\n        cy.zoom(options.zoom);\n      }\n      if (options.pan) {\n        cy.pan(options.pan);\n      }\n      layout.one('layoutready', options.ready);\n      layout.emit({\n        type: 'layoutready',\n        layout: layout\n      });\n      layout.one('layoutstop', options.stop);\n      layout.emit({\n        type: 'layoutstop',\n        layout: layout\n      });\n    }\n    return this; // chaining\n  },\n\n  layout: function layout(options) {\n    var cy = this.cy();\n    return cy.makeLayout(extend({}, options, {\n      eles: this\n    }));\n  }\n};\n\n// aliases:\nelesfn$5.createLayout = elesfn$5.makeLayout = elesfn$5.layout;\n\nfunction styleCache(key, fn, ele) {\n  var _p = ele._private;\n  var cache = _p.styleCache = _p.styleCache || [];\n  var val;\n  if ((val = cache[key]) != null) {\n    return val;\n  } else {\n    val = cache[key] = fn(ele);\n    return val;\n  }\n}\nfunction cacheStyleFunction(key, fn) {\n  key = hashString(key);\n  return function cachedStyleFunction(ele) {\n    return styleCache(key, fn, ele);\n  };\n}\nfunction cachePrototypeStyleFunction(key, fn) {\n  key = hashString(key);\n  var selfFn = function selfFn(ele) {\n    return fn.call(ele);\n  };\n  return function cachedPrototypeStyleFunction() {\n    var ele = this[0];\n    if (ele) {\n      return styleCache(key, selfFn, ele);\n    }\n  };\n}\nvar elesfn$4 = {\n  recalculateRenderedStyle: function recalculateRenderedStyle(useCache) {\n    var cy = this.cy();\n    var renderer = cy.renderer();\n    var styleEnabled = cy.styleEnabled();\n    if (renderer && styleEnabled) {\n      renderer.recalculateRenderedStyle(this, useCache);\n    }\n    return this;\n  },\n  dirtyStyleCache: function dirtyStyleCache() {\n    var cy = this.cy();\n    var dirty = function dirty(ele) {\n      return ele._private.styleCache = null;\n    };\n    if (cy.hasCompoundNodes()) {\n      var eles;\n      eles = this.spawnSelf().merge(this.descendants()).merge(this.parents());\n      eles.merge(eles.connectedEdges());\n      eles.forEach(dirty);\n    } else {\n      this.forEach(function (ele) {\n        dirty(ele);\n        ele.connectedEdges().forEach(dirty);\n      });\n    }\n    return this;\n  },\n  // fully updates (recalculates) the style for the elements\n  updateStyle: function updateStyle(notifyRenderer) {\n    var cy = this._private.cy;\n    if (!cy.styleEnabled()) {\n      return this;\n    }\n    if (cy.batching()) {\n      var bEles = cy._private.batchStyleEles;\n      bEles.merge(this);\n      return this; // chaining and exit early when batching\n    }\n\n    var hasCompounds = cy.hasCompoundNodes();\n    var updatedEles = this;\n    notifyRenderer = notifyRenderer || notifyRenderer === undefined ? true : false;\n    if (hasCompounds) {\n      // then add everything up and down for compound selector checks\n      updatedEles = this.spawnSelf().merge(this.descendants()).merge(this.parents());\n    }\n\n    // let changedEles = style.apply( updatedEles );\n    var changedEles = updatedEles;\n    if (notifyRenderer) {\n      changedEles.emitAndNotify('style'); // let renderer know we changed style\n    } else {\n      changedEles.emit('style'); // just fire the event\n    }\n\n    updatedEles.forEach(function (ele) {\n      return ele._private.styleDirty = true;\n    });\n    return this; // chaining\n  },\n\n  // private: clears dirty flag and recalculates style\n  cleanStyle: function cleanStyle() {\n    var cy = this.cy();\n    if (!cy.styleEnabled()) {\n      return;\n    }\n    for (var i = 0; i < this.length; i++) {\n      var ele = this[i];\n      if (ele._private.styleDirty) {\n        // n.b. this flag should be set before apply() to avoid potential infinite recursion\n        ele._private.styleDirty = false;\n        cy.style().apply(ele);\n      }\n    }\n  },\n  // get the internal parsed style object for the specified property\n  parsedStyle: function parsedStyle(property) {\n    var includeNonDefault = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    var ele = this[0];\n    var cy = ele.cy();\n    if (!cy.styleEnabled()) {\n      return;\n    }\n    if (ele) {\n      this.cleanStyle();\n      var overriddenStyle = ele._private.style[property];\n      if (overriddenStyle != null) {\n        return overriddenStyle;\n      } else if (includeNonDefault) {\n        return cy.style().getDefaultProperty(property);\n      } else {\n        return null;\n      }\n    }\n  },\n  numericStyle: function numericStyle(property) {\n    var ele = this[0];\n    if (!ele.cy().styleEnabled()) {\n      return;\n    }\n    if (ele) {\n      var pstyle = ele.pstyle(property);\n      return pstyle.pfValue !== undefined ? pstyle.pfValue : pstyle.value;\n    }\n  },\n  numericStyleUnits: function numericStyleUnits(property) {\n    var ele = this[0];\n    if (!ele.cy().styleEnabled()) {\n      return;\n    }\n    if (ele) {\n      return ele.pstyle(property).units;\n    }\n  },\n  // get the specified css property as a rendered value (i.e. on-screen value)\n  // or get the whole rendered style if no property specified (NB doesn't allow setting)\n  renderedStyle: function renderedStyle(property) {\n    var cy = this.cy();\n    if (!cy.styleEnabled()) {\n      return this;\n    }\n    var ele = this[0];\n    if (ele) {\n      return cy.style().getRenderedStyle(ele, property);\n    }\n  },\n  // read the calculated css style of the element or override the style (via a bypass)\n  style: function style(name, value) {\n    var cy = this.cy();\n    if (!cy.styleEnabled()) {\n      return this;\n    }\n    var updateTransitions = false;\n    var style = cy.style();\n    if (plainObject(name)) {\n      // then extend the bypass\n      var props = name;\n      style.applyBypass(this, props, updateTransitions);\n      this.emitAndNotify('style'); // let the renderer know we've updated style\n    } else if (string(name)) {\n      if (value === undefined) {\n        // then get the property from the style\n        var ele = this[0];\n        if (ele) {\n          return style.getStylePropertyValue(ele, name);\n        } else {\n          // empty collection => can't get any value\n          return;\n        }\n      } else {\n        // then set the bypass with the property value\n        style.applyBypass(this, name, value, updateTransitions);\n        this.emitAndNotify('style'); // let the renderer know we've updated style\n      }\n    } else if (name === undefined) {\n      var _ele = this[0];\n      if (_ele) {\n        return style.getRawStyle(_ele);\n      } else {\n        // empty collection => can't get any value\n        return;\n      }\n    }\n    return this; // chaining\n  },\n\n  removeStyle: function removeStyle(names) {\n    var cy = this.cy();\n    if (!cy.styleEnabled()) {\n      return this;\n    }\n    var updateTransitions = false;\n    var style = cy.style();\n    var eles = this;\n    if (names === undefined) {\n      for (var i = 0; i < eles.length; i++) {\n        var ele = eles[i];\n        style.removeAllBypasses(ele, updateTransitions);\n      }\n    } else {\n      names = names.split(/\\s+/);\n      for (var _i = 0; _i < eles.length; _i++) {\n        var _ele2 = eles[_i];\n        style.removeBypasses(_ele2, names, updateTransitions);\n      }\n    }\n    this.emitAndNotify('style'); // let the renderer know we've updated style\n\n    return this; // chaining\n  },\n\n  show: function show() {\n    this.css('display', 'element');\n    return this; // chaining\n  },\n\n  hide: function hide() {\n    this.css('display', 'none');\n    return this; // chaining\n  },\n\n  effectiveOpacity: function effectiveOpacity() {\n    var cy = this.cy();\n    if (!cy.styleEnabled()) {\n      return 1;\n    }\n    var hasCompoundNodes = cy.hasCompoundNodes();\n    var ele = this[0];\n    if (ele) {\n      var _p = ele._private;\n      var parentOpacity = ele.pstyle('opacity').value;\n      if (!hasCompoundNodes) {\n        return parentOpacity;\n      }\n      var parents = !_p.data.parent ? null : ele.parents();\n      if (parents) {\n        for (var i = 0; i < parents.length; i++) {\n          var parent = parents[i];\n          var opacity = parent.pstyle('opacity').value;\n          parentOpacity = opacity * parentOpacity;\n        }\n      }\n      return parentOpacity;\n    }\n  },\n  transparent: function transparent() {\n    var cy = this.cy();\n    if (!cy.styleEnabled()) {\n      return false;\n    }\n    var ele = this[0];\n    var hasCompoundNodes = ele.cy().hasCompoundNodes();\n    if (ele) {\n      if (!hasCompoundNodes) {\n        return ele.pstyle('opacity').value === 0;\n      } else {\n        return ele.effectiveOpacity() === 0;\n      }\n    }\n  },\n  backgrounding: function backgrounding() {\n    var cy = this.cy();\n    if (!cy.styleEnabled()) {\n      return false;\n    }\n    var ele = this[0];\n    return ele._private.backgrounding ? true : false;\n  }\n};\nfunction checkCompound(ele, parentOk) {\n  var _p = ele._private;\n  var parents = _p.data.parent ? ele.parents() : null;\n  if (parents) {\n    for (var i = 0; i < parents.length; i++) {\n      var parent = parents[i];\n      if (!parentOk(parent)) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\nfunction defineDerivedStateFunction(specs) {\n  var ok = specs.ok;\n  var edgeOkViaNode = specs.edgeOkViaNode || specs.ok;\n  var parentOk = specs.parentOk || specs.ok;\n  return function () {\n    var cy = this.cy();\n    if (!cy.styleEnabled()) {\n      return true;\n    }\n    var ele = this[0];\n    var hasCompoundNodes = cy.hasCompoundNodes();\n    if (ele) {\n      var _p = ele._private;\n      if (!ok(ele)) {\n        return false;\n      }\n      if (ele.isNode()) {\n        return !hasCompoundNodes || checkCompound(ele, parentOk);\n      } else {\n        var src = _p.source;\n        var tgt = _p.target;\n        return edgeOkViaNode(src) && (!hasCompoundNodes || checkCompound(src, edgeOkViaNode)) && (src === tgt || edgeOkViaNode(tgt) && (!hasCompoundNodes || checkCompound(tgt, edgeOkViaNode)));\n      }\n    }\n  };\n}\nvar eleTakesUpSpace = cacheStyleFunction('eleTakesUpSpace', function (ele) {\n  return ele.pstyle('display').value === 'element' && ele.width() !== 0 && (ele.isNode() ? ele.height() !== 0 : true);\n});\nelesfn$4.takesUpSpace = cachePrototypeStyleFunction('takesUpSpace', defineDerivedStateFunction({\n  ok: eleTakesUpSpace\n}));\nvar eleInteractive = cacheStyleFunction('eleInteractive', function (ele) {\n  return ele.pstyle('events').value === 'yes' && ele.pstyle('visibility').value === 'visible' && eleTakesUpSpace(ele);\n});\nvar parentInteractive = cacheStyleFunction('parentInteractive', function (parent) {\n  return parent.pstyle('visibility').value === 'visible' && eleTakesUpSpace(parent);\n});\nelesfn$4.interactive = cachePrototypeStyleFunction('interactive', defineDerivedStateFunction({\n  ok: eleInteractive,\n  parentOk: parentInteractive,\n  edgeOkViaNode: eleTakesUpSpace\n}));\nelesfn$4.noninteractive = function () {\n  var ele = this[0];\n  if (ele) {\n    return !ele.interactive();\n  }\n};\nvar eleVisible = cacheStyleFunction('eleVisible', function (ele) {\n  return ele.pstyle('visibility').value === 'visible' && ele.pstyle('opacity').pfValue !== 0 && eleTakesUpSpace(ele);\n});\nvar edgeVisibleViaNode = eleTakesUpSpace;\nelesfn$4.visible = cachePrototypeStyleFunction('visible', defineDerivedStateFunction({\n  ok: eleVisible,\n  edgeOkViaNode: edgeVisibleViaNode\n}));\nelesfn$4.hidden = function () {\n  var ele = this[0];\n  if (ele) {\n    return !ele.visible();\n  }\n};\nelesfn$4.isBundledBezier = cachePrototypeStyleFunction('isBundledBezier', function () {\n  if (!this.cy().styleEnabled()) {\n    return false;\n  }\n  return !this.removed() && this.pstyle('curve-style').value === 'bezier' && this.takesUpSpace();\n});\nelesfn$4.bypass = elesfn$4.css = elesfn$4.style;\nelesfn$4.renderedCss = elesfn$4.renderedStyle;\nelesfn$4.removeBypass = elesfn$4.removeCss = elesfn$4.removeStyle;\nelesfn$4.pstyle = elesfn$4.parsedStyle;\n\nvar elesfn$3 = {};\nfunction defineSwitchFunction(params) {\n  return function () {\n    var args = arguments;\n    var changedEles = [];\n\n    // e.g. cy.nodes().select( data, handler )\n    if (args.length === 2) {\n      var data = args[0];\n      var handler = args[1];\n      this.on(params.event, data, handler);\n    }\n\n    // e.g. cy.nodes().select( handler )\n    else if (args.length === 1 && fn$6(args[0])) {\n      var _handler = args[0];\n      this.on(params.event, _handler);\n    }\n\n    // e.g. cy.nodes().select()\n    // e.g. (private) cy.nodes().select(['tapselect'])\n    else if (args.length === 0 || args.length === 1 && array(args[0])) {\n      var addlEvents = args.length === 1 ? args[0] : null;\n      for (var i = 0; i < this.length; i++) {\n        var ele = this[i];\n        var able = !params.ableField || ele._private[params.ableField];\n        var changed = ele._private[params.field] != params.value;\n        if (params.overrideAble) {\n          var overrideAble = params.overrideAble(ele);\n          if (overrideAble !== undefined) {\n            able = overrideAble;\n            if (!overrideAble) {\n              return this;\n            } // to save cycles assume not able for all on override\n          }\n        }\n\n        if (able) {\n          ele._private[params.field] = params.value;\n          if (changed) {\n            changedEles.push(ele);\n          }\n        }\n      }\n      var changedColl = this.spawn(changedEles);\n      changedColl.updateStyle(); // change of state => possible change of style\n      changedColl.emit(params.event);\n      if (addlEvents) {\n        changedColl.emit(addlEvents);\n      }\n    }\n    return this;\n  };\n}\nfunction defineSwitchSet(params) {\n  elesfn$3[params.field] = function () {\n    var ele = this[0];\n    if (ele) {\n      if (params.overrideField) {\n        var val = params.overrideField(ele);\n        if (val !== undefined) {\n          return val;\n        }\n      }\n      return ele._private[params.field];\n    }\n  };\n  elesfn$3[params.on] = defineSwitchFunction({\n    event: params.on,\n    field: params.field,\n    ableField: params.ableField,\n    overrideAble: params.overrideAble,\n    value: true\n  });\n  elesfn$3[params.off] = defineSwitchFunction({\n    event: params.off,\n    field: params.field,\n    ableField: params.ableField,\n    overrideAble: params.overrideAble,\n    value: false\n  });\n}\ndefineSwitchSet({\n  field: 'locked',\n  overrideField: function overrideField(ele) {\n    return ele.cy().autolock() ? true : undefined;\n  },\n  on: 'lock',\n  off: 'unlock'\n});\ndefineSwitchSet({\n  field: 'grabbable',\n  overrideField: function overrideField(ele) {\n    return ele.cy().autoungrabify() || ele.pannable() ? false : undefined;\n  },\n  on: 'grabify',\n  off: 'ungrabify'\n});\ndefineSwitchSet({\n  field: 'selected',\n  ableField: 'selectable',\n  overrideAble: function overrideAble(ele) {\n    return ele.cy().autounselectify() ? false : undefined;\n  },\n  on: 'select',\n  off: 'unselect'\n});\ndefineSwitchSet({\n  field: 'selectable',\n  overrideField: function overrideField(ele) {\n    return ele.cy().autounselectify() ? false : undefined;\n  },\n  on: 'selectify',\n  off: 'unselectify'\n});\nelesfn$3.deselect = elesfn$3.unselect;\nelesfn$3.grabbed = function () {\n  var ele = this[0];\n  if (ele) {\n    return ele._private.grabbed;\n  }\n};\ndefineSwitchSet({\n  field: 'active',\n  on: 'activate',\n  off: 'unactivate'\n});\ndefineSwitchSet({\n  field: 'pannable',\n  on: 'panify',\n  off: 'unpanify'\n});\nelesfn$3.inactive = function () {\n  var ele = this[0];\n  if (ele) {\n    return !ele._private.active;\n  }\n};\n\nvar elesfn$2 = {};\n\n// DAG functions\n////////////////\n\nvar defineDagExtremity = function defineDagExtremity(params) {\n  return function dagExtremityImpl(selector) {\n    var eles = this;\n    var ret = [];\n    for (var i = 0; i < eles.length; i++) {\n      var ele = eles[i];\n      if (!ele.isNode()) {\n        continue;\n      }\n      var disqualified = false;\n      var edges = ele.connectedEdges();\n      for (var j = 0; j < edges.length; j++) {\n        var edge = edges[j];\n        var src = edge.source();\n        var tgt = edge.target();\n        if (params.noIncomingEdges && tgt === ele && src !== ele || params.noOutgoingEdges && src === ele && tgt !== ele) {\n          disqualified = true;\n          break;\n        }\n      }\n      if (!disqualified) {\n        ret.push(ele);\n      }\n    }\n    return this.spawn(ret, true).filter(selector);\n  };\n};\nvar defineDagOneHop = function defineDagOneHop(params) {\n  return function (selector) {\n    var eles = this;\n    var oEles = [];\n    for (var i = 0; i < eles.length; i++) {\n      var ele = eles[i];\n      if (!ele.isNode()) {\n        continue;\n      }\n      var edges = ele.connectedEdges();\n      for (var j = 0; j < edges.length; j++) {\n        var edge = edges[j];\n        var src = edge.source();\n        var tgt = edge.target();\n        if (params.outgoing && src === ele) {\n          oEles.push(edge);\n          oEles.push(tgt);\n        } else if (params.incoming && tgt === ele) {\n          oEles.push(edge);\n          oEles.push(src);\n        }\n      }\n    }\n    return this.spawn(oEles, true).filter(selector);\n  };\n};\nvar defineDagAllHops = function defineDagAllHops(params) {\n  return function (selector) {\n    var eles = this;\n    var sEles = [];\n    var sElesIds = {};\n    for (;;) {\n      var next = params.outgoing ? eles.outgoers() : eles.incomers();\n      if (next.length === 0) {\n        break;\n      } // done if none left\n\n      var newNext = false;\n      for (var i = 0; i < next.length; i++) {\n        var n = next[i];\n        var nid = n.id();\n        if (!sElesIds[nid]) {\n          sElesIds[nid] = true;\n          sEles.push(n);\n          newNext = true;\n        }\n      }\n      if (!newNext) {\n        break;\n      } // done if touched all outgoers already\n\n      eles = next;\n    }\n    return this.spawn(sEles, true).filter(selector);\n  };\n};\nelesfn$2.clearTraversalCache = function () {\n  for (var i = 0; i < this.length; i++) {\n    this[i]._private.traversalCache = null;\n  }\n};\nextend(elesfn$2, {\n  // get the root nodes in the DAG\n  roots: defineDagExtremity({\n    noIncomingEdges: true\n  }),\n  // get the leaf nodes in the DAG\n  leaves: defineDagExtremity({\n    noOutgoingEdges: true\n  }),\n  // normally called children in graph theory\n  // these nodes =edges=> outgoing nodes\n  outgoers: cache(defineDagOneHop({\n    outgoing: true\n  }), 'outgoers'),\n  // aka DAG descendants\n  successors: defineDagAllHops({\n    outgoing: true\n  }),\n  // normally called parents in graph theory\n  // these nodes <=edges= incoming nodes\n  incomers: cache(defineDagOneHop({\n    incoming: true\n  }), 'incomers'),\n  // aka DAG ancestors\n  predecessors: defineDagAllHops({\n    incoming: true\n  })\n});\n\n// Neighbourhood functions\n//////////////////////////\n\nextend(elesfn$2, {\n  neighborhood: cache(function (selector) {\n    var elements = [];\n    var nodes = this.nodes();\n    for (var i = 0; i < nodes.length; i++) {\n      // for all nodes\n      var node = nodes[i];\n      var connectedEdges = node.connectedEdges();\n\n      // for each connected edge, add the edge and the other node\n      for (var j = 0; j < connectedEdges.length; j++) {\n        var edge = connectedEdges[j];\n        var src = edge.source();\n        var tgt = edge.target();\n        var otherNode = node === src ? tgt : src;\n\n        // need check in case of loop\n        if (otherNode.length > 0) {\n          elements.push(otherNode[0]); // add node 1 hop away\n        }\n\n        // add connected edge\n        elements.push(edge[0]);\n      }\n    }\n    return this.spawn(elements, true).filter(selector);\n  }, 'neighborhood'),\n  closedNeighborhood: function closedNeighborhood(selector) {\n    return this.neighborhood().add(this).filter(selector);\n  },\n  openNeighborhood: function openNeighborhood(selector) {\n    return this.neighborhood(selector);\n  }\n});\n\n// aliases\nelesfn$2.neighbourhood = elesfn$2.neighborhood;\nelesfn$2.closedNeighbourhood = elesfn$2.closedNeighborhood;\nelesfn$2.openNeighbourhood = elesfn$2.openNeighborhood;\n\n// Edge functions\n/////////////////\n\nextend(elesfn$2, {\n  source: cache(function sourceImpl(selector) {\n    var ele = this[0];\n    var src;\n    if (ele) {\n      src = ele._private.source || ele.cy().collection();\n    }\n    return src && selector ? src.filter(selector) : src;\n  }, 'source'),\n  target: cache(function targetImpl(selector) {\n    var ele = this[0];\n    var tgt;\n    if (ele) {\n      tgt = ele._private.target || ele.cy().collection();\n    }\n    return tgt && selector ? tgt.filter(selector) : tgt;\n  }, 'target'),\n  sources: defineSourceFunction({\n    attr: 'source'\n  }),\n  targets: defineSourceFunction({\n    attr: 'target'\n  })\n});\nfunction defineSourceFunction(params) {\n  return function sourceImpl(selector) {\n    var sources = [];\n    for (var i = 0; i < this.length; i++) {\n      var ele = this[i];\n      var src = ele._private[params.attr];\n      if (src) {\n        sources.push(src);\n      }\n    }\n    return this.spawn(sources, true).filter(selector);\n  };\n}\nextend(elesfn$2, {\n  edgesWith: cache(defineEdgesWithFunction(), 'edgesWith'),\n  edgesTo: cache(defineEdgesWithFunction({\n    thisIsSrc: true\n  }), 'edgesTo')\n});\nfunction defineEdgesWithFunction(params) {\n  return function edgesWithImpl(otherNodes) {\n    var elements = [];\n    var cy = this._private.cy;\n    var p = params || {};\n\n    // get elements if a selector is specified\n    if (string(otherNodes)) {\n      otherNodes = cy.$(otherNodes);\n    }\n    for (var h = 0; h < otherNodes.length; h++) {\n      var edges = otherNodes[h]._private.edges;\n      for (var i = 0; i < edges.length; i++) {\n        var edge = edges[i];\n        var edgeData = edge._private.data;\n        var thisToOther = this.hasElementWithId(edgeData.source) && otherNodes.hasElementWithId(edgeData.target);\n        var otherToThis = otherNodes.hasElementWithId(edgeData.source) && this.hasElementWithId(edgeData.target);\n        var edgeConnectsThisAndOther = thisToOther || otherToThis;\n        if (!edgeConnectsThisAndOther) {\n          continue;\n        }\n        if (p.thisIsSrc || p.thisIsTgt) {\n          if (p.thisIsSrc && !thisToOther) {\n            continue;\n          }\n          if (p.thisIsTgt && !otherToThis) {\n            continue;\n          }\n        }\n        elements.push(edge);\n      }\n    }\n    return this.spawn(elements, true);\n  };\n}\nextend(elesfn$2, {\n  connectedEdges: cache(function (selector) {\n    var retEles = [];\n    var eles = this;\n    for (var i = 0; i < eles.length; i++) {\n      var node = eles[i];\n      if (!node.isNode()) {\n        continue;\n      }\n      var edges = node._private.edges;\n      for (var j = 0; j < edges.length; j++) {\n        var edge = edges[j];\n        retEles.push(edge);\n      }\n    }\n    return this.spawn(retEles, true).filter(selector);\n  }, 'connectedEdges'),\n  connectedNodes: cache(function (selector) {\n    var retEles = [];\n    var eles = this;\n    for (var i = 0; i < eles.length; i++) {\n      var edge = eles[i];\n      if (!edge.isEdge()) {\n        continue;\n      }\n      retEles.push(edge.source()[0]);\n      retEles.push(edge.target()[0]);\n    }\n    return this.spawn(retEles, true).filter(selector);\n  }, 'connectedNodes'),\n  parallelEdges: cache(defineParallelEdgesFunction(), 'parallelEdges'),\n  codirectedEdges: cache(defineParallelEdgesFunction({\n    codirected: true\n  }), 'codirectedEdges')\n});\nfunction defineParallelEdgesFunction(params) {\n  var defaults = {\n    codirected: false\n  };\n  params = extend({}, defaults, params);\n  return function parallelEdgesImpl(selector) {\n    // micro-optimised for renderer\n    var elements = [];\n    var edges = this.edges();\n    var p = params;\n\n    // look at all the edges in the collection\n    for (var i = 0; i < edges.length; i++) {\n      var edge1 = edges[i];\n      var edge1_p = edge1._private;\n      var src1 = edge1_p.source;\n      var srcid1 = src1._private.data.id;\n      var tgtid1 = edge1_p.data.target;\n      var srcEdges1 = src1._private.edges;\n\n      // look at edges connected to the src node of this edge\n      for (var j = 0; j < srcEdges1.length; j++) {\n        var edge2 = srcEdges1[j];\n        var edge2data = edge2._private.data;\n        var tgtid2 = edge2data.target;\n        var srcid2 = edge2data.source;\n        var codirected = tgtid2 === tgtid1 && srcid2 === srcid1;\n        var oppdirected = srcid1 === tgtid2 && tgtid1 === srcid2;\n        if (p.codirected && codirected || !p.codirected && (codirected || oppdirected)) {\n          elements.push(edge2);\n        }\n      }\n    }\n    return this.spawn(elements, true).filter(selector);\n  };\n}\n\n// Misc functions\n/////////////////\n\nextend(elesfn$2, {\n  components: function components(root) {\n    var self = this;\n    var cy = self.cy();\n    var visited = cy.collection();\n    var unvisited = root == null ? self.nodes() : root.nodes();\n    var components = [];\n    if (root != null && unvisited.empty()) {\n      // root may contain only edges\n      unvisited = root.sources(); // doesn't matter which node to use (undirected), so just use the source sides\n    }\n\n    var visitInComponent = function visitInComponent(node, component) {\n      visited.merge(node);\n      unvisited.unmerge(node);\n      component.merge(node);\n    };\n    if (unvisited.empty()) {\n      return self.spawn();\n    }\n    var _loop = function _loop() {\n      // each iteration yields a component\n      var cmpt = cy.collection();\n      components.push(cmpt);\n      var root = unvisited[0];\n      visitInComponent(root, cmpt);\n      self.bfs({\n        directed: false,\n        roots: root,\n        visit: function visit(v) {\n          return visitInComponent(v, cmpt);\n        }\n      });\n      cmpt.forEach(function (node) {\n        node.connectedEdges().forEach(function (e) {\n          // connectedEdges() usually cached\n          if (self.has(e) && cmpt.has(e.source()) && cmpt.has(e.target())) {\n            // has() is cheap\n            cmpt.merge(e); // forEach() only considers nodes -- sets N at call time\n          }\n        });\n      });\n    };\n    do {\n      _loop();\n    } while (unvisited.length > 0);\n    return components;\n  },\n  component: function component() {\n    var ele = this[0];\n    return ele.cy().mutableElements().components(ele)[0];\n  }\n});\nelesfn$2.componentsOf = elesfn$2.components;\n\n// represents a set of nodes, edges, or both together\nvar Collection = function Collection(cy, elements) {\n  var unique = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  var removed = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  if (cy === undefined) {\n    error('A collection must have a reference to the core');\n    return;\n  }\n  var map = new Map$2();\n  var createdElements = false;\n  if (!elements) {\n    elements = [];\n  } else if (elements.length > 0 && plainObject(elements[0]) && !element(elements[0])) {\n    createdElements = true;\n\n    // make elements from json and restore all at once later\n    var eles = [];\n    var elesIds = new Set$1();\n    for (var i = 0, l = elements.length; i < l; i++) {\n      var json = elements[i];\n      if (json.data == null) {\n        json.data = {};\n      }\n      var _data = json.data;\n\n      // make sure newly created elements have valid ids\n      if (_data.id == null) {\n        _data.id = uuid();\n      } else if (cy.hasElementWithId(_data.id) || elesIds.has(_data.id)) {\n        continue; // can't create element if prior id already exists\n      }\n\n      var ele = new Element(cy, json, false);\n      eles.push(ele);\n      elesIds.add(_data.id);\n    }\n    elements = eles;\n  }\n  this.length = 0;\n  for (var _i = 0, _l = elements.length; _i < _l; _i++) {\n    var element$1 = elements[_i][0]; // [0] in case elements is an array of collections, rather than array of elements\n    if (element$1 == null) {\n      continue;\n    }\n    var id = element$1._private.data.id;\n    if (!unique || !map.has(id)) {\n      if (unique) {\n        map.set(id, {\n          index: this.length,\n          ele: element$1\n        });\n      }\n      this[this.length] = element$1;\n      this.length++;\n    }\n  }\n  this._private = {\n    eles: this,\n    cy: cy,\n    get map() {\n      if (this.lazyMap == null) {\n        this.rebuildMap();\n      }\n      return this.lazyMap;\n    },\n    set map(m) {\n      this.lazyMap = m;\n    },\n    rebuildMap: function rebuildMap() {\n      var m = this.lazyMap = new Map$2();\n      var eles = this.eles;\n      for (var _i2 = 0; _i2 < eles.length; _i2++) {\n        var _ele = eles[_i2];\n        m.set(_ele.id(), {\n          index: _i2,\n          ele: _ele\n        });\n      }\n    }\n  };\n  if (unique) {\n    this._private.map = map;\n  }\n\n  // restore the elements if we created them from json\n  if (createdElements && !removed) {\n    this.restore();\n  }\n};\n\n// Functions\n////////////////////////////////////////////////////////////////////////////////////////////////////\n\n// keep the prototypes in sync (an element has the same functions as a collection)\n// and use elefn and elesfn as shorthands to the prototypes\nvar elesfn$1 = Element.prototype = Collection.prototype = Object.create(Array.prototype);\nelesfn$1.instanceString = function () {\n  return 'collection';\n};\nelesfn$1.spawn = function (eles, unique) {\n  return new Collection(this.cy(), eles, unique);\n};\nelesfn$1.spawnSelf = function () {\n  return this.spawn(this);\n};\nelesfn$1.cy = function () {\n  return this._private.cy;\n};\nelesfn$1.renderer = function () {\n  return this._private.cy.renderer();\n};\nelesfn$1.element = function () {\n  return this[0];\n};\nelesfn$1.collection = function () {\n  if (collection(this)) {\n    return this;\n  } else {\n    // an element\n    return new Collection(this._private.cy, [this]);\n  }\n};\nelesfn$1.unique = function () {\n  return new Collection(this._private.cy, this, true);\n};\nelesfn$1.hasElementWithId = function (id) {\n  id = '' + id; // id must be string\n\n  return this._private.map.has(id);\n};\nelesfn$1.getElementById = function (id) {\n  id = '' + id; // id must be string\n\n  var cy = this._private.cy;\n  var entry = this._private.map.get(id);\n  return entry ? entry.ele : new Collection(cy); // get ele or empty collection\n};\n\nelesfn$1.$id = elesfn$1.getElementById;\nelesfn$1.poolIndex = function () {\n  var cy = this._private.cy;\n  var eles = cy._private.elements;\n  var id = this[0]._private.data.id;\n  return eles._private.map.get(id).index;\n};\nelesfn$1.indexOf = function (ele) {\n  var id = ele[0]._private.data.id;\n  return this._private.map.get(id).index;\n};\nelesfn$1.indexOfId = function (id) {\n  id = '' + id; // id must be string\n\n  return this._private.map.get(id).index;\n};\nelesfn$1.json = function (obj) {\n  var ele = this.element();\n  var cy = this.cy();\n  if (ele == null && obj) {\n    return this;\n  } // can't set to no eles\n\n  if (ele == null) {\n    return undefined;\n  } // can't get from no eles\n\n  var p = ele._private;\n  if (plainObject(obj)) {\n    // set\n\n    cy.startBatch();\n    if (obj.data) {\n      ele.data(obj.data);\n      var _data2 = p.data;\n      if (ele.isEdge()) {\n        // source and target are immutable via data()\n        var move = false;\n        var spec = {};\n        var src = obj.data.source;\n        var tgt = obj.data.target;\n        if (src != null && src != _data2.source) {\n          spec.source = '' + src; // id must be string\n          move = true;\n        }\n        if (tgt != null && tgt != _data2.target) {\n          spec.target = '' + tgt; // id must be string\n          move = true;\n        }\n        if (move) {\n          ele = ele.move(spec);\n        }\n      } else {\n        // parent is immutable via data()\n        var newParentValSpecd = ('parent' in obj.data);\n        var parent = obj.data.parent;\n        if (newParentValSpecd && (parent != null || _data2.parent != null) && parent != _data2.parent) {\n          if (parent === undefined) {\n            // can't set undefined imperatively, so use null\n            parent = null;\n          }\n          if (parent != null) {\n            parent = '' + parent; // id must be string\n          }\n\n          ele = ele.move({\n            parent: parent\n          });\n        }\n      }\n    }\n    if (obj.position) {\n      ele.position(obj.position);\n    }\n\n    // ignore group -- immutable\n\n    var checkSwitch = function checkSwitch(k, trueFnName, falseFnName) {\n      var obj_k = obj[k];\n      if (obj_k != null && obj_k !== p[k]) {\n        if (obj_k) {\n          ele[trueFnName]();\n        } else {\n          ele[falseFnName]();\n        }\n      }\n    };\n    checkSwitch('removed', 'remove', 'restore');\n    checkSwitch('selected', 'select', 'unselect');\n    checkSwitch('selectable', 'selectify', 'unselectify');\n    checkSwitch('locked', 'lock', 'unlock');\n    checkSwitch('grabbable', 'grabify', 'ungrabify');\n    checkSwitch('pannable', 'panify', 'unpanify');\n    if (obj.classes != null) {\n      ele.classes(obj.classes);\n    }\n    cy.endBatch();\n    return this;\n  } else if (obj === undefined) {\n    // get\n\n    var json = {\n      data: copy(p.data),\n      position: copy(p.position),\n      group: p.group,\n      removed: p.removed,\n      selected: p.selected,\n      selectable: p.selectable,\n      locked: p.locked,\n      grabbable: p.grabbable,\n      pannable: p.pannable,\n      classes: null\n    };\n    json.classes = '';\n    var i = 0;\n    p.classes.forEach(function (cls) {\n      return json.classes += i++ === 0 ? cls : ' ' + cls;\n    });\n    return json;\n  }\n};\nelesfn$1.jsons = function () {\n  var jsons = [];\n  for (var i = 0; i < this.length; i++) {\n    var ele = this[i];\n    var json = ele.json();\n    jsons.push(json);\n  }\n  return jsons;\n};\nelesfn$1.clone = function () {\n  var cy = this.cy();\n  var elesArr = [];\n  for (var i = 0; i < this.length; i++) {\n    var ele = this[i];\n    var json = ele.json();\n    var clone = new Element(cy, json, false); // NB no restore\n\n    elesArr.push(clone);\n  }\n  return new Collection(cy, elesArr);\n};\nelesfn$1.copy = elesfn$1.clone;\nelesfn$1.restore = function () {\n  var notifyRenderer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n  var addToPool = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  var self = this;\n  var cy = self.cy();\n  var cy_p = cy._private;\n\n  // create arrays of nodes and edges, since we need to\n  // restore the nodes first\n  var nodes = [];\n  var edges = [];\n  var elements;\n  for (var _i3 = 0, l = self.length; _i3 < l; _i3++) {\n    var ele = self[_i3];\n    if (addToPool && !ele.removed()) {\n      // don't need to handle this ele\n      continue;\n    }\n\n    // keep nodes first in the array and edges after\n    if (ele.isNode()) {\n      // put to front of array if node\n      nodes.push(ele);\n    } else {\n      // put to end of array if edge\n      edges.push(ele);\n    }\n  }\n  elements = nodes.concat(edges);\n  var i;\n  var removeFromElements = function removeFromElements() {\n    elements.splice(i, 1);\n    i--;\n  };\n\n  // now, restore each element\n  for (i = 0; i < elements.length; i++) {\n    var _ele2 = elements[i];\n    var _private = _ele2._private;\n    var _data3 = _private.data;\n\n    // the traversal cache should start fresh when ele is added\n    _ele2.clearTraversalCache();\n\n    // set id and validate\n    if (!addToPool && !_private.removed) ; else if (_data3.id === undefined) {\n      _data3.id = uuid();\n    } else if (number$1(_data3.id)) {\n      _data3.id = '' + _data3.id; // now it's a string\n    } else if (emptyString(_data3.id) || !string(_data3.id)) {\n      error('Can not create element with invalid string ID `' + _data3.id + '`');\n\n      // can't create element if it has empty string as id or non-string id\n      removeFromElements();\n      continue;\n    } else if (cy.hasElementWithId(_data3.id)) {\n      error('Can not create second element with ID `' + _data3.id + '`');\n\n      // can't create element if one already has that id\n      removeFromElements();\n      continue;\n    }\n    var id = _data3.id; // id is finalised, now let's keep a ref\n\n    if (_ele2.isNode()) {\n      // extra checks for nodes\n      var pos = _private.position;\n\n      // make sure the nodes have a defined position\n\n      if (pos.x == null) {\n        pos.x = 0;\n      }\n      if (pos.y == null) {\n        pos.y = 0;\n      }\n    }\n    if (_ele2.isEdge()) {\n      // extra checks for edges\n\n      var edge = _ele2;\n      var fields = ['source', 'target'];\n      var fieldsLength = fields.length;\n      var badSourceOrTarget = false;\n      for (var j = 0; j < fieldsLength; j++) {\n        var field = fields[j];\n        var val = _data3[field];\n        if (number$1(val)) {\n          val = _data3[field] = '' + _data3[field]; // now string\n        }\n\n        if (val == null || val === '') {\n          // can't create if source or target is not defined properly\n          error('Can not create edge `' + id + '` with unspecified ' + field);\n          badSourceOrTarget = true;\n        } else if (!cy.hasElementWithId(val)) {\n          // can't create edge if one of its nodes doesn't exist\n          error('Can not create edge `' + id + '` with nonexistant ' + field + ' `' + val + '`');\n          badSourceOrTarget = true;\n        }\n      }\n      if (badSourceOrTarget) {\n        removeFromElements();\n        continue;\n      } // can't create this\n\n      var src = cy.getElementById(_data3.source);\n      var tgt = cy.getElementById(_data3.target);\n\n      // only one edge in node if loop\n      if (src.same(tgt)) {\n        src._private.edges.push(edge);\n      } else {\n        src._private.edges.push(edge);\n        tgt._private.edges.push(edge);\n      }\n      edge._private.source = src;\n      edge._private.target = tgt;\n    } // if is edge\n\n    // create mock ids / indexes maps for element so it can be used like collections\n    _private.map = new Map$2();\n    _private.map.set(id, {\n      ele: _ele2,\n      index: 0\n    });\n    _private.removed = false;\n    if (addToPool) {\n      cy.addToPool(_ele2);\n    }\n  } // for each element\n\n  // do compound node sanity checks\n  for (var _i4 = 0; _i4 < nodes.length; _i4++) {\n    // each node\n    var node = nodes[_i4];\n    var _data4 = node._private.data;\n    if (number$1(_data4.parent)) {\n      // then automake string\n      _data4.parent = '' + _data4.parent;\n    }\n    var parentId = _data4.parent;\n    var specifiedParent = parentId != null;\n    if (specifiedParent || node._private.parent) {\n      var parent = node._private.parent ? cy.collection().merge(node._private.parent) : cy.getElementById(parentId);\n      if (parent.empty()) {\n        // non-existant parent; just remove it\n        _data4.parent = undefined;\n      } else if (parent[0].removed()) {\n        warn('Node added with missing parent, reference to parent removed');\n        _data4.parent = undefined;\n        node._private.parent = null;\n      } else {\n        var selfAsParent = false;\n        var ancestor = parent;\n        while (!ancestor.empty()) {\n          if (node.same(ancestor)) {\n            // mark self as parent and remove from data\n            selfAsParent = true;\n            _data4.parent = undefined; // remove parent reference\n\n            // exit or we loop forever\n            break;\n          }\n          ancestor = ancestor.parent();\n        }\n        if (!selfAsParent) {\n          // connect with children\n          parent[0]._private.children.push(node);\n          node._private.parent = parent[0];\n\n          // let the core know we have a compound graph\n          cy_p.hasCompoundNodes = true;\n        }\n      } // else\n    } // if specified parent\n  } // for each node\n\n  if (elements.length > 0) {\n    var restored = elements.length === self.length ? self : new Collection(cy, elements);\n    for (var _i5 = 0; _i5 < restored.length; _i5++) {\n      var _ele3 = restored[_i5];\n      if (_ele3.isNode()) {\n        continue;\n      }\n\n      // adding an edge invalidates the traversal caches for the parallel edges\n      _ele3.parallelEdges().clearTraversalCache();\n\n      // adding an edge invalidates the traversal cache for the connected nodes\n      _ele3.source().clearTraversalCache();\n      _ele3.target().clearTraversalCache();\n    }\n    var toUpdateStyle;\n    if (cy_p.hasCompoundNodes) {\n      toUpdateStyle = cy.collection().merge(restored).merge(restored.connectedNodes()).merge(restored.parent());\n    } else {\n      toUpdateStyle = restored;\n    }\n    toUpdateStyle.dirtyCompoundBoundsCache().dirtyBoundingBoxCache().updateStyle(notifyRenderer);\n    if (notifyRenderer) {\n      restored.emitAndNotify('add');\n    } else if (addToPool) {\n      restored.emit('add');\n    }\n  }\n  return self; // chainability\n};\n\nelesfn$1.removed = function () {\n  var ele = this[0];\n  return ele && ele._private.removed;\n};\nelesfn$1.inside = function () {\n  var ele = this[0];\n  return ele && !ele._private.removed;\n};\nelesfn$1.remove = function () {\n  var notifyRenderer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n  var removeFromPool = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  var self = this;\n  var elesToRemove = [];\n  var elesToRemoveIds = {};\n  var cy = self._private.cy;\n\n  // add connected edges\n  function addConnectedEdges(node) {\n    var edges = node._private.edges;\n    for (var i = 0; i < edges.length; i++) {\n      add(edges[i]);\n    }\n  }\n\n  // add descendant nodes\n  function addChildren(node) {\n    var children = node._private.children;\n    for (var i = 0; i < children.length; i++) {\n      add(children[i]);\n    }\n  }\n  function add(ele) {\n    var alreadyAdded = elesToRemoveIds[ele.id()];\n    if (removeFromPool && ele.removed() || alreadyAdded) {\n      return;\n    } else {\n      elesToRemoveIds[ele.id()] = true;\n    }\n    if (ele.isNode()) {\n      elesToRemove.push(ele); // nodes are removed last\n\n      addConnectedEdges(ele);\n      addChildren(ele);\n    } else {\n      elesToRemove.unshift(ele); // edges are removed first\n    }\n  }\n\n  // make the list of elements to remove\n  // (may be removing more than specified due to connected edges etc)\n\n  for (var i = 0, l = self.length; i < l; i++) {\n    var ele = self[i];\n    add(ele);\n  }\n  function removeEdgeRef(node, edge) {\n    var connectedEdges = node._private.edges;\n    removeFromArray(connectedEdges, edge);\n\n    // removing an edges invalidates the traversal cache for its nodes\n    node.clearTraversalCache();\n  }\n  function removeParallelRef(pllEdge) {\n    // removing an edge invalidates the traversal caches for the parallel edges\n    pllEdge.clearTraversalCache();\n  }\n  var alteredParents = [];\n  alteredParents.ids = {};\n  function removeChildRef(parent, ele) {\n    ele = ele[0];\n    parent = parent[0];\n    var children = parent._private.children;\n    var pid = parent.id();\n    removeFromArray(children, ele); // remove parent => child ref\n\n    ele._private.parent = null; // remove child => parent ref\n\n    if (!alteredParents.ids[pid]) {\n      alteredParents.ids[pid] = true;\n      alteredParents.push(parent);\n    }\n  }\n  self.dirtyCompoundBoundsCache();\n  if (removeFromPool) {\n    cy.removeFromPool(elesToRemove); // remove from core pool\n  }\n\n  for (var _i6 = 0; _i6 < elesToRemove.length; _i6++) {\n    var _ele4 = elesToRemove[_i6];\n    if (_ele4.isEdge()) {\n      // remove references to this edge in its connected nodes\n      var src = _ele4.source()[0];\n      var tgt = _ele4.target()[0];\n      removeEdgeRef(src, _ele4);\n      removeEdgeRef(tgt, _ele4);\n      var pllEdges = _ele4.parallelEdges();\n      for (var j = 0; j < pllEdges.length; j++) {\n        var pllEdge = pllEdges[j];\n        removeParallelRef(pllEdge);\n        if (pllEdge.isBundledBezier()) {\n          pllEdge.dirtyBoundingBoxCache();\n        }\n      }\n    } else {\n      // remove reference to parent\n      var parent = _ele4.parent();\n      if (parent.length !== 0) {\n        removeChildRef(parent, _ele4);\n      }\n    }\n    if (removeFromPool) {\n      // mark as removed\n      _ele4._private.removed = true;\n    }\n  }\n\n  // check to see if we have a compound graph or not\n  var elesStillInside = cy._private.elements;\n  cy._private.hasCompoundNodes = false;\n  for (var _i7 = 0; _i7 < elesStillInside.length; _i7++) {\n    var _ele5 = elesStillInside[_i7];\n    if (_ele5.isParent()) {\n      cy._private.hasCompoundNodes = true;\n      break;\n    }\n  }\n  var removedElements = new Collection(this.cy(), elesToRemove);\n  if (removedElements.size() > 0) {\n    // must manually notify since trigger won't do this automatically once removed\n\n    if (notifyRenderer) {\n      removedElements.emitAndNotify('remove');\n    } else if (removeFromPool) {\n      removedElements.emit('remove');\n    }\n  }\n\n  // the parents who were modified by the removal need their style updated\n  for (var _i8 = 0; _i8 < alteredParents.length; _i8++) {\n    var _ele6 = alteredParents[_i8];\n    if (!removeFromPool || !_ele6.removed()) {\n      _ele6.updateStyle();\n    }\n  }\n  return removedElements;\n};\nelesfn$1.move = function (struct) {\n  var cy = this._private.cy;\n  var eles = this;\n\n  // just clean up refs, caches, etc. in the same way as when removing and then restoring\n  // (our calls to remove/restore do not remove from the graph or make events)\n  var notifyRenderer = false;\n  var modifyPool = false;\n  var toString = function toString(id) {\n    return id == null ? id : '' + id;\n  }; // id must be string\n\n  if (struct.source !== undefined || struct.target !== undefined) {\n    var srcId = toString(struct.source);\n    var tgtId = toString(struct.target);\n    var srcExists = srcId != null && cy.hasElementWithId(srcId);\n    var tgtExists = tgtId != null && cy.hasElementWithId(tgtId);\n    if (srcExists || tgtExists) {\n      cy.batch(function () {\n        // avoid duplicate style updates\n        eles.remove(notifyRenderer, modifyPool); // clean up refs etc.\n        eles.emitAndNotify('moveout');\n        for (var i = 0; i < eles.length; i++) {\n          var ele = eles[i];\n          var _data5 = ele._private.data;\n          if (ele.isEdge()) {\n            if (srcExists) {\n              _data5.source = srcId;\n            }\n            if (tgtExists) {\n              _data5.target = tgtId;\n            }\n          }\n        }\n        eles.restore(notifyRenderer, modifyPool); // make new refs, style, etc.\n      });\n\n      eles.emitAndNotify('move');\n    }\n  } else if (struct.parent !== undefined) {\n    // move node to new parent\n    var parentId = toString(struct.parent);\n    var parentExists = parentId === null || cy.hasElementWithId(parentId);\n    if (parentExists) {\n      var pidToAssign = parentId === null ? undefined : parentId;\n      cy.batch(function () {\n        // avoid duplicate style updates\n        var updated = eles.remove(notifyRenderer, modifyPool); // clean up refs etc.\n        updated.emitAndNotify('moveout');\n        for (var i = 0; i < eles.length; i++) {\n          var ele = eles[i];\n          var _data6 = ele._private.data;\n          if (ele.isNode()) {\n            _data6.parent = pidToAssign;\n          }\n        }\n        updated.restore(notifyRenderer, modifyPool); // make new refs, style, etc.\n      });\n\n      eles.emitAndNotify('move');\n    }\n  }\n  return this;\n};\n[elesfn$j, elesfn$i, elesfn$h, elesfn$g, elesfn$f, data, elesfn$d, dimensions, elesfn$9, elesfn$8, elesfn$7, elesfn$6, elesfn$5, elesfn$4, elesfn$3, elesfn$2].forEach(function (props) {\n  extend(elesfn$1, props);\n});\n\nvar corefn$9 = {\n  add: function add(opts) {\n    var elements;\n    var cy = this;\n\n    // add the elements\n    if (elementOrCollection(opts)) {\n      var eles = opts;\n      if (eles._private.cy === cy) {\n        // same instance => just restore\n        elements = eles.restore();\n      } else {\n        // otherwise, copy from json\n        var jsons = [];\n        for (var i = 0; i < eles.length; i++) {\n          var ele = eles[i];\n          jsons.push(ele.json());\n        }\n        elements = new Collection(cy, jsons);\n      }\n    }\n\n    // specify an array of options\n    else if (array(opts)) {\n      var _jsons = opts;\n      elements = new Collection(cy, _jsons);\n    }\n\n    // specify via opts.nodes and opts.edges\n    else if (plainObject(opts) && (array(opts.nodes) || array(opts.edges))) {\n      var elesByGroup = opts;\n      var _jsons2 = [];\n      var grs = ['nodes', 'edges'];\n      for (var _i = 0, il = grs.length; _i < il; _i++) {\n        var group = grs[_i];\n        var elesArray = elesByGroup[group];\n        if (array(elesArray)) {\n          for (var j = 0, jl = elesArray.length; j < jl; j++) {\n            var json = extend({\n              group: group\n            }, elesArray[j]);\n            _jsons2.push(json);\n          }\n        }\n      }\n      elements = new Collection(cy, _jsons2);\n    }\n\n    // specify options for one element\n    else {\n      var _json = opts;\n      elements = new Element(cy, _json).collection();\n    }\n    return elements;\n  },\n  remove: function remove(collection) {\n    if (elementOrCollection(collection)) ; else if (string(collection)) {\n      var selector = collection;\n      collection = this.$(selector);\n    }\n    return collection.remove();\n  }\n};\n\n/* global Float32Array */\n\n/*! Bezier curve function generator. Copyright Gaetan Renaudeau. MIT License: http://en.wikipedia.org/wiki/MIT_License */\nfunction generateCubicBezier(mX1, mY1, mX2, mY2) {\n  var NEWTON_ITERATIONS = 4,\n    NEWTON_MIN_SLOPE = 0.001,\n    SUBDIVISION_PRECISION = 0.0000001,\n    SUBDIVISION_MAX_ITERATIONS = 10,\n    kSplineTableSize = 11,\n    kSampleStepSize = 1.0 / (kSplineTableSize - 1.0),\n    float32ArraySupported = typeof Float32Array !== 'undefined';\n\n  /* Must contain four arguments. */\n  if (arguments.length !== 4) {\n    return false;\n  }\n\n  /* Arguments must be numbers. */\n  for (var i = 0; i < 4; ++i) {\n    if (typeof arguments[i] !== \"number\" || isNaN(arguments[i]) || !isFinite(arguments[i])) {\n      return false;\n    }\n  }\n\n  /* X values must be in the [0, 1] range. */\n  mX1 = Math.min(mX1, 1);\n  mX2 = Math.min(mX2, 1);\n  mX1 = Math.max(mX1, 0);\n  mX2 = Math.max(mX2, 0);\n  var mSampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);\n  function A(aA1, aA2) {\n    return 1.0 - 3.0 * aA2 + 3.0 * aA1;\n  }\n  function B(aA1, aA2) {\n    return 3.0 * aA2 - 6.0 * aA1;\n  }\n  function C(aA1) {\n    return 3.0 * aA1;\n  }\n  function calcBezier(aT, aA1, aA2) {\n    return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT;\n  }\n  function getSlope(aT, aA1, aA2) {\n    return 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1);\n  }\n  function newtonRaphsonIterate(aX, aGuessT) {\n    for (var _i = 0; _i < NEWTON_ITERATIONS; ++_i) {\n      var currentSlope = getSlope(aGuessT, mX1, mX2);\n      if (currentSlope === 0.0) {\n        return aGuessT;\n      }\n      var currentX = calcBezier(aGuessT, mX1, mX2) - aX;\n      aGuessT -= currentX / currentSlope;\n    }\n    return aGuessT;\n  }\n  function calcSampleValues() {\n    for (var _i2 = 0; _i2 < kSplineTableSize; ++_i2) {\n      mSampleValues[_i2] = calcBezier(_i2 * kSampleStepSize, mX1, mX2);\n    }\n  }\n  function binarySubdivide(aX, aA, aB) {\n    var currentX,\n      currentT,\n      i = 0;\n    do {\n      currentT = aA + (aB - aA) / 2.0;\n      currentX = calcBezier(currentT, mX1, mX2) - aX;\n      if (currentX > 0.0) {\n        aB = currentT;\n      } else {\n        aA = currentT;\n      }\n    } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);\n    return currentT;\n  }\n  function getTForX(aX) {\n    var intervalStart = 0.0,\n      currentSample = 1,\n      lastSample = kSplineTableSize - 1;\n    for (; currentSample !== lastSample && mSampleValues[currentSample] <= aX; ++currentSample) {\n      intervalStart += kSampleStepSize;\n    }\n    --currentSample;\n    var dist = (aX - mSampleValues[currentSample]) / (mSampleValues[currentSample + 1] - mSampleValues[currentSample]),\n      guessForT = intervalStart + dist * kSampleStepSize,\n      initialSlope = getSlope(guessForT, mX1, mX2);\n    if (initialSlope >= NEWTON_MIN_SLOPE) {\n      return newtonRaphsonIterate(aX, guessForT);\n    } else if (initialSlope === 0.0) {\n      return guessForT;\n    } else {\n      return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize);\n    }\n  }\n  var _precomputed = false;\n  function precompute() {\n    _precomputed = true;\n    if (mX1 !== mY1 || mX2 !== mY2) {\n      calcSampleValues();\n    }\n  }\n  var f = function f(aX) {\n    if (!_precomputed) {\n      precompute();\n    }\n    if (mX1 === mY1 && mX2 === mY2) {\n      return aX;\n    }\n    if (aX === 0) {\n      return 0;\n    }\n    if (aX === 1) {\n      return 1;\n    }\n    return calcBezier(getTForX(aX), mY1, mY2);\n  };\n  f.getControlPoints = function () {\n    return [{\n      x: mX1,\n      y: mY1\n    }, {\n      x: mX2,\n      y: mY2\n    }];\n  };\n  var str = \"generateBezier(\" + [mX1, mY1, mX2, mY2] + \")\";\n  f.toString = function () {\n    return str;\n  };\n  return f;\n}\n\n/*! Runge-Kutta spring physics function generator. Adapted from Framer.js, copyright Koen Bok. MIT License: http://en.wikipedia.org/wiki/MIT_License */\n/* Given a tension, friction, and duration, a simulation at 60FPS will first run without a defined duration in order to calculate the full path. A second pass\n   then adjusts the time delta -- using the relation between actual time and duration -- to calculate the path for the duration-constrained animation. */\nvar generateSpringRK4 = function () {\n  function springAccelerationForState(state) {\n    return -state.tension * state.x - state.friction * state.v;\n  }\n  function springEvaluateStateWithDerivative(initialState, dt, derivative) {\n    var state = {\n      x: initialState.x + derivative.dx * dt,\n      v: initialState.v + derivative.dv * dt,\n      tension: initialState.tension,\n      friction: initialState.friction\n    };\n    return {\n      dx: state.v,\n      dv: springAccelerationForState(state)\n    };\n  }\n  function springIntegrateState(state, dt) {\n    var a = {\n        dx: state.v,\n        dv: springAccelerationForState(state)\n      },\n      b = springEvaluateStateWithDerivative(state, dt * 0.5, a),\n      c = springEvaluateStateWithDerivative(state, dt * 0.5, b),\n      d = springEvaluateStateWithDerivative(state, dt, c),\n      dxdt = 1.0 / 6.0 * (a.dx + 2.0 * (b.dx + c.dx) + d.dx),\n      dvdt = 1.0 / 6.0 * (a.dv + 2.0 * (b.dv + c.dv) + d.dv);\n    state.x = state.x + dxdt * dt;\n    state.v = state.v + dvdt * dt;\n    return state;\n  }\n  return function springRK4Factory(tension, friction, duration) {\n    var initState = {\n        x: -1,\n        v: 0,\n        tension: null,\n        friction: null\n      },\n      path = [0],\n      time_lapsed = 0,\n      tolerance = 1 / 10000,\n      DT = 16 / 1000,\n      have_duration,\n      dt,\n      last_state;\n    tension = parseFloat(tension) || 500;\n    friction = parseFloat(friction) || 20;\n    duration = duration || null;\n    initState.tension = tension;\n    initState.friction = friction;\n    have_duration = duration !== null;\n\n    /* Calculate the actual time it takes for this animation to complete with the provided conditions. */\n    if (have_duration) {\n      /* Run the simulation without a duration. */\n      time_lapsed = springRK4Factory(tension, friction);\n      /* Compute the adjusted time delta. */\n      dt = time_lapsed / duration * DT;\n    } else {\n      dt = DT;\n    }\n    for (;;) {\n      /* Next/step function .*/\n      last_state = springIntegrateState(last_state || initState, dt);\n      /* Store the position. */\n      path.push(1 + last_state.x);\n      time_lapsed += 16;\n      /* If the change threshold is reached, break. */\n      if (!(Math.abs(last_state.x) > tolerance && Math.abs(last_state.v) > tolerance)) {\n        break;\n      }\n    }\n\n    /* If duration is not defined, return the actual time required for completing this animation. Otherwise, return a closure that holds the\n       computed path and returns a snapshot of the position according to a given percentComplete. */\n    return !have_duration ? time_lapsed : function (percentComplete) {\n      return path[percentComplete * (path.length - 1) | 0];\n    };\n  };\n}();\n\nvar cubicBezier = function cubicBezier(t1, p1, t2, p2) {\n  var bezier = generateCubicBezier(t1, p1, t2, p2);\n  return function (start, end, percent) {\n    return start + (end - start) * bezier(percent);\n  };\n};\nvar easings = {\n  'linear': function linear(start, end, percent) {\n    return start + (end - start) * percent;\n  },\n  // default easings\n  'ease': cubicBezier(0.25, 0.1, 0.25, 1),\n  'ease-in': cubicBezier(0.42, 0, 1, 1),\n  'ease-out': cubicBezier(0, 0, 0.58, 1),\n  'ease-in-out': cubicBezier(0.42, 0, 0.58, 1),\n  // sine\n  'ease-in-sine': cubicBezier(0.47, 0, 0.745, 0.715),\n  'ease-out-sine': cubicBezier(0.39, 0.575, 0.565, 1),\n  'ease-in-out-sine': cubicBezier(0.445, 0.05, 0.55, 0.95),\n  // quad\n  'ease-in-quad': cubicBezier(0.55, 0.085, 0.68, 0.53),\n  'ease-out-quad': cubicBezier(0.25, 0.46, 0.45, 0.94),\n  'ease-in-out-quad': cubicBezier(0.455, 0.03, 0.515, 0.955),\n  // cubic\n  'ease-in-cubic': cubicBezier(0.55, 0.055, 0.675, 0.19),\n  'ease-out-cubic': cubicBezier(0.215, 0.61, 0.355, 1),\n  'ease-in-out-cubic': cubicBezier(0.645, 0.045, 0.355, 1),\n  // quart\n  'ease-in-quart': cubicBezier(0.895, 0.03, 0.685, 0.22),\n  'ease-out-quart': cubicBezier(0.165, 0.84, 0.44, 1),\n  'ease-in-out-quart': cubicBezier(0.77, 0, 0.175, 1),\n  // quint\n  'ease-in-quint': cubicBezier(0.755, 0.05, 0.855, 0.06),\n  'ease-out-quint': cubicBezier(0.23, 1, 0.32, 1),\n  'ease-in-out-quint': cubicBezier(0.86, 0, 0.07, 1),\n  // expo\n  'ease-in-expo': cubicBezier(0.95, 0.05, 0.795, 0.035),\n  'ease-out-expo': cubicBezier(0.19, 1, 0.22, 1),\n  'ease-in-out-expo': cubicBezier(1, 0, 0, 1),\n  // circ\n  'ease-in-circ': cubicBezier(0.6, 0.04, 0.98, 0.335),\n  'ease-out-circ': cubicBezier(0.075, 0.82, 0.165, 1),\n  'ease-in-out-circ': cubicBezier(0.785, 0.135, 0.15, 0.86),\n  // user param easings...\n\n  'spring': function spring(tension, friction, duration) {\n    if (duration === 0) {\n      // can't get a spring w/ duration 0\n      return easings.linear; // duration 0 => jump to end so impl doesn't matter\n    }\n\n    var spring = generateSpringRK4(tension, friction, duration);\n    return function (start, end, percent) {\n      return start + (end - start) * spring(percent);\n    };\n  },\n  'cubic-bezier': cubicBezier\n};\n\nfunction getEasedValue(type, start, end, percent, easingFn) {\n  if (percent === 1) {\n    return end;\n  }\n  if (start === end) {\n    return end;\n  }\n  var val = easingFn(start, end, percent);\n  if (type == null) {\n    return val;\n  }\n  if (type.roundValue || type.color) {\n    val = Math.round(val);\n  }\n  if (type.min !== undefined) {\n    val = Math.max(val, type.min);\n  }\n  if (type.max !== undefined) {\n    val = Math.min(val, type.max);\n  }\n  return val;\n}\nfunction getValue(prop, spec) {\n  if (prop.pfValue != null || prop.value != null) {\n    if (prop.pfValue != null && (spec == null || spec.type.units !== '%')) {\n      return prop.pfValue;\n    } else {\n      return prop.value;\n    }\n  } else {\n    return prop;\n  }\n}\nfunction ease(startProp, endProp, percent, easingFn, propSpec) {\n  var type = propSpec != null ? propSpec.type : null;\n  if (percent < 0) {\n    percent = 0;\n  } else if (percent > 1) {\n    percent = 1;\n  }\n  var start = getValue(startProp, propSpec);\n  var end = getValue(endProp, propSpec);\n  if (number$1(start) && number$1(end)) {\n    return getEasedValue(type, start, end, percent, easingFn);\n  } else if (array(start) && array(end)) {\n    var easedArr = [];\n    for (var i = 0; i < end.length; i++) {\n      var si = start[i];\n      var ei = end[i];\n      if (si != null && ei != null) {\n        var val = getEasedValue(type, si, ei, percent, easingFn);\n        easedArr.push(val);\n      } else {\n        easedArr.push(ei);\n      }\n    }\n    return easedArr;\n  }\n  return undefined;\n}\n\nfunction step$1(self, ani, now, isCore) {\n  var isEles = !isCore;\n  var _p = self._private;\n  var ani_p = ani._private;\n  var pEasing = ani_p.easing;\n  var startTime = ani_p.startTime;\n  var cy = isCore ? self : self.cy();\n  var style = cy.style();\n  if (!ani_p.easingImpl) {\n    if (pEasing == null) {\n      // use default\n      ani_p.easingImpl = easings['linear'];\n    } else {\n      // then define w/ name\n      var easingVals;\n      if (string(pEasing)) {\n        var easingProp = style.parse('transition-timing-function', pEasing);\n        easingVals = easingProp.value;\n      } else {\n        // then assume preparsed array\n        easingVals = pEasing;\n      }\n      var name, args;\n      if (string(easingVals)) {\n        name = easingVals;\n        args = [];\n      } else {\n        name = easingVals[1];\n        args = easingVals.slice(2).map(function (n) {\n          return +n;\n        });\n      }\n      if (args.length > 0) {\n        // create with args\n        if (name === 'spring') {\n          args.push(ani_p.duration); // need duration to generate spring\n        }\n\n        ani_p.easingImpl = easings[name].apply(null, args);\n      } else {\n        // static impl by name\n        ani_p.easingImpl = easings[name];\n      }\n    }\n  }\n  var easing = ani_p.easingImpl;\n  var percent;\n  if (ani_p.duration === 0) {\n    percent = 1;\n  } else {\n    percent = (now - startTime) / ani_p.duration;\n  }\n  if (ani_p.applying) {\n    percent = ani_p.progress;\n  }\n  if (percent < 0) {\n    percent = 0;\n  } else if (percent > 1) {\n    percent = 1;\n  }\n  if (ani_p.delay == null) {\n    // then update\n\n    var startPos = ani_p.startPosition;\n    var endPos = ani_p.position;\n    if (endPos && isEles && !self.locked()) {\n      var newPos = {};\n      if (valid(startPos.x, endPos.x)) {\n        newPos.x = ease(startPos.x, endPos.x, percent, easing);\n      }\n      if (valid(startPos.y, endPos.y)) {\n        newPos.y = ease(startPos.y, endPos.y, percent, easing);\n      }\n      self.position(newPos);\n    }\n    var startPan = ani_p.startPan;\n    var endPan = ani_p.pan;\n    var pan = _p.pan;\n    var animatingPan = endPan != null && isCore;\n    if (animatingPan) {\n      if (valid(startPan.x, endPan.x)) {\n        pan.x = ease(startPan.x, endPan.x, percent, easing);\n      }\n      if (valid(startPan.y, endPan.y)) {\n        pan.y = ease(startPan.y, endPan.y, percent, easing);\n      }\n      self.emit('pan');\n    }\n    var startZoom = ani_p.startZoom;\n    var endZoom = ani_p.zoom;\n    var animatingZoom = endZoom != null && isCore;\n    if (animatingZoom) {\n      if (valid(startZoom, endZoom)) {\n        _p.zoom = bound(_p.minZoom, ease(startZoom, endZoom, percent, easing), _p.maxZoom);\n      }\n      self.emit('zoom');\n    }\n    if (animatingPan || animatingZoom) {\n      self.emit('viewport');\n    }\n    var props = ani_p.style;\n    if (props && props.length > 0 && isEles) {\n      for (var i = 0; i < props.length; i++) {\n        var prop = props[i];\n        var _name = prop.name;\n        var end = prop;\n        var start = ani_p.startStyle[_name];\n        var propSpec = style.properties[start.name];\n        var easedVal = ease(start, end, percent, easing, propSpec);\n        style.overrideBypass(self, _name, easedVal);\n      } // for props\n\n      self.emit('style');\n    } // if\n  }\n\n  ani_p.progress = percent;\n  return percent;\n}\nfunction valid(start, end) {\n  if (start == null || end == null) {\n    return false;\n  }\n  if (number$1(start) && number$1(end)) {\n    return true;\n  } else if (start && end) {\n    return true;\n  }\n  return false;\n}\n\nfunction startAnimation(self, ani, now, isCore) {\n  var ani_p = ani._private;\n  ani_p.started = true;\n  ani_p.startTime = now - ani_p.progress * ani_p.duration;\n}\n\nfunction stepAll(now, cy) {\n  var eles = cy._private.aniEles;\n  var doneEles = [];\n  function stepOne(ele, isCore) {\n    var _p = ele._private;\n    var current = _p.animation.current;\n    var queue = _p.animation.queue;\n    var ranAnis = false;\n\n    // if nothing currently animating, get something from the queue\n    if (current.length === 0) {\n      var next = queue.shift();\n      if (next) {\n        current.push(next);\n      }\n    }\n    var callbacks = function callbacks(_callbacks) {\n      for (var j = _callbacks.length - 1; j >= 0; j--) {\n        var cb = _callbacks[j];\n        cb();\n      }\n      _callbacks.splice(0, _callbacks.length);\n    };\n\n    // step and remove if done\n    for (var i = current.length - 1; i >= 0; i--) {\n      var ani = current[i];\n      var ani_p = ani._private;\n      if (ani_p.stopped) {\n        current.splice(i, 1);\n        ani_p.hooked = false;\n        ani_p.playing = false;\n        ani_p.started = false;\n        callbacks(ani_p.frames);\n        continue;\n      }\n      if (!ani_p.playing && !ani_p.applying) {\n        continue;\n      }\n\n      // an apply() while playing shouldn't do anything\n      if (ani_p.playing && ani_p.applying) {\n        ani_p.applying = false;\n      }\n      if (!ani_p.started) {\n        startAnimation(ele, ani, now);\n      }\n      step$1(ele, ani, now, isCore);\n      if (ani_p.applying) {\n        ani_p.applying = false;\n      }\n      callbacks(ani_p.frames);\n      if (ani_p.step != null) {\n        ani_p.step(now);\n      }\n      if (ani.completed()) {\n        current.splice(i, 1);\n        ani_p.hooked = false;\n        ani_p.playing = false;\n        ani_p.started = false;\n        callbacks(ani_p.completes);\n      }\n      ranAnis = true;\n    }\n    if (!isCore && current.length === 0 && queue.length === 0) {\n      doneEles.push(ele);\n    }\n    return ranAnis;\n  } // stepElement\n\n  // handle all eles\n  var ranEleAni = false;\n  for (var e = 0; e < eles.length; e++) {\n    var ele = eles[e];\n    var handledThisEle = stepOne(ele);\n    ranEleAni = ranEleAni || handledThisEle;\n  } // each element\n\n  var ranCoreAni = stepOne(cy, true);\n\n  // notify renderer\n  if (ranEleAni || ranCoreAni) {\n    if (eles.length > 0) {\n      cy.notify('draw', eles);\n    } else {\n      cy.notify('draw');\n    }\n  }\n\n  // remove elements from list of currently animating if its queues are empty\n  eles.unmerge(doneEles);\n  cy.emit('step');\n} // stepAll\n\nvar corefn$8 = {\n  // pull in animation functions\n  animate: define.animate(),\n  animation: define.animation(),\n  animated: define.animated(),\n  clearQueue: define.clearQueue(),\n  delay: define.delay(),\n  delayAnimation: define.delayAnimation(),\n  stop: define.stop(),\n  addToAnimationPool: function addToAnimationPool(eles) {\n    var cy = this;\n    if (!cy.styleEnabled()) {\n      return;\n    } // save cycles when no style used\n\n    cy._private.aniEles.merge(eles);\n  },\n  stopAnimationLoop: function stopAnimationLoop() {\n    this._private.animationsRunning = false;\n  },\n  startAnimationLoop: function startAnimationLoop() {\n    var cy = this;\n    cy._private.animationsRunning = true;\n    if (!cy.styleEnabled()) {\n      return;\n    } // save cycles when no style used\n\n    // NB the animation loop will exec in headless environments if style enabled\n    // and explicit cy.destroy() is necessary to stop the loop\n\n    function headlessStep() {\n      if (!cy._private.animationsRunning) {\n        return;\n      }\n      requestAnimationFrame(function animationStep(now) {\n        stepAll(now, cy);\n        headlessStep();\n      });\n    }\n    var renderer = cy.renderer();\n    if (renderer && renderer.beforeRender) {\n      // let the renderer schedule animations\n      renderer.beforeRender(function rendererAnimationStep(willDraw, now) {\n        stepAll(now, cy);\n      }, renderer.beforeRenderPriorities.animations);\n    } else {\n      // manage the animation loop ourselves\n      headlessStep(); // first call\n    }\n  }\n};\n\nvar emitterOptions = {\n  qualifierCompare: function qualifierCompare(selector1, selector2) {\n    if (selector1 == null || selector2 == null) {\n      return selector1 == null && selector2 == null;\n    } else {\n      return selector1.sameText(selector2);\n    }\n  },\n  eventMatches: function eventMatches(cy, listener, eventObj) {\n    var selector = listener.qualifier;\n    if (selector != null) {\n      return cy !== eventObj.target && element(eventObj.target) && selector.matches(eventObj.target);\n    }\n    return true;\n  },\n  addEventFields: function addEventFields(cy, evt) {\n    evt.cy = cy;\n    evt.target = cy;\n  },\n  callbackContext: function callbackContext(cy, listener, eventObj) {\n    return listener.qualifier != null ? eventObj.target : cy;\n  }\n};\nvar argSelector = function argSelector(arg) {\n  if (string(arg)) {\n    return new Selector(arg);\n  } else {\n    return arg;\n  }\n};\nvar elesfn = {\n  createEmitter: function createEmitter() {\n    var _p = this._private;\n    if (!_p.emitter) {\n      _p.emitter = new Emitter(emitterOptions, this);\n    }\n    return this;\n  },\n  emitter: function emitter() {\n    return this._private.emitter;\n  },\n  on: function on(events, selector, callback) {\n    this.emitter().on(events, argSelector(selector), callback);\n    return this;\n  },\n  removeListener: function removeListener(events, selector, callback) {\n    this.emitter().removeListener(events, argSelector(selector), callback);\n    return this;\n  },\n  removeAllListeners: function removeAllListeners() {\n    this.emitter().removeAllListeners();\n    return this;\n  },\n  one: function one(events, selector, callback) {\n    this.emitter().one(events, argSelector(selector), callback);\n    return this;\n  },\n  once: function once(events, selector, callback) {\n    this.emitter().one(events, argSelector(selector), callback);\n    return this;\n  },\n  emit: function emit(events, extraParams) {\n    this.emitter().emit(events, extraParams);\n    return this;\n  },\n  emitAndNotify: function emitAndNotify(event, eles) {\n    this.emit(event);\n    this.notify(event, eles);\n    return this;\n  }\n};\ndefine.eventAliasesOn(elesfn);\n\nvar corefn$7 = {\n  png: function png(options) {\n    var renderer = this._private.renderer;\n    options = options || {};\n    return renderer.png(options);\n  },\n  jpg: function jpg(options) {\n    var renderer = this._private.renderer;\n    options = options || {};\n    options.bg = options.bg || '#fff';\n    return renderer.jpg(options);\n  }\n};\ncorefn$7.jpeg = corefn$7.jpg;\n\nvar corefn$6 = {\n  layout: function layout(options) {\n    var cy = this;\n    if (options == null) {\n      error('Layout options must be specified to make a layout');\n      return;\n    }\n    if (options.name == null) {\n      error('A `name` must be specified to make a layout');\n      return;\n    }\n    var name = options.name;\n    var Layout = cy.extension('layout', name);\n    if (Layout == null) {\n      error('No such layout `' + name + '` found.  Did you forget to import it and `cytoscape.use()` it?');\n      return;\n    }\n    var eles;\n    if (string(options.eles)) {\n      eles = cy.$(options.eles);\n    } else {\n      eles = options.eles != null ? options.eles : cy.$();\n    }\n    var layout = new Layout(extend({}, options, {\n      cy: cy,\n      eles: eles\n    }));\n    return layout;\n  }\n};\ncorefn$6.createLayout = corefn$6.makeLayout = corefn$6.layout;\n\nvar corefn$5 = {\n  notify: function notify(eventName, eventEles) {\n    var _p = this._private;\n    if (this.batching()) {\n      _p.batchNotifications = _p.batchNotifications || {};\n      var eles = _p.batchNotifications[eventName] = _p.batchNotifications[eventName] || this.collection();\n      if (eventEles != null) {\n        eles.merge(eventEles);\n      }\n      return; // notifications are disabled during batching\n    }\n\n    if (!_p.notificationsEnabled) {\n      return;\n    } // exit on disabled\n\n    var renderer = this.renderer();\n\n    // exit if destroy() called on core or renderer in between frames #1499 #1528\n    if (this.destroyed() || !renderer) {\n      return;\n    }\n    renderer.notify(eventName, eventEles);\n  },\n  notifications: function notifications(bool) {\n    var p = this._private;\n    if (bool === undefined) {\n      return p.notificationsEnabled;\n    } else {\n      p.notificationsEnabled = bool ? true : false;\n    }\n    return this;\n  },\n  noNotifications: function noNotifications(callback) {\n    this.notifications(false);\n    callback();\n    this.notifications(true);\n  },\n  batching: function batching() {\n    return this._private.batchCount > 0;\n  },\n  startBatch: function startBatch() {\n    var _p = this._private;\n    if (_p.batchCount == null) {\n      _p.batchCount = 0;\n    }\n    if (_p.batchCount === 0) {\n      _p.batchStyleEles = this.collection();\n      _p.batchNotifications = {};\n    }\n    _p.batchCount++;\n    return this;\n  },\n  endBatch: function endBatch() {\n    var _p = this._private;\n    if (_p.batchCount === 0) {\n      return this;\n    }\n    _p.batchCount--;\n    if (_p.batchCount === 0) {\n      // update style for dirty eles\n      _p.batchStyleEles.updateStyle();\n      var renderer = this.renderer();\n\n      // notify the renderer of queued eles and event types\n      Object.keys(_p.batchNotifications).forEach(function (eventName) {\n        var eles = _p.batchNotifications[eventName];\n        if (eles.empty()) {\n          renderer.notify(eventName);\n        } else {\n          renderer.notify(eventName, eles);\n        }\n      });\n    }\n    return this;\n  },\n  batch: function batch(callback) {\n    this.startBatch();\n    callback();\n    this.endBatch();\n    return this;\n  },\n  // for backwards compatibility\n  batchData: function batchData(map) {\n    var cy = this;\n    return this.batch(function () {\n      var ids = Object.keys(map);\n      for (var i = 0; i < ids.length; i++) {\n        var id = ids[i];\n        var data = map[id];\n        var ele = cy.getElementById(id);\n        ele.data(data);\n      }\n    });\n  }\n};\n\nvar rendererDefaults = defaults$g({\n  hideEdgesOnViewport: false,\n  textureOnViewport: false,\n  motionBlur: false,\n  motionBlurOpacity: 0.05,\n  pixelRatio: undefined,\n  desktopTapThreshold: 4,\n  touchTapThreshold: 8,\n  wheelSensitivity: 1,\n  debug: false,\n  showFps: false\n});\nvar corefn$4 = {\n  renderTo: function renderTo(context, zoom, pan, pxRatio) {\n    var r = this._private.renderer;\n    r.renderTo(context, zoom, pan, pxRatio);\n    return this;\n  },\n  renderer: function renderer() {\n    return this._private.renderer;\n  },\n  forceRender: function forceRender() {\n    this.notify('draw');\n    return this;\n  },\n  resize: function resize() {\n    this.invalidateSize();\n    this.emitAndNotify('resize');\n    return this;\n  },\n  initRenderer: function initRenderer(options) {\n    var cy = this;\n    var RendererProto = cy.extension('renderer', options.name);\n    if (RendererProto == null) {\n      error(\"Can not initialise: No such renderer `\".concat(options.name, \"` found. Did you forget to import it and `cytoscape.use()` it?\"));\n      return;\n    }\n    if (options.wheelSensitivity !== undefined) {\n      warn(\"You have set a custom wheel sensitivity.  This will make your app zoom unnaturally when using mainstream mice.  You should change this value from the default only if you can guarantee that all your users will use the same hardware and OS configuration as your current machine.\");\n    }\n    var rOpts = rendererDefaults(options);\n    rOpts.cy = cy;\n    cy._private.renderer = new RendererProto(rOpts);\n    this.notify('init');\n  },\n  destroyRenderer: function destroyRenderer() {\n    var cy = this;\n    cy.notify('destroy'); // destroy the renderer\n\n    var domEle = cy.container();\n    if (domEle) {\n      domEle._cyreg = null;\n      while (domEle.childNodes.length > 0) {\n        domEle.removeChild(domEle.childNodes[0]);\n      }\n    }\n    cy._private.renderer = null; // to be extra safe, remove the ref\n    cy.mutableElements().forEach(function (ele) {\n      var _p = ele._private;\n      _p.rscratch = {};\n      _p.rstyle = {};\n      _p.animation.current = [];\n      _p.animation.queue = [];\n    });\n  },\n  onRender: function onRender(fn) {\n    return this.on('render', fn);\n  },\n  offRender: function offRender(fn) {\n    return this.off('render', fn);\n  }\n};\ncorefn$4.invalidateDimensions = corefn$4.resize;\n\nvar corefn$3 = {\n  // get a collection\n  // - empty collection on no args\n  // - collection of elements in the graph on selector arg\n  // - guarantee a returned collection when elements or collection specified\n  collection: function collection(eles, opts) {\n    if (string(eles)) {\n      return this.$(eles);\n    } else if (elementOrCollection(eles)) {\n      return eles.collection();\n    } else if (array(eles)) {\n      if (!opts) {\n        opts = {};\n      }\n      return new Collection(this, eles, opts.unique, opts.removed);\n    }\n    return new Collection(this);\n  },\n  nodes: function nodes(selector) {\n    var nodes = this.$(function (ele) {\n      return ele.isNode();\n    });\n    if (selector) {\n      return nodes.filter(selector);\n    }\n    return nodes;\n  },\n  edges: function edges(selector) {\n    var edges = this.$(function (ele) {\n      return ele.isEdge();\n    });\n    if (selector) {\n      return edges.filter(selector);\n    }\n    return edges;\n  },\n  // search the graph like jQuery\n  $: function $(selector) {\n    var eles = this._private.elements;\n    if (selector) {\n      return eles.filter(selector);\n    } else {\n      return eles.spawnSelf();\n    }\n  },\n  mutableElements: function mutableElements() {\n    return this._private.elements;\n  }\n};\n\n// aliases\ncorefn$3.elements = corefn$3.filter = corefn$3.$;\n\nvar styfn$8 = {};\n\n// keys for style blocks, e.g. ttfftt\nvar TRUE = 't';\nvar FALSE = 'f';\n\n// (potentially expensive calculation)\n// apply the style to the element based on\n// - its bypass\n// - what selectors match it\nstyfn$8.apply = function (eles) {\n  var self = this;\n  var _p = self._private;\n  var cy = _p.cy;\n  var updatedEles = cy.collection();\n  for (var ie = 0; ie < eles.length; ie++) {\n    var ele = eles[ie];\n    var cxtMeta = self.getContextMeta(ele);\n    if (cxtMeta.empty) {\n      continue;\n    }\n    var cxtStyle = self.getContextStyle(cxtMeta);\n    var app = self.applyContextStyle(cxtMeta, cxtStyle, ele);\n    if (ele._private.appliedInitStyle) {\n      self.updateTransitions(ele, app.diffProps);\n    } else {\n      ele._private.appliedInitStyle = true;\n    }\n    var hintsDiff = self.updateStyleHints(ele);\n    if (hintsDiff) {\n      updatedEles.push(ele);\n    }\n  } // for elements\n\n  return updatedEles;\n};\nstyfn$8.getPropertiesDiff = function (oldCxtKey, newCxtKey) {\n  var self = this;\n  var cache = self._private.propDiffs = self._private.propDiffs || {};\n  var dualCxtKey = oldCxtKey + '-' + newCxtKey;\n  var cachedVal = cache[dualCxtKey];\n  if (cachedVal) {\n    return cachedVal;\n  }\n  var diffProps = [];\n  var addedProp = {};\n  for (var i = 0; i < self.length; i++) {\n    var cxt = self[i];\n    var oldHasCxt = oldCxtKey[i] === TRUE;\n    var newHasCxt = newCxtKey[i] === TRUE;\n    var cxtHasDiffed = oldHasCxt !== newHasCxt;\n    var cxtHasMappedProps = cxt.mappedProperties.length > 0;\n    if (cxtHasDiffed || newHasCxt && cxtHasMappedProps) {\n      var props = void 0;\n      if (cxtHasDiffed && cxtHasMappedProps) {\n        props = cxt.properties; // suffices b/c mappedProperties is a subset of properties\n      } else if (cxtHasDiffed) {\n        props = cxt.properties; // need to check them all\n      } else if (cxtHasMappedProps) {\n        props = cxt.mappedProperties; // only need to check mapped\n      }\n\n      for (var j = 0; j < props.length; j++) {\n        var prop = props[j];\n        var name = prop.name;\n\n        // if a later context overrides this property, then the fact that this context has switched/diffed doesn't matter\n        // (semi expensive check since it makes this function O(n^2) on context length, but worth it since overall result\n        // is cached)\n        var laterCxtOverrides = false;\n        for (var k = i + 1; k < self.length; k++) {\n          var laterCxt = self[k];\n          var hasLaterCxt = newCxtKey[k] === TRUE;\n          if (!hasLaterCxt) {\n            continue;\n          } // can't override unless the context is active\n\n          laterCxtOverrides = laterCxt.properties[prop.name] != null;\n          if (laterCxtOverrides) {\n            break;\n          } // exit early as long as one later context overrides\n        }\n\n        if (!addedProp[name] && !laterCxtOverrides) {\n          addedProp[name] = true;\n          diffProps.push(name);\n        }\n      } // for props\n    } // if\n  } // for contexts\n\n  cache[dualCxtKey] = diffProps;\n  return diffProps;\n};\nstyfn$8.getContextMeta = function (ele) {\n  var self = this;\n  var cxtKey = '';\n  var diffProps;\n  var prevKey = ele._private.styleCxtKey || '';\n\n  // get the cxt key\n  for (var i = 0; i < self.length; i++) {\n    var context = self[i];\n    var contextSelectorMatches = context.selector && context.selector.matches(ele); // NB: context.selector may be null for 'core'\n\n    if (contextSelectorMatches) {\n      cxtKey += TRUE;\n    } else {\n      cxtKey += FALSE;\n    }\n  } // for context\n\n  diffProps = self.getPropertiesDiff(prevKey, cxtKey);\n  ele._private.styleCxtKey = cxtKey;\n  return {\n    key: cxtKey,\n    diffPropNames: diffProps,\n    empty: diffProps.length === 0\n  };\n};\n\n// gets a computed ele style object based on matched contexts\nstyfn$8.getContextStyle = function (cxtMeta) {\n  var cxtKey = cxtMeta.key;\n  var self = this;\n  var cxtStyles = this._private.contextStyles = this._private.contextStyles || {};\n\n  // if already computed style, returned cached copy\n  if (cxtStyles[cxtKey]) {\n    return cxtStyles[cxtKey];\n  }\n  var style = {\n    _private: {\n      key: cxtKey\n    }\n  };\n  for (var i = 0; i < self.length; i++) {\n    var cxt = self[i];\n    var hasCxt = cxtKey[i] === TRUE;\n    if (!hasCxt) {\n      continue;\n    }\n    for (var j = 0; j < cxt.properties.length; j++) {\n      var prop = cxt.properties[j];\n      style[prop.name] = prop;\n    }\n  }\n  cxtStyles[cxtKey] = style;\n  return style;\n};\nstyfn$8.applyContextStyle = function (cxtMeta, cxtStyle, ele) {\n  var self = this;\n  var diffProps = cxtMeta.diffPropNames;\n  var retDiffProps = {};\n  var types = self.types;\n  for (var i = 0; i < diffProps.length; i++) {\n    var diffPropName = diffProps[i];\n    var cxtProp = cxtStyle[diffPropName];\n    var eleProp = ele.pstyle(diffPropName);\n    if (!cxtProp) {\n      // no context prop means delete\n      if (!eleProp) {\n        continue; // no existing prop means nothing needs to be removed\n        // nb affects initial application on mapped values like control-point-distances\n      } else if (eleProp.bypass) {\n        cxtProp = {\n          name: diffPropName,\n          deleteBypassed: true\n        };\n      } else {\n        cxtProp = {\n          name: diffPropName,\n          \"delete\": true\n        };\n      }\n    }\n\n    // save cycles when the context prop doesn't need to be applied\n    if (eleProp === cxtProp) {\n      continue;\n    }\n\n    // save cycles when a mapped context prop doesn't need to be applied\n    if (cxtProp.mapped === types.fn // context prop is function mapper\n    && eleProp != null // some props can be null even by default (e.g. a prop that overrides another one)\n    && eleProp.mapping != null // ele prop is a concrete value from from a mapper\n    && eleProp.mapping.value === cxtProp.value // the current prop on the ele is a flat prop value for the function mapper\n    ) {\n      // NB don't write to cxtProp, as it's shared among eles (stored in stylesheet)\n      var mapping = eleProp.mapping; // can write to mapping, as it's a per-ele copy\n      var fnValue = mapping.fnValue = cxtProp.value(ele); // temporarily cache the value in case of a miss\n\n      if (fnValue === mapping.prevFnValue) {\n        continue;\n      }\n    }\n    var retDiffProp = retDiffProps[diffPropName] = {\n      prev: eleProp\n    };\n    self.applyParsedProperty(ele, cxtProp);\n    retDiffProp.next = ele.pstyle(diffPropName);\n    if (retDiffProp.next && retDiffProp.next.bypass) {\n      retDiffProp.next = retDiffProp.next.bypassed;\n    }\n  }\n  return {\n    diffProps: retDiffProps\n  };\n};\nstyfn$8.updateStyleHints = function (ele) {\n  var _p = ele._private;\n  var self = this;\n  var propNames = self.propertyGroupNames;\n  var propGrKeys = self.propertyGroupKeys;\n  var propHash = function propHash(ele, propNames, seedKey) {\n    return self.getPropertiesHash(ele, propNames, seedKey);\n  };\n  var oldStyleKey = _p.styleKey;\n  if (ele.removed()) {\n    return false;\n  }\n  var isNode = _p.group === 'nodes';\n\n  // get the style key hashes per prop group\n  // but lazily -- only use non-default prop values to reduce the number of hashes\n  //\n\n  var overriddenStyles = ele._private.style;\n  propNames = Object.keys(overriddenStyles);\n  for (var i = 0; i < propGrKeys.length; i++) {\n    var grKey = propGrKeys[i];\n    _p.styleKeys[grKey] = [DEFAULT_HASH_SEED, DEFAULT_HASH_SEED_ALT];\n  }\n  var updateGrKey1 = function updateGrKey1(val, grKey) {\n    return _p.styleKeys[grKey][0] = hashInt(val, _p.styleKeys[grKey][0]);\n  };\n  var updateGrKey2 = function updateGrKey2(val, grKey) {\n    return _p.styleKeys[grKey][1] = hashIntAlt(val, _p.styleKeys[grKey][1]);\n  };\n  var updateGrKey = function updateGrKey(val, grKey) {\n    updateGrKey1(val, grKey);\n    updateGrKey2(val, grKey);\n  };\n  var updateGrKeyWStr = function updateGrKeyWStr(strVal, grKey) {\n    for (var j = 0; j < strVal.length; j++) {\n      var ch = strVal.charCodeAt(j);\n      updateGrKey1(ch, grKey);\n      updateGrKey2(ch, grKey);\n    }\n  };\n\n  // - hashing works on 32 bit ints b/c we use bitwise ops\n  // - small numbers get cut off (e.g. 0.123 is seen as 0 by the hashing function)\n  // - raise up small numbers so more significant digits are seen by hashing\n  // - make small numbers larger than a normal value to avoid collisions\n  // - works in practice and it's relatively cheap\n  var N = 2000000000;\n  var cleanNum = function cleanNum(val) {\n    return -128 < val && val < 128 && Math.floor(val) !== val ? N - (val * 1024 | 0) : val;\n  };\n  for (var _i = 0; _i < propNames.length; _i++) {\n    var name = propNames[_i];\n    var parsedProp = overriddenStyles[name];\n    if (parsedProp == null) {\n      continue;\n    }\n    var propInfo = this.properties[name];\n    var type = propInfo.type;\n    var _grKey = propInfo.groupKey;\n    var normalizedNumberVal = void 0;\n    if (propInfo.hashOverride != null) {\n      normalizedNumberVal = propInfo.hashOverride(ele, parsedProp);\n    } else if (parsedProp.pfValue != null) {\n      normalizedNumberVal = parsedProp.pfValue;\n    }\n\n    // might not be a number if it allows enums\n    var numberVal = propInfo.enums == null ? parsedProp.value : null;\n    var haveNormNum = normalizedNumberVal != null;\n    var haveUnitedNum = numberVal != null;\n    var haveNum = haveNormNum || haveUnitedNum;\n    var units = parsedProp.units;\n\n    // numbers are cheaper to hash than strings\n    // 1 hash op vs n hash ops (for length n string)\n    if (type.number && haveNum && !type.multiple) {\n      var v = haveNormNum ? normalizedNumberVal : numberVal;\n      updateGrKey(cleanNum(v), _grKey);\n      if (!haveNormNum && units != null) {\n        updateGrKeyWStr(units, _grKey);\n      }\n    } else {\n      updateGrKeyWStr(parsedProp.strValue, _grKey);\n    }\n  }\n\n  // overall style key\n  //\n\n  var hash = [DEFAULT_HASH_SEED, DEFAULT_HASH_SEED_ALT];\n  for (var _i2 = 0; _i2 < propGrKeys.length; _i2++) {\n    var _grKey2 = propGrKeys[_i2];\n    var grHash = _p.styleKeys[_grKey2];\n    hash[0] = hashInt(grHash[0], hash[0]);\n    hash[1] = hashIntAlt(grHash[1], hash[1]);\n  }\n  _p.styleKey = combineHashes(hash[0], hash[1]);\n\n  // label dims\n  //\n\n  var sk = _p.styleKeys;\n  _p.labelDimsKey = combineHashesArray(sk.labelDimensions);\n  var labelKeys = propHash(ele, ['label'], sk.labelDimensions);\n  _p.labelKey = combineHashesArray(labelKeys);\n  _p.labelStyleKey = combineHashesArray(hashArrays(sk.commonLabel, labelKeys));\n  if (!isNode) {\n    var sourceLabelKeys = propHash(ele, ['source-label'], sk.labelDimensions);\n    _p.sourceLabelKey = combineHashesArray(sourceLabelKeys);\n    _p.sourceLabelStyleKey = combineHashesArray(hashArrays(sk.commonLabel, sourceLabelKeys));\n    var targetLabelKeys = propHash(ele, ['target-label'], sk.labelDimensions);\n    _p.targetLabelKey = combineHashesArray(targetLabelKeys);\n    _p.targetLabelStyleKey = combineHashesArray(hashArrays(sk.commonLabel, targetLabelKeys));\n  }\n\n  // node\n  //\n\n  if (isNode) {\n    var _p$styleKeys = _p.styleKeys,\n      nodeBody = _p$styleKeys.nodeBody,\n      nodeBorder = _p$styleKeys.nodeBorder,\n      nodeOutline = _p$styleKeys.nodeOutline,\n      backgroundImage = _p$styleKeys.backgroundImage,\n      compound = _p$styleKeys.compound,\n      pie = _p$styleKeys.pie;\n    var nodeKeys = [nodeBody, nodeBorder, nodeOutline, backgroundImage, compound, pie].filter(function (k) {\n      return k != null;\n    }).reduce(hashArrays, [DEFAULT_HASH_SEED, DEFAULT_HASH_SEED_ALT]);\n    _p.nodeKey = combineHashesArray(nodeKeys);\n    _p.hasPie = pie != null && pie[0] !== DEFAULT_HASH_SEED && pie[1] !== DEFAULT_HASH_SEED_ALT;\n  }\n  return oldStyleKey !== _p.styleKey;\n};\nstyfn$8.clearStyleHints = function (ele) {\n  var _p = ele._private;\n  _p.styleCxtKey = '';\n  _p.styleKeys = {};\n  _p.styleKey = null;\n  _p.labelKey = null;\n  _p.labelStyleKey = null;\n  _p.sourceLabelKey = null;\n  _p.sourceLabelStyleKey = null;\n  _p.targetLabelKey = null;\n  _p.targetLabelStyleKey = null;\n  _p.nodeKey = null;\n  _p.hasPie = null;\n};\n\n// apply a property to the style (for internal use)\n// returns whether application was successful\n//\n// now, this function flattens the property, and here's how:\n//\n// for parsedProp:{ bypass: true, deleteBypass: true }\n// no property is generated, instead the bypass property in the\n// element's style is replaced by what's pointed to by the `bypassed`\n// field in the bypass property (i.e. restoring the property the\n// bypass was overriding)\n//\n// for parsedProp:{ mapped: truthy }\n// the generated flattenedProp:{ mapping: prop }\n//\n// for parsedProp:{ bypass: true }\n// the generated flattenedProp:{ bypassed: parsedProp }\nstyfn$8.applyParsedProperty = function (ele, parsedProp) {\n  var self = this;\n  var prop = parsedProp;\n  var style = ele._private.style;\n  var flatProp;\n  var types = self.types;\n  var type = self.properties[prop.name].type;\n  var propIsBypass = prop.bypass;\n  var origProp = style[prop.name];\n  var origPropIsBypass = origProp && origProp.bypass;\n  var _p = ele._private;\n  var flatPropMapping = 'mapping';\n  var getVal = function getVal(p) {\n    if (p == null) {\n      return null;\n    } else if (p.pfValue != null) {\n      return p.pfValue;\n    } else {\n      return p.value;\n    }\n  };\n  var checkTriggers = function checkTriggers() {\n    var fromVal = getVal(origProp);\n    var toVal = getVal(prop);\n    self.checkTriggers(ele, prop.name, fromVal, toVal);\n  };\n\n  // edge sanity checks to prevent the client from making serious mistakes\n  if (parsedProp.name === 'curve-style' && ele.isEdge() && (\n  // loops must be bundled beziers\n  parsedProp.value !== 'bezier' && ele.isLoop() ||\n  // edges connected to compound nodes can not be haystacks\n  parsedProp.value === 'haystack' && (ele.source().isParent() || ele.target().isParent()))) {\n    prop = parsedProp = this.parse(parsedProp.name, 'bezier', propIsBypass);\n  }\n  if (prop[\"delete\"]) {\n    // delete the property and use the default value on falsey value\n    style[prop.name] = undefined;\n    checkTriggers();\n    return true;\n  }\n  if (prop.deleteBypassed) {\n    // delete the property that the\n    if (!origProp) {\n      checkTriggers();\n      return true; // can't delete if no prop\n    } else if (origProp.bypass) {\n      // delete bypassed\n      origProp.bypassed = undefined;\n      checkTriggers();\n      return true;\n    } else {\n      return false; // we're unsuccessful deleting the bypassed\n    }\n  }\n\n  // check if we need to delete the current bypass\n  if (prop.deleteBypass) {\n    // then this property is just here to indicate we need to delete\n    if (!origProp) {\n      checkTriggers();\n      return true; // property is already not defined\n    } else if (origProp.bypass) {\n      // then replace the bypass property with the original\n      // because the bypassed property was already applied (and therefore parsed), we can just replace it (no reapplying necessary)\n      style[prop.name] = origProp.bypassed;\n      checkTriggers();\n      return true;\n    } else {\n      return false; // we're unsuccessful deleting the bypass\n    }\n  }\n\n  var printMappingErr = function printMappingErr() {\n    warn('Do not assign mappings to elements without corresponding data (i.e. ele `' + ele.id() + '` has no mapping for property `' + prop.name + '` with data field `' + prop.field + '`); try a `[' + prop.field + ']` selector to limit scope to elements with `' + prop.field + '` defined');\n  };\n\n  // put the property in the style objects\n  switch (prop.mapped) {\n    // flatten the property if mapped\n    case types.mapData:\n      {\n        // flatten the field (e.g. data.foo.bar)\n        var fields = prop.field.split('.');\n        var fieldVal = _p.data;\n        for (var i = 0; i < fields.length && fieldVal; i++) {\n          var field = fields[i];\n          fieldVal = fieldVal[field];\n        }\n        if (fieldVal == null) {\n          printMappingErr();\n          return false;\n        }\n        var percent;\n        if (!number$1(fieldVal)) {\n          // then don't apply and fall back on the existing style\n          warn('Do not use continuous mappers without specifying numeric data (i.e. `' + prop.field + ': ' + fieldVal + '` for `' + ele.id() + '` is non-numeric)');\n          return false;\n        } else {\n          var fieldWidth = prop.fieldMax - prop.fieldMin;\n          if (fieldWidth === 0) {\n            // safety check -- not strictly necessary as no props of zero range should be passed here\n            percent = 0;\n          } else {\n            percent = (fieldVal - prop.fieldMin) / fieldWidth;\n          }\n        }\n\n        // make sure to bound percent value\n        if (percent < 0) {\n          percent = 0;\n        } else if (percent > 1) {\n          percent = 1;\n        }\n        if (type.color) {\n          var r1 = prop.valueMin[0];\n          var r2 = prop.valueMax[0];\n          var g1 = prop.valueMin[1];\n          var g2 = prop.valueMax[1];\n          var b1 = prop.valueMin[2];\n          var b2 = prop.valueMax[2];\n          var a1 = prop.valueMin[3] == null ? 1 : prop.valueMin[3];\n          var a2 = prop.valueMax[3] == null ? 1 : prop.valueMax[3];\n          var clr = [Math.round(r1 + (r2 - r1) * percent), Math.round(g1 + (g2 - g1) * percent), Math.round(b1 + (b2 - b1) * percent), Math.round(a1 + (a2 - a1) * percent)];\n          flatProp = {\n            // colours are simple, so just create the flat property instead of expensive string parsing\n            bypass: prop.bypass,\n            // we're a bypass if the mapping property is a bypass\n            name: prop.name,\n            value: clr,\n            strValue: 'rgb(' + clr[0] + ', ' + clr[1] + ', ' + clr[2] + ')'\n          };\n        } else if (type.number) {\n          var calcValue = prop.valueMin + (prop.valueMax - prop.valueMin) * percent;\n          flatProp = this.parse(prop.name, calcValue, prop.bypass, flatPropMapping);\n        } else {\n          return false; // can only map to colours and numbers\n        }\n\n        if (!flatProp) {\n          // if we can't flatten the property, then don't apply the property and fall back on the existing style\n          printMappingErr();\n          return false;\n        }\n        flatProp.mapping = prop; // keep a reference to the mapping\n        prop = flatProp; // the flattened (mapped) property is the one we want\n\n        break;\n      }\n\n    // direct mapping\n    case types.data:\n      {\n        // flatten the field (e.g. data.foo.bar)\n        var _fields = prop.field.split('.');\n        var _fieldVal = _p.data;\n        for (var _i3 = 0; _i3 < _fields.length && _fieldVal; _i3++) {\n          var _field = _fields[_i3];\n          _fieldVal = _fieldVal[_field];\n        }\n        if (_fieldVal != null) {\n          flatProp = this.parse(prop.name, _fieldVal, prop.bypass, flatPropMapping);\n        }\n        if (!flatProp) {\n          // if we can't flatten the property, then don't apply and fall back on the existing style\n          printMappingErr();\n          return false;\n        }\n        flatProp.mapping = prop; // keep a reference to the mapping\n        prop = flatProp; // the flattened (mapped) property is the one we want\n\n        break;\n      }\n    case types.fn:\n      {\n        var fn = prop.value;\n        var fnRetVal = prop.fnValue != null ? prop.fnValue : fn(ele); // check for cached value before calling function\n\n        prop.prevFnValue = fnRetVal;\n        if (fnRetVal == null) {\n          warn('Custom function mappers may not return null (i.e. `' + prop.name + '` for ele `' + ele.id() + '` is null)');\n          return false;\n        }\n        flatProp = this.parse(prop.name, fnRetVal, prop.bypass, flatPropMapping);\n        if (!flatProp) {\n          warn('Custom function mappers may not return invalid values for the property type (i.e. `' + prop.name + '` for ele `' + ele.id() + '` is invalid)');\n          return false;\n        }\n        flatProp.mapping = copy(prop); // keep a reference to the mapping\n        prop = flatProp; // the flattened (mapped) property is the one we want\n\n        break;\n      }\n    case undefined:\n      break;\n    // just set the property\n\n    default:\n      return false;\n    // not a valid mapping\n  }\n\n  // if the property is a bypass property, then link the resultant property to the original one\n  if (propIsBypass) {\n    if (origPropIsBypass) {\n      // then this bypass overrides the existing one\n      prop.bypassed = origProp.bypassed; // steal bypassed prop from old bypass\n    } else {\n      // then link the orig prop to the new bypass\n      prop.bypassed = origProp;\n    }\n    style[prop.name] = prop; // and set\n  } else {\n    // prop is not bypass\n    if (origPropIsBypass) {\n      // then keep the orig prop (since it's a bypass) and link to the new prop\n      origProp.bypassed = prop;\n    } else {\n      // then just replace the old prop with the new one\n      style[prop.name] = prop;\n    }\n  }\n  checkTriggers();\n  return true;\n};\nstyfn$8.cleanElements = function (eles, keepBypasses) {\n  for (var i = 0; i < eles.length; i++) {\n    var ele = eles[i];\n    this.clearStyleHints(ele);\n    ele.dirtyCompoundBoundsCache();\n    ele.dirtyBoundingBoxCache();\n    if (!keepBypasses) {\n      ele._private.style = {};\n    } else {\n      var style = ele._private.style;\n      var propNames = Object.keys(style);\n      for (var j = 0; j < propNames.length; j++) {\n        var propName = propNames[j];\n        var eleProp = style[propName];\n        if (eleProp != null) {\n          if (eleProp.bypass) {\n            eleProp.bypassed = null;\n          } else {\n            style[propName] = null;\n          }\n        }\n      }\n    }\n  }\n};\n\n// updates the visual style for all elements (useful for manual style modification after init)\nstyfn$8.update = function () {\n  var cy = this._private.cy;\n  var eles = cy.mutableElements();\n  eles.updateStyle();\n};\n\n// diffProps : { name => { prev, next } }\nstyfn$8.updateTransitions = function (ele, diffProps) {\n  var self = this;\n  var _p = ele._private;\n  var props = ele.pstyle('transition-property').value;\n  var duration = ele.pstyle('transition-duration').pfValue;\n  var delay = ele.pstyle('transition-delay').pfValue;\n  if (props.length > 0 && duration > 0) {\n    var style = {};\n\n    // build up the style to animate towards\n    var anyPrev = false;\n    for (var i = 0; i < props.length; i++) {\n      var prop = props[i];\n      var styProp = ele.pstyle(prop);\n      var diffProp = diffProps[prop];\n      if (!diffProp) {\n        continue;\n      }\n      var prevProp = diffProp.prev;\n      var fromProp = prevProp;\n      var toProp = diffProp.next != null ? diffProp.next : styProp;\n      var diff = false;\n      var initVal = void 0;\n      var initDt = 0.000001; // delta time % value for initVal (allows animating out of init zero opacity)\n\n      if (!fromProp) {\n        continue;\n      }\n\n      // consider px values\n      if (number$1(fromProp.pfValue) && number$1(toProp.pfValue)) {\n        diff = toProp.pfValue - fromProp.pfValue; // nonzero is truthy\n        initVal = fromProp.pfValue + initDt * diff;\n\n        // consider numerical values\n      } else if (number$1(fromProp.value) && number$1(toProp.value)) {\n        diff = toProp.value - fromProp.value; // nonzero is truthy\n        initVal = fromProp.value + initDt * diff;\n\n        // consider colour values\n      } else if (array(fromProp.value) && array(toProp.value)) {\n        diff = fromProp.value[0] !== toProp.value[0] || fromProp.value[1] !== toProp.value[1] || fromProp.value[2] !== toProp.value[2];\n        initVal = fromProp.strValue;\n      }\n\n      // the previous value is good for an animation only if it's different\n      if (diff) {\n        style[prop] = toProp.strValue; // to val\n        this.applyBypass(ele, prop, initVal); // from val\n        anyPrev = true;\n      }\n    } // end if props allow ani\n\n    // can't transition if there's nothing previous to transition from\n    if (!anyPrev) {\n      return;\n    }\n    _p.transitioning = true;\n    new Promise$1(function (resolve) {\n      if (delay > 0) {\n        ele.delayAnimation(delay).play().promise().then(resolve);\n      } else {\n        resolve();\n      }\n    }).then(function () {\n      return ele.animation({\n        style: style,\n        duration: duration,\n        easing: ele.pstyle('transition-timing-function').value,\n        queue: false\n      }).play().promise();\n    }).then(function () {\n      // if( !isBypass ){\n      self.removeBypasses(ele, props);\n      ele.emitAndNotify('style');\n      // }\n\n      _p.transitioning = false;\n    });\n  } else if (_p.transitioning) {\n    this.removeBypasses(ele, props);\n    ele.emitAndNotify('style');\n    _p.transitioning = false;\n  }\n};\nstyfn$8.checkTrigger = function (ele, name, fromValue, toValue, getTrigger, onTrigger) {\n  var prop = this.properties[name];\n  var triggerCheck = getTrigger(prop);\n  if (triggerCheck != null && triggerCheck(fromValue, toValue)) {\n    onTrigger(prop);\n  }\n};\nstyfn$8.checkZOrderTrigger = function (ele, name, fromValue, toValue) {\n  var _this = this;\n  this.checkTrigger(ele, name, fromValue, toValue, function (prop) {\n    return prop.triggersZOrder;\n  }, function () {\n    _this._private.cy.notify('zorder', ele);\n  });\n};\nstyfn$8.checkBoundsTrigger = function (ele, name, fromValue, toValue) {\n  this.checkTrigger(ele, name, fromValue, toValue, function (prop) {\n    return prop.triggersBounds;\n  }, function (prop) {\n    ele.dirtyCompoundBoundsCache();\n    ele.dirtyBoundingBoxCache();\n\n    // if the prop change makes the bb of pll bezier edges invalid,\n    // then dirty the pll edge bb cache as well\n    if (\n    // only for beziers -- so performance of other edges isn't affected\n    prop.triggersBoundsOfParallelBeziers && name === 'curve-style' && (fromValue === 'bezier' || toValue === 'bezier')) {\n      ele.parallelEdges().forEach(function (pllEdge) {\n        pllEdge.dirtyBoundingBoxCache();\n      });\n    }\n    if (prop.triggersBoundsOfConnectedEdges && name === 'display' && (fromValue === 'none' || toValue === 'none')) {\n      ele.connectedEdges().forEach(function (edge) {\n        edge.dirtyBoundingBoxCache();\n      });\n    }\n  });\n};\nstyfn$8.checkTriggers = function (ele, name, fromValue, toValue) {\n  ele.dirtyStyleCache();\n  this.checkZOrderTrigger(ele, name, fromValue, toValue);\n  this.checkBoundsTrigger(ele, name, fromValue, toValue);\n};\n\nvar styfn$7 = {};\n\n// bypasses are applied to an existing style on an element, and just tacked on temporarily\n// returns true iff application was successful for at least 1 specified property\nstyfn$7.applyBypass = function (eles, name, value, updateTransitions) {\n  var self = this;\n  var props = [];\n  var isBypass = true;\n\n  // put all the properties (can specify one or many) in an array after parsing them\n  if (name === '*' || name === '**') {\n    // apply to all property names\n\n    if (value !== undefined) {\n      for (var i = 0; i < self.properties.length; i++) {\n        var prop = self.properties[i];\n        var _name = prop.name;\n        var parsedProp = this.parse(_name, value, true);\n        if (parsedProp) {\n          props.push(parsedProp);\n        }\n      }\n    }\n  } else if (string(name)) {\n    // then parse the single property\n    var _parsedProp = this.parse(name, value, true);\n    if (_parsedProp) {\n      props.push(_parsedProp);\n    }\n  } else if (plainObject(name)) {\n    // then parse each property\n    var specifiedProps = name;\n    updateTransitions = value;\n    var names = Object.keys(specifiedProps);\n    for (var _i = 0; _i < names.length; _i++) {\n      var _name2 = names[_i];\n      var _value = specifiedProps[_name2];\n      if (_value === undefined) {\n        // try camel case name too\n        _value = specifiedProps[dash2camel(_name2)];\n      }\n      if (_value !== undefined) {\n        var _parsedProp2 = this.parse(_name2, _value, true);\n        if (_parsedProp2) {\n          props.push(_parsedProp2);\n        }\n      }\n    }\n  } else {\n    // can't do anything without well defined properties\n    return false;\n  }\n\n  // we've failed if there are no valid properties\n  if (props.length === 0) {\n    return false;\n  }\n\n  // now, apply the bypass properties on the elements\n  var ret = false; // return true if at least one succesful bypass applied\n  for (var _i2 = 0; _i2 < eles.length; _i2++) {\n    // for each ele\n    var ele = eles[_i2];\n    var diffProps = {};\n    var diffProp = void 0;\n    for (var j = 0; j < props.length; j++) {\n      // for each prop\n      var _prop = props[j];\n      if (updateTransitions) {\n        var prevProp = ele.pstyle(_prop.name);\n        diffProp = diffProps[_prop.name] = {\n          prev: prevProp\n        };\n      }\n      ret = this.applyParsedProperty(ele, copy(_prop)) || ret;\n      if (updateTransitions) {\n        diffProp.next = ele.pstyle(_prop.name);\n      }\n    } // for props\n\n    if (ret) {\n      this.updateStyleHints(ele);\n    }\n    if (updateTransitions) {\n      this.updateTransitions(ele, diffProps, isBypass);\n    }\n  } // for eles\n\n  return ret;\n};\n\n// only useful in specific cases like animation\nstyfn$7.overrideBypass = function (eles, name, value) {\n  name = camel2dash(name);\n  for (var i = 0; i < eles.length; i++) {\n    var ele = eles[i];\n    var prop = ele._private.style[name];\n    var type = this.properties[name].type;\n    var isColor = type.color;\n    var isMulti = type.mutiple;\n    var oldValue = !prop ? null : prop.pfValue != null ? prop.pfValue : prop.value;\n    if (!prop || !prop.bypass) {\n      // need a bypass if one doesn't exist\n      this.applyBypass(ele, name, value);\n    } else {\n      prop.value = value;\n      if (prop.pfValue != null) {\n        prop.pfValue = value;\n      }\n      if (isColor) {\n        prop.strValue = 'rgb(' + value.join(',') + ')';\n      } else if (isMulti) {\n        prop.strValue = value.join(' ');\n      } else {\n        prop.strValue = '' + value;\n      }\n      this.updateStyleHints(ele);\n    }\n    this.checkTriggers(ele, name, oldValue, value);\n  }\n};\nstyfn$7.removeAllBypasses = function (eles, updateTransitions) {\n  return this.removeBypasses(eles, this.propertyNames, updateTransitions);\n};\nstyfn$7.removeBypasses = function (eles, props, updateTransitions) {\n  var isBypass = true;\n  for (var j = 0; j < eles.length; j++) {\n    var ele = eles[j];\n    var diffProps = {};\n    for (var i = 0; i < props.length; i++) {\n      var name = props[i];\n      var prop = this.properties[name];\n      var prevProp = ele.pstyle(prop.name);\n      if (!prevProp || !prevProp.bypass) {\n        // if a bypass doesn't exist for the prop, nothing needs to be removed\n        continue;\n      }\n      var value = ''; // empty => remove bypass\n      var parsedProp = this.parse(name, value, true);\n      var diffProp = diffProps[prop.name] = {\n        prev: prevProp\n      };\n      this.applyParsedProperty(ele, parsedProp);\n      diffProp.next = ele.pstyle(prop.name);\n    } // for props\n\n    this.updateStyleHints(ele);\n    if (updateTransitions) {\n      this.updateTransitions(ele, diffProps, isBypass);\n    }\n  } // for eles\n};\n\nvar styfn$6 = {};\n\n// gets what an em size corresponds to in pixels relative to a dom element\nstyfn$6.getEmSizeInPixels = function () {\n  var px = this.containerCss('font-size');\n  if (px != null) {\n    return parseFloat(px);\n  } else {\n    return 1; // for headless\n  }\n};\n\n// gets css property from the core container\nstyfn$6.containerCss = function (propName) {\n  var cy = this._private.cy;\n  var domElement = cy.container();\n  var containerWindow = cy.window();\n  if (containerWindow && domElement && containerWindow.getComputedStyle) {\n    return containerWindow.getComputedStyle(domElement).getPropertyValue(propName);\n  }\n};\n\nvar styfn$5 = {};\n\n// gets the rendered style for an element\nstyfn$5.getRenderedStyle = function (ele, prop) {\n  if (prop) {\n    return this.getStylePropertyValue(ele, prop, true);\n  } else {\n    return this.getRawStyle(ele, true);\n  }\n};\n\n// gets the raw style for an element\nstyfn$5.getRawStyle = function (ele, isRenderedVal) {\n  var self = this;\n  ele = ele[0]; // insure it's an element\n\n  if (ele) {\n    var rstyle = {};\n    for (var i = 0; i < self.properties.length; i++) {\n      var prop = self.properties[i];\n      var val = self.getStylePropertyValue(ele, prop.name, isRenderedVal);\n      if (val != null) {\n        rstyle[prop.name] = val;\n        rstyle[dash2camel(prop.name)] = val;\n      }\n    }\n    return rstyle;\n  }\n};\nstyfn$5.getIndexedStyle = function (ele, property, subproperty, index) {\n  var pstyle = ele.pstyle(property)[subproperty][index];\n  return pstyle != null ? pstyle : ele.cy().style().getDefaultProperty(property)[subproperty][0];\n};\nstyfn$5.getStylePropertyValue = function (ele, propName, isRenderedVal) {\n  var self = this;\n  ele = ele[0]; // insure it's an element\n\n  if (ele) {\n    var prop = self.properties[propName];\n    if (prop.alias) {\n      prop = prop.pointsTo;\n    }\n    var type = prop.type;\n    var styleProp = ele.pstyle(prop.name);\n    if (styleProp) {\n      var value = styleProp.value,\n        units = styleProp.units,\n        strValue = styleProp.strValue;\n      if (isRenderedVal && type.number && value != null && number$1(value)) {\n        var zoom = ele.cy().zoom();\n        var getRenderedValue = function getRenderedValue(val) {\n          return val * zoom;\n        };\n        var getValueStringWithUnits = function getValueStringWithUnits(val, units) {\n          return getRenderedValue(val) + units;\n        };\n        var isArrayValue = array(value);\n        var haveUnits = isArrayValue ? units.every(function (u) {\n          return u != null;\n        }) : units != null;\n        if (haveUnits) {\n          if (isArrayValue) {\n            return value.map(function (v, i) {\n              return getValueStringWithUnits(v, units[i]);\n            }).join(' ');\n          } else {\n            return getValueStringWithUnits(value, units);\n          }\n        } else {\n          if (isArrayValue) {\n            return value.map(function (v) {\n              return string(v) ? v : '' + getRenderedValue(v);\n            }).join(' ');\n          } else {\n            return '' + getRenderedValue(value);\n          }\n        }\n      } else if (strValue != null) {\n        return strValue;\n      }\n    }\n    return null;\n  }\n};\nstyfn$5.getAnimationStartStyle = function (ele, aniProps) {\n  var rstyle = {};\n  for (var i = 0; i < aniProps.length; i++) {\n    var aniProp = aniProps[i];\n    var name = aniProp.name;\n    var styleProp = ele.pstyle(name);\n    if (styleProp !== undefined) {\n      // then make a prop of it\n      if (plainObject(styleProp)) {\n        styleProp = this.parse(name, styleProp.strValue);\n      } else {\n        styleProp = this.parse(name, styleProp);\n      }\n    }\n    if (styleProp) {\n      rstyle[name] = styleProp;\n    }\n  }\n  return rstyle;\n};\nstyfn$5.getPropsList = function (propsObj) {\n  var self = this;\n  var rstyle = [];\n  var style = propsObj;\n  var props = self.properties;\n  if (style) {\n    var names = Object.keys(style);\n    for (var i = 0; i < names.length; i++) {\n      var name = names[i];\n      var val = style[name];\n      var prop = props[name] || props[camel2dash(name)];\n      var styleProp = this.parse(prop.name, val);\n      if (styleProp) {\n        rstyle.push(styleProp);\n      }\n    }\n  }\n  return rstyle;\n};\nstyfn$5.getNonDefaultPropertiesHash = function (ele, propNames, seed) {\n  var hash = seed.slice();\n  var name, val, strVal, chVal;\n  var i, j;\n  for (i = 0; i < propNames.length; i++) {\n    name = propNames[i];\n    val = ele.pstyle(name, false);\n    if (val == null) {\n      continue;\n    } else if (val.pfValue != null) {\n      hash[0] = hashInt(chVal, hash[0]);\n      hash[1] = hashIntAlt(chVal, hash[1]);\n    } else {\n      strVal = val.strValue;\n      for (j = 0; j < strVal.length; j++) {\n        chVal = strVal.charCodeAt(j);\n        hash[0] = hashInt(chVal, hash[0]);\n        hash[1] = hashIntAlt(chVal, hash[1]);\n      }\n    }\n  }\n  return hash;\n};\nstyfn$5.getPropertiesHash = styfn$5.getNonDefaultPropertiesHash;\n\nvar styfn$4 = {};\nstyfn$4.appendFromJson = function (json) {\n  var style = this;\n  for (var i = 0; i < json.length; i++) {\n    var context = json[i];\n    var selector = context.selector;\n    var props = context.style || context.css;\n    var names = Object.keys(props);\n    style.selector(selector); // apply selector\n\n    for (var j = 0; j < names.length; j++) {\n      var name = names[j];\n      var value = props[name];\n      style.css(name, value); // apply property\n    }\n  }\n\n  return style;\n};\n\n// accessible cy.style() function\nstyfn$4.fromJson = function (json) {\n  var style = this;\n  style.resetToDefault();\n  style.appendFromJson(json);\n  return style;\n};\n\n// get json from cy.style() api\nstyfn$4.json = function () {\n  var json = [];\n  for (var i = this.defaultLength; i < this.length; i++) {\n    var cxt = this[i];\n    var selector = cxt.selector;\n    var props = cxt.properties;\n    var css = {};\n    for (var j = 0; j < props.length; j++) {\n      var prop = props[j];\n      css[prop.name] = prop.strValue;\n    }\n    json.push({\n      selector: !selector ? 'core' : selector.toString(),\n      style: css\n    });\n  }\n  return json;\n};\n\nvar styfn$3 = {};\nstyfn$3.appendFromString = function (string) {\n  var self = this;\n  var style = this;\n  var remaining = '' + string;\n  var selAndBlockStr;\n  var blockRem;\n  var propAndValStr;\n\n  // remove comments from the style string\n  remaining = remaining.replace(/[/][*](\\s|.)+?[*][/]/g, '');\n  function removeSelAndBlockFromRemaining() {\n    // remove the parsed selector and block from the remaining text to parse\n    if (remaining.length > selAndBlockStr.length) {\n      remaining = remaining.substr(selAndBlockStr.length);\n    } else {\n      remaining = '';\n    }\n  }\n  function removePropAndValFromRem() {\n    // remove the parsed property and value from the remaining block text to parse\n    if (blockRem.length > propAndValStr.length) {\n      blockRem = blockRem.substr(propAndValStr.length);\n    } else {\n      blockRem = '';\n    }\n  }\n  for (;;) {\n    var nothingLeftToParse = remaining.match(/^\\s*$/);\n    if (nothingLeftToParse) {\n      break;\n    }\n    var selAndBlock = remaining.match(/^\\s*((?:.|\\s)+?)\\s*\\{((?:.|\\s)+?)\\}/);\n    if (!selAndBlock) {\n      warn('Halting stylesheet parsing: String stylesheet contains more to parse but no selector and block found in: ' + remaining);\n      break;\n    }\n    selAndBlockStr = selAndBlock[0];\n\n    // parse the selector\n    var selectorStr = selAndBlock[1];\n    if (selectorStr !== 'core') {\n      var selector = new Selector(selectorStr);\n      if (selector.invalid) {\n        warn('Skipping parsing of block: Invalid selector found in string stylesheet: ' + selectorStr);\n\n        // skip this selector and block\n        removeSelAndBlockFromRemaining();\n        continue;\n      }\n    }\n\n    // parse the block of properties and values\n    var blockStr = selAndBlock[2];\n    var invalidBlock = false;\n    blockRem = blockStr;\n    var props = [];\n    for (;;) {\n      var _nothingLeftToParse = blockRem.match(/^\\s*$/);\n      if (_nothingLeftToParse) {\n        break;\n      }\n      var propAndVal = blockRem.match(/^\\s*(.+?)\\s*:\\s*(.+?)(?:\\s*;|\\s*$)/);\n      if (!propAndVal) {\n        warn('Skipping parsing of block: Invalid formatting of style property and value definitions found in:' + blockStr);\n        invalidBlock = true;\n        break;\n      }\n      propAndValStr = propAndVal[0];\n      var propStr = propAndVal[1];\n      var valStr = propAndVal[2];\n      var prop = self.properties[propStr];\n      if (!prop) {\n        warn('Skipping property: Invalid property name in: ' + propAndValStr);\n\n        // skip this property in the block\n        removePropAndValFromRem();\n        continue;\n      }\n      var parsedProp = style.parse(propStr, valStr);\n      if (!parsedProp) {\n        warn('Skipping property: Invalid property definition in: ' + propAndValStr);\n\n        // skip this property in the block\n        removePropAndValFromRem();\n        continue;\n      }\n      props.push({\n        name: propStr,\n        val: valStr\n      });\n      removePropAndValFromRem();\n    }\n    if (invalidBlock) {\n      removeSelAndBlockFromRemaining();\n      break;\n    }\n\n    // put the parsed block in the style\n    style.selector(selectorStr);\n    for (var i = 0; i < props.length; i++) {\n      var _prop = props[i];\n      style.css(_prop.name, _prop.val);\n    }\n    removeSelAndBlockFromRemaining();\n  }\n  return style;\n};\nstyfn$3.fromString = function (string) {\n  var style = this;\n  style.resetToDefault();\n  style.appendFromString(string);\n  return style;\n};\n\nvar styfn$2 = {};\n(function () {\n  var number$1 = number;\n  var rgba = rgbaNoBackRefs;\n  var hsla = hslaNoBackRefs;\n  var hex3$1 = hex3;\n  var hex6$1 = hex6;\n  var data = function data(prefix) {\n    return '^' + prefix + '\\\\s*\\\\(\\\\s*([\\\\w\\\\.]+)\\\\s*\\\\)$';\n  };\n  var mapData = function mapData(prefix) {\n    var mapArg = number$1 + '|\\\\w+|' + rgba + '|' + hsla + '|' + hex3$1 + '|' + hex6$1;\n    return '^' + prefix + '\\\\s*\\\\(([\\\\w\\\\.]+)\\\\s*\\\\,\\\\s*(' + number$1 + ')\\\\s*\\\\,\\\\s*(' + number$1 + ')\\\\s*,\\\\s*(' + mapArg + ')\\\\s*\\\\,\\\\s*(' + mapArg + ')\\\\)$';\n  };\n  var urlRegexes = ['^url\\\\s*\\\\(\\\\s*[\\'\"]?(.+?)[\\'\"]?\\\\s*\\\\)$', '^(none)$', '^(.+)$'];\n\n  // each visual style property has a type and needs to be validated according to it\n  styfn$2.types = {\n    time: {\n      number: true,\n      min: 0,\n      units: 's|ms',\n      implicitUnits: 'ms'\n    },\n    percent: {\n      number: true,\n      min: 0,\n      max: 100,\n      units: '%',\n      implicitUnits: '%'\n    },\n    percentages: {\n      number: true,\n      min: 0,\n      max: 100,\n      units: '%',\n      implicitUnits: '%',\n      multiple: true\n    },\n    zeroOneNumber: {\n      number: true,\n      min: 0,\n      max: 1,\n      unitless: true\n    },\n    zeroOneNumbers: {\n      number: true,\n      min: 0,\n      max: 1,\n      unitless: true,\n      multiple: true\n    },\n    nOneOneNumber: {\n      number: true,\n      min: -1,\n      max: 1,\n      unitless: true\n    },\n    nonNegativeInt: {\n      number: true,\n      min: 0,\n      integer: true,\n      unitless: true\n    },\n    nonNegativeNumber: {\n      number: true,\n      min: 0,\n      unitless: true\n    },\n    position: {\n      enums: ['parent', 'origin']\n    },\n    nodeSize: {\n      number: true,\n      min: 0,\n      enums: ['label']\n    },\n    number: {\n      number: true,\n      unitless: true\n    },\n    numbers: {\n      number: true,\n      unitless: true,\n      multiple: true\n    },\n    positiveNumber: {\n      number: true,\n      unitless: true,\n      min: 0,\n      strictMin: true\n    },\n    size: {\n      number: true,\n      min: 0\n    },\n    bidirectionalSize: {\n      number: true\n    },\n    // allows negative\n    bidirectionalSizeMaybePercent: {\n      number: true,\n      allowPercent: true\n    },\n    // allows negative\n    bidirectionalSizes: {\n      number: true,\n      multiple: true\n    },\n    // allows negative\n    sizeMaybePercent: {\n      number: true,\n      min: 0,\n      allowPercent: true\n    },\n    axisDirection: {\n      enums: ['horizontal', 'leftward', 'rightward', 'vertical', 'upward', 'downward', 'auto']\n    },\n    paddingRelativeTo: {\n      enums: ['width', 'height', 'average', 'min', 'max']\n    },\n    bgWH: {\n      number: true,\n      min: 0,\n      allowPercent: true,\n      enums: ['auto'],\n      multiple: true\n    },\n    bgPos: {\n      number: true,\n      allowPercent: true,\n      multiple: true\n    },\n    bgRelativeTo: {\n      enums: ['inner', 'include-padding'],\n      multiple: true\n    },\n    bgRepeat: {\n      enums: ['repeat', 'repeat-x', 'repeat-y', 'no-repeat'],\n      multiple: true\n    },\n    bgFit: {\n      enums: ['none', 'contain', 'cover'],\n      multiple: true\n    },\n    bgCrossOrigin: {\n      enums: ['anonymous', 'use-credentials', 'null'],\n      multiple: true\n    },\n    bgClip: {\n      enums: ['none', 'node'],\n      multiple: true\n    },\n    bgContainment: {\n      enums: ['inside', 'over'],\n      multiple: true\n    },\n    color: {\n      color: true\n    },\n    colors: {\n      color: true,\n      multiple: true\n    },\n    fill: {\n      enums: ['solid', 'linear-gradient', 'radial-gradient']\n    },\n    bool: {\n      enums: ['yes', 'no']\n    },\n    bools: {\n      enums: ['yes', 'no'],\n      multiple: true\n    },\n    lineStyle: {\n      enums: ['solid', 'dotted', 'dashed']\n    },\n    lineCap: {\n      enums: ['butt', 'round', 'square']\n    },\n    linePosition: {\n      enums: ['center', 'inside', 'outside']\n    },\n    lineJoin: {\n      enums: ['round', 'bevel', 'miter']\n    },\n    borderStyle: {\n      enums: ['solid', 'dotted', 'dashed', 'double']\n    },\n    curveStyle: {\n      enums: ['bezier', 'unbundled-bezier', 'haystack', 'segments', 'straight', 'straight-triangle', 'taxi', 'round-segments', 'round-taxi']\n    },\n    radiusType: {\n      enums: ['arc-radius', 'influence-radius'],\n      multiple: true\n    },\n    fontFamily: {\n      regex: '^([\\\\w- \\\\\"]+(?:\\\\s*,\\\\s*[\\\\w- \\\\\"]+)*)$'\n    },\n    fontStyle: {\n      enums: ['italic', 'normal', 'oblique']\n    },\n    fontWeight: {\n      enums: ['normal', 'bold', 'bolder', 'lighter', '100', '200', '300', '400', '500', '600', '800', '900', 100, 200, 300, 400, 500, 600, 700, 800, 900]\n    },\n    textDecoration: {\n      enums: ['none', 'underline', 'overline', 'line-through']\n    },\n    textTransform: {\n      enums: ['none', 'uppercase', 'lowercase']\n    },\n    textWrap: {\n      enums: ['none', 'wrap', 'ellipsis']\n    },\n    textOverflowWrap: {\n      enums: ['whitespace', 'anywhere']\n    },\n    textBackgroundShape: {\n      enums: ['rectangle', 'roundrectangle', 'round-rectangle']\n    },\n    nodeShape: {\n      enums: ['rectangle', 'roundrectangle', 'round-rectangle', 'cutrectangle', 'cut-rectangle', 'bottomroundrectangle', 'bottom-round-rectangle', 'barrel', 'ellipse', 'triangle', 'round-triangle', 'square', 'pentagon', 'round-pentagon', 'hexagon', 'round-hexagon', 'concavehexagon', 'concave-hexagon', 'heptagon', 'round-heptagon', 'octagon', 'round-octagon', 'tag', 'round-tag', 'star', 'diamond', 'round-diamond', 'vee', 'rhomboid', 'right-rhomboid', 'polygon']\n    },\n    overlayShape: {\n      enums: ['roundrectangle', 'round-rectangle', 'ellipse']\n    },\n    cornerRadius: {\n      number: true,\n      min: 0,\n      units: 'px|em',\n      implicitUnits: 'px',\n      enums: ['auto']\n    },\n    compoundIncludeLabels: {\n      enums: ['include', 'exclude']\n    },\n    arrowShape: {\n      enums: ['tee', 'triangle', 'triangle-tee', 'circle-triangle', 'triangle-cross', 'triangle-backcurve', 'vee', 'square', 'circle', 'diamond', 'chevron', 'none']\n    },\n    arrowFill: {\n      enums: ['filled', 'hollow']\n    },\n    arrowWidth: {\n      number: true,\n      units: '%|px|em',\n      implicitUnits: 'px',\n      enums: ['match-line']\n    },\n    display: {\n      enums: ['element', 'none']\n    },\n    visibility: {\n      enums: ['hidden', 'visible']\n    },\n    zCompoundDepth: {\n      enums: ['bottom', 'orphan', 'auto', 'top']\n    },\n    zIndexCompare: {\n      enums: ['auto', 'manual']\n    },\n    valign: {\n      enums: ['top', 'center', 'bottom']\n    },\n    halign: {\n      enums: ['left', 'center', 'right']\n    },\n    justification: {\n      enums: ['left', 'center', 'right', 'auto']\n    },\n    text: {\n      string: true\n    },\n    data: {\n      mapping: true,\n      regex: data('data')\n    },\n    layoutData: {\n      mapping: true,\n      regex: data('layoutData')\n    },\n    scratch: {\n      mapping: true,\n      regex: data('scratch')\n    },\n    mapData: {\n      mapping: true,\n      regex: mapData('mapData')\n    },\n    mapLayoutData: {\n      mapping: true,\n      regex: mapData('mapLayoutData')\n    },\n    mapScratch: {\n      mapping: true,\n      regex: mapData('mapScratch')\n    },\n    fn: {\n      mapping: true,\n      fn: true\n    },\n    url: {\n      regexes: urlRegexes,\n      singleRegexMatchValue: true\n    },\n    urls: {\n      regexes: urlRegexes,\n      singleRegexMatchValue: true,\n      multiple: true\n    },\n    propList: {\n      propList: true\n    },\n    angle: {\n      number: true,\n      units: 'deg|rad',\n      implicitUnits: 'rad'\n    },\n    textRotation: {\n      number: true,\n      units: 'deg|rad',\n      implicitUnits: 'rad',\n      enums: ['none', 'autorotate']\n    },\n    polygonPointList: {\n      number: true,\n      multiple: true,\n      evenMultiple: true,\n      min: -1,\n      max: 1,\n      unitless: true\n    },\n    edgeDistances: {\n      enums: ['intersection', 'node-position', 'endpoints']\n    },\n    edgeEndpoint: {\n      number: true,\n      multiple: true,\n      units: '%|px|em|deg|rad',\n      implicitUnits: 'px',\n      enums: ['inside-to-node', 'outside-to-node', 'outside-to-node-or-label', 'outside-to-line', 'outside-to-line-or-label'],\n      singleEnum: true,\n      validate: function validate(valArr, unitsArr) {\n        switch (valArr.length) {\n          case 2:\n            // can be % or px only\n            return unitsArr[0] !== 'deg' && unitsArr[0] !== 'rad' && unitsArr[1] !== 'deg' && unitsArr[1] !== 'rad';\n          case 1:\n            // can be enum, deg, or rad only\n            return string(valArr[0]) || unitsArr[0] === 'deg' || unitsArr[0] === 'rad';\n          default:\n            return false;\n        }\n      }\n    },\n    easing: {\n      regexes: ['^(spring)\\\\s*\\\\(\\\\s*(' + number$1 + ')\\\\s*,\\\\s*(' + number$1 + ')\\\\s*\\\\)$', '^(cubic-bezier)\\\\s*\\\\(\\\\s*(' + number$1 + ')\\\\s*,\\\\s*(' + number$1 + ')\\\\s*,\\\\s*(' + number$1 + ')\\\\s*,\\\\s*(' + number$1 + ')\\\\s*\\\\)$'],\n      enums: ['linear', 'ease', 'ease-in', 'ease-out', 'ease-in-out', 'ease-in-sine', 'ease-out-sine', 'ease-in-out-sine', 'ease-in-quad', 'ease-out-quad', 'ease-in-out-quad', 'ease-in-cubic', 'ease-out-cubic', 'ease-in-out-cubic', 'ease-in-quart', 'ease-out-quart', 'ease-in-out-quart', 'ease-in-quint', 'ease-out-quint', 'ease-in-out-quint', 'ease-in-expo', 'ease-out-expo', 'ease-in-out-expo', 'ease-in-circ', 'ease-out-circ', 'ease-in-out-circ']\n    },\n    gradientDirection: {\n      enums: ['to-bottom', 'to-top', 'to-left', 'to-right', 'to-bottom-right', 'to-bottom-left', 'to-top-right', 'to-top-left', 'to-right-bottom', 'to-left-bottom', 'to-right-top', 'to-left-top' // different order\n      ]\n    },\n\n    boundsExpansion: {\n      number: true,\n      multiple: true,\n      min: 0,\n      validate: function validate(valArr) {\n        var length = valArr.length;\n        return length === 1 || length === 2 || length === 4;\n      }\n    }\n  };\n  var diff = {\n    zeroNonZero: function zeroNonZero(val1, val2) {\n      if ((val1 == null || val2 == null) && val1 !== val2) {\n        return true; // null cases could represent any value\n      }\n      if (val1 == 0 && val2 != 0) {\n        return true;\n      } else if (val1 != 0 && val2 == 0) {\n        return true;\n      } else {\n        return false;\n      }\n    },\n    any: function any(val1, val2) {\n      return val1 != val2;\n    },\n    emptyNonEmpty: function emptyNonEmpty(str1, str2) {\n      var empty1 = emptyString(str1);\n      var empty2 = emptyString(str2);\n      return empty1 && !empty2 || !empty1 && empty2;\n    }\n  };\n\n  // define visual style properties\n  //\n  // - n.b. adding a new group of props may require updates to updateStyleHints()\n  // - adding new props to an existing group gets handled automatically\n\n  var t = styfn$2.types;\n  var mainLabel = [{\n    name: 'label',\n    type: t.text,\n    triggersBounds: diff.any,\n    triggersZOrder: diff.emptyNonEmpty\n  }, {\n    name: 'text-rotation',\n    type: t.textRotation,\n    triggersBounds: diff.any\n  }, {\n    name: 'text-margin-x',\n    type: t.bidirectionalSize,\n    triggersBounds: diff.any\n  }, {\n    name: 'text-margin-y',\n    type: t.bidirectionalSize,\n    triggersBounds: diff.any\n  }];\n  var sourceLabel = [{\n    name: 'source-label',\n    type: t.text,\n    triggersBounds: diff.any\n  }, {\n    name: 'source-text-rotation',\n    type: t.textRotation,\n    triggersBounds: diff.any\n  }, {\n    name: 'source-text-margin-x',\n    type: t.bidirectionalSize,\n    triggersBounds: diff.any\n  }, {\n    name: 'source-text-margin-y',\n    type: t.bidirectionalSize,\n    triggersBounds: diff.any\n  }, {\n    name: 'source-text-offset',\n    type: t.size,\n    triggersBounds: diff.any\n  }];\n  var targetLabel = [{\n    name: 'target-label',\n    type: t.text,\n    triggersBounds: diff.any\n  }, {\n    name: 'target-text-rotation',\n    type: t.textRotation,\n    triggersBounds: diff.any\n  }, {\n    name: 'target-text-margin-x',\n    type: t.bidirectionalSize,\n    triggersBounds: diff.any\n  }, {\n    name: 'target-text-margin-y',\n    type: t.bidirectionalSize,\n    triggersBounds: diff.any\n  }, {\n    name: 'target-text-offset',\n    type: t.size,\n    triggersBounds: diff.any\n  }];\n  var labelDimensions = [{\n    name: 'font-family',\n    type: t.fontFamily,\n    triggersBounds: diff.any\n  }, {\n    name: 'font-style',\n    type: t.fontStyle,\n    triggersBounds: diff.any\n  }, {\n    name: 'font-weight',\n    type: t.fontWeight,\n    triggersBounds: diff.any\n  }, {\n    name: 'font-size',\n    type: t.size,\n    triggersBounds: diff.any\n  }, {\n    name: 'text-transform',\n    type: t.textTransform,\n    triggersBounds: diff.any\n  }, {\n    name: 'text-wrap',\n    type: t.textWrap,\n    triggersBounds: diff.any\n  }, {\n    name: 'text-overflow-wrap',\n    type: t.textOverflowWrap,\n    triggersBounds: diff.any\n  }, {\n    name: 'text-max-width',\n    type: t.size,\n    triggersBounds: diff.any\n  }, {\n    name: 'text-outline-width',\n    type: t.size,\n    triggersBounds: diff.any\n  }, {\n    name: 'line-height',\n    type: t.positiveNumber,\n    triggersBounds: diff.any\n  }];\n  var commonLabel = [{\n    name: 'text-valign',\n    type: t.valign,\n    triggersBounds: diff.any\n  }, {\n    name: 'text-halign',\n    type: t.halign,\n    triggersBounds: diff.any\n  }, {\n    name: 'color',\n    type: t.color\n  }, {\n    name: 'text-outline-color',\n    type: t.color\n  }, {\n    name: 'text-outline-opacity',\n    type: t.zeroOneNumber\n  }, {\n    name: 'text-background-color',\n    type: t.color\n  }, {\n    name: 'text-background-opacity',\n    type: t.zeroOneNumber\n  }, {\n    name: 'text-background-padding',\n    type: t.size,\n    triggersBounds: diff.any\n  }, {\n    name: 'text-border-opacity',\n    type: t.zeroOneNumber\n  }, {\n    name: 'text-border-color',\n    type: t.color\n  }, {\n    name: 'text-border-width',\n    type: t.size,\n    triggersBounds: diff.any\n  }, {\n    name: 'text-border-style',\n    type: t.borderStyle,\n    triggersBounds: diff.any\n  }, {\n    name: 'text-background-shape',\n    type: t.textBackgroundShape,\n    triggersBounds: diff.any\n  }, {\n    name: 'text-justification',\n    type: t.justification\n  }];\n  var behavior = [{\n    name: 'events',\n    type: t.bool,\n    triggersZOrder: diff.any\n  }, {\n    name: 'text-events',\n    type: t.bool,\n    triggersZOrder: diff.any\n  }];\n  var visibility = [{\n    name: 'display',\n    type: t.display,\n    triggersZOrder: diff.any,\n    triggersBounds: diff.any,\n    triggersBoundsOfConnectedEdges: true\n  }, {\n    name: 'visibility',\n    type: t.visibility,\n    triggersZOrder: diff.any\n  }, {\n    name: 'opacity',\n    type: t.zeroOneNumber,\n    triggersZOrder: diff.zeroNonZero\n  }, {\n    name: 'text-opacity',\n    type: t.zeroOneNumber\n  }, {\n    name: 'min-zoomed-font-size',\n    type: t.size\n  }, {\n    name: 'z-compound-depth',\n    type: t.zCompoundDepth,\n    triggersZOrder: diff.any\n  }, {\n    name: 'z-index-compare',\n    type: t.zIndexCompare,\n    triggersZOrder: diff.any\n  }, {\n    name: 'z-index',\n    type: t.number,\n    triggersZOrder: diff.any\n  }];\n  var overlay = [{\n    name: 'overlay-padding',\n    type: t.size,\n    triggersBounds: diff.any\n  }, {\n    name: 'overlay-color',\n    type: t.color\n  }, {\n    name: 'overlay-opacity',\n    type: t.zeroOneNumber,\n    triggersBounds: diff.zeroNonZero\n  }, {\n    name: 'overlay-shape',\n    type: t.overlayShape,\n    triggersBounds: diff.any\n  }, {\n    name: 'overlay-corner-radius',\n    type: t.cornerRadius\n  }];\n  var underlay = [{\n    name: 'underlay-padding',\n    type: t.size,\n    triggersBounds: diff.any\n  }, {\n    name: 'underlay-color',\n    type: t.color\n  }, {\n    name: 'underlay-opacity',\n    type: t.zeroOneNumber,\n    triggersBounds: diff.zeroNonZero\n  }, {\n    name: 'underlay-shape',\n    type: t.overlayShape,\n    triggersBounds: diff.any\n  }, {\n    name: 'underlay-corner-radius',\n    type: t.cornerRadius\n  }];\n  var transition = [{\n    name: 'transition-property',\n    type: t.propList\n  }, {\n    name: 'transition-duration',\n    type: t.time\n  }, {\n    name: 'transition-delay',\n    type: t.time\n  }, {\n    name: 'transition-timing-function',\n    type: t.easing\n  }];\n  var nodeSizeHashOverride = function nodeSizeHashOverride(ele, parsedProp) {\n    if (parsedProp.value === 'label') {\n      return -ele.poolIndex(); // no hash key hits is using label size (hitrate for perf probably low anyway)\n    } else {\n      return parsedProp.pfValue;\n    }\n  };\n  var nodeBody = [{\n    name: 'height',\n    type: t.nodeSize,\n    triggersBounds: diff.any,\n    hashOverride: nodeSizeHashOverride\n  }, {\n    name: 'width',\n    type: t.nodeSize,\n    triggersBounds: diff.any,\n    hashOverride: nodeSizeHashOverride\n  }, {\n    name: 'shape',\n    type: t.nodeShape,\n    triggersBounds: diff.any\n  }, {\n    name: 'shape-polygon-points',\n    type: t.polygonPointList,\n    triggersBounds: diff.any\n  }, {\n    name: 'corner-radius',\n    type: t.cornerRadius\n  }, {\n    name: 'background-color',\n    type: t.color\n  }, {\n    name: 'background-fill',\n    type: t.fill\n  }, {\n    name: 'background-opacity',\n    type: t.zeroOneNumber\n  }, {\n    name: 'background-blacken',\n    type: t.nOneOneNumber\n  }, {\n    name: 'background-gradient-stop-colors',\n    type: t.colors\n  }, {\n    name: 'background-gradient-stop-positions',\n    type: t.percentages\n  }, {\n    name: 'background-gradient-direction',\n    type: t.gradientDirection\n  }, {\n    name: 'padding',\n    type: t.sizeMaybePercent,\n    triggersBounds: diff.any\n  }, {\n    name: 'padding-relative-to',\n    type: t.paddingRelativeTo,\n    triggersBounds: diff.any\n  }, {\n    name: 'bounds-expansion',\n    type: t.boundsExpansion,\n    triggersBounds: diff.any\n  }];\n  var nodeBorder = [{\n    name: 'border-color',\n    type: t.color\n  }, {\n    name: 'border-opacity',\n    type: t.zeroOneNumber\n  }, {\n    name: 'border-width',\n    type: t.size,\n    triggersBounds: diff.any\n  }, {\n    name: 'border-style',\n    type: t.borderStyle\n  }, {\n    name: 'border-cap',\n    type: t.lineCap\n  }, {\n    name: 'border-join',\n    type: t.lineJoin\n  }, {\n    name: 'border-dash-pattern',\n    type: t.numbers\n  }, {\n    name: 'border-dash-offset',\n    type: t.number\n  }, {\n    name: 'border-position',\n    type: t.linePosition\n  }];\n  var nodeOutline = [{\n    name: 'outline-color',\n    type: t.color\n  }, {\n    name: 'outline-opacity',\n    type: t.zeroOneNumber\n  }, {\n    name: 'outline-width',\n    type: t.size,\n    triggersBounds: diff.any\n  }, {\n    name: 'outline-style',\n    type: t.borderStyle\n  }, {\n    name: 'outline-offset',\n    type: t.size,\n    triggersBounds: diff.any\n  }];\n  var backgroundImage = [{\n    name: 'background-image',\n    type: t.urls\n  }, {\n    name: 'background-image-crossorigin',\n    type: t.bgCrossOrigin\n  }, {\n    name: 'background-image-opacity',\n    type: t.zeroOneNumbers\n  }, {\n    name: 'background-image-containment',\n    type: t.bgContainment\n  }, {\n    name: 'background-image-smoothing',\n    type: t.bools\n  }, {\n    name: 'background-position-x',\n    type: t.bgPos\n  }, {\n    name: 'background-position-y',\n    type: t.bgPos\n  }, {\n    name: 'background-width-relative-to',\n    type: t.bgRelativeTo\n  }, {\n    name: 'background-height-relative-to',\n    type: t.bgRelativeTo\n  }, {\n    name: 'background-repeat',\n    type: t.bgRepeat\n  }, {\n    name: 'background-fit',\n    type: t.bgFit\n  }, {\n    name: 'background-clip',\n    type: t.bgClip\n  }, {\n    name: 'background-width',\n    type: t.bgWH\n  }, {\n    name: 'background-height',\n    type: t.bgWH\n  }, {\n    name: 'background-offset-x',\n    type: t.bgPos\n  }, {\n    name: 'background-offset-y',\n    type: t.bgPos\n  }];\n  var compound = [{\n    name: 'position',\n    type: t.position,\n    triggersBounds: diff.any\n  }, {\n    name: 'compound-sizing-wrt-labels',\n    type: t.compoundIncludeLabels,\n    triggersBounds: diff.any\n  }, {\n    name: 'min-width',\n    type: t.size,\n    triggersBounds: diff.any\n  }, {\n    name: 'min-width-bias-left',\n    type: t.sizeMaybePercent,\n    triggersBounds: diff.any\n  }, {\n    name: 'min-width-bias-right',\n    type: t.sizeMaybePercent,\n    triggersBounds: diff.any\n  }, {\n    name: 'min-height',\n    type: t.size,\n    triggersBounds: diff.any\n  }, {\n    name: 'min-height-bias-top',\n    type: t.sizeMaybePercent,\n    triggersBounds: diff.any\n  }, {\n    name: 'min-height-bias-bottom',\n    type: t.sizeMaybePercent,\n    triggersBounds: diff.any\n  }];\n  var edgeLine = [{\n    name: 'line-style',\n    type: t.lineStyle\n  }, {\n    name: 'line-color',\n    type: t.color\n  }, {\n    name: 'line-fill',\n    type: t.fill\n  }, {\n    name: 'line-cap',\n    type: t.lineCap\n  }, {\n    name: 'line-opacity',\n    type: t.zeroOneNumber\n  }, {\n    name: 'line-dash-pattern',\n    type: t.numbers\n  }, {\n    name: 'line-dash-offset',\n    type: t.number\n  }, {\n    name: 'line-outline-width',\n    type: t.size\n  }, {\n    name: 'line-outline-color',\n    type: t.color\n  }, {\n    name: 'line-gradient-stop-colors',\n    type: t.colors\n  }, {\n    name: 'line-gradient-stop-positions',\n    type: t.percentages\n  }, {\n    name: 'curve-style',\n    type: t.curveStyle,\n    triggersBounds: diff.any,\n    triggersBoundsOfParallelBeziers: true\n  }, {\n    name: 'haystack-radius',\n    type: t.zeroOneNumber,\n    triggersBounds: diff.any\n  }, {\n    name: 'source-endpoint',\n    type: t.edgeEndpoint,\n    triggersBounds: diff.any\n  }, {\n    name: 'target-endpoint',\n    type: t.edgeEndpoint,\n    triggersBounds: diff.any\n  }, {\n    name: 'control-point-step-size',\n    type: t.size,\n    triggersBounds: diff.any\n  }, {\n    name: 'control-point-distances',\n    type: t.bidirectionalSizes,\n    triggersBounds: diff.any\n  }, {\n    name: 'control-point-weights',\n    type: t.numbers,\n    triggersBounds: diff.any\n  }, {\n    name: 'segment-distances',\n    type: t.bidirectionalSizes,\n    triggersBounds: diff.any\n  }, {\n    name: 'segment-weights',\n    type: t.numbers,\n    triggersBounds: diff.any\n  }, {\n    name: 'segment-radii',\n    type: t.numbers,\n    triggersBounds: diff.any\n  }, {\n    name: 'radius-type',\n    type: t.radiusType,\n    triggersBounds: diff.any\n  }, {\n    name: 'taxi-turn',\n    type: t.bidirectionalSizeMaybePercent,\n    triggersBounds: diff.any\n  }, {\n    name: 'taxi-turn-min-distance',\n    type: t.size,\n    triggersBounds: diff.any\n  }, {\n    name: 'taxi-direction',\n    type: t.axisDirection,\n    triggersBounds: diff.any\n  }, {\n    name: 'taxi-radius',\n    type: t.number,\n    triggersBounds: diff.any\n  }, {\n    name: 'edge-distances',\n    type: t.edgeDistances,\n    triggersBounds: diff.any\n  }, {\n    name: 'arrow-scale',\n    type: t.positiveNumber,\n    triggersBounds: diff.any\n  }, {\n    name: 'loop-direction',\n    type: t.angle,\n    triggersBounds: diff.any\n  }, {\n    name: 'loop-sweep',\n    type: t.angle,\n    triggersBounds: diff.any\n  }, {\n    name: 'source-distance-from-node',\n    type: t.size,\n    triggersBounds: diff.any\n  }, {\n    name: 'target-distance-from-node',\n    type: t.size,\n    triggersBounds: diff.any\n  }];\n  var ghost = [{\n    name: 'ghost',\n    type: t.bool,\n    triggersBounds: diff.any\n  }, {\n    name: 'ghost-offset-x',\n    type: t.bidirectionalSize,\n    triggersBounds: diff.any\n  }, {\n    name: 'ghost-offset-y',\n    type: t.bidirectionalSize,\n    triggersBounds: diff.any\n  }, {\n    name: 'ghost-opacity',\n    type: t.zeroOneNumber\n  }];\n  var core = [{\n    name: 'selection-box-color',\n    type: t.color\n  }, {\n    name: 'selection-box-opacity',\n    type: t.zeroOneNumber\n  }, {\n    name: 'selection-box-border-color',\n    type: t.color\n  }, {\n    name: 'selection-box-border-width',\n    type: t.size\n  }, {\n    name: 'active-bg-color',\n    type: t.color\n  }, {\n    name: 'active-bg-opacity',\n    type: t.zeroOneNumber\n  }, {\n    name: 'active-bg-size',\n    type: t.size\n  }, {\n    name: 'outside-texture-bg-color',\n    type: t.color\n  }, {\n    name: 'outside-texture-bg-opacity',\n    type: t.zeroOneNumber\n  }];\n\n  // pie backgrounds for nodes\n  var pie = [];\n  styfn$2.pieBackgroundN = 16; // because the pie properties are numbered, give access to a constant N (for renderer use)\n  pie.push({\n    name: 'pie-size',\n    type: t.sizeMaybePercent\n  });\n  for (var i = 1; i <= styfn$2.pieBackgroundN; i++) {\n    pie.push({\n      name: 'pie-' + i + '-background-color',\n      type: t.color\n    });\n    pie.push({\n      name: 'pie-' + i + '-background-size',\n      type: t.percent\n    });\n    pie.push({\n      name: 'pie-' + i + '-background-opacity',\n      type: t.zeroOneNumber\n    });\n  }\n\n  // edge arrows\n  var edgeArrow = [];\n  var arrowPrefixes = styfn$2.arrowPrefixes = ['source', 'mid-source', 'target', 'mid-target'];\n  [{\n    name: 'arrow-shape',\n    type: t.arrowShape,\n    triggersBounds: diff.any\n  }, {\n    name: 'arrow-color',\n    type: t.color\n  }, {\n    name: 'arrow-fill',\n    type: t.arrowFill\n  }, {\n    name: 'arrow-width',\n    type: t.arrowWidth\n  }].forEach(function (prop) {\n    arrowPrefixes.forEach(function (prefix) {\n      var name = prefix + '-' + prop.name;\n      var type = prop.type,\n        triggersBounds = prop.triggersBounds;\n      edgeArrow.push({\n        name: name,\n        type: type,\n        triggersBounds: triggersBounds\n      });\n    });\n  }, {});\n  var props = styfn$2.properties = [].concat(behavior, transition, visibility, overlay, underlay, ghost, commonLabel, labelDimensions, mainLabel, sourceLabel, targetLabel, nodeBody, nodeBorder, nodeOutline, backgroundImage, pie, compound, edgeLine, edgeArrow, core);\n  var propGroups = styfn$2.propertyGroups = {\n    // common to all eles\n    behavior: behavior,\n    transition: transition,\n    visibility: visibility,\n    overlay: overlay,\n    underlay: underlay,\n    ghost: ghost,\n    // labels\n    commonLabel: commonLabel,\n    labelDimensions: labelDimensions,\n    mainLabel: mainLabel,\n    sourceLabel: sourceLabel,\n    targetLabel: targetLabel,\n    // node props\n    nodeBody: nodeBody,\n    nodeBorder: nodeBorder,\n    nodeOutline: nodeOutline,\n    backgroundImage: backgroundImage,\n    pie: pie,\n    compound: compound,\n    // edge props\n    edgeLine: edgeLine,\n    edgeArrow: edgeArrow,\n    core: core\n  };\n  var propGroupNames = styfn$2.propertyGroupNames = {};\n  var propGroupKeys = styfn$2.propertyGroupKeys = Object.keys(propGroups);\n  propGroupKeys.forEach(function (key) {\n    propGroupNames[key] = propGroups[key].map(function (prop) {\n      return prop.name;\n    });\n    propGroups[key].forEach(function (prop) {\n      return prop.groupKey = key;\n    });\n  });\n\n  // define aliases\n  var aliases = styfn$2.aliases = [{\n    name: 'content',\n    pointsTo: 'label'\n  }, {\n    name: 'control-point-distance',\n    pointsTo: 'control-point-distances'\n  }, {\n    name: 'control-point-weight',\n    pointsTo: 'control-point-weights'\n  }, {\n    name: 'segment-distance',\n    pointsTo: 'segment-distances'\n  }, {\n    name: 'segment-weight',\n    pointsTo: 'segment-weights'\n  }, {\n    name: 'segment-radius',\n    pointsTo: 'segment-radii'\n  }, {\n    name: 'edge-text-rotation',\n    pointsTo: 'text-rotation'\n  }, {\n    name: 'padding-left',\n    pointsTo: 'padding'\n  }, {\n    name: 'padding-right',\n    pointsTo: 'padding'\n  }, {\n    name: 'padding-top',\n    pointsTo: 'padding'\n  }, {\n    name: 'padding-bottom',\n    pointsTo: 'padding'\n  }];\n\n  // list of property names\n  styfn$2.propertyNames = props.map(function (p) {\n    return p.name;\n  });\n\n  // allow access of properties by name ( e.g. style.properties.height )\n  for (var _i = 0; _i < props.length; _i++) {\n    var prop = props[_i];\n    props[prop.name] = prop; // allow lookup by name\n  }\n\n  // map aliases\n  for (var _i2 = 0; _i2 < aliases.length; _i2++) {\n    var alias = aliases[_i2];\n    var pointsToProp = props[alias.pointsTo];\n    var aliasProp = {\n      name: alias.name,\n      alias: true,\n      pointsTo: pointsToProp\n    };\n\n    // add alias prop for parsing\n    props.push(aliasProp);\n    props[alias.name] = aliasProp; // allow lookup by name\n  }\n})();\n\nstyfn$2.getDefaultProperty = function (name) {\n  return this.getDefaultProperties()[name];\n};\nstyfn$2.getDefaultProperties = function () {\n  var _p = this._private;\n  if (_p.defaultProperties != null) {\n    return _p.defaultProperties;\n  }\n  var rawProps = extend({\n    // core props\n    'selection-box-color': '#ddd',\n    'selection-box-opacity': 0.65,\n    'selection-box-border-color': '#aaa',\n    'selection-box-border-width': 1,\n    'active-bg-color': 'black',\n    'active-bg-opacity': 0.15,\n    'active-bg-size': 30,\n    'outside-texture-bg-color': '#000',\n    'outside-texture-bg-opacity': 0.125,\n    // common node/edge props\n    'events': 'yes',\n    'text-events': 'no',\n    'text-valign': 'top',\n    'text-halign': 'center',\n    'text-justification': 'auto',\n    'line-height': 1,\n    'color': '#000',\n    'text-outline-color': '#000',\n    'text-outline-width': 0,\n    'text-outline-opacity': 1,\n    'text-opacity': 1,\n    'text-decoration': 'none',\n    'text-transform': 'none',\n    'text-wrap': 'none',\n    'text-overflow-wrap': 'whitespace',\n    'text-max-width': 9999,\n    'text-background-color': '#000',\n    'text-background-opacity': 0,\n    'text-background-shape': 'rectangle',\n    'text-background-padding': 0,\n    'text-border-opacity': 0,\n    'text-border-width': 0,\n    'text-border-style': 'solid',\n    'text-border-color': '#000',\n    'font-family': 'Helvetica Neue, Helvetica, sans-serif',\n    'font-style': 'normal',\n    'font-weight': 'normal',\n    'font-size': 16,\n    'min-zoomed-font-size': 0,\n    'text-rotation': 'none',\n    'source-text-rotation': 'none',\n    'target-text-rotation': 'none',\n    'visibility': 'visible',\n    'display': 'element',\n    'opacity': 1,\n    'z-compound-depth': 'auto',\n    'z-index-compare': 'auto',\n    'z-index': 0,\n    'label': '',\n    'text-margin-x': 0,\n    'text-margin-y': 0,\n    'source-label': '',\n    'source-text-offset': 0,\n    'source-text-margin-x': 0,\n    'source-text-margin-y': 0,\n    'target-label': '',\n    'target-text-offset': 0,\n    'target-text-margin-x': 0,\n    'target-text-margin-y': 0,\n    'overlay-opacity': 0,\n    'overlay-color': '#000',\n    'overlay-padding': 10,\n    'overlay-shape': 'round-rectangle',\n    'overlay-corner-radius': 'auto',\n    'underlay-opacity': 0,\n    'underlay-color': '#000',\n    'underlay-padding': 10,\n    'underlay-shape': 'round-rectangle',\n    'underlay-corner-radius': 'auto',\n    'transition-property': 'none',\n    'transition-duration': 0,\n    'transition-delay': 0,\n    'transition-timing-function': 'linear',\n    // node props\n    'background-blacken': 0,\n    'background-color': '#999',\n    'background-fill': 'solid',\n    'background-opacity': 1,\n    'background-image': 'none',\n    'background-image-crossorigin': 'anonymous',\n    'background-image-opacity': 1,\n    'background-image-containment': 'inside',\n    'background-image-smoothing': 'yes',\n    'background-position-x': '50%',\n    'background-position-y': '50%',\n    'background-offset-x': 0,\n    'background-offset-y': 0,\n    'background-width-relative-to': 'include-padding',\n    'background-height-relative-to': 'include-padding',\n    'background-repeat': 'no-repeat',\n    'background-fit': 'none',\n    'background-clip': 'node',\n    'background-width': 'auto',\n    'background-height': 'auto',\n    'border-color': '#000',\n    'border-opacity': 1,\n    'border-width': 0,\n    'border-style': 'solid',\n    'border-dash-pattern': [4, 2],\n    'border-dash-offset': 0,\n    'border-cap': 'butt',\n    'border-join': 'miter',\n    'border-position': 'center',\n    'outline-color': '#999',\n    'outline-opacity': 1,\n    'outline-width': 0,\n    'outline-offset': 0,\n    'outline-style': 'solid',\n    'height': 30,\n    'width': 30,\n    'shape': 'ellipse',\n    'shape-polygon-points': '-1, -1,   1, -1,   1, 1,   -1, 1',\n    'corner-radius': 'auto',\n    'bounds-expansion': 0,\n    // node gradient\n    'background-gradient-direction': 'to-bottom',\n    'background-gradient-stop-colors': '#999',\n    'background-gradient-stop-positions': '0%',\n    // ghost props\n    'ghost': 'no',\n    'ghost-offset-y': 0,\n    'ghost-offset-x': 0,\n    'ghost-opacity': 0,\n    // compound props\n    'padding': 0,\n    'padding-relative-to': 'width',\n    'position': 'origin',\n    'compound-sizing-wrt-labels': 'include',\n    'min-width': 0,\n    'min-width-bias-left': 0,\n    'min-width-bias-right': 0,\n    'min-height': 0,\n    'min-height-bias-top': 0,\n    'min-height-bias-bottom': 0\n  }, {\n    // node pie bg\n    'pie-size': '100%'\n  }, [{\n    name: 'pie-{{i}}-background-color',\n    value: 'black'\n  }, {\n    name: 'pie-{{i}}-background-size',\n    value: '0%'\n  }, {\n    name: 'pie-{{i}}-background-opacity',\n    value: 1\n  }].reduce(function (css, prop) {\n    for (var i = 1; i <= styfn$2.pieBackgroundN; i++) {\n      var name = prop.name.replace('{{i}}', i);\n      var val = prop.value;\n      css[name] = val;\n    }\n    return css;\n  }, {}), {\n    // edge props\n    'line-style': 'solid',\n    'line-color': '#999',\n    'line-fill': 'solid',\n    'line-cap': 'butt',\n    'line-opacity': 1,\n    'line-outline-width': 0,\n    'line-outline-color': '#000',\n    'line-gradient-stop-colors': '#999',\n    'line-gradient-stop-positions': '0%',\n    'control-point-step-size': 40,\n    'control-point-weights': 0.5,\n    'segment-weights': 0.5,\n    'segment-distances': 20,\n    'segment-radii': 15,\n    'radius-type': 'arc-radius',\n    'taxi-turn': '50%',\n    'taxi-radius': 15,\n    'taxi-turn-min-distance': 10,\n    'taxi-direction': 'auto',\n    'edge-distances': 'intersection',\n    'curve-style': 'haystack',\n    'haystack-radius': 0,\n    'arrow-scale': 1,\n    'loop-direction': '-45deg',\n    'loop-sweep': '-90deg',\n    'source-distance-from-node': 0,\n    'target-distance-from-node': 0,\n    'source-endpoint': 'outside-to-node',\n    'target-endpoint': 'outside-to-node',\n    'line-dash-pattern': [6, 3],\n    'line-dash-offset': 0\n  }, [{\n    name: 'arrow-shape',\n    value: 'none'\n  }, {\n    name: 'arrow-color',\n    value: '#999'\n  }, {\n    name: 'arrow-fill',\n    value: 'filled'\n  }, {\n    name: 'arrow-width',\n    value: 1\n  }].reduce(function (css, prop) {\n    styfn$2.arrowPrefixes.forEach(function (prefix) {\n      var name = prefix + '-' + prop.name;\n      var val = prop.value;\n      css[name] = val;\n    });\n    return css;\n  }, {}));\n  var parsedProps = {};\n  for (var i = 0; i < this.properties.length; i++) {\n    var prop = this.properties[i];\n    if (prop.pointsTo) {\n      continue;\n    }\n    var name = prop.name;\n    var val = rawProps[name];\n    var parsedProp = this.parse(name, val);\n    parsedProps[name] = parsedProp;\n  }\n  _p.defaultProperties = parsedProps;\n  return _p.defaultProperties;\n};\nstyfn$2.addDefaultStylesheet = function () {\n  this.selector(':parent').css({\n    'shape': 'rectangle',\n    'padding': 10,\n    'background-color': '#eee',\n    'border-color': '#ccc',\n    'border-width': 1\n  }).selector('edge').css({\n    'width': 3\n  }).selector(':loop').css({\n    'curve-style': 'bezier'\n  }).selector('edge:compound').css({\n    'curve-style': 'bezier',\n    'source-endpoint': 'outside-to-line',\n    'target-endpoint': 'outside-to-line'\n  }).selector(':selected').css({\n    'background-color': '#0169D9',\n    'line-color': '#0169D9',\n    'source-arrow-color': '#0169D9',\n    'target-arrow-color': '#0169D9',\n    'mid-source-arrow-color': '#0169D9',\n    'mid-target-arrow-color': '#0169D9'\n  }).selector(':parent:selected').css({\n    'background-color': '#CCE1F9',\n    'border-color': '#aec8e5'\n  }).selector(':active').css({\n    'overlay-color': 'black',\n    'overlay-padding': 10,\n    'overlay-opacity': 0.25\n  });\n  this.defaultLength = this.length;\n};\n\nvar styfn$1 = {};\n\n// a caching layer for property parsing\nstyfn$1.parse = function (name, value, propIsBypass, propIsFlat) {\n  var self = this;\n\n  // function values can't be cached in all cases, and there isn't much benefit of caching them anyway\n  if (fn$6(value)) {\n    return self.parseImplWarn(name, value, propIsBypass, propIsFlat);\n  }\n  var flatKey = propIsFlat === 'mapping' || propIsFlat === true || propIsFlat === false || propIsFlat == null ? 'dontcare' : propIsFlat;\n  var bypassKey = propIsBypass ? 't' : 'f';\n  var valueKey = '' + value;\n  var argHash = hashStrings(name, valueKey, bypassKey, flatKey);\n  var propCache = self.propCache = self.propCache || [];\n  var ret;\n  if (!(ret = propCache[argHash])) {\n    ret = propCache[argHash] = self.parseImplWarn(name, value, propIsBypass, propIsFlat);\n  }\n\n  // - bypasses can't be shared b/c the value can be changed by animations or otherwise overridden\n  // - mappings can't be shared b/c mappings are per-element\n  if (propIsBypass || propIsFlat === 'mapping') {\n    // need a copy since props are mutated later in their lifecycles\n    ret = copy(ret);\n    if (ret) {\n      ret.value = copy(ret.value); // because it could be an array, e.g. colour\n    }\n  }\n\n  return ret;\n};\nstyfn$1.parseImplWarn = function (name, value, propIsBypass, propIsFlat) {\n  var prop = this.parseImpl(name, value, propIsBypass, propIsFlat);\n  if (!prop && value != null) {\n    warn(\"The style property `\".concat(name, \": \").concat(value, \"` is invalid\"));\n  }\n  if (prop && (prop.name === 'width' || prop.name === 'height') && value === 'label') {\n    warn('The style value of `label` is deprecated for `' + prop.name + '`');\n  }\n  return prop;\n};\n\n// parse a property; return null on invalid; return parsed property otherwise\n// fields :\n// - name : the name of the property\n// - value : the parsed, native-typed value of the property\n// - strValue : a string value that represents the property value in valid css\n// - bypass : true iff the property is a bypass property\nstyfn$1.parseImpl = function (name, value, propIsBypass, propIsFlat) {\n  var self = this;\n  name = camel2dash(name); // make sure the property name is in dash form (e.g. 'property-name' not 'propertyName')\n\n  var property = self.properties[name];\n  var passedValue = value;\n  var types = self.types;\n  if (!property) {\n    return null;\n  } // return null on property of unknown name\n  if (value === undefined) {\n    return null;\n  } // can't assign undefined\n\n  // the property may be an alias\n  if (property.alias) {\n    property = property.pointsTo;\n    name = property.name;\n  }\n  var valueIsString = string(value);\n  if (valueIsString) {\n    // trim the value to make parsing easier\n    value = value.trim();\n  }\n  var type = property.type;\n  if (!type) {\n    return null;\n  } // no type, no luck\n\n  // check if bypass is null or empty string (i.e. indication to delete bypass property)\n  if (propIsBypass && (value === '' || value === null)) {\n    return {\n      name: name,\n      value: value,\n      bypass: true,\n      deleteBypass: true\n    };\n  }\n\n  // check if value is a function used as a mapper\n  if (fn$6(value)) {\n    return {\n      name: name,\n      value: value,\n      strValue: 'fn',\n      mapped: types.fn,\n      bypass: propIsBypass\n    };\n  }\n\n  // check if value is mapped\n  var data, mapData;\n  if (!valueIsString || propIsFlat || value.length < 7 || value[1] !== 'a') ; else if (value.length >= 7 && value[0] === 'd' && (data = new RegExp(types.data.regex).exec(value))) {\n    if (propIsBypass) {\n      return false;\n    } // mappers not allowed in bypass\n\n    var mapped = types.data;\n    return {\n      name: name,\n      value: data,\n      strValue: '' + value,\n      mapped: mapped,\n      field: data[1],\n      bypass: propIsBypass\n    };\n  } else if (value.length >= 10 && value[0] === 'm' && (mapData = new RegExp(types.mapData.regex).exec(value))) {\n    if (propIsBypass) {\n      return false;\n    } // mappers not allowed in bypass\n    if (type.multiple) {\n      return false;\n    } // impossible to map to num\n\n    var _mapped = types.mapData;\n\n    // we can map only if the type is a colour or a number\n    if (!(type.color || type.number)) {\n      return false;\n    }\n    var valueMin = this.parse(name, mapData[4]); // parse to validate\n    if (!valueMin || valueMin.mapped) {\n      return false;\n    } // can't be invalid or mapped\n\n    var valueMax = this.parse(name, mapData[5]); // parse to validate\n    if (!valueMax || valueMax.mapped) {\n      return false;\n    } // can't be invalid or mapped\n\n    // check if valueMin and valueMax are the same\n    if (valueMin.pfValue === valueMax.pfValue || valueMin.strValue === valueMax.strValue) {\n      warn('`' + name + ': ' + value + '` is not a valid mapper because the output range is zero; converting to `' + name + ': ' + valueMin.strValue + '`');\n      return this.parse(name, valueMin.strValue); // can't make much of a mapper without a range\n    } else if (type.color) {\n      var c1 = valueMin.value;\n      var c2 = valueMax.value;\n      var same = c1[0] === c2[0] // red\n      && c1[1] === c2[1] // green\n      && c1[2] === c2[2] // blue\n      && (\n      // optional alpha\n      c1[3] === c2[3] // same alpha outright\n      || (c1[3] == null || c1[3] === 1 // full opacity for colour 1?\n      ) && (c2[3] == null || c2[3] === 1) // full opacity for colour 2?\n      );\n\n      if (same) {\n        return false;\n      } // can't make a mapper without a range\n    }\n\n    return {\n      name: name,\n      value: mapData,\n      strValue: '' + value,\n      mapped: _mapped,\n      field: mapData[1],\n      fieldMin: parseFloat(mapData[2]),\n      // min & max are numeric\n      fieldMax: parseFloat(mapData[3]),\n      valueMin: valueMin.value,\n      valueMax: valueMax.value,\n      bypass: propIsBypass\n    };\n  }\n  if (type.multiple && propIsFlat !== 'multiple') {\n    var vals;\n    if (valueIsString) {\n      vals = value.split(/\\s+/);\n    } else if (array(value)) {\n      vals = value;\n    } else {\n      vals = [value];\n    }\n    if (type.evenMultiple && vals.length % 2 !== 0) {\n      return null;\n    }\n    var valArr = [];\n    var unitsArr = [];\n    var pfValArr = [];\n    var strVal = '';\n    var hasEnum = false;\n    for (var i = 0; i < vals.length; i++) {\n      var p = self.parse(name, vals[i], propIsBypass, 'multiple');\n      hasEnum = hasEnum || string(p.value);\n      valArr.push(p.value);\n      pfValArr.push(p.pfValue != null ? p.pfValue : p.value);\n      unitsArr.push(p.units);\n      strVal += (i > 0 ? ' ' : '') + p.strValue;\n    }\n    if (type.validate && !type.validate(valArr, unitsArr)) {\n      return null;\n    }\n    if (type.singleEnum && hasEnum) {\n      if (valArr.length === 1 && string(valArr[0])) {\n        return {\n          name: name,\n          value: valArr[0],\n          strValue: valArr[0],\n          bypass: propIsBypass\n        };\n      } else {\n        return null;\n      }\n    }\n    return {\n      name: name,\n      value: valArr,\n      pfValue: pfValArr,\n      strValue: strVal,\n      bypass: propIsBypass,\n      units: unitsArr\n    };\n  }\n\n  // several types also allow enums\n  var checkEnums = function checkEnums() {\n    for (var _i = 0; _i < type.enums.length; _i++) {\n      var en = type.enums[_i];\n      if (en === value) {\n        return {\n          name: name,\n          value: value,\n          strValue: '' + value,\n          bypass: propIsBypass\n        };\n      }\n    }\n    return null;\n  };\n\n  // check the type and return the appropriate object\n  if (type.number) {\n    var units;\n    var implicitUnits = 'px'; // not set => px\n\n    if (type.units) {\n      // use specified units if set\n      units = type.units;\n    }\n    if (type.implicitUnits) {\n      implicitUnits = type.implicitUnits;\n    }\n    if (!type.unitless) {\n      if (valueIsString) {\n        var unitsRegex = 'px|em' + (type.allowPercent ? '|\\\\%' : '');\n        if (units) {\n          unitsRegex = units;\n        } // only allow explicit units if so set\n        var match = value.match('^(' + number + ')(' + unitsRegex + ')?' + '$');\n        if (match) {\n          value = match[1];\n          units = match[2] || implicitUnits;\n        }\n      } else if (!units || type.implicitUnits) {\n        units = implicitUnits; // implicitly px if unspecified\n      }\n    }\n\n    value = parseFloat(value);\n\n    // if not a number and enums not allowed, then the value is invalid\n    if (isNaN(value) && type.enums === undefined) {\n      return null;\n    }\n\n    // check if this number type also accepts special keywords in place of numbers\n    // (i.e. `left`, `auto`, etc)\n    if (isNaN(value) && type.enums !== undefined) {\n      value = passedValue;\n      return checkEnums();\n    }\n\n    // check if value must be an integer\n    if (type.integer && !integer(value)) {\n      return null;\n    }\n\n    // check value is within range\n    if (type.min !== undefined && (value < type.min || type.strictMin && value === type.min) || type.max !== undefined && (value > type.max || type.strictMax && value === type.max)) {\n      return null;\n    }\n    var ret = {\n      name: name,\n      value: value,\n      strValue: '' + value + (units ? units : ''),\n      units: units,\n      bypass: propIsBypass\n    };\n\n    // normalise value in pixels\n    if (type.unitless || units !== 'px' && units !== 'em') {\n      ret.pfValue = value;\n    } else {\n      ret.pfValue = units === 'px' || !units ? value : this.getEmSizeInPixels() * value;\n    }\n\n    // normalise value in ms\n    if (units === 'ms' || units === 's') {\n      ret.pfValue = units === 'ms' ? value : 1000 * value;\n    }\n\n    // normalise value in rad\n    if (units === 'deg' || units === 'rad') {\n      ret.pfValue = units === 'rad' ? value : deg2rad(value);\n    }\n\n    // normalize value in %\n    if (units === '%') {\n      ret.pfValue = value / 100;\n    }\n    return ret;\n  } else if (type.propList) {\n    var props = [];\n    var propsStr = '' + value;\n    if (propsStr === 'none') ; else {\n      // go over each prop\n\n      var propsSplit = propsStr.split(/\\s*,\\s*|\\s+/);\n      for (var _i2 = 0; _i2 < propsSplit.length; _i2++) {\n        var propName = propsSplit[_i2].trim();\n        if (self.properties[propName]) {\n          props.push(propName);\n        } else {\n          warn('`' + propName + '` is not a valid property name');\n        }\n      }\n      if (props.length === 0) {\n        return null;\n      }\n    }\n    return {\n      name: name,\n      value: props,\n      strValue: props.length === 0 ? 'none' : props.join(' '),\n      bypass: propIsBypass\n    };\n  } else if (type.color) {\n    var tuple = color2tuple(value);\n    if (!tuple) {\n      return null;\n    }\n    return {\n      name: name,\n      value: tuple,\n      pfValue: tuple,\n      strValue: 'rgb(' + tuple[0] + ',' + tuple[1] + ',' + tuple[2] + ')',\n      // n.b. no spaces b/c of multiple support\n      bypass: propIsBypass\n    };\n  } else if (type.regex || type.regexes) {\n    // first check enums\n    if (type.enums) {\n      var enumProp = checkEnums();\n      if (enumProp) {\n        return enumProp;\n      }\n    }\n    var regexes = type.regexes ? type.regexes : [type.regex];\n    for (var _i3 = 0; _i3 < regexes.length; _i3++) {\n      var regex = new RegExp(regexes[_i3]); // make a regex from the type string\n      var m = regex.exec(value);\n      if (m) {\n        // regex matches\n        return {\n          name: name,\n          value: type.singleRegexMatchValue ? m[1] : m,\n          strValue: '' + value,\n          bypass: propIsBypass\n        };\n      }\n    }\n    return null; // didn't match any\n  } else if (type.string) {\n    // just return\n    return {\n      name: name,\n      value: '' + value,\n      strValue: '' + value,\n      bypass: propIsBypass\n    };\n  } else if (type.enums) {\n    // check enums last because it's a combo type in others\n    return checkEnums();\n  } else {\n    return null; // not a type we can handle\n  }\n};\n\nvar Style = function Style(cy) {\n  if (!(this instanceof Style)) {\n    return new Style(cy);\n  }\n  if (!core(cy)) {\n    error('A style must have a core reference');\n    return;\n  }\n  this._private = {\n    cy: cy,\n    coreStyle: {}\n  };\n  this.length = 0;\n  this.resetToDefault();\n};\nvar styfn = Style.prototype;\nstyfn.instanceString = function () {\n  return 'style';\n};\n\n// remove all contexts\nstyfn.clear = function () {\n  var _p = this._private;\n  var cy = _p.cy;\n  var eles = cy.elements();\n  for (var i = 0; i < this.length; i++) {\n    this[i] = undefined;\n  }\n  this.length = 0;\n  _p.contextStyles = {};\n  _p.propDiffs = {};\n  this.cleanElements(eles, true);\n  eles.forEach(function (ele) {\n    var ele_p = ele[0]._private;\n    ele_p.styleDirty = true;\n    ele_p.appliedInitStyle = false;\n  });\n  return this; // chaining\n};\n\nstyfn.resetToDefault = function () {\n  this.clear();\n  this.addDefaultStylesheet();\n  return this;\n};\n\n// builds a style object for the 'core' selector\nstyfn.core = function (propName) {\n  return this._private.coreStyle[propName] || this.getDefaultProperty(propName);\n};\n\n// create a new context from the specified selector string and switch to that context\nstyfn.selector = function (selectorStr) {\n  // 'core' is a special case and does not need a selector\n  var selector = selectorStr === 'core' ? null : new Selector(selectorStr);\n  var i = this.length++; // new context means new index\n  this[i] = {\n    selector: selector,\n    properties: [],\n    mappedProperties: [],\n    index: i\n  };\n  return this; // chaining\n};\n\n// add one or many css rules to the current context\nstyfn.css = function () {\n  var self = this;\n  var args = arguments;\n  if (args.length === 1) {\n    var map = args[0];\n    for (var i = 0; i < self.properties.length; i++) {\n      var prop = self.properties[i];\n      var mapVal = map[prop.name];\n      if (mapVal === undefined) {\n        mapVal = map[dash2camel(prop.name)];\n      }\n      if (mapVal !== undefined) {\n        this.cssRule(prop.name, mapVal);\n      }\n    }\n  } else if (args.length === 2) {\n    this.cssRule(args[0], args[1]);\n  }\n\n  // do nothing if args are invalid\n\n  return this; // chaining\n};\n\nstyfn.style = styfn.css;\n\n// add a single css rule to the current context\nstyfn.cssRule = function (name, value) {\n  // name-value pair\n  var property = this.parse(name, value);\n\n  // add property to current context if valid\n  if (property) {\n    var i = this.length - 1;\n    this[i].properties.push(property);\n    this[i].properties[property.name] = property; // allow access by name as well\n\n    if (property.name.match(/pie-(\\d+)-background-size/) && property.value) {\n      this._private.hasPie = true;\n    }\n    if (property.mapped) {\n      this[i].mappedProperties.push(property);\n    }\n\n    // add to core style if necessary\n    var currentSelectorIsCore = !this[i].selector;\n    if (currentSelectorIsCore) {\n      this._private.coreStyle[property.name] = property;\n    }\n  }\n  return this; // chaining\n};\n\nstyfn.append = function (style) {\n  if (stylesheet(style)) {\n    style.appendToStyle(this);\n  } else if (array(style)) {\n    this.appendFromJson(style);\n  } else if (string(style)) {\n    this.appendFromString(style);\n  } // you probably wouldn't want to append a Style, since you'd duplicate the default parts\n\n  return this;\n};\n\n// static function\nStyle.fromJson = function (cy, json) {\n  var style = new Style(cy);\n  style.fromJson(json);\n  return style;\n};\nStyle.fromString = function (cy, string) {\n  return new Style(cy).fromString(string);\n};\n[styfn$8, styfn$7, styfn$6, styfn$5, styfn$4, styfn$3, styfn$2, styfn$1].forEach(function (props) {\n  extend(styfn, props);\n});\nStyle.types = styfn.types;\nStyle.properties = styfn.properties;\nStyle.propertyGroups = styfn.propertyGroups;\nStyle.propertyGroupNames = styfn.propertyGroupNames;\nStyle.propertyGroupKeys = styfn.propertyGroupKeys;\n\nvar corefn$2 = {\n  style: function style(newStyle) {\n    if (newStyle) {\n      var s = this.setStyle(newStyle);\n      s.update();\n    }\n    return this._private.style;\n  },\n  setStyle: function setStyle(style) {\n    var _p = this._private;\n    if (stylesheet(style)) {\n      _p.style = style.generateStyle(this);\n    } else if (array(style)) {\n      _p.style = Style.fromJson(this, style);\n    } else if (string(style)) {\n      _p.style = Style.fromString(this, style);\n    } else {\n      _p.style = Style(this);\n    }\n    return _p.style;\n  },\n  // e.g. cy.data() changed => recalc ele mappers\n  updateStyle: function updateStyle() {\n    this.mutableElements().updateStyle(); // just send to all eles\n  }\n};\n\nvar defaultSelectionType = 'single';\nvar corefn$1 = {\n  autolock: function autolock(bool) {\n    if (bool !== undefined) {\n      this._private.autolock = bool ? true : false;\n    } else {\n      return this._private.autolock;\n    }\n    return this; // chaining\n  },\n\n  autoungrabify: function autoungrabify(bool) {\n    if (bool !== undefined) {\n      this._private.autoungrabify = bool ? true : false;\n    } else {\n      return this._private.autoungrabify;\n    }\n    return this; // chaining\n  },\n\n  autounselectify: function autounselectify(bool) {\n    if (bool !== undefined) {\n      this._private.autounselectify = bool ? true : false;\n    } else {\n      return this._private.autounselectify;\n    }\n    return this; // chaining\n  },\n\n  selectionType: function selectionType(selType) {\n    var _p = this._private;\n    if (_p.selectionType == null) {\n      _p.selectionType = defaultSelectionType;\n    }\n    if (selType !== undefined) {\n      if (selType === 'additive' || selType === 'single') {\n        _p.selectionType = selType;\n      }\n    } else {\n      return _p.selectionType;\n    }\n    return this;\n  },\n  panningEnabled: function panningEnabled(bool) {\n    if (bool !== undefined) {\n      this._private.panningEnabled = bool ? true : false;\n    } else {\n      return this._private.panningEnabled;\n    }\n    return this; // chaining\n  },\n\n  userPanningEnabled: function userPanningEnabled(bool) {\n    if (bool !== undefined) {\n      this._private.userPanningEnabled = bool ? true : false;\n    } else {\n      return this._private.userPanningEnabled;\n    }\n    return this; // chaining\n  },\n\n  zoomingEnabled: function zoomingEnabled(bool) {\n    if (bool !== undefined) {\n      this._private.zoomingEnabled = bool ? true : false;\n    } else {\n      return this._private.zoomingEnabled;\n    }\n    return this; // chaining\n  },\n\n  userZoomingEnabled: function userZoomingEnabled(bool) {\n    if (bool !== undefined) {\n      this._private.userZoomingEnabled = bool ? true : false;\n    } else {\n      return this._private.userZoomingEnabled;\n    }\n    return this; // chaining\n  },\n\n  boxSelectionEnabled: function boxSelectionEnabled(bool) {\n    if (bool !== undefined) {\n      this._private.boxSelectionEnabled = bool ? true : false;\n    } else {\n      return this._private.boxSelectionEnabled;\n    }\n    return this; // chaining\n  },\n\n  pan: function pan() {\n    var args = arguments;\n    var pan = this._private.pan;\n    var dim, val, dims, x, y;\n    switch (args.length) {\n      case 0:\n        // .pan()\n        return pan;\n      case 1:\n        if (string(args[0])) {\n          // .pan('x')\n          dim = args[0];\n          return pan[dim];\n        } else if (plainObject(args[0])) {\n          // .pan({ x: 0, y: 100 })\n          if (!this._private.panningEnabled) {\n            return this;\n          }\n          dims = args[0];\n          x = dims.x;\n          y = dims.y;\n          if (number$1(x)) {\n            pan.x = x;\n          }\n          if (number$1(y)) {\n            pan.y = y;\n          }\n          this.emit('pan viewport');\n        }\n        break;\n      case 2:\n        // .pan('x', 100)\n        if (!this._private.panningEnabled) {\n          return this;\n        }\n        dim = args[0];\n        val = args[1];\n        if ((dim === 'x' || dim === 'y') && number$1(val)) {\n          pan[dim] = val;\n        }\n        this.emit('pan viewport');\n        break;\n      // invalid\n    }\n\n    this.notify('viewport');\n    return this; // chaining\n  },\n\n  panBy: function panBy(arg0, arg1) {\n    var args = arguments;\n    var pan = this._private.pan;\n    var dim, val, dims, x, y;\n    if (!this._private.panningEnabled) {\n      return this;\n    }\n    switch (args.length) {\n      case 1:\n        if (plainObject(arg0)) {\n          // .panBy({ x: 0, y: 100 })\n          dims = args[0];\n          x = dims.x;\n          y = dims.y;\n          if (number$1(x)) {\n            pan.x += x;\n          }\n          if (number$1(y)) {\n            pan.y += y;\n          }\n          this.emit('pan viewport');\n        }\n        break;\n      case 2:\n        // .panBy('x', 100)\n        dim = arg0;\n        val = arg1;\n        if ((dim === 'x' || dim === 'y') && number$1(val)) {\n          pan[dim] += val;\n        }\n        this.emit('pan viewport');\n        break;\n      // invalid\n    }\n\n    this.notify('viewport');\n    return this; // chaining\n  },\n\n  fit: function fit(elements, padding) {\n    var viewportState = this.getFitViewport(elements, padding);\n    if (viewportState) {\n      var _p = this._private;\n      _p.zoom = viewportState.zoom;\n      _p.pan = viewportState.pan;\n      this.emit('pan zoom viewport');\n      this.notify('viewport');\n    }\n    return this; // chaining\n  },\n\n  getFitViewport: function getFitViewport(elements, padding) {\n    if (number$1(elements) && padding === undefined) {\n      // elements is optional\n      padding = elements;\n      elements = undefined;\n    }\n    if (!this._private.panningEnabled || !this._private.zoomingEnabled) {\n      return;\n    }\n    var bb;\n    if (string(elements)) {\n      var sel = elements;\n      elements = this.$(sel);\n    } else if (boundingBox(elements)) {\n      // assume bb\n      var bbe = elements;\n      bb = {\n        x1: bbe.x1,\n        y1: bbe.y1,\n        x2: bbe.x2,\n        y2: bbe.y2\n      };\n      bb.w = bb.x2 - bb.x1;\n      bb.h = bb.y2 - bb.y1;\n    } else if (!elementOrCollection(elements)) {\n      elements = this.mutableElements();\n    }\n    if (elementOrCollection(elements) && elements.empty()) {\n      return;\n    } // can't fit to nothing\n\n    bb = bb || elements.boundingBox();\n    var w = this.width();\n    var h = this.height();\n    var zoom;\n    padding = number$1(padding) ? padding : 0;\n    if (!isNaN(w) && !isNaN(h) && w > 0 && h > 0 && !isNaN(bb.w) && !isNaN(bb.h) && bb.w > 0 && bb.h > 0) {\n      zoom = Math.min((w - 2 * padding) / bb.w, (h - 2 * padding) / bb.h);\n\n      // crop zoom\n      zoom = zoom > this._private.maxZoom ? this._private.maxZoom : zoom;\n      zoom = zoom < this._private.minZoom ? this._private.minZoom : zoom;\n      var pan = {\n        // now pan to middle\n        x: (w - zoom * (bb.x1 + bb.x2)) / 2,\n        y: (h - zoom * (bb.y1 + bb.y2)) / 2\n      };\n      return {\n        zoom: zoom,\n        pan: pan\n      };\n    }\n    return;\n  },\n  zoomRange: function zoomRange(min, max) {\n    var _p = this._private;\n    if (max == null) {\n      var opts = min;\n      min = opts.min;\n      max = opts.max;\n    }\n    if (number$1(min) && number$1(max) && min <= max) {\n      _p.minZoom = min;\n      _p.maxZoom = max;\n    } else if (number$1(min) && max === undefined && min <= _p.maxZoom) {\n      _p.minZoom = min;\n    } else if (number$1(max) && min === undefined && max >= _p.minZoom) {\n      _p.maxZoom = max;\n    }\n    return this;\n  },\n  minZoom: function minZoom(zoom) {\n    if (zoom === undefined) {\n      return this._private.minZoom;\n    } else {\n      return this.zoomRange({\n        min: zoom\n      });\n    }\n  },\n  maxZoom: function maxZoom(zoom) {\n    if (zoom === undefined) {\n      return this._private.maxZoom;\n    } else {\n      return this.zoomRange({\n        max: zoom\n      });\n    }\n  },\n  getZoomedViewport: function getZoomedViewport(params) {\n    var _p = this._private;\n    var currentPan = _p.pan;\n    var currentZoom = _p.zoom;\n    var pos; // in rendered px\n    var zoom;\n    var bail = false;\n    if (!_p.zoomingEnabled) {\n      // zooming disabled\n      bail = true;\n    }\n    if (number$1(params)) {\n      // then set the zoom\n      zoom = params;\n    } else if (plainObject(params)) {\n      // then zoom about a point\n      zoom = params.level;\n      if (params.position != null) {\n        pos = modelToRenderedPosition(params.position, currentZoom, currentPan);\n      } else if (params.renderedPosition != null) {\n        pos = params.renderedPosition;\n      }\n      if (pos != null && !_p.panningEnabled) {\n        // panning disabled\n        bail = true;\n      }\n    }\n\n    // crop zoom\n    zoom = zoom > _p.maxZoom ? _p.maxZoom : zoom;\n    zoom = zoom < _p.minZoom ? _p.minZoom : zoom;\n\n    // can't zoom with invalid params\n    if (bail || !number$1(zoom) || zoom === currentZoom || pos != null && (!number$1(pos.x) || !number$1(pos.y))) {\n      return null;\n    }\n    if (pos != null) {\n      // set zoom about position\n      var pan1 = currentPan;\n      var zoom1 = currentZoom;\n      var zoom2 = zoom;\n      var pan2 = {\n        x: -zoom2 / zoom1 * (pos.x - pan1.x) + pos.x,\n        y: -zoom2 / zoom1 * (pos.y - pan1.y) + pos.y\n      };\n      return {\n        zoomed: true,\n        panned: true,\n        zoom: zoom2,\n        pan: pan2\n      };\n    } else {\n      // just set the zoom\n      return {\n        zoomed: true,\n        panned: false,\n        zoom: zoom,\n        pan: currentPan\n      };\n    }\n  },\n  zoom: function zoom(params) {\n    if (params === undefined) {\n      // get\n      return this._private.zoom;\n    } else {\n      // set\n      var vp = this.getZoomedViewport(params);\n      var _p = this._private;\n      if (vp == null || !vp.zoomed) {\n        return this;\n      }\n      _p.zoom = vp.zoom;\n      if (vp.panned) {\n        _p.pan.x = vp.pan.x;\n        _p.pan.y = vp.pan.y;\n      }\n      this.emit('zoom' + (vp.panned ? ' pan' : '') + ' viewport');\n      this.notify('viewport');\n      return this; // chaining\n    }\n  },\n\n  viewport: function viewport(opts) {\n    var _p = this._private;\n    var zoomDefd = true;\n    var panDefd = true;\n    var events = []; // to trigger\n    var zoomFailed = false;\n    var panFailed = false;\n    if (!opts) {\n      return this;\n    }\n    if (!number$1(opts.zoom)) {\n      zoomDefd = false;\n    }\n    if (!plainObject(opts.pan)) {\n      panDefd = false;\n    }\n    if (!zoomDefd && !panDefd) {\n      return this;\n    }\n    if (zoomDefd) {\n      var z = opts.zoom;\n      if (z < _p.minZoom || z > _p.maxZoom || !_p.zoomingEnabled) {\n        zoomFailed = true;\n      } else {\n        _p.zoom = z;\n        events.push('zoom');\n      }\n    }\n    if (panDefd && (!zoomFailed || !opts.cancelOnFailedZoom) && _p.panningEnabled) {\n      var p = opts.pan;\n      if (number$1(p.x)) {\n        _p.pan.x = p.x;\n        panFailed = false;\n      }\n      if (number$1(p.y)) {\n        _p.pan.y = p.y;\n        panFailed = false;\n      }\n      if (!panFailed) {\n        events.push('pan');\n      }\n    }\n    if (events.length > 0) {\n      events.push('viewport');\n      this.emit(events.join(' '));\n      this.notify('viewport');\n    }\n    return this; // chaining\n  },\n\n  center: function center(elements) {\n    var pan = this.getCenterPan(elements);\n    if (pan) {\n      this._private.pan = pan;\n      this.emit('pan viewport');\n      this.notify('viewport');\n    }\n    return this; // chaining\n  },\n\n  getCenterPan: function getCenterPan(elements, zoom) {\n    if (!this._private.panningEnabled) {\n      return;\n    }\n    if (string(elements)) {\n      var selector = elements;\n      elements = this.mutableElements().filter(selector);\n    } else if (!elementOrCollection(elements)) {\n      elements = this.mutableElements();\n    }\n    if (elements.length === 0) {\n      return;\n    } // can't centre pan to nothing\n\n    var bb = elements.boundingBox();\n    var w = this.width();\n    var h = this.height();\n    zoom = zoom === undefined ? this._private.zoom : zoom;\n    var pan = {\n      // middle\n      x: (w - zoom * (bb.x1 + bb.x2)) / 2,\n      y: (h - zoom * (bb.y1 + bb.y2)) / 2\n    };\n    return pan;\n  },\n  reset: function reset() {\n    if (!this._private.panningEnabled || !this._private.zoomingEnabled) {\n      return this;\n    }\n    this.viewport({\n      pan: {\n        x: 0,\n        y: 0\n      },\n      zoom: 1\n    });\n    return this; // chaining\n  },\n\n  invalidateSize: function invalidateSize() {\n    this._private.sizeCache = null;\n  },\n  size: function size() {\n    var _p = this._private;\n    var container = _p.container;\n    var cy = this;\n    return _p.sizeCache = _p.sizeCache || (container ? function () {\n      var style = cy.window().getComputedStyle(container);\n      var val = function val(name) {\n        return parseFloat(style.getPropertyValue(name));\n      };\n      return {\n        width: container.clientWidth - val('padding-left') - val('padding-right'),\n        height: container.clientHeight - val('padding-top') - val('padding-bottom')\n      };\n    }() : {\n      // fallback if no container (not 0 b/c can be used for dividing etc)\n      width: 1,\n      height: 1\n    });\n  },\n  width: function width() {\n    return this.size().width;\n  },\n  height: function height() {\n    return this.size().height;\n  },\n  extent: function extent() {\n    var pan = this._private.pan;\n    var zoom = this._private.zoom;\n    var rb = this.renderedExtent();\n    var b = {\n      x1: (rb.x1 - pan.x) / zoom,\n      x2: (rb.x2 - pan.x) / zoom,\n      y1: (rb.y1 - pan.y) / zoom,\n      y2: (rb.y2 - pan.y) / zoom\n    };\n    b.w = b.x2 - b.x1;\n    b.h = b.y2 - b.y1;\n    return b;\n  },\n  renderedExtent: function renderedExtent() {\n    var width = this.width();\n    var height = this.height();\n    return {\n      x1: 0,\n      y1: 0,\n      x2: width,\n      y2: height,\n      w: width,\n      h: height\n    };\n  },\n  multiClickDebounceTime: function multiClickDebounceTime(_int) {\n    if (_int) this._private.multiClickDebounceTime = _int;else return this._private.multiClickDebounceTime;\n    return this; // chaining\n  }\n};\n\n// aliases\ncorefn$1.centre = corefn$1.center;\n\n// backwards compatibility\ncorefn$1.autolockNodes = corefn$1.autolock;\ncorefn$1.autoungrabifyNodes = corefn$1.autoungrabify;\n\nvar fn = {\n  data: define.data({\n    field: 'data',\n    bindingEvent: 'data',\n    allowBinding: true,\n    allowSetting: true,\n    settingEvent: 'data',\n    settingTriggersEvent: true,\n    triggerFnName: 'trigger',\n    allowGetting: true,\n    updateStyle: true\n  }),\n  removeData: define.removeData({\n    field: 'data',\n    event: 'data',\n    triggerFnName: 'trigger',\n    triggerEvent: true,\n    updateStyle: true\n  }),\n  scratch: define.data({\n    field: 'scratch',\n    bindingEvent: 'scratch',\n    allowBinding: true,\n    allowSetting: true,\n    settingEvent: 'scratch',\n    settingTriggersEvent: true,\n    triggerFnName: 'trigger',\n    allowGetting: true,\n    updateStyle: true\n  }),\n  removeScratch: define.removeData({\n    field: 'scratch',\n    event: 'scratch',\n    triggerFnName: 'trigger',\n    triggerEvent: true,\n    updateStyle: true\n  })\n};\n\n// aliases\nfn.attr = fn.data;\nfn.removeAttr = fn.removeData;\n\nvar Core = function Core(opts) {\n  var cy = this;\n  opts = extend({}, opts);\n  var container = opts.container;\n\n  // allow for passing a wrapped jquery object\n  // e.g. cytoscape({ container: $('#cy') })\n  if (container && !htmlElement(container) && htmlElement(container[0])) {\n    container = container[0];\n  }\n  var reg = container ? container._cyreg : null; // e.g. already registered some info (e.g. readies) via jquery\n  reg = reg || {};\n  if (reg && reg.cy) {\n    reg.cy.destroy();\n    reg = {}; // old instance => replace reg completely\n  }\n\n  var readies = reg.readies = reg.readies || [];\n  if (container) {\n    container._cyreg = reg;\n  } // make sure container assoc'd reg points to this cy\n  reg.cy = cy;\n  var head = _window !== undefined && container !== undefined && !opts.headless;\n  var options = opts;\n  options.layout = extend({\n    name: head ? 'grid' : 'null'\n  }, options.layout);\n  options.renderer = extend({\n    name: head ? 'canvas' : 'null'\n  }, options.renderer);\n  var defVal = function defVal(def, val, altVal) {\n    if (val !== undefined) {\n      return val;\n    } else if (altVal !== undefined) {\n      return altVal;\n    } else {\n      return def;\n    }\n  };\n  var _p = this._private = {\n    container: container,\n    // html dom ele container\n    ready: false,\n    // whether ready has been triggered\n    options: options,\n    // cached options\n    elements: new Collection(this),\n    // elements in the graph\n    listeners: [],\n    // list of listeners\n    aniEles: new Collection(this),\n    // elements being animated\n    data: options.data || {},\n    // data for the core\n    scratch: {},\n    // scratch object for core\n    layout: null,\n    renderer: null,\n    destroyed: false,\n    // whether destroy was called\n    notificationsEnabled: true,\n    // whether notifications are sent to the renderer\n    minZoom: 1e-50,\n    maxZoom: 1e50,\n    zoomingEnabled: defVal(true, options.zoomingEnabled),\n    userZoomingEnabled: defVal(true, options.userZoomingEnabled),\n    panningEnabled: defVal(true, options.panningEnabled),\n    userPanningEnabled: defVal(true, options.userPanningEnabled),\n    boxSelectionEnabled: defVal(true, options.boxSelectionEnabled),\n    autolock: defVal(false, options.autolock, options.autolockNodes),\n    autoungrabify: defVal(false, options.autoungrabify, options.autoungrabifyNodes),\n    autounselectify: defVal(false, options.autounselectify),\n    styleEnabled: options.styleEnabled === undefined ? head : options.styleEnabled,\n    zoom: number$1(options.zoom) ? options.zoom : 1,\n    pan: {\n      x: plainObject(options.pan) && number$1(options.pan.x) ? options.pan.x : 0,\n      y: plainObject(options.pan) && number$1(options.pan.y) ? options.pan.y : 0\n    },\n    animation: {\n      // object for currently-running animations\n      current: [],\n      queue: []\n    },\n    hasCompoundNodes: false,\n    multiClickDebounceTime: defVal(250, options.multiClickDebounceTime)\n  };\n  this.createEmitter();\n\n  // set selection type\n  this.selectionType(options.selectionType);\n\n  // init zoom bounds\n  this.zoomRange({\n    min: options.minZoom,\n    max: options.maxZoom\n  });\n  var loadExtData = function loadExtData(extData, next) {\n    var anyIsPromise = extData.some(promise);\n    if (anyIsPromise) {\n      return Promise$1.all(extData).then(next); // load all data asynchronously, then exec rest of init\n    } else {\n      next(extData); // exec synchronously for convenience\n    }\n  };\n\n  // start with the default stylesheet so we have something before loading an external stylesheet\n  if (_p.styleEnabled) {\n    cy.setStyle([]);\n  }\n\n  // create the renderer\n  var rendererOptions = extend({}, options, options.renderer); // allow rendering hints in top level options\n  cy.initRenderer(rendererOptions);\n  var setElesAndLayout = function setElesAndLayout(elements, onload, ondone) {\n    cy.notifications(false);\n\n    // remove old elements\n    var oldEles = cy.mutableElements();\n    if (oldEles.length > 0) {\n      oldEles.remove();\n    }\n    if (elements != null) {\n      if (plainObject(elements) || array(elements)) {\n        cy.add(elements);\n      }\n    }\n    cy.one('layoutready', function (e) {\n      cy.notifications(true);\n      cy.emit(e); // we missed this event by turning notifications off, so pass it on\n\n      cy.one('load', onload);\n      cy.emitAndNotify('load');\n    }).one('layoutstop', function () {\n      cy.one('done', ondone);\n      cy.emit('done');\n    });\n    var layoutOpts = extend({}, cy._private.options.layout);\n    layoutOpts.eles = cy.elements();\n    cy.layout(layoutOpts).run();\n  };\n  loadExtData([options.style, options.elements], function (thens) {\n    var initStyle = thens[0];\n    var initEles = thens[1];\n\n    // init style\n    if (_p.styleEnabled) {\n      cy.style().append(initStyle);\n    }\n\n    // initial load\n    setElesAndLayout(initEles, function () {\n      // onready\n      cy.startAnimationLoop();\n      _p.ready = true;\n\n      // if a ready callback is specified as an option, the bind it\n      if (fn$6(options.ready)) {\n        cy.on('ready', options.ready);\n      }\n\n      // bind all the ready handlers registered before creating this instance\n      for (var i = 0; i < readies.length; i++) {\n        var fn = readies[i];\n        cy.on('ready', fn);\n      }\n      if (reg) {\n        reg.readies = [];\n      } // clear b/c we've bound them all and don't want to keep it around in case a new core uses the same div etc\n\n      cy.emit('ready');\n    }, options.done);\n  });\n};\nvar corefn = Core.prototype; // short alias\n\nextend(corefn, {\n  instanceString: function instanceString() {\n    return 'core';\n  },\n  isReady: function isReady() {\n    return this._private.ready;\n  },\n  destroyed: function destroyed() {\n    return this._private.destroyed;\n  },\n  ready: function ready(fn) {\n    if (this.isReady()) {\n      this.emitter().emit('ready', [], fn); // just calls fn as though triggered via ready event\n    } else {\n      this.on('ready', fn);\n    }\n    return this;\n  },\n  destroy: function destroy() {\n    var cy = this;\n    if (cy.destroyed()) return;\n    cy.stopAnimationLoop();\n    cy.destroyRenderer();\n    this.emit('destroy');\n    cy._private.destroyed = true;\n    return cy;\n  },\n  hasElementWithId: function hasElementWithId(id) {\n    return this._private.elements.hasElementWithId(id);\n  },\n  getElementById: function getElementById(id) {\n    return this._private.elements.getElementById(id);\n  },\n  hasCompoundNodes: function hasCompoundNodes() {\n    return this._private.hasCompoundNodes;\n  },\n  headless: function headless() {\n    return this._private.renderer.isHeadless();\n  },\n  styleEnabled: function styleEnabled() {\n    return this._private.styleEnabled;\n  },\n  addToPool: function addToPool(eles) {\n    this._private.elements.merge(eles);\n    return this; // chaining\n  },\n\n  removeFromPool: function removeFromPool(eles) {\n    this._private.elements.unmerge(eles);\n    return this;\n  },\n  container: function container() {\n    return this._private.container || null;\n  },\n  window: function window() {\n    var container = this._private.container;\n    if (container == null) return _window;\n    var ownerDocument = this._private.container.ownerDocument;\n    if (ownerDocument === undefined || ownerDocument == null) {\n      return _window;\n    }\n    return ownerDocument.defaultView || _window;\n  },\n  mount: function mount(container) {\n    if (container == null) {\n      return;\n    }\n    var cy = this;\n    var _p = cy._private;\n    var options = _p.options;\n    if (!htmlElement(container) && htmlElement(container[0])) {\n      container = container[0];\n    }\n    cy.stopAnimationLoop();\n    cy.destroyRenderer();\n    _p.container = container;\n    _p.styleEnabled = true;\n    cy.invalidateSize();\n    cy.initRenderer(extend({}, options, options.renderer, {\n      // allow custom renderer name to be re-used, otherwise use canvas\n      name: options.renderer.name === 'null' ? 'canvas' : options.renderer.name\n    }));\n    cy.startAnimationLoop();\n    cy.style(options.style);\n    cy.emit('mount');\n    return cy;\n  },\n  unmount: function unmount() {\n    var cy = this;\n    cy.stopAnimationLoop();\n    cy.destroyRenderer();\n    cy.initRenderer({\n      name: 'null'\n    });\n    cy.emit('unmount');\n    return cy;\n  },\n  options: function options() {\n    return copy(this._private.options);\n  },\n  json: function json(obj) {\n    var cy = this;\n    var _p = cy._private;\n    var eles = cy.mutableElements();\n    var getFreshRef = function getFreshRef(ele) {\n      return cy.getElementById(ele.id());\n    };\n    if (plainObject(obj)) {\n      // set\n\n      cy.startBatch();\n      if (obj.elements) {\n        var idInJson = {};\n        var updateEles = function updateEles(jsons, gr) {\n          var toAdd = [];\n          var toMod = [];\n          for (var i = 0; i < jsons.length; i++) {\n            var json = jsons[i];\n            if (!json.data.id) {\n              warn('cy.json() cannot handle elements without an ID attribute');\n              continue;\n            }\n            var id = '' + json.data.id; // id must be string\n            var ele = cy.getElementById(id);\n            idInJson[id] = true;\n            if (ele.length !== 0) {\n              // existing element should be updated\n              toMod.push({\n                ele: ele,\n                json: json\n              });\n            } else {\n              // otherwise should be added\n              if (gr) {\n                json.group = gr;\n                toAdd.push(json);\n              } else {\n                toAdd.push(json);\n              }\n            }\n          }\n          cy.add(toAdd);\n          for (var _i = 0; _i < toMod.length; _i++) {\n            var _toMod$_i = toMod[_i],\n              _ele = _toMod$_i.ele,\n              _json = _toMod$_i.json;\n            _ele.json(_json);\n          }\n        };\n        if (array(obj.elements)) {\n          // elements: []\n          updateEles(obj.elements);\n        } else {\n          // elements: { nodes: [], edges: [] }\n          var grs = ['nodes', 'edges'];\n          for (var i = 0; i < grs.length; i++) {\n            var gr = grs[i];\n            var elements = obj.elements[gr];\n            if (array(elements)) {\n              updateEles(elements, gr);\n            }\n          }\n        }\n        var parentsToRemove = cy.collection();\n        eles.filter(function (ele) {\n          return !idInJson[ele.id()];\n        }).forEach(function (ele) {\n          if (ele.isParent()) {\n            parentsToRemove.merge(ele);\n          } else {\n            ele.remove();\n          }\n        });\n\n        // so that children are not removed w/parent\n        parentsToRemove.forEach(function (ele) {\n          return ele.children().move({\n            parent: null\n          });\n        });\n\n        // intermediate parents may be moved by prior line, so make sure we remove by fresh refs\n        parentsToRemove.forEach(function (ele) {\n          return getFreshRef(ele).remove();\n        });\n      }\n      if (obj.style) {\n        cy.style(obj.style);\n      }\n      if (obj.zoom != null && obj.zoom !== _p.zoom) {\n        cy.zoom(obj.zoom);\n      }\n      if (obj.pan) {\n        if (obj.pan.x !== _p.pan.x || obj.pan.y !== _p.pan.y) {\n          cy.pan(obj.pan);\n        }\n      }\n      if (obj.data) {\n        cy.data(obj.data);\n      }\n      var fields = ['minZoom', 'maxZoom', 'zoomingEnabled', 'userZoomingEnabled', 'panningEnabled', 'userPanningEnabled', 'boxSelectionEnabled', 'autolock', 'autoungrabify', 'autounselectify', 'multiClickDebounceTime'];\n      for (var _i2 = 0; _i2 < fields.length; _i2++) {\n        var f = fields[_i2];\n        if (obj[f] != null) {\n          cy[f](obj[f]);\n        }\n      }\n      cy.endBatch();\n      return this; // chaining\n    } else {\n      // get\n      var flat = !!obj;\n      var json = {};\n      if (flat) {\n        json.elements = this.elements().map(function (ele) {\n          return ele.json();\n        });\n      } else {\n        json.elements = {};\n        eles.forEach(function (ele) {\n          var group = ele.group();\n          if (!json.elements[group]) {\n            json.elements[group] = [];\n          }\n          json.elements[group].push(ele.json());\n        });\n      }\n      if (this._private.styleEnabled) {\n        json.style = cy.style().json();\n      }\n      json.data = copy(cy.data());\n      var options = _p.options;\n      json.zoomingEnabled = _p.zoomingEnabled;\n      json.userZoomingEnabled = _p.userZoomingEnabled;\n      json.zoom = _p.zoom;\n      json.minZoom = _p.minZoom;\n      json.maxZoom = _p.maxZoom;\n      json.panningEnabled = _p.panningEnabled;\n      json.userPanningEnabled = _p.userPanningEnabled;\n      json.pan = copy(_p.pan);\n      json.boxSelectionEnabled = _p.boxSelectionEnabled;\n      json.renderer = copy(options.renderer);\n      json.hideEdgesOnViewport = options.hideEdgesOnViewport;\n      json.textureOnViewport = options.textureOnViewport;\n      json.wheelSensitivity = options.wheelSensitivity;\n      json.motionBlur = options.motionBlur;\n      json.multiClickDebounceTime = options.multiClickDebounceTime;\n      return json;\n    }\n  }\n});\ncorefn.$id = corefn.getElementById;\n[corefn$9, corefn$8, elesfn, corefn$7, corefn$6, corefn$5, corefn$4, corefn$3, corefn$2, corefn$1, fn].forEach(function (props) {\n  extend(corefn, props);\n});\n\n/* eslint-disable no-unused-vars */\nvar defaults$7 = {\n  fit: true,\n  // whether to fit the viewport to the graph\n  directed: false,\n  // whether the tree is directed downwards (or edges can point in any direction if false)\n  padding: 30,\n  // padding on fit\n  circle: false,\n  // put depths in concentric circles if true, put depths top down if false\n  grid: false,\n  // whether to create an even grid into which the DAG is placed (circle:false only)\n  spacingFactor: 1.75,\n  // positive spacing factor, larger => more space between nodes (N.B. n/a if causes overlap)\n  boundingBox: undefined,\n  // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }\n  avoidOverlap: true,\n  // prevents node overlap, may overflow boundingBox if not enough space\n  nodeDimensionsIncludeLabels: false,\n  // Excludes the label when calculating node bounding boxes for the layout algorithm\n  roots: undefined,\n  // the roots of the trees\n  depthSort: undefined,\n  // a sorting function to order nodes at equal depth. e.g. function(a, b){ return a.data('weight') - b.data('weight') }\n  animate: false,\n  // whether to transition the node positions\n  animationDuration: 500,\n  // duration of animation in ms if enabled\n  animationEasing: undefined,\n  // easing of animation if enabled,\n  animateFilter: function animateFilter(node, i) {\n    return true;\n  },\n  // a function that determines whether the node should be animated.  All nodes animated by default on animate enabled.  Non-animated nodes are positioned immediately when the layout starts\n  ready: undefined,\n  // callback on layoutready\n  stop: undefined,\n  // callback on layoutstop\n  transform: function transform(node, position) {\n    return position;\n  } // transform a given node position. Useful for changing flow direction in discrete layouts\n};\n\nvar deprecatedOptionDefaults = {\n  maximal: false,\n  // whether to shift nodes down their natural BFS depths in order to avoid upwards edges (DAGS only); setting acyclic to true sets maximal to true also\n  acyclic: false // whether the tree is acyclic and thus a node could be shifted (due to the maximal option) multiple times without causing an infinite loop; setting to true sets maximal to true also; if you are uncertain whether a tree is acyclic, set to false to avoid potential infinite loops\n};\n\n/* eslint-enable */\n\nvar getInfo = function getInfo(ele) {\n  return ele.scratch('breadthfirst');\n};\nvar setInfo = function setInfo(ele, obj) {\n  return ele.scratch('breadthfirst', obj);\n};\nfunction BreadthFirstLayout(options) {\n  this.options = extend({}, defaults$7, deprecatedOptionDefaults, options);\n}\nBreadthFirstLayout.prototype.run = function () {\n  var params = this.options;\n  var options = params;\n  var cy = params.cy;\n  var eles = options.eles;\n  var nodes = eles.nodes().filter(function (n) {\n    return !n.isParent();\n  });\n  var graph = eles;\n  var directed = options.directed;\n  var maximal = options.acyclic || options.maximal || options.maximalAdjustments > 0; // maximalAdjustments for compat. w/ old code; also, setting acyclic to true sets maximal to true\n\n  var bb = makeBoundingBox(options.boundingBox ? options.boundingBox : {\n    x1: 0,\n    y1: 0,\n    w: cy.width(),\n    h: cy.height()\n  });\n  var roots;\n  if (elementOrCollection(options.roots)) {\n    roots = options.roots;\n  } else if (array(options.roots)) {\n    var rootsArray = [];\n    for (var i = 0; i < options.roots.length; i++) {\n      var id = options.roots[i];\n      var ele = cy.getElementById(id);\n      rootsArray.push(ele);\n    }\n    roots = cy.collection(rootsArray);\n  } else if (string(options.roots)) {\n    roots = cy.$(options.roots);\n  } else {\n    if (directed) {\n      roots = nodes.roots();\n    } else {\n      var components = eles.components();\n      roots = cy.collection();\n      var _loop = function _loop(_i) {\n        var comp = components[_i];\n        var maxDegree = comp.maxDegree(false);\n        var compRoots = comp.filter(function (ele) {\n          return ele.degree(false) === maxDegree;\n        });\n        roots = roots.add(compRoots);\n      };\n      for (var _i = 0; _i < components.length; _i++) {\n        _loop(_i);\n      }\n    }\n  }\n  var depths = [];\n  var foundByBfs = {};\n  var addToDepth = function addToDepth(ele, d) {\n    if (depths[d] == null) {\n      depths[d] = [];\n    }\n    var i = depths[d].length;\n    depths[d].push(ele);\n    setInfo(ele, {\n      index: i,\n      depth: d\n    });\n  };\n  var changeDepth = function changeDepth(ele, newDepth) {\n    var _getInfo = getInfo(ele),\n      depth = _getInfo.depth,\n      index = _getInfo.index;\n    depths[depth][index] = null;\n    addToDepth(ele, newDepth);\n  };\n\n  // find the depths of the nodes\n  graph.bfs({\n    roots: roots,\n    directed: options.directed,\n    visit: function visit(node, edge, pNode, i, depth) {\n      var ele = node[0];\n      var id = ele.id();\n      addToDepth(ele, depth);\n      foundByBfs[id] = true;\n    }\n  });\n\n  // check for nodes not found by bfs\n  var orphanNodes = [];\n  for (var _i2 = 0; _i2 < nodes.length; _i2++) {\n    var _ele = nodes[_i2];\n    if (foundByBfs[_ele.id()]) {\n      continue;\n    } else {\n      orphanNodes.push(_ele);\n    }\n  }\n\n  // assign the nodes a depth and index\n\n  var assignDepthsAt = function assignDepthsAt(i) {\n    var eles = depths[i];\n    for (var j = 0; j < eles.length; j++) {\n      var _ele2 = eles[j];\n      if (_ele2 == null) {\n        eles.splice(j, 1);\n        j--;\n        continue;\n      }\n      setInfo(_ele2, {\n        depth: i,\n        index: j\n      });\n    }\n  };\n  var assignDepths = function assignDepths() {\n    for (var _i3 = 0; _i3 < depths.length; _i3++) {\n      assignDepthsAt(_i3);\n    }\n  };\n  var adjustMaximally = function adjustMaximally(ele, shifted) {\n    var eInfo = getInfo(ele);\n    var incomers = ele.incomers().filter(function (el) {\n      return el.isNode() && eles.has(el);\n    });\n    var maxDepth = -1;\n    var id = ele.id();\n    for (var k = 0; k < incomers.length; k++) {\n      var incmr = incomers[k];\n      var iInfo = getInfo(incmr);\n      maxDepth = Math.max(maxDepth, iInfo.depth);\n    }\n    if (eInfo.depth <= maxDepth) {\n      if (!options.acyclic && shifted[id]) {\n        return null;\n      }\n      var newDepth = maxDepth + 1;\n      changeDepth(ele, newDepth);\n      shifted[id] = newDepth;\n      return true;\n    }\n    return false;\n  };\n\n  // for the directed case, try to make the edges all go down (i.e. depth i => depth i + 1)\n  if (directed && maximal) {\n    var Q = [];\n    var shifted = {};\n    var enqueue = function enqueue(n) {\n      return Q.push(n);\n    };\n    var dequeue = function dequeue() {\n      return Q.shift();\n    };\n    nodes.forEach(function (n) {\n      return Q.push(n);\n    });\n    while (Q.length > 0) {\n      var _ele3 = dequeue();\n      var didShift = adjustMaximally(_ele3, shifted);\n      if (didShift) {\n        _ele3.outgoers().filter(function (el) {\n          return el.isNode() && eles.has(el);\n        }).forEach(enqueue);\n      } else if (didShift === null) {\n        warn('Detected double maximal shift for node `' + _ele3.id() + '`.  Bailing maximal adjustment due to cycle.  Use `options.maximal: true` only on DAGs.');\n        break; // exit on failure\n      }\n    }\n  }\n\n  assignDepths(); // clear holes\n\n  // find min distance we need to leave between nodes\n  var minDistance = 0;\n  if (options.avoidOverlap) {\n    for (var _i4 = 0; _i4 < nodes.length; _i4++) {\n      var n = nodes[_i4];\n      var nbb = n.layoutDimensions(options);\n      var w = nbb.w;\n      var h = nbb.h;\n      minDistance = Math.max(minDistance, w, h);\n    }\n  }\n\n  // get the weighted percent for an element based on its connectivity to other levels\n  var cachedWeightedPercent = {};\n  var getWeightedPercent = function getWeightedPercent(ele) {\n    if (cachedWeightedPercent[ele.id()]) {\n      return cachedWeightedPercent[ele.id()];\n    }\n    var eleDepth = getInfo(ele).depth;\n    var neighbors = ele.neighborhood();\n    var percent = 0;\n    var samples = 0;\n    for (var _i5 = 0; _i5 < neighbors.length; _i5++) {\n      var neighbor = neighbors[_i5];\n      if (neighbor.isEdge() || neighbor.isParent() || !nodes.has(neighbor)) {\n        continue;\n      }\n      var bf = getInfo(neighbor);\n      if (bf == null) {\n        continue;\n      }\n      var index = bf.index;\n      var depth = bf.depth;\n\n      // unassigned neighbours shouldn't affect the ordering\n      if (index == null || depth == null) {\n        continue;\n      }\n      var nDepth = depths[depth].length;\n      if (depth < eleDepth) {\n        // only get influenced by elements above\n        percent += index / nDepth;\n        samples++;\n      }\n    }\n    samples = Math.max(1, samples);\n    percent = percent / samples;\n    if (samples === 0) {\n      // put lone nodes at the start\n      percent = 0;\n    }\n    cachedWeightedPercent[ele.id()] = percent;\n    return percent;\n  };\n\n  // rearrange the indices in each depth level based on connectivity\n\n  var sortFn = function sortFn(a, b) {\n    var apct = getWeightedPercent(a);\n    var bpct = getWeightedPercent(b);\n    var diff = apct - bpct;\n    if (diff === 0) {\n      return ascending(a.id(), b.id()); // make sure sort doesn't have don't-care comparisons\n    } else {\n      return diff;\n    }\n  };\n  if (options.depthSort !== undefined) {\n    sortFn = options.depthSort;\n  }\n\n  // sort each level to make connected nodes closer\n  for (var _i6 = 0; _i6 < depths.length; _i6++) {\n    depths[_i6].sort(sortFn);\n    assignDepthsAt(_i6);\n  }\n\n  // assign orphan nodes to a new top-level depth\n  var orphanDepth = [];\n  for (var _i7 = 0; _i7 < orphanNodes.length; _i7++) {\n    orphanDepth.push(orphanNodes[_i7]);\n  }\n  depths.unshift(orphanDepth);\n  assignDepths();\n  var biggestDepthSize = 0;\n  for (var _i8 = 0; _i8 < depths.length; _i8++) {\n    biggestDepthSize = Math.max(depths[_i8].length, biggestDepthSize);\n  }\n  var center = {\n    x: bb.x1 + bb.w / 2,\n    y: bb.x1 + bb.h / 2\n  };\n  var maxDepthSize = depths.reduce(function (max, eles) {\n    return Math.max(max, eles.length);\n  }, 0);\n  var getPosition = function getPosition(ele) {\n    var _getInfo2 = getInfo(ele),\n      depth = _getInfo2.depth,\n      index = _getInfo2.index;\n    var depthSize = depths[depth].length;\n    var distanceX = Math.max(bb.w / ((options.grid ? maxDepthSize : depthSize) + 1), minDistance);\n    var distanceY = Math.max(bb.h / (depths.length + 1), minDistance);\n    var radiusStepSize = Math.min(bb.w / 2 / depths.length, bb.h / 2 / depths.length);\n    radiusStepSize = Math.max(radiusStepSize, minDistance);\n    if (!options.circle) {\n      var epos = {\n        x: center.x + (index + 1 - (depthSize + 1) / 2) * distanceX,\n        y: (depth + 1) * distanceY\n      };\n      return epos;\n    } else {\n      var radius = radiusStepSize * depth + radiusStepSize - (depths.length > 0 && depths[0].length <= 3 ? radiusStepSize / 2 : 0);\n      var theta = 2 * Math.PI / depths[depth].length * index;\n      if (depth === 0 && depths[0].length === 1) {\n        radius = 1;\n      }\n      return {\n        x: center.x + radius * Math.cos(theta),\n        y: center.y + radius * Math.sin(theta)\n      };\n    }\n  };\n  eles.nodes().layoutPositions(this, options, getPosition);\n  return this; // chaining\n};\n\nvar defaults$6 = {\n  fit: true,\n  // whether to fit the viewport to the graph\n  padding: 30,\n  // the padding on fit\n  boundingBox: undefined,\n  // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }\n  avoidOverlap: true,\n  // prevents node overlap, may overflow boundingBox and radius if not enough space\n  nodeDimensionsIncludeLabels: false,\n  // Excludes the label when calculating node bounding boxes for the layout algorithm\n  spacingFactor: undefined,\n  // Applies a multiplicative factor (>0) to expand or compress the overall area that the nodes take up\n  radius: undefined,\n  // the radius of the circle\n  startAngle: 3 / 2 * Math.PI,\n  // where nodes start in radians\n  sweep: undefined,\n  // how many radians should be between the first and last node (defaults to full circle)\n  clockwise: true,\n  // whether the layout should go clockwise (true) or counterclockwise/anticlockwise (false)\n  sort: undefined,\n  // a sorting function to order the nodes; e.g. function(a, b){ return a.data('weight') - b.data('weight') }\n  animate: false,\n  // whether to transition the node positions\n  animationDuration: 500,\n  // duration of animation in ms if enabled\n  animationEasing: undefined,\n  // easing of animation if enabled\n  animateFilter: function animateFilter(node, i) {\n    return true;\n  },\n  // a function that determines whether the node should be animated.  All nodes animated by default on animate enabled.  Non-animated nodes are positioned immediately when the layout starts\n  ready: undefined,\n  // callback on layoutready\n  stop: undefined,\n  // callback on layoutstop\n  transform: function transform(node, position) {\n    return position;\n  } // transform a given node position. Useful for changing flow direction in discrete layouts \n};\n\nfunction CircleLayout(options) {\n  this.options = extend({}, defaults$6, options);\n}\nCircleLayout.prototype.run = function () {\n  var params = this.options;\n  var options = params;\n  var cy = params.cy;\n  var eles = options.eles;\n  var clockwise = options.counterclockwise !== undefined ? !options.counterclockwise : options.clockwise;\n  var nodes = eles.nodes().not(':parent');\n  if (options.sort) {\n    nodes = nodes.sort(options.sort);\n  }\n  var bb = makeBoundingBox(options.boundingBox ? options.boundingBox : {\n    x1: 0,\n    y1: 0,\n    w: cy.width(),\n    h: cy.height()\n  });\n  var center = {\n    x: bb.x1 + bb.w / 2,\n    y: bb.y1 + bb.h / 2\n  };\n  var sweep = options.sweep === undefined ? 2 * Math.PI - 2 * Math.PI / nodes.length : options.sweep;\n  var dTheta = sweep / Math.max(1, nodes.length - 1);\n  var r;\n  var minDistance = 0;\n  for (var i = 0; i < nodes.length; i++) {\n    var n = nodes[i];\n    var nbb = n.layoutDimensions(options);\n    var w = nbb.w;\n    var h = nbb.h;\n    minDistance = Math.max(minDistance, w, h);\n  }\n  if (number$1(options.radius)) {\n    r = options.radius;\n  } else if (nodes.length <= 1) {\n    r = 0;\n  } else {\n    r = Math.min(bb.h, bb.w) / 2 - minDistance;\n  }\n\n  // calculate the radius\n  if (nodes.length > 1 && options.avoidOverlap) {\n    // but only if more than one node (can't overlap)\n    minDistance *= 1.75; // just to have some nice spacing\n\n    var dcos = Math.cos(dTheta) - Math.cos(0);\n    var dsin = Math.sin(dTheta) - Math.sin(0);\n    var rMin = Math.sqrt(minDistance * minDistance / (dcos * dcos + dsin * dsin)); // s.t. no nodes overlapping\n    r = Math.max(rMin, r);\n  }\n  var getPos = function getPos(ele, i) {\n    var theta = options.startAngle + i * dTheta * (clockwise ? 1 : -1);\n    var rx = r * Math.cos(theta);\n    var ry = r * Math.sin(theta);\n    var pos = {\n      x: center.x + rx,\n      y: center.y + ry\n    };\n    return pos;\n  };\n  eles.nodes().layoutPositions(this, options, getPos);\n  return this; // chaining\n};\n\nvar defaults$5 = {\n  fit: true,\n  // whether to fit the viewport to the graph\n  padding: 30,\n  // the padding on fit\n  startAngle: 3 / 2 * Math.PI,\n  // where nodes start in radians\n  sweep: undefined,\n  // how many radians should be between the first and last node (defaults to full circle)\n  clockwise: true,\n  // whether the layout should go clockwise (true) or counterclockwise/anticlockwise (false)\n  equidistant: false,\n  // whether levels have an equal radial distance betwen them, may cause bounding box overflow\n  minNodeSpacing: 10,\n  // min spacing between outside of nodes (used for radius adjustment)\n  boundingBox: undefined,\n  // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }\n  avoidOverlap: true,\n  // prevents node overlap, may overflow boundingBox if not enough space\n  nodeDimensionsIncludeLabels: false,\n  // Excludes the label when calculating node bounding boxes for the layout algorithm\n  height: undefined,\n  // height of layout area (overrides container height)\n  width: undefined,\n  // width of layout area (overrides container width)\n  spacingFactor: undefined,\n  // Applies a multiplicative factor (>0) to expand or compress the overall area that the nodes take up\n  concentric: function concentric(node) {\n    // returns numeric value for each node, placing higher nodes in levels towards the centre\n    return node.degree();\n  },\n  levelWidth: function levelWidth(nodes) {\n    // the variation of concentric values in each level\n    return nodes.maxDegree() / 4;\n  },\n  animate: false,\n  // whether to transition the node positions\n  animationDuration: 500,\n  // duration of animation in ms if enabled\n  animationEasing: undefined,\n  // easing of animation if enabled\n  animateFilter: function animateFilter(node, i) {\n    return true;\n  },\n  // a function that determines whether the node should be animated.  All nodes animated by default on animate enabled.  Non-animated nodes are positioned immediately when the layout starts\n  ready: undefined,\n  // callback on layoutready\n  stop: undefined,\n  // callback on layoutstop\n  transform: function transform(node, position) {\n    return position;\n  } // transform a given node position. Useful for changing flow direction in discrete layouts\n};\n\nfunction ConcentricLayout(options) {\n  this.options = extend({}, defaults$5, options);\n}\nConcentricLayout.prototype.run = function () {\n  var params = this.options;\n  var options = params;\n  var clockwise = options.counterclockwise !== undefined ? !options.counterclockwise : options.clockwise;\n  var cy = params.cy;\n  var eles = options.eles;\n  var nodes = eles.nodes().not(':parent');\n  var bb = makeBoundingBox(options.boundingBox ? options.boundingBox : {\n    x1: 0,\n    y1: 0,\n    w: cy.width(),\n    h: cy.height()\n  });\n  var center = {\n    x: bb.x1 + bb.w / 2,\n    y: bb.y1 + bb.h / 2\n  };\n  var nodeValues = []; // { node, value }\n  var maxNodeSize = 0;\n  for (var i = 0; i < nodes.length; i++) {\n    var node = nodes[i];\n    var value = void 0;\n\n    // calculate the node value\n    value = options.concentric(node);\n    nodeValues.push({\n      value: value,\n      node: node\n    });\n\n    // for style mapping\n    node._private.scratch.concentric = value;\n  }\n\n  // in case we used the `concentric` in style\n  nodes.updateStyle();\n\n  // calculate max size now based on potentially updated mappers\n  for (var _i = 0; _i < nodes.length; _i++) {\n    var _node = nodes[_i];\n    var nbb = _node.layoutDimensions(options);\n    maxNodeSize = Math.max(maxNodeSize, nbb.w, nbb.h);\n  }\n\n  // sort node values in descreasing order\n  nodeValues.sort(function (a, b) {\n    return b.value - a.value;\n  });\n  var levelWidth = options.levelWidth(nodes);\n\n  // put the values into levels\n  var levels = [[]];\n  var currentLevel = levels[0];\n  for (var _i2 = 0; _i2 < nodeValues.length; _i2++) {\n    var val = nodeValues[_i2];\n    if (currentLevel.length > 0) {\n      var diff = Math.abs(currentLevel[0].value - val.value);\n      if (diff >= levelWidth) {\n        currentLevel = [];\n        levels.push(currentLevel);\n      }\n    }\n    currentLevel.push(val);\n  }\n\n  // create positions from levels\n\n  var minDist = maxNodeSize + options.minNodeSpacing; // min dist between nodes\n\n  if (!options.avoidOverlap) {\n    // then strictly constrain to bb\n    var firstLvlHasMulti = levels.length > 0 && levels[0].length > 1;\n    var maxR = Math.min(bb.w, bb.h) / 2 - minDist;\n    var rStep = maxR / (levels.length + firstLvlHasMulti ? 1 : 0);\n    minDist = Math.min(minDist, rStep);\n  }\n\n  // find the metrics for each level\n  var r = 0;\n  for (var _i3 = 0; _i3 < levels.length; _i3++) {\n    var level = levels[_i3];\n    var sweep = options.sweep === undefined ? 2 * Math.PI - 2 * Math.PI / level.length : options.sweep;\n    var dTheta = level.dTheta = sweep / Math.max(1, level.length - 1);\n\n    // calculate the radius\n    if (level.length > 1 && options.avoidOverlap) {\n      // but only if more than one node (can't overlap)\n      var dcos = Math.cos(dTheta) - Math.cos(0);\n      var dsin = Math.sin(dTheta) - Math.sin(0);\n      var rMin = Math.sqrt(minDist * minDist / (dcos * dcos + dsin * dsin)); // s.t. no nodes overlapping\n\n      r = Math.max(rMin, r);\n    }\n    level.r = r;\n    r += minDist;\n  }\n  if (options.equidistant) {\n    var rDeltaMax = 0;\n    var _r = 0;\n    for (var _i4 = 0; _i4 < levels.length; _i4++) {\n      var _level = levels[_i4];\n      var rDelta = _level.r - _r;\n      rDeltaMax = Math.max(rDeltaMax, rDelta);\n    }\n    _r = 0;\n    for (var _i5 = 0; _i5 < levels.length; _i5++) {\n      var _level2 = levels[_i5];\n      if (_i5 === 0) {\n        _r = _level2.r;\n      }\n      _level2.r = _r;\n      _r += rDeltaMax;\n    }\n  }\n\n  // calculate the node positions\n  var pos = {}; // id => position\n  for (var _i6 = 0; _i6 < levels.length; _i6++) {\n    var _level3 = levels[_i6];\n    var _dTheta = _level3.dTheta;\n    var _r2 = _level3.r;\n    for (var j = 0; j < _level3.length; j++) {\n      var _val = _level3[j];\n      var theta = options.startAngle + (clockwise ? 1 : -1) * _dTheta * j;\n      var p = {\n        x: center.x + _r2 * Math.cos(theta),\n        y: center.y + _r2 * Math.sin(theta)\n      };\n      pos[_val.node.id()] = p;\n    }\n  }\n\n  // position the nodes\n  eles.nodes().layoutPositions(this, options, function (ele) {\n    var id = ele.id();\n    return pos[id];\n  });\n  return this; // chaining\n};\n\n/*\nThe CoSE layout was written by Gerardo Huck.\nhttps://www.linkedin.com/in/gerardohuck/\n\nBased on the following article:\nhttp://dl.acm.org/citation.cfm?id=1498047\n\nModifications tracked on Github.\n*/\nvar DEBUG;\n\n/**\n * @brief :  default layout options\n */\nvar defaults$4 = {\n  // Called on `layoutready`\n  ready: function ready() {},\n  // Called on `layoutstop`\n  stop: function stop() {},\n  // Whether to animate while running the layout\n  // true : Animate continuously as the layout is running\n  // false : Just show the end result\n  // 'end' : Animate with the end result, from the initial positions to the end positions\n  animate: true,\n  // Easing of the animation for animate:'end'\n  animationEasing: undefined,\n  // The duration of the animation for animate:'end'\n  animationDuration: undefined,\n  // A function that determines whether the node should be animated\n  // All nodes animated by default on animate enabled\n  // Non-animated nodes are positioned immediately when the layout starts\n  animateFilter: function animateFilter(node, i) {\n    return true;\n  },\n  // The layout animates only after this many milliseconds for animate:true\n  // (prevents flashing on fast runs)\n  animationThreshold: 250,\n  // Number of iterations between consecutive screen positions update\n  refresh: 20,\n  // Whether to fit the network view after when done\n  fit: true,\n  // Padding on fit\n  padding: 30,\n  // Constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }\n  boundingBox: undefined,\n  // Excludes the label when calculating node bounding boxes for the layout algorithm\n  nodeDimensionsIncludeLabels: false,\n  // Randomize the initial positions of the nodes (true) or use existing positions (false)\n  randomize: false,\n  // Extra spacing between components in non-compound graphs\n  componentSpacing: 40,\n  // Node repulsion (non overlapping) multiplier\n  nodeRepulsion: function nodeRepulsion(node) {\n    return 2048;\n  },\n  // Node repulsion (overlapping) multiplier\n  nodeOverlap: 4,\n  // Ideal edge (non nested) length\n  idealEdgeLength: function idealEdgeLength(edge) {\n    return 32;\n  },\n  // Divisor to compute edge forces\n  edgeElasticity: function edgeElasticity(edge) {\n    return 32;\n  },\n  // Nesting factor (multiplier) to compute ideal edge length for nested edges\n  nestingFactor: 1.2,\n  // Gravity force (constant)\n  gravity: 1,\n  // Maximum number of iterations to perform\n  numIter: 1000,\n  // Initial temperature (maximum node displacement)\n  initialTemp: 1000,\n  // Cooling factor (how the temperature is reduced between consecutive iterations\n  coolingFactor: 0.99,\n  // Lower temperature threshold (below this point the layout will end)\n  minTemp: 1.0\n};\n\n/**\n * @brief       : constructor\n * @arg options : object containing layout options\n */\nfunction CoseLayout(options) {\n  this.options = extend({}, defaults$4, options);\n  this.options.layout = this;\n\n  // Exclude any edge that has a source or target node that is not in the set of passed-in nodes\n  var nodes = this.options.eles.nodes();\n  var edges = this.options.eles.edges();\n  var notEdges = edges.filter(function (e) {\n    var sourceId = e.source().data('id');\n    var targetId = e.target().data('id');\n    var hasSource = nodes.some(function (n) {\n      return n.data('id') === sourceId;\n    });\n    var hasTarget = nodes.some(function (n) {\n      return n.data('id') === targetId;\n    });\n    return !hasSource || !hasTarget;\n  });\n  this.options.eles = this.options.eles.not(notEdges);\n}\n\n/**\n * @brief : runs the layout\n */\nCoseLayout.prototype.run = function () {\n  var options = this.options;\n  var cy = options.cy;\n  var layout = this;\n  layout.stopped = false;\n  if (options.animate === true || options.animate === false) {\n    layout.emit({\n      type: 'layoutstart',\n      layout: layout\n    });\n  }\n\n  // Set DEBUG - Global variable\n  if (true === options.debug) {\n    DEBUG = true;\n  } else {\n    DEBUG = false;\n  }\n\n  // Initialize layout info\n  var layoutInfo = createLayoutInfo(cy, layout, options);\n\n  // Show LayoutInfo contents if debugging\n  if (DEBUG) {\n    printLayoutInfo(layoutInfo);\n  }\n\n  // If required, randomize node positions\n  if (options.randomize) {\n    randomizePositions(layoutInfo);\n  }\n  var startTime = performanceNow();\n  var refresh = function refresh() {\n    refreshPositions(layoutInfo, cy, options);\n\n    // Fit the graph if necessary\n    if (true === options.fit) {\n      cy.fit(options.padding);\n    }\n  };\n  var mainLoop = function mainLoop(i) {\n    if (layout.stopped || i >= options.numIter) {\n      // logDebug(\"Layout manually stopped. Stopping computation in step \" + i);\n      return false;\n    }\n\n    // Do one step in the phisical simulation\n    step(layoutInfo, options);\n\n    // Update temperature\n    layoutInfo.temperature = layoutInfo.temperature * options.coolingFactor;\n    // logDebug(\"New temperature: \" + layoutInfo.temperature);\n\n    if (layoutInfo.temperature < options.minTemp) {\n      // logDebug(\"Temperature drop below minimum threshold. Stopping computation in step \" + i);\n      return false;\n    }\n    return true;\n  };\n  var done = function done() {\n    if (options.animate === true || options.animate === false) {\n      refresh();\n\n      // Layout has finished\n      layout.one('layoutstop', options.stop);\n      layout.emit({\n        type: 'layoutstop',\n        layout: layout\n      });\n    } else {\n      var nodes = options.eles.nodes();\n      var getScaledPos = getScaleInBoundsFn(layoutInfo, options, nodes);\n      nodes.layoutPositions(layout, options, getScaledPos);\n    }\n  };\n  var i = 0;\n  var loopRet = true;\n  if (options.animate === true) {\n    var frame = function frame() {\n      var f = 0;\n      while (loopRet && f < options.refresh) {\n        loopRet = mainLoop(i);\n        i++;\n        f++;\n      }\n      if (!loopRet) {\n        // it's done\n        separateComponents(layoutInfo, options);\n        done();\n      } else {\n        var now = performanceNow();\n        if (now - startTime >= options.animationThreshold) {\n          refresh();\n        }\n        requestAnimationFrame(frame);\n      }\n    };\n    frame();\n  } else {\n    while (loopRet) {\n      loopRet = mainLoop(i);\n      i++;\n    }\n    separateComponents(layoutInfo, options);\n    done();\n  }\n  return this; // chaining\n};\n\n/**\n * @brief : called on continuous layouts to stop them before they finish\n */\nCoseLayout.prototype.stop = function () {\n  this.stopped = true;\n  if (this.thread) {\n    this.thread.stop();\n  }\n  this.emit('layoutstop');\n  return this; // chaining\n};\n\nCoseLayout.prototype.destroy = function () {\n  if (this.thread) {\n    this.thread.stop();\n  }\n  return this; // chaining\n};\n\n/**\n * @brief     : Creates an object which is contains all the data\n *              used in the layout process\n * @arg cy    : cytoscape.js object\n * @return    : layoutInfo object initialized\n */\nvar createLayoutInfo = function createLayoutInfo(cy, layout, options) {\n  // Shortcut\n  var edges = options.eles.edges();\n  var nodes = options.eles.nodes();\n  var bb = makeBoundingBox(options.boundingBox ? options.boundingBox : {\n    x1: 0,\n    y1: 0,\n    w: cy.width(),\n    h: cy.height()\n  });\n  var layoutInfo = {\n    isCompound: cy.hasCompoundNodes(),\n    layoutNodes: [],\n    idToIndex: {},\n    nodeSize: nodes.size(),\n    graphSet: [],\n    indexToGraph: [],\n    layoutEdges: [],\n    edgeSize: edges.size(),\n    temperature: options.initialTemp,\n    clientWidth: bb.w,\n    clientHeight: bb.h,\n    boundingBox: bb\n  };\n  var components = options.eles.components();\n  var id2cmptId = {};\n  for (var i = 0; i < components.length; i++) {\n    var component = components[i];\n    for (var j = 0; j < component.length; j++) {\n      var node = component[j];\n      id2cmptId[node.id()] = i;\n    }\n  }\n\n  // Iterate over all nodes, creating layout nodes\n  for (var i = 0; i < layoutInfo.nodeSize; i++) {\n    var n = nodes[i];\n    var nbb = n.layoutDimensions(options);\n    var tempNode = {};\n    tempNode.isLocked = n.locked();\n    tempNode.id = n.data('id');\n    tempNode.parentId = n.data('parent');\n    tempNode.cmptId = id2cmptId[n.id()];\n    tempNode.children = [];\n    tempNode.positionX = n.position('x');\n    tempNode.positionY = n.position('y');\n    tempNode.offsetX = 0;\n    tempNode.offsetY = 0;\n    tempNode.height = nbb.w;\n    tempNode.width = nbb.h;\n    tempNode.maxX = tempNode.positionX + tempNode.width / 2;\n    tempNode.minX = tempNode.positionX - tempNode.width / 2;\n    tempNode.maxY = tempNode.positionY + tempNode.height / 2;\n    tempNode.minY = tempNode.positionY - tempNode.height / 2;\n    tempNode.padLeft = parseFloat(n.style('padding'));\n    tempNode.padRight = parseFloat(n.style('padding'));\n    tempNode.padTop = parseFloat(n.style('padding'));\n    tempNode.padBottom = parseFloat(n.style('padding'));\n\n    // forces\n    tempNode.nodeRepulsion = fn$6(options.nodeRepulsion) ? options.nodeRepulsion(n) : options.nodeRepulsion;\n\n    // Add new node\n    layoutInfo.layoutNodes.push(tempNode);\n    // Add entry to id-index map\n    layoutInfo.idToIndex[tempNode.id] = i;\n  }\n\n  // Inline implementation of a queue, used for traversing the graph in BFS order\n  var queue = [];\n  var start = 0; // Points to the start the queue\n  var end = -1; // Points to the end of the queue\n\n  var tempGraph = [];\n\n  // Second pass to add child information and\n  // initialize queue for hierarchical traversal\n  for (var i = 0; i < layoutInfo.nodeSize; i++) {\n    var n = layoutInfo.layoutNodes[i];\n    var p_id = n.parentId;\n    // Check if node n has a parent node\n    if (null != p_id) {\n      // Add node Id to parent's list of children\n      layoutInfo.layoutNodes[layoutInfo.idToIndex[p_id]].children.push(n.id);\n    } else {\n      // If a node doesn't have a parent, then it's in the root graph\n      queue[++end] = n.id;\n      tempGraph.push(n.id);\n    }\n  }\n\n  // Add root graph to graphSet\n  layoutInfo.graphSet.push(tempGraph);\n\n  // Traverse the graph, level by level,\n  while (start <= end) {\n    // Get the node to visit and remove it from queue\n    var node_id = queue[start++];\n    var node_ix = layoutInfo.idToIndex[node_id];\n    var node = layoutInfo.layoutNodes[node_ix];\n    var children = node.children;\n    if (children.length > 0) {\n      // Add children nodes as a new graph to graph set\n      layoutInfo.graphSet.push(children);\n      // Add children to que queue to be visited\n      for (var i = 0; i < children.length; i++) {\n        queue[++end] = children[i];\n      }\n    }\n  }\n\n  // Create indexToGraph map\n  for (var i = 0; i < layoutInfo.graphSet.length; i++) {\n    var graph = layoutInfo.graphSet[i];\n    for (var j = 0; j < graph.length; j++) {\n      var index = layoutInfo.idToIndex[graph[j]];\n      layoutInfo.indexToGraph[index] = i;\n    }\n  }\n\n  // Iterate over all edges, creating Layout Edges\n  for (var i = 0; i < layoutInfo.edgeSize; i++) {\n    var e = edges[i];\n    var tempEdge = {};\n    tempEdge.id = e.data('id');\n    tempEdge.sourceId = e.data('source');\n    tempEdge.targetId = e.data('target');\n\n    // Compute ideal length\n    var idealLength = fn$6(options.idealEdgeLength) ? options.idealEdgeLength(e) : options.idealEdgeLength;\n    var elasticity = fn$6(options.edgeElasticity) ? options.edgeElasticity(e) : options.edgeElasticity;\n\n    // Check if it's an inter graph edge\n    var sourceIx = layoutInfo.idToIndex[tempEdge.sourceId];\n    var targetIx = layoutInfo.idToIndex[tempEdge.targetId];\n    var sourceGraph = layoutInfo.indexToGraph[sourceIx];\n    var targetGraph = layoutInfo.indexToGraph[targetIx];\n    if (sourceGraph != targetGraph) {\n      // Find lowest common graph ancestor\n      var lca = findLCA(tempEdge.sourceId, tempEdge.targetId, layoutInfo);\n\n      // Compute sum of node depths, relative to lca graph\n      var lcaGraph = layoutInfo.graphSet[lca];\n      var depth = 0;\n\n      // Source depth\n      var tempNode = layoutInfo.layoutNodes[sourceIx];\n      while (-1 === lcaGraph.indexOf(tempNode.id)) {\n        tempNode = layoutInfo.layoutNodes[layoutInfo.idToIndex[tempNode.parentId]];\n        depth++;\n      }\n\n      // Target depth\n      tempNode = layoutInfo.layoutNodes[targetIx];\n      while (-1 === lcaGraph.indexOf(tempNode.id)) {\n        tempNode = layoutInfo.layoutNodes[layoutInfo.idToIndex[tempNode.parentId]];\n        depth++;\n      }\n\n      // logDebug('LCA of nodes ' + tempEdge.sourceId + ' and ' + tempEdge.targetId +\n      //  \". Index: \" + lca + \" Contents: \" + lcaGraph.toString() +\n      //  \". Depth: \" + depth);\n\n      // Update idealLength\n      idealLength *= depth * options.nestingFactor;\n    }\n    tempEdge.idealLength = idealLength;\n    tempEdge.elasticity = elasticity;\n    layoutInfo.layoutEdges.push(tempEdge);\n  }\n\n  // Finally, return layoutInfo object\n  return layoutInfo;\n};\n\n/**\n * @brief : This function finds the index of the lowest common\n *          graph ancestor between 2 nodes in the subtree\n *          (from the graph hierarchy induced tree) whose\n *          root is graphIx\n *\n * @arg node1: node1's ID\n * @arg node2: node2's ID\n * @arg layoutInfo: layoutInfo object\n *\n */\nvar findLCA = function findLCA(node1, node2, layoutInfo) {\n  // Find their common ancester, starting from the root graph\n  var res = findLCA_aux(node1, node2, 0, layoutInfo);\n  if (2 > res.count) {\n    // If aux function couldn't find the common ancester,\n    // then it is the root graph\n    return 0;\n  } else {\n    return res.graph;\n  }\n};\n\n/**\n * @brief          : Auxiliary function used for LCA computation\n *\n * @arg node1      : node1's ID\n * @arg node2      : node2's ID\n * @arg graphIx    : subgraph index\n * @arg layoutInfo : layoutInfo object\n *\n * @return         : object of the form {count: X, graph: Y}, where:\n *                   X is the number of ancestors (max: 2) found in\n *                   graphIx (and it's subgraphs),\n *                   Y is the graph index of the lowest graph containing\n *                   all X nodes\n */\nvar findLCA_aux = function findLCA_aux(node1, node2, graphIx, layoutInfo) {\n  var graph = layoutInfo.graphSet[graphIx];\n  // If both nodes belongs to graphIx\n  if (-1 < graph.indexOf(node1) && -1 < graph.indexOf(node2)) {\n    return {\n      count: 2,\n      graph: graphIx\n    };\n  }\n\n  // Make recursive calls for all subgraphs\n  var c = 0;\n  for (var i = 0; i < graph.length; i++) {\n    var nodeId = graph[i];\n    var nodeIx = layoutInfo.idToIndex[nodeId];\n    var children = layoutInfo.layoutNodes[nodeIx].children;\n\n    // If the node has no child, skip it\n    if (0 === children.length) {\n      continue;\n    }\n    var childGraphIx = layoutInfo.indexToGraph[layoutInfo.idToIndex[children[0]]];\n    var result = findLCA_aux(node1, node2, childGraphIx, layoutInfo);\n    if (0 === result.count) {\n      // Neither node1 nor node2 are present in this subgraph\n      continue;\n    } else if (1 === result.count) {\n      // One of (node1, node2) is present in this subgraph\n      c++;\n      if (2 === c) {\n        // We've already found both nodes, no need to keep searching\n        break;\n      }\n    } else {\n      // Both nodes are present in this subgraph\n      return result;\n    }\n  }\n  return {\n    count: c,\n    graph: graphIx\n  };\n};\n\n/**\n * @brief: printsLayoutInfo into js console\n *         Only used for debbuging\n */\nvar printLayoutInfo; \n\n/**\n * @brief : Randomizes the position of all nodes\n */\nvar randomizePositions = function randomizePositions(layoutInfo, cy) {\n  var width = layoutInfo.clientWidth;\n  var height = layoutInfo.clientHeight;\n  for (var i = 0; i < layoutInfo.nodeSize; i++) {\n    var n = layoutInfo.layoutNodes[i];\n\n    // No need to randomize compound nodes or locked nodes\n    if (0 === n.children.length && !n.isLocked) {\n      n.positionX = Math.random() * width;\n      n.positionY = Math.random() * height;\n    }\n  }\n};\nvar getScaleInBoundsFn = function getScaleInBoundsFn(layoutInfo, options, nodes) {\n  var bb = layoutInfo.boundingBox;\n  var coseBB = {\n    x1: Infinity,\n    x2: -Infinity,\n    y1: Infinity,\n    y2: -Infinity\n  };\n  if (options.boundingBox) {\n    nodes.forEach(function (node) {\n      var lnode = layoutInfo.layoutNodes[layoutInfo.idToIndex[node.data('id')]];\n      coseBB.x1 = Math.min(coseBB.x1, lnode.positionX);\n      coseBB.x2 = Math.max(coseBB.x2, lnode.positionX);\n      coseBB.y1 = Math.min(coseBB.y1, lnode.positionY);\n      coseBB.y2 = Math.max(coseBB.y2, lnode.positionY);\n    });\n    coseBB.w = coseBB.x2 - coseBB.x1;\n    coseBB.h = coseBB.y2 - coseBB.y1;\n  }\n  return function (ele, i) {\n    var lnode = layoutInfo.layoutNodes[layoutInfo.idToIndex[ele.data('id')]];\n    if (options.boundingBox) {\n      // then add extra bounding box constraint\n      var pctX = (lnode.positionX - coseBB.x1) / coseBB.w;\n      var pctY = (lnode.positionY - coseBB.y1) / coseBB.h;\n      return {\n        x: bb.x1 + pctX * bb.w,\n        y: bb.y1 + pctY * bb.h\n      };\n    } else {\n      return {\n        x: lnode.positionX,\n        y: lnode.positionY\n      };\n    }\n  };\n};\n\n/**\n * @brief          : Updates the positions of nodes in the network\n * @arg layoutInfo : LayoutInfo object\n * @arg cy         : Cytoscape object\n * @arg options    : Layout options\n */\nvar refreshPositions = function refreshPositions(layoutInfo, cy, options) {\n  // var s = 'Refreshing positions';\n  // logDebug(s);\n\n  var layout = options.layout;\n  var nodes = options.eles.nodes();\n  var getScaledPos = getScaleInBoundsFn(layoutInfo, options, nodes);\n  nodes.positions(getScaledPos);\n\n  // Trigger layoutReady only on first call\n  if (true !== layoutInfo.ready) {\n    // s = 'Triggering layoutready';\n    // logDebug(s);\n    layoutInfo.ready = true;\n    layout.one('layoutready', options.ready);\n    layout.emit({\n      type: 'layoutready',\n      layout: this\n    });\n  }\n};\n\n/**\n * @brief : Logs a debug message in JS console, if DEBUG is ON\n */\n// var logDebug = function(text) {\n//   if (DEBUG) {\n//     console.debug(text);\n//   }\n// };\n\n/**\n * @brief          : Performs one iteration of the physical simulation\n * @arg layoutInfo : LayoutInfo object already initialized\n * @arg cy         : Cytoscape object\n * @arg options    : Layout options\n */\nvar step = function step(layoutInfo, options, _step) {\n  // var s = \"\\n\\n###############################\";\n  // s += \"\\nSTEP: \" + step;\n  // s += \"\\n###############################\\n\";\n  // logDebug(s);\n\n  // Calculate node repulsions\n  calculateNodeForces(layoutInfo, options);\n  // Calculate edge forces\n  calculateEdgeForces(layoutInfo);\n  // Calculate gravity forces\n  calculateGravityForces(layoutInfo, options);\n  // Propagate forces from parent to child\n  propagateForces(layoutInfo);\n  // Update positions based on calculated forces\n  updatePositions(layoutInfo);\n};\n\n/**\n * @brief : Computes the node repulsion forces\n */\nvar calculateNodeForces = function calculateNodeForces(layoutInfo, options) {\n  // Go through each of the graphs in graphSet\n  // Nodes only repel each other if they belong to the same graph\n  // var s = 'calculateNodeForces';\n  // logDebug(s);\n  for (var i = 0; i < layoutInfo.graphSet.length; i++) {\n    var graph = layoutInfo.graphSet[i];\n    var numNodes = graph.length;\n\n    // s = \"Set: \" + graph.toString();\n    // logDebug(s);\n\n    // Now get all the pairs of nodes\n    // Only get each pair once, (A, B) = (B, A)\n    for (var j = 0; j < numNodes; j++) {\n      var node1 = layoutInfo.layoutNodes[layoutInfo.idToIndex[graph[j]]];\n      for (var k = j + 1; k < numNodes; k++) {\n        var node2 = layoutInfo.layoutNodes[layoutInfo.idToIndex[graph[k]]];\n        nodeRepulsion(node1, node2, layoutInfo, options);\n      }\n    }\n  }\n};\nvar randomDistance = function randomDistance(max) {\n  return -max + 2 * max * Math.random();\n};\n\n/**\n * @brief : Compute the node repulsion forces between a pair of nodes\n */\nvar nodeRepulsion = function nodeRepulsion(node1, node2, layoutInfo, options) {\n  // var s = \"Node repulsion. Node1: \" + node1.id + \" Node2: \" + node2.id;\n\n  var cmptId1 = node1.cmptId;\n  var cmptId2 = node2.cmptId;\n  if (cmptId1 !== cmptId2 && !layoutInfo.isCompound) {\n    return;\n  }\n\n  // Get direction of line connecting both node centers\n  var directionX = node2.positionX - node1.positionX;\n  var directionY = node2.positionY - node1.positionY;\n  var maxRandDist = 1;\n  // s += \"\\ndirectionX: \" + directionX + \", directionY: \" + directionY;\n\n  // If both centers are the same, apply a random force\n  if (0 === directionX && 0 === directionY) {\n    directionX = randomDistance(maxRandDist);\n    directionY = randomDistance(maxRandDist);\n  }\n  var overlap = nodesOverlap(node1, node2, directionX, directionY);\n  if (overlap > 0) {\n    // s += \"\\nNodes DO overlap.\";\n    // s += \"\\nOverlap: \" + overlap;\n    // If nodes overlap, repulsion force is proportional\n    // to the overlap\n    var force = options.nodeOverlap * overlap;\n\n    // Compute the module and components of the force vector\n    var distance = Math.sqrt(directionX * directionX + directionY * directionY);\n    // s += \"\\nDistance: \" + distance;\n    var forceX = force * directionX / distance;\n    var forceY = force * directionY / distance;\n  } else {\n    // s += \"\\nNodes do NOT overlap.\";\n    // If there's no overlap, force is inversely proportional\n    // to squared distance\n\n    // Get clipping points for both nodes\n    var point1 = findClippingPoint(node1, directionX, directionY);\n    var point2 = findClippingPoint(node2, -1 * directionX, -1 * directionY);\n\n    // Use clipping points to compute distance\n    var distanceX = point2.x - point1.x;\n    var distanceY = point2.y - point1.y;\n    var distanceSqr = distanceX * distanceX + distanceY * distanceY;\n    var distance = Math.sqrt(distanceSqr);\n    // s += \"\\nDistance: \" + distance;\n\n    // Compute the module and components of the force vector\n    var force = (node1.nodeRepulsion + node2.nodeRepulsion) / distanceSqr;\n    var forceX = force * distanceX / distance;\n    var forceY = force * distanceY / distance;\n  }\n\n  // Apply force\n  if (!node1.isLocked) {\n    node1.offsetX -= forceX;\n    node1.offsetY -= forceY;\n  }\n  if (!node2.isLocked) {\n    node2.offsetX += forceX;\n    node2.offsetY += forceY;\n  }\n\n  // s += \"\\nForceX: \" + forceX + \" ForceY: \" + forceY;\n  // logDebug(s);\n\n  return;\n};\n\n/**\n * @brief  : Determines whether two nodes overlap or not\n * @return : Amount of overlapping (0 => no overlap)\n */\nvar nodesOverlap = function nodesOverlap(node1, node2, dX, dY) {\n  if (dX > 0) {\n    var overlapX = node1.maxX - node2.minX;\n  } else {\n    var overlapX = node2.maxX - node1.minX;\n  }\n  if (dY > 0) {\n    var overlapY = node1.maxY - node2.minY;\n  } else {\n    var overlapY = node2.maxY - node1.minY;\n  }\n  if (overlapX >= 0 && overlapY >= 0) {\n    return Math.sqrt(overlapX * overlapX + overlapY * overlapY);\n  } else {\n    return 0;\n  }\n};\n\n/**\n * @brief : Finds the point in which an edge (direction dX, dY) intersects\n *          the rectangular bounding box of it's source/target node\n */\nvar findClippingPoint = function findClippingPoint(node, dX, dY) {\n  // Shorcuts\n  var X = node.positionX;\n  var Y = node.positionY;\n  var H = node.height || 1;\n  var W = node.width || 1;\n  var dirSlope = dY / dX;\n  var nodeSlope = H / W;\n\n  // var s = 'Computing clipping point of node ' + node.id +\n  //   \" . Height:  \" + H + \", Width: \" + W +\n  //   \"\\nDirection \" + dX + \", \" + dY;\n  //\n  // Compute intersection\n  var res = {};\n\n  // Case: Vertical direction (up)\n  if (0 === dX && 0 < dY) {\n    res.x = X;\n    // s += \"\\nUp direction\";\n    res.y = Y + H / 2;\n    return res;\n  }\n\n  // Case: Vertical direction (down)\n  if (0 === dX && 0 > dY) {\n    res.x = X;\n    res.y = Y + H / 2;\n    // s += \"\\nDown direction\";\n\n    return res;\n  }\n\n  // Case: Intersects the right border\n  if (0 < dX && -1 * nodeSlope <= dirSlope && dirSlope <= nodeSlope) {\n    res.x = X + W / 2;\n    res.y = Y + W * dY / 2 / dX;\n    // s += \"\\nRightborder\";\n\n    return res;\n  }\n\n  // Case: Intersects the left border\n  if (0 > dX && -1 * nodeSlope <= dirSlope && dirSlope <= nodeSlope) {\n    res.x = X - W / 2;\n    res.y = Y - W * dY / 2 / dX;\n    // s += \"\\nLeftborder\";\n\n    return res;\n  }\n\n  // Case: Intersects the top border\n  if (0 < dY && (dirSlope <= -1 * nodeSlope || dirSlope >= nodeSlope)) {\n    res.x = X + H * dX / 2 / dY;\n    res.y = Y + H / 2;\n    // s += \"\\nTop border\";\n\n    return res;\n  }\n\n  // Case: Intersects the bottom border\n  if (0 > dY && (dirSlope <= -1 * nodeSlope || dirSlope >= nodeSlope)) {\n    res.x = X - H * dX / 2 / dY;\n    res.y = Y - H / 2;\n    // s += \"\\nBottom border\";\n\n    return res;\n  }\n\n  // s += \"\\nClipping point found at \" + res.x + \", \" + res.y;\n  // logDebug(s);\n  return res;\n};\n\n/**\n * @brief : Calculates all edge forces\n */\nvar calculateEdgeForces = function calculateEdgeForces(layoutInfo, options) {\n  // Iterate over all edges\n  for (var i = 0; i < layoutInfo.edgeSize; i++) {\n    // Get edge, source & target nodes\n    var edge = layoutInfo.layoutEdges[i];\n    var sourceIx = layoutInfo.idToIndex[edge.sourceId];\n    var source = layoutInfo.layoutNodes[sourceIx];\n    var targetIx = layoutInfo.idToIndex[edge.targetId];\n    var target = layoutInfo.layoutNodes[targetIx];\n\n    // Get direction of line connecting both node centers\n    var directionX = target.positionX - source.positionX;\n    var directionY = target.positionY - source.positionY;\n\n    // If both centers are the same, do nothing.\n    // A random force has already been applied as node repulsion\n    if (0 === directionX && 0 === directionY) {\n      continue;\n    }\n\n    // Get clipping points for both nodes\n    var point1 = findClippingPoint(source, directionX, directionY);\n    var point2 = findClippingPoint(target, -1 * directionX, -1 * directionY);\n    var lx = point2.x - point1.x;\n    var ly = point2.y - point1.y;\n    var l = Math.sqrt(lx * lx + ly * ly);\n    var force = Math.pow(edge.idealLength - l, 2) / edge.elasticity;\n    if (0 !== l) {\n      var forceX = force * lx / l;\n      var forceY = force * ly / l;\n    } else {\n      var forceX = 0;\n      var forceY = 0;\n    }\n\n    // Add this force to target and source nodes\n    if (!source.isLocked) {\n      source.offsetX += forceX;\n      source.offsetY += forceY;\n    }\n    if (!target.isLocked) {\n      target.offsetX -= forceX;\n      target.offsetY -= forceY;\n    }\n\n    // var s = 'Edge force between nodes ' + source.id + ' and ' + target.id;\n    // s += \"\\nDistance: \" + l + \" Force: (\" + forceX + \", \" + forceY + \")\";\n    // logDebug(s);\n  }\n};\n\n/**\n * @brief : Computes gravity forces for all nodes\n */\nvar calculateGravityForces = function calculateGravityForces(layoutInfo, options) {\n  if (options.gravity === 0) {\n    return;\n  }\n  var distThreshold = 1;\n\n  // var s = 'calculateGravityForces';\n  // logDebug(s);\n  for (var i = 0; i < layoutInfo.graphSet.length; i++) {\n    var graph = layoutInfo.graphSet[i];\n    var numNodes = graph.length;\n\n    // s = \"Set: \" + graph.toString();\n    // logDebug(s);\n\n    // Compute graph center\n    if (0 === i) {\n      var centerX = layoutInfo.clientHeight / 2;\n      var centerY = layoutInfo.clientWidth / 2;\n    } else {\n      // Get Parent node for this graph, and use its position as center\n      var temp = layoutInfo.layoutNodes[layoutInfo.idToIndex[graph[0]]];\n      var parent = layoutInfo.layoutNodes[layoutInfo.idToIndex[temp.parentId]];\n      var centerX = parent.positionX;\n      var centerY = parent.positionY;\n    }\n    // s = \"Center found at: \" + centerX + \", \" + centerY;\n    // logDebug(s);\n\n    // Apply force to all nodes in graph\n    for (var j = 0; j < numNodes; j++) {\n      var node = layoutInfo.layoutNodes[layoutInfo.idToIndex[graph[j]]];\n      // s = \"Node: \" + node.id;\n\n      if (node.isLocked) {\n        continue;\n      }\n      var dx = centerX - node.positionX;\n      var dy = centerY - node.positionY;\n      var d = Math.sqrt(dx * dx + dy * dy);\n      if (d > distThreshold) {\n        var fx = options.gravity * dx / d;\n        var fy = options.gravity * dy / d;\n        node.offsetX += fx;\n        node.offsetY += fy;\n        // s += \": Applied force: \" + fx + \", \" + fy;\n      }\n      // logDebug(s);\n    }\n  }\n};\n\n/**\n * @brief          : This function propagates the existing offsets from\n *                   parent nodes to its descendents.\n * @arg layoutInfo : layoutInfo Object\n * @arg cy         : cytoscape Object\n * @arg options    : Layout options\n */\nvar propagateForces = function propagateForces(layoutInfo, options) {\n  // Inline implementation of a queue, used for traversing the graph in BFS order\n  var queue = [];\n  var start = 0; // Points to the start the queue\n  var end = -1; // Points to the end of the queue\n\n  // logDebug('propagateForces');\n\n  // Start by visiting the nodes in the root graph\n  queue.push.apply(queue, layoutInfo.graphSet[0]);\n  end += layoutInfo.graphSet[0].length;\n\n  // Traverse the graph, level by level,\n  while (start <= end) {\n    // Get the node to visit and remove it from queue\n    var nodeId = queue[start++];\n    var nodeIndex = layoutInfo.idToIndex[nodeId];\n    var node = layoutInfo.layoutNodes[nodeIndex];\n    var children = node.children;\n\n    // We only need to process the node if it's compound\n    if (0 < children.length && !node.isLocked) {\n      var offX = node.offsetX;\n      var offY = node.offsetY;\n\n      // var s = \"Propagating offset from parent node : \" + node.id +\n      //   \". OffsetX: \" + offX + \". OffsetY: \" + offY;\n      // s += \"\\n Children: \" + children.toString();\n      // logDebug(s);\n\n      for (var i = 0; i < children.length; i++) {\n        var childNode = layoutInfo.layoutNodes[layoutInfo.idToIndex[children[i]]];\n        // Propagate offset\n        childNode.offsetX += offX;\n        childNode.offsetY += offY;\n        // Add children to queue to be visited\n        queue[++end] = children[i];\n      }\n\n      // Reset parent offsets\n      node.offsetX = 0;\n      node.offsetY = 0;\n    }\n  }\n};\n\n/**\n * @brief : Updates the layout model positions, based on\n *          the accumulated forces\n */\nvar updatePositions = function updatePositions(layoutInfo, options) {\n  // var s = 'Updating positions';\n  // logDebug(s);\n\n  // Reset boundaries for compound nodes\n  for (var i = 0; i < layoutInfo.nodeSize; i++) {\n    var n = layoutInfo.layoutNodes[i];\n    if (0 < n.children.length) {\n      // logDebug(\"Resetting boundaries of compound node: \" + n.id);\n      n.maxX = undefined;\n      n.minX = undefined;\n      n.maxY = undefined;\n      n.minY = undefined;\n    }\n  }\n  for (var i = 0; i < layoutInfo.nodeSize; i++) {\n    var n = layoutInfo.layoutNodes[i];\n    if (0 < n.children.length || n.isLocked) {\n      // No need to set compound or locked node position\n      // logDebug(\"Skipping position update of node: \" + n.id);\n      continue;\n    }\n    // s = \"Node: \" + n.id + \" Previous position: (\" +\n    // n.positionX + \", \" + n.positionY + \").\";\n\n    // Limit displacement in order to improve stability\n    var tempForce = limitForce(n.offsetX, n.offsetY, layoutInfo.temperature);\n    n.positionX += tempForce.x;\n    n.positionY += tempForce.y;\n    n.offsetX = 0;\n    n.offsetY = 0;\n    n.minX = n.positionX - n.width;\n    n.maxX = n.positionX + n.width;\n    n.minY = n.positionY - n.height;\n    n.maxY = n.positionY + n.height;\n    // s += \" New Position: (\" + n.positionX + \", \" + n.positionY + \").\";\n    // logDebug(s);\n\n    // Update ancestry boudaries\n    updateAncestryBoundaries(n, layoutInfo);\n  }\n\n  // Update size, position of compund nodes\n  for (var i = 0; i < layoutInfo.nodeSize; i++) {\n    var n = layoutInfo.layoutNodes[i];\n    if (0 < n.children.length && !n.isLocked) {\n      n.positionX = (n.maxX + n.minX) / 2;\n      n.positionY = (n.maxY + n.minY) / 2;\n      n.width = n.maxX - n.minX;\n      n.height = n.maxY - n.minY;\n      // s = \"Updating position, size of compound node \" + n.id;\n      // s += \"\\nPositionX: \" + n.positionX + \", PositionY: \" + n.positionY;\n      // s += \"\\nWidth: \" + n.width + \", Height: \" + n.height;\n      // logDebug(s);\n    }\n  }\n};\n\n/**\n * @brief : Limits a force (forceX, forceY) to be not\n *          greater (in modulo) than max.\n 8          Preserves force direction.\n  */\nvar limitForce = function limitForce(forceX, forceY, max) {\n  // var s = \"Limiting force: (\" + forceX + \", \" + forceY + \"). Max: \" + max;\n  var force = Math.sqrt(forceX * forceX + forceY * forceY);\n  if (force > max) {\n    var res = {\n      x: max * forceX / force,\n      y: max * forceY / force\n    };\n  } else {\n    var res = {\n      x: forceX,\n      y: forceY\n    };\n  }\n\n  // s += \".\\nResult: (\" + res.x + \", \" + res.y + \")\";\n  // logDebug(s);\n\n  return res;\n};\n\n/**\n * @brief : Function used for keeping track of compound node\n *          sizes, since they should bound all their subnodes.\n */\nvar updateAncestryBoundaries = function updateAncestryBoundaries(node, layoutInfo) {\n  // var s = \"Propagating new position/size of node \" + node.id;\n  var parentId = node.parentId;\n  if (null == parentId) {\n    // If there's no parent, we are done\n    // s += \". No parent node.\";\n    // logDebug(s);\n    return;\n  }\n\n  // Get Parent Node\n  var p = layoutInfo.layoutNodes[layoutInfo.idToIndex[parentId]];\n  var flag = false;\n\n  // MaxX\n  if (null == p.maxX || node.maxX + p.padRight > p.maxX) {\n    p.maxX = node.maxX + p.padRight;\n    flag = true;\n    // s += \"\\nNew maxX for parent node \" + p.id + \": \" + p.maxX;\n  }\n\n  // MinX\n  if (null == p.minX || node.minX - p.padLeft < p.minX) {\n    p.minX = node.minX - p.padLeft;\n    flag = true;\n    // s += \"\\nNew minX for parent node \" + p.id + \": \" + p.minX;\n  }\n\n  // MaxY\n  if (null == p.maxY || node.maxY + p.padBottom > p.maxY) {\n    p.maxY = node.maxY + p.padBottom;\n    flag = true;\n    // s += \"\\nNew maxY for parent node \" + p.id + \": \" + p.maxY;\n  }\n\n  // MinY\n  if (null == p.minY || node.minY - p.padTop < p.minY) {\n    p.minY = node.minY - p.padTop;\n    flag = true;\n    // s += \"\\nNew minY for parent node \" + p.id + \": \" + p.minY;\n  }\n\n  // If updated boundaries, propagate changes upward\n  if (flag) {\n    // logDebug(s);\n    return updateAncestryBoundaries(p, layoutInfo);\n  }\n\n  // s += \". No changes in boundaries/position of parent node \" + p.id;\n  // logDebug(s);\n  return;\n};\nvar separateComponents = function separateComponents(layoutInfo, options) {\n  var nodes = layoutInfo.layoutNodes;\n  var components = [];\n  for (var i = 0; i < nodes.length; i++) {\n    var node = nodes[i];\n    var cid = node.cmptId;\n    var component = components[cid] = components[cid] || [];\n    component.push(node);\n  }\n  var totalA = 0;\n  for (var i = 0; i < components.length; i++) {\n    var c = components[i];\n    if (!c) {\n      continue;\n    }\n    c.x1 = Infinity;\n    c.x2 = -Infinity;\n    c.y1 = Infinity;\n    c.y2 = -Infinity;\n    for (var j = 0; j < c.length; j++) {\n      var n = c[j];\n      c.x1 = Math.min(c.x1, n.positionX - n.width / 2);\n      c.x2 = Math.max(c.x2, n.positionX + n.width / 2);\n      c.y1 = Math.min(c.y1, n.positionY - n.height / 2);\n      c.y2 = Math.max(c.y2, n.positionY + n.height / 2);\n    }\n    c.w = c.x2 - c.x1;\n    c.h = c.y2 - c.y1;\n    totalA += c.w * c.h;\n  }\n  components.sort(function (c1, c2) {\n    return c2.w * c2.h - c1.w * c1.h;\n  });\n  var x = 0;\n  var y = 0;\n  var usedW = 0;\n  var rowH = 0;\n  var maxRowW = Math.sqrt(totalA) * layoutInfo.clientWidth / layoutInfo.clientHeight;\n  for (var i = 0; i < components.length; i++) {\n    var c = components[i];\n    if (!c) {\n      continue;\n    }\n    for (var j = 0; j < c.length; j++) {\n      var n = c[j];\n      if (!n.isLocked) {\n        n.positionX += x - c.x1;\n        n.positionY += y - c.y1;\n      }\n    }\n    x += c.w + options.componentSpacing;\n    usedW += c.w + options.componentSpacing;\n    rowH = Math.max(rowH, c.h);\n    if (usedW > maxRowW) {\n      y += rowH + options.componentSpacing;\n      x = 0;\n      usedW = 0;\n      rowH = 0;\n    }\n  }\n};\n\nvar defaults$3 = {\n  fit: true,\n  // whether to fit the viewport to the graph\n  padding: 30,\n  // padding used on fit\n  boundingBox: undefined,\n  // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }\n  avoidOverlap: true,\n  // prevents node overlap, may overflow boundingBox if not enough space\n  avoidOverlapPadding: 10,\n  // extra spacing around nodes when avoidOverlap: true\n  nodeDimensionsIncludeLabels: false,\n  // Excludes the label when calculating node bounding boxes for the layout algorithm\n  spacingFactor: undefined,\n  // Applies a multiplicative factor (>0) to expand or compress the overall area that the nodes take up\n  condense: false,\n  // uses all available space on false, uses minimal space on true\n  rows: undefined,\n  // force num of rows in the grid\n  cols: undefined,\n  // force num of columns in the grid\n  position: function position(node) {},\n  // returns { row, col } for element\n  sort: undefined,\n  // a sorting function to order the nodes; e.g. function(a, b){ return a.data('weight') - b.data('weight') }\n  animate: false,\n  // whether to transition the node positions\n  animationDuration: 500,\n  // duration of animation in ms if enabled\n  animationEasing: undefined,\n  // easing of animation if enabled\n  animateFilter: function animateFilter(node, i) {\n    return true;\n  },\n  // a function that determines whether the node should be animated.  All nodes animated by default on animate enabled.  Non-animated nodes are positioned immediately when the layout starts\n  ready: undefined,\n  // callback on layoutready\n  stop: undefined,\n  // callback on layoutstop\n  transform: function transform(node, position) {\n    return position;\n  } // transform a given node position. Useful for changing flow direction in discrete layouts \n};\n\nfunction GridLayout(options) {\n  this.options = extend({}, defaults$3, options);\n}\nGridLayout.prototype.run = function () {\n  var params = this.options;\n  var options = params;\n  var cy = params.cy;\n  var eles = options.eles;\n  var nodes = eles.nodes().not(':parent');\n  if (options.sort) {\n    nodes = nodes.sort(options.sort);\n  }\n  var bb = makeBoundingBox(options.boundingBox ? options.boundingBox : {\n    x1: 0,\n    y1: 0,\n    w: cy.width(),\n    h: cy.height()\n  });\n  if (bb.h === 0 || bb.w === 0) {\n    eles.nodes().layoutPositions(this, options, function (ele) {\n      return {\n        x: bb.x1,\n        y: bb.y1\n      };\n    });\n  } else {\n    // width/height * splits^2 = cells where splits is number of times to split width\n    var cells = nodes.size();\n    var splits = Math.sqrt(cells * bb.h / bb.w);\n    var rows = Math.round(splits);\n    var cols = Math.round(bb.w / bb.h * splits);\n    var small = function small(val) {\n      if (val == null) {\n        return Math.min(rows, cols);\n      } else {\n        var min = Math.min(rows, cols);\n        if (min == rows) {\n          rows = val;\n        } else {\n          cols = val;\n        }\n      }\n    };\n    var large = function large(val) {\n      if (val == null) {\n        return Math.max(rows, cols);\n      } else {\n        var max = Math.max(rows, cols);\n        if (max == rows) {\n          rows = val;\n        } else {\n          cols = val;\n        }\n      }\n    };\n    var oRows = options.rows;\n    var oCols = options.cols != null ? options.cols : options.columns;\n\n    // if rows or columns were set in options, use those values\n    if (oRows != null && oCols != null) {\n      rows = oRows;\n      cols = oCols;\n    } else if (oRows != null && oCols == null) {\n      rows = oRows;\n      cols = Math.ceil(cells / rows);\n    } else if (oRows == null && oCols != null) {\n      cols = oCols;\n      rows = Math.ceil(cells / cols);\n    }\n\n    // otherwise use the automatic values and adjust accordingly\n\n    // if rounding was up, see if we can reduce rows or columns\n    else if (cols * rows > cells) {\n      var sm = small();\n      var lg = large();\n\n      // reducing the small side takes away the most cells, so try it first\n      if ((sm - 1) * lg >= cells) {\n        small(sm - 1);\n      } else if ((lg - 1) * sm >= cells) {\n        large(lg - 1);\n      }\n    } else {\n      // if rounding was too low, add rows or columns\n      while (cols * rows < cells) {\n        var _sm = small();\n        var _lg = large();\n\n        // try to add to larger side first (adds less in multiplication)\n        if ((_lg + 1) * _sm >= cells) {\n          large(_lg + 1);\n        } else {\n          small(_sm + 1);\n        }\n      }\n    }\n    var cellWidth = bb.w / cols;\n    var cellHeight = bb.h / rows;\n    if (options.condense) {\n      cellWidth = 0;\n      cellHeight = 0;\n    }\n    if (options.avoidOverlap) {\n      for (var i = 0; i < nodes.length; i++) {\n        var node = nodes[i];\n        var pos = node._private.position;\n        if (pos.x == null || pos.y == null) {\n          // for bb\n          pos.x = 0;\n          pos.y = 0;\n        }\n        var nbb = node.layoutDimensions(options);\n        var p = options.avoidOverlapPadding;\n        var w = nbb.w + p;\n        var h = nbb.h + p;\n        cellWidth = Math.max(cellWidth, w);\n        cellHeight = Math.max(cellHeight, h);\n      }\n    }\n    var cellUsed = {}; // e.g. 'c-0-2' => true\n\n    var used = function used(row, col) {\n      return cellUsed['c-' + row + '-' + col] ? true : false;\n    };\n    var use = function use(row, col) {\n      cellUsed['c-' + row + '-' + col] = true;\n    };\n\n    // to keep track of current cell position\n    var row = 0;\n    var col = 0;\n    var moveToNextCell = function moveToNextCell() {\n      col++;\n      if (col >= cols) {\n        col = 0;\n        row++;\n      }\n    };\n\n    // get a cache of all the manual positions\n    var id2manPos = {};\n    for (var _i = 0; _i < nodes.length; _i++) {\n      var _node = nodes[_i];\n      var rcPos = options.position(_node);\n      if (rcPos && (rcPos.row !== undefined || rcPos.col !== undefined)) {\n        // must have at least row or col def'd\n        var _pos = {\n          row: rcPos.row,\n          col: rcPos.col\n        };\n        if (_pos.col === undefined) {\n          // find unused col\n          _pos.col = 0;\n          while (used(_pos.row, _pos.col)) {\n            _pos.col++;\n          }\n        } else if (_pos.row === undefined) {\n          // find unused row\n          _pos.row = 0;\n          while (used(_pos.row, _pos.col)) {\n            _pos.row++;\n          }\n        }\n        id2manPos[_node.id()] = _pos;\n        use(_pos.row, _pos.col);\n      }\n    }\n    var getPos = function getPos(element, i) {\n      var x, y;\n      if (element.locked() || element.isParent()) {\n        return false;\n      }\n\n      // see if we have a manual position set\n      var rcPos = id2manPos[element.id()];\n      if (rcPos) {\n        x = rcPos.col * cellWidth + cellWidth / 2 + bb.x1;\n        y = rcPos.row * cellHeight + cellHeight / 2 + bb.y1;\n      } else {\n        // otherwise set automatically\n\n        while (used(row, col)) {\n          moveToNextCell();\n        }\n        x = col * cellWidth + cellWidth / 2 + bb.x1;\n        y = row * cellHeight + cellHeight / 2 + bb.y1;\n        use(row, col);\n        moveToNextCell();\n      }\n      return {\n        x: x,\n        y: y\n      };\n    };\n    nodes.layoutPositions(this, options, getPos);\n  }\n  return this; // chaining\n};\n\n// default layout options\nvar defaults$2 = {\n  ready: function ready() {},\n  // on layoutready\n  stop: function stop() {} // on layoutstop\n};\n\n// constructor\n// options : object containing layout options\nfunction NullLayout(options) {\n  this.options = extend({}, defaults$2, options);\n}\n\n// runs the layout\nNullLayout.prototype.run = function () {\n  var options = this.options;\n  var eles = options.eles; // elements to consider in the layout\n  var layout = this;\n\n  // cy is automatically populated for us in the constructor\n  // (disable eslint for next line as this serves as example layout code to external developers)\n  // eslint-disable-next-line no-unused-vars\n  options.cy;\n  layout.emit('layoutstart');\n\n  // puts all nodes at (0, 0)\n  // n.b. most layouts would use layoutPositions(), instead of positions() and manual events\n  eles.nodes().positions(function () {\n    return {\n      x: 0,\n      y: 0\n    };\n  });\n\n  // trigger layoutready when each node has had its position set at least once\n  layout.one('layoutready', options.ready);\n  layout.emit('layoutready');\n\n  // trigger layoutstop when the layout stops (e.g. finishes)\n  layout.one('layoutstop', options.stop);\n  layout.emit('layoutstop');\n  return this; // chaining\n};\n\n// called on continuous layouts to stop them before they finish\nNullLayout.prototype.stop = function () {\n  return this; // chaining\n};\n\nvar defaults$1 = {\n  positions: undefined,\n  // map of (node id) => (position obj); or function(node){ return somPos; }\n  zoom: undefined,\n  // the zoom level to set (prob want fit = false if set)\n  pan: undefined,\n  // the pan level to set (prob want fit = false if set)\n  fit: true,\n  // whether to fit to viewport\n  padding: 30,\n  // padding on fit\n  spacingFactor: undefined,\n  // Applies a multiplicative factor (>0) to expand or compress the overall area that the nodes take up\n  animate: false,\n  // whether to transition the node positions\n  animationDuration: 500,\n  // duration of animation in ms if enabled\n  animationEasing: undefined,\n  // easing of animation if enabled\n  animateFilter: function animateFilter(node, i) {\n    return true;\n  },\n  // a function that determines whether the node should be animated.  All nodes animated by default on animate enabled.  Non-animated nodes are positioned immediately when the layout starts\n  ready: undefined,\n  // callback on layoutready\n  stop: undefined,\n  // callback on layoutstop\n  transform: function transform(node, position) {\n    return position;\n  } // transform a given node position. Useful for changing flow direction in discrete layouts\n};\n\nfunction PresetLayout(options) {\n  this.options = extend({}, defaults$1, options);\n}\nPresetLayout.prototype.run = function () {\n  var options = this.options;\n  var eles = options.eles;\n  var nodes = eles.nodes();\n  var posIsFn = fn$6(options.positions);\n  function getPosition(node) {\n    if (options.positions == null) {\n      return copyPosition(node.position());\n    }\n    if (posIsFn) {\n      return options.positions(node);\n    }\n    var pos = options.positions[node._private.data.id];\n    if (pos == null) {\n      return null;\n    }\n    return pos;\n  }\n  nodes.layoutPositions(this, options, function (node, i) {\n    var position = getPosition(node);\n    if (node.locked() || position == null) {\n      return false;\n    }\n    return position;\n  });\n  return this; // chaining\n};\n\nvar defaults = {\n  fit: true,\n  // whether to fit to viewport\n  padding: 30,\n  // fit padding\n  boundingBox: undefined,\n  // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }\n  animate: false,\n  // whether to transition the node positions\n  animationDuration: 500,\n  // duration of animation in ms if enabled\n  animationEasing: undefined,\n  // easing of animation if enabled\n  animateFilter: function animateFilter(node, i) {\n    return true;\n  },\n  // a function that determines whether the node should be animated.  All nodes animated by default on animate enabled.  Non-animated nodes are positioned immediately when the layout starts\n  ready: undefined,\n  // callback on layoutready\n  stop: undefined,\n  // callback on layoutstop\n  transform: function transform(node, position) {\n    return position;\n  } // transform a given node position. Useful for changing flow direction in discrete layouts \n};\n\nfunction RandomLayout(options) {\n  this.options = extend({}, defaults, options);\n}\nRandomLayout.prototype.run = function () {\n  var options = this.options;\n  var cy = options.cy;\n  var eles = options.eles;\n  var bb = makeBoundingBox(options.boundingBox ? options.boundingBox : {\n    x1: 0,\n    y1: 0,\n    w: cy.width(),\n    h: cy.height()\n  });\n  var getPos = function getPos(node, i) {\n    return {\n      x: bb.x1 + Math.round(Math.random() * bb.w),\n      y: bb.y1 + Math.round(Math.random() * bb.h)\n    };\n  };\n  eles.nodes().layoutPositions(this, options, getPos);\n  return this; // chaining\n};\n\nvar layout = [{\n  name: 'breadthfirst',\n  impl: BreadthFirstLayout\n}, {\n  name: 'circle',\n  impl: CircleLayout\n}, {\n  name: 'concentric',\n  impl: ConcentricLayout\n}, {\n  name: 'cose',\n  impl: CoseLayout\n}, {\n  name: 'grid',\n  impl: GridLayout\n}, {\n  name: 'null',\n  impl: NullLayout\n}, {\n  name: 'preset',\n  impl: PresetLayout\n}, {\n  name: 'random',\n  impl: RandomLayout\n}];\n\nfunction NullRenderer(options) {\n  this.options = options;\n  this.notifications = 0; // for testing\n}\n\nvar noop = function noop() {};\nvar throwImgErr = function throwImgErr() {\n  throw new Error('A headless instance can not render images');\n};\nNullRenderer.prototype = {\n  recalculateRenderedStyle: noop,\n  notify: function notify() {\n    this.notifications++;\n  },\n  init: noop,\n  isHeadless: function isHeadless() {\n    return true;\n  },\n  png: throwImgErr,\n  jpg: throwImgErr\n};\n\nvar BRp$f = {};\nBRp$f.arrowShapeWidth = 0.3;\nBRp$f.registerArrowShapes = function () {\n  var arrowShapes = this.arrowShapes = {};\n  var renderer = this;\n\n  // Contract for arrow shapes:\n  // 0, 0 is arrow tip\n  // (0, 1) is direction towards node\n  // (1, 0) is right\n  //\n  // functional api:\n  // collide: check x, y in shape\n  // roughCollide: called before collide, no false negatives\n  // draw: draw\n  // spacing: dist(arrowTip, nodeBoundary)\n  // gap: dist(edgeTip, nodeBoundary), edgeTip may != arrowTip\n\n  var bbCollide = function bbCollide(x, y, size, angle, translation, edgeWidth, padding) {\n    var x1 = translation.x - size / 2 - padding;\n    var x2 = translation.x + size / 2 + padding;\n    var y1 = translation.y - size / 2 - padding;\n    var y2 = translation.y + size / 2 + padding;\n    var inside = x1 <= x && x <= x2 && y1 <= y && y <= y2;\n    return inside;\n  };\n  var transform = function transform(x, y, size, angle, translation) {\n    var xRotated = x * Math.cos(angle) - y * Math.sin(angle);\n    var yRotated = x * Math.sin(angle) + y * Math.cos(angle);\n    var xScaled = xRotated * size;\n    var yScaled = yRotated * size;\n    var xTranslated = xScaled + translation.x;\n    var yTranslated = yScaled + translation.y;\n    return {\n      x: xTranslated,\n      y: yTranslated\n    };\n  };\n  var transformPoints = function transformPoints(pts, size, angle, translation) {\n    var retPts = [];\n    for (var i = 0; i < pts.length; i += 2) {\n      var x = pts[i];\n      var y = pts[i + 1];\n      retPts.push(transform(x, y, size, angle, translation));\n    }\n    return retPts;\n  };\n  var pointsToArr = function pointsToArr(pts) {\n    var ret = [];\n    for (var i = 0; i < pts.length; i++) {\n      var p = pts[i];\n      ret.push(p.x, p.y);\n    }\n    return ret;\n  };\n  var standardGap = function standardGap(edge) {\n    return edge.pstyle('width').pfValue * edge.pstyle('arrow-scale').pfValue * 2;\n  };\n  var defineArrowShape = function defineArrowShape(name, defn) {\n    if (string(defn)) {\n      defn = arrowShapes[defn];\n    }\n    arrowShapes[name] = extend({\n      name: name,\n      points: [-0.15, -0.3, 0.15, -0.3, 0.15, 0.3, -0.15, 0.3],\n      collide: function collide(x, y, size, angle, translation, padding) {\n        var points = pointsToArr(transformPoints(this.points, size + 2 * padding, angle, translation));\n        var inside = pointInsidePolygonPoints(x, y, points);\n        return inside;\n      },\n      roughCollide: bbCollide,\n      draw: function draw(context, size, angle, translation) {\n        var points = transformPoints(this.points, size, angle, translation);\n        renderer.arrowShapeImpl('polygon')(context, points);\n      },\n      spacing: function spacing(edge) {\n        return 0;\n      },\n      gap: standardGap\n    }, defn);\n  };\n  defineArrowShape('none', {\n    collide: falsify,\n    roughCollide: falsify,\n    draw: noop$1,\n    spacing: zeroify,\n    gap: zeroify\n  });\n  defineArrowShape('triangle', {\n    points: [-0.15, -0.3, 0, 0, 0.15, -0.3]\n  });\n  defineArrowShape('arrow', 'triangle');\n  defineArrowShape('triangle-backcurve', {\n    points: arrowShapes['triangle'].points,\n    controlPoint: [0, -0.15],\n    roughCollide: bbCollide,\n    draw: function draw(context, size, angle, translation, edgeWidth) {\n      var ptsTrans = transformPoints(this.points, size, angle, translation);\n      var ctrlPt = this.controlPoint;\n      var ctrlPtTrans = transform(ctrlPt[0], ctrlPt[1], size, angle, translation);\n      renderer.arrowShapeImpl(this.name)(context, ptsTrans, ctrlPtTrans);\n    },\n    gap: function gap(edge) {\n      return standardGap(edge) * 0.8;\n    }\n  });\n  defineArrowShape('triangle-tee', {\n    points: [0, 0, 0.15, -0.3, -0.15, -0.3, 0, 0],\n    pointsTee: [-0.15, -0.4, -0.15, -0.5, 0.15, -0.5, 0.15, -0.4],\n    collide: function collide(x, y, size, angle, translation, edgeWidth, padding) {\n      var triPts = pointsToArr(transformPoints(this.points, size + 2 * padding, angle, translation));\n      var teePts = pointsToArr(transformPoints(this.pointsTee, size + 2 * padding, angle, translation));\n      var inside = pointInsidePolygonPoints(x, y, triPts) || pointInsidePolygonPoints(x, y, teePts);\n      return inside;\n    },\n    draw: function draw(context, size, angle, translation, edgeWidth) {\n      var triPts = transformPoints(this.points, size, angle, translation);\n      var teePts = transformPoints(this.pointsTee, size, angle, translation);\n      renderer.arrowShapeImpl(this.name)(context, triPts, teePts);\n    }\n  });\n  defineArrowShape('circle-triangle', {\n    radius: 0.15,\n    pointsTr: [0, -0.15, 0.15, -0.45, -0.15, -0.45, 0, -0.15],\n    collide: function collide(x, y, size, angle, translation, edgeWidth, padding) {\n      var t = translation;\n      var circleInside = Math.pow(t.x - x, 2) + Math.pow(t.y - y, 2) <= Math.pow((size + 2 * padding) * this.radius, 2);\n      var triPts = pointsToArr(transformPoints(this.points, size + 2 * padding, angle, translation));\n      return pointInsidePolygonPoints(x, y, triPts) || circleInside;\n    },\n    draw: function draw(context, size, angle, translation, edgeWidth) {\n      var triPts = transformPoints(this.pointsTr, size, angle, translation);\n      renderer.arrowShapeImpl(this.name)(context, triPts, translation.x, translation.y, this.radius * size);\n    },\n    spacing: function spacing(edge) {\n      return renderer.getArrowWidth(edge.pstyle('width').pfValue, edge.pstyle('arrow-scale').value) * this.radius;\n    }\n  });\n  defineArrowShape('triangle-cross', {\n    points: [0, 0, 0.15, -0.3, -0.15, -0.3, 0, 0],\n    baseCrossLinePts: [-0.15, -0.4,\n    // first half of the rectangle\n    -0.15, -0.4, 0.15, -0.4,\n    // second half of the rectangle\n    0.15, -0.4],\n    crossLinePts: function crossLinePts(size, edgeWidth) {\n      // shift points so that the distance between the cross points matches edge width\n      var p = this.baseCrossLinePts.slice();\n      var shiftFactor = edgeWidth / size;\n      var y0 = 3;\n      var y1 = 5;\n      p[y0] = p[y0] - shiftFactor;\n      p[y1] = p[y1] - shiftFactor;\n      return p;\n    },\n    collide: function collide(x, y, size, angle, translation, edgeWidth, padding) {\n      var triPts = pointsToArr(transformPoints(this.points, size + 2 * padding, angle, translation));\n      var teePts = pointsToArr(transformPoints(this.crossLinePts(size, edgeWidth), size + 2 * padding, angle, translation));\n      var inside = pointInsidePolygonPoints(x, y, triPts) || pointInsidePolygonPoints(x, y, teePts);\n      return inside;\n    },\n    draw: function draw(context, size, angle, translation, edgeWidth) {\n      var triPts = transformPoints(this.points, size, angle, translation);\n      var crossLinePts = transformPoints(this.crossLinePts(size, edgeWidth), size, angle, translation);\n      renderer.arrowShapeImpl(this.name)(context, triPts, crossLinePts);\n    }\n  });\n  defineArrowShape('vee', {\n    points: [-0.15, -0.3, 0, 0, 0.15, -0.3, 0, -0.15],\n    gap: function gap(edge) {\n      return standardGap(edge) * 0.525;\n    }\n  });\n  defineArrowShape('circle', {\n    radius: 0.15,\n    collide: function collide(x, y, size, angle, translation, edgeWidth, padding) {\n      var t = translation;\n      var inside = Math.pow(t.x - x, 2) + Math.pow(t.y - y, 2) <= Math.pow((size + 2 * padding) * this.radius, 2);\n      return inside;\n    },\n    draw: function draw(context, size, angle, translation, edgeWidth) {\n      renderer.arrowShapeImpl(this.name)(context, translation.x, translation.y, this.radius * size);\n    },\n    spacing: function spacing(edge) {\n      return renderer.getArrowWidth(edge.pstyle('width').pfValue, edge.pstyle('arrow-scale').value) * this.radius;\n    }\n  });\n  defineArrowShape('tee', {\n    points: [-0.15, 0, -0.15, -0.1, 0.15, -0.1, 0.15, 0],\n    spacing: function spacing(edge) {\n      return 1;\n    },\n    gap: function gap(edge) {\n      return 1;\n    }\n  });\n  defineArrowShape('square', {\n    points: [-0.15, 0.00, 0.15, 0.00, 0.15, -0.3, -0.15, -0.3]\n  });\n  defineArrowShape('diamond', {\n    points: [-0.15, -0.15, 0, -0.3, 0.15, -0.15, 0, 0],\n    gap: function gap(edge) {\n      return edge.pstyle('width').pfValue * edge.pstyle('arrow-scale').value;\n    }\n  });\n  defineArrowShape('chevron', {\n    points: [0, 0, -0.15, -0.15, -0.1, -0.2, 0, -0.1, 0.1, -0.2, 0.15, -0.15],\n    gap: function gap(edge) {\n      return 0.95 * edge.pstyle('width').pfValue * edge.pstyle('arrow-scale').value;\n    }\n  });\n};\n\nvar BRp$e = {};\n\n// Project mouse\nBRp$e.projectIntoViewport = function (clientX, clientY) {\n  var cy = this.cy;\n  var offsets = this.findContainerClientCoords();\n  var offsetLeft = offsets[0];\n  var offsetTop = offsets[1];\n  var scale = offsets[4];\n  var pan = cy.pan();\n  var zoom = cy.zoom();\n  var x = ((clientX - offsetLeft) / scale - pan.x) / zoom;\n  var y = ((clientY - offsetTop) / scale - pan.y) / zoom;\n  return [x, y];\n};\nBRp$e.findContainerClientCoords = function () {\n  if (this.containerBB) {\n    return this.containerBB;\n  }\n  var container = this.container;\n  var rect = container.getBoundingClientRect();\n  var style = this.cy.window().getComputedStyle(container);\n  var styleValue = function styleValue(name) {\n    return parseFloat(style.getPropertyValue(name));\n  };\n  var padding = {\n    left: styleValue('padding-left'),\n    right: styleValue('padding-right'),\n    top: styleValue('padding-top'),\n    bottom: styleValue('padding-bottom')\n  };\n  var border = {\n    left: styleValue('border-left-width'),\n    right: styleValue('border-right-width'),\n    top: styleValue('border-top-width'),\n    bottom: styleValue('border-bottom-width')\n  };\n  var clientWidth = container.clientWidth;\n  var clientHeight = container.clientHeight;\n  var paddingHor = padding.left + padding.right;\n  var paddingVer = padding.top + padding.bottom;\n  var borderHor = border.left + border.right;\n  var scale = rect.width / (clientWidth + borderHor);\n  var unscaledW = clientWidth - paddingHor;\n  var unscaledH = clientHeight - paddingVer;\n  var left = rect.left + padding.left + border.left;\n  var top = rect.top + padding.top + border.top;\n  return this.containerBB = [left, top, unscaledW, unscaledH, scale];\n};\nBRp$e.invalidateContainerClientCoordsCache = function () {\n  this.containerBB = null;\n};\nBRp$e.findNearestElement = function (x, y, interactiveElementsOnly, isTouch) {\n  return this.findNearestElements(x, y, interactiveElementsOnly, isTouch)[0];\n};\nBRp$e.findNearestElements = function (x, y, interactiveElementsOnly, isTouch) {\n  var self = this;\n  var r = this;\n  var eles = r.getCachedZSortedEles();\n  var near = []; // 1 node max, 1 edge max\n  var zoom = r.cy.zoom();\n  var hasCompounds = r.cy.hasCompoundNodes();\n  var edgeThreshold = (isTouch ? 24 : 8) / zoom;\n  var nodeThreshold = (isTouch ? 8 : 2) / zoom;\n  var labelThreshold = (isTouch ? 8 : 2) / zoom;\n  var minSqDist = Infinity;\n  var nearEdge;\n  var nearNode;\n  if (interactiveElementsOnly) {\n    eles = eles.interactive;\n  }\n  function addEle(ele, sqDist) {\n    if (ele.isNode()) {\n      if (nearNode) {\n        return; // can't replace node\n      } else {\n        nearNode = ele;\n        near.push(ele);\n      }\n    }\n    if (ele.isEdge() && (sqDist == null || sqDist < minSqDist)) {\n      if (nearEdge) {\n        // then replace existing edge\n        // can replace only if same z-index\n        if (nearEdge.pstyle('z-compound-depth').value === ele.pstyle('z-compound-depth').value && nearEdge.pstyle('z-compound-depth').value === ele.pstyle('z-compound-depth').value) {\n          for (var i = 0; i < near.length; i++) {\n            if (near[i].isEdge()) {\n              near[i] = ele;\n              nearEdge = ele;\n              minSqDist = sqDist != null ? sqDist : minSqDist;\n              break;\n            }\n          }\n        }\n      } else {\n        near.push(ele);\n        nearEdge = ele;\n        minSqDist = sqDist != null ? sqDist : minSqDist;\n      }\n    }\n  }\n  function checkNode(node) {\n    var width = node.outerWidth() + 2 * nodeThreshold;\n    var height = node.outerHeight() + 2 * nodeThreshold;\n    var hw = width / 2;\n    var hh = height / 2;\n    var pos = node.position();\n    var cornerRadius = node.pstyle('corner-radius').value === 'auto' ? 'auto' : node.pstyle('corner-radius').pfValue;\n    var rs = node._private.rscratch;\n    if (pos.x - hw <= x && x <= pos.x + hw // bb check x\n    && pos.y - hh <= y && y <= pos.y + hh // bb check y\n    ) {\n      var shape = r.nodeShapes[self.getNodeShape(node)];\n      if (shape.checkPoint(x, y, 0, width, height, pos.x, pos.y, cornerRadius, rs)) {\n        addEle(node, 0);\n        return true;\n      }\n    }\n  }\n  function checkEdge(edge) {\n    var _p = edge._private;\n    var rs = _p.rscratch;\n    var styleWidth = edge.pstyle('width').pfValue;\n    var scale = edge.pstyle('arrow-scale').value;\n    var width = styleWidth / 2 + edgeThreshold; // more like a distance radius from centre\n    var widthSq = width * width;\n    var width2 = width * 2;\n    var src = _p.source;\n    var tgt = _p.target;\n    var sqDist;\n    if (rs.edgeType === 'segments' || rs.edgeType === 'straight' || rs.edgeType === 'haystack') {\n      var pts = rs.allpts;\n      for (var i = 0; i + 3 < pts.length; i += 2) {\n        if (inLineVicinity(x, y, pts[i], pts[i + 1], pts[i + 2], pts[i + 3], width2) && widthSq > (sqDist = sqdistToFiniteLine(x, y, pts[i], pts[i + 1], pts[i + 2], pts[i + 3]))) {\n          addEle(edge, sqDist);\n          return true;\n        }\n      }\n    } else if (rs.edgeType === 'bezier' || rs.edgeType === 'multibezier' || rs.edgeType === 'self' || rs.edgeType === 'compound') {\n      var pts = rs.allpts;\n      for (var i = 0; i + 5 < rs.allpts.length; i += 4) {\n        if (inBezierVicinity(x, y, pts[i], pts[i + 1], pts[i + 2], pts[i + 3], pts[i + 4], pts[i + 5], width2) && widthSq > (sqDist = sqdistToQuadraticBezier(x, y, pts[i], pts[i + 1], pts[i + 2], pts[i + 3], pts[i + 4], pts[i + 5]))) {\n          addEle(edge, sqDist);\n          return true;\n        }\n      }\n    }\n\n    // if we're close to the edge but didn't hit it, maybe we hit its arrows\n\n    var src = src || _p.source;\n    var tgt = tgt || _p.target;\n    var arSize = self.getArrowWidth(styleWidth, scale);\n    var arrows = [{\n      name: 'source',\n      x: rs.arrowStartX,\n      y: rs.arrowStartY,\n      angle: rs.srcArrowAngle\n    }, {\n      name: 'target',\n      x: rs.arrowEndX,\n      y: rs.arrowEndY,\n      angle: rs.tgtArrowAngle\n    }, {\n      name: 'mid-source',\n      x: rs.midX,\n      y: rs.midY,\n      angle: rs.midsrcArrowAngle\n    }, {\n      name: 'mid-target',\n      x: rs.midX,\n      y: rs.midY,\n      angle: rs.midtgtArrowAngle\n    }];\n    for (var i = 0; i < arrows.length; i++) {\n      var ar = arrows[i];\n      var shape = r.arrowShapes[edge.pstyle(ar.name + '-arrow-shape').value];\n      var edgeWidth = edge.pstyle('width').pfValue;\n      if (shape.roughCollide(x, y, arSize, ar.angle, {\n        x: ar.x,\n        y: ar.y\n      }, edgeWidth, edgeThreshold) && shape.collide(x, y, arSize, ar.angle, {\n        x: ar.x,\n        y: ar.y\n      }, edgeWidth, edgeThreshold)) {\n        addEle(edge);\n        return true;\n      }\n    }\n\n    // for compound graphs, hitting edge may actually want a connected node instead (b/c edge may have greater z-index precedence)\n    if (hasCompounds && near.length > 0) {\n      checkNode(src);\n      checkNode(tgt);\n    }\n  }\n  function preprop(obj, name, pre) {\n    return getPrefixedProperty(obj, name, pre);\n  }\n  function checkLabel(ele, prefix) {\n    var _p = ele._private;\n    var th = labelThreshold;\n    var prefixDash;\n    if (prefix) {\n      prefixDash = prefix + '-';\n    } else {\n      prefixDash = '';\n    }\n    ele.boundingBox();\n    var bb = _p.labelBounds[prefix || 'main'];\n    var text = ele.pstyle(prefixDash + 'label').value;\n    var eventsEnabled = ele.pstyle('text-events').strValue === 'yes';\n    if (!eventsEnabled || !text) {\n      return;\n    }\n    var lx = preprop(_p.rscratch, 'labelX', prefix);\n    var ly = preprop(_p.rscratch, 'labelY', prefix);\n    var theta = preprop(_p.rscratch, 'labelAngle', prefix);\n    var ox = ele.pstyle(prefixDash + 'text-margin-x').pfValue;\n    var oy = ele.pstyle(prefixDash + 'text-margin-y').pfValue;\n    var lx1 = bb.x1 - th - ox; // (-ox, -oy) as bb already includes margin\n    var lx2 = bb.x2 + th - ox; // and rotation is about (lx, ly)\n    var ly1 = bb.y1 - th - oy;\n    var ly2 = bb.y2 + th - oy;\n    if (theta) {\n      var cos = Math.cos(theta);\n      var sin = Math.sin(theta);\n      var rotate = function rotate(x, y) {\n        x = x - lx;\n        y = y - ly;\n        return {\n          x: x * cos - y * sin + lx,\n          y: x * sin + y * cos + ly\n        };\n      };\n      var px1y1 = rotate(lx1, ly1);\n      var px1y2 = rotate(lx1, ly2);\n      var px2y1 = rotate(lx2, ly1);\n      var px2y2 = rotate(lx2, ly2);\n      var points = [\n      // with the margin added after the rotation is applied\n      px1y1.x + ox, px1y1.y + oy, px2y1.x + ox, px2y1.y + oy, px2y2.x + ox, px2y2.y + oy, px1y2.x + ox, px1y2.y + oy];\n      if (pointInsidePolygonPoints(x, y, points)) {\n        addEle(ele);\n        return true;\n      }\n    } else {\n      // do a cheaper bb check\n      if (inBoundingBox(bb, x, y)) {\n        addEle(ele);\n        return true;\n      }\n    }\n  }\n  for (var i = eles.length - 1; i >= 0; i--) {\n    // reverse order for precedence\n    var ele = eles[i];\n    if (ele.isNode()) {\n      checkNode(ele) || checkLabel(ele);\n    } else {\n      // then edge\n      checkEdge(ele) || checkLabel(ele) || checkLabel(ele, 'source') || checkLabel(ele, 'target');\n    }\n  }\n  return near;\n};\n\n// 'Give me everything from this box'\nBRp$e.getAllInBox = function (x1, y1, x2, y2) {\n  var eles = this.getCachedZSortedEles().interactive;\n  var box = [];\n  var x1c = Math.min(x1, x2);\n  var x2c = Math.max(x1, x2);\n  var y1c = Math.min(y1, y2);\n  var y2c = Math.max(y1, y2);\n  x1 = x1c;\n  x2 = x2c;\n  y1 = y1c;\n  y2 = y2c;\n  var boxBb = makeBoundingBox({\n    x1: x1,\n    y1: y1,\n    x2: x2,\n    y2: y2\n  });\n  for (var e = 0; e < eles.length; e++) {\n    var ele = eles[e];\n    if (ele.isNode()) {\n      var node = ele;\n      var nodeBb = node.boundingBox({\n        includeNodes: true,\n        includeEdges: false,\n        includeLabels: false\n      });\n      if (boundingBoxesIntersect(boxBb, nodeBb) && !boundingBoxInBoundingBox(nodeBb, boxBb)) {\n        box.push(node);\n      }\n    } else {\n      var edge = ele;\n      var _p = edge._private;\n      var rs = _p.rscratch;\n      if (rs.startX != null && rs.startY != null && !inBoundingBox(boxBb, rs.startX, rs.startY)) {\n        continue;\n      }\n      if (rs.endX != null && rs.endY != null && !inBoundingBox(boxBb, rs.endX, rs.endY)) {\n        continue;\n      }\n      if (rs.edgeType === 'bezier' || rs.edgeType === 'multibezier' || rs.edgeType === 'self' || rs.edgeType === 'compound' || rs.edgeType === 'segments' || rs.edgeType === 'haystack') {\n        var pts = _p.rstyle.bezierPts || _p.rstyle.linePts || _p.rstyle.haystackPts;\n        var allInside = true;\n        for (var i = 0; i < pts.length; i++) {\n          if (!pointInBoundingBox(boxBb, pts[i])) {\n            allInside = false;\n            break;\n          }\n        }\n        if (allInside) {\n          box.push(edge);\n        }\n      } else if (rs.edgeType === 'haystack' || rs.edgeType === 'straight') {\n        box.push(edge);\n      }\n    }\n  }\n  return box;\n};\n\nvar BRp$d = {};\nBRp$d.calculateArrowAngles = function (edge) {\n  var rs = edge._private.rscratch;\n  var isHaystack = rs.edgeType === 'haystack';\n  var isBezier = rs.edgeType === 'bezier';\n  var isMultibezier = rs.edgeType === 'multibezier';\n  var isSegments = rs.edgeType === 'segments';\n  var isCompound = rs.edgeType === 'compound';\n  var isSelf = rs.edgeType === 'self';\n\n  // Displacement gives direction for arrowhead orientation\n  var dispX, dispY;\n  var startX, startY, endX, endY, midX, midY;\n  if (isHaystack) {\n    startX = rs.haystackPts[0];\n    startY = rs.haystackPts[1];\n    endX = rs.haystackPts[2];\n    endY = rs.haystackPts[3];\n  } else {\n    startX = rs.arrowStartX;\n    startY = rs.arrowStartY;\n    endX = rs.arrowEndX;\n    endY = rs.arrowEndY;\n  }\n  midX = rs.midX;\n  midY = rs.midY;\n\n  // source\n  //\n\n  if (isSegments) {\n    dispX = startX - rs.segpts[0];\n    dispY = startY - rs.segpts[1];\n  } else if (isMultibezier || isCompound || isSelf || isBezier) {\n    var pts = rs.allpts;\n    var bX = qbezierAt(pts[0], pts[2], pts[4], 0.1);\n    var bY = qbezierAt(pts[1], pts[3], pts[5], 0.1);\n    dispX = startX - bX;\n    dispY = startY - bY;\n  } else {\n    dispX = startX - midX;\n    dispY = startY - midY;\n  }\n  rs.srcArrowAngle = getAngleFromDisp(dispX, dispY);\n\n  // mid target\n  //\n\n  var midX = rs.midX;\n  var midY = rs.midY;\n  if (isHaystack) {\n    midX = (startX + endX) / 2;\n    midY = (startY + endY) / 2;\n  }\n  dispX = endX - startX;\n  dispY = endY - startY;\n  if (isSegments) {\n    var pts = rs.allpts;\n    if (pts.length / 2 % 2 === 0) {\n      var i2 = pts.length / 2;\n      var i1 = i2 - 2;\n      dispX = pts[i2] - pts[i1];\n      dispY = pts[i2 + 1] - pts[i1 + 1];\n    } else if (rs.isRound) {\n      dispX = rs.midVector[1];\n      dispY = -rs.midVector[0];\n    } else {\n      var i2 = pts.length / 2 - 1;\n      var i1 = i2 - 2;\n      dispX = pts[i2] - pts[i1];\n      dispY = pts[i2 + 1] - pts[i1 + 1];\n    }\n  } else if (isMultibezier || isCompound || isSelf) {\n    var pts = rs.allpts;\n    var cpts = rs.ctrlpts;\n    var bp0x, bp0y;\n    var bp1x, bp1y;\n    if (cpts.length / 2 % 2 === 0) {\n      var p0 = pts.length / 2 - 1; // startpt\n      var ic = p0 + 2;\n      var p1 = ic + 2;\n      bp0x = qbezierAt(pts[p0], pts[ic], pts[p1], 0.0);\n      bp0y = qbezierAt(pts[p0 + 1], pts[ic + 1], pts[p1 + 1], 0.0);\n      bp1x = qbezierAt(pts[p0], pts[ic], pts[p1], 0.0001);\n      bp1y = qbezierAt(pts[p0 + 1], pts[ic + 1], pts[p1 + 1], 0.0001);\n    } else {\n      var ic = pts.length / 2 - 1; // ctrpt\n      var p0 = ic - 2; // startpt\n      var p1 = ic + 2; // endpt\n\n      bp0x = qbezierAt(pts[p0], pts[ic], pts[p1], 0.4999);\n      bp0y = qbezierAt(pts[p0 + 1], pts[ic + 1], pts[p1 + 1], 0.4999);\n      bp1x = qbezierAt(pts[p0], pts[ic], pts[p1], 0.5);\n      bp1y = qbezierAt(pts[p0 + 1], pts[ic + 1], pts[p1 + 1], 0.5);\n    }\n    dispX = bp1x - bp0x;\n    dispY = bp1y - bp0y;\n  }\n  rs.midtgtArrowAngle = getAngleFromDisp(dispX, dispY);\n  rs.midDispX = dispX;\n  rs.midDispY = dispY;\n\n  // mid source\n  //\n\n  dispX *= -1;\n  dispY *= -1;\n  if (isSegments) {\n    var pts = rs.allpts;\n    if (pts.length / 2 % 2 === 0) ; else if (!rs.isRound) {\n      var i2 = pts.length / 2 - 1;\n      var i3 = i2 + 2;\n      dispX = -(pts[i3] - pts[i2]);\n      dispY = -(pts[i3 + 1] - pts[i2 + 1]);\n    }\n  }\n  rs.midsrcArrowAngle = getAngleFromDisp(dispX, dispY);\n\n  // target\n  //\n\n  if (isSegments) {\n    dispX = endX - rs.segpts[rs.segpts.length - 2];\n    dispY = endY - rs.segpts[rs.segpts.length - 1];\n  } else if (isMultibezier || isCompound || isSelf || isBezier) {\n    var pts = rs.allpts;\n    var l = pts.length;\n    var bX = qbezierAt(pts[l - 6], pts[l - 4], pts[l - 2], 0.9);\n    var bY = qbezierAt(pts[l - 5], pts[l - 3], pts[l - 1], 0.9);\n    dispX = endX - bX;\n    dispY = endY - bY;\n  } else {\n    dispX = endX - midX;\n    dispY = endY - midY;\n  }\n  rs.tgtArrowAngle = getAngleFromDisp(dispX, dispY);\n};\nBRp$d.getArrowWidth = BRp$d.getArrowHeight = function (edgeWidth, scale) {\n  var cache = this.arrowWidthCache = this.arrowWidthCache || {};\n  var cachedVal = cache[edgeWidth + ', ' + scale];\n  if (cachedVal) {\n    return cachedVal;\n  }\n  cachedVal = Math.max(Math.pow(edgeWidth * 13.37, 0.9), 29) * scale;\n  cache[edgeWidth + ', ' + scale] = cachedVal;\n  return cachedVal;\n};\n\n/**\n * Explained by Blindman67 at https://stackoverflow.com/a/44856925/11028828\n */\n\n// Declare reused variable to avoid reallocating variables every time the function is called\nvar x,\n  y,\n  v1 = {},\n  v2 = {},\n  sinA,\n  sinA90,\n  radDirection,\n  drawDirection,\n  angle,\n  halfAngle,\n  cRadius,\n  lenOut,\n  radius,\n  limit;\nvar startX, startY, stopX, stopY;\nvar lastPoint;\n\n// convert 2 points into vector form, polar form, and normalised\nvar asVec = function asVec(p, pp, v) {\n  v.x = pp.x - p.x;\n  v.y = pp.y - p.y;\n  v.len = Math.sqrt(v.x * v.x + v.y * v.y);\n  v.nx = v.x / v.len;\n  v.ny = v.y / v.len;\n  v.ang = Math.atan2(v.ny, v.nx);\n};\nvar invertVec = function invertVec(originalV, invertedV) {\n  invertedV.x = originalV.x * -1;\n  invertedV.y = originalV.y * -1;\n  invertedV.nx = originalV.nx * -1;\n  invertedV.ny = originalV.ny * -1;\n  invertedV.ang = originalV.ang > 0 ? -(Math.PI - originalV.ang) : Math.PI + originalV.ang;\n};\nvar calcCornerArc = function calcCornerArc(previousPoint, currentPoint, nextPoint, radiusMax, isArcRadius) {\n  //-----------------------------------------\n  // Part 1\n  previousPoint !== lastPoint ? asVec(currentPoint, previousPoint, v1) : invertVec(v2, v1); // Avoid recalculating vec if it is the invert of the last one calculated\n  asVec(currentPoint, nextPoint, v2);\n  sinA = v1.nx * v2.ny - v1.ny * v2.nx;\n  sinA90 = v1.nx * v2.nx - v1.ny * -v2.ny;\n  angle = Math.asin(Math.max(-1, Math.min(1, sinA)));\n  if (Math.abs(angle) < 1e-6) {\n    x = currentPoint.x;\n    y = currentPoint.y;\n    cRadius = radius = 0;\n    return;\n  }\n  //-----------------------------------------\n  radDirection = 1;\n  drawDirection = false;\n  if (sinA90 < 0) {\n    if (angle < 0) {\n      angle = Math.PI + angle;\n    } else {\n      angle = Math.PI - angle;\n      radDirection = -1;\n      drawDirection = true;\n    }\n  } else {\n    if (angle > 0) {\n      radDirection = -1;\n      drawDirection = true;\n    }\n  }\n  if (currentPoint.radius !== undefined) {\n    radius = currentPoint.radius;\n  } else {\n    radius = radiusMax;\n  }\n  //-----------------------------------------\n  // Part 2\n  halfAngle = angle / 2;\n  //-----------------------------------------\n\n  limit = Math.min(v1.len / 2, v2.len / 2);\n  if (isArcRadius) {\n    //-----------------------------------------\n    // Part 3\n    lenOut = Math.abs(Math.cos(halfAngle) * radius / Math.sin(halfAngle));\n\n    //-----------------------------------------\n    // Special part A\n    if (lenOut > limit) {\n      lenOut = limit;\n      cRadius = Math.abs(lenOut * Math.sin(halfAngle) / Math.cos(halfAngle));\n    } else {\n      cRadius = radius;\n    }\n  } else {\n    lenOut = Math.min(limit, radius);\n    cRadius = Math.abs(lenOut * Math.sin(halfAngle) / Math.cos(halfAngle));\n  }\n  //-----------------------------------------\n\n  //-----------------------------------------\n  // Part 4\n  stopX = currentPoint.x + v2.nx * lenOut;\n  stopY = currentPoint.y + v2.ny * lenOut;\n  //-----------------------------------------\n  // Part 5\n  x = stopX - v2.ny * cRadius * radDirection;\n  y = stopY + v2.nx * cRadius * radDirection;\n  //-----------------------------------------\n  // Additional Part : calculate start point E\n  startX = currentPoint.x + v1.nx * lenOut;\n  startY = currentPoint.y + v1.ny * lenOut;\n\n  // Save last point to avoid recalculating vector when not needed\n  lastPoint = currentPoint;\n};\n\n/**\n * Draw corner provided by {@link getRoundCorner}\n *\n * @param ctx :CanvasRenderingContext2D\n * @param roundCorner {{cx:number, cy:number, radius:number, endAngle: number, startAngle: number, counterClockwise: boolean}}\n */\nfunction drawPreparedRoundCorner(ctx, roundCorner) {\n  if (roundCorner.radius === 0) ctx.lineTo(roundCorner.cx, roundCorner.cy);else ctx.arc(roundCorner.cx, roundCorner.cy, roundCorner.radius, roundCorner.startAngle, roundCorner.endAngle, roundCorner.counterClockwise);\n}\n\n/**\n * Get round corner from a point and its previous and next neighbours in a path\n *\n * @param previousPoint {{x: number, y:number, radius: number?}}\n * @param currentPoint {{x: number, y:number, radius: number?}}\n * @param nextPoint {{x: number, y:number, radius: number?}}\n * @param radiusMax :number\n * @param isArcRadius :boolean\n * @return {{\n * cx:number, cy:number, radius:number,\n * startX:number, startY:number,\n * stopX:number, stopY: number,\n * endAngle: number, startAngle: number, counterClockwise: boolean\n * }}\n */\nfunction getRoundCorner(previousPoint, currentPoint, nextPoint, radiusMax) {\n  var isArcRadius = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n  if (radiusMax === 0 || currentPoint.radius === 0) return {\n    cx: currentPoint.x,\n    cy: currentPoint.y,\n    radius: 0,\n    startX: currentPoint.x,\n    startY: currentPoint.y,\n    stopX: currentPoint.x,\n    stopY: currentPoint.y,\n    startAngle: undefined,\n    endAngle: undefined,\n    counterClockwise: undefined\n  };\n  calcCornerArc(previousPoint, currentPoint, nextPoint, radiusMax, isArcRadius);\n  return {\n    cx: x,\n    cy: y,\n    radius: cRadius,\n    startX: startX,\n    startY: startY,\n    stopX: stopX,\n    stopY: stopY,\n    startAngle: v1.ang + Math.PI / 2 * radDirection,\n    endAngle: v2.ang - Math.PI / 2 * radDirection,\n    counterClockwise: drawDirection\n  };\n}\n\nvar BRp$c = {};\nBRp$c.findMidptPtsEtc = function (edge, pairInfo) {\n  var posPts = pairInfo.posPts,\n    intersectionPts = pairInfo.intersectionPts,\n    vectorNormInverse = pairInfo.vectorNormInverse;\n  var midptPts;\n\n  // n.b. assumes all edges in bezier bundle have same endpoints specified\n  var srcManEndpt = edge.pstyle('source-endpoint');\n  var tgtManEndpt = edge.pstyle('target-endpoint');\n  var haveManualEndPts = srcManEndpt.units != null && tgtManEndpt.units != null;\n  var recalcVectorNormInverse = function recalcVectorNormInverse(x1, y1, x2, y2) {\n    var dy = y2 - y1;\n    var dx = x2 - x1;\n    var l = Math.sqrt(dx * dx + dy * dy);\n    return {\n      x: -dy / l,\n      y: dx / l\n    };\n  };\n  var edgeDistances = edge.pstyle('edge-distances').value;\n  switch (edgeDistances) {\n    case 'node-position':\n      midptPts = posPts;\n      break;\n    case 'intersection':\n      midptPts = intersectionPts;\n      break;\n    case 'endpoints':\n      {\n        if (haveManualEndPts) {\n          var _this$manualEndptToPx = this.manualEndptToPx(edge.source()[0], srcManEndpt),\n            _this$manualEndptToPx2 = _slicedToArray(_this$manualEndptToPx, 2),\n            x1 = _this$manualEndptToPx2[0],\n            y1 = _this$manualEndptToPx2[1];\n          var _this$manualEndptToPx3 = this.manualEndptToPx(edge.target()[0], tgtManEndpt),\n            _this$manualEndptToPx4 = _slicedToArray(_this$manualEndptToPx3, 2),\n            x2 = _this$manualEndptToPx4[0],\n            y2 = _this$manualEndptToPx4[1];\n          var endPts = {\n            x1: x1,\n            y1: y1,\n            x2: x2,\n            y2: y2\n          };\n          vectorNormInverse = recalcVectorNormInverse(x1, y1, x2, y2);\n          midptPts = endPts;\n        } else {\n          warn(\"Edge \".concat(edge.id(), \" has edge-distances:endpoints specified without manual endpoints specified via source-endpoint and target-endpoint.  Falling back on edge-distances:intersection (default).\"));\n          midptPts = intersectionPts; // back to default\n        }\n\n        break;\n      }\n  }\n  return {\n    midptPts: midptPts,\n    vectorNormInverse: vectorNormInverse\n  };\n};\nBRp$c.findHaystackPoints = function (edges) {\n  for (var i = 0; i < edges.length; i++) {\n    var edge = edges[i];\n    var _p = edge._private;\n    var rs = _p.rscratch;\n    if (!rs.haystack) {\n      var angle = Math.random() * 2 * Math.PI;\n      rs.source = {\n        x: Math.cos(angle),\n        y: Math.sin(angle)\n      };\n      angle = Math.random() * 2 * Math.PI;\n      rs.target = {\n        x: Math.cos(angle),\n        y: Math.sin(angle)\n      };\n    }\n    var src = _p.source;\n    var tgt = _p.target;\n    var srcPos = src.position();\n    var tgtPos = tgt.position();\n    var srcW = src.width();\n    var tgtW = tgt.width();\n    var srcH = src.height();\n    var tgtH = tgt.height();\n    var radius = edge.pstyle('haystack-radius').value;\n    var halfRadius = radius / 2; // b/c have to half width/height\n\n    rs.haystackPts = rs.allpts = [rs.source.x * srcW * halfRadius + srcPos.x, rs.source.y * srcH * halfRadius + srcPos.y, rs.target.x * tgtW * halfRadius + tgtPos.x, rs.target.y * tgtH * halfRadius + tgtPos.y];\n    rs.midX = (rs.allpts[0] + rs.allpts[2]) / 2;\n    rs.midY = (rs.allpts[1] + rs.allpts[3]) / 2;\n\n    // always override as haystack in case set to different type previously\n    rs.edgeType = 'haystack';\n    rs.haystack = true;\n    this.storeEdgeProjections(edge);\n    this.calculateArrowAngles(edge);\n    this.recalculateEdgeLabelProjections(edge);\n    this.calculateLabelAngles(edge);\n  }\n};\nBRp$c.findSegmentsPoints = function (edge, pairInfo) {\n  // Segments (multiple straight lines)\n\n  var rs = edge._private.rscratch;\n  var segmentWs = edge.pstyle('segment-weights');\n  var segmentDs = edge.pstyle('segment-distances');\n  var segmentRs = edge.pstyle('segment-radii');\n  var segmentTs = edge.pstyle('radius-type');\n  var segmentsN = Math.min(segmentWs.pfValue.length, segmentDs.pfValue.length);\n  var lastRadius = segmentRs.pfValue[segmentRs.pfValue.length - 1];\n  var lastRadiusType = segmentTs.pfValue[segmentTs.pfValue.length - 1];\n  rs.edgeType = 'segments';\n  rs.segpts = [];\n  rs.radii = [];\n  rs.isArcRadius = [];\n  for (var s = 0; s < segmentsN; s++) {\n    var w = segmentWs.pfValue[s];\n    var d = segmentDs.pfValue[s];\n    var w1 = 1 - w;\n    var w2 = w;\n    var _this$findMidptPtsEtc = this.findMidptPtsEtc(edge, pairInfo),\n      midptPts = _this$findMidptPtsEtc.midptPts,\n      vectorNormInverse = _this$findMidptPtsEtc.vectorNormInverse;\n    var adjustedMidpt = {\n      x: midptPts.x1 * w1 + midptPts.x2 * w2,\n      y: midptPts.y1 * w1 + midptPts.y2 * w2\n    };\n    rs.segpts.push(adjustedMidpt.x + vectorNormInverse.x * d, adjustedMidpt.y + vectorNormInverse.y * d);\n    rs.radii.push(segmentRs.pfValue[s] !== undefined ? segmentRs.pfValue[s] : lastRadius);\n    rs.isArcRadius.push((segmentTs.pfValue[s] !== undefined ? segmentTs.pfValue[s] : lastRadiusType) === 'arc-radius');\n  }\n};\nBRp$c.findLoopPoints = function (edge, pairInfo, i, edgeIsUnbundled) {\n  // Self-edge\n\n  var rs = edge._private.rscratch;\n  var dirCounts = pairInfo.dirCounts,\n    srcPos = pairInfo.srcPos;\n  var ctrlptDists = edge.pstyle('control-point-distances');\n  var ctrlptDist = ctrlptDists ? ctrlptDists.pfValue[0] : undefined;\n  var loopDir = edge.pstyle('loop-direction').pfValue;\n  var loopSwp = edge.pstyle('loop-sweep').pfValue;\n  var stepSize = edge.pstyle('control-point-step-size').pfValue;\n  rs.edgeType = 'self';\n  var j = i;\n  var loopDist = stepSize;\n  if (edgeIsUnbundled) {\n    j = 0;\n    loopDist = ctrlptDist;\n  }\n  var loopAngle = loopDir - Math.PI / 2;\n  var outAngle = loopAngle - loopSwp / 2;\n  var inAngle = loopAngle + loopSwp / 2;\n\n  // increase by step size for overlapping loops, keyed on direction and sweep values\n  var dc = String(loopDir + '_' + loopSwp);\n  j = dirCounts[dc] === undefined ? dirCounts[dc] = 0 : ++dirCounts[dc];\n  rs.ctrlpts = [srcPos.x + Math.cos(outAngle) * 1.4 * loopDist * (j / 3 + 1), srcPos.y + Math.sin(outAngle) * 1.4 * loopDist * (j / 3 + 1), srcPos.x + Math.cos(inAngle) * 1.4 * loopDist * (j / 3 + 1), srcPos.y + Math.sin(inAngle) * 1.4 * loopDist * (j / 3 + 1)];\n};\nBRp$c.findCompoundLoopPoints = function (edge, pairInfo, i, edgeIsUnbundled) {\n  // Compound edge\n\n  var rs = edge._private.rscratch;\n  rs.edgeType = 'compound';\n  var srcPos = pairInfo.srcPos,\n    tgtPos = pairInfo.tgtPos,\n    srcW = pairInfo.srcW,\n    srcH = pairInfo.srcH,\n    tgtW = pairInfo.tgtW,\n    tgtH = pairInfo.tgtH;\n  var stepSize = edge.pstyle('control-point-step-size').pfValue;\n  var ctrlptDists = edge.pstyle('control-point-distances');\n  var ctrlptDist = ctrlptDists ? ctrlptDists.pfValue[0] : undefined;\n  var j = i;\n  var loopDist = stepSize;\n  if (edgeIsUnbundled) {\n    j = 0;\n    loopDist = ctrlptDist;\n  }\n  var loopW = 50;\n  var loopaPos = {\n    x: srcPos.x - srcW / 2,\n    y: srcPos.y - srcH / 2\n  };\n  var loopbPos = {\n    x: tgtPos.x - tgtW / 2,\n    y: tgtPos.y - tgtH / 2\n  };\n  var loopPos = {\n    x: Math.min(loopaPos.x, loopbPos.x),\n    y: Math.min(loopaPos.y, loopbPos.y)\n  };\n\n  // avoids cases with impossible beziers\n  var minCompoundStretch = 0.5;\n  var compoundStretchA = Math.max(minCompoundStretch, Math.log(srcW * 0.01));\n  var compoundStretchB = Math.max(minCompoundStretch, Math.log(tgtW * 0.01));\n  rs.ctrlpts = [loopPos.x, loopPos.y - (1 + Math.pow(loopW, 1.12) / 100) * loopDist * (j / 3 + 1) * compoundStretchA, loopPos.x - (1 + Math.pow(loopW, 1.12) / 100) * loopDist * (j / 3 + 1) * compoundStretchB, loopPos.y];\n};\nBRp$c.findStraightEdgePoints = function (edge) {\n  // Straight edge within bundle\n\n  edge._private.rscratch.edgeType = 'straight';\n};\nBRp$c.findBezierPoints = function (edge, pairInfo, i, edgeIsUnbundled, edgeIsSwapped) {\n  var rs = edge._private.rscratch;\n  var stepSize = edge.pstyle('control-point-step-size').pfValue;\n  var ctrlptDists = edge.pstyle('control-point-distances');\n  var ctrlptWs = edge.pstyle('control-point-weights');\n  var bezierN = ctrlptDists && ctrlptWs ? Math.min(ctrlptDists.value.length, ctrlptWs.value.length) : 1;\n  var ctrlptDist = ctrlptDists ? ctrlptDists.pfValue[0] : undefined;\n  var ctrlptWeight = ctrlptWs.value[0];\n\n  // (Multi)bezier\n\n  var multi = edgeIsUnbundled;\n  rs.edgeType = multi ? 'multibezier' : 'bezier';\n  rs.ctrlpts = [];\n  for (var b = 0; b < bezierN; b++) {\n    var normctrlptDist = (0.5 - pairInfo.eles.length / 2 + i) * stepSize * (edgeIsSwapped ? -1 : 1);\n    var manctrlptDist = void 0;\n    var sign = signum(normctrlptDist);\n    if (multi) {\n      ctrlptDist = ctrlptDists ? ctrlptDists.pfValue[b] : stepSize; // fall back on step size\n      ctrlptWeight = ctrlptWs.value[b];\n    }\n    if (edgeIsUnbundled) {\n      // multi or single unbundled\n      manctrlptDist = ctrlptDist;\n    } else {\n      manctrlptDist = ctrlptDist !== undefined ? sign * ctrlptDist : undefined;\n    }\n    var distanceFromMidpoint = manctrlptDist !== undefined ? manctrlptDist : normctrlptDist;\n    var w1 = 1 - ctrlptWeight;\n    var w2 = ctrlptWeight;\n    var _this$findMidptPtsEtc2 = this.findMidptPtsEtc(edge, pairInfo),\n      midptPts = _this$findMidptPtsEtc2.midptPts,\n      vectorNormInverse = _this$findMidptPtsEtc2.vectorNormInverse;\n    var adjustedMidpt = {\n      x: midptPts.x1 * w1 + midptPts.x2 * w2,\n      y: midptPts.y1 * w1 + midptPts.y2 * w2\n    };\n    rs.ctrlpts.push(adjustedMidpt.x + vectorNormInverse.x * distanceFromMidpoint, adjustedMidpt.y + vectorNormInverse.y * distanceFromMidpoint);\n  }\n};\nBRp$c.findTaxiPoints = function (edge, pairInfo) {\n  // Taxicab geometry with two turns maximum\n\n  var rs = edge._private.rscratch;\n  rs.edgeType = 'segments';\n  var VERTICAL = 'vertical';\n  var HORIZONTAL = 'horizontal';\n  var LEFTWARD = 'leftward';\n  var RIGHTWARD = 'rightward';\n  var DOWNWARD = 'downward';\n  var UPWARD = 'upward';\n  var AUTO = 'auto';\n  var posPts = pairInfo.posPts,\n    srcW = pairInfo.srcW,\n    srcH = pairInfo.srcH,\n    tgtW = pairInfo.tgtW,\n    tgtH = pairInfo.tgtH;\n  var edgeDistances = edge.pstyle('edge-distances').value;\n  var dIncludesNodeBody = edgeDistances !== 'node-position';\n  var taxiDir = edge.pstyle('taxi-direction').value;\n  var rawTaxiDir = taxiDir; // unprocessed value\n  var taxiTurn = edge.pstyle('taxi-turn');\n  var turnIsPercent = taxiTurn.units === '%';\n  var taxiTurnPfVal = taxiTurn.pfValue;\n  var turnIsNegative = taxiTurnPfVal < 0; // i.e. from target side\n  var minD = edge.pstyle('taxi-turn-min-distance').pfValue;\n  var dw = dIncludesNodeBody ? (srcW + tgtW) / 2 : 0;\n  var dh = dIncludesNodeBody ? (srcH + tgtH) / 2 : 0;\n  var pdx = posPts.x2 - posPts.x1;\n  var pdy = posPts.y2 - posPts.y1;\n\n  // take away the effective w/h from the magnitude of the delta value\n  var subDWH = function subDWH(dxy, dwh) {\n    if (dxy > 0) {\n      return Math.max(dxy - dwh, 0);\n    } else {\n      return Math.min(dxy + dwh, 0);\n    }\n  };\n  var dx = subDWH(pdx, dw);\n  var dy = subDWH(pdy, dh);\n  var isExplicitDir = false;\n  if (rawTaxiDir === AUTO) {\n    taxiDir = Math.abs(dx) > Math.abs(dy) ? HORIZONTAL : VERTICAL;\n  } else if (rawTaxiDir === UPWARD || rawTaxiDir === DOWNWARD) {\n    taxiDir = VERTICAL;\n    isExplicitDir = true;\n  } else if (rawTaxiDir === LEFTWARD || rawTaxiDir === RIGHTWARD) {\n    taxiDir = HORIZONTAL;\n    isExplicitDir = true;\n  }\n  var isVert = taxiDir === VERTICAL;\n  var l = isVert ? dy : dx;\n  var pl = isVert ? pdy : pdx;\n  var sgnL = signum(pl);\n  var forcedDir = false;\n  if (!(isExplicitDir && (turnIsPercent || turnIsNegative)) // forcing in this case would cause weird growing in the opposite direction\n  && (rawTaxiDir === DOWNWARD && pl < 0 || rawTaxiDir === UPWARD && pl > 0 || rawTaxiDir === LEFTWARD && pl > 0 || rawTaxiDir === RIGHTWARD && pl < 0)) {\n    sgnL *= -1;\n    l = sgnL * Math.abs(l);\n    forcedDir = true;\n  }\n  var d;\n  if (turnIsPercent) {\n    var p = taxiTurnPfVal < 0 ? 1 + taxiTurnPfVal : taxiTurnPfVal;\n    d = p * l;\n  } else {\n    var k = taxiTurnPfVal < 0 ? l : 0;\n    d = k + taxiTurnPfVal * sgnL;\n  }\n  var getIsTooClose = function getIsTooClose(d) {\n    return Math.abs(d) < minD || Math.abs(d) >= Math.abs(l);\n  };\n  var isTooCloseSrc = getIsTooClose(d);\n  var isTooCloseTgt = getIsTooClose(Math.abs(l) - Math.abs(d));\n  var isTooClose = isTooCloseSrc || isTooCloseTgt;\n  if (isTooClose && !forcedDir) {\n    // non-ideal routing\n    if (isVert) {\n      // vertical fallbacks\n      var lShapeInsideSrc = Math.abs(pl) <= srcH / 2;\n      var lShapeInsideTgt = Math.abs(pdx) <= tgtW / 2;\n      if (lShapeInsideSrc) {\n        // horizontal Z-shape (direction not respected)\n        var x = (posPts.x1 + posPts.x2) / 2;\n        var y1 = posPts.y1,\n          y2 = posPts.y2;\n        rs.segpts = [x, y1, x, y2];\n      } else if (lShapeInsideTgt) {\n        // vertical Z-shape (distance not respected)\n        var y = (posPts.y1 + posPts.y2) / 2;\n        var x1 = posPts.x1,\n          x2 = posPts.x2;\n        rs.segpts = [x1, y, x2, y];\n      } else {\n        // L-shape fallback (turn distance not respected, but works well with tree siblings)\n        rs.segpts = [posPts.x1, posPts.y2];\n      }\n    } else {\n      // horizontal fallbacks\n      var _lShapeInsideSrc = Math.abs(pl) <= srcW / 2;\n      var _lShapeInsideTgt = Math.abs(pdy) <= tgtH / 2;\n      if (_lShapeInsideSrc) {\n        // vertical Z-shape (direction not respected)\n        var _y = (posPts.y1 + posPts.y2) / 2;\n        var _x = posPts.x1,\n          _x2 = posPts.x2;\n        rs.segpts = [_x, _y, _x2, _y];\n      } else if (_lShapeInsideTgt) {\n        // horizontal Z-shape (turn distance not respected)\n        var _x3 = (posPts.x1 + posPts.x2) / 2;\n        var _y2 = posPts.y1,\n          _y3 = posPts.y2;\n        rs.segpts = [_x3, _y2, _x3, _y3];\n      } else {\n        // L-shape (turn distance not respected, but works well for tree siblings)\n        rs.segpts = [posPts.x2, posPts.y1];\n      }\n    }\n  } else {\n    // ideal routing\n    if (isVert) {\n      var _y4 = posPts.y1 + d + (dIncludesNodeBody ? srcH / 2 * sgnL : 0);\n      var _x4 = posPts.x1,\n        _x5 = posPts.x2;\n      rs.segpts = [_x4, _y4, _x5, _y4];\n    } else {\n      // horizontal\n      var _x6 = posPts.x1 + d + (dIncludesNodeBody ? srcW / 2 * sgnL : 0);\n      var _y5 = posPts.y1,\n        _y6 = posPts.y2;\n      rs.segpts = [_x6, _y5, _x6, _y6];\n    }\n  }\n  if (rs.isRound) {\n    var radius = edge.pstyle('taxi-radius').value;\n    var isArcRadius = edge.pstyle('radius-type').value[0] === 'arc-radius';\n    rs.radii = new Array(rs.segpts.length / 2).fill(radius);\n    rs.isArcRadius = new Array(rs.segpts.length / 2).fill(isArcRadius);\n  }\n};\nBRp$c.tryToCorrectInvalidPoints = function (edge, pairInfo) {\n  var rs = edge._private.rscratch;\n\n  // can only correct beziers for now...\n  if (rs.edgeType === 'bezier') {\n    var srcPos = pairInfo.srcPos,\n      tgtPos = pairInfo.tgtPos,\n      srcW = pairInfo.srcW,\n      srcH = pairInfo.srcH,\n      tgtW = pairInfo.tgtW,\n      tgtH = pairInfo.tgtH,\n      srcShape = pairInfo.srcShape,\n      tgtShape = pairInfo.tgtShape,\n      srcCornerRadius = pairInfo.srcCornerRadius,\n      tgtCornerRadius = pairInfo.tgtCornerRadius,\n      srcRs = pairInfo.srcRs,\n      tgtRs = pairInfo.tgtRs;\n    var badStart = !number$1(rs.startX) || !number$1(rs.startY);\n    var badAStart = !number$1(rs.arrowStartX) || !number$1(rs.arrowStartY);\n    var badEnd = !number$1(rs.endX) || !number$1(rs.endY);\n    var badAEnd = !number$1(rs.arrowEndX) || !number$1(rs.arrowEndY);\n    var minCpADistFactor = 3;\n    var arrowW = this.getArrowWidth(edge.pstyle('width').pfValue, edge.pstyle('arrow-scale').value) * this.arrowShapeWidth;\n    var minCpADist = minCpADistFactor * arrowW;\n    var startACpDist = dist({\n      x: rs.ctrlpts[0],\n      y: rs.ctrlpts[1]\n    }, {\n      x: rs.startX,\n      y: rs.startY\n    });\n    var closeStartACp = startACpDist < minCpADist;\n    var endACpDist = dist({\n      x: rs.ctrlpts[0],\n      y: rs.ctrlpts[1]\n    }, {\n      x: rs.endX,\n      y: rs.endY\n    });\n    var closeEndACp = endACpDist < minCpADist;\n    var overlapping = false;\n    if (badStart || badAStart || closeStartACp) {\n      overlapping = true;\n\n      // project control point along line from src centre to outside the src shape\n      // (otherwise intersection will yield nothing)\n      var cpD = {\n        // delta\n        x: rs.ctrlpts[0] - srcPos.x,\n        y: rs.ctrlpts[1] - srcPos.y\n      };\n      var cpL = Math.sqrt(cpD.x * cpD.x + cpD.y * cpD.y); // length of line\n      var cpM = {\n        // normalised delta\n        x: cpD.x / cpL,\n        y: cpD.y / cpL\n      };\n      var radius = Math.max(srcW, srcH);\n      var cpProj = {\n        // *2 radius guarantees outside shape\n        x: rs.ctrlpts[0] + cpM.x * 2 * radius,\n        y: rs.ctrlpts[1] + cpM.y * 2 * radius\n      };\n      var srcCtrlPtIntn = srcShape.intersectLine(srcPos.x, srcPos.y, srcW, srcH, cpProj.x, cpProj.y, 0, srcCornerRadius, srcRs);\n      if (closeStartACp) {\n        rs.ctrlpts[0] = rs.ctrlpts[0] + cpM.x * (minCpADist - startACpDist);\n        rs.ctrlpts[1] = rs.ctrlpts[1] + cpM.y * (minCpADist - startACpDist);\n      } else {\n        rs.ctrlpts[0] = srcCtrlPtIntn[0] + cpM.x * minCpADist;\n        rs.ctrlpts[1] = srcCtrlPtIntn[1] + cpM.y * minCpADist;\n      }\n    }\n    if (badEnd || badAEnd || closeEndACp) {\n      overlapping = true;\n\n      // project control point along line from tgt centre to outside the tgt shape\n      // (otherwise intersection will yield nothing)\n      var _cpD = {\n        // delta\n        x: rs.ctrlpts[0] - tgtPos.x,\n        y: rs.ctrlpts[1] - tgtPos.y\n      };\n      var _cpL = Math.sqrt(_cpD.x * _cpD.x + _cpD.y * _cpD.y); // length of line\n      var _cpM = {\n        // normalised delta\n        x: _cpD.x / _cpL,\n        y: _cpD.y / _cpL\n      };\n      var _radius = Math.max(srcW, srcH);\n      var _cpProj = {\n        // *2 radius guarantees outside shape\n        x: rs.ctrlpts[0] + _cpM.x * 2 * _radius,\n        y: rs.ctrlpts[1] + _cpM.y * 2 * _radius\n      };\n      var tgtCtrlPtIntn = tgtShape.intersectLine(tgtPos.x, tgtPos.y, tgtW, tgtH, _cpProj.x, _cpProj.y, 0, tgtCornerRadius, tgtRs);\n      if (closeEndACp) {\n        rs.ctrlpts[0] = rs.ctrlpts[0] + _cpM.x * (minCpADist - endACpDist);\n        rs.ctrlpts[1] = rs.ctrlpts[1] + _cpM.y * (minCpADist - endACpDist);\n      } else {\n        rs.ctrlpts[0] = tgtCtrlPtIntn[0] + _cpM.x * minCpADist;\n        rs.ctrlpts[1] = tgtCtrlPtIntn[1] + _cpM.y * minCpADist;\n      }\n    }\n    if (overlapping) {\n      // recalc endpts\n      this.findEndpoints(edge);\n    }\n  }\n};\nBRp$c.storeAllpts = function (edge) {\n  var rs = edge._private.rscratch;\n  if (rs.edgeType === 'multibezier' || rs.edgeType === 'bezier' || rs.edgeType === 'self' || rs.edgeType === 'compound') {\n    rs.allpts = [];\n    rs.allpts.push(rs.startX, rs.startY);\n    for (var b = 0; b + 1 < rs.ctrlpts.length; b += 2) {\n      // ctrl pt itself\n      rs.allpts.push(rs.ctrlpts[b], rs.ctrlpts[b + 1]);\n\n      // the midpt between ctrlpts as intermediate destination pts\n      if (b + 3 < rs.ctrlpts.length) {\n        rs.allpts.push((rs.ctrlpts[b] + rs.ctrlpts[b + 2]) / 2, (rs.ctrlpts[b + 1] + rs.ctrlpts[b + 3]) / 2);\n      }\n    }\n    rs.allpts.push(rs.endX, rs.endY);\n    var m, mt;\n    if (rs.ctrlpts.length / 2 % 2 === 0) {\n      m = rs.allpts.length / 2 - 1;\n      rs.midX = rs.allpts[m];\n      rs.midY = rs.allpts[m + 1];\n    } else {\n      m = rs.allpts.length / 2 - 3;\n      mt = 0.5;\n      rs.midX = qbezierAt(rs.allpts[m], rs.allpts[m + 2], rs.allpts[m + 4], mt);\n      rs.midY = qbezierAt(rs.allpts[m + 1], rs.allpts[m + 3], rs.allpts[m + 5], mt);\n    }\n  } else if (rs.edgeType === 'straight') {\n    // need to calc these after endpts\n    rs.allpts = [rs.startX, rs.startY, rs.endX, rs.endY];\n\n    // default midpt for labels etc\n    rs.midX = (rs.startX + rs.endX + rs.arrowStartX + rs.arrowEndX) / 4;\n    rs.midY = (rs.startY + rs.endY + rs.arrowStartY + rs.arrowEndY) / 4;\n  } else if (rs.edgeType === 'segments') {\n    rs.allpts = [];\n    rs.allpts.push(rs.startX, rs.startY);\n    rs.allpts.push.apply(rs.allpts, rs.segpts);\n    rs.allpts.push(rs.endX, rs.endY);\n    if (rs.isRound) {\n      rs.roundCorners = [];\n      for (var i = 2; i + 3 < rs.allpts.length; i += 2) {\n        var radius = rs.radii[i / 2 - 1];\n        var isArcRadius = rs.isArcRadius[i / 2 - 1];\n        rs.roundCorners.push(getRoundCorner({\n          x: rs.allpts[i - 2],\n          y: rs.allpts[i - 1]\n        }, {\n          x: rs.allpts[i],\n          y: rs.allpts[i + 1],\n          radius: radius\n        }, {\n          x: rs.allpts[i + 2],\n          y: rs.allpts[i + 3]\n        }, radius, isArcRadius));\n      }\n    }\n    if (rs.segpts.length % 4 === 0) {\n      var i2 = rs.segpts.length / 2;\n      var i1 = i2 - 2;\n      rs.midX = (rs.segpts[i1] + rs.segpts[i2]) / 2;\n      rs.midY = (rs.segpts[i1 + 1] + rs.segpts[i2 + 1]) / 2;\n    } else {\n      var _i = rs.segpts.length / 2 - 1;\n      if (!rs.isRound) {\n        rs.midX = rs.segpts[_i];\n        rs.midY = rs.segpts[_i + 1];\n      } else {\n        var point = {\n          x: rs.segpts[_i],\n          y: rs.segpts[_i + 1]\n        };\n        var corner = rs.roundCorners[_i / 2];\n        var v = [point.x - corner.cx, point.y - corner.cy];\n        var factor = corner.radius / Math.sqrt(Math.pow(v[0], 2) + Math.pow(v[1], 2));\n        v = v.map(function (c) {\n          return c * factor;\n        });\n        rs.midX = corner.cx + v[0];\n        rs.midY = corner.cy + v[1];\n        rs.midVector = v;\n      }\n    }\n  }\n};\nBRp$c.checkForInvalidEdgeWarning = function (edge) {\n  var rs = edge[0]._private.rscratch;\n  if (rs.nodesOverlap || number$1(rs.startX) && number$1(rs.startY) && number$1(rs.endX) && number$1(rs.endY)) {\n    rs.loggedErr = false;\n  } else {\n    if (!rs.loggedErr) {\n      rs.loggedErr = true;\n      warn('Edge `' + edge.id() + '` has invalid endpoints and so it is impossible to draw.  Adjust your edge style (e.g. control points) accordingly or use an alternative edge type.  This is expected behaviour when the source node and the target node overlap.');\n    }\n  }\n};\nBRp$c.findEdgeControlPoints = function (edges) {\n  var _this = this;\n  if (!edges || edges.length === 0) {\n    return;\n  }\n  var r = this;\n  var cy = r.cy;\n  var hasCompounds = cy.hasCompoundNodes();\n  var hashTable = {\n    map: new Map$2(),\n    get: function get(pairId) {\n      var map2 = this.map.get(pairId[0]);\n      if (map2 != null) {\n        return map2.get(pairId[1]);\n      } else {\n        return null;\n      }\n    },\n    set: function set(pairId, val) {\n      var map2 = this.map.get(pairId[0]);\n      if (map2 == null) {\n        map2 = new Map$2();\n        this.map.set(pairId[0], map2);\n      }\n      map2.set(pairId[1], val);\n    }\n  };\n  var pairIds = [];\n  var haystackEdges = [];\n\n  // create a table of edge (src, tgt) => list of edges between them\n  for (var i = 0; i < edges.length; i++) {\n    var edge = edges[i];\n    var _p = edge._private;\n    var curveStyle = edge.pstyle('curve-style').value;\n\n    // ignore edges who are not to be displayed\n    // they shouldn't take up space\n    if (edge.removed() || !edge.takesUpSpace()) {\n      continue;\n    }\n    if (curveStyle === 'haystack') {\n      haystackEdges.push(edge);\n      continue;\n    }\n    var edgeIsUnbundled = curveStyle === 'unbundled-bezier' || curveStyle.endsWith('segments') || curveStyle === 'straight' || curveStyle === 'straight-triangle' || curveStyle.endsWith('taxi');\n    var edgeIsBezier = curveStyle === 'unbundled-bezier' || curveStyle === 'bezier';\n    var src = _p.source;\n    var tgt = _p.target;\n    var srcIndex = src.poolIndex();\n    var tgtIndex = tgt.poolIndex();\n    var pairId = [srcIndex, tgtIndex].sort();\n    var tableEntry = hashTable.get(pairId);\n    if (tableEntry == null) {\n      tableEntry = {\n        eles: []\n      };\n      hashTable.set(pairId, tableEntry);\n      pairIds.push(pairId);\n    }\n    tableEntry.eles.push(edge);\n    if (edgeIsUnbundled) {\n      tableEntry.hasUnbundled = true;\n    }\n    if (edgeIsBezier) {\n      tableEntry.hasBezier = true;\n    }\n  }\n\n  // for each pair (src, tgt), create the ctrl pts\n  // Nested for loop is OK; total number of iterations for both loops = edgeCount\n  var _loop = function _loop(p) {\n    var pairId = pairIds[p];\n    var pairInfo = hashTable.get(pairId);\n    var swappedpairInfo = void 0;\n    if (!pairInfo.hasUnbundled) {\n      var pllEdges = pairInfo.eles[0].parallelEdges().filter(function (e) {\n        return e.isBundledBezier();\n      });\n      clearArray(pairInfo.eles);\n      pllEdges.forEach(function (edge) {\n        return pairInfo.eles.push(edge);\n      });\n\n      // for each pair id, the edges should be sorted by index\n      pairInfo.eles.sort(function (edge1, edge2) {\n        return edge1.poolIndex() - edge2.poolIndex();\n      });\n    }\n    var firstEdge = pairInfo.eles[0];\n    var src = firstEdge.source();\n    var tgt = firstEdge.target();\n\n    // make sure src/tgt distinction is consistent w.r.t. pairId\n    if (src.poolIndex() > tgt.poolIndex()) {\n      var temp = src;\n      src = tgt;\n      tgt = temp;\n    }\n    var srcPos = pairInfo.srcPos = src.position();\n    var tgtPos = pairInfo.tgtPos = tgt.position();\n    var srcW = pairInfo.srcW = src.outerWidth();\n    var srcH = pairInfo.srcH = src.outerHeight();\n    var tgtW = pairInfo.tgtW = tgt.outerWidth();\n    var tgtH = pairInfo.tgtH = tgt.outerHeight();\n    var srcShape = pairInfo.srcShape = r.nodeShapes[_this.getNodeShape(src)];\n    var tgtShape = pairInfo.tgtShape = r.nodeShapes[_this.getNodeShape(tgt)];\n    var srcCornerRadius = pairInfo.srcCornerRadius = src.pstyle('corner-radius').value === 'auto' ? 'auto' : src.pstyle('corner-radius').pfValue;\n    var tgtCornerRadius = pairInfo.tgtCornerRadius = tgt.pstyle('corner-radius').value === 'auto' ? 'auto' : tgt.pstyle('corner-radius').pfValue;\n    var tgtRs = pairInfo.tgtRs = tgt._private.rscratch;\n    var srcRs = pairInfo.srcRs = src._private.rscratch;\n    pairInfo.dirCounts = {\n      'north': 0,\n      'west': 0,\n      'south': 0,\n      'east': 0,\n      'northwest': 0,\n      'southwest': 0,\n      'northeast': 0,\n      'southeast': 0\n    };\n    for (var _i2 = 0; _i2 < pairInfo.eles.length; _i2++) {\n      var _edge = pairInfo.eles[_i2];\n      var rs = _edge[0]._private.rscratch;\n      var _curveStyle = _edge.pstyle('curve-style').value;\n      var _edgeIsUnbundled = _curveStyle === 'unbundled-bezier' || _curveStyle.endsWith('segments') || _curveStyle.endsWith('taxi');\n\n      // whether the normalised pair order is the reverse of the edge's src-tgt order\n      var edgeIsSwapped = !src.same(_edge.source());\n      if (!pairInfo.calculatedIntersection && src !== tgt && (pairInfo.hasBezier || pairInfo.hasUnbundled)) {\n        pairInfo.calculatedIntersection = true;\n\n        // pt outside src shape to calc distance/displacement from src to tgt\n        var srcOutside = srcShape.intersectLine(srcPos.x, srcPos.y, srcW, srcH, tgtPos.x, tgtPos.y, 0, srcCornerRadius, srcRs);\n        var srcIntn = pairInfo.srcIntn = srcOutside;\n\n        // pt outside tgt shape to calc distance/displacement from src to tgt\n        var tgtOutside = tgtShape.intersectLine(tgtPos.x, tgtPos.y, tgtW, tgtH, srcPos.x, srcPos.y, 0, tgtCornerRadius, tgtRs);\n        var tgtIntn = pairInfo.tgtIntn = tgtOutside;\n        var intersectionPts = pairInfo.intersectionPts = {\n          x1: srcOutside[0],\n          x2: tgtOutside[0],\n          y1: srcOutside[1],\n          y2: tgtOutside[1]\n        };\n        var posPts = pairInfo.posPts = {\n          x1: srcPos.x,\n          x2: tgtPos.x,\n          y1: srcPos.y,\n          y2: tgtPos.y\n        };\n        var dy = tgtOutside[1] - srcOutside[1];\n        var dx = tgtOutside[0] - srcOutside[0];\n        var l = Math.sqrt(dx * dx + dy * dy);\n        var vector = pairInfo.vector = {\n          x: dx,\n          y: dy\n        };\n        var vectorNorm = pairInfo.vectorNorm = {\n          x: vector.x / l,\n          y: vector.y / l\n        };\n        var vectorNormInverse = {\n          x: -vectorNorm.y,\n          y: vectorNorm.x\n        };\n\n        // if node shapes overlap, then no ctrl pts to draw\n        pairInfo.nodesOverlap = !number$1(l) || tgtShape.checkPoint(srcOutside[0], srcOutside[1], 0, tgtW, tgtH, tgtPos.x, tgtPos.y, tgtCornerRadius, tgtRs) || srcShape.checkPoint(tgtOutside[0], tgtOutside[1], 0, srcW, srcH, srcPos.x, srcPos.y, srcCornerRadius, srcRs);\n        pairInfo.vectorNormInverse = vectorNormInverse;\n        swappedpairInfo = {\n          nodesOverlap: pairInfo.nodesOverlap,\n          dirCounts: pairInfo.dirCounts,\n          calculatedIntersection: true,\n          hasBezier: pairInfo.hasBezier,\n          hasUnbundled: pairInfo.hasUnbundled,\n          eles: pairInfo.eles,\n          srcPos: tgtPos,\n          srcRs: tgtRs,\n          tgtPos: srcPos,\n          tgtRs: srcRs,\n          srcW: tgtW,\n          srcH: tgtH,\n          tgtW: srcW,\n          tgtH: srcH,\n          srcIntn: tgtIntn,\n          tgtIntn: srcIntn,\n          srcShape: tgtShape,\n          tgtShape: srcShape,\n          posPts: {\n            x1: posPts.x2,\n            y1: posPts.y2,\n            x2: posPts.x1,\n            y2: posPts.y1\n          },\n          intersectionPts: {\n            x1: intersectionPts.x2,\n            y1: intersectionPts.y2,\n            x2: intersectionPts.x1,\n            y2: intersectionPts.y1\n          },\n          vector: {\n            x: -vector.x,\n            y: -vector.y\n          },\n          vectorNorm: {\n            x: -vectorNorm.x,\n            y: -vectorNorm.y\n          },\n          vectorNormInverse: {\n            x: -vectorNormInverse.x,\n            y: -vectorNormInverse.y\n          }\n        };\n      }\n      var passedPairInfo = edgeIsSwapped ? swappedpairInfo : pairInfo;\n      rs.nodesOverlap = passedPairInfo.nodesOverlap;\n      rs.srcIntn = passedPairInfo.srcIntn;\n      rs.tgtIntn = passedPairInfo.tgtIntn;\n      rs.isRound = _curveStyle.startsWith('round');\n      if (hasCompounds && (src.isParent() || src.isChild() || tgt.isParent() || tgt.isChild()) && (src.parents().anySame(tgt) || tgt.parents().anySame(src) || src.same(tgt) && src.isParent())) {\n        _this.findCompoundLoopPoints(_edge, passedPairInfo, _i2, _edgeIsUnbundled);\n      } else if (src === tgt) {\n        _this.findLoopPoints(_edge, passedPairInfo, _i2, _edgeIsUnbundled);\n      } else if (_curveStyle.endsWith('segments')) {\n        _this.findSegmentsPoints(_edge, passedPairInfo);\n      } else if (_curveStyle.endsWith('taxi')) {\n        _this.findTaxiPoints(_edge, passedPairInfo);\n      } else if (_curveStyle === 'straight' || !_edgeIsUnbundled && pairInfo.eles.length % 2 === 1 && _i2 === Math.floor(pairInfo.eles.length / 2)) {\n        _this.findStraightEdgePoints(_edge);\n      } else {\n        _this.findBezierPoints(_edge, passedPairInfo, _i2, _edgeIsUnbundled, edgeIsSwapped);\n      }\n      _this.findEndpoints(_edge);\n      _this.tryToCorrectInvalidPoints(_edge, passedPairInfo);\n      _this.checkForInvalidEdgeWarning(_edge);\n      _this.storeAllpts(_edge);\n      _this.storeEdgeProjections(_edge);\n      _this.calculateArrowAngles(_edge);\n      _this.recalculateEdgeLabelProjections(_edge);\n      _this.calculateLabelAngles(_edge);\n    } // for pair edges\n  };\n  for (var p = 0; p < pairIds.length; p++) {\n    _loop(p);\n  } // for pair ids\n\n  // haystacks avoid the expense of pairInfo stuff (intersections etc.)\n  this.findHaystackPoints(haystackEdges);\n};\nfunction getPts(pts) {\n  var retPts = [];\n  if (pts == null) {\n    return;\n  }\n  for (var i = 0; i < pts.length; i += 2) {\n    var x = pts[i];\n    var y = pts[i + 1];\n    retPts.push({\n      x: x,\n      y: y\n    });\n  }\n  return retPts;\n}\nBRp$c.getSegmentPoints = function (edge) {\n  var rs = edge[0]._private.rscratch;\n  this.recalculateRenderedStyle(edge);\n  var type = rs.edgeType;\n  if (type === 'segments') {\n    return getPts(rs.segpts);\n  }\n};\nBRp$c.getControlPoints = function (edge) {\n  var rs = edge[0]._private.rscratch;\n  this.recalculateRenderedStyle(edge);\n  var type = rs.edgeType;\n  if (type === 'bezier' || type === 'multibezier' || type === 'self' || type === 'compound') {\n    return getPts(rs.ctrlpts);\n  }\n};\nBRp$c.getEdgeMidpoint = function (edge) {\n  var rs = edge[0]._private.rscratch;\n  this.recalculateRenderedStyle(edge);\n  return {\n    x: rs.midX,\n    y: rs.midY\n  };\n};\n\nvar BRp$b = {};\nBRp$b.manualEndptToPx = function (node, prop) {\n  var r = this;\n  var npos = node.position();\n  var w = node.outerWidth();\n  var h = node.outerHeight();\n  var rs = node._private.rscratch;\n  if (prop.value.length === 2) {\n    var p = [prop.pfValue[0], prop.pfValue[1]];\n    if (prop.units[0] === '%') {\n      p[0] = p[0] * w;\n    }\n    if (prop.units[1] === '%') {\n      p[1] = p[1] * h;\n    }\n    p[0] += npos.x;\n    p[1] += npos.y;\n    return p;\n  } else {\n    var angle = prop.pfValue[0];\n    angle = -Math.PI / 2 + angle; // start at 12 o'clock\n\n    var l = 2 * Math.max(w, h);\n    var _p = [npos.x + Math.cos(angle) * l, npos.y + Math.sin(angle) * l];\n    return r.nodeShapes[this.getNodeShape(node)].intersectLine(npos.x, npos.y, w, h, _p[0], _p[1], 0, node.pstyle('corner-radius').value === 'auto' ? 'auto' : node.pstyle('corner-radius').pfValue, rs);\n  }\n};\nBRp$b.findEndpoints = function (edge) {\n  var r = this;\n  var intersect;\n  var source = edge.source()[0];\n  var target = edge.target()[0];\n  var srcPos = source.position();\n  var tgtPos = target.position();\n  var tgtArShape = edge.pstyle('target-arrow-shape').value;\n  var srcArShape = edge.pstyle('source-arrow-shape').value;\n  var tgtDist = edge.pstyle('target-distance-from-node').pfValue;\n  var srcDist = edge.pstyle('source-distance-from-node').pfValue;\n  var srcRs = source._private.rscratch;\n  var tgtRs = target._private.rscratch;\n  var curveStyle = edge.pstyle('curve-style').value;\n  var rs = edge._private.rscratch;\n  var et = rs.edgeType;\n  var taxi = curveStyle === 'taxi';\n  var self = et === 'self' || et === 'compound';\n  var bezier = et === 'bezier' || et === 'multibezier' || self;\n  var multi = et !== 'bezier';\n  var lines = et === 'straight' || et === 'segments';\n  var segments = et === 'segments';\n  var hasEndpts = bezier || multi || lines;\n  var overrideEndpts = self || taxi;\n  var srcManEndpt = edge.pstyle('source-endpoint');\n  var srcManEndptVal = overrideEndpts ? 'outside-to-node' : srcManEndpt.value;\n  var srcCornerRadius = source.pstyle('corner-radius').value === 'auto' ? 'auto' : source.pstyle('corner-radius').pfValue;\n  var tgtManEndpt = edge.pstyle('target-endpoint');\n  var tgtManEndptVal = overrideEndpts ? 'outside-to-node' : tgtManEndpt.value;\n  var tgtCornerRadius = target.pstyle('corner-radius').value === 'auto' ? 'auto' : target.pstyle('corner-radius').pfValue;\n  rs.srcManEndpt = srcManEndpt;\n  rs.tgtManEndpt = tgtManEndpt;\n  var p1; // last known point of edge on target side\n  var p2; // last known point of edge on source side\n\n  var p1_i; // point to intersect with target shape\n  var p2_i; // point to intersect with source shape\n\n  if (bezier) {\n    var cpStart = [rs.ctrlpts[0], rs.ctrlpts[1]];\n    var cpEnd = multi ? [rs.ctrlpts[rs.ctrlpts.length - 2], rs.ctrlpts[rs.ctrlpts.length - 1]] : cpStart;\n    p1 = cpEnd;\n    p2 = cpStart;\n  } else if (lines) {\n    var srcArrowFromPt = !segments ? [tgtPos.x, tgtPos.y] : rs.segpts.slice(0, 2);\n    var tgtArrowFromPt = !segments ? [srcPos.x, srcPos.y] : rs.segpts.slice(rs.segpts.length - 2);\n    p1 = tgtArrowFromPt;\n    p2 = srcArrowFromPt;\n  }\n  if (tgtManEndptVal === 'inside-to-node') {\n    intersect = [tgtPos.x, tgtPos.y];\n  } else if (tgtManEndpt.units) {\n    intersect = this.manualEndptToPx(target, tgtManEndpt);\n  } else if (tgtManEndptVal === 'outside-to-line') {\n    intersect = rs.tgtIntn; // use cached value from ctrlpt calc\n  } else {\n    if (tgtManEndptVal === 'outside-to-node' || tgtManEndptVal === 'outside-to-node-or-label') {\n      p1_i = p1;\n    } else if (tgtManEndptVal === 'outside-to-line' || tgtManEndptVal === 'outside-to-line-or-label') {\n      p1_i = [srcPos.x, srcPos.y];\n    }\n    intersect = r.nodeShapes[this.getNodeShape(target)].intersectLine(tgtPos.x, tgtPos.y, target.outerWidth(), target.outerHeight(), p1_i[0], p1_i[1], 0, tgtCornerRadius, tgtRs);\n    if (tgtManEndptVal === 'outside-to-node-or-label' || tgtManEndptVal === 'outside-to-line-or-label') {\n      var trs = target._private.rscratch;\n      var lw = trs.labelWidth;\n      var lh = trs.labelHeight;\n      var lx = trs.labelX;\n      var ly = trs.labelY;\n      var lw2 = lw / 2;\n      var lh2 = lh / 2;\n      var va = target.pstyle('text-valign').value;\n      if (va === 'top') {\n        ly -= lh2;\n      } else if (va === 'bottom') {\n        ly += lh2;\n      }\n      var ha = target.pstyle('text-halign').value;\n      if (ha === 'left') {\n        lx -= lw2;\n      } else if (ha === 'right') {\n        lx += lw2;\n      }\n      var labelIntersect = polygonIntersectLine(p1_i[0], p1_i[1], [lx - lw2, ly - lh2, lx + lw2, ly - lh2, lx + lw2, ly + lh2, lx - lw2, ly + lh2], tgtPos.x, tgtPos.y);\n      if (labelIntersect.length > 0) {\n        var refPt = srcPos;\n        var intSqdist = sqdist(refPt, array2point(intersect));\n        var labIntSqdist = sqdist(refPt, array2point(labelIntersect));\n        var minSqDist = intSqdist;\n        if (labIntSqdist < intSqdist) {\n          intersect = labelIntersect;\n          minSqDist = labIntSqdist;\n        }\n        if (labelIntersect.length > 2) {\n          var labInt2SqDist = sqdist(refPt, {\n            x: labelIntersect[2],\n            y: labelIntersect[3]\n          });\n          if (labInt2SqDist < minSqDist) {\n            intersect = [labelIntersect[2], labelIntersect[3]];\n          }\n        }\n      }\n    }\n  }\n  var arrowEnd = shortenIntersection(intersect, p1, r.arrowShapes[tgtArShape].spacing(edge) + tgtDist);\n  var edgeEnd = shortenIntersection(intersect, p1, r.arrowShapes[tgtArShape].gap(edge) + tgtDist);\n  rs.endX = edgeEnd[0];\n  rs.endY = edgeEnd[1];\n  rs.arrowEndX = arrowEnd[0];\n  rs.arrowEndY = arrowEnd[1];\n  if (srcManEndptVal === 'inside-to-node') {\n    intersect = [srcPos.x, srcPos.y];\n  } else if (srcManEndpt.units) {\n    intersect = this.manualEndptToPx(source, srcManEndpt);\n  } else if (srcManEndptVal === 'outside-to-line') {\n    intersect = rs.srcIntn; // use cached value from ctrlpt calc\n  } else {\n    if (srcManEndptVal === 'outside-to-node' || srcManEndptVal === 'outside-to-node-or-label') {\n      p2_i = p2;\n    } else if (srcManEndptVal === 'outside-to-line' || srcManEndptVal === 'outside-to-line-or-label') {\n      p2_i = [tgtPos.x, tgtPos.y];\n    }\n    intersect = r.nodeShapes[this.getNodeShape(source)].intersectLine(srcPos.x, srcPos.y, source.outerWidth(), source.outerHeight(), p2_i[0], p2_i[1], 0, srcCornerRadius, srcRs);\n    if (srcManEndptVal === 'outside-to-node-or-label' || srcManEndptVal === 'outside-to-line-or-label') {\n      var srs = source._private.rscratch;\n      var _lw = srs.labelWidth;\n      var _lh = srs.labelHeight;\n      var _lx = srs.labelX;\n      var _ly = srs.labelY;\n      var _lw2 = _lw / 2;\n      var _lh2 = _lh / 2;\n      var _va = source.pstyle('text-valign').value;\n      if (_va === 'top') {\n        _ly -= _lh2;\n      } else if (_va === 'bottom') {\n        _ly += _lh2;\n      }\n      var _ha = source.pstyle('text-halign').value;\n      if (_ha === 'left') {\n        _lx -= _lw2;\n      } else if (_ha === 'right') {\n        _lx += _lw2;\n      }\n      var _labelIntersect = polygonIntersectLine(p2_i[0], p2_i[1], [_lx - _lw2, _ly - _lh2, _lx + _lw2, _ly - _lh2, _lx + _lw2, _ly + _lh2, _lx - _lw2, _ly + _lh2], srcPos.x, srcPos.y);\n      if (_labelIntersect.length > 0) {\n        var _refPt = tgtPos;\n        var _intSqdist = sqdist(_refPt, array2point(intersect));\n        var _labIntSqdist = sqdist(_refPt, array2point(_labelIntersect));\n        var _minSqDist = _intSqdist;\n        if (_labIntSqdist < _intSqdist) {\n          intersect = [_labelIntersect[0], _labelIntersect[1]];\n          _minSqDist = _labIntSqdist;\n        }\n        if (_labelIntersect.length > 2) {\n          var _labInt2SqDist = sqdist(_refPt, {\n            x: _labelIntersect[2],\n            y: _labelIntersect[3]\n          });\n          if (_labInt2SqDist < _minSqDist) {\n            intersect = [_labelIntersect[2], _labelIntersect[3]];\n          }\n        }\n      }\n    }\n  }\n  var arrowStart = shortenIntersection(intersect, p2, r.arrowShapes[srcArShape].spacing(edge) + srcDist);\n  var edgeStart = shortenIntersection(intersect, p2, r.arrowShapes[srcArShape].gap(edge) + srcDist);\n  rs.startX = edgeStart[0];\n  rs.startY = edgeStart[1];\n  rs.arrowStartX = arrowStart[0];\n  rs.arrowStartY = arrowStart[1];\n  if (hasEndpts) {\n    if (!number$1(rs.startX) || !number$1(rs.startY) || !number$1(rs.endX) || !number$1(rs.endY)) {\n      rs.badLine = true;\n    } else {\n      rs.badLine = false;\n    }\n  }\n};\nBRp$b.getSourceEndpoint = function (edge) {\n  var rs = edge[0]._private.rscratch;\n  this.recalculateRenderedStyle(edge);\n  switch (rs.edgeType) {\n    case 'haystack':\n      return {\n        x: rs.haystackPts[0],\n        y: rs.haystackPts[1]\n      };\n    default:\n      return {\n        x: rs.arrowStartX,\n        y: rs.arrowStartY\n      };\n  }\n};\nBRp$b.getTargetEndpoint = function (edge) {\n  var rs = edge[0]._private.rscratch;\n  this.recalculateRenderedStyle(edge);\n  switch (rs.edgeType) {\n    case 'haystack':\n      return {\n        x: rs.haystackPts[2],\n        y: rs.haystackPts[3]\n      };\n    default:\n      return {\n        x: rs.arrowEndX,\n        y: rs.arrowEndY\n      };\n  }\n};\n\nvar BRp$a = {};\nfunction pushBezierPts(r, edge, pts) {\n  var qbezierAt$1 = function qbezierAt$1(p1, p2, p3, t) {\n    return qbezierAt(p1, p2, p3, t);\n  };\n  var _p = edge._private;\n  var bpts = _p.rstyle.bezierPts;\n  for (var i = 0; i < r.bezierProjPcts.length; i++) {\n    var p = r.bezierProjPcts[i];\n    bpts.push({\n      x: qbezierAt$1(pts[0], pts[2], pts[4], p),\n      y: qbezierAt$1(pts[1], pts[3], pts[5], p)\n    });\n  }\n}\nBRp$a.storeEdgeProjections = function (edge) {\n  var _p = edge._private;\n  var rs = _p.rscratch;\n  var et = rs.edgeType;\n\n  // clear the cached points state\n  _p.rstyle.bezierPts = null;\n  _p.rstyle.linePts = null;\n  _p.rstyle.haystackPts = null;\n  if (et === 'multibezier' || et === 'bezier' || et === 'self' || et === 'compound') {\n    _p.rstyle.bezierPts = [];\n    for (var i = 0; i + 5 < rs.allpts.length; i += 4) {\n      pushBezierPts(this, edge, rs.allpts.slice(i, i + 6));\n    }\n  } else if (et === 'segments') {\n    var lpts = _p.rstyle.linePts = [];\n    for (var i = 0; i + 1 < rs.allpts.length; i += 2) {\n      lpts.push({\n        x: rs.allpts[i],\n        y: rs.allpts[i + 1]\n      });\n    }\n  } else if (et === 'haystack') {\n    var hpts = rs.haystackPts;\n    _p.rstyle.haystackPts = [{\n      x: hpts[0],\n      y: hpts[1]\n    }, {\n      x: hpts[2],\n      y: hpts[3]\n    }];\n  }\n  _p.rstyle.arrowWidth = this.getArrowWidth(edge.pstyle('width').pfValue, edge.pstyle('arrow-scale').value) * this.arrowShapeWidth;\n};\nBRp$a.recalculateEdgeProjections = function (edges) {\n  this.findEdgeControlPoints(edges);\n};\n\nvar BRp$9 = {};\nBRp$9.recalculateNodeLabelProjection = function (node) {\n  var content = node.pstyle('label').strValue;\n  if (emptyString(content)) {\n    return;\n  }\n  var textX, textY;\n  var _p = node._private;\n  var nodeWidth = node.width();\n  var nodeHeight = node.height();\n  var padding = node.padding();\n  var nodePos = node.position();\n  var textHalign = node.pstyle('text-halign').strValue;\n  var textValign = node.pstyle('text-valign').strValue;\n  var rs = _p.rscratch;\n  var rstyle = _p.rstyle;\n  switch (textHalign) {\n    case 'left':\n      textX = nodePos.x - nodeWidth / 2 - padding;\n      break;\n    case 'right':\n      textX = nodePos.x + nodeWidth / 2 + padding;\n      break;\n    default:\n      // e.g. center\n      textX = nodePos.x;\n  }\n  switch (textValign) {\n    case 'top':\n      textY = nodePos.y - nodeHeight / 2 - padding;\n      break;\n    case 'bottom':\n      textY = nodePos.y + nodeHeight / 2 + padding;\n      break;\n    default:\n      // e.g. middle\n      textY = nodePos.y;\n  }\n  rs.labelX = textX;\n  rs.labelY = textY;\n  rstyle.labelX = textX;\n  rstyle.labelY = textY;\n  this.calculateLabelAngles(node);\n  this.applyLabelDimensions(node);\n};\nvar lineAngleFromDelta = function lineAngleFromDelta(dx, dy) {\n  var angle = Math.atan(dy / dx);\n  if (dx === 0 && angle < 0) {\n    angle = angle * -1;\n  }\n  return angle;\n};\nvar lineAngle = function lineAngle(p0, p1) {\n  var dx = p1.x - p0.x;\n  var dy = p1.y - p0.y;\n  return lineAngleFromDelta(dx, dy);\n};\nvar bezierAngle = function bezierAngle(p0, p1, p2, t) {\n  var t0 = bound(0, t - 0.001, 1);\n  var t1 = bound(0, t + 0.001, 1);\n  var lp0 = qbezierPtAt(p0, p1, p2, t0);\n  var lp1 = qbezierPtAt(p0, p1, p2, t1);\n  return lineAngle(lp0, lp1);\n};\nBRp$9.recalculateEdgeLabelProjections = function (edge) {\n  var p;\n  var _p = edge._private;\n  var rs = _p.rscratch;\n  var r = this;\n  var content = {\n    mid: edge.pstyle('label').strValue,\n    source: edge.pstyle('source-label').strValue,\n    target: edge.pstyle('target-label').strValue\n  };\n  if (content.mid || content.source || content.target) ; else {\n    return; // no labels => no calcs\n  }\n\n  // add center point to style so bounding box calculations can use it\n  //\n  p = {\n    x: rs.midX,\n    y: rs.midY\n  };\n  var setRs = function setRs(propName, prefix, value) {\n    setPrefixedProperty(_p.rscratch, propName, prefix, value);\n    setPrefixedProperty(_p.rstyle, propName, prefix, value);\n  };\n  setRs('labelX', null, p.x);\n  setRs('labelY', null, p.y);\n  var midAngle = lineAngleFromDelta(rs.midDispX, rs.midDispY);\n  setRs('labelAutoAngle', null, midAngle);\n  var createControlPointInfo = function createControlPointInfo() {\n    if (createControlPointInfo.cache) {\n      return createControlPointInfo.cache;\n    } // use cache so only 1x per edge\n\n    var ctrlpts = [];\n\n    // store each ctrlpt info init\n    for (var i = 0; i + 5 < rs.allpts.length; i += 4) {\n      var p0 = {\n        x: rs.allpts[i],\n        y: rs.allpts[i + 1]\n      };\n      var p1 = {\n        x: rs.allpts[i + 2],\n        y: rs.allpts[i + 3]\n      }; // ctrlpt\n      var p2 = {\n        x: rs.allpts[i + 4],\n        y: rs.allpts[i + 5]\n      };\n      ctrlpts.push({\n        p0: p0,\n        p1: p1,\n        p2: p2,\n        startDist: 0,\n        length: 0,\n        segments: []\n      });\n    }\n    var bpts = _p.rstyle.bezierPts;\n    var nProjs = r.bezierProjPcts.length;\n    function addSegment(cp, p0, p1, t0, t1) {\n      var length = dist(p0, p1);\n      var prevSegment = cp.segments[cp.segments.length - 1];\n      var segment = {\n        p0: p0,\n        p1: p1,\n        t0: t0,\n        t1: t1,\n        startDist: prevSegment ? prevSegment.startDist + prevSegment.length : 0,\n        length: length\n      };\n      cp.segments.push(segment);\n      cp.length += length;\n    }\n\n    // update each ctrlpt with segment info\n    for (var _i = 0; _i < ctrlpts.length; _i++) {\n      var cp = ctrlpts[_i];\n      var prevCp = ctrlpts[_i - 1];\n      if (prevCp) {\n        cp.startDist = prevCp.startDist + prevCp.length;\n      }\n      addSegment(cp, cp.p0, bpts[_i * nProjs], 0, r.bezierProjPcts[0]); // first\n\n      for (var j = 0; j < nProjs - 1; j++) {\n        addSegment(cp, bpts[_i * nProjs + j], bpts[_i * nProjs + j + 1], r.bezierProjPcts[j], r.bezierProjPcts[j + 1]);\n      }\n      addSegment(cp, bpts[_i * nProjs + nProjs - 1], cp.p2, r.bezierProjPcts[nProjs - 1], 1); // last\n    }\n\n    return createControlPointInfo.cache = ctrlpts;\n  };\n  var calculateEndProjection = function calculateEndProjection(prefix) {\n    var angle;\n    var isSrc = prefix === 'source';\n    if (!content[prefix]) {\n      return;\n    }\n    var offset = edge.pstyle(prefix + '-text-offset').pfValue;\n    switch (rs.edgeType) {\n      case 'self':\n      case 'compound':\n      case 'bezier':\n      case 'multibezier':\n        {\n          var cps = createControlPointInfo();\n          var selected;\n          var startDist = 0;\n          var totalDist = 0;\n\n          // find the segment we're on\n          for (var i = 0; i < cps.length; i++) {\n            var _cp = cps[isSrc ? i : cps.length - 1 - i];\n            for (var j = 0; j < _cp.segments.length; j++) {\n              var _seg = _cp.segments[isSrc ? j : _cp.segments.length - 1 - j];\n              var lastSeg = i === cps.length - 1 && j === _cp.segments.length - 1;\n              startDist = totalDist;\n              totalDist += _seg.length;\n              if (totalDist >= offset || lastSeg) {\n                selected = {\n                  cp: _cp,\n                  segment: _seg\n                };\n                break;\n              }\n            }\n            if (selected) {\n              break;\n            }\n          }\n          var cp = selected.cp;\n          var seg = selected.segment;\n          var tSegment = (offset - startDist) / seg.length;\n          var segDt = seg.t1 - seg.t0;\n          var t = isSrc ? seg.t0 + segDt * tSegment : seg.t1 - segDt * tSegment;\n          t = bound(0, t, 1);\n          p = qbezierPtAt(cp.p0, cp.p1, cp.p2, t);\n          angle = bezierAngle(cp.p0, cp.p1, cp.p2, t);\n          break;\n        }\n      case 'straight':\n      case 'segments':\n      case 'haystack':\n        {\n          var d = 0,\n            di,\n            d0;\n          var p0, p1;\n          var l = rs.allpts.length;\n          for (var _i2 = 0; _i2 + 3 < l; _i2 += 2) {\n            if (isSrc) {\n              p0 = {\n                x: rs.allpts[_i2],\n                y: rs.allpts[_i2 + 1]\n              };\n              p1 = {\n                x: rs.allpts[_i2 + 2],\n                y: rs.allpts[_i2 + 3]\n              };\n            } else {\n              p0 = {\n                x: rs.allpts[l - 2 - _i2],\n                y: rs.allpts[l - 1 - _i2]\n              };\n              p1 = {\n                x: rs.allpts[l - 4 - _i2],\n                y: rs.allpts[l - 3 - _i2]\n              };\n            }\n            di = dist(p0, p1);\n            d0 = d;\n            d += di;\n            if (d >= offset) {\n              break;\n            }\n          }\n          var pD = offset - d0;\n          var _t = pD / di;\n          _t = bound(0, _t, 1);\n          p = lineAt(p0, p1, _t);\n          angle = lineAngle(p0, p1);\n          break;\n        }\n    }\n    setRs('labelX', prefix, p.x);\n    setRs('labelY', prefix, p.y);\n    setRs('labelAutoAngle', prefix, angle);\n  };\n  calculateEndProjection('source');\n  calculateEndProjection('target');\n  this.applyLabelDimensions(edge);\n};\nBRp$9.applyLabelDimensions = function (ele) {\n  this.applyPrefixedLabelDimensions(ele);\n  if (ele.isEdge()) {\n    this.applyPrefixedLabelDimensions(ele, 'source');\n    this.applyPrefixedLabelDimensions(ele, 'target');\n  }\n};\nBRp$9.applyPrefixedLabelDimensions = function (ele, prefix) {\n  var _p = ele._private;\n  var text = this.getLabelText(ele, prefix);\n  var labelDims = this.calculateLabelDimensions(ele, text);\n  var lineHeight = ele.pstyle('line-height').pfValue;\n  var textWrap = ele.pstyle('text-wrap').strValue;\n  var lines = getPrefixedProperty(_p.rscratch, 'labelWrapCachedLines', prefix) || [];\n  var numLines = textWrap !== 'wrap' ? 1 : Math.max(lines.length, 1);\n  var normPerLineHeight = labelDims.height / numLines;\n  var labelLineHeight = normPerLineHeight * lineHeight;\n  var width = labelDims.width;\n  var height = labelDims.height + (numLines - 1) * (lineHeight - 1) * normPerLineHeight;\n  setPrefixedProperty(_p.rstyle, 'labelWidth', prefix, width);\n  setPrefixedProperty(_p.rscratch, 'labelWidth', prefix, width);\n  setPrefixedProperty(_p.rstyle, 'labelHeight', prefix, height);\n  setPrefixedProperty(_p.rscratch, 'labelHeight', prefix, height);\n  setPrefixedProperty(_p.rscratch, 'labelLineHeight', prefix, labelLineHeight);\n};\nBRp$9.getLabelText = function (ele, prefix) {\n  var _p = ele._private;\n  var pfd = prefix ? prefix + '-' : '';\n  var text = ele.pstyle(pfd + 'label').strValue;\n  var textTransform = ele.pstyle('text-transform').value;\n  var rscratch = function rscratch(propName, value) {\n    if (value) {\n      setPrefixedProperty(_p.rscratch, propName, prefix, value);\n      return value;\n    } else {\n      return getPrefixedProperty(_p.rscratch, propName, prefix);\n    }\n  };\n\n  // for empty text, skip all processing\n  if (!text) {\n    return '';\n  }\n  if (textTransform == 'none') ; else if (textTransform == 'uppercase') {\n    text = text.toUpperCase();\n  } else if (textTransform == 'lowercase') {\n    text = text.toLowerCase();\n  }\n  var wrapStyle = ele.pstyle('text-wrap').value;\n  if (wrapStyle === 'wrap') {\n    var labelKey = rscratch('labelKey');\n\n    // save recalc if the label is the same as before\n    if (labelKey != null && rscratch('labelWrapKey') === labelKey) {\n      return rscratch('labelWrapCachedText');\n    }\n    var zwsp = \"\\u200B\";\n    var lines = text.split('\\n');\n    var maxW = ele.pstyle('text-max-width').pfValue;\n    var overflow = ele.pstyle('text-overflow-wrap').value;\n    var overflowAny = overflow === 'anywhere';\n    var wrappedLines = [];\n    var separatorRegex = /[\\s\\u200b]+|$/g; // Include end of string to add last word\n\n    for (var l = 0; l < lines.length; l++) {\n      var line = lines[l];\n      var lineDims = this.calculateLabelDimensions(ele, line);\n      var lineW = lineDims.width;\n      if (overflowAny) {\n        var processedLine = line.split('').join(zwsp);\n        line = processedLine;\n      }\n      if (lineW > maxW) {\n        // line is too long\n        var separatorMatches = line.matchAll(separatorRegex);\n        var subline = '';\n        var previousIndex = 0;\n        // Add fake match\n        var _iterator = _createForOfIteratorHelper(separatorMatches),\n          _step;\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var separatorMatch = _step.value;\n            var wordSeparator = separatorMatch[0];\n            var word = line.substring(previousIndex, separatorMatch.index);\n            previousIndex = separatorMatch.index + wordSeparator.length;\n            var testLine = subline.length === 0 ? word : subline + word + wordSeparator;\n            var testDims = this.calculateLabelDimensions(ele, testLine);\n            var testW = testDims.width;\n            if (testW <= maxW) {\n              // word fits on current line\n              subline += word + wordSeparator;\n            } else {\n              // word starts new line\n              if (subline) {\n                wrappedLines.push(subline);\n              }\n              subline = word + wordSeparator;\n            }\n          }\n\n          // if there's remaining text, put it in a wrapped line\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n        if (!subline.match(/^[\\s\\u200b]+$/)) {\n          wrappedLines.push(subline);\n        }\n      } else {\n        // line is already short enough\n        wrappedLines.push(line);\n      }\n    } // for\n\n    rscratch('labelWrapCachedLines', wrappedLines);\n    text = rscratch('labelWrapCachedText', wrappedLines.join('\\n'));\n    rscratch('labelWrapKey', labelKey);\n  } else if (wrapStyle === 'ellipsis') {\n    var _maxW = ele.pstyle('text-max-width').pfValue;\n    var ellipsized = '';\n    var ellipsis = \"\\u2026\";\n    var incLastCh = false;\n    if (this.calculateLabelDimensions(ele, text).width < _maxW) {\n      // the label already fits\n      return text;\n    }\n    for (var i = 0; i < text.length; i++) {\n      var widthWithNextCh = this.calculateLabelDimensions(ele, ellipsized + text[i] + ellipsis).width;\n      if (widthWithNextCh > _maxW) {\n        break;\n      }\n      ellipsized += text[i];\n      if (i === text.length - 1) {\n        incLastCh = true;\n      }\n    }\n    if (!incLastCh) {\n      ellipsized += ellipsis;\n    }\n    return ellipsized;\n  } // if ellipsize\n\n  return text;\n};\nBRp$9.getLabelJustification = function (ele) {\n  var justification = ele.pstyle('text-justification').strValue;\n  var textHalign = ele.pstyle('text-halign').strValue;\n  if (justification === 'auto') {\n    if (ele.isNode()) {\n      switch (textHalign) {\n        case 'left':\n          return 'right';\n        case 'right':\n          return 'left';\n        default:\n          return 'center';\n      }\n    } else {\n      return 'center';\n    }\n  } else {\n    return justification;\n  }\n};\nBRp$9.calculateLabelDimensions = function (ele, text) {\n  var r = this;\n  var containerWindow = r.cy.window();\n  var document = containerWindow.document;\n  var cacheKey = hashString(text, ele._private.labelDimsKey);\n  var cache = r.labelDimCache || (r.labelDimCache = []);\n  var existingVal = cache[cacheKey];\n  if (existingVal != null) {\n    return existingVal;\n  }\n  var padding = 0; // add padding around text dims, as the measurement isn't that accurate\n  var fStyle = ele.pstyle('font-style').strValue;\n  var size = ele.pstyle('font-size').pfValue;\n  var family = ele.pstyle('font-family').strValue;\n  var weight = ele.pstyle('font-weight').strValue;\n  var canvas = this.labelCalcCanvas;\n  var c2d = this.labelCalcCanvasContext;\n  if (!canvas) {\n    canvas = this.labelCalcCanvas = document.createElement('canvas');\n    c2d = this.labelCalcCanvasContext = canvas.getContext('2d');\n    var ds = canvas.style;\n    ds.position = 'absolute';\n    ds.left = '-9999px';\n    ds.top = '-9999px';\n    ds.zIndex = '-1';\n    ds.visibility = 'hidden';\n    ds.pointerEvents = 'none';\n  }\n  c2d.font = \"\".concat(fStyle, \" \").concat(weight, \" \").concat(size, \"px \").concat(family);\n  var width = 0;\n  var height = 0;\n  var lines = text.split('\\n');\n  for (var i = 0; i < lines.length; i++) {\n    var line = lines[i];\n    var metrics = c2d.measureText(line);\n    var w = Math.ceil(metrics.width);\n    var h = size;\n    width = Math.max(w, width);\n    height += h;\n  }\n  width += padding;\n  height += padding;\n  return cache[cacheKey] = {\n    width: width,\n    height: height\n  };\n};\nBRp$9.calculateLabelAngle = function (ele, prefix) {\n  var _p = ele._private;\n  var rs = _p.rscratch;\n  var isEdge = ele.isEdge();\n  var prefixDash = prefix ? prefix + '-' : '';\n  var rot = ele.pstyle(prefixDash + 'text-rotation');\n  var rotStr = rot.strValue;\n  if (rotStr === 'none') {\n    return 0;\n  } else if (isEdge && rotStr === 'autorotate') {\n    return rs.labelAutoAngle;\n  } else if (rotStr === 'autorotate') {\n    return 0;\n  } else {\n    return rot.pfValue;\n  }\n};\nBRp$9.calculateLabelAngles = function (ele) {\n  var r = this;\n  var isEdge = ele.isEdge();\n  var _p = ele._private;\n  var rs = _p.rscratch;\n  rs.labelAngle = r.calculateLabelAngle(ele);\n  if (isEdge) {\n    rs.sourceLabelAngle = r.calculateLabelAngle(ele, 'source');\n    rs.targetLabelAngle = r.calculateLabelAngle(ele, 'target');\n  }\n};\n\nvar BRp$8 = {};\nvar TOO_SMALL_CUT_RECT = 28;\nvar warnedCutRect = false;\nBRp$8.getNodeShape = function (node) {\n  var r = this;\n  var shape = node.pstyle('shape').value;\n  if (shape === 'cutrectangle' && (node.width() < TOO_SMALL_CUT_RECT || node.height() < TOO_SMALL_CUT_RECT)) {\n    if (!warnedCutRect) {\n      warn('The `cutrectangle` node shape can not be used at small sizes so `rectangle` is used instead');\n      warnedCutRect = true;\n    }\n    return 'rectangle';\n  }\n  if (node.isParent()) {\n    if (shape === 'rectangle' || shape === 'roundrectangle' || shape === 'round-rectangle' || shape === 'cutrectangle' || shape === 'cut-rectangle' || shape === 'barrel') {\n      return shape;\n    } else {\n      return 'rectangle';\n    }\n  }\n  if (shape === 'polygon') {\n    var points = node.pstyle('shape-polygon-points').value;\n    return r.nodeShapes.makePolygon(points).name;\n  }\n  return shape;\n};\n\nvar BRp$7 = {};\nBRp$7.registerCalculationListeners = function () {\n  var cy = this.cy;\n  var elesToUpdate = cy.collection();\n  var r = this;\n  var enqueue = function enqueue(eles) {\n    var dirtyStyleCaches = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    elesToUpdate.merge(eles);\n    if (dirtyStyleCaches) {\n      for (var i = 0; i < eles.length; i++) {\n        var ele = eles[i];\n        var _p = ele._private;\n        var rstyle = _p.rstyle;\n        rstyle.clean = false;\n        rstyle.cleanConnected = false;\n      }\n    }\n  };\n  r.binder(cy).on('bounds.* dirty.*', function onDirtyBounds(e) {\n    var ele = e.target;\n    enqueue(ele);\n  }).on('style.* background.*', function onDirtyStyle(e) {\n    var ele = e.target;\n    enqueue(ele, false);\n  });\n  var updateEleCalcs = function updateEleCalcs(willDraw) {\n    if (willDraw) {\n      var fns = r.onUpdateEleCalcsFns;\n\n      // because we need to have up-to-date style (e.g. stylesheet mappers)\n      // before calculating rendered style (and pstyle might not be called yet)\n      elesToUpdate.cleanStyle();\n      for (var i = 0; i < elesToUpdate.length; i++) {\n        var ele = elesToUpdate[i];\n        var rstyle = ele._private.rstyle;\n        if (ele.isNode() && !rstyle.cleanConnected) {\n          enqueue(ele.connectedEdges());\n          rstyle.cleanConnected = true;\n        }\n      }\n      if (fns) {\n        for (var _i = 0; _i < fns.length; _i++) {\n          var fn = fns[_i];\n          fn(willDraw, elesToUpdate);\n        }\n      }\n      r.recalculateRenderedStyle(elesToUpdate);\n      elesToUpdate = cy.collection();\n    }\n  };\n  r.flushRenderedStyleQueue = function () {\n    updateEleCalcs(true);\n  };\n  r.beforeRender(updateEleCalcs, r.beforeRenderPriorities.eleCalcs);\n};\nBRp$7.onUpdateEleCalcs = function (fn) {\n  var fns = this.onUpdateEleCalcsFns = this.onUpdateEleCalcsFns || [];\n  fns.push(fn);\n};\nBRp$7.recalculateRenderedStyle = function (eles, useCache) {\n  var isCleanConnected = function isCleanConnected(ele) {\n    return ele._private.rstyle.cleanConnected;\n  };\n  var edges = [];\n  var nodes = [];\n\n  // the renderer can't be used for calcs when destroyed, e.g. ele.boundingBox()\n  if (this.destroyed) {\n    return;\n  }\n\n  // use cache by default for perf\n  if (useCache === undefined) {\n    useCache = true;\n  }\n  for (var i = 0; i < eles.length; i++) {\n    var ele = eles[i];\n    var _p = ele._private;\n    var rstyle = _p.rstyle;\n\n    // an edge may be implicitly dirty b/c of one of its connected nodes\n    // (and a request for recalc may come in between frames)\n    if (ele.isEdge() && (!isCleanConnected(ele.source()) || !isCleanConnected(ele.target()))) {\n      rstyle.clean = false;\n    }\n\n    // only update if dirty and in graph\n    if (useCache && rstyle.clean || ele.removed()) {\n      continue;\n    }\n\n    // only update if not display: none\n    if (ele.pstyle('display').value === 'none') {\n      continue;\n    }\n    if (_p.group === 'nodes') {\n      nodes.push(ele);\n    } else {\n      // edges\n      edges.push(ele);\n    }\n    rstyle.clean = true;\n  }\n\n  // update node data from projections\n  for (var _i2 = 0; _i2 < nodes.length; _i2++) {\n    var _ele = nodes[_i2];\n    var _p2 = _ele._private;\n    var _rstyle = _p2.rstyle;\n    var pos = _ele.position();\n    this.recalculateNodeLabelProjection(_ele);\n    _rstyle.nodeX = pos.x;\n    _rstyle.nodeY = pos.y;\n    _rstyle.nodeW = _ele.pstyle('width').pfValue;\n    _rstyle.nodeH = _ele.pstyle('height').pfValue;\n  }\n  this.recalculateEdgeProjections(edges);\n\n  // update edge data from projections\n  for (var _i3 = 0; _i3 < edges.length; _i3++) {\n    var _ele2 = edges[_i3];\n    var _p3 = _ele2._private;\n    var _rstyle2 = _p3.rstyle;\n    var rs = _p3.rscratch;\n\n    // update rstyle positions\n    _rstyle2.srcX = rs.arrowStartX;\n    _rstyle2.srcY = rs.arrowStartY;\n    _rstyle2.tgtX = rs.arrowEndX;\n    _rstyle2.tgtY = rs.arrowEndY;\n    _rstyle2.midX = rs.midX;\n    _rstyle2.midY = rs.midY;\n    _rstyle2.labelAngle = rs.labelAngle;\n    _rstyle2.sourceLabelAngle = rs.sourceLabelAngle;\n    _rstyle2.targetLabelAngle = rs.targetLabelAngle;\n  }\n};\n\nvar BRp$6 = {};\nBRp$6.updateCachedGrabbedEles = function () {\n  var eles = this.cachedZSortedEles;\n  if (!eles) {\n    // just let this be recalculated on the next z sort tick\n    return;\n  }\n  eles.drag = [];\n  eles.nondrag = [];\n  var grabTargets = [];\n  for (var i = 0; i < eles.length; i++) {\n    var ele = eles[i];\n    var rs = ele._private.rscratch;\n    if (ele.grabbed() && !ele.isParent()) {\n      grabTargets.push(ele);\n    } else if (rs.inDragLayer) {\n      eles.drag.push(ele);\n    } else {\n      eles.nondrag.push(ele);\n    }\n  }\n\n  // put the grab target nodes last so it's on top of its neighbourhood\n  for (var i = 0; i < grabTargets.length; i++) {\n    var ele = grabTargets[i];\n    eles.drag.push(ele);\n  }\n};\nBRp$6.invalidateCachedZSortedEles = function () {\n  this.cachedZSortedEles = null;\n};\nBRp$6.getCachedZSortedEles = function (forceRecalc) {\n  if (forceRecalc || !this.cachedZSortedEles) {\n    var eles = this.cy.mutableElements().toArray();\n    eles.sort(zIndexSort);\n    eles.interactive = eles.filter(function (ele) {\n      return ele.interactive();\n    });\n    this.cachedZSortedEles = eles;\n    this.updateCachedGrabbedEles();\n  } else {\n    eles = this.cachedZSortedEles;\n  }\n  return eles;\n};\n\nvar BRp$5 = {};\n[BRp$e, BRp$d, BRp$c, BRp$b, BRp$a, BRp$9, BRp$8, BRp$7, BRp$6].forEach(function (props) {\n  extend(BRp$5, props);\n});\n\nvar BRp$4 = {};\nBRp$4.getCachedImage = function (url, crossOrigin, onLoad) {\n  var r = this;\n  var imageCache = r.imageCache = r.imageCache || {};\n  var cache = imageCache[url];\n  if (cache) {\n    if (!cache.image.complete) {\n      cache.image.addEventListener('load', onLoad);\n    }\n    return cache.image;\n  } else {\n    cache = imageCache[url] = imageCache[url] || {};\n    var image = cache.image = new Image(); // eslint-disable-line no-undef\n\n    image.addEventListener('load', onLoad);\n    image.addEventListener('error', function () {\n      image.error = true;\n    });\n\n    // #1582 safari doesn't load data uris with crossOrigin properly\n    // https://bugs.webkit.org/show_bug.cgi?id=123978\n    var dataUriPrefix = 'data:';\n    var isDataUri = url.substring(0, dataUriPrefix.length).toLowerCase() === dataUriPrefix;\n    if (!isDataUri) {\n      // if crossorigin is 'null'(stringified), then manually set it to null \n      crossOrigin = crossOrigin === 'null' ? null : crossOrigin;\n      image.crossOrigin = crossOrigin; // prevent tainted canvas\n    }\n\n    image.src = url;\n    return image;\n  }\n};\n\nvar BRp$3 = {};\n\n/* global document, ResizeObserver, MutationObserver */\n\nBRp$3.registerBinding = function (target, event, handler, useCapture) {\n  // eslint-disable-line no-unused-vars\n  var args = Array.prototype.slice.apply(arguments, [1]); // copy\n\n  if (Array.isArray(target)) {\n    var res = [];\n    for (var i = 0; i < target.length; i++) {\n      var t = target[i];\n      if (t !== undefined) {\n        var b = this.binder(t);\n        res.push(b.on.apply(b, args));\n      }\n    }\n    return res;\n  }\n  var b = this.binder(target);\n  return b.on.apply(b, args);\n};\nBRp$3.binder = function (tgt) {\n  var r = this;\n  var containerWindow = r.cy.window();\n  var tgtIsDom = tgt === containerWindow || tgt === containerWindow.document || tgt === containerWindow.document.body || domElement(tgt);\n  if (r.supportsPassiveEvents == null) {\n    // from https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md#feature-detection\n    var supportsPassive = false;\n    try {\n      var opts = Object.defineProperty({}, 'passive', {\n        get: function get() {\n          supportsPassive = true;\n          return true;\n        }\n      });\n      containerWindow.addEventListener('test', null, opts);\n    } catch (err) {\n      // not supported\n    }\n    r.supportsPassiveEvents = supportsPassive;\n  }\n  var on = function on(event, handler, useCapture) {\n    var args = Array.prototype.slice.call(arguments);\n    if (tgtIsDom && r.supportsPassiveEvents) {\n      // replace useCapture w/ opts obj\n      args[2] = {\n        capture: useCapture != null ? useCapture : false,\n        passive: false,\n        once: false\n      };\n    }\n    r.bindings.push({\n      target: tgt,\n      args: args\n    });\n    (tgt.addEventListener || tgt.on).apply(tgt, args);\n    return this;\n  };\n  return {\n    on: on,\n    addEventListener: on,\n    addListener: on,\n    bind: on\n  };\n};\nBRp$3.nodeIsDraggable = function (node) {\n  return node && node.isNode() && !node.locked() && node.grabbable();\n};\nBRp$3.nodeIsGrabbable = function (node) {\n  return this.nodeIsDraggable(node) && node.interactive();\n};\nBRp$3.load = function () {\n  var r = this;\n  var containerWindow = r.cy.window();\n  var isSelected = function isSelected(ele) {\n    return ele.selected();\n  };\n  var getShadowRoot = function getShadowRoot(element) {\n    var rootNode = element.getRootNode();\n    // Check if the root node is a shadow root\n    if (rootNode && rootNode.nodeType === 11 && rootNode.host !== undefined) {\n      return rootNode;\n    }\n  };\n  var triggerEvents = function triggerEvents(target, names, e, position) {\n    if (target == null) {\n      target = r.cy;\n    }\n    for (var i = 0; i < names.length; i++) {\n      var name = names[i];\n      target.emit({\n        originalEvent: e,\n        type: name,\n        position: position\n      });\n    }\n  };\n  var isMultSelKeyDown = function isMultSelKeyDown(e) {\n    return e.shiftKey || e.metaKey || e.ctrlKey; // maybe e.altKey\n  };\n\n  var allowPanningPassthrough = function allowPanningPassthrough(down, downs) {\n    var allowPassthrough = true;\n    if (r.cy.hasCompoundNodes() && down && down.pannable()) {\n      // a grabbable compound node below the ele => no passthrough panning\n      for (var i = 0; downs && i < downs.length; i++) {\n        var down = downs[i];\n\n        //if any parent node in event hierarchy isn't pannable, reject passthrough\n        if (down.isNode() && down.isParent() && !down.pannable()) {\n          allowPassthrough = false;\n          break;\n        }\n      }\n    } else {\n      allowPassthrough = true;\n    }\n    return allowPassthrough;\n  };\n  var setGrabbed = function setGrabbed(ele) {\n    ele[0]._private.grabbed = true;\n  };\n  var setFreed = function setFreed(ele) {\n    ele[0]._private.grabbed = false;\n  };\n  var setInDragLayer = function setInDragLayer(ele) {\n    ele[0]._private.rscratch.inDragLayer = true;\n  };\n  var setOutDragLayer = function setOutDragLayer(ele) {\n    ele[0]._private.rscratch.inDragLayer = false;\n  };\n  var setGrabTarget = function setGrabTarget(ele) {\n    ele[0]._private.rscratch.isGrabTarget = true;\n  };\n  var removeGrabTarget = function removeGrabTarget(ele) {\n    ele[0]._private.rscratch.isGrabTarget = false;\n  };\n  var addToDragList = function addToDragList(ele, opts) {\n    var list = opts.addToList;\n    var listHasEle = list.has(ele);\n    if (!listHasEle && ele.grabbable() && !ele.locked()) {\n      list.merge(ele);\n      setGrabbed(ele);\n    }\n  };\n\n  // helper function to determine which child nodes and inner edges\n  // of a compound node to be dragged as well as the grabbed and selected nodes\n  var addDescendantsToDrag = function addDescendantsToDrag(node, opts) {\n    if (!node.cy().hasCompoundNodes()) {\n      return;\n    }\n    if (opts.inDragLayer == null && opts.addToList == null) {\n      return;\n    } // nothing to do\n\n    var innerNodes = node.descendants();\n    if (opts.inDragLayer) {\n      innerNodes.forEach(setInDragLayer);\n      innerNodes.connectedEdges().forEach(setInDragLayer);\n    }\n    if (opts.addToList) {\n      addToDragList(innerNodes, opts);\n    }\n  };\n\n  // adds the given nodes and its neighbourhood to the drag layer\n  var addNodesToDrag = function addNodesToDrag(nodes, opts) {\n    opts = opts || {};\n    var hasCompoundNodes = nodes.cy().hasCompoundNodes();\n    if (opts.inDragLayer) {\n      nodes.forEach(setInDragLayer);\n      nodes.neighborhood().stdFilter(function (ele) {\n        return !hasCompoundNodes || ele.isEdge();\n      }).forEach(setInDragLayer);\n    }\n    if (opts.addToList) {\n      nodes.forEach(function (ele) {\n        addToDragList(ele, opts);\n      });\n    }\n    addDescendantsToDrag(nodes, opts); // always add to drag\n\n    // also add nodes and edges related to the topmost ancestor\n    updateAncestorsInDragLayer(nodes, {\n      inDragLayer: opts.inDragLayer\n    });\n    r.updateCachedGrabbedEles();\n  };\n  var addNodeToDrag = addNodesToDrag;\n  var freeDraggedElements = function freeDraggedElements(grabbedEles) {\n    if (!grabbedEles) {\n      return;\n    }\n\n    // just go over all elements rather than doing a bunch of (possibly expensive) traversals\n    r.getCachedZSortedEles().forEach(function (ele) {\n      setFreed(ele);\n      setOutDragLayer(ele);\n      removeGrabTarget(ele);\n    });\n    r.updateCachedGrabbedEles();\n  };\n\n  // helper function to determine which ancestor nodes and edges should go\n  // to the drag layer (or should be removed from drag layer).\n  var updateAncestorsInDragLayer = function updateAncestorsInDragLayer(node, opts) {\n    if (opts.inDragLayer == null && opts.addToList == null) {\n      return;\n    } // nothing to do\n\n    if (!node.cy().hasCompoundNodes()) {\n      return;\n    }\n\n    // find top-level parent\n    var parent = node.ancestors().orphans();\n\n    // no parent node: no nodes to add to the drag layer\n    if (parent.same(node)) {\n      return;\n    }\n    var nodes = parent.descendants().spawnSelf().merge(parent).unmerge(node).unmerge(node.descendants());\n    var edges = nodes.connectedEdges();\n    if (opts.inDragLayer) {\n      edges.forEach(setInDragLayer);\n      nodes.forEach(setInDragLayer);\n    }\n    if (opts.addToList) {\n      nodes.forEach(function (ele) {\n        addToDragList(ele, opts);\n      });\n    }\n  };\n  var blurActiveDomElement = function blurActiveDomElement() {\n    if (document.activeElement != null && document.activeElement.blur != null) {\n      document.activeElement.blur();\n    }\n  };\n  var haveMutationsApi = typeof MutationObserver !== 'undefined';\n  var haveResizeObserverApi = typeof ResizeObserver !== 'undefined';\n\n  // watch for when the cy container is removed from the dom\n  if (haveMutationsApi) {\n    r.removeObserver = new MutationObserver(function (mutns) {\n      // eslint-disable-line no-undef\n      for (var i = 0; i < mutns.length; i++) {\n        var mutn = mutns[i];\n        var rNodes = mutn.removedNodes;\n        if (rNodes) {\n          for (var j = 0; j < rNodes.length; j++) {\n            var rNode = rNodes[j];\n            if (rNode === r.container) {\n              r.destroy();\n              break;\n            }\n          }\n        }\n      }\n    });\n    if (r.container.parentNode) {\n      r.removeObserver.observe(r.container.parentNode, {\n        childList: true\n      });\n    }\n  } else {\n    r.registerBinding(r.container, 'DOMNodeRemoved', function (e) {\n      // eslint-disable-line no-unused-vars\n      r.destroy();\n    });\n  }\n  var onResize = debounce_1(function () {\n    r.cy.resize();\n  }, 100);\n  if (haveMutationsApi) {\n    r.styleObserver = new MutationObserver(onResize); // eslint-disable-line no-undef\n\n    r.styleObserver.observe(r.container, {\n      attributes: true\n    });\n  }\n\n  // auto resize\n  r.registerBinding(containerWindow, 'resize', onResize); // eslint-disable-line no-undef\n\n  if (haveResizeObserverApi) {\n    r.resizeObserver = new ResizeObserver(onResize); // eslint-disable-line no-undef\n\n    r.resizeObserver.observe(r.container);\n  }\n  var forEachUp = function forEachUp(domEle, fn) {\n    while (domEle != null) {\n      fn(domEle);\n      domEle = domEle.parentNode;\n    }\n  };\n  var invalidateCoords = function invalidateCoords() {\n    r.invalidateContainerClientCoordsCache();\n  };\n  forEachUp(r.container, function (domEle) {\n    r.registerBinding(domEle, 'transitionend', invalidateCoords);\n    r.registerBinding(domEle, 'animationend', invalidateCoords);\n    r.registerBinding(domEle, 'scroll', invalidateCoords);\n  });\n\n  // stop right click menu from appearing on cy\n  r.registerBinding(r.container, 'contextmenu', function (e) {\n    e.preventDefault();\n  });\n  var inBoxSelection = function inBoxSelection() {\n    return r.selection[4] !== 0;\n  };\n  var eventInContainer = function eventInContainer(e) {\n    // save cycles if mouse events aren't to be captured\n    var containerPageCoords = r.findContainerClientCoords();\n    var x = containerPageCoords[0];\n    var y = containerPageCoords[1];\n    var width = containerPageCoords[2];\n    var height = containerPageCoords[3];\n    var positions = e.touches ? e.touches : [e];\n    var atLeastOnePosInside = false;\n    for (var i = 0; i < positions.length; i++) {\n      var p = positions[i];\n      if (x <= p.clientX && p.clientX <= x + width && y <= p.clientY && p.clientY <= y + height) {\n        atLeastOnePosInside = true;\n        break;\n      }\n    }\n    if (!atLeastOnePosInside) {\n      return false;\n    }\n    var container = r.container;\n    var target = e.target;\n    var tParent = target.parentNode;\n    var containerIsTarget = false;\n    while (tParent) {\n      if (tParent === container) {\n        containerIsTarget = true;\n        break;\n      }\n      tParent = tParent.parentNode;\n    }\n    if (!containerIsTarget) {\n      return false;\n    } // if target is outisde cy container, then this event is not for us\n\n    return true;\n  };\n\n  // Primary key\n  r.registerBinding(r.container, 'mousedown', function mousedownHandler(e) {\n    if (!eventInContainer(e)) {\n      return;\n    }\n\n    // during left mouse button gestures, ignore other buttons\n    if (r.hoverData.which === 1 && e.which !== 1) {\n      return;\n    }\n    e.preventDefault();\n    blurActiveDomElement();\n    r.hoverData.capture = true;\n    r.hoverData.which = e.which;\n    var cy = r.cy;\n    var gpos = [e.clientX, e.clientY];\n    var pos = r.projectIntoViewport(gpos[0], gpos[1]);\n    var select = r.selection;\n    var nears = r.findNearestElements(pos[0], pos[1], true, false);\n    var near = nears[0];\n    var draggedElements = r.dragData.possibleDragElements;\n    r.hoverData.mdownPos = pos;\n    r.hoverData.mdownGPos = gpos;\n    var checkForTaphold = function checkForTaphold() {\n      r.hoverData.tapholdCancelled = false;\n      clearTimeout(r.hoverData.tapholdTimeout);\n      r.hoverData.tapholdTimeout = setTimeout(function () {\n        if (r.hoverData.tapholdCancelled) {\n          return;\n        } else {\n          var ele = r.hoverData.down;\n          if (ele) {\n            ele.emit({\n              originalEvent: e,\n              type: 'taphold',\n              position: {\n                x: pos[0],\n                y: pos[1]\n              }\n            });\n          } else {\n            cy.emit({\n              originalEvent: e,\n              type: 'taphold',\n              position: {\n                x: pos[0],\n                y: pos[1]\n              }\n            });\n          }\n        }\n      }, r.tapholdDuration);\n    };\n\n    // Right click button\n    if (e.which == 3) {\n      r.hoverData.cxtStarted = true;\n      var cxtEvt = {\n        originalEvent: e,\n        type: 'cxttapstart',\n        position: {\n          x: pos[0],\n          y: pos[1]\n        }\n      };\n      if (near) {\n        near.activate();\n        near.emit(cxtEvt);\n        r.hoverData.down = near;\n      } else {\n        cy.emit(cxtEvt);\n      }\n      r.hoverData.downTime = new Date().getTime();\n      r.hoverData.cxtDragged = false;\n\n      // Primary button\n    } else if (e.which == 1) {\n      if (near) {\n        near.activate();\n      }\n\n      // Element dragging\n      {\n        // If something is under the cursor and it is draggable, prepare to grab it\n        if (near != null) {\n          if (r.nodeIsGrabbable(near)) {\n            var makeEvent = function makeEvent(type) {\n              return {\n                originalEvent: e,\n                type: type,\n                position: {\n                  x: pos[0],\n                  y: pos[1]\n                }\n              };\n            };\n            var triggerGrab = function triggerGrab(ele) {\n              ele.emit(makeEvent('grab'));\n            };\n            setGrabTarget(near);\n            if (!near.selected()) {\n              draggedElements = r.dragData.possibleDragElements = cy.collection();\n              addNodeToDrag(near, {\n                addToList: draggedElements\n              });\n              near.emit(makeEvent('grabon')).emit(makeEvent('grab'));\n            } else {\n              draggedElements = r.dragData.possibleDragElements = cy.collection();\n              var selectedNodes = cy.$(function (ele) {\n                return ele.isNode() && ele.selected() && r.nodeIsGrabbable(ele);\n              });\n              addNodesToDrag(selectedNodes, {\n                addToList: draggedElements\n              });\n              near.emit(makeEvent('grabon'));\n              selectedNodes.forEach(triggerGrab);\n            }\n            r.redrawHint('eles', true);\n            r.redrawHint('drag', true);\n          }\n        }\n        r.hoverData.down = near;\n        r.hoverData.downs = nears;\n        r.hoverData.downTime = new Date().getTime();\n      }\n      triggerEvents(near, ['mousedown', 'tapstart', 'vmousedown'], e, {\n        x: pos[0],\n        y: pos[1]\n      });\n      if (near == null) {\n        select[4] = 1;\n        r.data.bgActivePosistion = {\n          x: pos[0],\n          y: pos[1]\n        };\n        r.redrawHint('select', true);\n        r.redraw();\n      } else if (near.pannable()) {\n        select[4] = 1; // for future pan\n      }\n\n      checkForTaphold();\n    }\n\n    // Initialize selection box coordinates\n    select[0] = select[2] = pos[0];\n    select[1] = select[3] = pos[1];\n  }, false);\n  var shadowRoot = getShadowRoot(r.container);\n  r.registerBinding([containerWindow, shadowRoot], 'mousemove', function mousemoveHandler(e) {\n    // eslint-disable-line no-undef\n    var capture = r.hoverData.capture;\n    if (!capture && !eventInContainer(e)) {\n      return;\n    }\n    var preventDefault = false;\n    var cy = r.cy;\n    var zoom = cy.zoom();\n    var gpos = [e.clientX, e.clientY];\n    var pos = r.projectIntoViewport(gpos[0], gpos[1]);\n    var mdownPos = r.hoverData.mdownPos;\n    var mdownGPos = r.hoverData.mdownGPos;\n    var select = r.selection;\n    var near = null;\n    if (!r.hoverData.draggingEles && !r.hoverData.dragging && !r.hoverData.selecting) {\n      near = r.findNearestElement(pos[0], pos[1], true, false);\n    }\n    var last = r.hoverData.last;\n    var down = r.hoverData.down;\n    var disp = [pos[0] - select[2], pos[1] - select[3]];\n    var draggedElements = r.dragData.possibleDragElements;\n    var isOverThresholdDrag;\n    if (mdownGPos) {\n      var dx = gpos[0] - mdownGPos[0];\n      var dx2 = dx * dx;\n      var dy = gpos[1] - mdownGPos[1];\n      var dy2 = dy * dy;\n      var dist2 = dx2 + dy2;\n      r.hoverData.isOverThresholdDrag = isOverThresholdDrag = dist2 >= r.desktopTapThreshold2;\n    }\n    var multSelKeyDown = isMultSelKeyDown(e);\n    if (isOverThresholdDrag) {\n      r.hoverData.tapholdCancelled = true;\n    }\n    var updateDragDelta = function updateDragDelta() {\n      var dragDelta = r.hoverData.dragDelta = r.hoverData.dragDelta || [];\n      if (dragDelta.length === 0) {\n        dragDelta.push(disp[0]);\n        dragDelta.push(disp[1]);\n      } else {\n        dragDelta[0] += disp[0];\n        dragDelta[1] += disp[1];\n      }\n    };\n    preventDefault = true;\n    triggerEvents(near, ['mousemove', 'vmousemove', 'tapdrag'], e, {\n      x: pos[0],\n      y: pos[1]\n    });\n    var goIntoBoxMode = function goIntoBoxMode() {\n      r.data.bgActivePosistion = undefined;\n      if (!r.hoverData.selecting) {\n        cy.emit({\n          originalEvent: e,\n          type: 'boxstart',\n          position: {\n            x: pos[0],\n            y: pos[1]\n          }\n        });\n      }\n      select[4] = 1;\n      r.hoverData.selecting = true;\n      r.redrawHint('select', true);\n      r.redraw();\n    };\n\n    // trigger context drag if rmouse down\n    if (r.hoverData.which === 3) {\n      // but only if over threshold\n      if (isOverThresholdDrag) {\n        var cxtEvt = {\n          originalEvent: e,\n          type: 'cxtdrag',\n          position: {\n            x: pos[0],\n            y: pos[1]\n          }\n        };\n        if (down) {\n          down.emit(cxtEvt);\n        } else {\n          cy.emit(cxtEvt);\n        }\n        r.hoverData.cxtDragged = true;\n        if (!r.hoverData.cxtOver || near !== r.hoverData.cxtOver) {\n          if (r.hoverData.cxtOver) {\n            r.hoverData.cxtOver.emit({\n              originalEvent: e,\n              type: 'cxtdragout',\n              position: {\n                x: pos[0],\n                y: pos[1]\n              }\n            });\n          }\n          r.hoverData.cxtOver = near;\n          if (near) {\n            near.emit({\n              originalEvent: e,\n              type: 'cxtdragover',\n              position: {\n                x: pos[0],\n                y: pos[1]\n              }\n            });\n          }\n        }\n      }\n\n      // Check if we are drag panning the entire graph\n    } else if (r.hoverData.dragging) {\n      preventDefault = true;\n      if (cy.panningEnabled() && cy.userPanningEnabled()) {\n        var deltaP;\n        if (r.hoverData.justStartedPan) {\n          var mdPos = r.hoverData.mdownPos;\n          deltaP = {\n            x: (pos[0] - mdPos[0]) * zoom,\n            y: (pos[1] - mdPos[1]) * zoom\n          };\n          r.hoverData.justStartedPan = false;\n        } else {\n          deltaP = {\n            x: disp[0] * zoom,\n            y: disp[1] * zoom\n          };\n        }\n        cy.panBy(deltaP);\n        cy.emit('dragpan');\n        r.hoverData.dragged = true;\n      }\n\n      // Needs reproject due to pan changing viewport\n      pos = r.projectIntoViewport(e.clientX, e.clientY);\n\n      // Checks primary button down & out of time & mouse not moved much\n    } else if (select[4] == 1 && (down == null || down.pannable())) {\n      if (isOverThresholdDrag) {\n        if (!r.hoverData.dragging && cy.boxSelectionEnabled() && (multSelKeyDown || !cy.panningEnabled() || !cy.userPanningEnabled())) {\n          goIntoBoxMode();\n        } else if (!r.hoverData.selecting && cy.panningEnabled() && cy.userPanningEnabled()) {\n          var allowPassthrough = allowPanningPassthrough(down, r.hoverData.downs);\n          if (allowPassthrough) {\n            r.hoverData.dragging = true;\n            r.hoverData.justStartedPan = true;\n            select[4] = 0;\n            r.data.bgActivePosistion = array2point(mdownPos);\n            r.redrawHint('select', true);\n            r.redraw();\n          }\n        }\n        if (down && down.pannable() && down.active()) {\n          down.unactivate();\n        }\n      }\n    } else {\n      if (down && down.pannable() && down.active()) {\n        down.unactivate();\n      }\n      if ((!down || !down.grabbed()) && near != last) {\n        if (last) {\n          triggerEvents(last, ['mouseout', 'tapdragout'], e, {\n            x: pos[0],\n            y: pos[1]\n          });\n        }\n        if (near) {\n          triggerEvents(near, ['mouseover', 'tapdragover'], e, {\n            x: pos[0],\n            y: pos[1]\n          });\n        }\n        r.hoverData.last = near;\n      }\n      if (down) {\n        if (isOverThresholdDrag) {\n          // then we can take action\n\n          if (cy.boxSelectionEnabled() && multSelKeyDown) {\n            // then selection overrides\n            if (down && down.grabbed()) {\n              freeDraggedElements(draggedElements);\n              down.emit('freeon');\n              draggedElements.emit('free');\n              if (r.dragData.didDrag) {\n                down.emit('dragfreeon');\n                draggedElements.emit('dragfree');\n              }\n            }\n            goIntoBoxMode();\n          } else if (down && down.grabbed() && r.nodeIsDraggable(down)) {\n            // drag node\n            var justStartedDrag = !r.dragData.didDrag;\n            if (justStartedDrag) {\n              r.redrawHint('eles', true);\n            }\n            r.dragData.didDrag = true; // indicate that we actually did drag the node\n\n            // now, add the elements to the drag layer if not done already\n            if (!r.hoverData.draggingEles) {\n              addNodesToDrag(draggedElements, {\n                inDragLayer: true\n              });\n            }\n            var totalShift = {\n              x: 0,\n              y: 0\n            };\n            if (number$1(disp[0]) && number$1(disp[1])) {\n              totalShift.x += disp[0];\n              totalShift.y += disp[1];\n              if (justStartedDrag) {\n                var dragDelta = r.hoverData.dragDelta;\n                if (dragDelta && number$1(dragDelta[0]) && number$1(dragDelta[1])) {\n                  totalShift.x += dragDelta[0];\n                  totalShift.y += dragDelta[1];\n                }\n              }\n            }\n            r.hoverData.draggingEles = true;\n            draggedElements.silentShift(totalShift).emit('position drag');\n            r.redrawHint('drag', true);\n            r.redraw();\n          }\n        } else {\n          // otherwise save drag delta for when we actually start dragging so the relative grab pos is constant\n          updateDragDelta();\n        }\n      }\n\n      // prevent the dragging from triggering text selection on the page\n      preventDefault = true;\n    }\n    select[2] = pos[0];\n    select[3] = pos[1];\n    if (preventDefault) {\n      if (e.stopPropagation) e.stopPropagation();\n      if (e.preventDefault) e.preventDefault();\n      return false;\n    }\n  }, false);\n  var clickTimeout, didDoubleClick, prevClickTimeStamp;\n  r.registerBinding(containerWindow, 'mouseup', function mouseupHandler(e) {\n    // eslint-disable-line no-undef\n    // during left mouse button gestures, ignore other buttons\n    if (r.hoverData.which === 1 && e.which !== 1 && r.hoverData.capture) {\n      return;\n    }\n    var capture = r.hoverData.capture;\n    if (!capture) {\n      return;\n    }\n    r.hoverData.capture = false;\n    var cy = r.cy;\n    var pos = r.projectIntoViewport(e.clientX, e.clientY);\n    var select = r.selection;\n    var near = r.findNearestElement(pos[0], pos[1], true, false);\n    var draggedElements = r.dragData.possibleDragElements;\n    var down = r.hoverData.down;\n    var multSelKeyDown = isMultSelKeyDown(e);\n    if (r.data.bgActivePosistion) {\n      r.redrawHint('select', true);\n      r.redraw();\n    }\n    r.hoverData.tapholdCancelled = true;\n    r.data.bgActivePosistion = undefined; // not active bg now\n\n    if (down) {\n      down.unactivate();\n    }\n    if (r.hoverData.which === 3) {\n      var cxtEvt = {\n        originalEvent: e,\n        type: 'cxttapend',\n        position: {\n          x: pos[0],\n          y: pos[1]\n        }\n      };\n      if (down) {\n        down.emit(cxtEvt);\n      } else {\n        cy.emit(cxtEvt);\n      }\n      if (!r.hoverData.cxtDragged) {\n        var cxtTap = {\n          originalEvent: e,\n          type: 'cxttap',\n          position: {\n            x: pos[0],\n            y: pos[1]\n          }\n        };\n        if (down) {\n          down.emit(cxtTap);\n        } else {\n          cy.emit(cxtTap);\n        }\n      }\n      r.hoverData.cxtDragged = false;\n      r.hoverData.which = null;\n    } else if (r.hoverData.which === 1) {\n      triggerEvents(near, ['mouseup', 'tapend', 'vmouseup'], e, {\n        x: pos[0],\n        y: pos[1]\n      });\n      if (!r.dragData.didDrag &&\n      // didn't move a node around\n      !r.hoverData.dragged &&\n      // didn't pan\n      !r.hoverData.selecting &&\n      // not box selection\n      !r.hoverData.isOverThresholdDrag // didn't move too much\n      ) {\n        triggerEvents(down, [\"click\", \"tap\", \"vclick\"], e, {\n          x: pos[0],\n          y: pos[1]\n        });\n        didDoubleClick = false;\n        if (e.timeStamp - prevClickTimeStamp <= cy.multiClickDebounceTime()) {\n          clickTimeout && clearTimeout(clickTimeout);\n          didDoubleClick = true;\n          prevClickTimeStamp = null;\n          triggerEvents(down, [\"dblclick\", \"dbltap\", \"vdblclick\"], e, {\n            x: pos[0],\n            y: pos[1]\n          });\n        } else {\n          clickTimeout = setTimeout(function () {\n            if (didDoubleClick) return;\n            triggerEvents(down, [\"oneclick\", \"onetap\", \"voneclick\"], e, {\n              x: pos[0],\n              y: pos[1]\n            });\n          }, cy.multiClickDebounceTime());\n          prevClickTimeStamp = e.timeStamp;\n        }\n      }\n\n      // Deselect all elements if nothing is currently under the mouse cursor and we aren't dragging something\n      if (down == null // not mousedown on node\n      && !r.dragData.didDrag // didn't move the node around\n      && !r.hoverData.selecting // not box selection\n      && !r.hoverData.dragged // didn't pan\n      && !isMultSelKeyDown(e)) {\n        cy.$(isSelected).unselect(['tapunselect']);\n        if (draggedElements.length > 0) {\n          r.redrawHint('eles', true);\n        }\n        r.dragData.possibleDragElements = draggedElements = cy.collection();\n      }\n\n      // Single selection\n      if (near == down && !r.dragData.didDrag && !r.hoverData.selecting) {\n        if (near != null && near._private.selectable) {\n          if (r.hoverData.dragging) ; else if (cy.selectionType() === 'additive' || multSelKeyDown) {\n            if (near.selected()) {\n              near.unselect(['tapunselect']);\n            } else {\n              near.select(['tapselect']);\n            }\n          } else {\n            if (!multSelKeyDown) {\n              cy.$(isSelected).unmerge(near).unselect(['tapunselect']);\n              near.select(['tapselect']);\n            }\n          }\n          r.redrawHint('eles', true);\n        }\n      }\n      if (r.hoverData.selecting) {\n        var box = cy.collection(r.getAllInBox(select[0], select[1], select[2], select[3]));\n        r.redrawHint('select', true);\n        if (box.length > 0) {\n          r.redrawHint('eles', true);\n        }\n        cy.emit({\n          type: 'boxend',\n          originalEvent: e,\n          position: {\n            x: pos[0],\n            y: pos[1]\n          }\n        });\n        var eleWouldBeSelected = function eleWouldBeSelected(ele) {\n          return ele.selectable() && !ele.selected();\n        };\n        if (cy.selectionType() === 'additive') {\n          box.emit('box').stdFilter(eleWouldBeSelected).select().emit('boxselect');\n        } else {\n          if (!multSelKeyDown) {\n            cy.$(isSelected).unmerge(box).unselect();\n          }\n          box.emit('box').stdFilter(eleWouldBeSelected).select().emit('boxselect');\n        }\n\n        // always need redraw in case eles unselectable\n        r.redraw();\n      }\n\n      // Cancel drag pan\n      if (r.hoverData.dragging) {\n        r.hoverData.dragging = false;\n        r.redrawHint('select', true);\n        r.redrawHint('eles', true);\n        r.redraw();\n      }\n      if (!select[4]) {\n        r.redrawHint('drag', true);\n        r.redrawHint('eles', true);\n        var downWasGrabbed = down && down.grabbed();\n        freeDraggedElements(draggedElements);\n        if (downWasGrabbed) {\n          down.emit('freeon');\n          draggedElements.emit('free');\n          if (r.dragData.didDrag) {\n            down.emit('dragfreeon');\n            draggedElements.emit('dragfree');\n          }\n        }\n      }\n    } // else not right mouse\n\n    select[4] = 0;\n    r.hoverData.down = null;\n    r.hoverData.cxtStarted = false;\n    r.hoverData.draggingEles = false;\n    r.hoverData.selecting = false;\n    r.hoverData.isOverThresholdDrag = false;\n    r.dragData.didDrag = false;\n    r.hoverData.dragged = false;\n    r.hoverData.dragDelta = [];\n    r.hoverData.mdownPos = null;\n    r.hoverData.mdownGPos = null;\n    r.hoverData.which = null;\n  }, false);\n  var wheelHandler = function wheelHandler(e) {\n    if (r.scrollingPage) {\n      return;\n    } // while scrolling, ignore wheel-to-zoom\n\n    var cy = r.cy;\n    var zoom = cy.zoom();\n    var pan = cy.pan();\n    var pos = r.projectIntoViewport(e.clientX, e.clientY);\n    var rpos = [pos[0] * zoom + pan.x, pos[1] * zoom + pan.y];\n    if (r.hoverData.draggingEles || r.hoverData.dragging || r.hoverData.cxtStarted || inBoxSelection()) {\n      // if pan dragging or cxt dragging, wheel movements make no zoom\n      e.preventDefault();\n      return;\n    }\n    if (cy.panningEnabled() && cy.userPanningEnabled() && cy.zoomingEnabled() && cy.userZoomingEnabled()) {\n      e.preventDefault();\n      r.data.wheelZooming = true;\n      clearTimeout(r.data.wheelTimeout);\n      r.data.wheelTimeout = setTimeout(function () {\n        r.data.wheelZooming = false;\n        r.redrawHint('eles', true);\n        r.redraw();\n      }, 150);\n      var diff;\n      if (e.deltaY != null) {\n        diff = e.deltaY / -250;\n      } else if (e.wheelDeltaY != null) {\n        diff = e.wheelDeltaY / 1000;\n      } else {\n        diff = e.wheelDelta / 1000;\n      }\n      diff = diff * r.wheelSensitivity;\n      var needsWheelFix = e.deltaMode === 1;\n      if (needsWheelFix) {\n        // fixes slow wheel events on ff/linux and ff/windows\n        diff *= 33;\n      }\n      var newZoom = cy.zoom() * Math.pow(10, diff);\n      if (e.type === 'gesturechange') {\n        newZoom = r.gestureStartZoom * e.scale;\n      }\n      cy.zoom({\n        level: newZoom,\n        renderedPosition: {\n          x: rpos[0],\n          y: rpos[1]\n        }\n      });\n      cy.emit(e.type === 'gesturechange' ? 'pinchzoom' : 'scrollzoom');\n    }\n  };\n\n  // Functions to help with whether mouse wheel should trigger zooming\n  // --\n  r.registerBinding(r.container, 'wheel', wheelHandler, true);\n\n  // disable nonstandard wheel events\n  // r.registerBinding(r.container, 'mousewheel', wheelHandler, true);\n  // r.registerBinding(r.container, 'DOMMouseScroll', wheelHandler, true);\n  // r.registerBinding(r.container, 'MozMousePixelScroll', wheelHandler, true); // older firefox\n\n  r.registerBinding(containerWindow, 'scroll', function scrollHandler(e) {\n    // eslint-disable-line no-unused-vars\n    r.scrollingPage = true;\n    clearTimeout(r.scrollingPageTimeout);\n    r.scrollingPageTimeout = setTimeout(function () {\n      r.scrollingPage = false;\n    }, 250);\n  }, true);\n\n  // desktop safari pinch to zoom start\n  r.registerBinding(r.container, 'gesturestart', function gestureStartHandler(e) {\n    r.gestureStartZoom = r.cy.zoom();\n    if (!r.hasTouchStarted) {\n      // don't affect touch devices like iphone\n      e.preventDefault();\n    }\n  }, true);\n  r.registerBinding(r.container, 'gesturechange', function (e) {\n    if (!r.hasTouchStarted) {\n      // don't affect touch devices like iphone\n      wheelHandler(e);\n    }\n  }, true);\n\n  // Functions to help with handling mouseout/mouseover on the Cytoscape container\n  // Handle mouseout on Cytoscape container\n  r.registerBinding(r.container, 'mouseout', function mouseOutHandler(e) {\n    var pos = r.projectIntoViewport(e.clientX, e.clientY);\n    r.cy.emit({\n      originalEvent: e,\n      type: 'mouseout',\n      position: {\n        x: pos[0],\n        y: pos[1]\n      }\n    });\n  }, false);\n  r.registerBinding(r.container, 'mouseover', function mouseOverHandler(e) {\n    var pos = r.projectIntoViewport(e.clientX, e.clientY);\n    r.cy.emit({\n      originalEvent: e,\n      type: 'mouseover',\n      position: {\n        x: pos[0],\n        y: pos[1]\n      }\n    });\n  }, false);\n  var f1x1, f1y1, f2x1, f2y1; // starting points for pinch-to-zoom\n  var distance1, distance1Sq; // initial distance between finger 1 and finger 2 for pinch-to-zoom\n  var center1, modelCenter1; // center point on start pinch to zoom\n  var offsetLeft, offsetTop;\n  var containerWidth, containerHeight;\n  var twoFingersStartInside;\n  var distance = function distance(x1, y1, x2, y2) {\n    return Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\n  };\n  var distanceSq = function distanceSq(x1, y1, x2, y2) {\n    return (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);\n  };\n  var touchstartHandler;\n  r.registerBinding(r.container, 'touchstart', touchstartHandler = function touchstartHandler(e) {\n    r.hasTouchStarted = true;\n    if (!eventInContainer(e)) {\n      return;\n    }\n    blurActiveDomElement();\n    r.touchData.capture = true;\n    r.data.bgActivePosistion = undefined;\n    var cy = r.cy;\n    var now = r.touchData.now;\n    var earlier = r.touchData.earlier;\n    if (e.touches[0]) {\n      var pos = r.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY);\n      now[0] = pos[0];\n      now[1] = pos[1];\n    }\n    if (e.touches[1]) {\n      var pos = r.projectIntoViewport(e.touches[1].clientX, e.touches[1].clientY);\n      now[2] = pos[0];\n      now[3] = pos[1];\n    }\n    if (e.touches[2]) {\n      var pos = r.projectIntoViewport(e.touches[2].clientX, e.touches[2].clientY);\n      now[4] = pos[0];\n      now[5] = pos[1];\n    }\n\n    // record starting points for pinch-to-zoom\n    if (e.touches[1]) {\n      r.touchData.singleTouchMoved = true;\n      freeDraggedElements(r.dragData.touchDragEles);\n      var offsets = r.findContainerClientCoords();\n      offsetLeft = offsets[0];\n      offsetTop = offsets[1];\n      containerWidth = offsets[2];\n      containerHeight = offsets[3];\n      f1x1 = e.touches[0].clientX - offsetLeft;\n      f1y1 = e.touches[0].clientY - offsetTop;\n      f2x1 = e.touches[1].clientX - offsetLeft;\n      f2y1 = e.touches[1].clientY - offsetTop;\n      twoFingersStartInside = 0 <= f1x1 && f1x1 <= containerWidth && 0 <= f2x1 && f2x1 <= containerWidth && 0 <= f1y1 && f1y1 <= containerHeight && 0 <= f2y1 && f2y1 <= containerHeight;\n      var pan = cy.pan();\n      var zoom = cy.zoom();\n      distance1 = distance(f1x1, f1y1, f2x1, f2y1);\n      distance1Sq = distanceSq(f1x1, f1y1, f2x1, f2y1);\n      center1 = [(f1x1 + f2x1) / 2, (f1y1 + f2y1) / 2];\n      modelCenter1 = [(center1[0] - pan.x) / zoom, (center1[1] - pan.y) / zoom];\n\n      // consider context tap\n      var cxtDistThreshold = 200;\n      var cxtDistThresholdSq = cxtDistThreshold * cxtDistThreshold;\n      if (distance1Sq < cxtDistThresholdSq && !e.touches[2]) {\n        var near1 = r.findNearestElement(now[0], now[1], true, true);\n        var near2 = r.findNearestElement(now[2], now[3], true, true);\n        if (near1 && near1.isNode()) {\n          near1.activate().emit({\n            originalEvent: e,\n            type: 'cxttapstart',\n            position: {\n              x: now[0],\n              y: now[1]\n            }\n          });\n          r.touchData.start = near1;\n        } else if (near2 && near2.isNode()) {\n          near2.activate().emit({\n            originalEvent: e,\n            type: 'cxttapstart',\n            position: {\n              x: now[0],\n              y: now[1]\n            }\n          });\n          r.touchData.start = near2;\n        } else {\n          cy.emit({\n            originalEvent: e,\n            type: 'cxttapstart',\n            position: {\n              x: now[0],\n              y: now[1]\n            }\n          });\n        }\n        if (r.touchData.start) {\n          r.touchData.start._private.grabbed = false;\n        }\n        r.touchData.cxt = true;\n        r.touchData.cxtDragged = false;\n        r.data.bgActivePosistion = undefined;\n        r.redraw();\n        return;\n      }\n    }\n    if (e.touches[2]) {\n      // ignore\n\n      // safari on ios pans the page otherwise (normally you should be able to preventdefault on touchmove...)\n      if (cy.boxSelectionEnabled()) {\n        e.preventDefault();\n      }\n    } else if (e.touches[1]) ; else if (e.touches[0]) {\n      var nears = r.findNearestElements(now[0], now[1], true, true);\n      var near = nears[0];\n      if (near != null) {\n        near.activate();\n        r.touchData.start = near;\n        r.touchData.starts = nears;\n        if (r.nodeIsGrabbable(near)) {\n          var draggedEles = r.dragData.touchDragEles = cy.collection();\n          var selectedNodes = null;\n          r.redrawHint('eles', true);\n          r.redrawHint('drag', true);\n          if (near.selected()) {\n            // reset drag elements, since near will be added again\n\n            selectedNodes = cy.$(function (ele) {\n              return ele.selected() && r.nodeIsGrabbable(ele);\n            });\n            addNodesToDrag(selectedNodes, {\n              addToList: draggedEles\n            });\n          } else {\n            addNodeToDrag(near, {\n              addToList: draggedEles\n            });\n          }\n          setGrabTarget(near);\n          var makeEvent = function makeEvent(type) {\n            return {\n              originalEvent: e,\n              type: type,\n              position: {\n                x: now[0],\n                y: now[1]\n              }\n            };\n          };\n          near.emit(makeEvent('grabon'));\n          if (selectedNodes) {\n            selectedNodes.forEach(function (n) {\n              n.emit(makeEvent('grab'));\n            });\n          } else {\n            near.emit(makeEvent('grab'));\n          }\n        }\n      }\n      triggerEvents(near, ['touchstart', 'tapstart', 'vmousedown'], e, {\n        x: now[0],\n        y: now[1]\n      });\n      if (near == null) {\n        r.data.bgActivePosistion = {\n          x: pos[0],\n          y: pos[1]\n        };\n        r.redrawHint('select', true);\n        r.redraw();\n      }\n\n      // Tap, taphold\n      // -----\n\n      r.touchData.singleTouchMoved = false;\n      r.touchData.singleTouchStartTime = +new Date();\n      clearTimeout(r.touchData.tapholdTimeout);\n      r.touchData.tapholdTimeout = setTimeout(function () {\n        if (r.touchData.singleTouchMoved === false && !r.pinching // if pinching, then taphold unselect shouldn't take effect\n        && !r.touchData.selecting // box selection shouldn't allow taphold through\n        ) {\n          triggerEvents(r.touchData.start, ['taphold'], e, {\n            x: now[0],\n            y: now[1]\n          });\n        }\n      }, r.tapholdDuration);\n    }\n    if (e.touches.length >= 1) {\n      var sPos = r.touchData.startPosition = [null, null, null, null, null, null];\n      for (var i = 0; i < now.length; i++) {\n        sPos[i] = earlier[i] = now[i];\n      }\n      var touch0 = e.touches[0];\n      r.touchData.startGPosition = [touch0.clientX, touch0.clientY];\n    }\n  }, false);\n  var touchmoveHandler;\n  r.registerBinding(containerWindow, 'touchmove', touchmoveHandler = function touchmoveHandler(e) {\n    // eslint-disable-line no-undef\n    var capture = r.touchData.capture;\n    if (!capture && !eventInContainer(e)) {\n      return;\n    }\n    var select = r.selection;\n    var cy = r.cy;\n    var now = r.touchData.now;\n    var earlier = r.touchData.earlier;\n    var zoom = cy.zoom();\n    if (e.touches[0]) {\n      var pos = r.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY);\n      now[0] = pos[0];\n      now[1] = pos[1];\n    }\n    if (e.touches[1]) {\n      var pos = r.projectIntoViewport(e.touches[1].clientX, e.touches[1].clientY);\n      now[2] = pos[0];\n      now[3] = pos[1];\n    }\n    if (e.touches[2]) {\n      var pos = r.projectIntoViewport(e.touches[2].clientX, e.touches[2].clientY);\n      now[4] = pos[0];\n      now[5] = pos[1];\n    }\n    var startGPos = r.touchData.startGPosition;\n    var isOverThresholdDrag;\n    if (capture && e.touches[0] && startGPos) {\n      var disp = [];\n      for (var j = 0; j < now.length; j++) {\n        disp[j] = now[j] - earlier[j];\n      }\n      var dx = e.touches[0].clientX - startGPos[0];\n      var dx2 = dx * dx;\n      var dy = e.touches[0].clientY - startGPos[1];\n      var dy2 = dy * dy;\n      var dist2 = dx2 + dy2;\n      isOverThresholdDrag = dist2 >= r.touchTapThreshold2;\n    }\n\n    // context swipe cancelling\n    if (capture && r.touchData.cxt) {\n      e.preventDefault();\n      var f1x2 = e.touches[0].clientX - offsetLeft,\n        f1y2 = e.touches[0].clientY - offsetTop;\n      var f2x2 = e.touches[1].clientX - offsetLeft,\n        f2y2 = e.touches[1].clientY - offsetTop;\n      // var distance2 = distance( f1x2, f1y2, f2x2, f2y2 );\n      var distance2Sq = distanceSq(f1x2, f1y2, f2x2, f2y2);\n      var factorSq = distance2Sq / distance1Sq;\n      var distThreshold = 150;\n      var distThresholdSq = distThreshold * distThreshold;\n      var factorThreshold = 1.5;\n      var factorThresholdSq = factorThreshold * factorThreshold;\n\n      // cancel ctx gestures if the distance b/t the fingers increases\n      if (factorSq >= factorThresholdSq || distance2Sq >= distThresholdSq) {\n        r.touchData.cxt = false;\n        r.data.bgActivePosistion = undefined;\n        r.redrawHint('select', true);\n        var cxtEvt = {\n          originalEvent: e,\n          type: 'cxttapend',\n          position: {\n            x: now[0],\n            y: now[1]\n          }\n        };\n        if (r.touchData.start) {\n          r.touchData.start.unactivate().emit(cxtEvt);\n          r.touchData.start = null;\n        } else {\n          cy.emit(cxtEvt);\n        }\n      }\n    }\n\n    // context swipe\n    if (capture && r.touchData.cxt) {\n      var cxtEvt = {\n        originalEvent: e,\n        type: 'cxtdrag',\n        position: {\n          x: now[0],\n          y: now[1]\n        }\n      };\n      r.data.bgActivePosistion = undefined;\n      r.redrawHint('select', true);\n      if (r.touchData.start) {\n        r.touchData.start.emit(cxtEvt);\n      } else {\n        cy.emit(cxtEvt);\n      }\n      if (r.touchData.start) {\n        r.touchData.start._private.grabbed = false;\n      }\n      r.touchData.cxtDragged = true;\n      var near = r.findNearestElement(now[0], now[1], true, true);\n      if (!r.touchData.cxtOver || near !== r.touchData.cxtOver) {\n        if (r.touchData.cxtOver) {\n          r.touchData.cxtOver.emit({\n            originalEvent: e,\n            type: 'cxtdragout',\n            position: {\n              x: now[0],\n              y: now[1]\n            }\n          });\n        }\n        r.touchData.cxtOver = near;\n        if (near) {\n          near.emit({\n            originalEvent: e,\n            type: 'cxtdragover',\n            position: {\n              x: now[0],\n              y: now[1]\n            }\n          });\n        }\n      }\n\n      // box selection\n    } else if (capture && e.touches[2] && cy.boxSelectionEnabled()) {\n      e.preventDefault();\n      r.data.bgActivePosistion = undefined;\n      this.lastThreeTouch = +new Date();\n      if (!r.touchData.selecting) {\n        cy.emit({\n          originalEvent: e,\n          type: 'boxstart',\n          position: {\n            x: now[0],\n            y: now[1]\n          }\n        });\n      }\n      r.touchData.selecting = true;\n      r.touchData.didSelect = true;\n      select[4] = 1;\n      if (!select || select.length === 0 || select[0] === undefined) {\n        select[0] = (now[0] + now[2] + now[4]) / 3;\n        select[1] = (now[1] + now[3] + now[5]) / 3;\n        select[2] = (now[0] + now[2] + now[4]) / 3 + 1;\n        select[3] = (now[1] + now[3] + now[5]) / 3 + 1;\n      } else {\n        select[2] = (now[0] + now[2] + now[4]) / 3;\n        select[3] = (now[1] + now[3] + now[5]) / 3;\n      }\n      r.redrawHint('select', true);\n      r.redraw();\n\n      // pinch to zoom\n    } else if (capture && e.touches[1] && !r.touchData.didSelect // don't allow box selection to degrade to pinch-to-zoom\n    && cy.zoomingEnabled() && cy.panningEnabled() && cy.userZoomingEnabled() && cy.userPanningEnabled()) {\n      // two fingers => pinch to zoom\n      e.preventDefault();\n      r.data.bgActivePosistion = undefined;\n      r.redrawHint('select', true);\n      var draggedEles = r.dragData.touchDragEles;\n      if (draggedEles) {\n        r.redrawHint('drag', true);\n        for (var i = 0; i < draggedEles.length; i++) {\n          var de_p = draggedEles[i]._private;\n          de_p.grabbed = false;\n          de_p.rscratch.inDragLayer = false;\n        }\n      }\n      var _start = r.touchData.start;\n\n      // (x2, y2) for fingers 1 and 2\n      var f1x2 = e.touches[0].clientX - offsetLeft,\n        f1y2 = e.touches[0].clientY - offsetTop;\n      var f2x2 = e.touches[1].clientX - offsetLeft,\n        f2y2 = e.touches[1].clientY - offsetTop;\n      var distance2 = distance(f1x2, f1y2, f2x2, f2y2);\n      // var distance2Sq = distanceSq( f1x2, f1y2, f2x2, f2y2 );\n      // var factor = Math.sqrt( distance2Sq ) / Math.sqrt( distance1Sq );\n      var factor = distance2 / distance1;\n      if (twoFingersStartInside) {\n        // delta finger1\n        var df1x = f1x2 - f1x1;\n        var df1y = f1y2 - f1y1;\n\n        // delta finger 2\n        var df2x = f2x2 - f2x1;\n        var df2y = f2y2 - f2y1;\n\n        // translation is the normalised vector of the two fingers movement\n        // i.e. so pinching cancels out and moving together pans\n        var tx = (df1x + df2x) / 2;\n        var ty = (df1y + df2y) / 2;\n\n        // now calculate the zoom\n        var zoom1 = cy.zoom();\n        var zoom2 = zoom1 * factor;\n        var pan1 = cy.pan();\n\n        // the model center point converted to the current rendered pos\n        var ctrx = modelCenter1[0] * zoom1 + pan1.x;\n        var ctry = modelCenter1[1] * zoom1 + pan1.y;\n        var pan2 = {\n          x: -zoom2 / zoom1 * (ctrx - pan1.x - tx) + ctrx,\n          y: -zoom2 / zoom1 * (ctry - pan1.y - ty) + ctry\n        };\n\n        // remove dragged eles\n        if (_start && _start.active()) {\n          var draggedEles = r.dragData.touchDragEles;\n          freeDraggedElements(draggedEles);\n          r.redrawHint('drag', true);\n          r.redrawHint('eles', true);\n          _start.unactivate().emit('freeon');\n          draggedEles.emit('free');\n          if (r.dragData.didDrag) {\n            _start.emit('dragfreeon');\n            draggedEles.emit('dragfree');\n          }\n        }\n        cy.viewport({\n          zoom: zoom2,\n          pan: pan2,\n          cancelOnFailedZoom: true\n        });\n        cy.emit('pinchzoom');\n        distance1 = distance2;\n        f1x1 = f1x2;\n        f1y1 = f1y2;\n        f2x1 = f2x2;\n        f2y1 = f2y2;\n        r.pinching = true;\n      }\n\n      // Re-project\n      if (e.touches[0]) {\n        var pos = r.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY);\n        now[0] = pos[0];\n        now[1] = pos[1];\n      }\n      if (e.touches[1]) {\n        var pos = r.projectIntoViewport(e.touches[1].clientX, e.touches[1].clientY);\n        now[2] = pos[0];\n        now[3] = pos[1];\n      }\n      if (e.touches[2]) {\n        var pos = r.projectIntoViewport(e.touches[2].clientX, e.touches[2].clientY);\n        now[4] = pos[0];\n        now[5] = pos[1];\n      }\n    } else if (e.touches[0] && !r.touchData.didSelect // don't allow box selection to degrade to single finger events like panning\n    ) {\n      var start = r.touchData.start;\n      var last = r.touchData.last;\n      var near;\n      if (!r.hoverData.draggingEles && !r.swipePanning) {\n        near = r.findNearestElement(now[0], now[1], true, true);\n      }\n      if (capture && start != null) {\n        e.preventDefault();\n      }\n\n      // dragging nodes\n      if (capture && start != null && r.nodeIsDraggable(start)) {\n        if (isOverThresholdDrag) {\n          // then dragging can happen\n          var draggedEles = r.dragData.touchDragEles;\n          var justStartedDrag = !r.dragData.didDrag;\n          if (justStartedDrag) {\n            addNodesToDrag(draggedEles, {\n              inDragLayer: true\n            });\n          }\n          r.dragData.didDrag = true;\n          var totalShift = {\n            x: 0,\n            y: 0\n          };\n          if (number$1(disp[0]) && number$1(disp[1])) {\n            totalShift.x += disp[0];\n            totalShift.y += disp[1];\n            if (justStartedDrag) {\n              r.redrawHint('eles', true);\n              var dragDelta = r.touchData.dragDelta;\n              if (dragDelta && number$1(dragDelta[0]) && number$1(dragDelta[1])) {\n                totalShift.x += dragDelta[0];\n                totalShift.y += dragDelta[1];\n              }\n            }\n          }\n          r.hoverData.draggingEles = true;\n          draggedEles.silentShift(totalShift).emit('position drag');\n          r.redrawHint('drag', true);\n          if (r.touchData.startPosition[0] == earlier[0] && r.touchData.startPosition[1] == earlier[1]) {\n            r.redrawHint('eles', true);\n          }\n          r.redraw();\n        } else {\n          // otherwise keep track of drag delta for later\n          var dragDelta = r.touchData.dragDelta = r.touchData.dragDelta || [];\n          if (dragDelta.length === 0) {\n            dragDelta.push(disp[0]);\n            dragDelta.push(disp[1]);\n          } else {\n            dragDelta[0] += disp[0];\n            dragDelta[1] += disp[1];\n          }\n        }\n      }\n\n      // touchmove\n      {\n        triggerEvents(start || near, ['touchmove', 'tapdrag', 'vmousemove'], e, {\n          x: now[0],\n          y: now[1]\n        });\n        if ((!start || !start.grabbed()) && near != last) {\n          if (last) {\n            last.emit({\n              originalEvent: e,\n              type: 'tapdragout',\n              position: {\n                x: now[0],\n                y: now[1]\n              }\n            });\n          }\n          if (near) {\n            near.emit({\n              originalEvent: e,\n              type: 'tapdragover',\n              position: {\n                x: now[0],\n                y: now[1]\n              }\n            });\n          }\n        }\n        r.touchData.last = near;\n      }\n\n      // check to cancel taphold\n      if (capture) {\n        for (var i = 0; i < now.length; i++) {\n          if (now[i] && r.touchData.startPosition[i] && isOverThresholdDrag) {\n            r.touchData.singleTouchMoved = true;\n          }\n        }\n      }\n\n      // panning\n      if (capture && (start == null || start.pannable()) && cy.panningEnabled() && cy.userPanningEnabled()) {\n        var allowPassthrough = allowPanningPassthrough(start, r.touchData.starts);\n        if (allowPassthrough) {\n          e.preventDefault();\n          if (!r.data.bgActivePosistion) {\n            r.data.bgActivePosistion = array2point(r.touchData.startPosition);\n          }\n          if (r.swipePanning) {\n            cy.panBy({\n              x: disp[0] * zoom,\n              y: disp[1] * zoom\n            });\n            cy.emit('dragpan');\n          } else if (isOverThresholdDrag) {\n            r.swipePanning = true;\n            cy.panBy({\n              x: dx * zoom,\n              y: dy * zoom\n            });\n            cy.emit('dragpan');\n            if (start) {\n              start.unactivate();\n              r.redrawHint('select', true);\n              r.touchData.start = null;\n            }\n          }\n        }\n\n        // Re-project\n        var pos = r.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY);\n        now[0] = pos[0];\n        now[1] = pos[1];\n      }\n    }\n    for (var j = 0; j < now.length; j++) {\n      earlier[j] = now[j];\n    }\n\n    // the active bg indicator should be removed when making a swipe that is neither for dragging nodes or panning\n    if (capture && e.touches.length > 0 && !r.hoverData.draggingEles && !r.swipePanning && r.data.bgActivePosistion != null) {\n      r.data.bgActivePosistion = undefined;\n      r.redrawHint('select', true);\n      r.redraw();\n    }\n  }, false);\n  var touchcancelHandler;\n  r.registerBinding(containerWindow, 'touchcancel', touchcancelHandler = function touchcancelHandler(e) {\n    // eslint-disable-line no-unused-vars\n    var start = r.touchData.start;\n    r.touchData.capture = false;\n    if (start) {\n      start.unactivate();\n    }\n  });\n  var touchendHandler, didDoubleTouch, touchTimeout, prevTouchTimeStamp;\n  r.registerBinding(containerWindow, 'touchend', touchendHandler = function touchendHandler(e) {\n    // eslint-disable-line no-unused-vars\n    var start = r.touchData.start;\n    var capture = r.touchData.capture;\n    if (capture) {\n      if (e.touches.length === 0) {\n        r.touchData.capture = false;\n      }\n      e.preventDefault();\n    } else {\n      return;\n    }\n    var select = r.selection;\n    r.swipePanning = false;\n    r.hoverData.draggingEles = false;\n    var cy = r.cy;\n    var zoom = cy.zoom();\n    var now = r.touchData.now;\n    var earlier = r.touchData.earlier;\n    if (e.touches[0]) {\n      var pos = r.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY);\n      now[0] = pos[0];\n      now[1] = pos[1];\n    }\n    if (e.touches[1]) {\n      var pos = r.projectIntoViewport(e.touches[1].clientX, e.touches[1].clientY);\n      now[2] = pos[0];\n      now[3] = pos[1];\n    }\n    if (e.touches[2]) {\n      var pos = r.projectIntoViewport(e.touches[2].clientX, e.touches[2].clientY);\n      now[4] = pos[0];\n      now[5] = pos[1];\n    }\n    if (start) {\n      start.unactivate();\n    }\n    var ctxTapend;\n    if (r.touchData.cxt) {\n      ctxTapend = {\n        originalEvent: e,\n        type: 'cxttapend',\n        position: {\n          x: now[0],\n          y: now[1]\n        }\n      };\n      if (start) {\n        start.emit(ctxTapend);\n      } else {\n        cy.emit(ctxTapend);\n      }\n      if (!r.touchData.cxtDragged) {\n        var ctxTap = {\n          originalEvent: e,\n          type: 'cxttap',\n          position: {\n            x: now[0],\n            y: now[1]\n          }\n        };\n        if (start) {\n          start.emit(ctxTap);\n        } else {\n          cy.emit(ctxTap);\n        }\n      }\n      if (r.touchData.start) {\n        r.touchData.start._private.grabbed = false;\n      }\n      r.touchData.cxt = false;\n      r.touchData.start = null;\n      r.redraw();\n      return;\n    }\n\n    // no more box selection if we don't have three fingers\n    if (!e.touches[2] && cy.boxSelectionEnabled() && r.touchData.selecting) {\n      r.touchData.selecting = false;\n      var box = cy.collection(r.getAllInBox(select[0], select[1], select[2], select[3]));\n      select[0] = undefined;\n      select[1] = undefined;\n      select[2] = undefined;\n      select[3] = undefined;\n      select[4] = 0;\n      r.redrawHint('select', true);\n      cy.emit({\n        type: 'boxend',\n        originalEvent: e,\n        position: {\n          x: now[0],\n          y: now[1]\n        }\n      });\n      var eleWouldBeSelected = function eleWouldBeSelected(ele) {\n        return ele.selectable() && !ele.selected();\n      };\n      box.emit('box').stdFilter(eleWouldBeSelected).select().emit('boxselect');\n      if (box.nonempty()) {\n        r.redrawHint('eles', true);\n      }\n      r.redraw();\n    }\n    if (start != null) {\n      start.unactivate();\n    }\n    if (e.touches[2]) {\n      r.data.bgActivePosistion = undefined;\n      r.redrawHint('select', true);\n    } else if (e.touches[1]) ; else if (e.touches[0]) ; else if (!e.touches[0]) {\n      r.data.bgActivePosistion = undefined;\n      r.redrawHint('select', true);\n      var draggedEles = r.dragData.touchDragEles;\n      if (start != null) {\n        var startWasGrabbed = start._private.grabbed;\n        freeDraggedElements(draggedEles);\n        r.redrawHint('drag', true);\n        r.redrawHint('eles', true);\n        if (startWasGrabbed) {\n          start.emit('freeon');\n          draggedEles.emit('free');\n          if (r.dragData.didDrag) {\n            start.emit('dragfreeon');\n            draggedEles.emit('dragfree');\n          }\n        }\n        triggerEvents(start, ['touchend', 'tapend', 'vmouseup', 'tapdragout'], e, {\n          x: now[0],\n          y: now[1]\n        });\n        start.unactivate();\n        r.touchData.start = null;\n      } else {\n        var near = r.findNearestElement(now[0], now[1], true, true);\n        triggerEvents(near, ['touchend', 'tapend', 'vmouseup', 'tapdragout'], e, {\n          x: now[0],\n          y: now[1]\n        });\n      }\n      var dx = r.touchData.startPosition[0] - now[0];\n      var dx2 = dx * dx;\n      var dy = r.touchData.startPosition[1] - now[1];\n      var dy2 = dy * dy;\n      var dist2 = dx2 + dy2;\n      var rdist2 = dist2 * zoom * zoom;\n\n      // Tap event, roughly same as mouse click event for touch\n      if (!r.touchData.singleTouchMoved) {\n        if (!start) {\n          cy.$(':selected').unselect(['tapunselect']);\n        }\n        triggerEvents(start, ['tap', 'vclick'], e, {\n          x: now[0],\n          y: now[1]\n        });\n        didDoubleTouch = false;\n        if (e.timeStamp - prevTouchTimeStamp <= cy.multiClickDebounceTime()) {\n          touchTimeout && clearTimeout(touchTimeout);\n          didDoubleTouch = true;\n          prevTouchTimeStamp = null;\n          triggerEvents(start, ['dbltap', 'vdblclick'], e, {\n            x: now[0],\n            y: now[1]\n          });\n        } else {\n          touchTimeout = setTimeout(function () {\n            if (didDoubleTouch) return;\n            triggerEvents(start, ['onetap', 'voneclick'], e, {\n              x: now[0],\n              y: now[1]\n            });\n          }, cy.multiClickDebounceTime());\n          prevTouchTimeStamp = e.timeStamp;\n        }\n      }\n\n      // Prepare to select the currently touched node, only if it hasn't been dragged past a certain distance\n      if (start != null && !r.dragData.didDrag // didn't drag nodes around\n      && start._private.selectable && rdist2 < r.touchTapThreshold2 && !r.pinching // pinch to zoom should not affect selection\n      ) {\n        if (cy.selectionType() === 'single') {\n          cy.$(isSelected).unmerge(start).unselect(['tapunselect']);\n          start.select(['tapselect']);\n        } else {\n          if (start.selected()) {\n            start.unselect(['tapunselect']);\n          } else {\n            start.select(['tapselect']);\n          }\n        }\n        r.redrawHint('eles', true);\n      }\n      r.touchData.singleTouchMoved = true;\n    }\n    for (var j = 0; j < now.length; j++) {\n      earlier[j] = now[j];\n    }\n    r.dragData.didDrag = false; // reset for next touchstart\n\n    if (e.touches.length === 0) {\n      r.touchData.dragDelta = [];\n      r.touchData.startPosition = [null, null, null, null, null, null];\n      r.touchData.startGPosition = null;\n      r.touchData.didSelect = false;\n    }\n    if (e.touches.length < 2) {\n      if (e.touches.length === 1) {\n        // the old start global pos'n may not be the same finger that remains\n        r.touchData.startGPosition = [e.touches[0].clientX, e.touches[0].clientY];\n      }\n      r.pinching = false;\n      r.redrawHint('eles', true);\n      r.redraw();\n    }\n\n    //r.redraw();\n  }, false);\n\n  // fallback compatibility layer for ms pointer events\n  if (typeof TouchEvent === 'undefined') {\n    var pointers = [];\n    var makeTouch = function makeTouch(e) {\n      return {\n        clientX: e.clientX,\n        clientY: e.clientY,\n        force: 1,\n        identifier: e.pointerId,\n        pageX: e.pageX,\n        pageY: e.pageY,\n        radiusX: e.width / 2,\n        radiusY: e.height / 2,\n        screenX: e.screenX,\n        screenY: e.screenY,\n        target: e.target\n      };\n    };\n    var makePointer = function makePointer(e) {\n      return {\n        event: e,\n        touch: makeTouch(e)\n      };\n    };\n    var addPointer = function addPointer(e) {\n      pointers.push(makePointer(e));\n    };\n    var removePointer = function removePointer(e) {\n      for (var i = 0; i < pointers.length; i++) {\n        var p = pointers[i];\n        if (p.event.pointerId === e.pointerId) {\n          pointers.splice(i, 1);\n          return;\n        }\n      }\n    };\n    var updatePointer = function updatePointer(e) {\n      var p = pointers.filter(function (p) {\n        return p.event.pointerId === e.pointerId;\n      })[0];\n      p.event = e;\n      p.touch = makeTouch(e);\n    };\n    var addTouchesToEvent = function addTouchesToEvent(e) {\n      e.touches = pointers.map(function (p) {\n        return p.touch;\n      });\n    };\n    var pointerIsMouse = function pointerIsMouse(e) {\n      return e.pointerType === 'mouse' || e.pointerType === 4;\n    };\n    r.registerBinding(r.container, 'pointerdown', function (e) {\n      if (pointerIsMouse(e)) {\n        return;\n      } // mouse already handled\n\n      e.preventDefault();\n      addPointer(e);\n      addTouchesToEvent(e);\n      touchstartHandler(e);\n    });\n    r.registerBinding(r.container, 'pointerup', function (e) {\n      if (pointerIsMouse(e)) {\n        return;\n      } // mouse already handled\n\n      removePointer(e);\n      addTouchesToEvent(e);\n      touchendHandler(e);\n    });\n    r.registerBinding(r.container, 'pointercancel', function (e) {\n      if (pointerIsMouse(e)) {\n        return;\n      } // mouse already handled\n\n      removePointer(e);\n      addTouchesToEvent(e);\n      touchcancelHandler(e);\n    });\n    r.registerBinding(r.container, 'pointermove', function (e) {\n      if (pointerIsMouse(e)) {\n        return;\n      } // mouse already handled\n\n      e.preventDefault();\n      updatePointer(e);\n      addTouchesToEvent(e);\n      touchmoveHandler(e);\n    });\n  }\n};\n\nvar BRp$2 = {};\nBRp$2.generatePolygon = function (name, points) {\n  return this.nodeShapes[name] = {\n    renderer: this,\n    name: name,\n    points: points,\n    draw: function draw(context, centerX, centerY, width, height, cornerRadius) {\n      this.renderer.nodeShapeImpl('polygon', context, centerX, centerY, width, height, this.points);\n    },\n    intersectLine: function intersectLine(nodeX, nodeY, width, height, x, y, padding, cornerRadius) {\n      return polygonIntersectLine(x, y, this.points, nodeX, nodeY, width / 2, height / 2, padding);\n    },\n    checkPoint: function checkPoint(x, y, padding, width, height, centerX, centerY, cornerRadius) {\n      return pointInsidePolygon(x, y, this.points, centerX, centerY, width, height, [0, -1], padding);\n    }\n  };\n};\nBRp$2.generateEllipse = function () {\n  return this.nodeShapes['ellipse'] = {\n    renderer: this,\n    name: 'ellipse',\n    draw: function draw(context, centerX, centerY, width, height, cornerRadius) {\n      this.renderer.nodeShapeImpl(this.name, context, centerX, centerY, width, height);\n    },\n    intersectLine: function intersectLine(nodeX, nodeY, width, height, x, y, padding, cornerRadius) {\n      return intersectLineEllipse(x, y, nodeX, nodeY, width / 2 + padding, height / 2 + padding);\n    },\n    checkPoint: function checkPoint(x, y, padding, width, height, centerX, centerY, cornerRadius) {\n      return checkInEllipse(x, y, width, height, centerX, centerY, padding);\n    }\n  };\n};\nBRp$2.generateRoundPolygon = function (name, points) {\n  return this.nodeShapes[name] = {\n    renderer: this,\n    name: name,\n    points: points,\n    getOrCreateCorners: function getOrCreateCorners(centerX, centerY, width, height, cornerRadius, rs, field) {\n      if (rs[field] !== undefined && rs[field + '-cx'] === centerX && rs[field + '-cy'] === centerY) {\n        return rs[field];\n      }\n      rs[field] = new Array(points.length / 2);\n      rs[field + '-cx'] = centerX;\n      rs[field + '-cy'] = centerY;\n      var halfW = width / 2;\n      var halfH = height / 2;\n      cornerRadius = cornerRadius === 'auto' ? getRoundPolygonRadius(width, height) : cornerRadius;\n      var p = new Array(points.length / 2);\n      for (var _i = 0; _i < points.length / 2; _i++) {\n        p[_i] = {\n          x: centerX + halfW * points[_i * 2],\n          y: centerY + halfH * points[_i * 2 + 1]\n        };\n      }\n      var i,\n        p1,\n        p2,\n        p3,\n        len = p.length;\n      p1 = p[len - 1];\n      // for each point\n      for (i = 0; i < len; i++) {\n        p2 = p[i % len];\n        p3 = p[(i + 1) % len];\n        rs[field][i] = getRoundCorner(p1, p2, p3, cornerRadius);\n        p1 = p2;\n        p2 = p3;\n      }\n      return rs[field];\n    },\n    draw: function draw(context, centerX, centerY, width, height, cornerRadius, rs) {\n      this.renderer.nodeShapeImpl('round-polygon', context, centerX, centerY, width, height, this.points, this.getOrCreateCorners(centerX, centerY, width, height, cornerRadius, rs, 'drawCorners'));\n    },\n    intersectLine: function intersectLine(nodeX, nodeY, width, height, x, y, padding, cornerRadius, rs) {\n      return roundPolygonIntersectLine(x, y, this.points, nodeX, nodeY, width, height, padding, this.getOrCreateCorners(nodeX, nodeY, width, height, cornerRadius, rs, 'corners'));\n    },\n    checkPoint: function checkPoint(x, y, padding, width, height, centerX, centerY, cornerRadius, rs) {\n      return pointInsideRoundPolygon(x, y, this.points, centerX, centerY, width, height, this.getOrCreateCorners(centerX, centerY, width, height, cornerRadius, rs, 'corners'));\n    }\n  };\n};\nBRp$2.generateRoundRectangle = function () {\n  return this.nodeShapes['round-rectangle'] = this.nodeShapes['roundrectangle'] = {\n    renderer: this,\n    name: 'round-rectangle',\n    points: generateUnitNgonPointsFitToSquare(4, 0),\n    draw: function draw(context, centerX, centerY, width, height, cornerRadius) {\n      this.renderer.nodeShapeImpl(this.name, context, centerX, centerY, width, height, this.points, cornerRadius);\n    },\n    intersectLine: function intersectLine(nodeX, nodeY, width, height, x, y, padding, cornerRadius) {\n      return roundRectangleIntersectLine(x, y, nodeX, nodeY, width, height, padding, cornerRadius);\n    },\n    checkPoint: function checkPoint(x, y, padding, width, height, centerX, centerY, cornerRadius) {\n      var halfWidth = width / 2;\n      var halfHeight = height / 2;\n      cornerRadius = cornerRadius === 'auto' ? getRoundRectangleRadius(width, height) : cornerRadius;\n      cornerRadius = Math.min(halfWidth, halfHeight, cornerRadius);\n      var diam = cornerRadius * 2;\n\n      // Check hBox\n      if (pointInsidePolygon(x, y, this.points, centerX, centerY, width, height - diam, [0, -1], padding)) {\n        return true;\n      }\n\n      // Check vBox\n      if (pointInsidePolygon(x, y, this.points, centerX, centerY, width - diam, height, [0, -1], padding)) {\n        return true;\n      }\n\n      // Check top left quarter circle\n      if (checkInEllipse(x, y, diam, diam, centerX - halfWidth + cornerRadius, centerY - halfHeight + cornerRadius, padding)) {\n        return true;\n      }\n\n      // Check top right quarter circle\n      if (checkInEllipse(x, y, diam, diam, centerX + halfWidth - cornerRadius, centerY - halfHeight + cornerRadius, padding)) {\n        return true;\n      }\n\n      // Check bottom right quarter circle\n      if (checkInEllipse(x, y, diam, diam, centerX + halfWidth - cornerRadius, centerY + halfHeight - cornerRadius, padding)) {\n        return true;\n      }\n\n      // Check bottom left quarter circle\n      if (checkInEllipse(x, y, diam, diam, centerX - halfWidth + cornerRadius, centerY + halfHeight - cornerRadius, padding)) {\n        return true;\n      }\n      return false;\n    }\n  };\n};\nBRp$2.generateCutRectangle = function () {\n  return this.nodeShapes['cut-rectangle'] = this.nodeShapes['cutrectangle'] = {\n    renderer: this,\n    name: 'cut-rectangle',\n    cornerLength: getCutRectangleCornerLength(),\n    points: generateUnitNgonPointsFitToSquare(4, 0),\n    draw: function draw(context, centerX, centerY, width, height, cornerRadius) {\n      this.renderer.nodeShapeImpl(this.name, context, centerX, centerY, width, height, null, cornerRadius);\n    },\n    generateCutTrianglePts: function generateCutTrianglePts(width, height, centerX, centerY, cornerRadius) {\n      var cl = cornerRadius === 'auto' ? this.cornerLength : cornerRadius;\n      var hh = height / 2;\n      var hw = width / 2;\n      var xBegin = centerX - hw;\n      var xEnd = centerX + hw;\n      var yBegin = centerY - hh;\n      var yEnd = centerY + hh;\n\n      // points are in clockwise order, inner (imaginary) triangle pt on [4, 5]\n      return {\n        topLeft: [xBegin, yBegin + cl, xBegin + cl, yBegin, xBegin + cl, yBegin + cl],\n        topRight: [xEnd - cl, yBegin, xEnd, yBegin + cl, xEnd - cl, yBegin + cl],\n        bottomRight: [xEnd, yEnd - cl, xEnd - cl, yEnd, xEnd - cl, yEnd - cl],\n        bottomLeft: [xBegin + cl, yEnd, xBegin, yEnd - cl, xBegin + cl, yEnd - cl]\n      };\n    },\n    intersectLine: function intersectLine(nodeX, nodeY, width, height, x, y, padding, cornerRadius) {\n      var cPts = this.generateCutTrianglePts(width + 2 * padding, height + 2 * padding, nodeX, nodeY, cornerRadius);\n      var pts = [].concat.apply([], [cPts.topLeft.splice(0, 4), cPts.topRight.splice(0, 4), cPts.bottomRight.splice(0, 4), cPts.bottomLeft.splice(0, 4)]);\n      return polygonIntersectLine(x, y, pts, nodeX, nodeY);\n    },\n    checkPoint: function checkPoint(x, y, padding, width, height, centerX, centerY, cornerRadius) {\n      var cl = cornerRadius === 'auto' ? this.cornerLength : cornerRadius;\n      // Check hBox\n      if (pointInsidePolygon(x, y, this.points, centerX, centerY, width, height - 2 * cl, [0, -1], padding)) {\n        return true;\n      }\n\n      // Check vBox\n      if (pointInsidePolygon(x, y, this.points, centerX, centerY, width - 2 * cl, height, [0, -1], padding)) {\n        return true;\n      }\n      var cutTrianglePts = this.generateCutTrianglePts(width, height, centerX, centerY);\n      return pointInsidePolygonPoints(x, y, cutTrianglePts.topLeft) || pointInsidePolygonPoints(x, y, cutTrianglePts.topRight) || pointInsidePolygonPoints(x, y, cutTrianglePts.bottomRight) || pointInsidePolygonPoints(x, y, cutTrianglePts.bottomLeft);\n    }\n  };\n};\nBRp$2.generateBarrel = function () {\n  return this.nodeShapes['barrel'] = {\n    renderer: this,\n    name: 'barrel',\n    points: generateUnitNgonPointsFitToSquare(4, 0),\n    draw: function draw(context, centerX, centerY, width, height, cornerRadius) {\n      this.renderer.nodeShapeImpl(this.name, context, centerX, centerY, width, height);\n    },\n    intersectLine: function intersectLine(nodeX, nodeY, width, height, x, y, padding, cornerRadius) {\n      // use two fixed t values for the bezier curve approximation\n\n      var t0 = 0.15;\n      var t1 = 0.5;\n      var t2 = 0.85;\n      var bPts = this.generateBarrelBezierPts(width + 2 * padding, height + 2 * padding, nodeX, nodeY);\n      var approximateBarrelCurvePts = function approximateBarrelCurvePts(pts) {\n        // approximate curve pts based on the two t values\n        var m0 = qbezierPtAt({\n          x: pts[0],\n          y: pts[1]\n        }, {\n          x: pts[2],\n          y: pts[3]\n        }, {\n          x: pts[4],\n          y: pts[5]\n        }, t0);\n        var m1 = qbezierPtAt({\n          x: pts[0],\n          y: pts[1]\n        }, {\n          x: pts[2],\n          y: pts[3]\n        }, {\n          x: pts[4],\n          y: pts[5]\n        }, t1);\n        var m2 = qbezierPtAt({\n          x: pts[0],\n          y: pts[1]\n        }, {\n          x: pts[2],\n          y: pts[3]\n        }, {\n          x: pts[4],\n          y: pts[5]\n        }, t2);\n        return [pts[0], pts[1], m0.x, m0.y, m1.x, m1.y, m2.x, m2.y, pts[4], pts[5]];\n      };\n      var pts = [].concat(approximateBarrelCurvePts(bPts.topLeft), approximateBarrelCurvePts(bPts.topRight), approximateBarrelCurvePts(bPts.bottomRight), approximateBarrelCurvePts(bPts.bottomLeft));\n      return polygonIntersectLine(x, y, pts, nodeX, nodeY);\n    },\n    generateBarrelBezierPts: function generateBarrelBezierPts(width, height, centerX, centerY) {\n      var hh = height / 2;\n      var hw = width / 2;\n      var xBegin = centerX - hw;\n      var xEnd = centerX + hw;\n      var yBegin = centerY - hh;\n      var yEnd = centerY + hh;\n      var curveConstants = getBarrelCurveConstants(width, height);\n      var hOffset = curveConstants.heightOffset;\n      var wOffset = curveConstants.widthOffset;\n      var ctrlPtXOffset = curveConstants.ctrlPtOffsetPct * width;\n\n      // points are in clockwise order, inner (imaginary) control pt on [4, 5]\n      var pts = {\n        topLeft: [xBegin, yBegin + hOffset, xBegin + ctrlPtXOffset, yBegin, xBegin + wOffset, yBegin],\n        topRight: [xEnd - wOffset, yBegin, xEnd - ctrlPtXOffset, yBegin, xEnd, yBegin + hOffset],\n        bottomRight: [xEnd, yEnd - hOffset, xEnd - ctrlPtXOffset, yEnd, xEnd - wOffset, yEnd],\n        bottomLeft: [xBegin + wOffset, yEnd, xBegin + ctrlPtXOffset, yEnd, xBegin, yEnd - hOffset]\n      };\n      pts.topLeft.isTop = true;\n      pts.topRight.isTop = true;\n      pts.bottomLeft.isBottom = true;\n      pts.bottomRight.isBottom = true;\n      return pts;\n    },\n    checkPoint: function checkPoint(x, y, padding, width, height, centerX, centerY, cornerRadius) {\n      var curveConstants = getBarrelCurveConstants(width, height);\n      var hOffset = curveConstants.heightOffset;\n      var wOffset = curveConstants.widthOffset;\n\n      // Check hBox\n      if (pointInsidePolygon(x, y, this.points, centerX, centerY, width, height - 2 * hOffset, [0, -1], padding)) {\n        return true;\n      }\n\n      // Check vBox\n      if (pointInsidePolygon(x, y, this.points, centerX, centerY, width - 2 * wOffset, height, [0, -1], padding)) {\n        return true;\n      }\n      var barrelCurvePts = this.generateBarrelBezierPts(width, height, centerX, centerY);\n      var getCurveT = function getCurveT(x, y, curvePts) {\n        var x0 = curvePts[4];\n        var x1 = curvePts[2];\n        var x2 = curvePts[0];\n        var y0 = curvePts[5];\n        // var y1 = curvePts[ 3 ];\n        var y2 = curvePts[1];\n        var xMin = Math.min(x0, x2);\n        var xMax = Math.max(x0, x2);\n        var yMin = Math.min(y0, y2);\n        var yMax = Math.max(y0, y2);\n        if (xMin <= x && x <= xMax && yMin <= y && y <= yMax) {\n          var coeff = bezierPtsToQuadCoeff(x0, x1, x2);\n          var roots = solveQuadratic(coeff[0], coeff[1], coeff[2], x);\n          var validRoots = roots.filter(function (r) {\n            return 0 <= r && r <= 1;\n          });\n          if (validRoots.length > 0) {\n            return validRoots[0];\n          }\n        }\n        return null;\n      };\n      var curveRegions = Object.keys(barrelCurvePts);\n      for (var i = 0; i < curveRegions.length; i++) {\n        var corner = curveRegions[i];\n        var cornerPts = barrelCurvePts[corner];\n        var t = getCurveT(x, y, cornerPts);\n        if (t == null) {\n          continue;\n        }\n        var y0 = cornerPts[5];\n        var y1 = cornerPts[3];\n        var y2 = cornerPts[1];\n        var bezY = qbezierAt(y0, y1, y2, t);\n        if (cornerPts.isTop && bezY <= y) {\n          return true;\n        }\n        if (cornerPts.isBottom && y <= bezY) {\n          return true;\n        }\n      }\n      return false;\n    }\n  };\n};\nBRp$2.generateBottomRoundrectangle = function () {\n  return this.nodeShapes['bottom-round-rectangle'] = this.nodeShapes['bottomroundrectangle'] = {\n    renderer: this,\n    name: 'bottom-round-rectangle',\n    points: generateUnitNgonPointsFitToSquare(4, 0),\n    draw: function draw(context, centerX, centerY, width, height, cornerRadius) {\n      this.renderer.nodeShapeImpl(this.name, context, centerX, centerY, width, height, this.points, cornerRadius);\n    },\n    intersectLine: function intersectLine(nodeX, nodeY, width, height, x, y, padding, cornerRadius) {\n      var topStartX = nodeX - (width / 2 + padding);\n      var topStartY = nodeY - (height / 2 + padding);\n      var topEndY = topStartY;\n      var topEndX = nodeX + (width / 2 + padding);\n      var topIntersections = finiteLinesIntersect(x, y, nodeX, nodeY, topStartX, topStartY, topEndX, topEndY, false);\n      if (topIntersections.length > 0) {\n        return topIntersections;\n      }\n      return roundRectangleIntersectLine(x, y, nodeX, nodeY, width, height, padding, cornerRadius);\n    },\n    checkPoint: function checkPoint(x, y, padding, width, height, centerX, centerY, cornerRadius) {\n      cornerRadius = cornerRadius === 'auto' ? getRoundRectangleRadius(width, height) : cornerRadius;\n      var diam = 2 * cornerRadius;\n\n      // Check hBox\n      if (pointInsidePolygon(x, y, this.points, centerX, centerY, width, height - diam, [0, -1], padding)) {\n        return true;\n      }\n\n      // Check vBox\n      if (pointInsidePolygon(x, y, this.points, centerX, centerY, width - diam, height, [0, -1], padding)) {\n        return true;\n      }\n\n      // check non-rounded top side\n      var outerWidth = width / 2 + 2 * padding;\n      var outerHeight = height / 2 + 2 * padding;\n      var points = [centerX - outerWidth, centerY - outerHeight, centerX - outerWidth, centerY, centerX + outerWidth, centerY, centerX + outerWidth, centerY - outerHeight];\n      if (pointInsidePolygonPoints(x, y, points)) {\n        return true;\n      }\n\n      // Check bottom right quarter circle\n      if (checkInEllipse(x, y, diam, diam, centerX + width / 2 - cornerRadius, centerY + height / 2 - cornerRadius, padding)) {\n        return true;\n      }\n\n      // Check bottom left quarter circle\n      if (checkInEllipse(x, y, diam, diam, centerX - width / 2 + cornerRadius, centerY + height / 2 - cornerRadius, padding)) {\n        return true;\n      }\n      return false;\n    }\n  };\n};\nBRp$2.registerNodeShapes = function () {\n  var nodeShapes = this.nodeShapes = {};\n  var renderer = this;\n  this.generateEllipse();\n  this.generatePolygon('triangle', generateUnitNgonPointsFitToSquare(3, 0));\n  this.generateRoundPolygon('round-triangle', generateUnitNgonPointsFitToSquare(3, 0));\n  this.generatePolygon('rectangle', generateUnitNgonPointsFitToSquare(4, 0));\n  nodeShapes['square'] = nodeShapes['rectangle'];\n  this.generateRoundRectangle();\n  this.generateCutRectangle();\n  this.generateBarrel();\n  this.generateBottomRoundrectangle();\n  {\n    var diamondPoints = [0, 1, 1, 0, 0, -1, -1, 0];\n    this.generatePolygon('diamond', diamondPoints);\n    this.generateRoundPolygon('round-diamond', diamondPoints);\n  }\n  this.generatePolygon('pentagon', generateUnitNgonPointsFitToSquare(5, 0));\n  this.generateRoundPolygon('round-pentagon', generateUnitNgonPointsFitToSquare(5, 0));\n  this.generatePolygon('hexagon', generateUnitNgonPointsFitToSquare(6, 0));\n  this.generateRoundPolygon('round-hexagon', generateUnitNgonPointsFitToSquare(6, 0));\n  this.generatePolygon('heptagon', generateUnitNgonPointsFitToSquare(7, 0));\n  this.generateRoundPolygon('round-heptagon', generateUnitNgonPointsFitToSquare(7, 0));\n  this.generatePolygon('octagon', generateUnitNgonPointsFitToSquare(8, 0));\n  this.generateRoundPolygon('round-octagon', generateUnitNgonPointsFitToSquare(8, 0));\n  var star5Points = new Array(20);\n  {\n    var outerPoints = generateUnitNgonPoints(5, 0);\n    var innerPoints = generateUnitNgonPoints(5, Math.PI / 5);\n\n    // Outer radius is 1; inner radius of star is smaller\n    var innerRadius = 0.5 * (3 - Math.sqrt(5));\n    innerRadius *= 1.57;\n    for (var i = 0; i < innerPoints.length / 2; i++) {\n      innerPoints[i * 2] *= innerRadius;\n      innerPoints[i * 2 + 1] *= innerRadius;\n    }\n    for (var i = 0; i < 20 / 4; i++) {\n      star5Points[i * 4] = outerPoints[i * 2];\n      star5Points[i * 4 + 1] = outerPoints[i * 2 + 1];\n      star5Points[i * 4 + 2] = innerPoints[i * 2];\n      star5Points[i * 4 + 3] = innerPoints[i * 2 + 1];\n    }\n  }\n  star5Points = fitPolygonToSquare(star5Points);\n  this.generatePolygon('star', star5Points);\n  this.generatePolygon('vee', [-1, -1, 0, -0.333, 1, -1, 0, 1]);\n  this.generatePolygon('rhomboid', [-1, -1, 0.333, -1, 1, 1, -0.333, 1]);\n  this.generatePolygon('right-rhomboid', [-0.333, -1, 1, -1, 0.333, 1, -1, 1]);\n  this.nodeShapes['concavehexagon'] = this.generatePolygon('concave-hexagon', [-1, -0.95, -0.75, 0, -1, 0.95, 1, 0.95, 0.75, 0, 1, -0.95]);\n  {\n    var tagPoints = [-1, -1, 0.25, -1, 1, 0, 0.25, 1, -1, 1];\n    this.generatePolygon('tag', tagPoints);\n    this.generateRoundPolygon('round-tag', tagPoints);\n  }\n  nodeShapes.makePolygon = function (points) {\n    // use caching on user-specified polygons so they are as fast as native shapes\n\n    var key = points.join('$');\n    var name = 'polygon-' + key;\n    var shape;\n    if (shape = this[name]) {\n      // got cached shape\n      return shape;\n    }\n\n    // create and cache new shape\n    return renderer.generatePolygon(name, points);\n  };\n};\n\nvar BRp$1 = {};\nBRp$1.timeToRender = function () {\n  return this.redrawTotalTime / this.redrawCount;\n};\nBRp$1.redraw = function (options) {\n  options = options || staticEmptyObject();\n  var r = this;\n  if (r.averageRedrawTime === undefined) {\n    r.averageRedrawTime = 0;\n  }\n  if (r.lastRedrawTime === undefined) {\n    r.lastRedrawTime = 0;\n  }\n  if (r.lastDrawTime === undefined) {\n    r.lastDrawTime = 0;\n  }\n  r.requestedFrame = true;\n  r.renderOptions = options;\n};\nBRp$1.beforeRender = function (fn, priority) {\n  // the renderer can't add tick callbacks when destroyed\n  if (this.destroyed) {\n    return;\n  }\n  if (priority == null) {\n    error('Priority is not optional for beforeRender');\n  }\n  var cbs = this.beforeRenderCallbacks;\n  cbs.push({\n    fn: fn,\n    priority: priority\n  });\n\n  // higher priority callbacks executed first\n  cbs.sort(function (a, b) {\n    return b.priority - a.priority;\n  });\n};\nvar beforeRenderCallbacks = function beforeRenderCallbacks(r, willDraw, startTime) {\n  var cbs = r.beforeRenderCallbacks;\n  for (var i = 0; i < cbs.length; i++) {\n    cbs[i].fn(willDraw, startTime);\n  }\n};\nBRp$1.startRenderLoop = function () {\n  var r = this;\n  var cy = r.cy;\n  if (r.renderLoopStarted) {\n    return;\n  } else {\n    r.renderLoopStarted = true;\n  }\n  var renderFn = function renderFn(requestTime) {\n    if (r.destroyed) {\n      return;\n    }\n    if (cy.batching()) ; else if (r.requestedFrame && !r.skipFrame) {\n      beforeRenderCallbacks(r, true, requestTime);\n      var startTime = performanceNow();\n      r.render(r.renderOptions);\n      var endTime = r.lastDrawTime = performanceNow();\n      if (r.averageRedrawTime === undefined) {\n        r.averageRedrawTime = endTime - startTime;\n      }\n      if (r.redrawCount === undefined) {\n        r.redrawCount = 0;\n      }\n      r.redrawCount++;\n      if (r.redrawTotalTime === undefined) {\n        r.redrawTotalTime = 0;\n      }\n      var duration = endTime - startTime;\n      r.redrawTotalTime += duration;\n      r.lastRedrawTime = duration;\n\n      // use a weighted average with a bias from the previous average so we don't spike so easily\n      r.averageRedrawTime = r.averageRedrawTime / 2 + duration / 2;\n      r.requestedFrame = false;\n    } else {\n      beforeRenderCallbacks(r, false, requestTime);\n    }\n    r.skipFrame = false;\n    requestAnimationFrame(renderFn);\n  };\n  requestAnimationFrame(renderFn);\n};\n\nvar BaseRenderer = function BaseRenderer(options) {\n  this.init(options);\n};\nvar BR = BaseRenderer;\nvar BRp = BR.prototype;\nBRp.clientFunctions = ['redrawHint', 'render', 'renderTo', 'matchCanvasSize', 'nodeShapeImpl', 'arrowShapeImpl'];\nBRp.init = function (options) {\n  var r = this;\n  r.options = options;\n  r.cy = options.cy;\n  var ctr = r.container = options.cy.container();\n  var containerWindow = r.cy.window();\n\n  // prepend a stylesheet in the head such that\n  if (containerWindow) {\n    var document = containerWindow.document;\n    var head = document.head;\n    var stylesheetId = '__________cytoscape_stylesheet';\n    var className = '__________cytoscape_container';\n    var stylesheetAlreadyExists = document.getElementById(stylesheetId) != null;\n    if (ctr.className.indexOf(className) < 0) {\n      ctr.className = (ctr.className || '') + ' ' + className;\n    }\n    if (!stylesheetAlreadyExists) {\n      var stylesheet = document.createElement('style');\n      stylesheet.id = stylesheetId;\n      stylesheet.textContent = '.' + className + ' { position: relative; }';\n      head.insertBefore(stylesheet, head.children[0]); // first so lowest priority\n    }\n\n    var computedStyle = containerWindow.getComputedStyle(ctr);\n    var position = computedStyle.getPropertyValue('position');\n    if (position === 'static') {\n      warn('A Cytoscape container has style position:static and so can not use UI extensions properly');\n    }\n  }\n  r.selection = [undefined, undefined, undefined, undefined, 0]; // Coordinates for selection box, plus enabled flag\n\n  r.bezierProjPcts = [0.05, 0.225, 0.4, 0.5, 0.6, 0.775, 0.95];\n\n  //--Pointer-related data\n  r.hoverData = {\n    down: null,\n    last: null,\n    downTime: null,\n    triggerMode: null,\n    dragging: false,\n    initialPan: [null, null],\n    capture: false\n  };\n  r.dragData = {\n    possibleDragElements: []\n  };\n  r.touchData = {\n    start: null,\n    capture: false,\n    // These 3 fields related to tap, taphold events\n    startPosition: [null, null, null, null, null, null],\n    singleTouchStartTime: null,\n    singleTouchMoved: true,\n    now: [null, null, null, null, null, null],\n    earlier: [null, null, null, null, null, null]\n  };\n  r.redraws = 0;\n  r.showFps = options.showFps;\n  r.debug = options.debug;\n  r.hideEdgesOnViewport = options.hideEdgesOnViewport;\n  r.textureOnViewport = options.textureOnViewport;\n  r.wheelSensitivity = options.wheelSensitivity;\n  r.motionBlurEnabled = options.motionBlur; // on by default\n  r.forcedPixelRatio = number$1(options.pixelRatio) ? options.pixelRatio : null;\n  r.motionBlur = options.motionBlur; // for initial kick off\n  r.motionBlurOpacity = options.motionBlurOpacity;\n  r.motionBlurTransparency = 1 - r.motionBlurOpacity;\n  r.motionBlurPxRatio = 1;\n  r.mbPxRBlurry = 1; //0.8;\n  r.minMbLowQualFrames = 4;\n  r.fullQualityMb = false;\n  r.clearedForMotionBlur = [];\n  r.desktopTapThreshold = options.desktopTapThreshold;\n  r.desktopTapThreshold2 = options.desktopTapThreshold * options.desktopTapThreshold;\n  r.touchTapThreshold = options.touchTapThreshold;\n  r.touchTapThreshold2 = options.touchTapThreshold * options.touchTapThreshold;\n  r.tapholdDuration = 500;\n  r.bindings = [];\n  r.beforeRenderCallbacks = [];\n  r.beforeRenderPriorities = {\n    // higher priority execs before lower one\n    animations: 400,\n    eleCalcs: 300,\n    eleTxrDeq: 200,\n    lyrTxrDeq: 150,\n    lyrTxrSkip: 100\n  };\n  r.registerNodeShapes();\n  r.registerArrowShapes();\n  r.registerCalculationListeners();\n};\nBRp.notify = function (eventName, eles) {\n  var r = this;\n  var cy = r.cy;\n\n  // the renderer can't be notified after it's destroyed\n  if (this.destroyed) {\n    return;\n  }\n  if (eventName === 'init') {\n    r.load();\n    return;\n  }\n  if (eventName === 'destroy') {\n    r.destroy();\n    return;\n  }\n  if (eventName === 'add' || eventName === 'remove' || eventName === 'move' && cy.hasCompoundNodes() || eventName === 'load' || eventName === 'zorder' || eventName === 'mount') {\n    r.invalidateCachedZSortedEles();\n  }\n  if (eventName === 'viewport') {\n    r.redrawHint('select', true);\n  }\n  if (eventName === 'load' || eventName === 'resize' || eventName === 'mount') {\n    r.invalidateContainerClientCoordsCache();\n    r.matchCanvasSize(r.container);\n  }\n  r.redrawHint('eles', true);\n  r.redrawHint('drag', true);\n  this.startRenderLoop();\n  this.redraw();\n};\nBRp.destroy = function () {\n  var r = this;\n  r.destroyed = true;\n  r.cy.stopAnimationLoop();\n  for (var i = 0; i < r.bindings.length; i++) {\n    var binding = r.bindings[i];\n    var b = binding;\n    var tgt = b.target;\n    (tgt.off || tgt.removeEventListener).apply(tgt, b.args);\n  }\n  r.bindings = [];\n  r.beforeRenderCallbacks = [];\n  r.onUpdateEleCalcsFns = [];\n  if (r.removeObserver) {\n    r.removeObserver.disconnect();\n  }\n  if (r.styleObserver) {\n    r.styleObserver.disconnect();\n  }\n  if (r.resizeObserver) {\n    r.resizeObserver.disconnect();\n  }\n  if (r.labelCalcDiv) {\n    try {\n      document.body.removeChild(r.labelCalcDiv); // eslint-disable-line no-undef\n    } catch (e) {\n      // ie10 issue #1014\n    }\n  }\n};\nBRp.isHeadless = function () {\n  return false;\n};\n[BRp$f, BRp$5, BRp$4, BRp$3, BRp$2, BRp$1].forEach(function (props) {\n  extend(BRp, props);\n});\n\nvar fullFpsTime = 1000 / 60; // assume 60 frames per second\n\nvar defs = {\n  setupDequeueing: function setupDequeueing(opts) {\n    return function setupDequeueingImpl() {\n      var self = this;\n      var r = this.renderer;\n      if (self.dequeueingSetup) {\n        return;\n      } else {\n        self.dequeueingSetup = true;\n      }\n      var queueRedraw = debounce_1(function () {\n        r.redrawHint('eles', true);\n        r.redrawHint('drag', true);\n        r.redraw();\n      }, opts.deqRedrawThreshold);\n      var dequeue = function dequeue(willDraw, frameStartTime) {\n        var startTime = performanceNow();\n        var avgRenderTime = r.averageRedrawTime;\n        var renderTime = r.lastRedrawTime;\n        var deqd = [];\n        var extent = r.cy.extent();\n        var pixelRatio = r.getPixelRatio();\n\n        // if we aren't in a tick that causes a draw, then the rendered style\n        // queue won't automatically be flushed before dequeueing starts\n        if (!willDraw) {\n          r.flushRenderedStyleQueue();\n        }\n        while (true) {\n          // eslint-disable-line no-constant-condition\n          var now = performanceNow();\n          var duration = now - startTime;\n          var frameDuration = now - frameStartTime;\n          if (renderTime < fullFpsTime) {\n            // if we're rendering faster than the ideal fps, then do dequeueing\n            // during all of the remaining frame time\n\n            var timeAvailable = fullFpsTime - (willDraw ? avgRenderTime : 0);\n            if (frameDuration >= opts.deqFastCost * timeAvailable) {\n              break;\n            }\n          } else {\n            if (willDraw) {\n              if (duration >= opts.deqCost * renderTime || duration >= opts.deqAvgCost * avgRenderTime) {\n                break;\n              }\n            } else if (frameDuration >= opts.deqNoDrawCost * fullFpsTime) {\n              break;\n            }\n          }\n          var thisDeqd = opts.deq(self, pixelRatio, extent);\n          if (thisDeqd.length > 0) {\n            for (var i = 0; i < thisDeqd.length; i++) {\n              deqd.push(thisDeqd[i]);\n            }\n          } else {\n            break;\n          }\n        }\n\n        // callbacks on dequeue\n        if (deqd.length > 0) {\n          opts.onDeqd(self, deqd);\n          if (!willDraw && opts.shouldRedraw(self, deqd, pixelRatio, extent)) {\n            queueRedraw();\n          }\n        }\n      };\n      var priority = opts.priority || noop$1;\n      r.beforeRender(dequeue, priority(self));\n    };\n  }\n};\n\n// Allows lookups for (ele, lvl) => cache.\n// Uses keys so elements may share the same cache.\nvar ElementTextureCacheLookup = /*#__PURE__*/function () {\n  function ElementTextureCacheLookup(getKey) {\n    var doesEleInvalidateKey = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : falsify;\n    _classCallCheck(this, ElementTextureCacheLookup);\n    this.idsByKey = new Map$2();\n    this.keyForId = new Map$2();\n    this.cachesByLvl = new Map$2();\n    this.lvls = [];\n    this.getKey = getKey;\n    this.doesEleInvalidateKey = doesEleInvalidateKey;\n  }\n  _createClass(ElementTextureCacheLookup, [{\n    key: \"getIdsFor\",\n    value: function getIdsFor(key) {\n      if (key == null) {\n        error(\"Can not get id list for null key\");\n      }\n      var idsByKey = this.idsByKey;\n      var ids = this.idsByKey.get(key);\n      if (!ids) {\n        ids = new Set$1();\n        idsByKey.set(key, ids);\n      }\n      return ids;\n    }\n  }, {\n    key: \"addIdForKey\",\n    value: function addIdForKey(key, id) {\n      if (key != null) {\n        this.getIdsFor(key).add(id);\n      }\n    }\n  }, {\n    key: \"deleteIdForKey\",\n    value: function deleteIdForKey(key, id) {\n      if (key != null) {\n        this.getIdsFor(key)[\"delete\"](id);\n      }\n    }\n  }, {\n    key: \"getNumberOfIdsForKey\",\n    value: function getNumberOfIdsForKey(key) {\n      if (key == null) {\n        return 0;\n      } else {\n        return this.getIdsFor(key).size;\n      }\n    }\n  }, {\n    key: \"updateKeyMappingFor\",\n    value: function updateKeyMappingFor(ele) {\n      var id = ele.id();\n      var prevKey = this.keyForId.get(id);\n      var currKey = this.getKey(ele);\n      this.deleteIdForKey(prevKey, id);\n      this.addIdForKey(currKey, id);\n      this.keyForId.set(id, currKey);\n    }\n  }, {\n    key: \"deleteKeyMappingFor\",\n    value: function deleteKeyMappingFor(ele) {\n      var id = ele.id();\n      var prevKey = this.keyForId.get(id);\n      this.deleteIdForKey(prevKey, id);\n      this.keyForId[\"delete\"](id);\n    }\n  }, {\n    key: \"keyHasChangedFor\",\n    value: function keyHasChangedFor(ele) {\n      var id = ele.id();\n      var prevKey = this.keyForId.get(id);\n      var newKey = this.getKey(ele);\n      return prevKey !== newKey;\n    }\n  }, {\n    key: \"isInvalid\",\n    value: function isInvalid(ele) {\n      return this.keyHasChangedFor(ele) || this.doesEleInvalidateKey(ele);\n    }\n  }, {\n    key: \"getCachesAt\",\n    value: function getCachesAt(lvl) {\n      var cachesByLvl = this.cachesByLvl,\n        lvls = this.lvls;\n      var caches = cachesByLvl.get(lvl);\n      if (!caches) {\n        caches = new Map$2();\n        cachesByLvl.set(lvl, caches);\n        lvls.push(lvl);\n      }\n      return caches;\n    }\n  }, {\n    key: \"getCache\",\n    value: function getCache(key, lvl) {\n      return this.getCachesAt(lvl).get(key);\n    }\n  }, {\n    key: \"get\",\n    value: function get(ele, lvl) {\n      var key = this.getKey(ele);\n      var cache = this.getCache(key, lvl);\n\n      // getting for an element may need to add to the id list b/c eles can share keys\n      if (cache != null) {\n        this.updateKeyMappingFor(ele);\n      }\n      return cache;\n    }\n  }, {\n    key: \"getForCachedKey\",\n    value: function getForCachedKey(ele, lvl) {\n      var key = this.keyForId.get(ele.id()); // n.b. use cached key, not newly computed key\n      var cache = this.getCache(key, lvl);\n      return cache;\n    }\n  }, {\n    key: \"hasCache\",\n    value: function hasCache(key, lvl) {\n      return this.getCachesAt(lvl).has(key);\n    }\n  }, {\n    key: \"has\",\n    value: function has(ele, lvl) {\n      var key = this.getKey(ele);\n      return this.hasCache(key, lvl);\n    }\n  }, {\n    key: \"setCache\",\n    value: function setCache(key, lvl, cache) {\n      cache.key = key;\n      this.getCachesAt(lvl).set(key, cache);\n    }\n  }, {\n    key: \"set\",\n    value: function set(ele, lvl, cache) {\n      var key = this.getKey(ele);\n      this.setCache(key, lvl, cache);\n      this.updateKeyMappingFor(ele);\n    }\n  }, {\n    key: \"deleteCache\",\n    value: function deleteCache(key, lvl) {\n      this.getCachesAt(lvl)[\"delete\"](key);\n    }\n  }, {\n    key: \"delete\",\n    value: function _delete(ele, lvl) {\n      var key = this.getKey(ele);\n      this.deleteCache(key, lvl);\n    }\n  }, {\n    key: \"invalidateKey\",\n    value: function invalidateKey(key) {\n      var _this = this;\n      this.lvls.forEach(function (lvl) {\n        return _this.deleteCache(key, lvl);\n      });\n    }\n\n    // returns true if no other eles reference the invalidated cache (n.b. other eles may need the cache with the same key)\n  }, {\n    key: \"invalidate\",\n    value: function invalidate(ele) {\n      var id = ele.id();\n      var key = this.keyForId.get(id); // n.b. use stored key rather than current (potential key)\n\n      this.deleteKeyMappingFor(ele);\n      var entireKeyInvalidated = this.doesEleInvalidateKey(ele);\n      if (entireKeyInvalidated) {\n        // clear mapping for current key\n        this.invalidateKey(key);\n      }\n      return entireKeyInvalidated || this.getNumberOfIdsForKey(key) === 0;\n    }\n  }]);\n  return ElementTextureCacheLookup;\n}();\n\nvar minTxrH = 25; // the size of the texture cache for small height eles (special case)\nvar txrStepH = 50; // the min size of the regular cache, and the size it increases with each step up\nvar minLvl$1 = -4; // when scaling smaller than that we don't need to re-render\nvar maxLvl$1 = 3; // when larger than this scale just render directly (caching is not helpful)\nvar maxZoom$1 = 7.99; // beyond this zoom level, layered textures are not used\nvar eleTxrSpacing = 8; // spacing between elements on textures to avoid blitting overlaps\nvar defTxrWidth = 1024; // default/minimum texture width\nvar maxTxrW = 1024; // the maximum width of a texture\nvar maxTxrH = 1024; // the maximum height of a texture\nvar minUtility = 0.2; // if usage of texture is less than this, it is retired\nvar maxFullness = 0.8; // fullness of texture after which queue removal is checked\nvar maxFullnessChecks = 10; // dequeued after this many checks\nvar deqCost$1 = 0.15; // % of add'l rendering cost allowed for dequeuing ele caches each frame\nvar deqAvgCost$1 = 0.1; // % of add'l rendering cost compared to average overall redraw time\nvar deqNoDrawCost$1 = 0.9; // % of avg frame time that can be used for dequeueing when not drawing\nvar deqFastCost$1 = 0.9; // % of frame time to be used when >60fps\nvar deqRedrawThreshold$1 = 100; // time to batch redraws together from dequeueing to allow more dequeueing calcs to happen in the meanwhile\nvar maxDeqSize$1 = 1; // number of eles to dequeue and render at higher texture in each batch\n\nvar getTxrReasons = {\n  dequeue: 'dequeue',\n  downscale: 'downscale',\n  highQuality: 'highQuality'\n};\nvar initDefaults = defaults$g({\n  getKey: null,\n  doesEleInvalidateKey: falsify,\n  drawElement: null,\n  getBoundingBox: null,\n  getRotationPoint: null,\n  getRotationOffset: null,\n  isVisible: trueify,\n  allowEdgeTxrCaching: true,\n  allowParentTxrCaching: true\n});\nvar ElementTextureCache = function ElementTextureCache(renderer, initOptions) {\n  var self = this;\n  self.renderer = renderer;\n  self.onDequeues = [];\n  var opts = initDefaults(initOptions);\n  extend(self, opts);\n  self.lookup = new ElementTextureCacheLookup(opts.getKey, opts.doesEleInvalidateKey);\n  self.setupDequeueing();\n};\nvar ETCp = ElementTextureCache.prototype;\nETCp.reasons = getTxrReasons;\n\n// the list of textures in which new subtextures for elements can be placed\nETCp.getTextureQueue = function (txrH) {\n  var self = this;\n  self.eleImgCaches = self.eleImgCaches || {};\n  return self.eleImgCaches[txrH] = self.eleImgCaches[txrH] || [];\n};\n\n// the list of usused textures which can be recycled (in use in texture queue)\nETCp.getRetiredTextureQueue = function (txrH) {\n  var self = this;\n  var rtxtrQs = self.eleImgCaches.retired = self.eleImgCaches.retired || {};\n  var rtxtrQ = rtxtrQs[txrH] = rtxtrQs[txrH] || [];\n  return rtxtrQ;\n};\n\n// queue of element draw requests at different scale levels\nETCp.getElementQueue = function () {\n  var self = this;\n  var q = self.eleCacheQueue = self.eleCacheQueue || new heap(function (a, b) {\n    return b.reqs - a.reqs;\n  });\n  return q;\n};\n\n// queue of element draw requests at different scale levels (element id lookup)\nETCp.getElementKeyToQueue = function () {\n  var self = this;\n  var k2q = self.eleKeyToCacheQueue = self.eleKeyToCacheQueue || {};\n  return k2q;\n};\nETCp.getElement = function (ele, bb, pxRatio, lvl, reason) {\n  var self = this;\n  var r = this.renderer;\n  var zoom = r.cy.zoom();\n  var lookup = this.lookup;\n  if (!bb || bb.w === 0 || bb.h === 0 || isNaN(bb.w) || isNaN(bb.h) || !ele.visible() || ele.removed()) {\n    return null;\n  }\n  if (!self.allowEdgeTxrCaching && ele.isEdge() || !self.allowParentTxrCaching && ele.isParent()) {\n    return null;\n  }\n  if (lvl == null) {\n    lvl = Math.ceil(log2(zoom * pxRatio));\n  }\n  if (lvl < minLvl$1) {\n    lvl = minLvl$1;\n  } else if (zoom >= maxZoom$1 || lvl > maxLvl$1) {\n    return null;\n  }\n  var scale = Math.pow(2, lvl);\n  var eleScaledH = bb.h * scale;\n  var eleScaledW = bb.w * scale;\n  var scaledLabelShown = r.eleTextBiggerThanMin(ele, scale);\n  if (!this.isVisible(ele, scaledLabelShown)) {\n    return null;\n  }\n  var eleCache = lookup.get(ele, lvl);\n\n  // if this get was on an unused/invalidated cache, then restore the texture usage metric\n  if (eleCache && eleCache.invalidated) {\n    eleCache.invalidated = false;\n    eleCache.texture.invalidatedWidth -= eleCache.width;\n  }\n  if (eleCache) {\n    return eleCache;\n  }\n  var txrH; // which texture height this ele belongs to\n\n  if (eleScaledH <= minTxrH) {\n    txrH = minTxrH;\n  } else if (eleScaledH <= txrStepH) {\n    txrH = txrStepH;\n  } else {\n    txrH = Math.ceil(eleScaledH / txrStepH) * txrStepH;\n  }\n  if (eleScaledH > maxTxrH || eleScaledW > maxTxrW) {\n    return null; // caching large elements is not efficient\n  }\n\n  var txrQ = self.getTextureQueue(txrH);\n\n  // first try the second last one in case it has space at the end\n  var txr = txrQ[txrQ.length - 2];\n  var addNewTxr = function addNewTxr() {\n    return self.recycleTexture(txrH, eleScaledW) || self.addTexture(txrH, eleScaledW);\n  };\n\n  // try the last one if there is no second last one\n  if (!txr) {\n    txr = txrQ[txrQ.length - 1];\n  }\n\n  // if the last one doesn't exist, we need a first one\n  if (!txr) {\n    txr = addNewTxr();\n  }\n\n  // if there's no room in the current texture, we need a new one\n  if (txr.width - txr.usedWidth < eleScaledW) {\n    txr = addNewTxr();\n  }\n  var scalableFrom = function scalableFrom(otherCache) {\n    return otherCache && otherCache.scaledLabelShown === scaledLabelShown;\n  };\n  var deqing = reason && reason === getTxrReasons.dequeue;\n  var highQualityReq = reason && reason === getTxrReasons.highQuality;\n  var downscaleReq = reason && reason === getTxrReasons.downscale;\n  var higherCache; // the nearest cache with a higher level\n  for (var l = lvl + 1; l <= maxLvl$1; l++) {\n    var c = lookup.get(ele, l);\n    if (c) {\n      higherCache = c;\n      break;\n    }\n  }\n  var oneUpCache = higherCache && higherCache.level === lvl + 1 ? higherCache : null;\n  var downscale = function downscale() {\n    txr.context.drawImage(oneUpCache.texture.canvas, oneUpCache.x, 0, oneUpCache.width, oneUpCache.height, txr.usedWidth, 0, eleScaledW, eleScaledH);\n  };\n\n  // reset ele area in texture\n  txr.context.setTransform(1, 0, 0, 1, 0, 0);\n  txr.context.clearRect(txr.usedWidth, 0, eleScaledW, txrH);\n  if (scalableFrom(oneUpCache)) {\n    // then we can relatively cheaply rescale the existing image w/o rerendering\n    downscale();\n  } else if (scalableFrom(higherCache)) {\n    // then use the higher cache for now and queue the next level down\n    // to cheaply scale towards the smaller level\n\n    if (highQualityReq) {\n      for (var _l = higherCache.level; _l > lvl; _l--) {\n        oneUpCache = self.getElement(ele, bb, pxRatio, _l, getTxrReasons.downscale);\n      }\n      downscale();\n    } else {\n      self.queueElement(ele, higherCache.level - 1);\n      return higherCache;\n    }\n  } else {\n    var lowerCache; // the nearest cache with a lower level\n    if (!deqing && !highQualityReq && !downscaleReq) {\n      for (var _l2 = lvl - 1; _l2 >= minLvl$1; _l2--) {\n        var _c = lookup.get(ele, _l2);\n        if (_c) {\n          lowerCache = _c;\n          break;\n        }\n      }\n    }\n    if (scalableFrom(lowerCache)) {\n      // then use the lower quality cache for now and queue the better one for later\n\n      self.queueElement(ele, lvl);\n      return lowerCache;\n    }\n    txr.context.translate(txr.usedWidth, 0);\n    txr.context.scale(scale, scale);\n    this.drawElement(txr.context, ele, bb, scaledLabelShown, false);\n    txr.context.scale(1 / scale, 1 / scale);\n    txr.context.translate(-txr.usedWidth, 0);\n  }\n  eleCache = {\n    x: txr.usedWidth,\n    texture: txr,\n    level: lvl,\n    scale: scale,\n    width: eleScaledW,\n    height: eleScaledH,\n    scaledLabelShown: scaledLabelShown\n  };\n  txr.usedWidth += Math.ceil(eleScaledW + eleTxrSpacing);\n  txr.eleCaches.push(eleCache);\n  lookup.set(ele, lvl, eleCache);\n  self.checkTextureFullness(txr);\n  return eleCache;\n};\nETCp.invalidateElements = function (eles) {\n  for (var i = 0; i < eles.length; i++) {\n    this.invalidateElement(eles[i]);\n  }\n};\nETCp.invalidateElement = function (ele) {\n  var self = this;\n  var lookup = self.lookup;\n  var caches = [];\n  var invalid = lookup.isInvalid(ele);\n  if (!invalid) {\n    return; // override the invalidation request if the element key has not changed\n  }\n\n  for (var lvl = minLvl$1; lvl <= maxLvl$1; lvl++) {\n    var cache = lookup.getForCachedKey(ele, lvl);\n    if (cache) {\n      caches.push(cache);\n    }\n  }\n  var noOtherElesUseCache = lookup.invalidate(ele);\n  if (noOtherElesUseCache) {\n    for (var i = 0; i < caches.length; i++) {\n      var _cache = caches[i];\n      var txr = _cache.texture;\n\n      // remove space from the texture it belongs to\n      txr.invalidatedWidth += _cache.width;\n\n      // mark the cache as invalidated\n      _cache.invalidated = true;\n\n      // retire the texture if its utility is low\n      self.checkTextureUtility(txr);\n    }\n  }\n\n  // remove from queue since the old req was for the old state\n  self.removeFromQueue(ele);\n};\nETCp.checkTextureUtility = function (txr) {\n  // invalidate all entries in the cache if the cache size is small\n  if (txr.invalidatedWidth >= minUtility * txr.width) {\n    this.retireTexture(txr);\n  }\n};\nETCp.checkTextureFullness = function (txr) {\n  // if texture has been mostly filled and passed over several times, remove\n  // it from the queue so we don't need to waste time looking at it to put new things\n\n  var self = this;\n  var txrQ = self.getTextureQueue(txr.height);\n  if (txr.usedWidth / txr.width > maxFullness && txr.fullnessChecks >= maxFullnessChecks) {\n    removeFromArray(txrQ, txr);\n  } else {\n    txr.fullnessChecks++;\n  }\n};\nETCp.retireTexture = function (txr) {\n  var self = this;\n  var txrH = txr.height;\n  var txrQ = self.getTextureQueue(txrH);\n  var lookup = this.lookup;\n\n  // retire the texture from the active / searchable queue:\n\n  removeFromArray(txrQ, txr);\n  txr.retired = true;\n\n  // remove the refs from the eles to the caches:\n\n  var eleCaches = txr.eleCaches;\n  for (var i = 0; i < eleCaches.length; i++) {\n    var eleCache = eleCaches[i];\n    lookup.deleteCache(eleCache.key, eleCache.level);\n  }\n  clearArray(eleCaches);\n\n  // add the texture to a retired queue so it can be recycled in future:\n\n  var rtxtrQ = self.getRetiredTextureQueue(txrH);\n  rtxtrQ.push(txr);\n};\nETCp.addTexture = function (txrH, minW) {\n  var self = this;\n  var txrQ = self.getTextureQueue(txrH);\n  var txr = {};\n  txrQ.push(txr);\n  txr.eleCaches = [];\n  txr.height = txrH;\n  txr.width = Math.max(defTxrWidth, minW);\n  txr.usedWidth = 0;\n  txr.invalidatedWidth = 0;\n  txr.fullnessChecks = 0;\n  txr.canvas = self.renderer.makeOffscreenCanvas(txr.width, txr.height);\n  txr.context = txr.canvas.getContext('2d');\n  return txr;\n};\nETCp.recycleTexture = function (txrH, minW) {\n  var self = this;\n  var txrQ = self.getTextureQueue(txrH);\n  var rtxtrQ = self.getRetiredTextureQueue(txrH);\n  for (var i = 0; i < rtxtrQ.length; i++) {\n    var txr = rtxtrQ[i];\n    if (txr.width >= minW) {\n      txr.retired = false;\n      txr.usedWidth = 0;\n      txr.invalidatedWidth = 0;\n      txr.fullnessChecks = 0;\n      clearArray(txr.eleCaches);\n      txr.context.setTransform(1, 0, 0, 1, 0, 0);\n      txr.context.clearRect(0, 0, txr.width, txr.height);\n      removeFromArray(rtxtrQ, txr);\n      txrQ.push(txr);\n      return txr;\n    }\n  }\n};\nETCp.queueElement = function (ele, lvl) {\n  var self = this;\n  var q = self.getElementQueue();\n  var k2q = self.getElementKeyToQueue();\n  var key = this.getKey(ele);\n  var existingReq = k2q[key];\n  if (existingReq) {\n    // use the max lvl b/c in between lvls are cheap to make\n    existingReq.level = Math.max(existingReq.level, lvl);\n    existingReq.eles.merge(ele);\n    existingReq.reqs++;\n    q.updateItem(existingReq);\n  } else {\n    var req = {\n      eles: ele.spawn().merge(ele),\n      level: lvl,\n      reqs: 1,\n      key: key\n    };\n    q.push(req);\n    k2q[key] = req;\n  }\n};\nETCp.dequeue = function (pxRatio /*, extent*/) {\n  var self = this;\n  var q = self.getElementQueue();\n  var k2q = self.getElementKeyToQueue();\n  var dequeued = [];\n  var lookup = self.lookup;\n  for (var i = 0; i < maxDeqSize$1; i++) {\n    if (q.size() > 0) {\n      var req = q.pop();\n      var key = req.key;\n      var ele = req.eles[0]; // all eles have the same key\n      var cacheExists = lookup.hasCache(ele, req.level);\n\n      // clear out the key to req lookup\n      k2q[key] = null;\n\n      // dequeueing isn't necessary with an existing cache\n      if (cacheExists) {\n        continue;\n      }\n      dequeued.push(req);\n      var bb = self.getBoundingBox(ele);\n      self.getElement(ele, bb, pxRatio, req.level, getTxrReasons.dequeue);\n    } else {\n      break;\n    }\n  }\n  return dequeued;\n};\nETCp.removeFromQueue = function (ele) {\n  var self = this;\n  var q = self.getElementQueue();\n  var k2q = self.getElementKeyToQueue();\n  var key = this.getKey(ele);\n  var req = k2q[key];\n  if (req != null) {\n    if (req.eles.length === 1) {\n      // remove if last ele in the req\n      // bring to front of queue\n      req.reqs = MAX_INT$1;\n      q.updateItem(req);\n      q.pop(); // remove from queue\n\n      k2q[key] = null; // remove from lookup map\n    } else {\n      // otherwise just remove ele from req\n      req.eles.unmerge(ele);\n    }\n  }\n};\nETCp.onDequeue = function (fn) {\n  this.onDequeues.push(fn);\n};\nETCp.offDequeue = function (fn) {\n  removeFromArray(this.onDequeues, fn);\n};\nETCp.setupDequeueing = defs.setupDequeueing({\n  deqRedrawThreshold: deqRedrawThreshold$1,\n  deqCost: deqCost$1,\n  deqAvgCost: deqAvgCost$1,\n  deqNoDrawCost: deqNoDrawCost$1,\n  deqFastCost: deqFastCost$1,\n  deq: function deq(self, pxRatio, extent) {\n    return self.dequeue(pxRatio, extent);\n  },\n  onDeqd: function onDeqd(self, deqd) {\n    for (var i = 0; i < self.onDequeues.length; i++) {\n      var fn = self.onDequeues[i];\n      fn(deqd);\n    }\n  },\n  shouldRedraw: function shouldRedraw(self, deqd, pxRatio, extent) {\n    for (var i = 0; i < deqd.length; i++) {\n      var eles = deqd[i].eles;\n      for (var j = 0; j < eles.length; j++) {\n        var bb = eles[j].boundingBox();\n        if (boundingBoxesIntersect(bb, extent)) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  priority: function priority(self) {\n    return self.renderer.beforeRenderPriorities.eleTxrDeq;\n  }\n});\n\nvar defNumLayers = 1; // default number of layers to use\nvar minLvl = -4; // when scaling smaller than that we don't need to re-render\nvar maxLvl = 2; // when larger than this scale just render directly (caching is not helpful)\nvar maxZoom = 3.99; // beyond this zoom level, layered textures are not used\nvar deqRedrawThreshold = 50; // time to batch redraws together from dequeueing to allow more dequeueing calcs to happen in the meanwhile\nvar refineEleDebounceTime = 50; // time to debounce sharper ele texture updates\nvar deqCost = 0.15; // % of add'l rendering cost allowed for dequeuing ele caches each frame\nvar deqAvgCost = 0.1; // % of add'l rendering cost compared to average overall redraw time\nvar deqNoDrawCost = 0.9; // % of avg frame time that can be used for dequeueing when not drawing\nvar deqFastCost = 0.9; // % of frame time to be used when >60fps\nvar maxDeqSize = 1; // number of eles to dequeue and render at higher texture in each batch\nvar invalidThreshold = 250; // time threshold for disabling b/c of invalidations\nvar maxLayerArea = 4000 * 4000; // layers can't be bigger than this\nvar maxLayerDim = 32767; // maximum size for the width/height of layer canvases\nvar useHighQualityEleTxrReqs = true; // whether to use high quality ele txr requests (generally faster and cheaper in the longterm)\n\n// var log = function(){ console.log.apply( console, arguments ); };\n\nvar LayeredTextureCache = function LayeredTextureCache(renderer) {\n  var self = this;\n  var r = self.renderer = renderer;\n  var cy = r.cy;\n  self.layersByLevel = {}; // e.g. 2 => [ layer1, layer2, ..., layerN ]\n\n  self.firstGet = true;\n  self.lastInvalidationTime = performanceNow() - 2 * invalidThreshold;\n  self.skipping = false;\n  self.eleTxrDeqs = cy.collection();\n  self.scheduleElementRefinement = debounce_1(function () {\n    self.refineElementTextures(self.eleTxrDeqs);\n    self.eleTxrDeqs.unmerge(self.eleTxrDeqs);\n  }, refineEleDebounceTime);\n  r.beforeRender(function (willDraw, now) {\n    if (now - self.lastInvalidationTime <= invalidThreshold) {\n      self.skipping = true;\n    } else {\n      self.skipping = false;\n    }\n  }, r.beforeRenderPriorities.lyrTxrSkip);\n  var qSort = function qSort(a, b) {\n    return b.reqs - a.reqs;\n  };\n  self.layersQueue = new heap(qSort);\n  self.setupDequeueing();\n};\nvar LTCp = LayeredTextureCache.prototype;\nvar layerIdPool = 0;\nvar MAX_INT = Math.pow(2, 53) - 1;\nLTCp.makeLayer = function (bb, lvl) {\n  var scale = Math.pow(2, lvl);\n  var w = Math.ceil(bb.w * scale);\n  var h = Math.ceil(bb.h * scale);\n  var canvas = this.renderer.makeOffscreenCanvas(w, h);\n  var layer = {\n    id: layerIdPool = ++layerIdPool % MAX_INT,\n    bb: bb,\n    level: lvl,\n    width: w,\n    height: h,\n    canvas: canvas,\n    context: canvas.getContext('2d'),\n    eles: [],\n    elesQueue: [],\n    reqs: 0\n  };\n\n  // log('make layer %s with w %s and h %s and lvl %s', layer.id, layer.width, layer.height, layer.level);\n\n  var cxt = layer.context;\n  var dx = -layer.bb.x1;\n  var dy = -layer.bb.y1;\n\n  // do the transform on creation to save cycles (it's the same for all eles)\n  cxt.scale(scale, scale);\n  cxt.translate(dx, dy);\n  return layer;\n};\nLTCp.getLayers = function (eles, pxRatio, lvl) {\n  var self = this;\n  var r = self.renderer;\n  var cy = r.cy;\n  var zoom = cy.zoom();\n  var firstGet = self.firstGet;\n  self.firstGet = false;\n\n  // log('--\\nget layers with %s eles', eles.length);\n  //log eles.map(function(ele){ return ele.id() }) );\n\n  if (lvl == null) {\n    lvl = Math.ceil(log2(zoom * pxRatio));\n    if (lvl < minLvl) {\n      lvl = minLvl;\n    } else if (zoom >= maxZoom || lvl > maxLvl) {\n      return null;\n    }\n  }\n  self.validateLayersElesOrdering(lvl, eles);\n  var layersByLvl = self.layersByLevel;\n  var scale = Math.pow(2, lvl);\n  var layers = layersByLvl[lvl] = layersByLvl[lvl] || [];\n  var bb;\n  var lvlComplete = self.levelIsComplete(lvl, eles);\n  var tmpLayers;\n  var checkTempLevels = function checkTempLevels() {\n    var canUseAsTmpLvl = function canUseAsTmpLvl(l) {\n      self.validateLayersElesOrdering(l, eles);\n      if (self.levelIsComplete(l, eles)) {\n        tmpLayers = layersByLvl[l];\n        return true;\n      }\n    };\n    var checkLvls = function checkLvls(dir) {\n      if (tmpLayers) {\n        return;\n      }\n      for (var l = lvl + dir; minLvl <= l && l <= maxLvl; l += dir) {\n        if (canUseAsTmpLvl(l)) {\n          break;\n        }\n      }\n    };\n    checkLvls(+1);\n    checkLvls(-1);\n\n    // remove the invalid layers; they will be replaced as needed later in this function\n    for (var i = layers.length - 1; i >= 0; i--) {\n      var layer = layers[i];\n      if (layer.invalid) {\n        removeFromArray(layers, layer);\n      }\n    }\n  };\n  if (!lvlComplete) {\n    // if the current level is incomplete, then use the closest, best quality layerset temporarily\n    // and later queue the current layerset so we can get the proper quality level soon\n\n    checkTempLevels();\n  } else {\n    // log('level complete, using existing layers\\n--');\n    return layers;\n  }\n  var getBb = function getBb() {\n    if (!bb) {\n      bb = makeBoundingBox();\n      for (var i = 0; i < eles.length; i++) {\n        updateBoundingBox(bb, eles[i].boundingBox());\n      }\n    }\n    return bb;\n  };\n  var makeLayer = function makeLayer(opts) {\n    opts = opts || {};\n    var after = opts.after;\n    getBb();\n    var w = Math.ceil(bb.w * scale);\n    var h = Math.ceil(bb.h * scale);\n    if (w > maxLayerDim || h > maxLayerDim) {\n      return null;\n    }\n    var area = w * h;\n    if (area > maxLayerArea) {\n      return null;\n    }\n    var layer = self.makeLayer(bb, lvl);\n    if (after != null) {\n      var index = layers.indexOf(after) + 1;\n      layers.splice(index, 0, layer);\n    } else if (opts.insert === undefined || opts.insert) {\n      // no after specified => first layer made so put at start\n      layers.unshift(layer);\n    }\n\n    // if( tmpLayers ){\n    //self.queueLayer( layer );\n    // }\n\n    return layer;\n  };\n  if (self.skipping && !firstGet) {\n    // log('skip layers');\n    return null;\n  }\n\n  // log('do layers');\n\n  var layer = null;\n  var maxElesPerLayer = eles.length / defNumLayers;\n  var allowLazyQueueing = !firstGet;\n  for (var i = 0; i < eles.length; i++) {\n    var ele = eles[i];\n    var rs = ele._private.rscratch;\n    var caches = rs.imgLayerCaches = rs.imgLayerCaches || {};\n\n    // log('look at ele', ele.id());\n\n    var existingLayer = caches[lvl];\n    if (existingLayer) {\n      // reuse layer for later eles\n      // log('reuse layer for', ele.id());\n      layer = existingLayer;\n      continue;\n    }\n    if (!layer || layer.eles.length >= maxElesPerLayer || !boundingBoxInBoundingBox(layer.bb, ele.boundingBox())) {\n      // log('make new layer for ele %s', ele.id());\n\n      layer = makeLayer({\n        insert: true,\n        after: layer\n      });\n\n      // if now layer can be built then we can't use layers at this level\n      if (!layer) {\n        return null;\n      }\n\n      // log('new layer with id %s', layer.id);\n    }\n\n    if (tmpLayers || allowLazyQueueing) {\n      // log('queue ele %s in layer %s', ele.id(), layer.id);\n      self.queueLayer(layer, ele);\n    } else {\n      // log('draw ele %s in layer %s', ele.id(), layer.id);\n      self.drawEleInLayer(layer, ele, lvl, pxRatio);\n    }\n    layer.eles.push(ele);\n    caches[lvl] = layer;\n  }\n\n  // log('--');\n\n  if (tmpLayers) {\n    // then we only queued the current layerset and can't draw it yet\n    return tmpLayers;\n  }\n  if (allowLazyQueueing) {\n    // log('lazy queue level', lvl);\n    return null;\n  }\n  return layers;\n};\n\n// a layer may want to use an ele cache of a higher level to avoid blurriness\n// so the layer level might not equal the ele level\nLTCp.getEleLevelForLayerLevel = function (lvl, pxRatio) {\n  return lvl;\n};\nLTCp.drawEleInLayer = function (layer, ele, lvl, pxRatio) {\n  var self = this;\n  var r = this.renderer;\n  var context = layer.context;\n  var bb = ele.boundingBox();\n  if (bb.w === 0 || bb.h === 0 || !ele.visible()) {\n    return;\n  }\n  lvl = self.getEleLevelForLayerLevel(lvl, pxRatio);\n  {\n    r.setImgSmoothing(context, false);\n  }\n  {\n    r.drawCachedElement(context, ele, null, null, lvl, useHighQualityEleTxrReqs);\n  }\n  {\n    r.setImgSmoothing(context, true);\n  }\n};\nLTCp.levelIsComplete = function (lvl, eles) {\n  var self = this;\n  var layers = self.layersByLevel[lvl];\n  if (!layers || layers.length === 0) {\n    return false;\n  }\n  var numElesInLayers = 0;\n  for (var i = 0; i < layers.length; i++) {\n    var layer = layers[i];\n\n    // if there are any eles needed to be drawn yet, the level is not complete\n    if (layer.reqs > 0) {\n      return false;\n    }\n\n    // if the layer is invalid, the level is not complete\n    if (layer.invalid) {\n      return false;\n    }\n    numElesInLayers += layer.eles.length;\n  }\n\n  // we should have exactly the number of eles passed in to be complete\n  if (numElesInLayers !== eles.length) {\n    return false;\n  }\n  return true;\n};\nLTCp.validateLayersElesOrdering = function (lvl, eles) {\n  var layers = this.layersByLevel[lvl];\n  if (!layers) {\n    return;\n  }\n\n  // if in a layer the eles are not in the same order, then the layer is invalid\n  // (i.e. there is an ele in between the eles in the layer)\n\n  for (var i = 0; i < layers.length; i++) {\n    var layer = layers[i];\n    var offset = -1;\n\n    // find the offset\n    for (var j = 0; j < eles.length; j++) {\n      if (layer.eles[0] === eles[j]) {\n        offset = j;\n        break;\n      }\n    }\n    if (offset < 0) {\n      // then the layer has nonexistent elements and is invalid\n      this.invalidateLayer(layer);\n      continue;\n    }\n\n    // the eles in the layer must be in the same continuous order, else the layer is invalid\n\n    var o = offset;\n    for (var j = 0; j < layer.eles.length; j++) {\n      if (layer.eles[j] !== eles[o + j]) {\n        // log('invalidate based on ordering', layer.id);\n\n        this.invalidateLayer(layer);\n        break;\n      }\n    }\n  }\n};\nLTCp.updateElementsInLayers = function (eles, update) {\n  var self = this;\n  var isEles = element(eles[0]);\n\n  // collect udpated elements (cascaded from the layers) and update each\n  // layer itself along the way\n  for (var i = 0; i < eles.length; i++) {\n    var req = isEles ? null : eles[i];\n    var ele = isEles ? eles[i] : eles[i].ele;\n    var rs = ele._private.rscratch;\n    var caches = rs.imgLayerCaches = rs.imgLayerCaches || {};\n    for (var l = minLvl; l <= maxLvl; l++) {\n      var layer = caches[l];\n      if (!layer) {\n        continue;\n      }\n\n      // if update is a request from the ele cache, then it affects only\n      // the matching level\n      if (req && self.getEleLevelForLayerLevel(layer.level) !== req.level) {\n        continue;\n      }\n      update(layer, ele, req);\n    }\n  }\n};\nLTCp.haveLayers = function () {\n  var self = this;\n  var haveLayers = false;\n  for (var l = minLvl; l <= maxLvl; l++) {\n    var layers = self.layersByLevel[l];\n    if (layers && layers.length > 0) {\n      haveLayers = true;\n      break;\n    }\n  }\n  return haveLayers;\n};\nLTCp.invalidateElements = function (eles) {\n  var self = this;\n  if (eles.length === 0) {\n    return;\n  }\n  self.lastInvalidationTime = performanceNow();\n\n  // log('update invalidate layer time from eles');\n\n  if (eles.length === 0 || !self.haveLayers()) {\n    return;\n  }\n  self.updateElementsInLayers(eles, function invalAssocLayers(layer, ele, req) {\n    self.invalidateLayer(layer);\n  });\n};\nLTCp.invalidateLayer = function (layer) {\n  // log('update invalidate layer time');\n\n  this.lastInvalidationTime = performanceNow();\n  if (layer.invalid) {\n    return;\n  } // save cycles\n\n  var lvl = layer.level;\n  var eles = layer.eles;\n  var layers = this.layersByLevel[lvl];\n\n  // log('invalidate layer', layer.id );\n\n  removeFromArray(layers, layer);\n  // layer.eles = [];\n\n  layer.elesQueue = [];\n  layer.invalid = true;\n  if (layer.replacement) {\n    layer.replacement.invalid = true;\n  }\n  for (var i = 0; i < eles.length; i++) {\n    var caches = eles[i]._private.rscratch.imgLayerCaches;\n    if (caches) {\n      caches[lvl] = null;\n    }\n  }\n};\nLTCp.refineElementTextures = function (eles) {\n  var self = this;\n\n  // log('refine', eles.length);\n\n  self.updateElementsInLayers(eles, function refineEachEle(layer, ele, req) {\n    var rLyr = layer.replacement;\n    if (!rLyr) {\n      rLyr = layer.replacement = self.makeLayer(layer.bb, layer.level);\n      rLyr.replaces = layer;\n      rLyr.eles = layer.eles;\n\n      // log('make replacement layer %s for %s with level %s', rLyr.id, layer.id, rLyr.level);\n    }\n\n    if (!rLyr.reqs) {\n      for (var i = 0; i < rLyr.eles.length; i++) {\n        self.queueLayer(rLyr, rLyr.eles[i]);\n      }\n\n      // log('queue replacement layer refinement', rLyr.id);\n    }\n  });\n};\n\nLTCp.enqueueElementRefinement = function (ele) {\n  this.eleTxrDeqs.merge(ele);\n  this.scheduleElementRefinement();\n};\nLTCp.queueLayer = function (layer, ele) {\n  var self = this;\n  var q = self.layersQueue;\n  var elesQ = layer.elesQueue;\n  var hasId = elesQ.hasId = elesQ.hasId || {};\n\n  // if a layer is going to be replaced, queuing is a waste of time\n  if (layer.replacement) {\n    return;\n  }\n  if (ele) {\n    if (hasId[ele.id()]) {\n      return;\n    }\n    elesQ.push(ele);\n    hasId[ele.id()] = true;\n  }\n  if (layer.reqs) {\n    layer.reqs++;\n    q.updateItem(layer);\n  } else {\n    layer.reqs = 1;\n    q.push(layer);\n  }\n};\nLTCp.dequeue = function (pxRatio) {\n  var self = this;\n  var q = self.layersQueue;\n  var deqd = [];\n  var eleDeqs = 0;\n  while (eleDeqs < maxDeqSize) {\n    if (q.size() === 0) {\n      break;\n    }\n    var layer = q.peek();\n\n    // if a layer has been or will be replaced, then don't waste time with it\n    if (layer.replacement) {\n      // log('layer %s in queue skipped b/c it already has a replacement', layer.id);\n      q.pop();\n      continue;\n    }\n\n    // if this is a replacement layer that has been superceded, then forget it\n    if (layer.replaces && layer !== layer.replaces.replacement) {\n      // log('layer is no longer the most uptodate replacement; dequeued', layer.id)\n      q.pop();\n      continue;\n    }\n    if (layer.invalid) {\n      // log('replacement layer %s is invalid; dequeued', layer.id);\n      q.pop();\n      continue;\n    }\n    var ele = layer.elesQueue.shift();\n    if (ele) {\n      // log('dequeue layer %s', layer.id);\n\n      self.drawEleInLayer(layer, ele, layer.level, pxRatio);\n      eleDeqs++;\n    }\n    if (deqd.length === 0) {\n      // we need only one entry in deqd to queue redrawing etc\n      deqd.push(true);\n    }\n\n    // if the layer has all its eles done, then remove from the queue\n    if (layer.elesQueue.length === 0) {\n      q.pop();\n      layer.reqs = 0;\n\n      // log('dequeue of layer %s complete', layer.id);\n\n      // when a replacement layer is dequeued, it replaces the old layer in the level\n      if (layer.replaces) {\n        self.applyLayerReplacement(layer);\n      }\n      self.requestRedraw();\n    }\n  }\n  return deqd;\n};\nLTCp.applyLayerReplacement = function (layer) {\n  var self = this;\n  var layersInLevel = self.layersByLevel[layer.level];\n  var replaced = layer.replaces;\n  var index = layersInLevel.indexOf(replaced);\n\n  // if the replaced layer is not in the active list for the level, then replacing\n  // refs would be a mistake (i.e. overwriting the true active layer)\n  if (index < 0 || replaced.invalid) {\n    // log('replacement layer would have no effect', layer.id);\n    return;\n  }\n  layersInLevel[index] = layer; // replace level ref\n\n  // replace refs in eles\n  for (var i = 0; i < layer.eles.length; i++) {\n    var _p = layer.eles[i]._private;\n    var cache = _p.imgLayerCaches = _p.imgLayerCaches || {};\n    if (cache) {\n      cache[layer.level] = layer;\n    }\n  }\n\n  // log('apply replacement layer %s over %s', layer.id, replaced.id);\n\n  self.requestRedraw();\n};\nLTCp.requestRedraw = debounce_1(function () {\n  var r = this.renderer;\n  r.redrawHint('eles', true);\n  r.redrawHint('drag', true);\n  r.redraw();\n}, 100);\nLTCp.setupDequeueing = defs.setupDequeueing({\n  deqRedrawThreshold: deqRedrawThreshold,\n  deqCost: deqCost,\n  deqAvgCost: deqAvgCost,\n  deqNoDrawCost: deqNoDrawCost,\n  deqFastCost: deqFastCost,\n  deq: function deq(self, pxRatio) {\n    return self.dequeue(pxRatio);\n  },\n  onDeqd: noop$1,\n  shouldRedraw: trueify,\n  priority: function priority(self) {\n    return self.renderer.beforeRenderPriorities.lyrTxrDeq;\n  }\n});\n\nvar CRp$a = {};\nvar impl;\nfunction polygon(context, points) {\n  for (var i = 0; i < points.length; i++) {\n    var pt = points[i];\n    context.lineTo(pt.x, pt.y);\n  }\n}\nfunction triangleBackcurve(context, points, controlPoint) {\n  var firstPt;\n  for (var i = 0; i < points.length; i++) {\n    var pt = points[i];\n    if (i === 0) {\n      firstPt = pt;\n    }\n    context.lineTo(pt.x, pt.y);\n  }\n  context.quadraticCurveTo(controlPoint.x, controlPoint.y, firstPt.x, firstPt.y);\n}\nfunction triangleTee(context, trianglePoints, teePoints) {\n  if (context.beginPath) {\n    context.beginPath();\n  }\n  var triPts = trianglePoints;\n  for (var i = 0; i < triPts.length; i++) {\n    var pt = triPts[i];\n    context.lineTo(pt.x, pt.y);\n  }\n  var teePts = teePoints;\n  var firstTeePt = teePoints[0];\n  context.moveTo(firstTeePt.x, firstTeePt.y);\n  for (var i = 1; i < teePts.length; i++) {\n    var pt = teePts[i];\n    context.lineTo(pt.x, pt.y);\n  }\n  if (context.closePath) {\n    context.closePath();\n  }\n}\nfunction circleTriangle(context, trianglePoints, rx, ry, r) {\n  if (context.beginPath) {\n    context.beginPath();\n  }\n  context.arc(rx, ry, r, 0, Math.PI * 2, false);\n  var triPts = trianglePoints;\n  var firstTrPt = triPts[0];\n  context.moveTo(firstTrPt.x, firstTrPt.y);\n  for (var i = 0; i < triPts.length; i++) {\n    var pt = triPts[i];\n    context.lineTo(pt.x, pt.y);\n  }\n  if (context.closePath) {\n    context.closePath();\n  }\n}\nfunction circle(context, rx, ry, r) {\n  context.arc(rx, ry, r, 0, Math.PI * 2, false);\n}\nCRp$a.arrowShapeImpl = function (name) {\n  return (impl || (impl = {\n    'polygon': polygon,\n    'triangle-backcurve': triangleBackcurve,\n    'triangle-tee': triangleTee,\n    'circle-triangle': circleTriangle,\n    'triangle-cross': triangleTee,\n    'circle': circle\n  }))[name];\n};\n\nvar CRp$9 = {};\nCRp$9.drawElement = function (context, ele, shiftToOriginWithBb, showLabel, showOverlay, showOpacity) {\n  var r = this;\n  if (ele.isNode()) {\n    r.drawNode(context, ele, shiftToOriginWithBb, showLabel, showOverlay, showOpacity);\n  } else {\n    r.drawEdge(context, ele, shiftToOriginWithBb, showLabel, showOverlay, showOpacity);\n  }\n};\nCRp$9.drawElementOverlay = function (context, ele) {\n  var r = this;\n  if (ele.isNode()) {\n    r.drawNodeOverlay(context, ele);\n  } else {\n    r.drawEdgeOverlay(context, ele);\n  }\n};\nCRp$9.drawElementUnderlay = function (context, ele) {\n  var r = this;\n  if (ele.isNode()) {\n    r.drawNodeUnderlay(context, ele);\n  } else {\n    r.drawEdgeUnderlay(context, ele);\n  }\n};\nCRp$9.drawCachedElementPortion = function (context, ele, eleTxrCache, pxRatio, lvl, reason, getRotation, getOpacity) {\n  var r = this;\n  var bb = eleTxrCache.getBoundingBox(ele);\n  if (bb.w === 0 || bb.h === 0) {\n    return;\n  } // ignore zero size case\n\n  var eleCache = eleTxrCache.getElement(ele, bb, pxRatio, lvl, reason);\n  if (eleCache != null) {\n    var opacity = getOpacity(r, ele);\n    if (opacity === 0) {\n      return;\n    }\n    var theta = getRotation(r, ele);\n    var x1 = bb.x1,\n      y1 = bb.y1,\n      w = bb.w,\n      h = bb.h;\n    var x, y, sx, sy, smooth;\n    if (theta !== 0) {\n      var rotPt = eleTxrCache.getRotationPoint(ele);\n      sx = rotPt.x;\n      sy = rotPt.y;\n      context.translate(sx, sy);\n      context.rotate(theta);\n      smooth = r.getImgSmoothing(context);\n      if (!smooth) {\n        r.setImgSmoothing(context, true);\n      }\n      var off = eleTxrCache.getRotationOffset(ele);\n      x = off.x;\n      y = off.y;\n    } else {\n      x = x1;\n      y = y1;\n    }\n    var oldGlobalAlpha;\n    if (opacity !== 1) {\n      oldGlobalAlpha = context.globalAlpha;\n      context.globalAlpha = oldGlobalAlpha * opacity;\n    }\n    context.drawImage(eleCache.texture.canvas, eleCache.x, 0, eleCache.width, eleCache.height, x, y, w, h);\n    if (opacity !== 1) {\n      context.globalAlpha = oldGlobalAlpha;\n    }\n    if (theta !== 0) {\n      context.rotate(-theta);\n      context.translate(-sx, -sy);\n      if (!smooth) {\n        r.setImgSmoothing(context, false);\n      }\n    }\n  } else {\n    eleTxrCache.drawElement(context, ele); // direct draw fallback\n  }\n};\n\nvar getZeroRotation = function getZeroRotation() {\n  return 0;\n};\nvar getLabelRotation = function getLabelRotation(r, ele) {\n  return r.getTextAngle(ele, null);\n};\nvar getSourceLabelRotation = function getSourceLabelRotation(r, ele) {\n  return r.getTextAngle(ele, 'source');\n};\nvar getTargetLabelRotation = function getTargetLabelRotation(r, ele) {\n  return r.getTextAngle(ele, 'target');\n};\nvar getOpacity = function getOpacity(r, ele) {\n  return ele.effectiveOpacity();\n};\nvar getTextOpacity = function getTextOpacity(e, ele) {\n  return ele.pstyle('text-opacity').pfValue * ele.effectiveOpacity();\n};\nCRp$9.drawCachedElement = function (context, ele, pxRatio, extent, lvl, requestHighQuality) {\n  var r = this;\n  var _r$data = r.data,\n    eleTxrCache = _r$data.eleTxrCache,\n    lblTxrCache = _r$data.lblTxrCache,\n    slbTxrCache = _r$data.slbTxrCache,\n    tlbTxrCache = _r$data.tlbTxrCache;\n  var bb = ele.boundingBox();\n  var reason = requestHighQuality === true ? eleTxrCache.reasons.highQuality : null;\n  if (bb.w === 0 || bb.h === 0 || !ele.visible()) {\n    return;\n  }\n  if (!extent || boundingBoxesIntersect(bb, extent)) {\n    var isEdge = ele.isEdge();\n    var badLine = ele.element()._private.rscratch.badLine;\n    r.drawElementUnderlay(context, ele);\n    r.drawCachedElementPortion(context, ele, eleTxrCache, pxRatio, lvl, reason, getZeroRotation, getOpacity);\n    if (!isEdge || !badLine) {\n      r.drawCachedElementPortion(context, ele, lblTxrCache, pxRatio, lvl, reason, getLabelRotation, getTextOpacity);\n    }\n    if (isEdge && !badLine) {\n      r.drawCachedElementPortion(context, ele, slbTxrCache, pxRatio, lvl, reason, getSourceLabelRotation, getTextOpacity);\n      r.drawCachedElementPortion(context, ele, tlbTxrCache, pxRatio, lvl, reason, getTargetLabelRotation, getTextOpacity);\n    }\n    r.drawElementOverlay(context, ele);\n  }\n};\nCRp$9.drawElements = function (context, eles) {\n  var r = this;\n  for (var i = 0; i < eles.length; i++) {\n    var ele = eles[i];\n    r.drawElement(context, ele);\n  }\n};\nCRp$9.drawCachedElements = function (context, eles, pxRatio, extent) {\n  var r = this;\n  for (var i = 0; i < eles.length; i++) {\n    var ele = eles[i];\n    r.drawCachedElement(context, ele, pxRatio, extent);\n  }\n};\nCRp$9.drawCachedNodes = function (context, eles, pxRatio, extent) {\n  var r = this;\n  for (var i = 0; i < eles.length; i++) {\n    var ele = eles[i];\n    if (!ele.isNode()) {\n      continue;\n    }\n    r.drawCachedElement(context, ele, pxRatio, extent);\n  }\n};\nCRp$9.drawLayeredElements = function (context, eles, pxRatio, extent) {\n  var r = this;\n  var layers = r.data.lyrTxrCache.getLayers(eles, pxRatio);\n  if (layers) {\n    for (var i = 0; i < layers.length; i++) {\n      var layer = layers[i];\n      var bb = layer.bb;\n      if (bb.w === 0 || bb.h === 0) {\n        continue;\n      }\n      context.drawImage(layer.canvas, bb.x1, bb.y1, bb.w, bb.h);\n    }\n  } else {\n    // fall back on plain caching if no layers\n    r.drawCachedElements(context, eles, pxRatio, extent);\n  }\n};\n\nvar CRp$8 = {};\nCRp$8.drawEdge = function (context, edge, shiftToOriginWithBb) {\n  var drawLabel = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n  var shouldDrawOverlay = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n  var shouldDrawOpacity = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;\n  var r = this;\n  var rs = edge._private.rscratch;\n  if (shouldDrawOpacity && !edge.visible()) {\n    return;\n  }\n\n  // if bezier ctrl pts can not be calculated, then die\n  if (rs.badLine || rs.allpts == null || isNaN(rs.allpts[0])) {\n    // isNaN in case edge is impossible and browser bugs (e.g. safari)\n    return;\n  }\n  var bb;\n  if (shiftToOriginWithBb) {\n    bb = shiftToOriginWithBb;\n    context.translate(-bb.x1, -bb.y1);\n  }\n  var opacity = shouldDrawOpacity ? edge.pstyle('opacity').value : 1;\n  var lineOpacity = shouldDrawOpacity ? edge.pstyle('line-opacity').value : 1;\n  var curveStyle = edge.pstyle('curve-style').value;\n  var lineStyle = edge.pstyle('line-style').value;\n  var edgeWidth = edge.pstyle('width').pfValue;\n  var lineCap = edge.pstyle('line-cap').value;\n  var lineOutlineWidth = edge.pstyle('line-outline-width').value;\n  var lineOutlineColor = edge.pstyle('line-outline-color').value;\n  var effectiveLineOpacity = opacity * lineOpacity;\n  // separate arrow opacity would require arrow-opacity property\n  var effectiveArrowOpacity = opacity * lineOpacity;\n  var drawLine = function drawLine() {\n    var strokeOpacity = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : effectiveLineOpacity;\n    if (curveStyle === 'straight-triangle') {\n      r.eleStrokeStyle(context, edge, strokeOpacity);\n      r.drawEdgeTrianglePath(edge, context, rs.allpts);\n    } else {\n      context.lineWidth = edgeWidth;\n      context.lineCap = lineCap;\n      r.eleStrokeStyle(context, edge, strokeOpacity);\n      r.drawEdgePath(edge, context, rs.allpts, lineStyle);\n      context.lineCap = 'butt'; // reset for other drawing functions\n    }\n  };\n\n  var drawLineOutline = function drawLineOutline() {\n    var strokeOpacity = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : effectiveLineOpacity;\n    context.lineWidth = edgeWidth + lineOutlineWidth;\n    context.lineCap = lineCap;\n    if (lineOutlineWidth > 0) {\n      r.colorStrokeStyle(context, lineOutlineColor[0], lineOutlineColor[1], lineOutlineColor[2], strokeOpacity);\n    } else {\n      // do not draw any lineOutline\n      context.lineCap = 'butt'; // reset for other drawing functions\n      return;\n    }\n    if (curveStyle === 'straight-triangle') {\n      r.drawEdgeTrianglePath(edge, context, rs.allpts);\n    } else {\n      r.drawEdgePath(edge, context, rs.allpts, lineStyle);\n      context.lineCap = 'butt'; // reset for other drawing functions\n    }\n  };\n\n  var drawOverlay = function drawOverlay() {\n    if (!shouldDrawOverlay) {\n      return;\n    }\n    r.drawEdgeOverlay(context, edge);\n  };\n  var drawUnderlay = function drawUnderlay() {\n    if (!shouldDrawOverlay) {\n      return;\n    }\n    r.drawEdgeUnderlay(context, edge);\n  };\n  var drawArrows = function drawArrows() {\n    var arrowOpacity = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : effectiveArrowOpacity;\n    r.drawArrowheads(context, edge, arrowOpacity);\n  };\n  var drawText = function drawText() {\n    r.drawElementText(context, edge, null, drawLabel);\n  };\n  context.lineJoin = 'round';\n  var ghost = edge.pstyle('ghost').value === 'yes';\n  if (ghost) {\n    var gx = edge.pstyle('ghost-offset-x').pfValue;\n    var gy = edge.pstyle('ghost-offset-y').pfValue;\n    var ghostOpacity = edge.pstyle('ghost-opacity').value;\n    var effectiveGhostOpacity = effectiveLineOpacity * ghostOpacity;\n    context.translate(gx, gy);\n    drawLine(effectiveGhostOpacity);\n    drawArrows(effectiveGhostOpacity);\n    context.translate(-gx, -gy);\n  } else {\n    drawLineOutline();\n  }\n  drawUnderlay();\n  drawLine();\n  drawArrows();\n  drawOverlay();\n  drawText();\n  if (shiftToOriginWithBb) {\n    context.translate(bb.x1, bb.y1);\n  }\n};\nvar drawEdgeOverlayUnderlay = function drawEdgeOverlayUnderlay(overlayOrUnderlay) {\n  if (!['overlay', 'underlay'].includes(overlayOrUnderlay)) {\n    throw new Error('Invalid state');\n  }\n  return function (context, edge) {\n    if (!edge.visible()) {\n      return;\n    }\n    var opacity = edge.pstyle(\"\".concat(overlayOrUnderlay, \"-opacity\")).value;\n    if (opacity === 0) {\n      return;\n    }\n    var r = this;\n    var usePaths = r.usePaths();\n    var rs = edge._private.rscratch;\n    var padding = edge.pstyle(\"\".concat(overlayOrUnderlay, \"-padding\")).pfValue;\n    var width = 2 * padding;\n    var color = edge.pstyle(\"\".concat(overlayOrUnderlay, \"-color\")).value;\n    context.lineWidth = width;\n    if (rs.edgeType === 'self' && !usePaths) {\n      context.lineCap = 'butt';\n    } else {\n      context.lineCap = 'round';\n    }\n    r.colorStrokeStyle(context, color[0], color[1], color[2], opacity);\n    r.drawEdgePath(edge, context, rs.allpts, 'solid');\n  };\n};\nCRp$8.drawEdgeOverlay = drawEdgeOverlayUnderlay('overlay');\nCRp$8.drawEdgeUnderlay = drawEdgeOverlayUnderlay('underlay');\nCRp$8.drawEdgePath = function (edge, context, pts, type) {\n  var rs = edge._private.rscratch;\n  var canvasCxt = context;\n  var path;\n  var pathCacheHit = false;\n  var usePaths = this.usePaths();\n  var lineDashPattern = edge.pstyle('line-dash-pattern').pfValue;\n  var lineDashOffset = edge.pstyle('line-dash-offset').pfValue;\n  if (usePaths) {\n    var pathCacheKey = pts.join('$');\n    var keyMatches = rs.pathCacheKey && rs.pathCacheKey === pathCacheKey;\n    if (keyMatches) {\n      path = context = rs.pathCache;\n      pathCacheHit = true;\n    } else {\n      path = context = new Path2D();\n      rs.pathCacheKey = pathCacheKey;\n      rs.pathCache = path;\n    }\n  }\n  if (canvasCxt.setLineDash) {\n    // for very outofdate browsers\n    switch (type) {\n      case 'dotted':\n        canvasCxt.setLineDash([1, 1]);\n        break;\n      case 'dashed':\n        canvasCxt.setLineDash(lineDashPattern);\n        canvasCxt.lineDashOffset = lineDashOffset;\n        break;\n      case 'solid':\n        canvasCxt.setLineDash([]);\n        break;\n    }\n  }\n  if (!pathCacheHit && !rs.badLine) {\n    if (context.beginPath) {\n      context.beginPath();\n    }\n    context.moveTo(pts[0], pts[1]);\n    switch (rs.edgeType) {\n      case 'bezier':\n      case 'self':\n      case 'compound':\n      case 'multibezier':\n        for (var i = 2; i + 3 < pts.length; i += 4) {\n          context.quadraticCurveTo(pts[i], pts[i + 1], pts[i + 2], pts[i + 3]);\n        }\n        break;\n      case 'straight':\n      case 'haystack':\n        for (var _i = 2; _i + 1 < pts.length; _i += 2) {\n          context.lineTo(pts[_i], pts[_i + 1]);\n        }\n        break;\n      case 'segments':\n        if (rs.isRound) {\n          var _iterator = _createForOfIteratorHelper(rs.roundCorners),\n            _step;\n          try {\n            for (_iterator.s(); !(_step = _iterator.n()).done;) {\n              var corner = _step.value;\n              drawPreparedRoundCorner(context, corner);\n            }\n          } catch (err) {\n            _iterator.e(err);\n          } finally {\n            _iterator.f();\n          }\n          context.lineTo(pts[pts.length - 2], pts[pts.length - 1]);\n        } else {\n          for (var _i2 = 2; _i2 + 1 < pts.length; _i2 += 2) {\n            context.lineTo(pts[_i2], pts[_i2 + 1]);\n          }\n        }\n        break;\n    }\n  }\n  context = canvasCxt;\n  if (usePaths) {\n    context.stroke(path);\n  } else {\n    context.stroke();\n  }\n\n  // reset any line dashes\n  if (context.setLineDash) {\n    // for very outofdate browsers\n    context.setLineDash([]);\n  }\n};\nCRp$8.drawEdgeTrianglePath = function (edge, context, pts) {\n  // use line stroke style for triangle fill style\n  context.fillStyle = context.strokeStyle;\n  var edgeWidth = edge.pstyle('width').pfValue;\n  for (var i = 0; i + 1 < pts.length; i += 2) {\n    var vector = [pts[i + 2] - pts[i], pts[i + 3] - pts[i + 1]];\n    var length = Math.sqrt(vector[0] * vector[0] + vector[1] * vector[1]);\n    var normal = [vector[1] / length, -vector[0] / length];\n    var triangleHead = [normal[0] * edgeWidth / 2, normal[1] * edgeWidth / 2];\n    context.beginPath();\n    context.moveTo(pts[i] - triangleHead[0], pts[i + 1] - triangleHead[1]);\n    context.lineTo(pts[i] + triangleHead[0], pts[i + 1] + triangleHead[1]);\n    context.lineTo(pts[i + 2], pts[i + 3]);\n    context.closePath();\n    context.fill();\n  }\n};\nCRp$8.drawArrowheads = function (context, edge, opacity) {\n  var rs = edge._private.rscratch;\n  var isHaystack = rs.edgeType === 'haystack';\n  if (!isHaystack) {\n    this.drawArrowhead(context, edge, 'source', rs.arrowStartX, rs.arrowStartY, rs.srcArrowAngle, opacity);\n  }\n  this.drawArrowhead(context, edge, 'mid-target', rs.midX, rs.midY, rs.midtgtArrowAngle, opacity);\n  this.drawArrowhead(context, edge, 'mid-source', rs.midX, rs.midY, rs.midsrcArrowAngle, opacity);\n  if (!isHaystack) {\n    this.drawArrowhead(context, edge, 'target', rs.arrowEndX, rs.arrowEndY, rs.tgtArrowAngle, opacity);\n  }\n};\nCRp$8.drawArrowhead = function (context, edge, prefix, x, y, angle, opacity) {\n  if (isNaN(x) || x == null || isNaN(y) || y == null || isNaN(angle) || angle == null) {\n    return;\n  }\n  var self = this;\n  var arrowShape = edge.pstyle(prefix + '-arrow-shape').value;\n  if (arrowShape === 'none') {\n    return;\n  }\n  var arrowClearFill = edge.pstyle(prefix + '-arrow-fill').value === 'hollow' ? 'both' : 'filled';\n  var arrowFill = edge.pstyle(prefix + '-arrow-fill').value;\n  var edgeWidth = edge.pstyle('width').pfValue;\n  var pArrowWidth = edge.pstyle(prefix + '-arrow-width');\n  var arrowWidth = pArrowWidth.value === 'match-line' ? edgeWidth : pArrowWidth.pfValue;\n  if (pArrowWidth.units === '%') arrowWidth *= edgeWidth;\n  var edgeOpacity = edge.pstyle('opacity').value;\n  if (opacity === undefined) {\n    opacity = edgeOpacity;\n  }\n  var gco = context.globalCompositeOperation;\n  if (opacity !== 1 || arrowFill === 'hollow') {\n    // then extra clear is needed\n    context.globalCompositeOperation = 'destination-out';\n    self.colorFillStyle(context, 255, 255, 255, 1);\n    self.colorStrokeStyle(context, 255, 255, 255, 1);\n    self.drawArrowShape(edge, context, arrowClearFill, edgeWidth, arrowShape, arrowWidth, x, y, angle);\n    context.globalCompositeOperation = gco;\n  } // otherwise, the opaque arrow clears it for free :)\n\n  var color = edge.pstyle(prefix + '-arrow-color').value;\n  self.colorFillStyle(context, color[0], color[1], color[2], opacity);\n  self.colorStrokeStyle(context, color[0], color[1], color[2], opacity);\n  self.drawArrowShape(edge, context, arrowFill, edgeWidth, arrowShape, arrowWidth, x, y, angle);\n};\nCRp$8.drawArrowShape = function (edge, context, fill, edgeWidth, shape, shapeWidth, x, y, angle) {\n  var r = this;\n  var usePaths = this.usePaths() && shape !== 'triangle-cross';\n  var pathCacheHit = false;\n  var path;\n  var canvasContext = context;\n  var translation = {\n    x: x,\n    y: y\n  };\n  var scale = edge.pstyle('arrow-scale').value;\n  var size = this.getArrowWidth(edgeWidth, scale);\n  var shapeImpl = r.arrowShapes[shape];\n  if (usePaths) {\n    var cache = r.arrowPathCache = r.arrowPathCache || [];\n    var key = hashString(shape);\n    var cachedPath = cache[key];\n    if (cachedPath != null) {\n      path = context = cachedPath;\n      pathCacheHit = true;\n    } else {\n      path = context = new Path2D();\n      cache[key] = path;\n    }\n  }\n  if (!pathCacheHit) {\n    if (context.beginPath) {\n      context.beginPath();\n    }\n    if (usePaths) {\n      // store in the path cache with values easily manipulated later\n      shapeImpl.draw(context, 1, 0, {\n        x: 0,\n        y: 0\n      }, 1);\n    } else {\n      shapeImpl.draw(context, size, angle, translation, edgeWidth);\n    }\n    if (context.closePath) {\n      context.closePath();\n    }\n  }\n  context = canvasContext;\n  if (usePaths) {\n    // set transform to arrow position/orientation\n    context.translate(x, y);\n    context.rotate(angle);\n    context.scale(size, size);\n  }\n  if (fill === 'filled' || fill === 'both') {\n    if (usePaths) {\n      context.fill(path);\n    } else {\n      context.fill();\n    }\n  }\n  if (fill === 'hollow' || fill === 'both') {\n    context.lineWidth = shapeWidth / (usePaths ? size : 1);\n    context.lineJoin = 'miter';\n    if (usePaths) {\n      context.stroke(path);\n    } else {\n      context.stroke();\n    }\n  }\n  if (usePaths) {\n    // reset transform by applying inverse\n    context.scale(1 / size, 1 / size);\n    context.rotate(-angle);\n    context.translate(-x, -y);\n  }\n};\n\nvar CRp$7 = {};\nCRp$7.safeDrawImage = function (context, img, ix, iy, iw, ih, x, y, w, h) {\n  // detect problematic cases for old browsers with bad images (cheaper than try-catch)\n  if (iw <= 0 || ih <= 0 || w <= 0 || h <= 0) {\n    return;\n  }\n  try {\n    context.drawImage(img, ix, iy, iw, ih, x, y, w, h);\n  } catch (e) {\n    warn(e);\n  }\n};\nCRp$7.drawInscribedImage = function (context, img, node, index, nodeOpacity) {\n  var r = this;\n  var pos = node.position();\n  var nodeX = pos.x;\n  var nodeY = pos.y;\n  var styleObj = node.cy().style();\n  var getIndexedStyle = styleObj.getIndexedStyle.bind(styleObj);\n  var fit = getIndexedStyle(node, 'background-fit', 'value', index);\n  var repeat = getIndexedStyle(node, 'background-repeat', 'value', index);\n  var nodeW = node.width();\n  var nodeH = node.height();\n  var paddingX2 = node.padding() * 2;\n  var nodeTW = nodeW + (getIndexedStyle(node, 'background-width-relative-to', 'value', index) === 'inner' ? 0 : paddingX2);\n  var nodeTH = nodeH + (getIndexedStyle(node, 'background-height-relative-to', 'value', index) === 'inner' ? 0 : paddingX2);\n  var rs = node._private.rscratch;\n  var clip = getIndexedStyle(node, 'background-clip', 'value', index);\n  var shouldClip = clip === 'node';\n  var imgOpacity = getIndexedStyle(node, 'background-image-opacity', 'value', index) * nodeOpacity;\n  var smooth = getIndexedStyle(node, 'background-image-smoothing', 'value', index);\n  var cornerRadius = node.pstyle('corner-radius').value;\n  if (cornerRadius !== 'auto') cornerRadius = node.pstyle('corner-radius').pfValue;\n  var imgW = img.width || img.cachedW;\n  var imgH = img.height || img.cachedH;\n\n  // workaround for broken browsers like ie\n  if (null == imgW || null == imgH) {\n    document.body.appendChild(img); // eslint-disable-line no-undef\n\n    imgW = img.cachedW = img.width || img.offsetWidth;\n    imgH = img.cachedH = img.height || img.offsetHeight;\n    document.body.removeChild(img); // eslint-disable-line no-undef\n  }\n\n  var w = imgW;\n  var h = imgH;\n  if (getIndexedStyle(node, 'background-width', 'value', index) !== 'auto') {\n    if (getIndexedStyle(node, 'background-width', 'units', index) === '%') {\n      w = getIndexedStyle(node, 'background-width', 'pfValue', index) * nodeTW;\n    } else {\n      w = getIndexedStyle(node, 'background-width', 'pfValue', index);\n    }\n  }\n  if (getIndexedStyle(node, 'background-height', 'value', index) !== 'auto') {\n    if (getIndexedStyle(node, 'background-height', 'units', index) === '%') {\n      h = getIndexedStyle(node, 'background-height', 'pfValue', index) * nodeTH;\n    } else {\n      h = getIndexedStyle(node, 'background-height', 'pfValue', index);\n    }\n  }\n  if (w === 0 || h === 0) {\n    return; // no point in drawing empty image (and chrome is broken in this case)\n  }\n\n  if (fit === 'contain') {\n    var scale = Math.min(nodeTW / w, nodeTH / h);\n    w *= scale;\n    h *= scale;\n  } else if (fit === 'cover') {\n    var scale = Math.max(nodeTW / w, nodeTH / h);\n    w *= scale;\n    h *= scale;\n  }\n  var x = nodeX - nodeTW / 2; // left\n  var posXUnits = getIndexedStyle(node, 'background-position-x', 'units', index);\n  var posXPfVal = getIndexedStyle(node, 'background-position-x', 'pfValue', index);\n  if (posXUnits === '%') {\n    x += (nodeTW - w) * posXPfVal;\n  } else {\n    x += posXPfVal;\n  }\n  var offXUnits = getIndexedStyle(node, 'background-offset-x', 'units', index);\n  var offXPfVal = getIndexedStyle(node, 'background-offset-x', 'pfValue', index);\n  if (offXUnits === '%') {\n    x += (nodeTW - w) * offXPfVal;\n  } else {\n    x += offXPfVal;\n  }\n  var y = nodeY - nodeTH / 2; // top\n  var posYUnits = getIndexedStyle(node, 'background-position-y', 'units', index);\n  var posYPfVal = getIndexedStyle(node, 'background-position-y', 'pfValue', index);\n  if (posYUnits === '%') {\n    y += (nodeTH - h) * posYPfVal;\n  } else {\n    y += posYPfVal;\n  }\n  var offYUnits = getIndexedStyle(node, 'background-offset-y', 'units', index);\n  var offYPfVal = getIndexedStyle(node, 'background-offset-y', 'pfValue', index);\n  if (offYUnits === '%') {\n    y += (nodeTH - h) * offYPfVal;\n  } else {\n    y += offYPfVal;\n  }\n  if (rs.pathCache) {\n    x -= nodeX;\n    y -= nodeY;\n    nodeX = 0;\n    nodeY = 0;\n  }\n  var gAlpha = context.globalAlpha;\n  context.globalAlpha = imgOpacity;\n  var smoothingEnabled = r.getImgSmoothing(context);\n  var isSmoothingSwitched = false;\n  if (smooth === 'no' && smoothingEnabled) {\n    r.setImgSmoothing(context, false);\n    isSmoothingSwitched = true;\n  } else if (smooth === 'yes' && !smoothingEnabled) {\n    r.setImgSmoothing(context, true);\n    isSmoothingSwitched = true;\n  }\n  if (repeat === 'no-repeat') {\n    if (shouldClip) {\n      context.save();\n      if (rs.pathCache) {\n        context.clip(rs.pathCache);\n      } else {\n        r.nodeShapes[r.getNodeShape(node)].draw(context, nodeX, nodeY, nodeTW, nodeTH, cornerRadius, rs);\n        context.clip();\n      }\n    }\n    r.safeDrawImage(context, img, 0, 0, imgW, imgH, x, y, w, h);\n    if (shouldClip) {\n      context.restore();\n    }\n  } else {\n    var pattern = context.createPattern(img, repeat);\n    context.fillStyle = pattern;\n    r.nodeShapes[r.getNodeShape(node)].draw(context, nodeX, nodeY, nodeTW, nodeTH, cornerRadius, rs);\n    context.translate(x, y);\n    context.fill();\n    context.translate(-x, -y);\n  }\n  context.globalAlpha = gAlpha;\n  if (isSmoothingSwitched) {\n    r.setImgSmoothing(context, smoothingEnabled);\n  }\n};\n\nvar CRp$6 = {};\nCRp$6.eleTextBiggerThanMin = function (ele, scale) {\n  if (!scale) {\n    var zoom = ele.cy().zoom();\n    var pxRatio = this.getPixelRatio();\n    var lvl = Math.ceil(log2(zoom * pxRatio)); // the effective texture level\n\n    scale = Math.pow(2, lvl);\n  }\n  var computedSize = ele.pstyle('font-size').pfValue * scale;\n  var minSize = ele.pstyle('min-zoomed-font-size').pfValue;\n  if (computedSize < minSize) {\n    return false;\n  }\n  return true;\n};\nCRp$6.drawElementText = function (context, ele, shiftToOriginWithBb, force, prefix) {\n  var useEleOpacity = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;\n  var r = this;\n  if (force == null) {\n    if (useEleOpacity && !r.eleTextBiggerThanMin(ele)) {\n      return;\n    }\n  } else if (force === false) {\n    return;\n  }\n  if (ele.isNode()) {\n    var label = ele.pstyle('label');\n    if (!label || !label.value) {\n      return;\n    }\n    var justification = r.getLabelJustification(ele);\n    context.textAlign = justification;\n    context.textBaseline = 'bottom';\n  } else {\n    var badLine = ele.element()._private.rscratch.badLine;\n    var _label = ele.pstyle('label');\n    var srcLabel = ele.pstyle('source-label');\n    var tgtLabel = ele.pstyle('target-label');\n    if (badLine || (!_label || !_label.value) && (!srcLabel || !srcLabel.value) && (!tgtLabel || !tgtLabel.value)) {\n      return;\n    }\n    context.textAlign = 'center';\n    context.textBaseline = 'bottom';\n  }\n  var applyRotation = !shiftToOriginWithBb;\n  var bb;\n  if (shiftToOriginWithBb) {\n    bb = shiftToOriginWithBb;\n    context.translate(-bb.x1, -bb.y1);\n  }\n  if (prefix == null) {\n    r.drawText(context, ele, null, applyRotation, useEleOpacity);\n    if (ele.isEdge()) {\n      r.drawText(context, ele, 'source', applyRotation, useEleOpacity);\n      r.drawText(context, ele, 'target', applyRotation, useEleOpacity);\n    }\n  } else {\n    r.drawText(context, ele, prefix, applyRotation, useEleOpacity);\n  }\n  if (shiftToOriginWithBb) {\n    context.translate(bb.x1, bb.y1);\n  }\n};\nCRp$6.getFontCache = function (context) {\n  var cache;\n  this.fontCaches = this.fontCaches || [];\n  for (var i = 0; i < this.fontCaches.length; i++) {\n    cache = this.fontCaches[i];\n    if (cache.context === context) {\n      return cache;\n    }\n  }\n  cache = {\n    context: context\n  };\n  this.fontCaches.push(cache);\n  return cache;\n};\n\n// set up canvas context with font\n// returns transformed text string\nCRp$6.setupTextStyle = function (context, ele) {\n  var useEleOpacity = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  // Font style\n  var labelStyle = ele.pstyle('font-style').strValue;\n  var labelSize = ele.pstyle('font-size').pfValue + 'px';\n  var labelFamily = ele.pstyle('font-family').strValue;\n  var labelWeight = ele.pstyle('font-weight').strValue;\n  var opacity = useEleOpacity ? ele.effectiveOpacity() * ele.pstyle('text-opacity').value : 1;\n  var outlineOpacity = ele.pstyle('text-outline-opacity').value * opacity;\n  var color = ele.pstyle('color').value;\n  var outlineColor = ele.pstyle('text-outline-color').value;\n  context.font = labelStyle + ' ' + labelWeight + ' ' + labelSize + ' ' + labelFamily;\n  context.lineJoin = 'round'; // so text outlines aren't jagged\n\n  this.colorFillStyle(context, color[0], color[1], color[2], opacity);\n  this.colorStrokeStyle(context, outlineColor[0], outlineColor[1], outlineColor[2], outlineOpacity);\n};\n\n// TODO ensure re-used\nfunction roundRect(ctx, x, y, width, height) {\n  var radius = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 5;\n  var stroke = arguments.length > 6 ? arguments[6] : undefined;\n  ctx.beginPath();\n  ctx.moveTo(x + radius, y);\n  ctx.lineTo(x + width - radius, y);\n  ctx.quadraticCurveTo(x + width, y, x + width, y + radius);\n  ctx.lineTo(x + width, y + height - radius);\n  ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);\n  ctx.lineTo(x + radius, y + height);\n  ctx.quadraticCurveTo(x, y + height, x, y + height - radius);\n  ctx.lineTo(x, y + radius);\n  ctx.quadraticCurveTo(x, y, x + radius, y);\n  ctx.closePath();\n  if (stroke) ctx.stroke();else ctx.fill();\n}\nCRp$6.getTextAngle = function (ele, prefix) {\n  var theta;\n  var _p = ele._private;\n  var rscratch = _p.rscratch;\n  var pdash = prefix ? prefix + '-' : '';\n  var rotation = ele.pstyle(pdash + 'text-rotation');\n  var textAngle = getPrefixedProperty(rscratch, 'labelAngle', prefix);\n  if (rotation.strValue === 'autorotate') {\n    theta = ele.isEdge() ? textAngle : 0;\n  } else if (rotation.strValue === 'none') {\n    theta = 0;\n  } else {\n    theta = rotation.pfValue;\n  }\n  return theta;\n};\nCRp$6.drawText = function (context, ele, prefix) {\n  var applyRotation = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n  var useEleOpacity = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n  var _p = ele._private;\n  var rscratch = _p.rscratch;\n  var parentOpacity = useEleOpacity ? ele.effectiveOpacity() : 1;\n  if (useEleOpacity && (parentOpacity === 0 || ele.pstyle('text-opacity').value === 0)) {\n    return;\n  }\n\n  // use 'main' as an alias for the main label (i.e. null prefix)\n  if (prefix === 'main') {\n    prefix = null;\n  }\n  var textX = getPrefixedProperty(rscratch, 'labelX', prefix);\n  var textY = getPrefixedProperty(rscratch, 'labelY', prefix);\n  var orgTextX, orgTextY; // used for rotation\n  var text = this.getLabelText(ele, prefix);\n  if (text != null && text !== '' && !isNaN(textX) && !isNaN(textY)) {\n    this.setupTextStyle(context, ele, useEleOpacity);\n    var pdash = prefix ? prefix + '-' : '';\n    var textW = getPrefixedProperty(rscratch, 'labelWidth', prefix);\n    var textH = getPrefixedProperty(rscratch, 'labelHeight', prefix);\n    var marginX = ele.pstyle(pdash + 'text-margin-x').pfValue;\n    var marginY = ele.pstyle(pdash + 'text-margin-y').pfValue;\n    var isEdge = ele.isEdge();\n    var halign = ele.pstyle('text-halign').value;\n    var valign = ele.pstyle('text-valign').value;\n    if (isEdge) {\n      halign = 'center';\n      valign = 'center';\n    }\n    textX += marginX;\n    textY += marginY;\n    var theta;\n    if (!applyRotation) {\n      theta = 0;\n    } else {\n      theta = this.getTextAngle(ele, prefix);\n    }\n    if (theta !== 0) {\n      orgTextX = textX;\n      orgTextY = textY;\n      context.translate(orgTextX, orgTextY);\n      context.rotate(theta);\n      textX = 0;\n      textY = 0;\n    }\n    switch (valign) {\n      case 'top':\n        break;\n      case 'center':\n        textY += textH / 2;\n        break;\n      case 'bottom':\n        textY += textH;\n        break;\n    }\n    var backgroundOpacity = ele.pstyle('text-background-opacity').value;\n    var borderOpacity = ele.pstyle('text-border-opacity').value;\n    var textBorderWidth = ele.pstyle('text-border-width').pfValue;\n    var backgroundPadding = ele.pstyle('text-background-padding').pfValue;\n    var styleShape = ele.pstyle('text-background-shape').strValue;\n    var rounded = styleShape.indexOf('round') === 0;\n    var roundRadius = 2;\n    if (backgroundOpacity > 0 || textBorderWidth > 0 && borderOpacity > 0) {\n      var bgX = textX - backgroundPadding;\n      switch (halign) {\n        case 'left':\n          bgX -= textW;\n          break;\n        case 'center':\n          bgX -= textW / 2;\n          break;\n      }\n      var bgY = textY - textH - backgroundPadding;\n      var bgW = textW + 2 * backgroundPadding;\n      var bgH = textH + 2 * backgroundPadding;\n      if (backgroundOpacity > 0) {\n        var textFill = context.fillStyle;\n        var textBackgroundColor = ele.pstyle('text-background-color').value;\n        context.fillStyle = 'rgba(' + textBackgroundColor[0] + ',' + textBackgroundColor[1] + ',' + textBackgroundColor[2] + ',' + backgroundOpacity * parentOpacity + ')';\n        if (rounded) {\n          roundRect(context, bgX, bgY, bgW, bgH, roundRadius);\n        } else {\n          context.fillRect(bgX, bgY, bgW, bgH);\n        }\n        context.fillStyle = textFill;\n      }\n      if (textBorderWidth > 0 && borderOpacity > 0) {\n        var textStroke = context.strokeStyle;\n        var textLineWidth = context.lineWidth;\n        var textBorderColor = ele.pstyle('text-border-color').value;\n        var textBorderStyle = ele.pstyle('text-border-style').value;\n        context.strokeStyle = 'rgba(' + textBorderColor[0] + ',' + textBorderColor[1] + ',' + textBorderColor[2] + ',' + borderOpacity * parentOpacity + ')';\n        context.lineWidth = textBorderWidth;\n        if (context.setLineDash) {\n          // for very outofdate browsers\n          switch (textBorderStyle) {\n            case 'dotted':\n              context.setLineDash([1, 1]);\n              break;\n            case 'dashed':\n              context.setLineDash([4, 2]);\n              break;\n            case 'double':\n              context.lineWidth = textBorderWidth / 4; // 50% reserved for white between the two borders\n              context.setLineDash([]);\n              break;\n            case 'solid':\n              context.setLineDash([]);\n              break;\n          }\n        }\n        if (rounded) {\n          roundRect(context, bgX, bgY, bgW, bgH, roundRadius, 'stroke');\n        } else {\n          context.strokeRect(bgX, bgY, bgW, bgH);\n        }\n        if (textBorderStyle === 'double') {\n          var whiteWidth = textBorderWidth / 2;\n          if (rounded) {\n            roundRect(context, bgX + whiteWidth, bgY + whiteWidth, bgW - whiteWidth * 2, bgH - whiteWidth * 2, roundRadius, 'stroke');\n          } else {\n            context.strokeRect(bgX + whiteWidth, bgY + whiteWidth, bgW - whiteWidth * 2, bgH - whiteWidth * 2);\n          }\n        }\n        if (context.setLineDash) {\n          // for very outofdate browsers\n          context.setLineDash([]);\n        }\n        context.lineWidth = textLineWidth;\n        context.strokeStyle = textStroke;\n      }\n    }\n    var lineWidth = 2 * ele.pstyle('text-outline-width').pfValue; // *2 b/c the stroke is drawn centred on the middle\n\n    if (lineWidth > 0) {\n      context.lineWidth = lineWidth;\n    }\n    if (ele.pstyle('text-wrap').value === 'wrap') {\n      var lines = getPrefixedProperty(rscratch, 'labelWrapCachedLines', prefix);\n      var lineHeight = getPrefixedProperty(rscratch, 'labelLineHeight', prefix);\n      var halfTextW = textW / 2;\n      var justification = this.getLabelJustification(ele);\n      if (justification === 'auto') ; else if (halign === 'left') {\n        // auto justification : right\n        if (justification === 'left') {\n          textX += -textW;\n        } else if (justification === 'center') {\n          textX += -halfTextW;\n        } // else same as auto\n      } else if (halign === 'center') {\n        // auto justfication : center\n        if (justification === 'left') {\n          textX += -halfTextW;\n        } else if (justification === 'right') {\n          textX += halfTextW;\n        } // else same as auto\n      } else if (halign === 'right') {\n        // auto justification : left\n        if (justification === 'center') {\n          textX += halfTextW;\n        } else if (justification === 'right') {\n          textX += textW;\n        } // else same as auto\n      }\n\n      switch (valign) {\n        case 'top':\n          textY -= (lines.length - 1) * lineHeight;\n          break;\n        case 'center':\n        case 'bottom':\n          textY -= (lines.length - 1) * lineHeight;\n          break;\n      }\n      for (var l = 0; l < lines.length; l++) {\n        if (lineWidth > 0) {\n          context.strokeText(lines[l], textX, textY);\n        }\n        context.fillText(lines[l], textX, textY);\n        textY += lineHeight;\n      }\n    } else {\n      if (lineWidth > 0) {\n        context.strokeText(text, textX, textY);\n      }\n      context.fillText(text, textX, textY);\n    }\n    if (theta !== 0) {\n      context.rotate(-theta);\n      context.translate(-orgTextX, -orgTextY);\n    }\n  }\n};\n\n/* global Path2D */\nvar CRp$5 = {};\nCRp$5.drawNode = function (context, node, shiftToOriginWithBb) {\n  var drawLabel = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n  var shouldDrawOverlay = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n  var shouldDrawOpacity = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;\n  var r = this;\n  var nodeWidth, nodeHeight;\n  var _p = node._private;\n  var rs = _p.rscratch;\n  var pos = node.position();\n  if (!number$1(pos.x) || !number$1(pos.y)) {\n    return; // can't draw node with undefined position\n  }\n\n  if (shouldDrawOpacity && !node.visible()) {\n    return;\n  }\n  var eleOpacity = shouldDrawOpacity ? node.effectiveOpacity() : 1;\n  var usePaths = r.usePaths();\n  var path;\n  var pathCacheHit = false;\n  var padding = node.padding();\n  nodeWidth = node.width() + 2 * padding;\n  nodeHeight = node.height() + 2 * padding;\n\n  //\n  // setup shift\n\n  var bb;\n  if (shiftToOriginWithBb) {\n    bb = shiftToOriginWithBb;\n    context.translate(-bb.x1, -bb.y1);\n  }\n\n  //\n  // load bg image\n\n  var bgImgProp = node.pstyle('background-image');\n  var urls = bgImgProp.value;\n  var urlDefined = new Array(urls.length);\n  var image = new Array(urls.length);\n  var numImages = 0;\n  for (var i = 0; i < urls.length; i++) {\n    var url = urls[i];\n    var defd = urlDefined[i] = url != null && url !== 'none';\n    if (defd) {\n      var bgImgCrossOrigin = node.cy().style().getIndexedStyle(node, 'background-image-crossorigin', 'value', i);\n      numImages++;\n\n      // get image, and if not loaded then ask to redraw when later loaded\n      image[i] = r.getCachedImage(url, bgImgCrossOrigin, function () {\n        _p.backgroundTimestamp = Date.now();\n        node.emitAndNotify('background');\n      });\n    }\n  }\n\n  //\n  // setup styles\n\n  var darkness = node.pstyle('background-blacken').value;\n  var borderWidth = node.pstyle('border-width').pfValue;\n  var bgOpacity = node.pstyle('background-opacity').value * eleOpacity;\n  var borderColor = node.pstyle('border-color').value;\n  var borderStyle = node.pstyle('border-style').value;\n  var borderJoin = node.pstyle('border-join').value;\n  var borderCap = node.pstyle('border-cap').value;\n  var borderPosition = node.pstyle('border-position').value;\n  var borderPattern = node.pstyle('border-dash-pattern').pfValue;\n  var borderOffset = node.pstyle('border-dash-offset').pfValue;\n  var borderOpacity = node.pstyle('border-opacity').value * eleOpacity;\n  var outlineWidth = node.pstyle('outline-width').pfValue;\n  var outlineColor = node.pstyle('outline-color').value;\n  var outlineStyle = node.pstyle('outline-style').value;\n  var outlineOpacity = node.pstyle('outline-opacity').value * eleOpacity;\n  var outlineOffset = node.pstyle('outline-offset').value;\n  var cornerRadius = node.pstyle('corner-radius').value;\n  if (cornerRadius !== 'auto') cornerRadius = node.pstyle('corner-radius').pfValue;\n  var setupShapeColor = function setupShapeColor() {\n    var bgOpy = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : bgOpacity;\n    r.eleFillStyle(context, node, bgOpy);\n  };\n  var setupBorderColor = function setupBorderColor() {\n    var bdrOpy = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : borderOpacity;\n    r.colorStrokeStyle(context, borderColor[0], borderColor[1], borderColor[2], bdrOpy);\n  };\n  var setupOutlineColor = function setupOutlineColor() {\n    var otlnOpy = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : outlineOpacity;\n    r.colorStrokeStyle(context, outlineColor[0], outlineColor[1], outlineColor[2], otlnOpy);\n  };\n\n  //\n  // setup shape\n\n  var getPath = function getPath(width, height, shape, points) {\n    var pathCache = r.nodePathCache = r.nodePathCache || [];\n    var key = hashStrings(shape === 'polygon' ? shape + ',' + points.join(',') : shape, '' + height, '' + width, '' + cornerRadius);\n    var cachedPath = pathCache[key];\n    var path;\n    var cacheHit = false;\n    if (cachedPath != null) {\n      path = cachedPath;\n      cacheHit = true;\n      rs.pathCache = path;\n    } else {\n      path = new Path2D();\n      pathCache[key] = rs.pathCache = path;\n    }\n    return {\n      path: path,\n      cacheHit: cacheHit\n    };\n  };\n  var styleShape = node.pstyle('shape').strValue;\n  var shapePts = node.pstyle('shape-polygon-points').pfValue;\n  if (usePaths) {\n    context.translate(pos.x, pos.y);\n    var shapePath = getPath(nodeWidth, nodeHeight, styleShape, shapePts);\n    path = shapePath.path;\n    pathCacheHit = shapePath.cacheHit;\n  }\n  var drawShape = function drawShape() {\n    if (!pathCacheHit) {\n      var npos = pos;\n      if (usePaths) {\n        npos = {\n          x: 0,\n          y: 0\n        };\n      }\n      r.nodeShapes[r.getNodeShape(node)].draw(path || context, npos.x, npos.y, nodeWidth, nodeHeight, cornerRadius, rs);\n    }\n    if (usePaths) {\n      context.fill(path);\n    } else {\n      context.fill();\n    }\n  };\n  var drawImages = function drawImages() {\n    var nodeOpacity = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : eleOpacity;\n    var inside = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    var prevBging = _p.backgrounding;\n    var totalCompleted = 0;\n    for (var _i = 0; _i < image.length; _i++) {\n      var bgContainment = node.cy().style().getIndexedStyle(node, 'background-image-containment', 'value', _i);\n      if (inside && bgContainment === 'over' || !inside && bgContainment === 'inside') {\n        totalCompleted++;\n        continue;\n      }\n      if (urlDefined[_i] && image[_i].complete && !image[_i].error) {\n        totalCompleted++;\n        r.drawInscribedImage(context, image[_i], node, _i, nodeOpacity);\n      }\n    }\n    _p.backgrounding = !(totalCompleted === numImages);\n    if (prevBging !== _p.backgrounding) {\n      // update style b/c :backgrounding state changed\n      node.updateStyle(false);\n    }\n  };\n  var drawPie = function drawPie() {\n    var redrawShape = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    var pieOpacity = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : eleOpacity;\n    if (r.hasPie(node)) {\n      r.drawPie(context, node, pieOpacity);\n\n      // redraw/restore path if steps after pie need it\n      if (redrawShape) {\n        if (!usePaths) {\n          r.nodeShapes[r.getNodeShape(node)].draw(context, pos.x, pos.y, nodeWidth, nodeHeight, cornerRadius, rs);\n        }\n      }\n    }\n  };\n  var darken = function darken() {\n    var darkenOpacity = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : eleOpacity;\n    var opacity = (darkness > 0 ? darkness : -darkness) * darkenOpacity;\n    var c = darkness > 0 ? 0 : 255;\n    if (darkness !== 0) {\n      r.colorFillStyle(context, c, c, c, opacity);\n      if (usePaths) {\n        context.fill(path);\n      } else {\n        context.fill();\n      }\n    }\n  };\n  var drawBorder = function drawBorder() {\n    if (borderWidth > 0) {\n      context.lineWidth = borderWidth;\n      context.lineCap = borderCap;\n      context.lineJoin = borderJoin;\n      if (context.setLineDash) {\n        // for very outofdate browsers\n        switch (borderStyle) {\n          case 'dotted':\n            context.setLineDash([1, 1]);\n            break;\n          case 'dashed':\n            context.setLineDash(borderPattern);\n            context.lineDashOffset = borderOffset;\n            break;\n          case 'solid':\n          case 'double':\n            context.setLineDash([]);\n            break;\n        }\n      }\n      if (borderPosition !== 'center') {\n        context.save();\n        context.lineWidth *= 2;\n        if (borderPosition === 'inside') {\n          usePaths ? context.clip(path) : context.clip();\n        } else {\n          var region = new Path2D();\n          region.rect(-nodeWidth / 2 - borderWidth, -nodeHeight / 2 - borderWidth, nodeWidth + 2 * borderWidth, nodeHeight + 2 * borderWidth);\n          region.addPath(path);\n          context.clip(region, 'evenodd');\n        }\n        usePaths ? context.stroke(path) : context.stroke();\n        context.restore();\n      } else {\n        usePaths ? context.stroke(path) : context.stroke();\n      }\n      if (borderStyle === 'double') {\n        context.lineWidth = borderWidth / 3;\n        var gco = context.globalCompositeOperation;\n        context.globalCompositeOperation = 'destination-out';\n        if (usePaths) {\n          context.stroke(path);\n        } else {\n          context.stroke();\n        }\n        context.globalCompositeOperation = gco;\n      }\n\n      // reset in case we changed the border style\n      if (context.setLineDash) {\n        // for very outofdate browsers\n        context.setLineDash([]);\n      }\n    }\n  };\n  var drawOutline = function drawOutline() {\n    if (outlineWidth > 0) {\n      context.lineWidth = outlineWidth;\n      context.lineCap = 'butt';\n      if (context.setLineDash) {\n        // for very outofdate browsers\n        switch (outlineStyle) {\n          case 'dotted':\n            context.setLineDash([1, 1]);\n            break;\n          case 'dashed':\n            context.setLineDash([4, 2]);\n            break;\n          case 'solid':\n          case 'double':\n            context.setLineDash([]);\n            break;\n        }\n      }\n      var npos = pos;\n      if (usePaths) {\n        npos = {\n          x: 0,\n          y: 0\n        };\n      }\n      var shape = r.getNodeShape(node);\n      var bWidth = borderWidth;\n      if (borderPosition === 'inside') bWidth = 0;\n      if (borderPosition === 'outside') bWidth *= 2;\n      var scaleX = (nodeWidth + bWidth + (outlineWidth + outlineOffset)) / nodeWidth;\n      var scaleY = (nodeHeight + bWidth + (outlineWidth + outlineOffset)) / nodeHeight;\n      var sWidth = nodeWidth * scaleX;\n      var sHeight = nodeHeight * scaleY;\n      var points = r.nodeShapes[shape].points;\n      var _path;\n      if (usePaths) {\n        var outlinePath = getPath(sWidth, sHeight, shape, points);\n        _path = outlinePath.path;\n      }\n\n      // draw the outline path, either by using expanded points or by scaling \n      // the dimensions, depending on shape\n      if (shape === \"ellipse\") {\n        r.drawEllipsePath(_path || context, npos.x, npos.y, sWidth, sHeight);\n      } else if (['round-diamond', 'round-heptagon', 'round-hexagon', 'round-octagon', 'round-pentagon', 'round-polygon', 'round-triangle', 'round-tag'].includes(shape)) {\n        var sMult = 0;\n        var offsetX = 0;\n        var offsetY = 0;\n        if (shape === 'round-diamond') {\n          sMult = (bWidth + outlineOffset + outlineWidth) * 1.4;\n        } else if (shape === 'round-heptagon') {\n          sMult = (bWidth + outlineOffset + outlineWidth) * 1.075;\n          offsetY = -(bWidth / 2 + outlineOffset + outlineWidth) / 35;\n        } else if (shape === 'round-hexagon') {\n          sMult = (bWidth + outlineOffset + outlineWidth) * 1.12;\n        } else if (shape === 'round-pentagon') {\n          sMult = (bWidth + outlineOffset + outlineWidth) * 1.13;\n          offsetY = -(bWidth / 2 + outlineOffset + outlineWidth) / 15;\n        } else if (shape === 'round-tag') {\n          sMult = (bWidth + outlineOffset + outlineWidth) * 1.12;\n          offsetX = (bWidth / 2 + outlineWidth + outlineOffset) * .07;\n        } else if (shape === 'round-triangle') {\n          sMult = (bWidth + outlineOffset + outlineWidth) * (Math.PI / 2);\n          offsetY = -(bWidth + outlineOffset / 2 + outlineWidth) / Math.PI;\n        }\n        if (sMult !== 0) {\n          scaleX = (nodeWidth + sMult) / nodeWidth;\n          sWidth = nodeWidth * scaleX;\n          if (!['round-hexagon', 'round-tag'].includes(shape)) {\n            scaleY = (nodeHeight + sMult) / nodeHeight;\n            sHeight = nodeHeight * scaleY;\n          }\n        }\n        cornerRadius = cornerRadius === 'auto' ? getRoundPolygonRadius(sWidth, sHeight) : cornerRadius;\n        var halfW = sWidth / 2;\n        var halfH = sHeight / 2;\n        var radius = cornerRadius + (bWidth + outlineWidth + outlineOffset) / 2;\n        var p = new Array(points.length / 2);\n        var corners = new Array(points.length / 2);\n        for (var _i3 = 0; _i3 < points.length / 2; _i3++) {\n          p[_i3] = {\n            x: npos.x + offsetX + halfW * points[_i3 * 2],\n            y: npos.y + offsetY + halfH * points[_i3 * 2 + 1]\n          };\n        }\n        var _i2,\n          p1,\n          p2,\n          p3,\n          len = p.length;\n        p1 = p[len - 1];\n        // for each point\n        for (_i2 = 0; _i2 < len; _i2++) {\n          p2 = p[_i2 % len];\n          p3 = p[(_i2 + 1) % len];\n          corners[_i2] = getRoundCorner(p1, p2, p3, radius);\n          p1 = p2;\n          p2 = p3;\n        }\n        r.drawRoundPolygonPath(_path || context, npos.x + offsetX, npos.y + offsetY, nodeWidth * scaleX, nodeHeight * scaleY, points, corners);\n      } else if (['roundrectangle', 'round-rectangle'].includes(shape)) {\n        cornerRadius = cornerRadius === 'auto' ? getRoundRectangleRadius(sWidth, sHeight) : cornerRadius;\n        r.drawRoundRectanglePath(_path || context, npos.x, npos.y, sWidth, sHeight, cornerRadius + (bWidth + outlineWidth + outlineOffset) / 2);\n      } else if (['cutrectangle', 'cut-rectangle'].includes(shape)) {\n        cornerRadius = cornerRadius === 'auto' ? getCutRectangleCornerLength() : cornerRadius;\n        r.drawCutRectanglePath(_path || context, npos.x, npos.y, sWidth, sHeight, null, cornerRadius + (bWidth + outlineWidth + outlineOffset) / 4);\n      } else if (['bottomroundrectangle', 'bottom-round-rectangle'].includes(shape)) {\n        cornerRadius = cornerRadius === 'auto' ? getRoundRectangleRadius(sWidth, sHeight) : cornerRadius;\n        r.drawBottomRoundRectanglePath(_path || context, npos.x, npos.y, sWidth, sHeight, cornerRadius + (bWidth + outlineWidth + outlineOffset) / 2);\n      } else if (shape === \"barrel\") {\n        r.drawBarrelPath(_path || context, npos.x, npos.y, sWidth, sHeight);\n      } else if (shape.startsWith(\"polygon\") || ['rhomboid', 'right-rhomboid', 'round-tag', 'tag', 'vee'].includes(shape)) {\n        var pad = (bWidth + outlineWidth + outlineOffset) / nodeWidth;\n        points = joinLines(expandPolygon(points, pad));\n        r.drawPolygonPath(_path || context, npos.x, npos.y, nodeWidth, nodeHeight, points);\n      } else {\n        var _pad = (bWidth + outlineWidth + outlineOffset) / nodeWidth;\n        points = joinLines(expandPolygon(points, -_pad));\n        r.drawPolygonPath(_path || context, npos.x, npos.y, nodeWidth, nodeHeight, points);\n      }\n      if (usePaths) {\n        context.stroke(_path);\n      } else {\n        context.stroke();\n      }\n      if (outlineStyle === 'double') {\n        context.lineWidth = bWidth / 3;\n        var gco = context.globalCompositeOperation;\n        context.globalCompositeOperation = 'destination-out';\n        if (usePaths) {\n          context.stroke(_path);\n        } else {\n          context.stroke();\n        }\n        context.globalCompositeOperation = gco;\n      }\n\n      // reset in case we changed the border style\n      if (context.setLineDash) {\n        // for very outofdate browsers\n        context.setLineDash([]);\n      }\n    }\n  };\n  var drawOverlay = function drawOverlay() {\n    if (shouldDrawOverlay) {\n      r.drawNodeOverlay(context, node, pos, nodeWidth, nodeHeight);\n    }\n  };\n  var drawUnderlay = function drawUnderlay() {\n    if (shouldDrawOverlay) {\n      r.drawNodeUnderlay(context, node, pos, nodeWidth, nodeHeight);\n    }\n  };\n  var drawText = function drawText() {\n    r.drawElementText(context, node, null, drawLabel);\n  };\n  var ghost = node.pstyle('ghost').value === 'yes';\n  if (ghost) {\n    var gx = node.pstyle('ghost-offset-x').pfValue;\n    var gy = node.pstyle('ghost-offset-y').pfValue;\n    var ghostOpacity = node.pstyle('ghost-opacity').value;\n    var effGhostOpacity = ghostOpacity * eleOpacity;\n    context.translate(gx, gy);\n    setupOutlineColor();\n    drawOutline();\n    setupShapeColor(ghostOpacity * bgOpacity);\n    drawShape();\n    drawImages(effGhostOpacity, true);\n    setupBorderColor(ghostOpacity * borderOpacity);\n    drawBorder();\n    drawPie(darkness !== 0 || borderWidth !== 0);\n    drawImages(effGhostOpacity, false);\n    darken(effGhostOpacity);\n    context.translate(-gx, -gy);\n  }\n  if (usePaths) {\n    context.translate(-pos.x, -pos.y);\n  }\n  drawUnderlay();\n  if (usePaths) {\n    context.translate(pos.x, pos.y);\n  }\n  setupOutlineColor();\n  drawOutline();\n  setupShapeColor();\n  drawShape();\n  drawImages(eleOpacity, true);\n  setupBorderColor();\n  drawBorder();\n  drawPie(darkness !== 0 || borderWidth !== 0);\n  drawImages(eleOpacity, false);\n  darken();\n  if (usePaths) {\n    context.translate(-pos.x, -pos.y);\n  }\n  drawText();\n  drawOverlay();\n\n  //\n  // clean up shift\n\n  if (shiftToOriginWithBb) {\n    context.translate(bb.x1, bb.y1);\n  }\n};\nvar drawNodeOverlayUnderlay = function drawNodeOverlayUnderlay(overlayOrUnderlay) {\n  if (!['overlay', 'underlay'].includes(overlayOrUnderlay)) {\n    throw new Error('Invalid state');\n  }\n  return function (context, node, pos, nodeWidth, nodeHeight) {\n    var r = this;\n    if (!node.visible()) {\n      return;\n    }\n    var padding = node.pstyle(\"\".concat(overlayOrUnderlay, \"-padding\")).pfValue;\n    var opacity = node.pstyle(\"\".concat(overlayOrUnderlay, \"-opacity\")).value;\n    var color = node.pstyle(\"\".concat(overlayOrUnderlay, \"-color\")).value;\n    var shape = node.pstyle(\"\".concat(overlayOrUnderlay, \"-shape\")).value;\n    var radius = node.pstyle(\"\".concat(overlayOrUnderlay, \"-corner-radius\")).value;\n    if (opacity > 0) {\n      pos = pos || node.position();\n      if (nodeWidth == null || nodeHeight == null) {\n        var _padding = node.padding();\n        nodeWidth = node.width() + 2 * _padding;\n        nodeHeight = node.height() + 2 * _padding;\n      }\n      r.colorFillStyle(context, color[0], color[1], color[2], opacity);\n      r.nodeShapes[shape].draw(context, pos.x, pos.y, nodeWidth + padding * 2, nodeHeight + padding * 2, radius);\n      context.fill();\n    }\n  };\n};\nCRp$5.drawNodeOverlay = drawNodeOverlayUnderlay('overlay');\nCRp$5.drawNodeUnderlay = drawNodeOverlayUnderlay('underlay');\n\n// does the node have at least one pie piece?\nCRp$5.hasPie = function (node) {\n  node = node[0]; // ensure ele ref\n\n  return node._private.hasPie;\n};\nCRp$5.drawPie = function (context, node, nodeOpacity, pos) {\n  node = node[0]; // ensure ele ref\n  pos = pos || node.position();\n  var cyStyle = node.cy().style();\n  var pieSize = node.pstyle('pie-size');\n  var x = pos.x;\n  var y = pos.y;\n  var nodeW = node.width();\n  var nodeH = node.height();\n  var radius = Math.min(nodeW, nodeH) / 2; // must fit in node\n  var lastPercent = 0; // what % to continue drawing pie slices from on [0, 1]\n  var usePaths = this.usePaths();\n  if (usePaths) {\n    x = 0;\n    y = 0;\n  }\n  if (pieSize.units === '%') {\n    radius = radius * pieSize.pfValue;\n  } else if (pieSize.pfValue !== undefined) {\n    radius = pieSize.pfValue / 2;\n  }\n  for (var i = 1; i <= cyStyle.pieBackgroundN; i++) {\n    // 1..N\n    var size = node.pstyle('pie-' + i + '-background-size').value;\n    var color = node.pstyle('pie-' + i + '-background-color').value;\n    var opacity = node.pstyle('pie-' + i + '-background-opacity').value * nodeOpacity;\n    var percent = size / 100; // map integer range [0, 100] to [0, 1]\n\n    // percent can't push beyond 1\n    if (percent + lastPercent > 1) {\n      percent = 1 - lastPercent;\n    }\n    var angleStart = 1.5 * Math.PI + 2 * Math.PI * lastPercent; // start at 12 o'clock and go clockwise\n    var angleDelta = 2 * Math.PI * percent;\n    var angleEnd = angleStart + angleDelta;\n\n    // ignore if\n    // - zero size\n    // - we're already beyond the full circle\n    // - adding the current slice would go beyond the full circle\n    if (size === 0 || lastPercent >= 1 || lastPercent + percent > 1) {\n      continue;\n    }\n    context.beginPath();\n    context.moveTo(x, y);\n    context.arc(x, y, radius, angleStart, angleEnd);\n    context.closePath();\n    this.colorFillStyle(context, color[0], color[1], color[2], opacity);\n    context.fill();\n    lastPercent += percent;\n  }\n};\n\nvar CRp$4 = {};\nvar motionBlurDelay = 100;\n\n// var isFirefox = typeof InstallTrigger !== 'undefined';\n\nCRp$4.getPixelRatio = function () {\n  var context = this.data.contexts[0];\n  if (this.forcedPixelRatio != null) {\n    return this.forcedPixelRatio;\n  }\n  var containerWindow = this.cy.window();\n  var backingStore = context.backingStorePixelRatio || context.webkitBackingStorePixelRatio || context.mozBackingStorePixelRatio || context.msBackingStorePixelRatio || context.oBackingStorePixelRatio || context.backingStorePixelRatio || 1;\n  return (containerWindow.devicePixelRatio || 1) / backingStore; // eslint-disable-line no-undef\n};\n\nCRp$4.paintCache = function (context) {\n  var caches = this.paintCaches = this.paintCaches || [];\n  var needToCreateCache = true;\n  var cache;\n  for (var i = 0; i < caches.length; i++) {\n    cache = caches[i];\n    if (cache.context === context) {\n      needToCreateCache = false;\n      break;\n    }\n  }\n  if (needToCreateCache) {\n    cache = {\n      context: context\n    };\n    caches.push(cache);\n  }\n  return cache;\n};\nCRp$4.createGradientStyleFor = function (context, shapeStyleName, ele, fill, opacity) {\n  var gradientStyle;\n  var usePaths = this.usePaths();\n  var colors = ele.pstyle(shapeStyleName + '-gradient-stop-colors').value,\n    positions = ele.pstyle(shapeStyleName + '-gradient-stop-positions').pfValue;\n  if (fill === 'radial-gradient') {\n    if (ele.isEdge()) {\n      var start = ele.sourceEndpoint(),\n        end = ele.targetEndpoint(),\n        mid = ele.midpoint();\n      var d1 = dist(start, mid);\n      var d2 = dist(end, mid);\n      gradientStyle = context.createRadialGradient(mid.x, mid.y, 0, mid.x, mid.y, Math.max(d1, d2));\n    } else {\n      var pos = usePaths ? {\n          x: 0,\n          y: 0\n        } : ele.position(),\n        width = ele.paddedWidth(),\n        height = ele.paddedHeight();\n      gradientStyle = context.createRadialGradient(pos.x, pos.y, 0, pos.x, pos.y, Math.max(width, height));\n    }\n  } else {\n    if (ele.isEdge()) {\n      var _start = ele.sourceEndpoint(),\n        _end = ele.targetEndpoint();\n      gradientStyle = context.createLinearGradient(_start.x, _start.y, _end.x, _end.y);\n    } else {\n      var _pos = usePaths ? {\n          x: 0,\n          y: 0\n        } : ele.position(),\n        _width = ele.paddedWidth(),\n        _height = ele.paddedHeight(),\n        halfWidth = _width / 2,\n        halfHeight = _height / 2;\n      var direction = ele.pstyle('background-gradient-direction').value;\n      switch (direction) {\n        case 'to-bottom':\n          gradientStyle = context.createLinearGradient(_pos.x, _pos.y - halfHeight, _pos.x, _pos.y + halfHeight);\n          break;\n        case 'to-top':\n          gradientStyle = context.createLinearGradient(_pos.x, _pos.y + halfHeight, _pos.x, _pos.y - halfHeight);\n          break;\n        case 'to-left':\n          gradientStyle = context.createLinearGradient(_pos.x + halfWidth, _pos.y, _pos.x - halfWidth, _pos.y);\n          break;\n        case 'to-right':\n          gradientStyle = context.createLinearGradient(_pos.x - halfWidth, _pos.y, _pos.x + halfWidth, _pos.y);\n          break;\n        case 'to-bottom-right':\n        case 'to-right-bottom':\n          gradientStyle = context.createLinearGradient(_pos.x - halfWidth, _pos.y - halfHeight, _pos.x + halfWidth, _pos.y + halfHeight);\n          break;\n        case 'to-top-right':\n        case 'to-right-top':\n          gradientStyle = context.createLinearGradient(_pos.x - halfWidth, _pos.y + halfHeight, _pos.x + halfWidth, _pos.y - halfHeight);\n          break;\n        case 'to-bottom-left':\n        case 'to-left-bottom':\n          gradientStyle = context.createLinearGradient(_pos.x + halfWidth, _pos.y - halfHeight, _pos.x - halfWidth, _pos.y + halfHeight);\n          break;\n        case 'to-top-left':\n        case 'to-left-top':\n          gradientStyle = context.createLinearGradient(_pos.x + halfWidth, _pos.y + halfHeight, _pos.x - halfWidth, _pos.y - halfHeight);\n          break;\n      }\n    }\n  }\n  if (!gradientStyle) return null; // invalid gradient style\n\n  var hasPositions = positions.length === colors.length;\n  var length = colors.length;\n  for (var i = 0; i < length; i++) {\n    gradientStyle.addColorStop(hasPositions ? positions[i] : i / (length - 1), 'rgba(' + colors[i][0] + ',' + colors[i][1] + ',' + colors[i][2] + ',' + opacity + ')');\n  }\n  return gradientStyle;\n};\nCRp$4.gradientFillStyle = function (context, ele, fill, opacity) {\n  var gradientStyle = this.createGradientStyleFor(context, 'background', ele, fill, opacity);\n  if (!gradientStyle) return null; // error\n  context.fillStyle = gradientStyle;\n};\nCRp$4.colorFillStyle = function (context, r, g, b, a) {\n  context.fillStyle = 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';\n  // turn off for now, seems context does its own caching\n\n  // var cache = this.paintCache(context);\n\n  // var fillStyle = 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';\n\n  // if( cache.fillStyle !== fillStyle ){\n  //   context.fillStyle = cache.fillStyle = fillStyle;\n  // }\n};\n\nCRp$4.eleFillStyle = function (context, ele, opacity) {\n  var backgroundFill = ele.pstyle('background-fill').value;\n  if (backgroundFill === 'linear-gradient' || backgroundFill === 'radial-gradient') {\n    this.gradientFillStyle(context, ele, backgroundFill, opacity);\n  } else {\n    var backgroundColor = ele.pstyle('background-color').value;\n    this.colorFillStyle(context, backgroundColor[0], backgroundColor[1], backgroundColor[2], opacity);\n  }\n};\nCRp$4.gradientStrokeStyle = function (context, ele, fill, opacity) {\n  var gradientStyle = this.createGradientStyleFor(context, 'line', ele, fill, opacity);\n  if (!gradientStyle) return null; // error\n  context.strokeStyle = gradientStyle;\n};\nCRp$4.colorStrokeStyle = function (context, r, g, b, a) {\n  context.strokeStyle = 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';\n  // turn off for now, seems context does its own caching\n\n  // var cache = this.paintCache(context);\n\n  // var strokeStyle = 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';\n\n  // if( cache.strokeStyle !== strokeStyle ){\n  //   context.strokeStyle = cache.strokeStyle = strokeStyle;\n  // }\n};\n\nCRp$4.eleStrokeStyle = function (context, ele, opacity) {\n  var lineFill = ele.pstyle('line-fill').value;\n  if (lineFill === 'linear-gradient' || lineFill === 'radial-gradient') {\n    this.gradientStrokeStyle(context, ele, lineFill, opacity);\n  } else {\n    var lineColor = ele.pstyle('line-color').value;\n    this.colorStrokeStyle(context, lineColor[0], lineColor[1], lineColor[2], opacity);\n  }\n};\n\n// Resize canvas\nCRp$4.matchCanvasSize = function (container) {\n  var r = this;\n  var data = r.data;\n  var bb = r.findContainerClientCoords();\n  var width = bb[2];\n  var height = bb[3];\n  var pixelRatio = r.getPixelRatio();\n  var mbPxRatio = r.motionBlurPxRatio;\n  if (container === r.data.bufferCanvases[r.MOTIONBLUR_BUFFER_NODE] || container === r.data.bufferCanvases[r.MOTIONBLUR_BUFFER_DRAG]) {\n    pixelRatio = mbPxRatio;\n  }\n  var canvasWidth = width * pixelRatio;\n  var canvasHeight = height * pixelRatio;\n  var canvas;\n  if (canvasWidth === r.canvasWidth && canvasHeight === r.canvasHeight) {\n    return; // save cycles if same\n  }\n\n  r.fontCaches = null; // resizing resets the style\n\n  var canvasContainer = data.canvasContainer;\n  canvasContainer.style.width = width + 'px';\n  canvasContainer.style.height = height + 'px';\n  for (var i = 0; i < r.CANVAS_LAYERS; i++) {\n    canvas = data.canvases[i];\n    canvas.width = canvasWidth;\n    canvas.height = canvasHeight;\n    canvas.style.width = width + 'px';\n    canvas.style.height = height + 'px';\n  }\n  for (var i = 0; i < r.BUFFER_COUNT; i++) {\n    canvas = data.bufferCanvases[i];\n    canvas.width = canvasWidth;\n    canvas.height = canvasHeight;\n    canvas.style.width = width + 'px';\n    canvas.style.height = height + 'px';\n  }\n  r.textureMult = 1;\n  if (pixelRatio <= 1) {\n    canvas = data.bufferCanvases[r.TEXTURE_BUFFER];\n    r.textureMult = 2;\n    canvas.width = canvasWidth * r.textureMult;\n    canvas.height = canvasHeight * r.textureMult;\n  }\n  r.canvasWidth = canvasWidth;\n  r.canvasHeight = canvasHeight;\n};\nCRp$4.renderTo = function (cxt, zoom, pan, pxRatio) {\n  this.render({\n    forcedContext: cxt,\n    forcedZoom: zoom,\n    forcedPan: pan,\n    drawAllLayers: true,\n    forcedPxRatio: pxRatio\n  });\n};\nCRp$4.render = function (options) {\n  options = options || staticEmptyObject();\n  var forcedContext = options.forcedContext;\n  var drawAllLayers = options.drawAllLayers;\n  var drawOnlyNodeLayer = options.drawOnlyNodeLayer;\n  var forcedZoom = options.forcedZoom;\n  var forcedPan = options.forcedPan;\n  var r = this;\n  var pixelRatio = options.forcedPxRatio === undefined ? this.getPixelRatio() : options.forcedPxRatio;\n  var cy = r.cy;\n  var data = r.data;\n  var needDraw = data.canvasNeedsRedraw;\n  var textureDraw = r.textureOnViewport && !forcedContext && (r.pinching || r.hoverData.dragging || r.swipePanning || r.data.wheelZooming);\n  var motionBlur = options.motionBlur !== undefined ? options.motionBlur : r.motionBlur;\n  var mbPxRatio = r.motionBlurPxRatio;\n  var hasCompoundNodes = cy.hasCompoundNodes();\n  var inNodeDragGesture = r.hoverData.draggingEles;\n  var inBoxSelection = r.hoverData.selecting || r.touchData.selecting ? true : false;\n  motionBlur = motionBlur && !forcedContext && r.motionBlurEnabled && !inBoxSelection;\n  var motionBlurFadeEffect = motionBlur;\n  if (!forcedContext) {\n    if (r.prevPxRatio !== pixelRatio) {\n      r.invalidateContainerClientCoordsCache();\n      r.matchCanvasSize(r.container);\n      r.redrawHint('eles', true);\n      r.redrawHint('drag', true);\n    }\n    r.prevPxRatio = pixelRatio;\n  }\n  if (!forcedContext && r.motionBlurTimeout) {\n    clearTimeout(r.motionBlurTimeout);\n  }\n  if (motionBlur) {\n    if (r.mbFrames == null) {\n      r.mbFrames = 0;\n    }\n    r.mbFrames++;\n    if (r.mbFrames < 3) {\n      // need several frames before even high quality motionblur\n      motionBlurFadeEffect = false;\n    }\n\n    // go to lower quality blurry frames when several m/b frames have been rendered (avoids flashing)\n    if (r.mbFrames > r.minMbLowQualFrames) {\n      //r.fullQualityMb = false;\n      r.motionBlurPxRatio = r.mbPxRBlurry;\n    }\n  }\n  if (r.clearingMotionBlur) {\n    r.motionBlurPxRatio = 1;\n  }\n\n  // b/c drawToContext() may be async w.r.t. redraw(), keep track of last texture frame\n  // because a rogue async texture frame would clear needDraw\n  if (r.textureDrawLastFrame && !textureDraw) {\n    needDraw[r.NODE] = true;\n    needDraw[r.SELECT_BOX] = true;\n  }\n  var style = cy.style();\n  var zoom = cy.zoom();\n  var effectiveZoom = forcedZoom !== undefined ? forcedZoom : zoom;\n  var pan = cy.pan();\n  var effectivePan = {\n    x: pan.x,\n    y: pan.y\n  };\n  var vp = {\n    zoom: zoom,\n    pan: {\n      x: pan.x,\n      y: pan.y\n    }\n  };\n  var prevVp = r.prevViewport;\n  var viewportIsDiff = prevVp === undefined || vp.zoom !== prevVp.zoom || vp.pan.x !== prevVp.pan.x || vp.pan.y !== prevVp.pan.y;\n\n  // we want the low quality motionblur only when the viewport is being manipulated etc (where it's not noticed)\n  if (!viewportIsDiff && !(inNodeDragGesture && !hasCompoundNodes)) {\n    r.motionBlurPxRatio = 1;\n  }\n  if (forcedPan) {\n    effectivePan = forcedPan;\n  }\n\n  // apply pixel ratio\n\n  effectiveZoom *= pixelRatio;\n  effectivePan.x *= pixelRatio;\n  effectivePan.y *= pixelRatio;\n  var eles = r.getCachedZSortedEles();\n  function mbclear(context, x, y, w, h) {\n    var gco = context.globalCompositeOperation;\n    context.globalCompositeOperation = 'destination-out';\n    r.colorFillStyle(context, 255, 255, 255, r.motionBlurTransparency);\n    context.fillRect(x, y, w, h);\n    context.globalCompositeOperation = gco;\n  }\n  function setContextTransform(context, clear) {\n    var ePan, eZoom, w, h;\n    if (!r.clearingMotionBlur && (context === data.bufferContexts[r.MOTIONBLUR_BUFFER_NODE] || context === data.bufferContexts[r.MOTIONBLUR_BUFFER_DRAG])) {\n      ePan = {\n        x: pan.x * mbPxRatio,\n        y: pan.y * mbPxRatio\n      };\n      eZoom = zoom * mbPxRatio;\n      w = r.canvasWidth * mbPxRatio;\n      h = r.canvasHeight * mbPxRatio;\n    } else {\n      ePan = effectivePan;\n      eZoom = effectiveZoom;\n      w = r.canvasWidth;\n      h = r.canvasHeight;\n    }\n    context.setTransform(1, 0, 0, 1, 0, 0);\n    if (clear === 'motionBlur') {\n      mbclear(context, 0, 0, w, h);\n    } else if (!forcedContext && (clear === undefined || clear)) {\n      context.clearRect(0, 0, w, h);\n    }\n    if (!drawAllLayers) {\n      context.translate(ePan.x, ePan.y);\n      context.scale(eZoom, eZoom);\n    }\n    if (forcedPan) {\n      context.translate(forcedPan.x, forcedPan.y);\n    }\n    if (forcedZoom) {\n      context.scale(forcedZoom, forcedZoom);\n    }\n  }\n  if (!textureDraw) {\n    r.textureDrawLastFrame = false;\n  }\n  if (textureDraw) {\n    r.textureDrawLastFrame = true;\n    if (!r.textureCache) {\n      r.textureCache = {};\n      r.textureCache.bb = cy.mutableElements().boundingBox();\n      r.textureCache.texture = r.data.bufferCanvases[r.TEXTURE_BUFFER];\n      var cxt = r.data.bufferContexts[r.TEXTURE_BUFFER];\n      cxt.setTransform(1, 0, 0, 1, 0, 0);\n      cxt.clearRect(0, 0, r.canvasWidth * r.textureMult, r.canvasHeight * r.textureMult);\n      r.render({\n        forcedContext: cxt,\n        drawOnlyNodeLayer: true,\n        forcedPxRatio: pixelRatio * r.textureMult\n      });\n      var vp = r.textureCache.viewport = {\n        zoom: cy.zoom(),\n        pan: cy.pan(),\n        width: r.canvasWidth,\n        height: r.canvasHeight\n      };\n      vp.mpan = {\n        x: (0 - vp.pan.x) / vp.zoom,\n        y: (0 - vp.pan.y) / vp.zoom\n      };\n    }\n    needDraw[r.DRAG] = false;\n    needDraw[r.NODE] = false;\n    var context = data.contexts[r.NODE];\n    var texture = r.textureCache.texture;\n    var vp = r.textureCache.viewport;\n    context.setTransform(1, 0, 0, 1, 0, 0);\n    if (motionBlur) {\n      mbclear(context, 0, 0, vp.width, vp.height);\n    } else {\n      context.clearRect(0, 0, vp.width, vp.height);\n    }\n    var outsideBgColor = style.core('outside-texture-bg-color').value;\n    var outsideBgOpacity = style.core('outside-texture-bg-opacity').value;\n    r.colorFillStyle(context, outsideBgColor[0], outsideBgColor[1], outsideBgColor[2], outsideBgOpacity);\n    context.fillRect(0, 0, vp.width, vp.height);\n    var zoom = cy.zoom();\n    setContextTransform(context, false);\n    context.clearRect(vp.mpan.x, vp.mpan.y, vp.width / vp.zoom / pixelRatio, vp.height / vp.zoom / pixelRatio);\n    context.drawImage(texture, vp.mpan.x, vp.mpan.y, vp.width / vp.zoom / pixelRatio, vp.height / vp.zoom / pixelRatio);\n  } else if (r.textureOnViewport && !forcedContext) {\n    // clear the cache since we don't need it\n    r.textureCache = null;\n  }\n  var extent = cy.extent();\n  var vpManip = r.pinching || r.hoverData.dragging || r.swipePanning || r.data.wheelZooming || r.hoverData.draggingEles || r.cy.animated();\n  var hideEdges = r.hideEdgesOnViewport && vpManip;\n  var needMbClear = [];\n  needMbClear[r.NODE] = !needDraw[r.NODE] && motionBlur && !r.clearedForMotionBlur[r.NODE] || r.clearingMotionBlur;\n  if (needMbClear[r.NODE]) {\n    r.clearedForMotionBlur[r.NODE] = true;\n  }\n  needMbClear[r.DRAG] = !needDraw[r.DRAG] && motionBlur && !r.clearedForMotionBlur[r.DRAG] || r.clearingMotionBlur;\n  if (needMbClear[r.DRAG]) {\n    r.clearedForMotionBlur[r.DRAG] = true;\n  }\n  if (needDraw[r.NODE] || drawAllLayers || drawOnlyNodeLayer || needMbClear[r.NODE]) {\n    var useBuffer = motionBlur && !needMbClear[r.NODE] && mbPxRatio !== 1;\n    var context = forcedContext || (useBuffer ? r.data.bufferContexts[r.MOTIONBLUR_BUFFER_NODE] : data.contexts[r.NODE]);\n    var clear = motionBlur && !useBuffer ? 'motionBlur' : undefined;\n    setContextTransform(context, clear);\n    if (hideEdges) {\n      r.drawCachedNodes(context, eles.nondrag, pixelRatio, extent);\n    } else {\n      r.drawLayeredElements(context, eles.nondrag, pixelRatio, extent);\n    }\n    if (r.debug) {\n      r.drawDebugPoints(context, eles.nondrag);\n    }\n    if (!drawAllLayers && !motionBlur) {\n      needDraw[r.NODE] = false;\n    }\n  }\n  if (!drawOnlyNodeLayer && (needDraw[r.DRAG] || drawAllLayers || needMbClear[r.DRAG])) {\n    var useBuffer = motionBlur && !needMbClear[r.DRAG] && mbPxRatio !== 1;\n    var context = forcedContext || (useBuffer ? r.data.bufferContexts[r.MOTIONBLUR_BUFFER_DRAG] : data.contexts[r.DRAG]);\n    setContextTransform(context, motionBlur && !useBuffer ? 'motionBlur' : undefined);\n    if (hideEdges) {\n      r.drawCachedNodes(context, eles.drag, pixelRatio, extent);\n    } else {\n      r.drawCachedElements(context, eles.drag, pixelRatio, extent);\n    }\n    if (r.debug) {\n      r.drawDebugPoints(context, eles.drag);\n    }\n    if (!drawAllLayers && !motionBlur) {\n      needDraw[r.DRAG] = false;\n    }\n  }\n  if (r.showFps || !drawOnlyNodeLayer && needDraw[r.SELECT_BOX] && !drawAllLayers) {\n    var context = forcedContext || data.contexts[r.SELECT_BOX];\n    setContextTransform(context);\n    if (r.selection[4] == 1 && (r.hoverData.selecting || r.touchData.selecting)) {\n      var zoom = r.cy.zoom();\n      var borderWidth = style.core('selection-box-border-width').value / zoom;\n      context.lineWidth = borderWidth;\n      context.fillStyle = 'rgba(' + style.core('selection-box-color').value[0] + ',' + style.core('selection-box-color').value[1] + ',' + style.core('selection-box-color').value[2] + ',' + style.core('selection-box-opacity').value + ')';\n      context.fillRect(r.selection[0], r.selection[1], r.selection[2] - r.selection[0], r.selection[3] - r.selection[1]);\n      if (borderWidth > 0) {\n        context.strokeStyle = 'rgba(' + style.core('selection-box-border-color').value[0] + ',' + style.core('selection-box-border-color').value[1] + ',' + style.core('selection-box-border-color').value[2] + ',' + style.core('selection-box-opacity').value + ')';\n        context.strokeRect(r.selection[0], r.selection[1], r.selection[2] - r.selection[0], r.selection[3] - r.selection[1]);\n      }\n    }\n    if (data.bgActivePosistion && !r.hoverData.selecting) {\n      var zoom = r.cy.zoom();\n      var pos = data.bgActivePosistion;\n      context.fillStyle = 'rgba(' + style.core('active-bg-color').value[0] + ',' + style.core('active-bg-color').value[1] + ',' + style.core('active-bg-color').value[2] + ',' + style.core('active-bg-opacity').value + ')';\n      context.beginPath();\n      context.arc(pos.x, pos.y, style.core('active-bg-size').pfValue / zoom, 0, 2 * Math.PI);\n      context.fill();\n    }\n    var timeToRender = r.lastRedrawTime;\n    if (r.showFps && timeToRender) {\n      timeToRender = Math.round(timeToRender);\n      var fps = Math.round(1000 / timeToRender);\n      context.setTransform(1, 0, 0, 1, 0, 0);\n      context.fillStyle = 'rgba(255, 0, 0, 0.75)';\n      context.strokeStyle = 'rgba(255, 0, 0, 0.75)';\n      context.lineWidth = 1;\n      context.fillText('1 frame = ' + timeToRender + ' ms = ' + fps + ' fps', 0, 20);\n      var maxFps = 60;\n      context.strokeRect(0, 30, 250, 20);\n      context.fillRect(0, 30, 250 * Math.min(fps / maxFps, 1), 20);\n    }\n    if (!drawAllLayers) {\n      needDraw[r.SELECT_BOX] = false;\n    }\n  }\n\n  // motionblur: blit rendered blurry frames\n  if (motionBlur && mbPxRatio !== 1) {\n    var cxtNode = data.contexts[r.NODE];\n    var txtNode = r.data.bufferCanvases[r.MOTIONBLUR_BUFFER_NODE];\n    var cxtDrag = data.contexts[r.DRAG];\n    var txtDrag = r.data.bufferCanvases[r.MOTIONBLUR_BUFFER_DRAG];\n    var drawMotionBlur = function drawMotionBlur(cxt, txt, needClear) {\n      cxt.setTransform(1, 0, 0, 1, 0, 0);\n      if (needClear || !motionBlurFadeEffect) {\n        cxt.clearRect(0, 0, r.canvasWidth, r.canvasHeight);\n      } else {\n        mbclear(cxt, 0, 0, r.canvasWidth, r.canvasHeight);\n      }\n      var pxr = mbPxRatio;\n      cxt.drawImage(txt,\n      // img\n      0, 0,\n      // sx, sy\n      r.canvasWidth * pxr, r.canvasHeight * pxr,\n      // sw, sh\n      0, 0,\n      // x, y\n      r.canvasWidth, r.canvasHeight // w, h\n      );\n    };\n\n    if (needDraw[r.NODE] || needMbClear[r.NODE]) {\n      drawMotionBlur(cxtNode, txtNode, needMbClear[r.NODE]);\n      needDraw[r.NODE] = false;\n    }\n    if (needDraw[r.DRAG] || needMbClear[r.DRAG]) {\n      drawMotionBlur(cxtDrag, txtDrag, needMbClear[r.DRAG]);\n      needDraw[r.DRAG] = false;\n    }\n  }\n  r.prevViewport = vp;\n  if (r.clearingMotionBlur) {\n    r.clearingMotionBlur = false;\n    r.motionBlurCleared = true;\n    r.motionBlur = true;\n  }\n  if (motionBlur) {\n    r.motionBlurTimeout = setTimeout(function () {\n      r.motionBlurTimeout = null;\n      r.clearedForMotionBlur[r.NODE] = false;\n      r.clearedForMotionBlur[r.DRAG] = false;\n      r.motionBlur = false;\n      r.clearingMotionBlur = !textureDraw;\n      r.mbFrames = 0;\n      needDraw[r.NODE] = true;\n      needDraw[r.DRAG] = true;\n      r.redraw();\n    }, motionBlurDelay);\n  }\n  if (!forcedContext) {\n    cy.emit('render');\n  }\n};\n\nvar CRp$3 = {};\n\n// @O Polygon drawing\nCRp$3.drawPolygonPath = function (context, x, y, width, height, points) {\n  var halfW = width / 2;\n  var halfH = height / 2;\n  if (context.beginPath) {\n    context.beginPath();\n  }\n  context.moveTo(x + halfW * points[0], y + halfH * points[1]);\n  for (var i = 1; i < points.length / 2; i++) {\n    context.lineTo(x + halfW * points[i * 2], y + halfH * points[i * 2 + 1]);\n  }\n  context.closePath();\n};\nCRp$3.drawRoundPolygonPath = function (context, x, y, width, height, points, corners) {\n  corners.forEach(function (corner) {\n    return drawPreparedRoundCorner(context, corner);\n  });\n  context.closePath();\n};\n\n// Round rectangle drawing\nCRp$3.drawRoundRectanglePath = function (context, x, y, width, height, radius) {\n  var halfWidth = width / 2;\n  var halfHeight = height / 2;\n  var cornerRadius = radius === 'auto' ? getRoundRectangleRadius(width, height) : Math.min(radius, halfHeight, halfWidth);\n  if (context.beginPath) {\n    context.beginPath();\n  }\n\n  // Start at top middle\n  context.moveTo(x, y - halfHeight);\n  // Arc from middle top to right side\n  context.arcTo(x + halfWidth, y - halfHeight, x + halfWidth, y, cornerRadius);\n  // Arc from right side to bottom\n  context.arcTo(x + halfWidth, y + halfHeight, x, y + halfHeight, cornerRadius);\n  // Arc from bottom to left side\n  context.arcTo(x - halfWidth, y + halfHeight, x - halfWidth, y, cornerRadius);\n  // Arc from left side to topBorder\n  context.arcTo(x - halfWidth, y - halfHeight, x, y - halfHeight, cornerRadius);\n  // Join line\n  context.lineTo(x, y - halfHeight);\n  context.closePath();\n};\nCRp$3.drawBottomRoundRectanglePath = function (context, x, y, width, height, radius) {\n  var halfWidth = width / 2;\n  var halfHeight = height / 2;\n  var cornerRadius = radius === 'auto' ? getRoundRectangleRadius(width, height) : radius;\n  if (context.beginPath) {\n    context.beginPath();\n  }\n\n  // Start at top middle\n  context.moveTo(x, y - halfHeight);\n  context.lineTo(x + halfWidth, y - halfHeight);\n  context.lineTo(x + halfWidth, y);\n  context.arcTo(x + halfWidth, y + halfHeight, x, y + halfHeight, cornerRadius);\n  context.arcTo(x - halfWidth, y + halfHeight, x - halfWidth, y, cornerRadius);\n  context.lineTo(x - halfWidth, y - halfHeight);\n  context.lineTo(x, y - halfHeight);\n  context.closePath();\n};\nCRp$3.drawCutRectanglePath = function (context, x, y, width, height, points, corners) {\n  var halfWidth = width / 2;\n  var halfHeight = height / 2;\n  var cornerLength = corners === 'auto' ? getCutRectangleCornerLength() : corners;\n  if (context.beginPath) {\n    context.beginPath();\n  }\n  context.moveTo(x - halfWidth + cornerLength, y - halfHeight);\n  context.lineTo(x + halfWidth - cornerLength, y - halfHeight);\n  context.lineTo(x + halfWidth, y - halfHeight + cornerLength);\n  context.lineTo(x + halfWidth, y + halfHeight - cornerLength);\n  context.lineTo(x + halfWidth - cornerLength, y + halfHeight);\n  context.lineTo(x - halfWidth + cornerLength, y + halfHeight);\n  context.lineTo(x - halfWidth, y + halfHeight - cornerLength);\n  context.lineTo(x - halfWidth, y - halfHeight + cornerLength);\n  context.closePath();\n};\nCRp$3.drawBarrelPath = function (context, x, y, width, height) {\n  var halfWidth = width / 2;\n  var halfHeight = height / 2;\n  var xBegin = x - halfWidth;\n  var xEnd = x + halfWidth;\n  var yBegin = y - halfHeight;\n  var yEnd = y + halfHeight;\n  var barrelCurveConstants = getBarrelCurveConstants(width, height);\n  var wOffset = barrelCurveConstants.widthOffset;\n  var hOffset = barrelCurveConstants.heightOffset;\n  var ctrlPtXOffset = barrelCurveConstants.ctrlPtOffsetPct * wOffset;\n  if (context.beginPath) {\n    context.beginPath();\n  }\n  context.moveTo(xBegin, yBegin + hOffset);\n  context.lineTo(xBegin, yEnd - hOffset);\n  context.quadraticCurveTo(xBegin + ctrlPtXOffset, yEnd, xBegin + wOffset, yEnd);\n  context.lineTo(xEnd - wOffset, yEnd);\n  context.quadraticCurveTo(xEnd - ctrlPtXOffset, yEnd, xEnd, yEnd - hOffset);\n  context.lineTo(xEnd, yBegin + hOffset);\n  context.quadraticCurveTo(xEnd - ctrlPtXOffset, yBegin, xEnd - wOffset, yBegin);\n  context.lineTo(xBegin + wOffset, yBegin);\n  context.quadraticCurveTo(xBegin + ctrlPtXOffset, yBegin, xBegin, yBegin + hOffset);\n  context.closePath();\n};\nvar sin0 = Math.sin(0);\nvar cos0 = Math.cos(0);\nvar sin = {};\nvar cos = {};\nvar ellipseStepSize = Math.PI / 40;\nfor (var i = 0 * Math.PI; i < 2 * Math.PI; i += ellipseStepSize) {\n  sin[i] = Math.sin(i);\n  cos[i] = Math.cos(i);\n}\nCRp$3.drawEllipsePath = function (context, centerX, centerY, width, height) {\n  if (context.beginPath) {\n    context.beginPath();\n  }\n  if (context.ellipse) {\n    context.ellipse(centerX, centerY, width / 2, height / 2, 0, 0, 2 * Math.PI);\n  } else {\n    var xPos, yPos;\n    var rw = width / 2;\n    var rh = height / 2;\n    for (var i = 0 * Math.PI; i < 2 * Math.PI; i += ellipseStepSize) {\n      xPos = centerX - rw * sin[i] * sin0 + rw * cos[i] * cos0;\n      yPos = centerY + rh * cos[i] * sin0 + rh * sin[i] * cos0;\n      if (i === 0) {\n        context.moveTo(xPos, yPos);\n      } else {\n        context.lineTo(xPos, yPos);\n      }\n    }\n  }\n  context.closePath();\n};\n\n/* global atob, ArrayBuffer, Uint8Array, Blob */\nvar CRp$2 = {};\nCRp$2.createBuffer = function (w, h) {\n  var buffer = document.createElement('canvas'); // eslint-disable-line no-undef\n  buffer.width = w;\n  buffer.height = h;\n  return [buffer, buffer.getContext('2d')];\n};\nCRp$2.bufferCanvasImage = function (options) {\n  var cy = this.cy;\n  var eles = cy.mutableElements();\n  var bb = eles.boundingBox();\n  var ctrRect = this.findContainerClientCoords();\n  var width = options.full ? Math.ceil(bb.w) : ctrRect[2];\n  var height = options.full ? Math.ceil(bb.h) : ctrRect[3];\n  var specdMaxDims = number$1(options.maxWidth) || number$1(options.maxHeight);\n  var pxRatio = this.getPixelRatio();\n  var scale = 1;\n  if (options.scale !== undefined) {\n    width *= options.scale;\n    height *= options.scale;\n    scale = options.scale;\n  } else if (specdMaxDims) {\n    var maxScaleW = Infinity;\n    var maxScaleH = Infinity;\n    if (number$1(options.maxWidth)) {\n      maxScaleW = scale * options.maxWidth / width;\n    }\n    if (number$1(options.maxHeight)) {\n      maxScaleH = scale * options.maxHeight / height;\n    }\n    scale = Math.min(maxScaleW, maxScaleH);\n    width *= scale;\n    height *= scale;\n  }\n  if (!specdMaxDims) {\n    width *= pxRatio;\n    height *= pxRatio;\n    scale *= pxRatio;\n  }\n  var buffCanvas = document.createElement('canvas'); // eslint-disable-line no-undef\n\n  buffCanvas.width = width;\n  buffCanvas.height = height;\n  buffCanvas.style.width = width + 'px';\n  buffCanvas.style.height = height + 'px';\n  var buffCxt = buffCanvas.getContext('2d');\n\n  // Rasterize the layers, but only if container has nonzero size\n  if (width > 0 && height > 0) {\n    buffCxt.clearRect(0, 0, width, height);\n    buffCxt.globalCompositeOperation = 'source-over';\n    var zsortedEles = this.getCachedZSortedEles();\n    if (options.full) {\n      // draw the full bounds of the graph\n      buffCxt.translate(-bb.x1 * scale, -bb.y1 * scale);\n      buffCxt.scale(scale, scale);\n      this.drawElements(buffCxt, zsortedEles);\n      buffCxt.scale(1 / scale, 1 / scale);\n      buffCxt.translate(bb.x1 * scale, bb.y1 * scale);\n    } else {\n      // draw the current view\n      var pan = cy.pan();\n      var translation = {\n        x: pan.x * scale,\n        y: pan.y * scale\n      };\n      scale *= cy.zoom();\n      buffCxt.translate(translation.x, translation.y);\n      buffCxt.scale(scale, scale);\n      this.drawElements(buffCxt, zsortedEles);\n      buffCxt.scale(1 / scale, 1 / scale);\n      buffCxt.translate(-translation.x, -translation.y);\n    }\n\n    // need to fill bg at end like this in order to fill cleared transparent pixels in jpgs\n    if (options.bg) {\n      buffCxt.globalCompositeOperation = 'destination-over';\n      buffCxt.fillStyle = options.bg;\n      buffCxt.rect(0, 0, width, height);\n      buffCxt.fill();\n    }\n  }\n  return buffCanvas;\n};\nfunction b64ToBlob(b64, mimeType) {\n  var bytes = atob(b64);\n  var buff = new ArrayBuffer(bytes.length);\n  var buffUint8 = new Uint8Array(buff);\n  for (var i = 0; i < bytes.length; i++) {\n    buffUint8[i] = bytes.charCodeAt(i);\n  }\n  return new Blob([buff], {\n    type: mimeType\n  });\n}\nfunction b64UriToB64(b64uri) {\n  var i = b64uri.indexOf(',');\n  return b64uri.substr(i + 1);\n}\nfunction output(options, canvas, mimeType) {\n  var getB64Uri = function getB64Uri() {\n    return canvas.toDataURL(mimeType, options.quality);\n  };\n  switch (options.output) {\n    case 'blob-promise':\n      return new Promise$1(function (resolve, reject) {\n        try {\n          canvas.toBlob(function (blob) {\n            if (blob != null) {\n              resolve(blob);\n            } else {\n              reject(new Error('`canvas.toBlob()` sent a null value in its callback'));\n            }\n          }, mimeType, options.quality);\n        } catch (err) {\n          reject(err);\n        }\n      });\n    case 'blob':\n      return b64ToBlob(b64UriToB64(getB64Uri()), mimeType);\n    case 'base64':\n      return b64UriToB64(getB64Uri());\n    case 'base64uri':\n    default:\n      return getB64Uri();\n  }\n}\nCRp$2.png = function (options) {\n  return output(options, this.bufferCanvasImage(options), 'image/png');\n};\nCRp$2.jpg = function (options) {\n  return output(options, this.bufferCanvasImage(options), 'image/jpeg');\n};\n\nvar CRp$1 = {};\nCRp$1.nodeShapeImpl = function (name, context, centerX, centerY, width, height, points, corners) {\n  switch (name) {\n    case 'ellipse':\n      return this.drawEllipsePath(context, centerX, centerY, width, height);\n    case 'polygon':\n      return this.drawPolygonPath(context, centerX, centerY, width, height, points);\n    case 'round-polygon':\n      return this.drawRoundPolygonPath(context, centerX, centerY, width, height, points, corners);\n    case 'roundrectangle':\n    case 'round-rectangle':\n      return this.drawRoundRectanglePath(context, centerX, centerY, width, height, corners);\n    case 'cutrectangle':\n    case 'cut-rectangle':\n      return this.drawCutRectanglePath(context, centerX, centerY, width, height, points, corners);\n    case 'bottomroundrectangle':\n    case 'bottom-round-rectangle':\n      return this.drawBottomRoundRectanglePath(context, centerX, centerY, width, height, corners);\n    case 'barrel':\n      return this.drawBarrelPath(context, centerX, centerY, width, height);\n  }\n};\n\nvar CR = CanvasRenderer;\nvar CRp = CanvasRenderer.prototype;\nCRp.CANVAS_LAYERS = 3;\n//\nCRp.SELECT_BOX = 0;\nCRp.DRAG = 1;\nCRp.NODE = 2;\nCRp.BUFFER_COUNT = 3;\n//\nCRp.TEXTURE_BUFFER = 0;\nCRp.MOTIONBLUR_BUFFER_NODE = 1;\nCRp.MOTIONBLUR_BUFFER_DRAG = 2;\nfunction CanvasRenderer(options) {\n  var r = this;\n  var containerWindow = r.cy.window();\n  var document = containerWindow.document;\n  r.data = {\n    canvases: new Array(CRp.CANVAS_LAYERS),\n    contexts: new Array(CRp.CANVAS_LAYERS),\n    canvasNeedsRedraw: new Array(CRp.CANVAS_LAYERS),\n    bufferCanvases: new Array(CRp.BUFFER_COUNT),\n    bufferContexts: new Array(CRp.CANVAS_LAYERS)\n  };\n  var tapHlOffAttr = '-webkit-tap-highlight-color';\n  var tapHlOffStyle = 'rgba(0,0,0,0)';\n  r.data.canvasContainer = document.createElement('div'); // eslint-disable-line no-undef\n  var containerStyle = r.data.canvasContainer.style;\n  r.data.canvasContainer.style[tapHlOffAttr] = tapHlOffStyle;\n  containerStyle.position = 'relative';\n  containerStyle.zIndex = '0';\n  containerStyle.overflow = 'hidden';\n  var container = options.cy.container();\n  container.appendChild(r.data.canvasContainer);\n  container.style[tapHlOffAttr] = tapHlOffStyle;\n  var styleMap = {\n    '-webkit-user-select': 'none',\n    '-moz-user-select': '-moz-none',\n    'user-select': 'none',\n    '-webkit-tap-highlight-color': 'rgba(0,0,0,0)',\n    'outline-style': 'none'\n  };\n  if (ms()) {\n    styleMap['-ms-touch-action'] = 'none';\n    styleMap['touch-action'] = 'none';\n  }\n  for (var i = 0; i < CRp.CANVAS_LAYERS; i++) {\n    var canvas = r.data.canvases[i] = document.createElement('canvas'); // eslint-disable-line no-undef\n    r.data.contexts[i] = canvas.getContext('2d');\n    Object.keys(styleMap).forEach(function (k) {\n      canvas.style[k] = styleMap[k];\n    });\n    canvas.style.position = 'absolute';\n    canvas.setAttribute('data-id', 'layer' + i);\n    canvas.style.zIndex = String(CRp.CANVAS_LAYERS - i);\n    r.data.canvasContainer.appendChild(canvas);\n    r.data.canvasNeedsRedraw[i] = false;\n  }\n  r.data.topCanvas = r.data.canvases[0];\n  r.data.canvases[CRp.NODE].setAttribute('data-id', 'layer' + CRp.NODE + '-node');\n  r.data.canvases[CRp.SELECT_BOX].setAttribute('data-id', 'layer' + CRp.SELECT_BOX + '-selectbox');\n  r.data.canvases[CRp.DRAG].setAttribute('data-id', 'layer' + CRp.DRAG + '-drag');\n  for (var i = 0; i < CRp.BUFFER_COUNT; i++) {\n    r.data.bufferCanvases[i] = document.createElement('canvas'); // eslint-disable-line no-undef\n    r.data.bufferContexts[i] = r.data.bufferCanvases[i].getContext('2d');\n    r.data.bufferCanvases[i].style.position = 'absolute';\n    r.data.bufferCanvases[i].setAttribute('data-id', 'buffer' + i);\n    r.data.bufferCanvases[i].style.zIndex = String(-i - 1);\n    r.data.bufferCanvases[i].style.visibility = 'hidden';\n    //r.data.canvasContainer.appendChild(r.data.bufferCanvases[i]);\n  }\n\n  r.pathsEnabled = true;\n  var emptyBb = makeBoundingBox();\n  var getBoxCenter = function getBoxCenter(bb) {\n    return {\n      x: (bb.x1 + bb.x2) / 2,\n      y: (bb.y1 + bb.y2) / 2\n    };\n  };\n  var getCenterOffset = function getCenterOffset(bb) {\n    return {\n      x: -bb.w / 2,\n      y: -bb.h / 2\n    };\n  };\n  var backgroundTimestampHasChanged = function backgroundTimestampHasChanged(ele) {\n    var _p = ele[0]._private;\n    var same = _p.oldBackgroundTimestamp === _p.backgroundTimestamp;\n    return !same;\n  };\n  var getStyleKey = function getStyleKey(ele) {\n    return ele[0]._private.nodeKey;\n  };\n  var getLabelKey = function getLabelKey(ele) {\n    return ele[0]._private.labelStyleKey;\n  };\n  var getSourceLabelKey = function getSourceLabelKey(ele) {\n    return ele[0]._private.sourceLabelStyleKey;\n  };\n  var getTargetLabelKey = function getTargetLabelKey(ele) {\n    return ele[0]._private.targetLabelStyleKey;\n  };\n  var drawElement = function drawElement(context, ele, bb, scaledLabelShown, useEleOpacity) {\n    return r.drawElement(context, ele, bb, false, false, useEleOpacity);\n  };\n  var drawLabel = function drawLabel(context, ele, bb, scaledLabelShown, useEleOpacity) {\n    return r.drawElementText(context, ele, bb, scaledLabelShown, 'main', useEleOpacity);\n  };\n  var drawSourceLabel = function drawSourceLabel(context, ele, bb, scaledLabelShown, useEleOpacity) {\n    return r.drawElementText(context, ele, bb, scaledLabelShown, 'source', useEleOpacity);\n  };\n  var drawTargetLabel = function drawTargetLabel(context, ele, bb, scaledLabelShown, useEleOpacity) {\n    return r.drawElementText(context, ele, bb, scaledLabelShown, 'target', useEleOpacity);\n  };\n  var getElementBox = function getElementBox(ele) {\n    ele.boundingBox();\n    return ele[0]._private.bodyBounds;\n  };\n  var getLabelBox = function getLabelBox(ele) {\n    ele.boundingBox();\n    return ele[0]._private.labelBounds.main || emptyBb;\n  };\n  var getSourceLabelBox = function getSourceLabelBox(ele) {\n    ele.boundingBox();\n    return ele[0]._private.labelBounds.source || emptyBb;\n  };\n  var getTargetLabelBox = function getTargetLabelBox(ele) {\n    ele.boundingBox();\n    return ele[0]._private.labelBounds.target || emptyBb;\n  };\n  var isLabelVisibleAtScale = function isLabelVisibleAtScale(ele, scaledLabelShown) {\n    return scaledLabelShown;\n  };\n  var getElementRotationPoint = function getElementRotationPoint(ele) {\n    return getBoxCenter(getElementBox(ele));\n  };\n  var addTextMargin = function addTextMargin(prefix, pt, ele) {\n    var pre = prefix ? prefix + '-' : '';\n    return {\n      x: pt.x + ele.pstyle(pre + 'text-margin-x').pfValue,\n      y: pt.y + ele.pstyle(pre + 'text-margin-y').pfValue\n    };\n  };\n  var getRsPt = function getRsPt(ele, x, y) {\n    var rs = ele[0]._private.rscratch;\n    return {\n      x: rs[x],\n      y: rs[y]\n    };\n  };\n  var getLabelRotationPoint = function getLabelRotationPoint(ele) {\n    return addTextMargin('', getRsPt(ele, 'labelX', 'labelY'), ele);\n  };\n  var getSourceLabelRotationPoint = function getSourceLabelRotationPoint(ele) {\n    return addTextMargin('source', getRsPt(ele, 'sourceLabelX', 'sourceLabelY'), ele);\n  };\n  var getTargetLabelRotationPoint = function getTargetLabelRotationPoint(ele) {\n    return addTextMargin('target', getRsPt(ele, 'targetLabelX', 'targetLabelY'), ele);\n  };\n  var getElementRotationOffset = function getElementRotationOffset(ele) {\n    return getCenterOffset(getElementBox(ele));\n  };\n  var getSourceLabelRotationOffset = function getSourceLabelRotationOffset(ele) {\n    return getCenterOffset(getSourceLabelBox(ele));\n  };\n  var getTargetLabelRotationOffset = function getTargetLabelRotationOffset(ele) {\n    return getCenterOffset(getTargetLabelBox(ele));\n  };\n  var getLabelRotationOffset = function getLabelRotationOffset(ele) {\n    var bb = getLabelBox(ele);\n    var p = getCenterOffset(getLabelBox(ele));\n    if (ele.isNode()) {\n      switch (ele.pstyle('text-halign').value) {\n        case 'left':\n          p.x = -bb.w - (bb.leftPad || 0);\n          break;\n        case 'right':\n          p.x = -(bb.rightPad || 0);\n          break;\n      }\n      switch (ele.pstyle('text-valign').value) {\n        case 'top':\n          p.y = -bb.h - (bb.topPad || 0);\n          break;\n        case 'bottom':\n          p.y = -(bb.botPad || 0);\n          break;\n      }\n    }\n    return p;\n  };\n  var eleTxrCache = r.data.eleTxrCache = new ElementTextureCache(r, {\n    getKey: getStyleKey,\n    doesEleInvalidateKey: backgroundTimestampHasChanged,\n    drawElement: drawElement,\n    getBoundingBox: getElementBox,\n    getRotationPoint: getElementRotationPoint,\n    getRotationOffset: getElementRotationOffset,\n    allowEdgeTxrCaching: false,\n    allowParentTxrCaching: false\n  });\n  var lblTxrCache = r.data.lblTxrCache = new ElementTextureCache(r, {\n    getKey: getLabelKey,\n    drawElement: drawLabel,\n    getBoundingBox: getLabelBox,\n    getRotationPoint: getLabelRotationPoint,\n    getRotationOffset: getLabelRotationOffset,\n    isVisible: isLabelVisibleAtScale\n  });\n  var slbTxrCache = r.data.slbTxrCache = new ElementTextureCache(r, {\n    getKey: getSourceLabelKey,\n    drawElement: drawSourceLabel,\n    getBoundingBox: getSourceLabelBox,\n    getRotationPoint: getSourceLabelRotationPoint,\n    getRotationOffset: getSourceLabelRotationOffset,\n    isVisible: isLabelVisibleAtScale\n  });\n  var tlbTxrCache = r.data.tlbTxrCache = new ElementTextureCache(r, {\n    getKey: getTargetLabelKey,\n    drawElement: drawTargetLabel,\n    getBoundingBox: getTargetLabelBox,\n    getRotationPoint: getTargetLabelRotationPoint,\n    getRotationOffset: getTargetLabelRotationOffset,\n    isVisible: isLabelVisibleAtScale\n  });\n  var lyrTxrCache = r.data.lyrTxrCache = new LayeredTextureCache(r);\n  r.onUpdateEleCalcs(function invalidateTextureCaches(willDraw, eles) {\n    // each cache should check for sub-key diff to see that the update affects that cache particularly\n    eleTxrCache.invalidateElements(eles);\n    lblTxrCache.invalidateElements(eles);\n    slbTxrCache.invalidateElements(eles);\n    tlbTxrCache.invalidateElements(eles);\n\n    // any change invalidates the layers\n    lyrTxrCache.invalidateElements(eles);\n\n    // update the old bg timestamp so diffs can be done in the ele txr caches\n    for (var _i = 0; _i < eles.length; _i++) {\n      var _p = eles[_i]._private;\n      _p.oldBackgroundTimestamp = _p.backgroundTimestamp;\n    }\n  });\n  var refineInLayers = function refineInLayers(reqs) {\n    for (var i = 0; i < reqs.length; i++) {\n      lyrTxrCache.enqueueElementRefinement(reqs[i].ele);\n    }\n  };\n  eleTxrCache.onDequeue(refineInLayers);\n  lblTxrCache.onDequeue(refineInLayers);\n  slbTxrCache.onDequeue(refineInLayers);\n  tlbTxrCache.onDequeue(refineInLayers);\n}\nCRp.redrawHint = function (group, bool) {\n  var r = this;\n  switch (group) {\n    case 'eles':\n      r.data.canvasNeedsRedraw[CRp.NODE] = bool;\n      break;\n    case 'drag':\n      r.data.canvasNeedsRedraw[CRp.DRAG] = bool;\n      break;\n    case 'select':\n      r.data.canvasNeedsRedraw[CRp.SELECT_BOX] = bool;\n      break;\n  }\n};\n\n// whether to use Path2D caching for drawing\nvar pathsImpld = typeof Path2D !== 'undefined';\nCRp.path2dEnabled = function (on) {\n  if (on === undefined) {\n    return this.pathsEnabled;\n  }\n  this.pathsEnabled = on ? true : false;\n};\nCRp.usePaths = function () {\n  return pathsImpld && this.pathsEnabled;\n};\nCRp.setImgSmoothing = function (context, bool) {\n  if (context.imageSmoothingEnabled != null) {\n    context.imageSmoothingEnabled = bool;\n  } else {\n    context.webkitImageSmoothingEnabled = bool;\n    context.mozImageSmoothingEnabled = bool;\n    context.msImageSmoothingEnabled = bool;\n  }\n};\nCRp.getImgSmoothing = function (context) {\n  if (context.imageSmoothingEnabled != null) {\n    return context.imageSmoothingEnabled;\n  } else {\n    return context.webkitImageSmoothingEnabled || context.mozImageSmoothingEnabled || context.msImageSmoothingEnabled;\n  }\n};\nCRp.makeOffscreenCanvas = function (width, height) {\n  var canvas;\n  if ((typeof OffscreenCanvas === \"undefined\" ? \"undefined\" : _typeof(OffscreenCanvas)) !== (\"undefined\" )) {\n    canvas = new OffscreenCanvas(width, height);\n  } else {\n    var containerWindow = this.cy.window();\n    var document = containerWindow.document;\n    canvas = document.createElement('canvas'); // eslint-disable-line no-undef\n    canvas.width = width;\n    canvas.height = height;\n  }\n  return canvas;\n};\n[CRp$a, CRp$9, CRp$8, CRp$7, CRp$6, CRp$5, CRp$4, CRp$3, CRp$2, CRp$1].forEach(function (props) {\n  extend(CRp, props);\n});\n\nvar renderer = [{\n  name: 'null',\n  impl: NullRenderer\n}, {\n  name: 'base',\n  impl: BR\n}, {\n  name: 'canvas',\n  impl: CR\n}];\n\nvar incExts = [{\n  type: 'layout',\n  extensions: layout\n}, {\n  type: 'renderer',\n  extensions: renderer\n}];\n\n// registered extensions to cytoscape, indexed by name\nvar extensions = {};\n\n// registered modules for extensions, indexed by name\nvar modules = {};\nfunction setExtension(type, name, registrant) {\n  var ext = registrant;\n  var overrideErr = function overrideErr(field) {\n    warn('Can not register `' + name + '` for `' + type + '` since `' + field + '` already exists in the prototype and can not be overridden');\n  };\n  if (type === 'core') {\n    if (Core.prototype[name]) {\n      return overrideErr(name);\n    } else {\n      Core.prototype[name] = registrant;\n    }\n  } else if (type === 'collection') {\n    if (Collection.prototype[name]) {\n      return overrideErr(name);\n    } else {\n      Collection.prototype[name] = registrant;\n    }\n  } else if (type === 'layout') {\n    // fill in missing layout functions in the prototype\n\n    var Layout = function Layout(options) {\n      this.options = options;\n      registrant.call(this, options);\n\n      // make sure layout has _private for use w/ std apis like .on()\n      if (!plainObject(this._private)) {\n        this._private = {};\n      }\n      this._private.cy = options.cy;\n      this._private.listeners = [];\n      this.createEmitter();\n    };\n    var layoutProto = Layout.prototype = Object.create(registrant.prototype);\n    var optLayoutFns = [];\n    for (var i = 0; i < optLayoutFns.length; i++) {\n      var fnName = optLayoutFns[i];\n      layoutProto[fnName] = layoutProto[fnName] || function () {\n        return this;\n      };\n    }\n\n    // either .start() or .run() is defined, so autogen the other\n    if (layoutProto.start && !layoutProto.run) {\n      layoutProto.run = function () {\n        this.start();\n        return this;\n      };\n    } else if (!layoutProto.start && layoutProto.run) {\n      layoutProto.start = function () {\n        this.run();\n        return this;\n      };\n    }\n    var regStop = registrant.prototype.stop;\n    layoutProto.stop = function () {\n      var opts = this.options;\n      if (opts && opts.animate) {\n        var anis = this.animations;\n        if (anis) {\n          for (var _i = 0; _i < anis.length; _i++) {\n            anis[_i].stop();\n          }\n        }\n      }\n      if (regStop) {\n        regStop.call(this);\n      } else {\n        this.emit('layoutstop');\n      }\n      return this;\n    };\n    if (!layoutProto.destroy) {\n      layoutProto.destroy = function () {\n        return this;\n      };\n    }\n    layoutProto.cy = function () {\n      return this._private.cy;\n    };\n    var getCy = function getCy(layout) {\n      return layout._private.cy;\n    };\n    var emitterOpts = {\n      addEventFields: function addEventFields(layout, evt) {\n        evt.layout = layout;\n        evt.cy = getCy(layout);\n        evt.target = layout;\n      },\n      bubble: function bubble() {\n        return true;\n      },\n      parent: function parent(layout) {\n        return getCy(layout);\n      }\n    };\n    extend(layoutProto, {\n      createEmitter: function createEmitter() {\n        this._private.emitter = new Emitter(emitterOpts, this);\n        return this;\n      },\n      emitter: function emitter() {\n        return this._private.emitter;\n      },\n      on: function on(evt, cb) {\n        this.emitter().on(evt, cb);\n        return this;\n      },\n      one: function one(evt, cb) {\n        this.emitter().one(evt, cb);\n        return this;\n      },\n      once: function once(evt, cb) {\n        this.emitter().one(evt, cb);\n        return this;\n      },\n      removeListener: function removeListener(evt, cb) {\n        this.emitter().removeListener(evt, cb);\n        return this;\n      },\n      removeAllListeners: function removeAllListeners() {\n        this.emitter().removeAllListeners();\n        return this;\n      },\n      emit: function emit(evt, params) {\n        this.emitter().emit(evt, params);\n        return this;\n      }\n    });\n    define.eventAliasesOn(layoutProto);\n    ext = Layout; // replace with our wrapped layout\n  } else if (type === 'renderer' && name !== 'null' && name !== 'base') {\n    // user registered renderers inherit from base\n\n    var BaseRenderer = getExtension('renderer', 'base');\n    var bProto = BaseRenderer.prototype;\n    var RegistrantRenderer = registrant;\n    var rProto = registrant.prototype;\n    var Renderer = function Renderer() {\n      BaseRenderer.apply(this, arguments);\n      RegistrantRenderer.apply(this, arguments);\n    };\n    var proto = Renderer.prototype;\n    for (var pName in bProto) {\n      var pVal = bProto[pName];\n      var existsInR = rProto[pName] != null;\n      if (existsInR) {\n        return overrideErr(pName);\n      }\n      proto[pName] = pVal; // take impl from base\n    }\n\n    for (var _pName in rProto) {\n      proto[_pName] = rProto[_pName]; // take impl from registrant\n    }\n\n    bProto.clientFunctions.forEach(function (name) {\n      proto[name] = proto[name] || function () {\n        error('Renderer does not implement `renderer.' + name + '()` on its prototype');\n      };\n    });\n    ext = Renderer;\n  } else if (type === '__proto__' || type === 'constructor' || type === 'prototype') {\n    // to avoid potential prototype pollution\n    return error(type + ' is an illegal type to be registered, possibly lead to prototype pollutions');\n  }\n  return setMap({\n    map: extensions,\n    keys: [type, name],\n    value: ext\n  });\n}\nfunction getExtension(type, name) {\n  return getMap({\n    map: extensions,\n    keys: [type, name]\n  });\n}\nfunction setModule(type, name, moduleType, moduleName, registrant) {\n  return setMap({\n    map: modules,\n    keys: [type, name, moduleType, moduleName],\n    value: registrant\n  });\n}\nfunction getModule(type, name, moduleType, moduleName) {\n  return getMap({\n    map: modules,\n    keys: [type, name, moduleType, moduleName]\n  });\n}\nvar extension = function extension() {\n  // e.g. extension('renderer', 'svg')\n  if (arguments.length === 2) {\n    return getExtension.apply(null, arguments);\n  }\n\n  // e.g. extension('renderer', 'svg', { ... })\n  else if (arguments.length === 3) {\n    return setExtension.apply(null, arguments);\n  }\n\n  // e.g. extension('renderer', 'svg', 'nodeShape', 'ellipse')\n  else if (arguments.length === 4) {\n    return getModule.apply(null, arguments);\n  }\n\n  // e.g. extension('renderer', 'svg', 'nodeShape', 'ellipse', { ... })\n  else if (arguments.length === 5) {\n    return setModule.apply(null, arguments);\n  } else {\n    error('Invalid extension access syntax');\n  }\n};\n\n// allows a core instance to access extensions internally\nCore.prototype.extension = extension;\n\n// included extensions\nincExts.forEach(function (group) {\n  group.extensions.forEach(function (ext) {\n    setExtension(group.type, ext.name, ext.impl);\n  });\n});\n\n// a dummy stylesheet object that doesn't need a reference to the core\n// (useful for init)\nvar Stylesheet = function Stylesheet() {\n  if (!(this instanceof Stylesheet)) {\n    return new Stylesheet();\n  }\n  this.length = 0;\n};\nvar sheetfn = Stylesheet.prototype;\nsheetfn.instanceString = function () {\n  return 'stylesheet';\n};\n\n// just store the selector to be parsed later\nsheetfn.selector = function (selector) {\n  var i = this.length++;\n  this[i] = {\n    selector: selector,\n    properties: []\n  };\n  return this; // chaining\n};\n\n// just store the property to be parsed later\nsheetfn.css = function (name, value) {\n  var i = this.length - 1;\n  if (string(name)) {\n    this[i].properties.push({\n      name: name,\n      value: value\n    });\n  } else if (plainObject(name)) {\n    var map = name;\n    var propNames = Object.keys(map);\n    for (var j = 0; j < propNames.length; j++) {\n      var key = propNames[j];\n      var mapVal = map[key];\n      if (mapVal == null) {\n        continue;\n      }\n      var prop = Style.properties[key] || Style.properties[dash2camel(key)];\n      if (prop == null) {\n        continue;\n      }\n      var _name = prop.name;\n      var _value = mapVal;\n      this[i].properties.push({\n        name: _name,\n        value: _value\n      });\n    }\n  }\n  return this; // chaining\n};\n\nsheetfn.style = sheetfn.css;\n\n// generate a real style object from the dummy stylesheet\nsheetfn.generateStyle = function (cy) {\n  var style = new Style(cy);\n  return this.appendToStyle(style);\n};\n\n// append a dummy stylesheet object on a real style object\nsheetfn.appendToStyle = function (style) {\n  for (var i = 0; i < this.length; i++) {\n    var context = this[i];\n    var selector = context.selector;\n    var props = context.properties;\n    style.selector(selector); // apply selector\n\n    for (var j = 0; j < props.length; j++) {\n      var prop = props[j];\n      style.css(prop.name, prop.value); // apply property\n    }\n  }\n\n  return style;\n};\n\nvar version = \"3.30.4\";\n\nvar cytoscape = function cytoscape(options) {\n  // if no options specified, use default\n  if (options === undefined) {\n    options = {};\n  }\n\n  // create instance\n  if (plainObject(options)) {\n    return new Core(options);\n  }\n\n  // allow for registration of extensions\n  else if (string(options)) {\n    return extension.apply(extension, arguments);\n  }\n};\n\n// e.g. cytoscape.use( require('cytoscape-foo'), bar )\ncytoscape.use = function (ext) {\n  var args = Array.prototype.slice.call(arguments, 1); // args to pass to ext\n\n  args.unshift(cytoscape); // cytoscape is first arg to ext\n\n  ext.apply(null, args);\n  return this;\n};\ncytoscape.warnings = function (bool) {\n  return warnings(bool);\n};\n\n// replaced by build system\ncytoscape.version = version;\n\n// expose public apis (mostly for extensions)\ncytoscape.stylesheet = cytoscape.Stylesheet = Stylesheet;\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY3l0b3NjYXBlL2Rpc3QvY3l0b3NjYXBlLmVzbS5tanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwrQkFBK0I7QUFDM0Q7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsU0FBUztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFL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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLE9BQU87QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLE9BQU87QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxtQkFBbUIsYUFBYTtBQUNoQzs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRLFdBQVc7QUFDOUIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsK0NBQStDLGlCQUFpQjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixpQkFBaUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBDQUEwQztBQUMxQyw0Q0FBNEM7O0FBRTVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7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Q0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLHNDQUFzQyxPQUFPO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixjQUFjO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLHdCQUF3QixzQkFBc0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDRCQUE0QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELG1DQUFtQywwQkFBMEI7QUFDcEg7QUFDQSxLQUFLO0FBQ0w7QUFDQSxzQ0FBc0MsV0FBVztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLFdBQVc7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxXQUFXO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0Msc0NBQXNDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7O0FBRUgsQ0FBQztBQUNELENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixpQkFBaUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHdCQUF3QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7O0FBRW5CO0FBQ0Esc0JBQXNCLG1CQUFtQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsY0FBYztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxxQkFBcUIsZUFBZTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLG9CQUFvQjtBQUMxQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsV0FBVztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLG1CQUFtQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHVCQUF1QjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLGtDQUFrQztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLG9CQUFvQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQix3QkFBd0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsdUJBQXVCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7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Q0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLGtCQUFrQixxQkFBcUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixzQkFBc0I7QUFDekM7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOLDBFQUEwRTtBQUMxRTtBQUNBLDREQUE0RDtBQUM1RDs7QUFFQTtBQUNBLG9CQUFvQix1QkFBdUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHFCQUFxQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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Q0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxXQUFXO0FBQ1gsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLGdFQUFnRTs7QUFFaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBOztBQUVBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCOztBQUV2QjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtB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QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLGFBQWEsR0FBRztBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsR0FBRztBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLEdBQUc7QUFDZCxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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O0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDJCQUEyQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGtCQUFrQixpQkFBaUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1QkFBdUIsa0JBQWtCO0FBQ3pDO0FBQ0E7QUFDQTtB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OztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiwyQkFBMkI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGlCQUFpQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7O0FBRTNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQixZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsZ0JBQWdCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsUUFBUTtBQUNSOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUixNQUFNOztBQUVOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQzs7QUFFbEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQzs7QUFFckM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixpQkFBaUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGtCQUFrQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixpQkFBaUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLElBQUk7O0FBRUwsMEJBQTBCOztBQUUxQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNENBQTRDO0FBQzVDLCtCQUErQjs7QUFFL0I7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQix5QkFBeUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixzQkFBc0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7O0FBRXZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG9CQUFvQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixpQkFBaUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7O0FBRUE7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixrQkFBa0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFROztBQUVSO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxRQUFRO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQ0FBcUMsUUFBUTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLGtCQUFrQixpQkFBaUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7O0FBRUE7QUFDQTtBQUNBLE1BQU07O0FBRU47O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixnQkFBZ0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELGNBQWM7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLCtCQUErQjtBQUMvQixNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsa0JBQWtCLDZCQUE2QjtBQUMvQztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTCxHQUFHLElBQUk7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsbUJBQW1CLG1CQUFtQjtBQUN0QztBQUNBLDZCQUE2QjtBQUM3Qjs7QUFFQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsaUJBQWlCLEdBQUc7QUFDcEI7QUFDQSxHQUFHO0FBQ0gsaUJBQWlCLEdBQUc7QUFDcEI7QUFDQSxHQUFHO0FBQ0gsaUJBQWlCLEdBQUc7QUFDcEI7QUFDQSxHQUFHO0FBQ0gsb0JBQW9CLDZCQUE2QjtBQUNqRCxzQ0FBc0MsR0FBRztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsSUFBSTtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUcsSUFBSTtBQUNQO0FBQ0Esa0JBQWtCLDRCQUE0QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtB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QUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQix5QkFBeUI7QUFDM0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsZ0NBQWdDO0FBQ2xEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLGNBQWM7QUFDbEM7QUFDQSwwQkFBMEIsY0FBYztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEIsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixpQkFBaUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLG9CQUFvQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0Esc0JBQXNCLDBCQUEwQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsUUFBUTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxrQkFBa0IsaUJBQWlCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLG1DQUFtQztBQUNuQyx1QkFBdUI7QUFDdkIsdUJBQXVCOztBQUV2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RkFBNEY7QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0EsMkVBQTJFO0FBQzNFOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQix5QkFBeUI7QUFDekIsc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLHNDQUFzQztBQUN0Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQzs7QUFFakM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGVBQWU7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsYUFBYTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRTtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRDtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStEO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMkJBQTJCO0FBQy9DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiwwQkFBMEI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsNEJBQTRCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLGtCQUFrQixvQkFBb0I7QUFDdEM7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsZ0JBQWdCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLGtDQUFrQzs7QUFFbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsVUFBVTs7QUFFVixZQUFZO0FBQ1osWUFBWTs7QUFFWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKLDRCQUE0QjtBQUM1QixJQUFJO0FBQ0o7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKLDRCQUE0QjtBQUM1QixJQUFJO0FBQ0o7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDZCQUE2QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDBCQUEwQjtBQUM5QztBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0Esb0JBQW9CLDBCQUEwQjtBQUM5QztBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RCxZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47O0FBRUE7QUFDQSxvQkFBb0IsMEJBQTBCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQixxQkFBcUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RTs7QUFFeEUsc0JBQXNCLGdCQUFnQjtBQUN0QztBQUNBO0FBQ0EsOEZBQThGO0FBQzlGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMEJBQTBCLGdCQUFnQjtBQUMxQztBQUNBLDRCQUE0Qix5QkFBeUI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixhQUFhO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7O0FBRTNDLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsOEJBQThCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsaUJBQWlCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHlCQUF5QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGlCQUFpQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGlCQUFpQjtBQUNuQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixvQkFBb0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixvQkFBb0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGlCQUFpQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0Isd0JBQXdCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLDJDQUEyQzs7QUFFM0M7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsMERBQTBEOztBQUUxRDtBQUNBO0FBQ0Esb0JBQW9CLG1CQUFtQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsMkJBQTJCO0FBQ2pEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSx1Q0FBdUM7O0FBRXZDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGtCQUFrQjtBQUN4QztBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsbUJBQW1CO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxzREFBc0Q7O0FBRXREO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSwwREFBMEQ7O0FBRTFEO0FBQ0EscURBQXFEOztBQUVyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isc0JBQXNCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUix1QkFBdUI7QUFDdkI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qzs7QUFFdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQzs7QUFFMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0ZBQWdGOztBQUVoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNILDhCQUE4QjtBQUM5Qiw4QkFBOEI7QUFDOUIsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLHlCQUF5QjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsWUFBWTtBQUNaO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsZ0JBQWdCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsZ0JBQWdCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isd0JBQXdCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixxQkFBcUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7QUFFUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxRQUFROztBQUVSO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxRQUFROztBQUVSO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxRQUFROztBQUVSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsd0JBQXdCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IseUJBQXlCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBLG9CQUFvQiw0QkFBNEI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFlBQVk7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsZ0JBQWdCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxxQkFBcUI7QUFDMUUsdURBQXVEO0FBQ3ZEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRTs7QUFFakU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsdUJBQXVCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pELE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVELDZCQUE2Qjs7QUFFN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIscUJBQXFCO0FBQ2pEO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osMkNBQTJDO0FBQzNDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixpQkFBaUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGlCQUFpQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsaUJBQWlCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isb0JBQW9CO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIscUJBQXFCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsOEJBQThCO0FBQzlEO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsNEJBQTRCLHNCQUFzQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixvQkFBb0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9DQUFvQzs7QUFFcEM7QUFDQTtBQUNBLG9DQUFvQztBQUNwQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQzs7QUFFL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDRCQUE0QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7O0FBRTlCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRTs7QUFFbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1YsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVixRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixrQkFBa0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsaUJBQWlCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixtQkFBbUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHlCQUF5QjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsV0FBVztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQjs7QUFFbEI7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0Esa0JBQWtCLDZCQUE2QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qjs7QUFFOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0U7QUFDaEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFO0FBQ2pFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLG1CQUFtQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQzs7QUFFbkM7QUFDQTtBQUNBLGtCQUFrQixZQUFZO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaOztBQUVBLHVCQUF1Qjs7QUFFdkI7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHFCQUFxQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isb0JBQW9CO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHVCQUF1QjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQixrQkFBa0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHlCQUF5QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGtCQUFrQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esa0JBQWtCO0FBQ2xCLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7O0FBRUE7QUFDQSxzQ0FBc0M7QUFDdEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUNBQXlDLEtBQUs7QUFDOUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlFQUFpRSxLQUFLO0FBQ3RFO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7QUFDQSxvQkFBb0Isc0JBQXNCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLGVBQWU7QUFDZjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0IsaUJBQWlCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qjs7QUFFOUIsb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBLHdDQUF3QztBQUN4QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1REFBdUQ7O0FBRXZELDJCQUEyQjs7QUFFM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFZ0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2N5dG9zY2FwZS9kaXN0L2N5dG9zY2FwZS5lc20ubWpzPzFlMGYiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAyNCwgVGhlIEN5dG9zY2FwZSBDb25zb3J0aXVtLlxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHkgb2ZcbiAqIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIOKAnFNvZnR3YXJl4oCdKSwgdG8gZGVhbCBpblxuICogdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0b1xuICogdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXNcbiAqIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkb1xuICogc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxuICogY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQg4oCcQVMgSVPigJ0sIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAqIFNPRlRXQVJFLlxuICovXG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gIFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjtcblxuICByZXR1cm4gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvYmopIHtcbiAgICByZXR1cm4gdHlwZW9mIG9iajtcbiAgfSA6IGZ1bmN0aW9uIChvYmopIHtcbiAgICByZXR1cm4gb2JqICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xuICB9LCBfdHlwZW9mKG9iaik7XG59XG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgfVxufVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICB9XG59XG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25zdHJ1Y3RvciwgXCJwcm90b3R5cGVcIiwge1xuICAgIHdyaXRhYmxlOiBmYWxzZVxuICB9KTtcbiAgcmV0dXJuIENvbnN0cnVjdG9yO1xufVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5JDEob2JqLCBrZXksIHZhbHVlKSB7XG4gIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmpba2V5XSA9IHZhbHVlO1xuICB9XG4gIHJldHVybiBvYmo7XG59XG5mdW5jdGlvbiBfc2xpY2VkVG9BcnJheShhcnIsIGkpIHtcbiAgcmV0dXJuIF9hcnJheVdpdGhIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIsIGkpIHx8IF9ub25JdGVyYWJsZVJlc3QoKTtcbn1cbmZ1bmN0aW9uIF9hcnJheVdpdGhIb2xlcyhhcnIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIGFycjtcbn1cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHtcbiAgdmFyIF9pID0gYXJyID09IG51bGwgPyBudWxsIDogdHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBhcnJbU3ltYm9sLml0ZXJhdG9yXSB8fCBhcnJbXCJAQGl0ZXJhdG9yXCJdO1xuICBpZiAoX2kgPT0gbnVsbCkgcmV0dXJuO1xuICB2YXIgX2FyciA9IFtdO1xuICB2YXIgX24gPSB0cnVlO1xuICB2YXIgX2QgPSBmYWxzZTtcbiAgdmFyIF9zLCBfZTtcbiAgdHJ5IHtcbiAgICBmb3IgKF9pID0gX2kuY2FsbChhcnIpOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7XG4gICAgICBfYXJyLnB1c2goX3MudmFsdWUpO1xuICAgICAgaWYgKGkgJiYgX2Fyci5sZW5ndGggPT09IGkpIGJyZWFrO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgX2QgPSB0cnVlO1xuICAgIF9lID0gZXJyO1xuICB9IGZpbmFsbHkge1xuICAgIHRyeSB7XG4gICAgICBpZiAoIV9uICYmIF9pW1wicmV0dXJuXCJdICE9IG51bGwpIF9pW1wicmV0dXJuXCJdKCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmIChfZCkgdGhyb3cgX2U7XG4gICAgfVxuICB9XG4gIHJldHVybiBfYXJyO1xufVxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikge1xuICBpZiAoIW8pIHJldHVybjtcbiAgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbiAgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpO1xuICBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lO1xuICBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTtcbiAgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xufVxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHtcbiAgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7XG4gIGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgYXJyMltpXSA9IGFycltpXTtcbiAgcmV0dXJuIGFycjI7XG59XG5mdW5jdGlvbiBfbm9uSXRlcmFibGVSZXN0KCkge1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpO1xufVxuZnVuY3Rpb24gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIobywgYWxsb3dBcnJheUxpa2UpIHtcbiAgdmFyIGl0ID0gdHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl0gfHwgb1tcIkBAaXRlcmF0b3JcIl07XG4gIGlmICghaXQpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShvKSB8fCAoaXQgPSBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobykpIHx8IGFsbG93QXJyYXlMaWtlICYmIG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSB7XG4gICAgICBpZiAoaXQpIG8gPSBpdDtcbiAgICAgIHZhciBpID0gMDtcbiAgICAgIHZhciBGID0gZnVuY3Rpb24gKCkge307XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzOiBGLFxuICAgICAgICBuOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKGkgPj0gby5sZW5ndGgpIHJldHVybiB7XG4gICAgICAgICAgICBkb25lOiB0cnVlXG4gICAgICAgICAgfTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZG9uZTogZmFsc2UsXG4gICAgICAgICAgICB2YWx1ZTogb1tpKytdXG4gICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgZTogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9LFxuICAgICAgICBmOiBGXG4gICAgICB9O1xuICAgIH1cbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG4gIH1cbiAgdmFyIG5vcm1hbENvbXBsZXRpb24gPSB0cnVlLFxuICAgIGRpZEVyciA9IGZhbHNlLFxuICAgIGVycjtcbiAgcmV0dXJuIHtcbiAgICBzOiBmdW5jdGlvbiAoKSB7XG4gICAgICBpdCA9IGl0LmNhbGwobyk7XG4gICAgfSxcbiAgICBuOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgc3RlcCA9IGl0Lm5leHQoKTtcbiAgICAgIG5vcm1hbENvbXBsZXRpb24gPSBzdGVwLmRvbmU7XG4gICAgICByZXR1cm4gc3RlcDtcbiAgICB9LFxuICAgIGU6IGZ1bmN0aW9uIChlKSB7XG4gICAgICBkaWRFcnIgPSB0cnVlO1xuICAgICAgZXJyID0gZTtcbiAgICB9LFxuICAgIGY6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICghbm9ybWFsQ29tcGxldGlvbiAmJiBpdC5yZXR1cm4gIT0gbnVsbCkgaXQucmV0dXJuKCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpZiAoZGlkRXJyKSB0aHJvdyBlcnI7XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuXG52YXIgX3dpbmRvdyA9IHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnID8gbnVsbCA6IHdpbmRvdzsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuXG52YXIgbmF2aWdhdG9yID0gX3dpbmRvdyA/IF93aW5kb3cubmF2aWdhdG9yIDogbnVsbDtcbl93aW5kb3cgPyBfd2luZG93LmRvY3VtZW50IDogbnVsbDtcbnZhciB0eXBlb2ZzdHIgPSBfdHlwZW9mKCcnKTtcbnZhciB0eXBlb2ZvYmogPSBfdHlwZW9mKHt9KTtcbnZhciB0eXBlb2ZmbiA9IF90eXBlb2YoZnVuY3Rpb24gKCkge30pO1xudmFyIHR5cGVvZmh0bWxlbGUgPSB0eXBlb2YgSFRNTEVsZW1lbnQgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVvZihIVE1MRWxlbWVudCk7XG52YXIgaW5zdGFuY2VTdHIgPSBmdW5jdGlvbiBpbnN0YW5jZVN0cihvYmopIHtcbiAgcmV0dXJuIG9iaiAmJiBvYmouaW5zdGFuY2VTdHJpbmcgJiYgZm4kNihvYmouaW5zdGFuY2VTdHJpbmcpID8gb2JqLmluc3RhbmNlU3RyaW5nKCkgOiBudWxsO1xufTtcblxudmFyIHN0cmluZyA9IGZ1bmN0aW9uIHN0cmluZyhvYmopIHtcbiAgcmV0dXJuIG9iaiAhPSBudWxsICYmIF90eXBlb2Yob2JqKSA9PSB0eXBlb2ZzdHI7XG59O1xudmFyIGZuJDYgPSBmdW5jdGlvbiBmbihvYmopIHtcbiAgcmV0dXJuIG9iaiAhPSBudWxsICYmIF90eXBlb2Yob2JqKSA9PT0gdHlwZW9mZm47XG59O1xudmFyIGFycmF5ID0gZnVuY3Rpb24gYXJyYXkob2JqKSB7XG4gIHJldHVybiAhZWxlbWVudE9yQ29sbGVjdGlvbihvYmopICYmIChBcnJheS5pc0FycmF5ID8gQXJyYXkuaXNBcnJheShvYmopIDogb2JqICE9IG51bGwgJiYgb2JqIGluc3RhbmNlb2YgQXJyYXkpO1xufTtcbnZhciBwbGFpbk9iamVjdCA9IGZ1bmN0aW9uIHBsYWluT2JqZWN0KG9iaikge1xuICByZXR1cm4gb2JqICE9IG51bGwgJiYgX3R5cGVvZihvYmopID09PSB0eXBlb2ZvYmogJiYgIWFycmF5KG9iaikgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBPYmplY3Q7XG59O1xudmFyIG9iamVjdCA9IGZ1bmN0aW9uIG9iamVjdChvYmopIHtcbiAgcmV0dXJuIG9iaiAhPSBudWxsICYmIF90eXBlb2Yob2JqKSA9PT0gdHlwZW9mb2JqO1xufTtcbnZhciBudW1iZXIkMSA9IGZ1bmN0aW9uIG51bWJlcihvYmopIHtcbiAgcmV0dXJuIG9iaiAhPSBudWxsICYmIF90eXBlb2Yob2JqKSA9PT0gX3R5cGVvZigxKSAmJiAhaXNOYU4ob2JqKTtcbn07XG52YXIgaW50ZWdlciA9IGZ1bmN0aW9uIGludGVnZXIob2JqKSB7XG4gIHJldHVybiBudW1iZXIkMShvYmopICYmIE1hdGguZmxvb3Iob2JqKSA9PT0gb2JqO1xufTtcbnZhciBodG1sRWxlbWVudCA9IGZ1bmN0aW9uIGh0bWxFbGVtZW50KG9iaikge1xuICBpZiAoJ3VuZGVmaW5lZCcgPT09IHR5cGVvZmh0bWxlbGUpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBudWxsICE9IG9iaiAmJiBvYmogaW5zdGFuY2VvZiBIVE1MRWxlbWVudDtcbiAgfVxufTtcbnZhciBlbGVtZW50T3JDb2xsZWN0aW9uID0gZnVuY3Rpb24gZWxlbWVudE9yQ29sbGVjdGlvbihvYmopIHtcbiAgcmV0dXJuIGVsZW1lbnQob2JqKSB8fCBjb2xsZWN0aW9uKG9iaik7XG59O1xudmFyIGVsZW1lbnQgPSBmdW5jdGlvbiBlbGVtZW50KG9iaikge1xuICByZXR1cm4gaW5zdGFuY2VTdHIob2JqKSA9PT0gJ2NvbGxlY3Rpb24nICYmIG9iai5fcHJpdmF0ZS5zaW5nbGU7XG59O1xudmFyIGNvbGxlY3Rpb24gPSBmdW5jdGlvbiBjb2xsZWN0aW9uKG9iaikge1xuICByZXR1cm4gaW5zdGFuY2VTdHIob2JqKSA9PT0gJ2NvbGxlY3Rpb24nICYmICFvYmouX3ByaXZhdGUuc2luZ2xlO1xufTtcbnZhciBjb3JlID0gZnVuY3Rpb24gY29yZShvYmopIHtcbiAgcmV0dXJuIGluc3RhbmNlU3RyKG9iaikgPT09ICdjb3JlJztcbn07XG52YXIgc3R5bGVzaGVldCA9IGZ1bmN0aW9uIHN0eWxlc2hlZXQob2JqKSB7XG4gIHJldHVybiBpbnN0YW5jZVN0cihvYmopID09PSAnc3R5bGVzaGVldCc7XG59O1xudmFyIGV2ZW50ID0gZnVuY3Rpb24gZXZlbnQob2JqKSB7XG4gIHJldHVybiBpbnN0YW5jZVN0cihvYmopID09PSAnZXZlbnQnO1xufTtcbnZhciBlbXB0eVN0cmluZyA9IGZ1bmN0aW9uIGVtcHR5U3RyaW5nKG9iaikge1xuICBpZiAob2JqID09PSB1bmRlZmluZWQgfHwgb2JqID09PSBudWxsKSB7XG4gICAgLy8gbnVsbCBpcyBlbXB0eVxuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2UgaWYgKG9iaiA9PT0gJycgfHwgb2JqLm1hdGNoKC9eXFxzKyQvKSkge1xuICAgIHJldHVybiB0cnVlOyAvLyBlbXB0eSBzdHJpbmcgaXMgZW1wdHlcbiAgfVxuXG4gIHJldHVybiBmYWxzZTsgLy8gb3RoZXJ3aXNlLCB3ZSBkb24ndCBrbm93IHdoYXQgd2UndmUgZ290XG59O1xudmFyIGRvbUVsZW1lbnQgPSBmdW5jdGlvbiBkb21FbGVtZW50KG9iaikge1xuICBpZiAodHlwZW9mIEhUTUxFbGVtZW50ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBmYWxzZTsgLy8gd2UncmUgbm90IGluIGEgYnJvd3NlciBzbyBpdCBkb2Vzbid0IG1hdHRlclxuICB9IGVsc2Uge1xuICAgIHJldHVybiBvYmogaW5zdGFuY2VvZiBIVE1MRWxlbWVudDtcbiAgfVxufTtcbnZhciBib3VuZGluZ0JveCA9IGZ1bmN0aW9uIGJvdW5kaW5nQm94KG9iaikge1xuICByZXR1cm4gcGxhaW5PYmplY3Qob2JqKSAmJiBudW1iZXIkMShvYmoueDEpICYmIG51bWJlciQxKG9iai54MikgJiYgbnVtYmVyJDEob2JqLnkxKSAmJiBudW1iZXIkMShvYmoueTIpO1xufTtcbnZhciBwcm9taXNlID0gZnVuY3Rpb24gcHJvbWlzZShvYmopIHtcbiAgcmV0dXJuIG9iamVjdChvYmopICYmIGZuJDYob2JqLnRoZW4pO1xufTtcbnZhciBtcyA9IGZ1bmN0aW9uIG1zKCkge1xuICByZXR1cm4gbmF2aWdhdG9yICYmIG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL21zaWV8dHJpZGVudHxlZGdlL2kpO1xufTsgLy8gcHJvYmFibHkgYSBiZXR0ZXIgd2F5IHRvIGRldGVjdCB0aGlzLi4uXG5cbnZhciBtZW1vaXplJDEgPSBmdW5jdGlvbiBtZW1vaXplKGZuLCBrZXlGbikge1xuICBpZiAoIWtleUZuKSB7XG4gICAga2V5Rm4gPSBmdW5jdGlvbiBrZXlGbigpIHtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHJldHVybiBhcmd1bWVudHNbMF07XG4gICAgICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuICd1bmRlZmluZWQnO1xuICAgICAgfVxuICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGFyZ3MucHVzaChhcmd1bWVudHNbaV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFyZ3Muam9pbignJCcpO1xuICAgIH07XG4gIH1cbiAgdmFyIG1lbW9pemVkRm4gPSBmdW5jdGlvbiBtZW1vaXplZEZuKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICB2YXIgcmV0O1xuICAgIHZhciBrID0ga2V5Rm4uYXBwbHkoc2VsZiwgYXJncyk7XG4gICAgdmFyIGNhY2hlID0gbWVtb2l6ZWRGbi5jYWNoZTtcbiAgICBpZiAoIShyZXQgPSBjYWNoZVtrXSkpIHtcbiAgICAgIHJldCA9IGNhY2hlW2tdID0gZm4uYXBwbHkoc2VsZiwgYXJncyk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH07XG4gIG1lbW9pemVkRm4uY2FjaGUgPSB7fTtcbiAgcmV0dXJuIG1lbW9pemVkRm47XG59O1xuXG52YXIgY2FtZWwyZGFzaCA9IG1lbW9pemUkMShmdW5jdGlvbiAoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvKFtBLVpdKS9nLCBmdW5jdGlvbiAodikge1xuICAgIHJldHVybiAnLScgKyB2LnRvTG93ZXJDYXNlKCk7XG4gIH0pO1xufSk7XG52YXIgZGFzaDJjYW1lbCA9IG1lbW9pemUkMShmdW5jdGlvbiAoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvKC1cXHcpL2csIGZ1bmN0aW9uICh2KSB7XG4gICAgcmV0dXJuIHZbMV0udG9VcHBlckNhc2UoKTtcbiAgfSk7XG59KTtcbnZhciBwcmVwZW5kQ2FtZWwgPSBtZW1vaXplJDEoZnVuY3Rpb24gKHByZWZpeCwgc3RyKSB7XG4gIHJldHVybiBwcmVmaXggKyBzdHJbMF0udG9VcHBlckNhc2UoKSArIHN0ci5zdWJzdHJpbmcoMSk7XG59LCBmdW5jdGlvbiAocHJlZml4LCBzdHIpIHtcbiAgcmV0dXJuIHByZWZpeCArICckJyArIHN0cjtcbn0pO1xudmFyIGNhcGl0YWxpemUgPSBmdW5jdGlvbiBjYXBpdGFsaXplKHN0cikge1xuICBpZiAoZW1wdHlTdHJpbmcoc3RyKSkge1xuICAgIHJldHVybiBzdHI7XG4gIH1cbiAgcmV0dXJuIHN0ci5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0ci5zdWJzdHJpbmcoMSk7XG59O1xuXG52YXIgbnVtYmVyID0gJyg/OlstK10/KD86KD86XFxcXGQrfFxcXFxkKlxcXFwuXFxcXGQrKSg/OltFZV1bKy1dP1xcXFxkKyk/KSknO1xudmFyIHJnYmEgPSAncmdiW2FdP1xcXFwoKCcgKyBudW1iZXIgKyAnWyVdPylcXFxccyosXFxcXHMqKCcgKyBudW1iZXIgKyAnWyVdPylcXFxccyosXFxcXHMqKCcgKyBudW1iZXIgKyAnWyVdPykoPzpcXFxccyosXFxcXHMqKCcgKyBudW1iZXIgKyAnKSk/XFxcXCknO1xudmFyIHJnYmFOb0JhY2tSZWZzID0gJ3JnYlthXT9cXFxcKCg/OicgKyBudW1iZXIgKyAnWyVdPylcXFxccyosXFxcXHMqKD86JyArIG51bWJlciArICdbJV0/KVxcXFxzKixcXFxccyooPzonICsgbnVtYmVyICsgJ1slXT8pKD86XFxcXHMqLFxcXFxzKig/OicgKyBudW1iZXIgKyAnKSk/XFxcXCknO1xudmFyIGhzbGEgPSAnaHNsW2FdP1xcXFwoKCcgKyBudW1iZXIgKyAnKVxcXFxzKixcXFxccyooJyArIG51bWJlciArICdbJV0pXFxcXHMqLFxcXFxzKignICsgbnVtYmVyICsgJ1slXSkoPzpcXFxccyosXFxcXHMqKCcgKyBudW1iZXIgKyAnKSk/XFxcXCknO1xudmFyIGhzbGFOb0JhY2tSZWZzID0gJ2hzbFthXT9cXFxcKCg/OicgKyBudW1iZXIgKyAnKVxcXFxzKixcXFxccyooPzonICsgbnVtYmVyICsgJ1slXSlcXFxccyosXFxcXHMqKD86JyArIG51bWJlciArICdbJV0pKD86XFxcXHMqLFxcXFxzKig/OicgKyBudW1iZXIgKyAnKSk/XFxcXCknO1xudmFyIGhleDMgPSAnXFxcXCNbMC05YS1mQS1GXXszfSc7XG52YXIgaGV4NiA9ICdcXFxcI1swLTlhLWZBLUZdezZ9JztcblxudmFyIGFzY2VuZGluZyA9IGZ1bmN0aW9uIGFzY2VuZGluZyhhLCBiKSB7XG4gIGlmIChhIDwgYikge1xuICAgIHJldHVybiAtMTtcbiAgfSBlbHNlIGlmIChhID4gYikge1xuICAgIHJldHVybiAxO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAwO1xuICB9XG59O1xudmFyIGRlc2NlbmRpbmcgPSBmdW5jdGlvbiBkZXNjZW5kaW5nKGEsIGIpIHtcbiAgcmV0dXJuIC0xICogYXNjZW5kaW5nKGEsIGIpO1xufTtcblxudmFyIGV4dGVuZCA9IE9iamVjdC5hc3NpZ24gIT0gbnVsbCA/IE9iamVjdC5hc3NpZ24uYmluZChPYmplY3QpIDogZnVuY3Rpb24gKHRndCkge1xuICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG9iaiA9IGFyZ3NbaV07XG4gICAgaWYgKG9iaiA9PSBudWxsKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwga2V5cy5sZW5ndGg7IGorKykge1xuICAgICAgdmFyIGsgPSBrZXlzW2pdO1xuICAgICAgdGd0W2tdID0gb2JqW2tdO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGd0O1xufTtcblxuLy8gZ2V0IFtyLCBnLCBiXSBmcm9tICNhYmMgb3IgI2FhYmJjY1xudmFyIGhleDJ0dXBsZSA9IGZ1bmN0aW9uIGhleDJ0dXBsZShoZXgpIHtcbiAgaWYgKCEoaGV4Lmxlbmd0aCA9PT0gNCB8fCBoZXgubGVuZ3RoID09PSA3KSB8fCBoZXhbMF0gIT09ICcjJykge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgc2hvcnRIZXggPSBoZXgubGVuZ3RoID09PSA0O1xuICB2YXIgciwgZywgYjtcbiAgdmFyIGJhc2UgPSAxNjtcbiAgaWYgKHNob3J0SGV4KSB7XG4gICAgciA9IHBhcnNlSW50KGhleFsxXSArIGhleFsxXSwgYmFzZSk7XG4gICAgZyA9IHBhcnNlSW50KGhleFsyXSArIGhleFsyXSwgYmFzZSk7XG4gICAgYiA9IHBhcnNlSW50KGhleFszXSArIGhleFszXSwgYmFzZSk7XG4gIH0gZWxzZSB7XG4gICAgciA9IHBhcnNlSW50KGhleFsxXSArIGhleFsyXSwgYmFzZSk7XG4gICAgZyA9IHBhcnNlSW50KGhleFszXSArIGhleFs0XSwgYmFzZSk7XG4gICAgYiA9IHBhcnNlSW50KGhleFs1XSArIGhleFs2XSwgYmFzZSk7XG4gIH1cbiAgcmV0dXJuIFtyLCBnLCBiXTtcbn07XG5cbi8vIGdldCBbciwgZywgYiwgYV0gZnJvbSBoc2woMCwgMCwgMCkgb3IgaHNsYSgwLCAwLCAwLCAwKVxudmFyIGhzbDJ0dXBsZSA9IGZ1bmN0aW9uIGhzbDJ0dXBsZShoc2wpIHtcbiAgdmFyIHJldDtcbiAgdmFyIGgsIHMsIGwsIGEsIHIsIGcsIGI7XG4gIGZ1bmN0aW9uIGh1ZTJyZ2IocCwgcSwgdCkge1xuICAgIGlmICh0IDwgMCkgdCArPSAxO1xuICAgIGlmICh0ID4gMSkgdCAtPSAxO1xuICAgIGlmICh0IDwgMSAvIDYpIHJldHVybiBwICsgKHEgLSBwKSAqIDYgKiB0O1xuICAgIGlmICh0IDwgMSAvIDIpIHJldHVybiBxO1xuICAgIGlmICh0IDwgMiAvIDMpIHJldHVybiBwICsgKHEgLSBwKSAqICgyIC8gMyAtIHQpICogNjtcbiAgICByZXR1cm4gcDtcbiAgfVxuICB2YXIgbSA9IG5ldyBSZWdFeHAoJ14nICsgaHNsYSArICckJykuZXhlYyhoc2wpO1xuICBpZiAobSkge1xuICAgIC8vIGdldCBodWVcbiAgICBoID0gcGFyc2VJbnQobVsxXSk7XG4gICAgaWYgKGggPCAwKSB7XG4gICAgICBoID0gKDM2MCAtIC0xICogaCAlIDM2MCkgJSAzNjA7XG4gICAgfSBlbHNlIGlmIChoID4gMzYwKSB7XG4gICAgICBoID0gaCAlIDM2MDtcbiAgICB9XG4gICAgaCAvPSAzNjA7IC8vIG5vcm1hbGlzZSBvbiBbMCwgMV1cblxuICAgIHMgPSBwYXJzZUZsb2F0KG1bMl0pO1xuICAgIGlmIChzIDwgMCB8fCBzID4gMTAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBzYXR1cmF0aW9uIGlzIFswLCAxMDBdXG4gICAgcyA9IHMgLyAxMDA7IC8vIG5vcm1hbGlzZSBvbiBbMCwgMV1cblxuICAgIGwgPSBwYXJzZUZsb2F0KG1bM10pO1xuICAgIGlmIChsIDwgMCB8fCBsID4gMTAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBsaWdodG5lc3MgaXMgWzAsIDEwMF1cbiAgICBsID0gbCAvIDEwMDsgLy8gbm9ybWFsaXNlIG9uIFswLCAxXVxuXG4gICAgYSA9IG1bNF07XG4gICAgaWYgKGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgYSA9IHBhcnNlRmxvYXQoYSk7XG4gICAgICBpZiAoYSA8IDAgfHwgYSA+IDEpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBhbHBoYSBpcyBbMCwgMV1cbiAgICB9XG5cbiAgICAvLyBub3csIGNvbnZlcnQgdG8gcmdiXG4gICAgLy8gY29kZSBmcm9tIGh0dHA6Ly9tamlqYWNrc29uLmNvbS8yMDA4LzAyL3JnYi10by1oc2wtYW5kLXJnYi10by1oc3YtY29sb3ItbW9kZWwtY29udmVyc2lvbi1hbGdvcml0aG1zLWluLWphdmFzY3JpcHRcbiAgICBpZiAocyA9PT0gMCkge1xuICAgICAgciA9IGcgPSBiID0gTWF0aC5yb3VuZChsICogMjU1KTsgLy8gYWNocm9tYXRpY1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcSA9IGwgPCAwLjUgPyBsICogKDEgKyBzKSA6IGwgKyBzIC0gbCAqIHM7XG4gICAgICB2YXIgcCA9IDIgKiBsIC0gcTtcbiAgICAgIHIgPSBNYXRoLnJvdW5kKDI1NSAqIGh1ZTJyZ2IocCwgcSwgaCArIDEgLyAzKSk7XG4gICAgICBnID0gTWF0aC5yb3VuZCgyNTUgKiBodWUycmdiKHAsIHEsIGgpKTtcbiAgICAgIGIgPSBNYXRoLnJvdW5kKDI1NSAqIGh1ZTJyZ2IocCwgcSwgaCAtIDEgLyAzKSk7XG4gICAgfVxuICAgIHJldCA9IFtyLCBnLCBiLCBhXTtcbiAgfVxuICByZXR1cm4gcmV0O1xufTtcblxuLy8gZ2V0IFtyLCBnLCBiLCBhXSBmcm9tIHJnYigwLCAwLCAwKSBvciByZ2JhKDAsIDAsIDAsIDApXG52YXIgcmdiMnR1cGxlID0gZnVuY3Rpb24gcmdiMnR1cGxlKHJnYikge1xuICB2YXIgcmV0O1xuICB2YXIgbSA9IG5ldyBSZWdFeHAoJ14nICsgcmdiYSArICckJykuZXhlYyhyZ2IpO1xuICBpZiAobSkge1xuICAgIHJldCA9IFtdO1xuICAgIHZhciBpc1BjdCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDw9IDM7IGkrKykge1xuICAgICAgdmFyIGNoYW5uZWwgPSBtW2ldO1xuICAgICAgaWYgKGNoYW5uZWxbY2hhbm5lbC5sZW5ndGggLSAxXSA9PT0gJyUnKSB7XG4gICAgICAgIGlzUGN0W2ldID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGNoYW5uZWwgPSBwYXJzZUZsb2F0KGNoYW5uZWwpO1xuICAgICAgaWYgKGlzUGN0W2ldKSB7XG4gICAgICAgIGNoYW5uZWwgPSBjaGFubmVsIC8gMTAwICogMjU1OyAvLyBub3JtYWxpc2UgdG8gWzAsIDI1NV1cbiAgICAgIH1cblxuICAgICAgaWYgKGNoYW5uZWwgPCAwIHx8IGNoYW5uZWwgPiAyNTUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBpbnZhbGlkIGNoYW5uZWwgdmFsdWVcblxuICAgICAgcmV0LnB1c2goTWF0aC5mbG9vcihjaGFubmVsKSk7XG4gICAgfVxuICAgIHZhciBhdExlYXN0T25lSXNQY3QgPSBpc1BjdFsxXSB8fCBpc1BjdFsyXSB8fCBpc1BjdFszXTtcbiAgICB2YXIgYWxsQXJlUGN0ID0gaXNQY3RbMV0gJiYgaXNQY3RbMl0gJiYgaXNQY3RbM107XG4gICAgaWYgKGF0TGVhc3RPbmVJc1BjdCAmJiAhYWxsQXJlUGN0KSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBtdXN0IGFsbCBiZSBwZXJjZW50IHZhbHVlcyBpZiBvbmUgaXNcblxuICAgIHZhciBhbHBoYSA9IG1bNF07XG4gICAgaWYgKGFscGhhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGFscGhhID0gcGFyc2VGbG9hdChhbHBoYSk7XG4gICAgICBpZiAoYWxwaGEgPCAwIHx8IGFscGhhID4gMSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIGludmFsaWQgYWxwaGEgdmFsdWVcblxuICAgICAgcmV0LnB1c2goYWxwaGEpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmV0O1xufTtcbnZhciBjb2xvcm5hbWUydHVwbGUgPSBmdW5jdGlvbiBjb2xvcm5hbWUydHVwbGUoY29sb3IpIHtcbiAgcmV0dXJuIGNvbG9yc1tjb2xvci50b0xvd2VyQ2FzZSgpXTtcbn07XG52YXIgY29sb3IydHVwbGUgPSBmdW5jdGlvbiBjb2xvcjJ0dXBsZShjb2xvcikge1xuICByZXR1cm4gKGFycmF5KGNvbG9yKSA/IGNvbG9yIDogbnVsbCkgfHwgY29sb3JuYW1lMnR1cGxlKGNvbG9yKSB8fCBoZXgydHVwbGUoY29sb3IpIHx8IHJnYjJ0dXBsZShjb2xvcikgfHwgaHNsMnR1cGxlKGNvbG9yKTtcbn07XG52YXIgY29sb3JzID0ge1xuICAvLyBzcGVjaWFsIGNvbG91ciBuYW1lc1xuICB0cmFuc3BhcmVudDogWzAsIDAsIDAsIDBdLFxuICAvLyBOQiBhbHBoYSA9PT0gMFxuXG4gIC8vIHJlZ3VsYXIgY29sb3Vyc1xuICBhbGljZWJsdWU6IFsyNDAsIDI0OCwgMjU1XSxcbiAgYW50aXF1ZXdoaXRlOiBbMjUwLCAyMzUsIDIxNV0sXG4gIGFxdWE6IFswLCAyNTUsIDI1NV0sXG4gIGFxdWFtYXJpbmU6IFsxMjcsIDI1NSwgMjEyXSxcbiAgYXp1cmU6IFsyNDAsIDI1NSwgMjU1XSxcbiAgYmVpZ2U6IFsyNDUsIDI0NSwgMjIwXSxcbiAgYmlzcXVlOiBbMjU1LCAyMjgsIDE5Nl0sXG4gIGJsYWNrOiBbMCwgMCwgMF0sXG4gIGJsYW5jaGVkYWxtb25kOiBbMjU1LCAyMzUsIDIwNV0sXG4gIGJsdWU6IFswLCAwLCAyNTVdLFxuICBibHVldmlvbGV0OiBbMTM4LCA0MywgMjI2XSxcbiAgYnJvd246IFsxNjUsIDQyLCA0Ml0sXG4gIGJ1cmx5d29vZDogWzIyMiwgMTg0LCAxMzVdLFxuICBjYWRldGJsdWU6IFs5NSwgMTU4LCAxNjBdLFxuICBjaGFydHJldXNlOiBbMTI3LCAyNTUsIDBdLFxuICBjaG9jb2xhdGU6IFsyMTAsIDEwNSwgMzBdLFxuICBjb3JhbDogWzI1NSwgMTI3LCA4MF0sXG4gIGNvcm5mbG93ZXJibHVlOiBbMTAwLCAxNDksIDIzN10sXG4gIGNvcm5zaWxrOiBbMjU1LCAyNDgsIDIyMF0sXG4gIGNyaW1zb246IFsyMjAsIDIwLCA2MF0sXG4gIGN5YW46IFswLCAyNTUsIDI1NV0sXG4gIGRhcmtibHVlOiBbMCwgMCwgMTM5XSxcbiAgZGFya2N5YW46IFswLCAxMzksIDEzOV0sXG4gIGRhcmtnb2xkZW5yb2Q6IFsxODQsIDEzNCwgMTFdLFxuICBkYXJrZ3JheTogWzE2OSwgMTY5LCAxNjldLFxuICBkYXJrZ3JlZW46IFswLCAxMDAsIDBdLFxuICBkYXJrZ3JleTogWzE2OSwgMTY5LCAxNjldLFxuICBkYXJra2hha2k6IFsxODksIDE4MywgMTA3XSxcbiAgZGFya21hZ2VudGE6IFsxMzksIDAsIDEzOV0sXG4gIGRhcmtvbGl2ZWdyZWVuOiBbODUsIDEwNywgNDddLFxuICBkYXJrb3JhbmdlOiBbMjU1LCAxNDAsIDBdLFxuICBkYXJrb3JjaGlkOiBbMTUzLCA1MCwgMjA0XSxcbiAgZGFya3JlZDogWzEzOSwgMCwgMF0sXG4gIGRhcmtzYWxtb246IFsyMzMsIDE1MCwgMTIyXSxcbiAgZGFya3NlYWdyZWVuOiBbMTQzLCAxODgsIDE0M10sXG4gIGRhcmtzbGF0ZWJsdWU6IFs3MiwgNjEsIDEzOV0sXG4gIGRhcmtzbGF0ZWdyYXk6IFs0NywgNzksIDc5XSxcbiAgZGFya3NsYXRlZ3JleTogWzQ3LCA3OSwgNzldLFxuICBkYXJrdHVycXVvaXNlOiBbMCwgMjA2LCAyMDldLFxuICBkYXJrdmlvbGV0OiBbMTQ4LCAwLCAyMTFdLFxuICBkZWVwcGluazogWzI1NSwgMjAsIDE0N10sXG4gIGRlZXBza3libHVlOiBbMCwgMTkxLCAyNTVdLFxuICBkaW1ncmF5OiBbMTA1LCAxMDUsIDEwNV0sXG4gIGRpbWdyZXk6IFsxMDUsIDEwNSwgMTA1XSxcbiAgZG9kZ2VyYmx1ZTogWzMwLCAxNDQsIDI1NV0sXG4gIGZpcmVicmljazogWzE3OCwgMzQsIDM0XSxcbiAgZmxvcmFsd2hpdGU6IFsyNTUsIDI1MCwgMjQwXSxcbiAgZm9yZXN0Z3JlZW46IFszNCwgMTM5LCAzNF0sXG4gIGZ1Y2hzaWE6IFsyNTUsIDAsIDI1NV0sXG4gIGdhaW5zYm9ybzogWzIyMCwgMjIwLCAyMjBdLFxuICBnaG9zdHdoaXRlOiBbMjQ4LCAyNDgsIDI1NV0sXG4gIGdvbGQ6IFsyNTUsIDIxNSwgMF0sXG4gIGdvbGRlbnJvZDogWzIxOCwgMTY1LCAzMl0sXG4gIGdyYXk6IFsxMjgsIDEyOCwgMTI4XSxcbiAgZ3JleTogWzEyOCwgMTI4LCAxMjhdLFxuICBncmVlbjogWzAsIDEyOCwgMF0sXG4gIGdyZWVueWVsbG93OiBbMTczLCAyNTUsIDQ3XSxcbiAgaG9uZXlkZXc6IFsyNDAsIDI1NSwgMjQwXSxcbiAgaG90cGluazogWzI1NSwgMTA1LCAxODBdLFxuICBpbmRpYW5yZWQ6IFsyMDUsIDkyLCA5Ml0sXG4gIGluZGlnbzogWzc1LCAwLCAxMzBdLFxuICBpdm9yeTogWzI1NSwgMjU1LCAyNDBdLFxuICBraGFraTogWzI0MCwgMjMwLCAxNDBdLFxuICBsYXZlbmRlcjogWzIzMCwgMjMwLCAyNTBdLFxuICBsYXZlbmRlcmJsdXNoOiBbMjU1LCAyNDAsIDI0NV0sXG4gIGxhd25ncmVlbjogWzEyNCwgMjUyLCAwXSxcbiAgbGVtb25jaGlmZm9uOiBbMjU1LCAyNTAsIDIwNV0sXG4gIGxpZ2h0Ymx1ZTogWzE3MywgMjE2LCAyMzBdLFxuICBsaWdodGNvcmFsOiBbMjQwLCAxMjgsIDEyOF0sXG4gIGxpZ2h0Y3lhbjogWzIyNCwgMjU1LCAyNTVdLFxuICBsaWdodGdvbGRlbnJvZHllbGxvdzogWzI1MCwgMjUwLCAyMTBdLFxuICBsaWdodGdyYXk6IFsyMTEsIDIxMSwgMjExXSxcbiAgbGlnaHRncmVlbjogWzE0NCwgMjM4LCAxNDRdLFxuICBsaWdodGdyZXk6IFsyMTEsIDIxMSwgMjExXSxcbiAgbGlnaHRwaW5rOiBbMjU1LCAxODIsIDE5M10sXG4gIGxpZ2h0c2FsbW9uOiBbMjU1LCAxNjAsIDEyMl0sXG4gIGxpZ2h0c2VhZ3JlZW46IFszMiwgMTc4LCAxNzBdLFxuICBsaWdodHNreWJsdWU6IFsxMzUsIDIwNiwgMjUwXSxcbiAgbGlnaHRzbGF0ZWdyYXk6IFsxMTksIDEzNiwgMTUzXSxcbiAgbGlnaHRzbGF0ZWdyZXk6IFsxMTksIDEzNiwgMTUzXSxcbiAgbGlnaHRzdGVlbGJsdWU6IFsxNzYsIDE5NiwgMjIyXSxcbiAgbGlnaHR5ZWxsb3c6IFsyNTUsIDI1NSwgMjI0XSxcbiAgbGltZTogWzAsIDI1NSwgMF0sXG4gIGxpbWVncmVlbjogWzUwLCAyMDUsIDUwXSxcbiAgbGluZW46IFsyNTAsIDI0MCwgMjMwXSxcbiAgbWFnZW50YTogWzI1NSwgMCwgMjU1XSxcbiAgbWFyb29uOiBbMTI4LCAwLCAwXSxcbiAgbWVkaXVtYXF1YW1hcmluZTogWzEwMiwgMjA1LCAxNzBdLFxuICBtZWRpdW1ibHVlOiBbMCwgMCwgMjA1XSxcbiAgbWVkaXVtb3JjaGlkOiBbMTg2LCA4NSwgMjExXSxcbiAgbWVkaXVtcHVycGxlOiBbMTQ3LCAxMTIsIDIxOV0sXG4gIG1lZGl1bXNlYWdyZWVuOiBbNjAsIDE3OSwgMTEzXSxcbiAgbWVkaXVtc2xhdGVibHVlOiBbMTIzLCAxMDQsIDIzOF0sXG4gIG1lZGl1bXNwcmluZ2dyZWVuOiBbMCwgMjUwLCAxNTRdLFxuICBtZWRpdW10dXJxdW9pc2U6IFs3MiwgMjA5LCAyMDRdLFxuICBtZWRpdW12aW9sZXRyZWQ6IFsxOTksIDIxLCAxMzNdLFxuICBtaWRuaWdodGJsdWU6IFsyNSwgMjUsIDExMl0sXG4gIG1pbnRjcmVhbTogWzI0NSwgMjU1LCAyNTBdLFxuICBtaXN0eXJvc2U6IFsyNTUsIDIyOCwgMjI1XSxcbiAgbW9jY2FzaW46IFsyNTUsIDIyOCwgMTgxXSxcbiAgbmF2YWpvd2hpdGU6IFsyNTUsIDIyMiwgMTczXSxcbiAgbmF2eTogWzAsIDAsIDEyOF0sXG4gIG9sZGxhY2U6IFsyNTMsIDI0NSwgMjMwXSxcbiAgb2xpdmU6IFsxMjgsIDEyOCwgMF0sXG4gIG9saXZlZHJhYjogWzEwNywgMTQyLCAzNV0sXG4gIG9yYW5nZTogWzI1NSwgMTY1LCAwXSxcbiAgb3JhbmdlcmVkOiBbMjU1LCA2OSwgMF0sXG4gIG9yY2hpZDogWzIxOCwgMTEyLCAyMTRdLFxuICBwYWxlZ29sZGVucm9kOiBbMjM4LCAyMzIsIDE3MF0sXG4gIHBhbGVncmVlbjogWzE1MiwgMjUxLCAxNTJdLFxuICBwYWxldHVycXVvaXNlOiBbMTc1LCAyMzgsIDIzOF0sXG4gIHBhbGV2aW9sZXRyZWQ6IFsyMTksIDExMiwgMTQ3XSxcbiAgcGFwYXlhd2hpcDogWzI1NSwgMjM5LCAyMTNdLFxuICBwZWFjaHB1ZmY6IFsyNTUsIDIxOCwgMTg1XSxcbiAgcGVydTogWzIwNSwgMTMzLCA2M10sXG4gIHBpbms6IFsyNTUsIDE5MiwgMjAzXSxcbiAgcGx1bTogWzIyMSwgMTYwLCAyMjFdLFxuICBwb3dkZXJibHVlOiBbMTc2LCAyMjQsIDIzMF0sXG4gIHB1cnBsZTogWzEyOCwgMCwgMTI4XSxcbiAgcmVkOiBbMjU1LCAwLCAwXSxcbiAgcm9zeWJyb3duOiBbMTg4LCAxNDMsIDE0M10sXG4gIHJveWFsYmx1ZTogWzY1LCAxMDUsIDIyNV0sXG4gIHNhZGRsZWJyb3duOiBbMTM5LCA2OSwgMTldLFxuICBzYWxtb246IFsyNTAsIDEyOCwgMTE0XSxcbiAgc2FuZHlicm93bjogWzI0NCwgMTY0LCA5Nl0sXG4gIHNlYWdyZWVuOiBbNDYsIDEzOSwgODddLFxuICBzZWFzaGVsbDogWzI1NSwgMjQ1LCAyMzhdLFxuICBzaWVubmE6IFsxNjAsIDgyLCA0NV0sXG4gIHNpbHZlcjogWzE5MiwgMTkyLCAxOTJdLFxuICBza3libHVlOiBbMTM1LCAyMDYsIDIzNV0sXG4gIHNsYXRlYmx1ZTogWzEwNiwgOTAsIDIwNV0sXG4gIHNsYXRlZ3JheTogWzExMiwgMTI4LCAxNDRdLFxuICBzbGF0ZWdyZXk6IFsxMTIsIDEyOCwgMTQ0XSxcbiAgc25vdzogWzI1NSwgMjUwLCAyNTBdLFxuICBzcHJpbmdncmVlbjogWzAsIDI1NSwgMTI3XSxcbiAgc3RlZWxibHVlOiBbNzAsIDEzMCwgMTgwXSxcbiAgdGFuOiBbMjEwLCAxODAsIDE0MF0sXG4gIHRlYWw6IFswLCAxMjgsIDEyOF0sXG4gIHRoaXN0bGU6IFsyMTYsIDE5MSwgMjE2XSxcbiAgdG9tYXRvOiBbMjU1LCA5OSwgNzFdLFxuICB0dXJxdW9pc2U6IFs2NCwgMjI0LCAyMDhdLFxuICB2aW9sZXQ6IFsyMzgsIDEzMCwgMjM4XSxcbiAgd2hlYXQ6IFsyNDUsIDIyMiwgMTc5XSxcbiAgd2hpdGU6IFsyNTUsIDI1NSwgMjU1XSxcbiAgd2hpdGVzbW9rZTogWzI0NSwgMjQ1LCAyNDVdLFxuICB5ZWxsb3c6IFsyNTUsIDI1NSwgMF0sXG4gIHllbGxvd2dyZWVuOiBbMTU0LCAyMDUsIDUwXVxufTtcblxuLy8gc2V0cyB0aGUgdmFsdWUgaW4gYSBtYXAgKG1hcCBtYXkgbm90IGJlIGJ1aWx0KVxudmFyIHNldE1hcCA9IGZ1bmN0aW9uIHNldE1hcChvcHRpb25zKSB7XG4gIHZhciBvYmogPSBvcHRpb25zLm1hcDtcbiAgdmFyIGtleXMgPSBvcHRpb25zLmtleXM7XG4gIHZhciBsID0ga2V5cy5sZW5ndGg7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgaWYgKHBsYWluT2JqZWN0KGtleSkpIHtcbiAgICAgIHRocm93IEVycm9yKCdUcmllZCB0byBzZXQgbWFwIHdpdGggb2JqZWN0IGtleScpO1xuICAgIH1cbiAgICBpZiAoaSA8IGtleXMubGVuZ3RoIC0gMSkge1xuICAgICAgLy8gZXh0ZW5kIHRoZSBtYXAgaWYgbmVjZXNzYXJ5XG4gICAgICBpZiAob2JqW2tleV0gPT0gbnVsbCkge1xuICAgICAgICBvYmpba2V5XSA9IHt9O1xuICAgICAgfVxuICAgICAgb2JqID0gb2JqW2tleV07XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHNldCB0aGUgdmFsdWVcbiAgICAgIG9ialtrZXldID0gb3B0aW9ucy52YWx1ZTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIGdldHMgdGhlIHZhbHVlIGluIGEgbWFwIGV2ZW4gaWYgaXQncyBub3QgYnVpbHQgaW4gcGxhY2VzXG52YXIgZ2V0TWFwID0gZnVuY3Rpb24gZ2V0TWFwKG9wdGlvbnMpIHtcbiAgdmFyIG9iaiA9IG9wdGlvbnMubWFwO1xuICB2YXIga2V5cyA9IG9wdGlvbnMua2V5cztcbiAgdmFyIGwgPSBrZXlzLmxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICBpZiAocGxhaW5PYmplY3Qoa2V5KSkge1xuICAgICAgdGhyb3cgRXJyb3IoJ1RyaWVkIHRvIGdldCBtYXAgd2l0aCBvYmplY3Qga2V5Jyk7XG4gICAgfVxuICAgIG9iaiA9IG9ialtrZXldO1xuICAgIGlmIChvYmogPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG9iajtcbn07XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgdGhlXG4gKiBbbGFuZ3VhZ2UgdHlwZV0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLWVjbWFzY3JpcHQtbGFuZ3VhZ2UtdHlwZXMpXG4gKiBvZiBgT2JqZWN0YC4gKGUuZy4gYXJyYXlzLCBmdW5jdGlvbnMsIG9iamVjdHMsIHJlZ2V4ZXMsIGBuZXcgTnVtYmVyKDApYCwgYW5kIGBuZXcgU3RyaW5nKCcnKWApXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3Qoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KF8ubm9vcCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiAodHlwZSA9PSAnb2JqZWN0JyB8fCB0eXBlID09ICdmdW5jdGlvbicpO1xufVxuXG52YXIgaXNPYmplY3RfMSA9IGlzT2JqZWN0O1xuXG52YXIgY29tbW9uanNHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWxUaGlzIDogdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGYgOiB7fTtcblxuZnVuY3Rpb24gY3JlYXRlQ29tbW9uanNNb2R1bGUoZm4sIG1vZHVsZSkge1xuXHRyZXR1cm4gbW9kdWxlID0geyBleHBvcnRzOiB7fSB9LCBmbihtb2R1bGUsIG1vZHVsZS5leHBvcnRzKSwgbW9kdWxlLmV4cG9ydHM7XG59XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZ2xvYmFsYCBmcm9tIE5vZGUuanMuICovXG52YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBjb21tb25qc0dsb2JhbCA9PSAnb2JqZWN0JyAmJiBjb21tb25qc0dsb2JhbCAmJiBjb21tb25qc0dsb2JhbC5PYmplY3QgPT09IE9iamVjdCAmJiBjb21tb25qc0dsb2JhbDtcblxudmFyIF9mcmVlR2xvYmFsID0gZnJlZUdsb2JhbDtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBzZWxmYC4gKi9cbnZhciBmcmVlU2VsZiA9IHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYgJiYgc2VsZi5PYmplY3QgPT09IE9iamVjdCAmJiBzZWxmO1xuXG4vKiogVXNlZCBhcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdC4gKi9cbnZhciByb290ID0gX2ZyZWVHbG9iYWwgfHwgZnJlZVNlbGYgfHwgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcblxudmFyIF9yb290ID0gcm9vdDtcblxuLyoqXG4gKiBHZXRzIHRoZSB0aW1lc3RhbXAgb2YgdGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdGhhdCBoYXZlIGVsYXBzZWQgc2luY2VcbiAqIHRoZSBVbml4IGVwb2NoICgxIEphbnVhcnkgMTk3MCAwMDowMDowMCBVVEMpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMi40LjBcbiAqIEBjYXRlZ29yeSBEYXRlXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSB0aW1lc3RhbXAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uZGVmZXIoZnVuY3Rpb24oc3RhbXApIHtcbiAqICAgY29uc29sZS5sb2coXy5ub3coKSAtIHN0YW1wKTtcbiAqIH0sIF8ubm93KCkpO1xuICogLy8gPT4gTG9ncyB0aGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBpdCB0b29rIGZvciB0aGUgZGVmZXJyZWQgaW52b2NhdGlvbi5cbiAqL1xudmFyIG5vdyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gX3Jvb3QuRGF0ZS5ub3coKTtcbn07XG5cbnZhciBub3dfMSA9IG5vdztcblxuLyoqIFVzZWQgdG8gbWF0Y2ggYSBzaW5nbGUgd2hpdGVzcGFjZSBjaGFyYWN0ZXIuICovXG52YXIgcmVXaGl0ZXNwYWNlID0gL1xccy87XG5cbi8qKlxuICogVXNlZCBieSBgXy50cmltYCBhbmQgYF8udHJpbUVuZGAgdG8gZ2V0IHRoZSBpbmRleCBvZiB0aGUgbGFzdCBub24td2hpdGVzcGFjZVxuICogY2hhcmFjdGVyIG9mIGBzdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gaW5zcGVjdC5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBsYXN0IG5vbi13aGl0ZXNwYWNlIGNoYXJhY3Rlci5cbiAqL1xuZnVuY3Rpb24gdHJpbW1lZEVuZEluZGV4KHN0cmluZykge1xuICB2YXIgaW5kZXggPSBzdHJpbmcubGVuZ3RoO1xuXG4gIHdoaWxlIChpbmRleC0tICYmIHJlV2hpdGVzcGFjZS50ZXN0KHN0cmluZy5jaGFyQXQoaW5kZXgpKSkge31cbiAgcmV0dXJuIGluZGV4O1xufVxuXG52YXIgX3RyaW1tZWRFbmRJbmRleCA9IHRyaW1tZWRFbmRJbmRleDtcblxuLyoqIFVzZWQgdG8gbWF0Y2ggbGVhZGluZyB3aGl0ZXNwYWNlLiAqL1xudmFyIHJlVHJpbVN0YXJ0ID0gL15cXHMrLztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50cmltYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIHRyaW0uXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSB0cmltbWVkIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gYmFzZVRyaW0oc3RyaW5nKSB7XG4gIHJldHVybiBzdHJpbmdcbiAgICA/IHN0cmluZy5zbGljZSgwLCBfdHJpbW1lZEVuZEluZGV4KHN0cmluZykgKyAxKS5yZXBsYWNlKHJlVHJpbVN0YXJ0LCAnJylcbiAgICA6IHN0cmluZztcbn1cblxudmFyIF9iYXNlVHJpbSA9IGJhc2VUcmltO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBTeW1ib2wkMSA9IF9yb290LlN5bWJvbDtcblxudmFyIF9TeW1ib2wgPSBTeW1ib2wkMTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvJDUgPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSQ0ID0gb2JqZWN0UHJvdG8kNS5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG5hdGl2ZU9iamVjdFRvU3RyaW5nJDEgPSBvYmplY3RQcm90byQ1LnRvU3RyaW5nO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1Ub1N0cmluZ1RhZyQxID0gX1N5bWJvbCA/IF9TeW1ib2wudG9TdHJpbmdUYWcgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlR2V0VGFnYCB3aGljaCBpZ25vcmVzIGBTeW1ib2wudG9TdHJpbmdUYWdgIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSByYXcgYHRvU3RyaW5nVGFnYC5cbiAqL1xuZnVuY3Rpb24gZ2V0UmF3VGFnKHZhbHVlKSB7XG4gIHZhciBpc093biA9IGhhc093blByb3BlcnR5JDQuY2FsbCh2YWx1ZSwgc3ltVG9TdHJpbmdUYWckMSksXG4gICAgICB0YWcgPSB2YWx1ZVtzeW1Ub1N0cmluZ1RhZyQxXTtcblxuICB0cnkge1xuICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnJDFdID0gdW5kZWZpbmVkO1xuICAgIHZhciB1bm1hc2tlZCA9IHRydWU7XG4gIH0gY2F0Y2ggKGUpIHt9XG5cbiAgdmFyIHJlc3VsdCA9IG5hdGl2ZU9iamVjdFRvU3RyaW5nJDEuY2FsbCh2YWx1ZSk7XG4gIGlmICh1bm1hc2tlZCkge1xuICAgIGlmIChpc093bikge1xuICAgICAgdmFsdWVbc3ltVG9TdHJpbmdUYWckMV0gPSB0YWc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGV0ZSB2YWx1ZVtzeW1Ub1N0cmluZ1RhZyQxXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxudmFyIF9nZXRSYXdUYWcgPSBnZXRSYXdUYWc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byQ0ID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG5hdGl2ZU9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8kNC50b1N0cmluZztcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nIHVzaW5nIGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbn1cblxudmFyIF9vYmplY3RUb1N0cmluZyA9IG9iamVjdFRvU3RyaW5nO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgbnVsbFRhZyA9ICdbb2JqZWN0IE51bGxdJyxcbiAgICB1bmRlZmluZWRUYWcgPSAnW29iamVjdCBVbmRlZmluZWRdJztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3ltVG9TdHJpbmdUYWcgPSBfU3ltYm9sID8gX1N5bWJvbC50b1N0cmluZ1RhZyA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgZ2V0VGFnYCB3aXRob3V0IGZhbGxiYWNrcyBmb3IgYnVnZ3kgZW52aXJvbm1lbnRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGB0b1N0cmluZ1RhZ2AuXG4gKi9cbmZ1bmN0aW9uIGJhc2VHZXRUYWcodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZFRhZyA6IG51bGxUYWc7XG4gIH1cbiAgcmV0dXJuIChzeW1Ub1N0cmluZ1RhZyAmJiBzeW1Ub1N0cmluZ1RhZyBpbiBPYmplY3QodmFsdWUpKVxuICAgID8gX2dldFJhd1RhZyh2YWx1ZSlcbiAgICA6IF9vYmplY3RUb1N0cmluZyh2YWx1ZSk7XG59XG5cbnZhciBfYmFzZUdldFRhZyA9IGJhc2VHZXRUYWc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuIEEgdmFsdWUgaXMgb2JqZWN0LWxpa2UgaWYgaXQncyBub3QgYG51bGxgXG4gKiBhbmQgaGFzIGEgYHR5cGVvZmAgcmVzdWx0IG9mIFwib2JqZWN0XCIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdExpa2Uoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc09iamVjdExpa2UobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xufVxuXG52YXIgaXNPYmplY3RMaWtlXzEgPSBpc09iamVjdExpa2U7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1ib2xUYWcgPSAnW29iamVjdCBTeW1ib2xdJztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFN5bWJvbGAgcHJpbWl0aXZlIG9yIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHN5bWJvbCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzU3ltYm9sKFN5bWJvbC5pdGVyYXRvcik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1N5bWJvbCgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1N5bWJvbCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdzeW1ib2wnIHx8XG4gICAgKGlzT2JqZWN0TGlrZV8xKHZhbHVlKSAmJiBfYmFzZUdldFRhZyh2YWx1ZSkgPT0gc3ltYm9sVGFnKTtcbn1cblxudmFyIGlzU3ltYm9sXzEgPSBpc1N5bWJvbDtcblxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgTkFOID0gMCAvIDA7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBiYWQgc2lnbmVkIGhleGFkZWNpbWFsIHN0cmluZyB2YWx1ZXMuICovXG52YXIgcmVJc0JhZEhleCA9IC9eWy0rXTB4WzAtOWEtZl0rJC9pO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgYmluYXJ5IHN0cmluZyB2YWx1ZXMuICovXG52YXIgcmVJc0JpbmFyeSA9IC9eMGJbMDFdKyQvaTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG9jdGFsIHN0cmluZyB2YWx1ZXMuICovXG52YXIgcmVJc09jdGFsID0gL14wb1swLTddKyQvaTtcblxuLyoqIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHdpdGhvdXQgYSBkZXBlbmRlbmN5IG9uIGByb290YC4gKi9cbnZhciBmcmVlUGFyc2VJbnQgPSBwYXJzZUludDtcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgbnVtYmVyLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm9jZXNzLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgbnVtYmVyLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRvTnVtYmVyKDMuMik7XG4gKiAvLyA9PiAzLjJcbiAqXG4gKiBfLnRvTnVtYmVyKE51bWJlci5NSU5fVkFMVUUpO1xuICogLy8gPT4gNWUtMzI0XG4gKlxuICogXy50b051bWJlcihJbmZpbml0eSk7XG4gKiAvLyA9PiBJbmZpbml0eVxuICpcbiAqIF8udG9OdW1iZXIoJzMuMicpO1xuICogLy8gPT4gMy4yXG4gKi9cbmZ1bmN0aW9uIHRvTnVtYmVyKHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKGlzU3ltYm9sXzEodmFsdWUpKSB7XG4gICAgcmV0dXJuIE5BTjtcbiAgfVxuICBpZiAoaXNPYmplY3RfMSh2YWx1ZSkpIHtcbiAgICB2YXIgb3RoZXIgPSB0eXBlb2YgdmFsdWUudmFsdWVPZiA9PSAnZnVuY3Rpb24nID8gdmFsdWUudmFsdWVPZigpIDogdmFsdWU7XG4gICAgdmFsdWUgPSBpc09iamVjdF8xKG90aGVyKSA/IChvdGhlciArICcnKSA6IG90aGVyO1xuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IDAgPyB2YWx1ZSA6ICt2YWx1ZTtcbiAgfVxuICB2YWx1ZSA9IF9iYXNlVHJpbSh2YWx1ZSk7XG4gIHZhciBpc0JpbmFyeSA9IHJlSXNCaW5hcnkudGVzdCh2YWx1ZSk7XG4gIHJldHVybiAoaXNCaW5hcnkgfHwgcmVJc09jdGFsLnRlc3QodmFsdWUpKVxuICAgID8gZnJlZVBhcnNlSW50KHZhbHVlLnNsaWNlKDIpLCBpc0JpbmFyeSA/IDIgOiA4KVxuICAgIDogKHJlSXNCYWRIZXgudGVzdCh2YWx1ZSkgPyBOQU4gOiArdmFsdWUpO1xufVxuXG52YXIgdG9OdW1iZXJfMSA9IHRvTnVtYmVyO1xuXG4vKiogRXJyb3IgbWVzc2FnZSBjb25zdGFudHMuICovXG52YXIgRlVOQ19FUlJPUl9URVhUJDEgPSAnRXhwZWN0ZWQgYSBmdW5jdGlvbic7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVNYXggPSBNYXRoLm1heCxcbiAgICBuYXRpdmVNaW4gPSBNYXRoLm1pbjtcblxuLyoqXG4gKiBDcmVhdGVzIGEgZGVib3VuY2VkIGZ1bmN0aW9uIHRoYXQgZGVsYXlzIGludm9raW5nIGBmdW5jYCB1bnRpbCBhZnRlciBgd2FpdGBcbiAqIG1pbGxpc2Vjb25kcyBoYXZlIGVsYXBzZWQgc2luY2UgdGhlIGxhc3QgdGltZSB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uIHdhc1xuICogaW52b2tlZC4gVGhlIGRlYm91bmNlZCBmdW5jdGlvbiBjb21lcyB3aXRoIGEgYGNhbmNlbGAgbWV0aG9kIHRvIGNhbmNlbFxuICogZGVsYXllZCBgZnVuY2AgaW52b2NhdGlvbnMgYW5kIGEgYGZsdXNoYCBtZXRob2QgdG8gaW1tZWRpYXRlbHkgaW52b2tlIHRoZW0uXG4gKiBQcm92aWRlIGBvcHRpb25zYCB0byBpbmRpY2F0ZSB3aGV0aGVyIGBmdW5jYCBzaG91bGQgYmUgaW52b2tlZCBvbiB0aGVcbiAqIGxlYWRpbmcgYW5kL29yIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIGB3YWl0YCB0aW1lb3V0LiBUaGUgYGZ1bmNgIGlzIGludm9rZWRcbiAqIHdpdGggdGhlIGxhc3QgYXJndW1lbnRzIHByb3ZpZGVkIHRvIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb24uIFN1YnNlcXVlbnRcbiAqIGNhbGxzIHRvIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb24gcmV0dXJuIHRoZSByZXN1bHQgb2YgdGhlIGxhc3QgYGZ1bmNgXG4gKiBpbnZvY2F0aW9uLlxuICpcbiAqICoqTm90ZToqKiBJZiBgbGVhZGluZ2AgYW5kIGB0cmFpbGluZ2Agb3B0aW9ucyBhcmUgYHRydWVgLCBgZnVuY2AgaXNcbiAqIGludm9rZWQgb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQgb25seSBpZiB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uXG4gKiBpcyBpbnZva2VkIG1vcmUgdGhhbiBvbmNlIGR1cmluZyB0aGUgYHdhaXRgIHRpbWVvdXQuXG4gKlxuICogSWYgYHdhaXRgIGlzIGAwYCBhbmQgYGxlYWRpbmdgIGlzIGBmYWxzZWAsIGBmdW5jYCBpbnZvY2F0aW9uIGlzIGRlZmVycmVkXG4gKiB1bnRpbCB0byB0aGUgbmV4dCB0aWNrLCBzaW1pbGFyIHRvIGBzZXRUaW1lb3V0YCB3aXRoIGEgdGltZW91dCBvZiBgMGAuXG4gKlxuICogU2VlIFtEYXZpZCBDb3JiYWNobydzIGFydGljbGVdKGh0dHBzOi8vY3NzLXRyaWNrcy5jb20vZGVib3VuY2luZy10aHJvdHRsaW5nLWV4cGxhaW5lZC1leGFtcGxlcy8pXG4gKiBmb3IgZGV0YWlscyBvdmVyIHRoZSBkaWZmZXJlbmNlcyBiZXR3ZWVuIGBfLmRlYm91bmNlYCBhbmQgYF8udGhyb3R0bGVgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gZGVib3VuY2UuXG4gKiBAcGFyYW0ge251bWJlcn0gW3dhaXQ9MF0gVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gZGVsYXkuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIFRoZSBvcHRpb25zIG9iamVjdC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMubGVhZGluZz1mYWxzZV1cbiAqICBTcGVjaWZ5IGludm9raW5nIG9uIHRoZSBsZWFkaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubWF4V2FpdF1cbiAqICBUaGUgbWF4aW11bSB0aW1lIGBmdW5jYCBpcyBhbGxvd2VkIHRvIGJlIGRlbGF5ZWQgYmVmb3JlIGl0J3MgaW52b2tlZC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMudHJhaWxpbmc9dHJ1ZV1cbiAqICBTcGVjaWZ5IGludm9raW5nIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZGVib3VuY2VkIGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiAvLyBBdm9pZCBjb3N0bHkgY2FsY3VsYXRpb25zIHdoaWxlIHRoZSB3aW5kb3cgc2l6ZSBpcyBpbiBmbHV4LlxuICogalF1ZXJ5KHdpbmRvdykub24oJ3Jlc2l6ZScsIF8uZGVib3VuY2UoY2FsY3VsYXRlTGF5b3V0LCAxNTApKTtcbiAqXG4gKiAvLyBJbnZva2UgYHNlbmRNYWlsYCB3aGVuIGNsaWNrZWQsIGRlYm91bmNpbmcgc3Vic2VxdWVudCBjYWxscy5cbiAqIGpRdWVyeShlbGVtZW50KS5vbignY2xpY2snLCBfLmRlYm91bmNlKHNlbmRNYWlsLCAzMDAsIHtcbiAqICAgJ2xlYWRpbmcnOiB0cnVlLFxuICogICAndHJhaWxpbmcnOiBmYWxzZVxuICogfSkpO1xuICpcbiAqIC8vIEVuc3VyZSBgYmF0Y2hMb2dgIGlzIGludm9rZWQgb25jZSBhZnRlciAxIHNlY29uZCBvZiBkZWJvdW5jZWQgY2FsbHMuXG4gKiB2YXIgZGVib3VuY2VkID0gXy5kZWJvdW5jZShiYXRjaExvZywgMjUwLCB7ICdtYXhXYWl0JzogMTAwMCB9KTtcbiAqIHZhciBzb3VyY2UgPSBuZXcgRXZlbnRTb3VyY2UoJy9zdHJlYW0nKTtcbiAqIGpRdWVyeShzb3VyY2UpLm9uKCdtZXNzYWdlJywgZGVib3VuY2VkKTtcbiAqXG4gKiAvLyBDYW5jZWwgdGhlIHRyYWlsaW5nIGRlYm91bmNlZCBpbnZvY2F0aW9uLlxuICogalF1ZXJ5KHdpbmRvdykub24oJ3BvcHN0YXRlJywgZGVib3VuY2VkLmNhbmNlbCk7XG4gKi9cbmZ1bmN0aW9uIGRlYm91bmNlKGZ1bmMsIHdhaXQsIG9wdGlvbnMpIHtcbiAgdmFyIGxhc3RBcmdzLFxuICAgICAgbGFzdFRoaXMsXG4gICAgICBtYXhXYWl0LFxuICAgICAgcmVzdWx0LFxuICAgICAgdGltZXJJZCxcbiAgICAgIGxhc3RDYWxsVGltZSxcbiAgICAgIGxhc3RJbnZva2VUaW1lID0gMCxcbiAgICAgIGxlYWRpbmcgPSBmYWxzZSxcbiAgICAgIG1heGluZyA9IGZhbHNlLFxuICAgICAgdHJhaWxpbmcgPSB0cnVlO1xuXG4gIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQkMSk7XG4gIH1cbiAgd2FpdCA9IHRvTnVtYmVyXzEod2FpdCkgfHwgMDtcbiAgaWYgKGlzT2JqZWN0XzEob3B0aW9ucykpIHtcbiAgICBsZWFkaW5nID0gISFvcHRpb25zLmxlYWRpbmc7XG4gICAgbWF4aW5nID0gJ21heFdhaXQnIGluIG9wdGlvbnM7XG4gICAgbWF4V2FpdCA9IG1heGluZyA/IG5hdGl2ZU1heCh0b051bWJlcl8xKG9wdGlvbnMubWF4V2FpdCkgfHwgMCwgd2FpdCkgOiBtYXhXYWl0O1xuICAgIHRyYWlsaW5nID0gJ3RyYWlsaW5nJyBpbiBvcHRpb25zID8gISFvcHRpb25zLnRyYWlsaW5nIDogdHJhaWxpbmc7XG4gIH1cblxuICBmdW5jdGlvbiBpbnZva2VGdW5jKHRpbWUpIHtcbiAgICB2YXIgYXJncyA9IGxhc3RBcmdzLFxuICAgICAgICB0aGlzQXJnID0gbGFzdFRoaXM7XG5cbiAgICBsYXN0QXJncyA9IGxhc3RUaGlzID0gdW5kZWZpbmVkO1xuICAgIGxhc3RJbnZva2VUaW1lID0gdGltZTtcbiAgICByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBmdW5jdGlvbiBsZWFkaW5nRWRnZSh0aW1lKSB7XG4gICAgLy8gUmVzZXQgYW55IGBtYXhXYWl0YCB0aW1lci5cbiAgICBsYXN0SW52b2tlVGltZSA9IHRpbWU7XG4gICAgLy8gU3RhcnQgdGhlIHRpbWVyIGZvciB0aGUgdHJhaWxpbmcgZWRnZS5cbiAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHdhaXQpO1xuICAgIC8vIEludm9rZSB0aGUgbGVhZGluZyBlZGdlLlxuICAgIHJldHVybiBsZWFkaW5nID8gaW52b2tlRnVuYyh0aW1lKSA6IHJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbWFpbmluZ1dhaXQodGltZSkge1xuICAgIHZhciB0aW1lU2luY2VMYXN0Q2FsbCA9IHRpbWUgLSBsYXN0Q2FsbFRpbWUsXG4gICAgICAgIHRpbWVTaW5jZUxhc3RJbnZva2UgPSB0aW1lIC0gbGFzdEludm9rZVRpbWUsXG4gICAgICAgIHRpbWVXYWl0aW5nID0gd2FpdCAtIHRpbWVTaW5jZUxhc3RDYWxsO1xuXG4gICAgcmV0dXJuIG1heGluZ1xuICAgICAgPyBuYXRpdmVNaW4odGltZVdhaXRpbmcsIG1heFdhaXQgLSB0aW1lU2luY2VMYXN0SW52b2tlKVxuICAgICAgOiB0aW1lV2FpdGluZztcbiAgfVxuXG4gIGZ1bmN0aW9uIHNob3VsZEludm9rZSh0aW1lKSB7XG4gICAgdmFyIHRpbWVTaW5jZUxhc3RDYWxsID0gdGltZSAtIGxhc3RDYWxsVGltZSxcbiAgICAgICAgdGltZVNpbmNlTGFzdEludm9rZSA9IHRpbWUgLSBsYXN0SW52b2tlVGltZTtcblxuICAgIC8vIEVpdGhlciB0aGlzIGlzIHRoZSBmaXJzdCBjYWxsLCBhY3Rpdml0eSBoYXMgc3RvcHBlZCBhbmQgd2UncmUgYXQgdGhlXG4gICAgLy8gdHJhaWxpbmcgZWRnZSwgdGhlIHN5c3RlbSB0aW1lIGhhcyBnb25lIGJhY2t3YXJkcyBhbmQgd2UncmUgdHJlYXRpbmdcbiAgICAvLyBpdCBhcyB0aGUgdHJhaWxpbmcgZWRnZSwgb3Igd2UndmUgaGl0IHRoZSBgbWF4V2FpdGAgbGltaXQuXG4gICAgcmV0dXJuIChsYXN0Q2FsbFRpbWUgPT09IHVuZGVmaW5lZCB8fCAodGltZVNpbmNlTGFzdENhbGwgPj0gd2FpdCkgfHxcbiAgICAgICh0aW1lU2luY2VMYXN0Q2FsbCA8IDApIHx8IChtYXhpbmcgJiYgdGltZVNpbmNlTGFzdEludm9rZSA+PSBtYXhXYWl0KSk7XG4gIH1cblxuICBmdW5jdGlvbiB0aW1lckV4cGlyZWQoKSB7XG4gICAgdmFyIHRpbWUgPSBub3dfMSgpO1xuICAgIGlmIChzaG91bGRJbnZva2UodGltZSkpIHtcbiAgICAgIHJldHVybiB0cmFpbGluZ0VkZ2UodGltZSk7XG4gICAgfVxuICAgIC8vIFJlc3RhcnQgdGhlIHRpbWVyLlxuICAgIHRpbWVySWQgPSBzZXRUaW1lb3V0KHRpbWVyRXhwaXJlZCwgcmVtYWluaW5nV2FpdCh0aW1lKSk7XG4gIH1cblxuICBmdW5jdGlvbiB0cmFpbGluZ0VkZ2UodGltZSkge1xuICAgIHRpbWVySWQgPSB1bmRlZmluZWQ7XG5cbiAgICAvLyBPbmx5IGludm9rZSBpZiB3ZSBoYXZlIGBsYXN0QXJnc2Agd2hpY2ggbWVhbnMgYGZ1bmNgIGhhcyBiZWVuXG4gICAgLy8gZGVib3VuY2VkIGF0IGxlYXN0IG9uY2UuXG4gICAgaWYgKHRyYWlsaW5nICYmIGxhc3RBcmdzKSB7XG4gICAgICByZXR1cm4gaW52b2tlRnVuYyh0aW1lKTtcbiAgICB9XG4gICAgbGFzdEFyZ3MgPSBsYXN0VGhpcyA9IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgZnVuY3Rpb24gY2FuY2VsKCkge1xuICAgIGlmICh0aW1lcklkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lcklkKTtcbiAgICB9XG4gICAgbGFzdEludm9rZVRpbWUgPSAwO1xuICAgIGxhc3RBcmdzID0gbGFzdENhbGxUaW1lID0gbGFzdFRoaXMgPSB0aW1lcklkID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgZnVuY3Rpb24gZmx1c2goKSB7XG4gICAgcmV0dXJuIHRpbWVySWQgPT09IHVuZGVmaW5lZCA/IHJlc3VsdCA6IHRyYWlsaW5nRWRnZShub3dfMSgpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlYm91bmNlZCgpIHtcbiAgICB2YXIgdGltZSA9IG5vd18xKCksXG4gICAgICAgIGlzSW52b2tpbmcgPSBzaG91bGRJbnZva2UodGltZSk7XG5cbiAgICBsYXN0QXJncyA9IGFyZ3VtZW50cztcbiAgICBsYXN0VGhpcyA9IHRoaXM7XG4gICAgbGFzdENhbGxUaW1lID0gdGltZTtcblxuICAgIGlmIChpc0ludm9raW5nKSB7XG4gICAgICBpZiAodGltZXJJZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBsZWFkaW5nRWRnZShsYXN0Q2FsbFRpbWUpO1xuICAgICAgfVxuICAgICAgaWYgKG1heGluZykge1xuICAgICAgICAvLyBIYW5kbGUgaW52b2NhdGlvbnMgaW4gYSB0aWdodCBsb29wLlxuICAgICAgICBjbGVhclRpbWVvdXQodGltZXJJZCk7XG4gICAgICAgIHRpbWVySWQgPSBzZXRUaW1lb3V0KHRpbWVyRXhwaXJlZCwgd2FpdCk7XG4gICAgICAgIHJldHVybiBpbnZva2VGdW5jKGxhc3RDYWxsVGltZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aW1lcklkID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRpbWVySWQgPSBzZXRUaW1lb3V0KHRpbWVyRXhwaXJlZCwgd2FpdCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgZGVib3VuY2VkLmNhbmNlbCA9IGNhbmNlbDtcbiAgZGVib3VuY2VkLmZsdXNoID0gZmx1c2g7XG4gIHJldHVybiBkZWJvdW5jZWQ7XG59XG5cbnZhciBkZWJvdW5jZV8xID0gZGVib3VuY2U7XG5cbnZhciBwZXJmb3JtYW5jZSA9IF93aW5kb3cgPyBfd2luZG93LnBlcmZvcm1hbmNlIDogbnVsbDtcbnZhciBwbm93ID0gcGVyZm9ybWFuY2UgJiYgcGVyZm9ybWFuY2Uubm93ID8gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gcGVyZm9ybWFuY2Uubm93KCk7XG59IDogZnVuY3Rpb24gKCkge1xuICByZXR1cm4gRGF0ZS5ub3coKTtcbn07XG52YXIgcmFmID0gZnVuY3Rpb24gKCkge1xuICBpZiAoX3dpbmRvdykge1xuICAgIGlmIChfd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChmbikge1xuICAgICAgICBfd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShmbik7XG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAoX3dpbmRvdy5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWUpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgX3dpbmRvdy5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZm4pO1xuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKF93aW5kb3cud2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIF93aW5kb3cud2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZuKTtcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmIChfd2luZG93Lm1zUmVxdWVzdEFuaW1hdGlvbkZyYW1lKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIF93aW5kb3cubXNSZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZm4pO1xuICAgICAgfTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uIChmbikge1xuICAgIGlmIChmbikge1xuICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZuKHBub3coKSk7XG4gICAgICB9LCAxMDAwIC8gNjApO1xuICAgIH1cbiAgfTtcbn0oKTtcbnZhciByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSBmdW5jdGlvbiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZm4pIHtcbiAgcmV0dXJuIHJhZihmbik7XG59O1xudmFyIHBlcmZvcm1hbmNlTm93ID0gcG5vdztcblxudmFyIERFRkFVTFRfSEFTSF9TRUVEID0gOTI2MTtcbnZhciBLID0gNjU1OTk7IC8vIDM3IGFsc28gd29ya3MgcHJldHR5IHdlbGxcbnZhciBERUZBVUxUX0hBU0hfU0VFRF9BTFQgPSA1MzgxO1xudmFyIGhhc2hJdGVyYWJsZUludHMgPSBmdW5jdGlvbiBoYXNoSXRlcmFibGVJbnRzKGl0ZXJhdG9yKSB7XG4gIHZhciBzZWVkID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBERUZBVUxUX0hBU0hfU0VFRDtcbiAgLy8gc2RibS9zdHJpbmctaGFzaFxuICB2YXIgaGFzaCA9IHNlZWQ7XG4gIHZhciBlbnRyeTtcbiAgZm9yICg7Oykge1xuICAgIGVudHJ5ID0gaXRlcmF0b3IubmV4dCgpO1xuICAgIGlmIChlbnRyeS5kb25lKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgaGFzaCA9IGhhc2ggKiBLICsgZW50cnkudmFsdWUgfCAwO1xuICB9XG4gIHJldHVybiBoYXNoO1xufTtcbnZhciBoYXNoSW50ID0gZnVuY3Rpb24gaGFzaEludChudW0pIHtcbiAgdmFyIHNlZWQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IERFRkFVTFRfSEFTSF9TRUVEO1xuICAvLyBzZGJtL3N0cmluZy1oYXNoXG4gIHJldHVybiBzZWVkICogSyArIG51bSB8IDA7XG59O1xudmFyIGhhc2hJbnRBbHQgPSBmdW5jdGlvbiBoYXNoSW50QWx0KG51bSkge1xuICB2YXIgc2VlZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogREVGQVVMVF9IQVNIX1NFRURfQUxUO1xuICAvLyBkamIyL3N0cmluZy1oYXNoXG4gIHJldHVybiAoc2VlZCA8PCA1KSArIHNlZWQgKyBudW0gfCAwO1xufTtcbnZhciBjb21iaW5lSGFzaGVzID0gZnVuY3Rpb24gY29tYmluZUhhc2hlcyhoYXNoMSwgaGFzaDIpIHtcbiAgcmV0dXJuIGhhc2gxICogMHgyMDAwMDAgKyBoYXNoMjtcbn07XG52YXIgY29tYmluZUhhc2hlc0FycmF5ID0gZnVuY3Rpb24gY29tYmluZUhhc2hlc0FycmF5KGhhc2hlcykge1xuICByZXR1cm4gaGFzaGVzWzBdICogMHgyMDAwMDAgKyBoYXNoZXNbMV07XG59O1xudmFyIGhhc2hBcnJheXMgPSBmdW5jdGlvbiBoYXNoQXJyYXlzKGhhc2hlczEsIGhhc2hlczIpIHtcbiAgcmV0dXJuIFtoYXNoSW50KGhhc2hlczFbMF0sIGhhc2hlczJbMF0pLCBoYXNoSW50QWx0KGhhc2hlczFbMV0sIGhhc2hlczJbMV0pXTtcbn07XG52YXIgaGFzaEludHNBcnJheSA9IGZ1bmN0aW9uIGhhc2hJbnRzQXJyYXkoaW50cywgc2VlZCkge1xuICB2YXIgZW50cnkgPSB7XG4gICAgdmFsdWU6IDAsXG4gICAgZG9uZTogZmFsc2VcbiAgfTtcbiAgdmFyIGkgPSAwO1xuICB2YXIgbGVuZ3RoID0gaW50cy5sZW5ndGg7XG4gIHZhciBpdGVyYXRvciA9IHtcbiAgICBuZXh0OiBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgaWYgKGkgPCBsZW5ndGgpIHtcbiAgICAgICAgZW50cnkudmFsdWUgPSBpbnRzW2krK107XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbnRyeS5kb25lID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBlbnRyeTtcbiAgICB9XG4gIH07XG4gIHJldHVybiBoYXNoSXRlcmFibGVJbnRzKGl0ZXJhdG9yLCBzZWVkKTtcbn07XG52YXIgaGFzaFN0cmluZyA9IGZ1bmN0aW9uIGhhc2hTdHJpbmcoc3RyLCBzZWVkKSB7XG4gIHZhciBlbnRyeSA9IHtcbiAgICB2YWx1ZTogMCxcbiAgICBkb25lOiBmYWxzZVxuICB9O1xuICB2YXIgaSA9IDA7XG4gIHZhciBsZW5ndGggPSBzdHIubGVuZ3RoO1xuICB2YXIgaXRlcmF0b3IgPSB7XG4gICAgbmV4dDogZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgIGlmIChpIDwgbGVuZ3RoKSB7XG4gICAgICAgIGVudHJ5LnZhbHVlID0gc3RyLmNoYXJDb2RlQXQoaSsrKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVudHJ5LmRvbmUgPSB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGVudHJ5O1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIGhhc2hJdGVyYWJsZUludHMoaXRlcmF0b3IsIHNlZWQpO1xufTtcbnZhciBoYXNoU3RyaW5ncyA9IGZ1bmN0aW9uIGhhc2hTdHJpbmdzKCkge1xuICByZXR1cm4gaGFzaFN0cmluZ3NBcnJheShhcmd1bWVudHMpO1xufTtcbnZhciBoYXNoU3RyaW5nc0FycmF5ID0gZnVuY3Rpb24gaGFzaFN0cmluZ3NBcnJheShzdHJzKSB7XG4gIHZhciBoYXNoO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0cnMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc3RyID0gc3Ryc1tpXTtcbiAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgaGFzaCA9IGhhc2hTdHJpbmcoc3RyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaGFzaCA9IGhhc2hTdHJpbmcoc3RyLCBoYXNoKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGhhc2g7XG59O1xuXG4vKmdsb2JhbCBjb25zb2xlICovXG52YXIgd2FybmluZ3NFbmFibGVkID0gdHJ1ZTtcbnZhciB3YXJuU3VwcG9ydGVkID0gY29uc29sZS53YXJuICE9IG51bGw7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uc29sZVxudmFyIHRyYWNlU3VwcG9ydGVkID0gY29uc29sZS50cmFjZSAhPSBudWxsOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnNvbGVcblxudmFyIE1BWF9JTlQkMSA9IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSIHx8IDkwMDcxOTkyNTQ3NDA5OTE7XG52YXIgdHJ1ZWlmeSA9IGZ1bmN0aW9uIHRydWVpZnkoKSB7XG4gIHJldHVybiB0cnVlO1xufTtcbnZhciBmYWxzaWZ5ID0gZnVuY3Rpb24gZmFsc2lmeSgpIHtcbiAgcmV0dXJuIGZhbHNlO1xufTtcbnZhciB6ZXJvaWZ5ID0gZnVuY3Rpb24gemVyb2lmeSgpIHtcbiAgcmV0dXJuIDA7XG59O1xudmFyIG5vb3AkMSA9IGZ1bmN0aW9uIG5vb3AoKSB7fTtcbnZhciBlcnJvciA9IGZ1bmN0aW9uIGVycm9yKG1zZykge1xuICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbn07XG52YXIgd2FybmluZ3MgPSBmdW5jdGlvbiB3YXJuaW5ncyhlbmFibGVkKSB7XG4gIGlmIChlbmFibGVkICE9PSB1bmRlZmluZWQpIHtcbiAgICB3YXJuaW5nc0VuYWJsZWQgPSAhIWVuYWJsZWQ7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHdhcm5pbmdzRW5hYmxlZDtcbiAgfVxufTtcbnZhciB3YXJuID0gZnVuY3Rpb24gd2Fybihtc2cpIHtcbiAgLyogZXNsaW50LWRpc2FibGUgbm8tY29uc29sZSAqL1xuICBpZiAoIXdhcm5pbmdzKCkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHdhcm5TdXBwb3J0ZWQpIHtcbiAgICBjb25zb2xlLndhcm4obXNnKTtcbiAgfSBlbHNlIHtcbiAgICBjb25zb2xlLmxvZyhtc2cpO1xuICAgIGlmICh0cmFjZVN1cHBvcnRlZCkge1xuICAgICAgY29uc29sZS50cmFjZSgpO1xuICAgIH1cbiAgfVxufTsgLyogZXNsaW50LWVuYWJsZSAqL1xuXG52YXIgY2xvbmUgPSBmdW5jdGlvbiBjbG9uZShvYmopIHtcbiAgcmV0dXJuIGV4dGVuZCh7fSwgb2JqKTtcbn07XG5cbi8vIGdldHMgYSBzaGFsbG93IGNvcHkgb2YgdGhlIGFyZ3VtZW50XG52YXIgY29weSA9IGZ1bmN0aW9uIGNvcHkob2JqKSB7XG4gIGlmIChvYmogPT0gbnVsbCkge1xuICAgIHJldHVybiBvYmo7XG4gIH1cbiAgaWYgKGFycmF5KG9iaikpIHtcbiAgICByZXR1cm4gb2JqLnNsaWNlKCk7XG4gIH0gZWxzZSBpZiAocGxhaW5PYmplY3Qob2JqKSkge1xuICAgIHJldHVybiBjbG9uZShvYmopO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBvYmo7XG4gIH1cbn07XG52YXIgY29weUFycmF5JDEgPSBmdW5jdGlvbiBjb3B5QXJyYXkoYXJyKSB7XG4gIHJldHVybiBhcnIuc2xpY2UoKTtcbn07XG52YXIgdXVpZCA9IGZ1bmN0aW9uIHV1aWQoYSwgYiAvKiBwbGFjZWhvbGRlcnMgKi8pIHtcbiAgZm9yIChcbiAgLy8gbG9vcCA6KVxuICBiID0gYSA9ICcnO1xuICAvLyBiIC0gcmVzdWx0ICwgYSAtIG51bWVyaWMgbGV0aWFibGVcbiAgYSsrIDwgMzY7XG4gIC8vXG4gIGIgKz0gYSAqIDUxICYgNTIgLy8gaWYgXCJhXCIgaXMgbm90IDkgb3IgMTQgb3IgMTkgb3IgMjRcbiAgP1xuICAvLyAgcmV0dXJuIGEgcmFuZG9tIG51bWJlciBvciA0XG4gIChhIF4gMTUgLy8gaWYgXCJhXCIgaXMgbm90IDE1XG4gID9cbiAgLy8gZ2VuZXJhdGUgYSByYW5kb20gbnVtYmVyIGZyb20gMCB0byAxNVxuICA4IF4gTWF0aC5yYW5kb20oKSAqIChhIF4gMjAgPyAxNiA6IDQpIC8vIHVubGVzcyBcImFcIiBpcyAyMCwgaW4gd2hpY2ggY2FzZSBhIHJhbmRvbSBudW1iZXIgZnJvbSA4IHRvIDExXG4gIDogNCAvLyAgb3RoZXJ3aXNlIDRcbiAgKS50b1N0cmluZygxNikgOiAnLScgLy8gIGluIG90aGVyIGNhc2VzIChpZiBcImFcIiBpcyA5LDE0LDE5LDI0KSBpbnNlcnQgXCItXCJcbiAgKSB7XG4gIH1cbiAgcmV0dXJuIGI7XG59O1xudmFyIF9zdGF0aWNFbXB0eU9iamVjdCA9IHt9O1xudmFyIHN0YXRpY0VtcHR5T2JqZWN0ID0gZnVuY3Rpb24gc3RhdGljRW1wdHlPYmplY3QoKSB7XG4gIHJldHVybiBfc3RhdGljRW1wdHlPYmplY3Q7XG59O1xudmFyIGRlZmF1bHRzJGcgPSBmdW5jdGlvbiBkZWZhdWx0cyhfZGVmYXVsdHMpIHtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhfZGVmYXVsdHMpO1xuICByZXR1cm4gZnVuY3Rpb24gKG9wdHMpIHtcbiAgICB2YXIgZmlsbGVkT3B0cyA9IHt9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICB2YXIgb3B0VmFsID0gb3B0cyA9PSBudWxsID8gdW5kZWZpbmVkIDogb3B0c1trZXldO1xuICAgICAgZmlsbGVkT3B0c1trZXldID0gb3B0VmFsID09PSB1bmRlZmluZWQgPyBfZGVmYXVsdHNba2V5XSA6IG9wdFZhbDtcbiAgICB9XG4gICAgcmV0dXJuIGZpbGxlZE9wdHM7XG4gIH07XG59O1xudmFyIHJlbW92ZUZyb21BcnJheSA9IGZ1bmN0aW9uIHJlbW92ZUZyb21BcnJheShhcnIsIGVsZSwgb25lQ29weSkge1xuICBmb3IgKHZhciBpID0gYXJyLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgaWYgKGFycltpXSA9PT0gZWxlKSB7XG4gICAgICBhcnIuc3BsaWNlKGksIDEpO1xuICAgICAgaWYgKG9uZUNvcHkpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xudmFyIGNsZWFyQXJyYXkgPSBmdW5jdGlvbiBjbGVhckFycmF5KGFycikge1xuICBhcnIuc3BsaWNlKDAsIGFyci5sZW5ndGgpO1xufTtcbnZhciBwdXNoID0gZnVuY3Rpb24gcHVzaChhcnIsIG90aGVyQXJyKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgb3RoZXJBcnIubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZWwgPSBvdGhlckFycltpXTtcbiAgICBhcnIucHVzaChlbCk7XG4gIH1cbn07XG52YXIgZ2V0UHJlZml4ZWRQcm9wZXJ0eSA9IGZ1bmN0aW9uIGdldFByZWZpeGVkUHJvcGVydHkob2JqLCBwcm9wTmFtZSwgcHJlZml4KSB7XG4gIGlmIChwcmVmaXgpIHtcbiAgICBwcm9wTmFtZSA9IHByZXBlbmRDYW1lbChwcmVmaXgsIHByb3BOYW1lKTsgLy8gZS5nLiAobGFiZWxXaWR0aCwgc291cmNlKSA9PiBzb3VyY2VMYWJlbFdpZHRoXG4gIH1cblxuICByZXR1cm4gb2JqW3Byb3BOYW1lXTtcbn07XG52YXIgc2V0UHJlZml4ZWRQcm9wZXJ0eSA9IGZ1bmN0aW9uIHNldFByZWZpeGVkUHJvcGVydHkob2JqLCBwcm9wTmFtZSwgcHJlZml4LCB2YWx1ZSkge1xuICBpZiAocHJlZml4KSB7XG4gICAgcHJvcE5hbWUgPSBwcmVwZW5kQ2FtZWwocHJlZml4LCBwcm9wTmFtZSk7IC8vIGUuZy4gKGxhYmVsV2lkdGgsIHNvdXJjZSkgPT4gc291cmNlTGFiZWxXaWR0aFxuICB9XG5cbiAgb2JqW3Byb3BOYW1lXSA9IHZhbHVlO1xufTtcblxuLyogZ2xvYmFsIE1hcCAqL1xudmFyIE9iamVjdE1hcCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIE9iamVjdE1hcCgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgT2JqZWN0TWFwKTtcbiAgICB0aGlzLl9vYmogPSB7fTtcbiAgfVxuICBfY3JlYXRlQ2xhc3MoT2JqZWN0TWFwLCBbe1xuICAgIGtleTogXCJzZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0KGtleSwgdmFsKSB7XG4gICAgICB0aGlzLl9vYmpba2V5XSA9IHZhbDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkZWxldGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2RlbGV0ZShrZXkpIHtcbiAgICAgIHRoaXMuX29ialtrZXldID0gdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNsZWFyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgICAgdGhpcy5fb2JqID0ge307XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImhhc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYXMoa2V5KSB7XG4gICAgICByZXR1cm4gdGhpcy5fb2JqW2tleV0gIT09IHVuZGVmaW5lZDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldChrZXkpIHtcbiAgICAgIHJldHVybiB0aGlzLl9vYmpba2V5XTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIE9iamVjdE1hcDtcbn0oKTtcbnZhciBNYXAkMiA9IHR5cGVvZiBNYXAgIT09ICd1bmRlZmluZWQnID8gTWFwIDogT2JqZWN0TWFwO1xuXG4vKiBnbG9iYWwgU2V0ICovXG5cbnZhciB1bmRlZiA9IFwidW5kZWZpbmVkXCIgO1xudmFyIE9iamVjdFNldCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIE9iamVjdFNldChhcnJheU9yT2JqZWN0U2V0KSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE9iamVjdFNldCk7XG4gICAgdGhpcy5fb2JqID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLnNpemUgPSAwO1xuICAgIGlmIChhcnJheU9yT2JqZWN0U2V0ICE9IG51bGwpIHtcbiAgICAgIHZhciBhcnI7XG4gICAgICBpZiAoYXJyYXlPck9iamVjdFNldC5pbnN0YW5jZVN0cmluZyAhPSBudWxsICYmIGFycmF5T3JPYmplY3RTZXQuaW5zdGFuY2VTdHJpbmcoKSA9PT0gdGhpcy5pbnN0YW5jZVN0cmluZygpKSB7XG4gICAgICAgIGFyciA9IGFycmF5T3JPYmplY3RTZXQudG9BcnJheSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXJyID0gYXJyYXlPck9iamVjdFNldDtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMuYWRkKGFycltpXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIF9jcmVhdGVDbGFzcyhPYmplY3RTZXQsIFt7XG4gICAga2V5OiBcImluc3RhbmNlU3RyaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluc3RhbmNlU3RyaW5nKCkge1xuICAgICAgcmV0dXJuICdzZXQnO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhZGRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkKHZhbCkge1xuICAgICAgdmFyIG8gPSB0aGlzLl9vYmo7XG4gICAgICBpZiAob1t2YWxdICE9PSAxKSB7XG4gICAgICAgIG9bdmFsXSA9IDE7XG4gICAgICAgIHRoaXMuc2l6ZSsrO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkZWxldGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2RlbGV0ZSh2YWwpIHtcbiAgICAgIHZhciBvID0gdGhpcy5fb2JqO1xuICAgICAgaWYgKG9bdmFsXSA9PT0gMSkge1xuICAgICAgICBvW3ZhbF0gPSAwO1xuICAgICAgICB0aGlzLnNpemUtLTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2xlYXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgICB0aGlzLl9vYmogPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJoYXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFzKHZhbCkge1xuICAgICAgcmV0dXJuIHRoaXMuX29ialt2YWxdID09PSAxO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0b0FycmF5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvQXJyYXkoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuX29iaikuZmlsdGVyKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzLmhhcyhrZXkpO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZvckVhY2hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZm9yRWFjaChjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgcmV0dXJuIHRoaXMudG9BcnJheSgpLmZvckVhY2goY2FsbGJhY2ssIHRoaXNBcmcpO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gT2JqZWN0U2V0O1xufSgpO1xudmFyIFNldCQxID0gKHR5cGVvZiBTZXQgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVvZihTZXQpKSAhPT0gdW5kZWYgPyBTZXQgOiBPYmplY3RTZXQ7XG5cbi8vIHJlcHJlc2VudHMgYSBub2RlIG9yIGFuIGVkZ2VcbnZhciBFbGVtZW50ID0gZnVuY3Rpb24gRWxlbWVudChjeSwgcGFyYW1zKSB7XG4gIHZhciByZXN0b3JlID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB0cnVlO1xuICBpZiAoY3kgPT09IHVuZGVmaW5lZCB8fCBwYXJhbXMgPT09IHVuZGVmaW5lZCB8fCAhY29yZShjeSkpIHtcbiAgICBlcnJvcignQW4gZWxlbWVudCBtdXN0IGhhdmUgYSBjb3JlIHJlZmVyZW5jZSBhbmQgcGFyYW1ldGVycyBzZXQnKTtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIGdyb3VwID0gcGFyYW1zLmdyb3VwO1xuXG4gIC8vIHRyeSB0byBhdXRvbWF0aWNhbGx5IGluZmVyIHRoZSBncm91cCBpZiB1bnNwZWNpZmllZFxuICBpZiAoZ3JvdXAgPT0gbnVsbCkge1xuICAgIGlmIChwYXJhbXMuZGF0YSAmJiBwYXJhbXMuZGF0YS5zb3VyY2UgIT0gbnVsbCAmJiBwYXJhbXMuZGF0YS50YXJnZXQgIT0gbnVsbCkge1xuICAgICAgZ3JvdXAgPSAnZWRnZXMnO1xuICAgIH0gZWxzZSB7XG4gICAgICBncm91cCA9ICdub2Rlcyc7XG4gICAgfVxuICB9XG5cbiAgLy8gdmFsaWRhdGUgZ3JvdXBcbiAgaWYgKGdyb3VwICE9PSAnbm9kZXMnICYmIGdyb3VwICE9PSAnZWRnZXMnKSB7XG4gICAgZXJyb3IoJ0FuIGVsZW1lbnQgbXVzdCBiZSBvZiB0eXBlIGBub2Rlc2Agb3IgYGVkZ2VzYDsgeW91IHNwZWNpZmllZCBgJyArIGdyb3VwICsgJ2AnKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBtYWtlIHRoZSBlbGVtZW50IGFycmF5LWxpa2UsIGp1c3QgbGlrZSBhIGNvbGxlY3Rpb25cbiAgdGhpcy5sZW5ndGggPSAxO1xuICB0aGlzWzBdID0gdGhpcztcblxuICAvLyBOT1RFOiB3aGVuIHNvbWV0aGluZyBpcyBhZGRlZCBoZXJlLCBhZGQgYWxzbyB0byBlbGUuanNvbigpXG4gIHZhciBfcCA9IHRoaXMuX3ByaXZhdGUgPSB7XG4gICAgY3k6IGN5LFxuICAgIHNpbmdsZTogdHJ1ZSxcbiAgICAvLyBpbmRpY2F0ZXMgdGhpcyBpcyBhbiBlbGVtZW50XG4gICAgZGF0YTogcGFyYW1zLmRhdGEgfHwge30sXG4gICAgLy8gZGF0YSBvYmplY3RcbiAgICBwb3NpdGlvbjogcGFyYW1zLnBvc2l0aW9uIHx8IHtcbiAgICAgIHg6IDAsXG4gICAgICB5OiAwXG4gICAgfSxcbiAgICAvLyAoeCwgeSkgcG9zaXRpb24gcGFpclxuICAgIGF1dG9XaWR0aDogdW5kZWZpbmVkLFxuICAgIC8vIHdpZHRoIGFuZCBoZWlnaHQgb2Ygbm9kZXMgY2FsY3VsYXRlZCBieSB0aGUgcmVuZGVyZXIgd2hlbiBzZXQgdG8gc3BlY2lhbCAnYXV0bycgdmFsdWVcbiAgICBhdXRvSGVpZ2h0OiB1bmRlZmluZWQsXG4gICAgYXV0b1BhZGRpbmc6IHVuZGVmaW5lZCxcbiAgICBjb21wb3VuZEJvdW5kc0NsZWFuOiBmYWxzZSxcbiAgICAvLyB3aGV0aGVyIHRoZSBjb21wb3VuZCBkaW1lbnNpb25zIG5lZWQgdG8gYmUgcmVjYWxjdWxhdGVkIHRoZSBuZXh0IHRpbWUgZGltZW5zaW9ucyBhcmUgcmVhZFxuICAgIGxpc3RlbmVyczogW10sXG4gICAgLy8gYXJyYXkgb2YgYm91bmQgbGlzdGVuZXJzXG4gICAgZ3JvdXA6IGdyb3VwLFxuICAgIC8vIHN0cmluZzsgJ25vZGVzJyBvciAnZWRnZXMnXG4gICAgc3R5bGU6IHt9LFxuICAgIC8vIHByb3BlcnRpZXMgYXMgc2V0IGJ5IHRoZSBzdHlsZVxuICAgIHJzdHlsZToge30sXG4gICAgLy8gcHJvcGVydGllcyBmb3Igc3R5bGUgc2VudCBmcm9tIHRoZSByZW5kZXJlciB0byB0aGUgY29yZVxuICAgIHN0eWxlQ3h0czogW10sXG4gICAgLy8gYXBwbGllZCBzdHlsZSBjb250ZXh0cyBmcm9tIHRoZSBzdHlsZXJcbiAgICBzdHlsZUtleXM6IHt9LFxuICAgIC8vIHBlci1ncm91cCBrZXlzIG9mIHN0eWxlIHByb3BlcnR5IHZhbHVlc1xuICAgIHJlbW92ZWQ6IHRydWUsXG4gICAgLy8gd2hldGhlciBpdCdzIGluc2lkZSB0aGUgdmlzOyB0cnVlIGlmIHJlbW92ZWQgKHNldCB0cnVlIGhlcmUgc2luY2Ugd2UgY2FsbCByZXN0b3JlKVxuICAgIHNlbGVjdGVkOiBwYXJhbXMuc2VsZWN0ZWQgPyB0cnVlIDogZmFsc2UsXG4gICAgLy8gd2hldGhlciBpdCdzIHNlbGVjdGVkXG4gICAgc2VsZWN0YWJsZTogcGFyYW1zLnNlbGVjdGFibGUgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBwYXJhbXMuc2VsZWN0YWJsZSA/IHRydWUgOiBmYWxzZSxcbiAgICAvLyB3aGV0aGVyIGl0J3Mgc2VsZWN0YWJsZVxuICAgIGxvY2tlZDogcGFyYW1zLmxvY2tlZCA/IHRydWUgOiBmYWxzZSxcbiAgICAvLyB3aGV0aGVyIHRoZSBlbGVtZW50IGlzIGxvY2tlZCAoY2Fubm90IGJlIG1vdmVkKVxuICAgIGdyYWJiZWQ6IGZhbHNlLFxuICAgIC8vIHdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgZ3JhYmJlZCBieSB0aGUgbW91c2U7IHJlbmRlcmVyIHNldHMgdGhpcyBwcml2YXRlbHlcbiAgICBncmFiYmFibGU6IHBhcmFtcy5ncmFiYmFibGUgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBwYXJhbXMuZ3JhYmJhYmxlID8gdHJ1ZSA6IGZhbHNlLFxuICAgIC8vIHdoZXRoZXIgdGhlIGVsZW1lbnQgY2FuIGJlIGdyYWJiZWRcbiAgICBwYW5uYWJsZTogcGFyYW1zLnBhbm5hYmxlID09PSB1bmRlZmluZWQgPyBncm91cCA9PT0gJ2VkZ2VzJyA/IHRydWUgOiBmYWxzZSA6IHBhcmFtcy5wYW5uYWJsZSA/IHRydWUgOiBmYWxzZSxcbiAgICAvLyB3aGV0aGVyIHRoZSBlbGVtZW50IGhhcyBwYXNzdGhyb3VnaCBwYW5uaW5nIGVuYWJsZWRcbiAgICBhY3RpdmU6IGZhbHNlLFxuICAgIC8vIHdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgYWN0aXZlIGZyb20gdXNlciBpbnRlcmFjdGlvblxuICAgIGNsYXNzZXM6IG5ldyBTZXQkMSgpLFxuICAgIC8vIG1hcCAoIGNsYXNzTmFtZSA9PiB0cnVlIClcbiAgICBhbmltYXRpb246IHtcbiAgICAgIC8vIG9iamVjdCBmb3IgY3VycmVudGx5LXJ1bm5pbmcgYW5pbWF0aW9uc1xuICAgICAgY3VycmVudDogW10sXG4gICAgICBxdWV1ZTogW11cbiAgICB9LFxuICAgIHJzY3JhdGNoOiB7fSxcbiAgICAvLyBvYmplY3QgaW4gd2hpY2ggdGhlIHJlbmRlcmVyIGNhbiBzdG9yZSBpbmZvcm1hdGlvblxuICAgIHNjcmF0Y2g6IHBhcmFtcy5zY3JhdGNoIHx8IHt9LFxuICAgIC8vIHNjcmF0Y2ggb2JqZWN0c1xuICAgIGVkZ2VzOiBbXSxcbiAgICAvLyBhcnJheSBvZiBjb25uZWN0ZWQgZWRnZXNcbiAgICBjaGlsZHJlbjogW10sXG4gICAgLy8gYXJyYXkgb2YgY2hpbGRyZW5cbiAgICBwYXJlbnQ6IHBhcmFtcy5wYXJlbnQgJiYgcGFyYW1zLnBhcmVudC5pc05vZGUoKSA/IHBhcmFtcy5wYXJlbnQgOiBudWxsLFxuICAgIC8vIHBhcmVudCByZWZcbiAgICB0cmF2ZXJzYWxDYWNoZToge30sXG4gICAgLy8gY2FjaGUgb2Ygb3V0cHV0IG9mIHRyYXZlcnNhbCBmdW5jdGlvbnNcbiAgICBiYWNrZ3JvdW5kaW5nOiBmYWxzZSxcbiAgICAvLyB3aGV0aGVyIGJhY2tncm91bmQgaW1hZ2VzIGFyZSBsb2FkaW5nXG4gICAgYmJDYWNoZTogbnVsbCxcbiAgICAvLyBjYWNoZSBvZiB0aGUgY3VycmVudCBib3VuZGluZyBib3hcbiAgICBiYkNhY2hlU2hpZnQ6IHtcbiAgICAgIHg6IDAsXG4gICAgICB5OiAwXG4gICAgfSxcbiAgICAvLyBzaGlmdCBhcHBsaWVkIHRvIGNhY2hlZCBiYiB0byBiZSBhcHBsaWVkIG9uIG5leHQgZ2V0XG4gICAgYm9keUJvdW5kczogbnVsbCxcbiAgICAvLyBib3VuZHMgY2FjaGUgb2YgZWxlbWVudCBib2R5LCB3L28gb3ZlcmxheVxuICAgIG92ZXJsYXlCb3VuZHM6IG51bGwsXG4gICAgLy8gYm91bmRzIGNhY2hlIG9mIGVsZW1lbnQgYm9keSwgaW5jbHVkaW5nIG92ZXJsYXlcbiAgICBsYWJlbEJvdW5kczoge1xuICAgICAgLy8gYm91bmRzIGNhY2hlIG9mIGxhYmVsc1xuICAgICAgYWxsOiBudWxsLFxuICAgICAgc291cmNlOiBudWxsLFxuICAgICAgdGFyZ2V0OiBudWxsLFxuICAgICAgbWFpbjogbnVsbFxuICAgIH0sXG4gICAgYXJyb3dCb3VuZHM6IHtcbiAgICAgIC8vIGJvdW5kcyBjYWNoZSBvZiBlZGdlIGFycm93c1xuICAgICAgc291cmNlOiBudWxsLFxuICAgICAgdGFyZ2V0OiBudWxsLFxuICAgICAgJ21pZC1zb3VyY2UnOiBudWxsLFxuICAgICAgJ21pZC10YXJnZXQnOiBudWxsXG4gICAgfVxuICB9O1xuICBpZiAoX3AucG9zaXRpb24ueCA9PSBudWxsKSB7XG4gICAgX3AucG9zaXRpb24ueCA9IDA7XG4gIH1cbiAgaWYgKF9wLnBvc2l0aW9uLnkgPT0gbnVsbCkge1xuICAgIF9wLnBvc2l0aW9uLnkgPSAwO1xuICB9XG5cbiAgLy8gcmVuZGVyZWRQb3NpdGlvbiBvdmVycmlkZXMgaWYgc3BlY2lmaWVkXG4gIGlmIChwYXJhbXMucmVuZGVyZWRQb3NpdGlvbikge1xuICAgIHZhciBycG9zID0gcGFyYW1zLnJlbmRlcmVkUG9zaXRpb247XG4gICAgdmFyIHBhbiA9IGN5LnBhbigpO1xuICAgIHZhciB6b29tID0gY3kuem9vbSgpO1xuICAgIF9wLnBvc2l0aW9uID0ge1xuICAgICAgeDogKHJwb3MueCAtIHBhbi54KSAvIHpvb20sXG4gICAgICB5OiAocnBvcy55IC0gcGFuLnkpIC8gem9vbVxuICAgIH07XG4gIH1cbiAgdmFyIGNsYXNzZXMgPSBbXTtcbiAgaWYgKGFycmF5KHBhcmFtcy5jbGFzc2VzKSkge1xuICAgIGNsYXNzZXMgPSBwYXJhbXMuY2xhc3NlcztcbiAgfSBlbHNlIGlmIChzdHJpbmcocGFyYW1zLmNsYXNzZXMpKSB7XG4gICAgY2xhc3NlcyA9IHBhcmFtcy5jbGFzc2VzLnNwbGl0KC9cXHMrLyk7XG4gIH1cbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBjbGFzc2VzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHZhciBjbHMgPSBjbGFzc2VzW2ldO1xuICAgIGlmICghY2xzIHx8IGNscyA9PT0gJycpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBfcC5jbGFzc2VzLmFkZChjbHMpO1xuICB9XG4gIHRoaXMuY3JlYXRlRW1pdHRlcigpO1xuICB2YXIgYnlwYXNzID0gcGFyYW1zLnN0eWxlIHx8IHBhcmFtcy5jc3M7XG4gIGlmIChieXBhc3MpIHtcbiAgICB3YXJuKCdTZXR0aW5nIGEgYHN0eWxlYCBieXBhc3MgYXQgZWxlbWVudCBjcmVhdGlvbiBzaG91bGQgYmUgZG9uZSBvbmx5IHdoZW4gYWJzb2x1dGVseSBuZWNlc3NhcnkuICBUcnkgdG8gdXNlIHRoZSBzdHlsZXNoZWV0IGluc3RlYWQuJyk7XG4gICAgdGhpcy5zdHlsZShieXBhc3MpO1xuICB9XG4gIGlmIChyZXN0b3JlID09PSB1bmRlZmluZWQgfHwgcmVzdG9yZSkge1xuICAgIHRoaXMucmVzdG9yZSgpO1xuICB9XG59O1xuXG52YXIgZGVmaW5lU2VhcmNoID0gZnVuY3Rpb24gZGVmaW5lU2VhcmNoKHBhcmFtcykge1xuICBwYXJhbXMgPSB7XG4gICAgYmZzOiBwYXJhbXMuYmZzIHx8ICFwYXJhbXMuZGZzLFxuICAgIGRmczogcGFyYW1zLmRmcyB8fCAhcGFyYW1zLmJmc1xuICB9O1xuXG4gIC8vIGZyb20gcHNldWRvY29kZSBvbiB3aWtpcGVkaWFcbiAgcmV0dXJuIGZ1bmN0aW9uIHNlYXJjaEZuKHJvb3RzLCBmbiwgZGlyZWN0ZWQpIHtcbiAgICB2YXIgb3B0aW9ucztcbiAgICBpZiAocGxhaW5PYmplY3Qocm9vdHMpICYmICFlbGVtZW50T3JDb2xsZWN0aW9uKHJvb3RzKSkge1xuICAgICAgb3B0aW9ucyA9IHJvb3RzO1xuICAgICAgcm9vdHMgPSBvcHRpb25zLnJvb3RzIHx8IG9wdGlvbnMucm9vdDtcbiAgICAgIGZuID0gb3B0aW9ucy52aXNpdDtcbiAgICAgIGRpcmVjdGVkID0gb3B0aW9ucy5kaXJlY3RlZDtcbiAgICB9XG4gICAgZGlyZWN0ZWQgPSBhcmd1bWVudHMubGVuZ3RoID09PSAyICYmICFmbiQ2KGZuKSA/IGZuIDogZGlyZWN0ZWQ7XG4gICAgZm4gPSBmbiQ2KGZuKSA/IGZuIDogZnVuY3Rpb24gKCkge307XG4gICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeTtcbiAgICB2YXIgdiA9IHJvb3RzID0gc3RyaW5nKHJvb3RzKSA/IHRoaXMuZmlsdGVyKHJvb3RzKSA6IHJvb3RzO1xuICAgIHZhciBRID0gW107XG4gICAgdmFyIGNvbm5lY3RlZE5vZGVzID0gW107XG4gICAgdmFyIGNvbm5lY3RlZEJ5ID0ge307XG4gICAgdmFyIGlkMmRlcHRoID0ge307XG4gICAgdmFyIFYgPSB7fTtcbiAgICB2YXIgaiA9IDA7XG4gICAgdmFyIGZvdW5kO1xuICAgIHZhciBfdGhpcyRieUdyb3VwID0gdGhpcy5ieUdyb3VwKCksXG4gICAgICBub2RlcyA9IF90aGlzJGJ5R3JvdXAubm9kZXMsXG4gICAgICBlZGdlcyA9IF90aGlzJGJ5R3JvdXAuZWRnZXM7XG5cbiAgICAvLyBlbnF1ZXVlIHZcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHYubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB2aSA9IHZbaV07XG4gICAgICB2YXIgdmlJZCA9IHZpLmlkKCk7XG4gICAgICBpZiAodmkuaXNOb2RlKCkpIHtcbiAgICAgICAgUS51bnNoaWZ0KHZpKTtcbiAgICAgICAgaWYgKHBhcmFtcy5iZnMpIHtcbiAgICAgICAgICBWW3ZpSWRdID0gdHJ1ZTtcbiAgICAgICAgICBjb25uZWN0ZWROb2Rlcy5wdXNoKHZpKTtcbiAgICAgICAgfVxuICAgICAgICBpZDJkZXB0aFt2aUlkXSA9IDA7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKCkge1xuICAgICAgdmFyIHYgPSBwYXJhbXMuYmZzID8gUS5zaGlmdCgpIDogUS5wb3AoKTtcbiAgICAgIHZhciB2SWQgPSB2LmlkKCk7XG4gICAgICBpZiAocGFyYW1zLmRmcykge1xuICAgICAgICBpZiAoVlt2SWRdKSB7XG4gICAgICAgICAgcmV0dXJuIFwiY29udGludWVcIjtcbiAgICAgICAgfVxuICAgICAgICBWW3ZJZF0gPSB0cnVlO1xuICAgICAgICBjb25uZWN0ZWROb2Rlcy5wdXNoKHYpO1xuICAgICAgfVxuICAgICAgdmFyIGRlcHRoID0gaWQyZGVwdGhbdklkXTtcbiAgICAgIHZhciBwcmV2RWRnZSA9IGNvbm5lY3RlZEJ5W3ZJZF07XG4gICAgICB2YXIgc3JjID0gcHJldkVkZ2UgIT0gbnVsbCA/IHByZXZFZGdlLnNvdXJjZSgpIDogbnVsbDtcbiAgICAgIHZhciB0Z3QgPSBwcmV2RWRnZSAhPSBudWxsID8gcHJldkVkZ2UudGFyZ2V0KCkgOiBudWxsO1xuICAgICAgdmFyIHByZXZOb2RlID0gcHJldkVkZ2UgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IHYuc2FtZShzcmMpID8gdGd0WzBdIDogc3JjWzBdO1xuICAgICAgdmFyIHJldCA9IHZvaWQgMDtcbiAgICAgIHJldCA9IGZuKHYsIHByZXZFZGdlLCBwcmV2Tm9kZSwgaisrLCBkZXB0aCk7XG4gICAgICBpZiAocmV0ID09PSB0cnVlKSB7XG4gICAgICAgIGZvdW5kID0gdjtcbiAgICAgICAgcmV0dXJuIFwiYnJlYWtcIjtcbiAgICAgIH1cbiAgICAgIGlmIChyZXQgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiBcImJyZWFrXCI7XG4gICAgICB9XG4gICAgICB2YXIgdndFZGdlcyA9IHYuY29ubmVjdGVkRWRnZXMoKS5maWx0ZXIoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgcmV0dXJuICghZGlyZWN0ZWQgfHwgZS5zb3VyY2UoKS5zYW1lKHYpKSAmJiBlZGdlcy5oYXMoZSk7XG4gICAgICB9KTtcbiAgICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IHZ3RWRnZXMubGVuZ3RoOyBfaTIrKykge1xuICAgICAgICB2YXIgZSA9IHZ3RWRnZXNbX2kyXTtcbiAgICAgICAgdmFyIHcgPSBlLmNvbm5lY3RlZE5vZGVzKCkuZmlsdGVyKGZ1bmN0aW9uIChuKSB7XG4gICAgICAgICAgcmV0dXJuICFuLnNhbWUodikgJiYgbm9kZXMuaGFzKG4pO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIHdJZCA9IHcuaWQoKTtcbiAgICAgICAgaWYgKHcubGVuZ3RoICE9PSAwICYmICFWW3dJZF0pIHtcbiAgICAgICAgICB3ID0gd1swXTtcbiAgICAgICAgICBRLnB1c2godyk7XG4gICAgICAgICAgaWYgKHBhcmFtcy5iZnMpIHtcbiAgICAgICAgICAgIFZbd0lkXSA9IHRydWU7XG4gICAgICAgICAgICBjb25uZWN0ZWROb2Rlcy5wdXNoKHcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25uZWN0ZWRCeVt3SWRdID0gZTtcbiAgICAgICAgICBpZDJkZXB0aFt3SWRdID0gaWQyZGVwdGhbdklkXSArIDE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIHdoaWxlIChRLmxlbmd0aCAhPT0gMCkge1xuICAgICAgdmFyIF9yZXQgPSBfbG9vcCgpO1xuICAgICAgaWYgKF9yZXQgPT09IFwiY29udGludWVcIikgY29udGludWU7XG4gICAgICBpZiAoX3JldCA9PT0gXCJicmVha1wiKSBicmVhaztcbiAgICB9XG4gICAgdmFyIGNvbm5lY3RlZEVsZXMgPSBjeS5jb2xsZWN0aW9uKCk7XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGNvbm5lY3RlZE5vZGVzLmxlbmd0aDsgX2krKykge1xuICAgICAgdmFyIG5vZGUgPSBjb25uZWN0ZWROb2Rlc1tfaV07XG4gICAgICB2YXIgZWRnZSA9IGNvbm5lY3RlZEJ5W25vZGUuaWQoKV07XG4gICAgICBpZiAoZWRnZSAhPSBudWxsKSB7XG4gICAgICAgIGNvbm5lY3RlZEVsZXMucHVzaChlZGdlKTtcbiAgICAgIH1cbiAgICAgIGNvbm5lY3RlZEVsZXMucHVzaChub2RlKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHBhdGg6IGN5LmNvbGxlY3Rpb24oY29ubmVjdGVkRWxlcyksXG4gICAgICBmb3VuZDogY3kuY29sbGVjdGlvbihmb3VuZClcbiAgICB9O1xuICB9O1xufTtcblxuLy8gc2VhcmNoLCBzcGFubmluZyB0cmVlcywgZXRjXG52YXIgZWxlc2ZuJHYgPSB7XG4gIGJyZWFkdGhGaXJzdFNlYXJjaDogZGVmaW5lU2VhcmNoKHtcbiAgICBiZnM6IHRydWVcbiAgfSksXG4gIGRlcHRoRmlyc3RTZWFyY2g6IGRlZmluZVNlYXJjaCh7XG4gICAgZGZzOiB0cnVlXG4gIH0pXG59O1xuXG4vLyBuaWNlLCBzaG9ydCBtYXRoZW1hdGljYWwgYWxpYXNcbmVsZXNmbiR2LmJmcyA9IGVsZXNmbiR2LmJyZWFkdGhGaXJzdFNlYXJjaDtcbmVsZXNmbiR2LmRmcyA9IGVsZXNmbiR2LmRlcHRoRmlyc3RTZWFyY2g7XG5cbnZhciBoZWFwJDEgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG4vLyBHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0IDEuOC4wXG4oZnVuY3Rpb24oKSB7XG4gIHZhciBIZWFwLCBkZWZhdWx0Q21wLCBmbG9vciwgaGVhcGlmeSwgaGVhcHBvcCwgaGVhcHB1c2gsIGhlYXBwdXNocG9wLCBoZWFwcmVwbGFjZSwgaW5zb3J0LCBtaW4sIG5sYXJnZXN0LCBuc21hbGxlc3QsIHVwZGF0ZUl0ZW0sIF9zaWZ0ZG93biwgX3NpZnR1cDtcblxuICBmbG9vciA9IE1hdGguZmxvb3IsIG1pbiA9IE1hdGgubWluO1xuXG5cbiAgLypcbiAgRGVmYXVsdCBjb21wYXJpc29uIGZ1bmN0aW9uIHRvIGJlIHVzZWRcbiAgICovXG5cbiAgZGVmYXVsdENtcCA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICBpZiAoeCA8IHkpIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gICAgaWYgKHggPiB5KSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH07XG5cblxuICAvKlxuICBJbnNlcnQgaXRlbSB4IGluIGxpc3QgYSwgYW5kIGtlZXAgaXQgc29ydGVkIGFzc3VtaW5nIGEgaXMgc29ydGVkLlxuICBcbiAgSWYgeCBpcyBhbHJlYWR5IGluIGEsIGluc2VydCBpdCB0byB0aGUgcmlnaHQgb2YgdGhlIHJpZ2h0bW9zdCB4LlxuICBcbiAgT3B0aW9uYWwgYXJncyBsbyAoZGVmYXVsdCAwKSBhbmQgaGkgKGRlZmF1bHQgYS5sZW5ndGgpIGJvdW5kIHRoZSBzbGljZVxuICBvZiBhIHRvIGJlIHNlYXJjaGVkLlxuICAgKi9cblxuICBpbnNvcnQgPSBmdW5jdGlvbihhLCB4LCBsbywgaGksIGNtcCkge1xuICAgIHZhciBtaWQ7XG4gICAgaWYgKGxvID09IG51bGwpIHtcbiAgICAgIGxvID0gMDtcbiAgICB9XG4gICAgaWYgKGNtcCA9PSBudWxsKSB7XG4gICAgICBjbXAgPSBkZWZhdWx0Q21wO1xuICAgIH1cbiAgICBpZiAobG8gPCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2xvIG11c3QgYmUgbm9uLW5lZ2F0aXZlJyk7XG4gICAgfVxuICAgIGlmIChoaSA9PSBudWxsKSB7XG4gICAgICBoaSA9IGEubGVuZ3RoO1xuICAgIH1cbiAgICB3aGlsZSAobG8gPCBoaSkge1xuICAgICAgbWlkID0gZmxvb3IoKGxvICsgaGkpIC8gMik7XG4gICAgICBpZiAoY21wKHgsIGFbbWlkXSkgPCAwKSB7XG4gICAgICAgIGhpID0gbWlkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbG8gPSBtaWQgKyAxO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gKFtdLnNwbGljZS5hcHBseShhLCBbbG8sIGxvIC0gbG9dLmNvbmNhdCh4KSksIHgpO1xuICB9O1xuXG5cbiAgLypcbiAgUHVzaCBpdGVtIG9udG8gaGVhcCwgbWFpbnRhaW5pbmcgdGhlIGhlYXAgaW52YXJpYW50LlxuICAgKi9cblxuICBoZWFwcHVzaCA9IGZ1bmN0aW9uKGFycmF5LCBpdGVtLCBjbXApIHtcbiAgICBpZiAoY21wID09IG51bGwpIHtcbiAgICAgIGNtcCA9IGRlZmF1bHRDbXA7XG4gICAgfVxuICAgIGFycmF5LnB1c2goaXRlbSk7XG4gICAgcmV0dXJuIF9zaWZ0ZG93bihhcnJheSwgMCwgYXJyYXkubGVuZ3RoIC0gMSwgY21wKTtcbiAgfTtcblxuXG4gIC8qXG4gIFBvcCB0aGUgc21hbGxlc3QgaXRlbSBvZmYgdGhlIGhlYXAsIG1haW50YWluaW5nIHRoZSBoZWFwIGludmFyaWFudC5cbiAgICovXG5cbiAgaGVhcHBvcCA9IGZ1bmN0aW9uKGFycmF5LCBjbXApIHtcbiAgICB2YXIgbGFzdGVsdCwgcmV0dXJuaXRlbTtcbiAgICBpZiAoY21wID09IG51bGwpIHtcbiAgICAgIGNtcCA9IGRlZmF1bHRDbXA7XG4gICAgfVxuICAgIGxhc3RlbHQgPSBhcnJheS5wb3AoKTtcbiAgICBpZiAoYXJyYXkubGVuZ3RoKSB7XG4gICAgICByZXR1cm5pdGVtID0gYXJyYXlbMF07XG4gICAgICBhcnJheVswXSA9IGxhc3RlbHQ7XG4gICAgICBfc2lmdHVwKGFycmF5LCAwLCBjbXApO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm5pdGVtID0gbGFzdGVsdDtcbiAgICB9XG4gICAgcmV0dXJuIHJldHVybml0ZW07XG4gIH07XG5cblxuICAvKlxuICBQb3AgYW5kIHJldHVybiB0aGUgY3VycmVudCBzbWFsbGVzdCB2YWx1ZSwgYW5kIGFkZCB0aGUgbmV3IGl0ZW0uXG4gIFxuICBUaGlzIGlzIG1vcmUgZWZmaWNpZW50IHRoYW4gaGVhcHBvcCgpIGZvbGxvd2VkIGJ5IGhlYXBwdXNoKCksIGFuZCBjYW4gYmVcbiAgbW9yZSBhcHByb3ByaWF0ZSB3aGVuIHVzaW5nIGEgZml4ZWQgc2l6ZSBoZWFwLiBOb3RlIHRoYXQgdGhlIHZhbHVlXG4gIHJldHVybmVkIG1heSBiZSBsYXJnZXIgdGhhbiBpdGVtISBUaGF0IGNvbnN0cmFpbnMgcmVhc29uYWJsZSB1c2Ugb2ZcbiAgdGhpcyByb3V0aW5lIHVubGVzcyB3cml0dGVuIGFzIHBhcnQgb2YgYSBjb25kaXRpb25hbCByZXBsYWNlbWVudDpcbiAgICAgIGlmIGl0ZW0gPiBhcnJheVswXVxuICAgICAgICBpdGVtID0gaGVhcHJlcGxhY2UoYXJyYXksIGl0ZW0pXG4gICAqL1xuXG4gIGhlYXByZXBsYWNlID0gZnVuY3Rpb24oYXJyYXksIGl0ZW0sIGNtcCkge1xuICAgIHZhciByZXR1cm5pdGVtO1xuICAgIGlmIChjbXAgPT0gbnVsbCkge1xuICAgICAgY21wID0gZGVmYXVsdENtcDtcbiAgICB9XG4gICAgcmV0dXJuaXRlbSA9IGFycmF5WzBdO1xuICAgIGFycmF5WzBdID0gaXRlbTtcbiAgICBfc2lmdHVwKGFycmF5LCAwLCBjbXApO1xuICAgIHJldHVybiByZXR1cm5pdGVtO1xuICB9O1xuXG5cbiAgLypcbiAgRmFzdCB2ZXJzaW9uIG9mIGEgaGVhcHB1c2ggZm9sbG93ZWQgYnkgYSBoZWFwcG9wLlxuICAgKi9cblxuICBoZWFwcHVzaHBvcCA9IGZ1bmN0aW9uKGFycmF5LCBpdGVtLCBjbXApIHtcbiAgICB2YXIgX3JlZjtcbiAgICBpZiAoY21wID09IG51bGwpIHtcbiAgICAgIGNtcCA9IGRlZmF1bHRDbXA7XG4gICAgfVxuICAgIGlmIChhcnJheS5sZW5ndGggJiYgY21wKGFycmF5WzBdLCBpdGVtKSA8IDApIHtcbiAgICAgIF9yZWYgPSBbYXJyYXlbMF0sIGl0ZW1dLCBpdGVtID0gX3JlZlswXSwgYXJyYXlbMF0gPSBfcmVmWzFdO1xuICAgICAgX3NpZnR1cChhcnJheSwgMCwgY21wKTtcbiAgICB9XG4gICAgcmV0dXJuIGl0ZW07XG4gIH07XG5cblxuICAvKlxuICBUcmFuc2Zvcm0gbGlzdCBpbnRvIGEgaGVhcCwgaW4tcGxhY2UsIGluIE8oYXJyYXkubGVuZ3RoKSB0aW1lLlxuICAgKi9cblxuICBoZWFwaWZ5ID0gZnVuY3Rpb24oYXJyYXksIGNtcCkge1xuICAgIHZhciBpLCBfaSwgX2xlbiwgX3JlZjEsIF9yZXN1bHRzLCBfcmVzdWx0czE7XG4gICAgaWYgKGNtcCA9PSBudWxsKSB7XG4gICAgICBjbXAgPSBkZWZhdWx0Q21wO1xuICAgIH1cbiAgICBfcmVmMSA9IChmdW5jdGlvbigpIHtcbiAgICAgIF9yZXN1bHRzMSA9IFtdO1xuICAgICAgZm9yICh2YXIgX2ogPSAwLCBfcmVmID0gZmxvb3IoYXJyYXkubGVuZ3RoIC8gMik7IDAgPD0gX3JlZiA/IF9qIDwgX3JlZiA6IF9qID4gX3JlZjsgMCA8PSBfcmVmID8gX2orKyA6IF9qLS0peyBfcmVzdWx0czEucHVzaChfaik7IH1cbiAgICAgIHJldHVybiBfcmVzdWx0czE7XG4gICAgfSkuYXBwbHkodGhpcykucmV2ZXJzZSgpO1xuICAgIF9yZXN1bHRzID0gW107XG4gICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmMS5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgaSA9IF9yZWYxW19pXTtcbiAgICAgIF9yZXN1bHRzLnB1c2goX3NpZnR1cChhcnJheSwgaSwgY21wKSk7XG4gICAgfVxuICAgIHJldHVybiBfcmVzdWx0cztcbiAgfTtcblxuXG4gIC8qXG4gIFVwZGF0ZSB0aGUgcG9zaXRpb24gb2YgdGhlIGdpdmVuIGl0ZW0gaW4gdGhlIGhlYXAuXG4gIFRoaXMgZnVuY3Rpb24gc2hvdWxkIGJlIGNhbGxlZCBldmVyeSB0aW1lIHRoZSBpdGVtIGlzIGJlaW5nIG1vZGlmaWVkLlxuICAgKi9cblxuICB1cGRhdGVJdGVtID0gZnVuY3Rpb24oYXJyYXksIGl0ZW0sIGNtcCkge1xuICAgIHZhciBwb3M7XG4gICAgaWYgKGNtcCA9PSBudWxsKSB7XG4gICAgICBjbXAgPSBkZWZhdWx0Q21wO1xuICAgIH1cbiAgICBwb3MgPSBhcnJheS5pbmRleE9mKGl0ZW0pO1xuICAgIGlmIChwb3MgPT09IC0xKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIF9zaWZ0ZG93bihhcnJheSwgMCwgcG9zLCBjbXApO1xuICAgIHJldHVybiBfc2lmdHVwKGFycmF5LCBwb3MsIGNtcCk7XG4gIH07XG5cblxuICAvKlxuICBGaW5kIHRoZSBuIGxhcmdlc3QgZWxlbWVudHMgaW4gYSBkYXRhc2V0LlxuICAgKi9cblxuICBubGFyZ2VzdCA9IGZ1bmN0aW9uKGFycmF5LCBuLCBjbXApIHtcbiAgICB2YXIgZWxlbSwgcmVzdWx0LCBfaSwgX2xlbiwgX3JlZjtcbiAgICBpZiAoY21wID09IG51bGwpIHtcbiAgICAgIGNtcCA9IGRlZmF1bHRDbXA7XG4gICAgfVxuICAgIHJlc3VsdCA9IGFycmF5LnNsaWNlKDAsIG4pO1xuICAgIGlmICghcmVzdWx0Lmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgaGVhcGlmeShyZXN1bHQsIGNtcCk7XG4gICAgX3JlZiA9IGFycmF5LnNsaWNlKG4pO1xuICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZi5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgZWxlbSA9IF9yZWZbX2ldO1xuICAgICAgaGVhcHB1c2hwb3AocmVzdWx0LCBlbGVtLCBjbXApO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0LnNvcnQoY21wKS5yZXZlcnNlKCk7XG4gIH07XG5cblxuICAvKlxuICBGaW5kIHRoZSBuIHNtYWxsZXN0IGVsZW1lbnRzIGluIGEgZGF0YXNldC5cbiAgICovXG5cbiAgbnNtYWxsZXN0ID0gZnVuY3Rpb24oYXJyYXksIG4sIGNtcCkge1xuICAgIHZhciBlbGVtLCBsb3MsIHJlc3VsdCwgX2ksIF9qLCBfbGVuLCBfcmVmLCBfcmVmMSwgX3Jlc3VsdHM7XG4gICAgaWYgKGNtcCA9PSBudWxsKSB7XG4gICAgICBjbXAgPSBkZWZhdWx0Q21wO1xuICAgIH1cbiAgICBpZiAobiAqIDEwIDw9IGFycmF5Lmxlbmd0aCkge1xuICAgICAgcmVzdWx0ID0gYXJyYXkuc2xpY2UoMCwgbikuc29ydChjbXApO1xuICAgICAgaWYgKCFyZXN1bHQubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICBsb3MgPSByZXN1bHRbcmVzdWx0Lmxlbmd0aCAtIDFdO1xuICAgICAgX3JlZiA9IGFycmF5LnNsaWNlKG4pO1xuICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgIGVsZW0gPSBfcmVmW19pXTtcbiAgICAgICAgaWYgKGNtcChlbGVtLCBsb3MpIDwgMCkge1xuICAgICAgICAgIGluc29ydChyZXN1bHQsIGVsZW0sIDAsIG51bGwsIGNtcCk7XG4gICAgICAgICAgcmVzdWx0LnBvcCgpO1xuICAgICAgICAgIGxvcyA9IHJlc3VsdFtyZXN1bHQubGVuZ3RoIC0gMV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGhlYXBpZnkoYXJyYXksIGNtcCk7XG4gICAgX3Jlc3VsdHMgPSBbXTtcbiAgICBmb3IgKF9qID0gMCwgX3JlZjEgPSBtaW4obiwgYXJyYXkubGVuZ3RoKTsgMCA8PSBfcmVmMSA/IF9qIDwgX3JlZjEgOiBfaiA+IF9yZWYxOyAwIDw9IF9yZWYxID8gKytfaiA6IC0tX2opIHtcbiAgICAgIF9yZXN1bHRzLnB1c2goaGVhcHBvcChhcnJheSwgY21wKSk7XG4gICAgfVxuICAgIHJldHVybiBfcmVzdWx0cztcbiAgfTtcblxuICBfc2lmdGRvd24gPSBmdW5jdGlvbihhcnJheSwgc3RhcnRwb3MsIHBvcywgY21wKSB7XG4gICAgdmFyIG5ld2l0ZW0sIHBhcmVudCwgcGFyZW50cG9zO1xuICAgIGlmIChjbXAgPT0gbnVsbCkge1xuICAgICAgY21wID0gZGVmYXVsdENtcDtcbiAgICB9XG4gICAgbmV3aXRlbSA9IGFycmF5W3Bvc107XG4gICAgd2hpbGUgKHBvcyA+IHN0YXJ0cG9zKSB7XG4gICAgICBwYXJlbnRwb3MgPSAocG9zIC0gMSkgPj4gMTtcbiAgICAgIHBhcmVudCA9IGFycmF5W3BhcmVudHBvc107XG4gICAgICBpZiAoY21wKG5ld2l0ZW0sIHBhcmVudCkgPCAwKSB7XG4gICAgICAgIGFycmF5W3Bvc10gPSBwYXJlbnQ7XG4gICAgICAgIHBvcyA9IHBhcmVudHBvcztcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5W3Bvc10gPSBuZXdpdGVtO1xuICB9O1xuXG4gIF9zaWZ0dXAgPSBmdW5jdGlvbihhcnJheSwgcG9zLCBjbXApIHtcbiAgICB2YXIgY2hpbGRwb3MsIGVuZHBvcywgbmV3aXRlbSwgcmlnaHRwb3MsIHN0YXJ0cG9zO1xuICAgIGlmIChjbXAgPT0gbnVsbCkge1xuICAgICAgY21wID0gZGVmYXVsdENtcDtcbiAgICB9XG4gICAgZW5kcG9zID0gYXJyYXkubGVuZ3RoO1xuICAgIHN0YXJ0cG9zID0gcG9zO1xuICAgIG5ld2l0ZW0gPSBhcnJheVtwb3NdO1xuICAgIGNoaWxkcG9zID0gMiAqIHBvcyArIDE7XG4gICAgd2hpbGUgKGNoaWxkcG9zIDwgZW5kcG9zKSB7XG4gICAgICByaWdodHBvcyA9IGNoaWxkcG9zICsgMTtcbiAgICAgIGlmIChyaWdodHBvcyA8IGVuZHBvcyAmJiAhKGNtcChhcnJheVtjaGlsZHBvc10sIGFycmF5W3JpZ2h0cG9zXSkgPCAwKSkge1xuICAgICAgICBjaGlsZHBvcyA9IHJpZ2h0cG9zO1xuICAgICAgfVxuICAgICAgYXJyYXlbcG9zXSA9IGFycmF5W2NoaWxkcG9zXTtcbiAgICAgIHBvcyA9IGNoaWxkcG9zO1xuICAgICAgY2hpbGRwb3MgPSAyICogcG9zICsgMTtcbiAgICB9XG4gICAgYXJyYXlbcG9zXSA9IG5ld2l0ZW07XG4gICAgcmV0dXJuIF9zaWZ0ZG93bihhcnJheSwgc3RhcnRwb3MsIHBvcywgY21wKTtcbiAgfTtcblxuICBIZWFwID0gKGZ1bmN0aW9uKCkge1xuICAgIEhlYXAucHVzaCA9IGhlYXBwdXNoO1xuXG4gICAgSGVhcC5wb3AgPSBoZWFwcG9wO1xuXG4gICAgSGVhcC5yZXBsYWNlID0gaGVhcHJlcGxhY2U7XG5cbiAgICBIZWFwLnB1c2hwb3AgPSBoZWFwcHVzaHBvcDtcblxuICAgIEhlYXAuaGVhcGlmeSA9IGhlYXBpZnk7XG5cbiAgICBIZWFwLnVwZGF0ZUl0ZW0gPSB1cGRhdGVJdGVtO1xuXG4gICAgSGVhcC5ubGFyZ2VzdCA9IG5sYXJnZXN0O1xuXG4gICAgSGVhcC5uc21hbGxlc3QgPSBuc21hbGxlc3Q7XG5cbiAgICBmdW5jdGlvbiBIZWFwKGNtcCkge1xuICAgICAgdGhpcy5jbXAgPSBjbXAgIT0gbnVsbCA/IGNtcCA6IGRlZmF1bHRDbXA7XG4gICAgICB0aGlzLm5vZGVzID0gW107XG4gICAgfVxuXG4gICAgSGVhcC5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIHJldHVybiBoZWFwcHVzaCh0aGlzLm5vZGVzLCB4LCB0aGlzLmNtcCk7XG4gICAgfTtcblxuICAgIEhlYXAucHJvdG90eXBlLnBvcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGhlYXBwb3AodGhpcy5ub2RlcywgdGhpcy5jbXApO1xuICAgIH07XG5cbiAgICBIZWFwLnByb3RvdHlwZS5wZWVrID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5ub2Rlc1swXTtcbiAgICB9O1xuXG4gICAgSGVhcC5wcm90b3R5cGUuY29udGFpbnMgPSBmdW5jdGlvbih4KSB7XG4gICAgICByZXR1cm4gdGhpcy5ub2Rlcy5pbmRleE9mKHgpICE9PSAtMTtcbiAgICB9O1xuXG4gICAgSGVhcC5wcm90b3R5cGUucmVwbGFjZSA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIHJldHVybiBoZWFwcmVwbGFjZSh0aGlzLm5vZGVzLCB4LCB0aGlzLmNtcCk7XG4gICAgfTtcblxuICAgIEhlYXAucHJvdG90eXBlLnB1c2hwb3AgPSBmdW5jdGlvbih4KSB7XG4gICAgICByZXR1cm4gaGVhcHB1c2hwb3AodGhpcy5ub2RlcywgeCwgdGhpcy5jbXApO1xuICAgIH07XG5cbiAgICBIZWFwLnByb3RvdHlwZS5oZWFwaWZ5ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gaGVhcGlmeSh0aGlzLm5vZGVzLCB0aGlzLmNtcCk7XG4gICAgfTtcblxuICAgIEhlYXAucHJvdG90eXBlLnVwZGF0ZUl0ZW0gPSBmdW5jdGlvbih4KSB7XG4gICAgICByZXR1cm4gdXBkYXRlSXRlbSh0aGlzLm5vZGVzLCB4LCB0aGlzLmNtcCk7XG4gICAgfTtcblxuICAgIEhlYXAucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5ub2RlcyA9IFtdO1xuICAgIH07XG5cbiAgICBIZWFwLnByb3RvdHlwZS5lbXB0eSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMubm9kZXMubGVuZ3RoID09PSAwO1xuICAgIH07XG5cbiAgICBIZWFwLnByb3RvdHlwZS5zaXplID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5ub2Rlcy5sZW5ndGg7XG4gICAgfTtcblxuICAgIEhlYXAucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgaGVhcDtcbiAgICAgIGhlYXAgPSBuZXcgSGVhcCgpO1xuICAgICAgaGVhcC5ub2RlcyA9IHRoaXMubm9kZXMuc2xpY2UoMCk7XG4gICAgICByZXR1cm4gaGVhcDtcbiAgICB9O1xuXG4gICAgSGVhcC5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMubm9kZXMuc2xpY2UoMCk7XG4gICAgfTtcblxuICAgIEhlYXAucHJvdG90eXBlLmluc2VydCA9IEhlYXAucHJvdG90eXBlLnB1c2g7XG5cbiAgICBIZWFwLnByb3RvdHlwZS50b3AgPSBIZWFwLnByb3RvdHlwZS5wZWVrO1xuXG4gICAgSGVhcC5wcm90b3R5cGUuZnJvbnQgPSBIZWFwLnByb3RvdHlwZS5wZWVrO1xuXG4gICAgSGVhcC5wcm90b3R5cGUuaGFzID0gSGVhcC5wcm90b3R5cGUuY29udGFpbnM7XG5cbiAgICBIZWFwLnByb3RvdHlwZS5jb3B5ID0gSGVhcC5wcm90b3R5cGUuY2xvbmU7XG5cbiAgICByZXR1cm4gSGVhcDtcblxuICB9KSgpO1xuXG4gIChmdW5jdGlvbihyb290LCBmYWN0b3J5KSB7XG4gICAge1xuICAgICAgcmV0dXJuIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuICAgIH1cbiAgfSkodGhpcywgZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIEhlYXA7XG4gIH0pO1xuXG59KS5jYWxsKGNvbW1vbmpzR2xvYmFsKTtcbn0pO1xuXG52YXIgaGVhcCA9IGhlYXAkMTtcblxudmFyIGRpamtzdHJhRGVmYXVsdHMgPSBkZWZhdWx0cyRnKHtcbiAgcm9vdDogbnVsbCxcbiAgd2VpZ2h0OiBmdW5jdGlvbiB3ZWlnaHQoZWRnZSkge1xuICAgIHJldHVybiAxO1xuICB9LFxuICBkaXJlY3RlZDogZmFsc2Vcbn0pO1xudmFyIGVsZXNmbiR1ID0ge1xuICBkaWprc3RyYTogZnVuY3Rpb24gZGlqa3N0cmEob3B0aW9ucykge1xuICAgIGlmICghcGxhaW5PYmplY3Qob3B0aW9ucykpIHtcbiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgcm9vdDogYXJnc1swXSxcbiAgICAgICAgd2VpZ2h0OiBhcmdzWzFdLFxuICAgICAgICBkaXJlY3RlZDogYXJnc1syXVxuICAgICAgfTtcbiAgICB9XG4gICAgdmFyIF9kaWprc3RyYURlZmF1bHRzID0gZGlqa3N0cmFEZWZhdWx0cyhvcHRpb25zKSxcbiAgICAgIHJvb3QgPSBfZGlqa3N0cmFEZWZhdWx0cy5yb290LFxuICAgICAgd2VpZ2h0ID0gX2RpamtzdHJhRGVmYXVsdHMud2VpZ2h0LFxuICAgICAgZGlyZWN0ZWQgPSBfZGlqa3N0cmFEZWZhdWx0cy5kaXJlY3RlZDtcbiAgICB2YXIgZWxlcyA9IHRoaXM7XG4gICAgdmFyIHdlaWdodEZuID0gd2VpZ2h0O1xuICAgIHZhciBzb3VyY2UgPSBzdHJpbmcocm9vdCkgPyB0aGlzLmZpbHRlcihyb290KVswXSA6IHJvb3RbMF07XG4gICAgdmFyIGRpc3QgPSB7fTtcbiAgICB2YXIgcHJldiA9IHt9O1xuICAgIHZhciBrbm93bkRpc3QgPSB7fTtcbiAgICB2YXIgX3RoaXMkYnlHcm91cCA9IHRoaXMuYnlHcm91cCgpLFxuICAgICAgbm9kZXMgPSBfdGhpcyRieUdyb3VwLm5vZGVzLFxuICAgICAgZWRnZXMgPSBfdGhpcyRieUdyb3VwLmVkZ2VzO1xuICAgIGVkZ2VzLnVubWVyZ2VCeShmdW5jdGlvbiAoZWxlKSB7XG4gICAgICByZXR1cm4gZWxlLmlzTG9vcCgpO1xuICAgIH0pO1xuICAgIHZhciBnZXREaXN0ID0gZnVuY3Rpb24gZ2V0RGlzdChub2RlKSB7XG4gICAgICByZXR1cm4gZGlzdFtub2RlLmlkKCldO1xuICAgIH07XG4gICAgdmFyIHNldERpc3QgPSBmdW5jdGlvbiBzZXREaXN0KG5vZGUsIGQpIHtcbiAgICAgIGRpc3Rbbm9kZS5pZCgpXSA9IGQ7XG4gICAgICBRLnVwZGF0ZUl0ZW0obm9kZSk7XG4gICAgfTtcbiAgICB2YXIgUSA9IG5ldyBoZWFwKGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICByZXR1cm4gZ2V0RGlzdChhKSAtIGdldERpc3QoYik7XG4gICAgfSk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgIGRpc3Rbbm9kZS5pZCgpXSA9IG5vZGUuc2FtZShzb3VyY2UpID8gMCA6IEluZmluaXR5O1xuICAgICAgUS5wdXNoKG5vZGUpO1xuICAgIH1cbiAgICB2YXIgZGlzdEJldHdlZW4gPSBmdW5jdGlvbiBkaXN0QmV0d2Vlbih1LCB2KSB7XG4gICAgICB2YXIgdXZzID0gKGRpcmVjdGVkID8gdS5lZGdlc1RvKHYpIDogdS5lZGdlc1dpdGgodikpLmludGVyc2VjdChlZGdlcyk7XG4gICAgICB2YXIgc21hbGxlc3REaXN0YW5jZSA9IEluZmluaXR5O1xuICAgICAgdmFyIHNtYWxsZXN0RWRnZTtcbiAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCB1dnMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciBlZGdlID0gdXZzW19pXTtcbiAgICAgICAgdmFyIF93ZWlnaHQgPSB3ZWlnaHRGbihlZGdlKTtcbiAgICAgICAgaWYgKF93ZWlnaHQgPCBzbWFsbGVzdERpc3RhbmNlIHx8ICFzbWFsbGVzdEVkZ2UpIHtcbiAgICAgICAgICBzbWFsbGVzdERpc3RhbmNlID0gX3dlaWdodDtcbiAgICAgICAgICBzbWFsbGVzdEVkZ2UgPSBlZGdlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBlZGdlOiBzbWFsbGVzdEVkZ2UsXG4gICAgICAgIGRpc3Q6IHNtYWxsZXN0RGlzdGFuY2VcbiAgICAgIH07XG4gICAgfTtcbiAgICB3aGlsZSAoUS5zaXplKCkgPiAwKSB7XG4gICAgICB2YXIgdSA9IFEucG9wKCk7XG4gICAgICB2YXIgc21hbGxldHNEaXN0ID0gZ2V0RGlzdCh1KTtcbiAgICAgIHZhciB1aWQgPSB1LmlkKCk7XG4gICAgICBrbm93bkRpc3RbdWlkXSA9IHNtYWxsZXRzRGlzdDtcbiAgICAgIGlmIChzbWFsbGV0c0Rpc3QgPT09IEluZmluaXR5KSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdmFyIG5laWdoYm9ycyA9IHUubmVpZ2hib3Job29kKCkuaW50ZXJzZWN0KG5vZGVzKTtcbiAgICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IG5laWdoYm9ycy5sZW5ndGg7IF9pMisrKSB7XG4gICAgICAgIHZhciB2ID0gbmVpZ2hib3JzW19pMl07XG4gICAgICAgIHZhciB2aWQgPSB2LmlkKCk7XG4gICAgICAgIHZhciB2RGlzdCA9IGRpc3RCZXR3ZWVuKHUsIHYpO1xuICAgICAgICB2YXIgYWx0ID0gc21hbGxldHNEaXN0ICsgdkRpc3QuZGlzdDtcbiAgICAgICAgaWYgKGFsdCA8IGdldERpc3QodikpIHtcbiAgICAgICAgICBzZXREaXN0KHYsIGFsdCk7XG4gICAgICAgICAgcHJldlt2aWRdID0ge1xuICAgICAgICAgICAgbm9kZTogdSxcbiAgICAgICAgICAgIGVkZ2U6IHZEaXN0LmVkZ2VcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9IC8vIGZvclxuICAgIH0gLy8gd2hpbGVcblxuICAgIHJldHVybiB7XG4gICAgICBkaXN0YW5jZVRvOiBmdW5jdGlvbiBkaXN0YW5jZVRvKG5vZGUpIHtcbiAgICAgICAgdmFyIHRhcmdldCA9IHN0cmluZyhub2RlKSA/IG5vZGVzLmZpbHRlcihub2RlKVswXSA6IG5vZGVbMF07XG4gICAgICAgIHJldHVybiBrbm93bkRpc3RbdGFyZ2V0LmlkKCldO1xuICAgICAgfSxcbiAgICAgIHBhdGhUbzogZnVuY3Rpb24gcGF0aFRvKG5vZGUpIHtcbiAgICAgICAgdmFyIHRhcmdldCA9IHN0cmluZyhub2RlKSA/IG5vZGVzLmZpbHRlcihub2RlKVswXSA6IG5vZGVbMF07XG4gICAgICAgIHZhciBTID0gW107XG4gICAgICAgIHZhciB1ID0gdGFyZ2V0O1xuICAgICAgICB2YXIgdWlkID0gdS5pZCgpO1xuICAgICAgICBpZiAodGFyZ2V0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBTLnVuc2hpZnQodGFyZ2V0KTtcbiAgICAgICAgICB3aGlsZSAocHJldlt1aWRdKSB7XG4gICAgICAgICAgICB2YXIgcCA9IHByZXZbdWlkXTtcbiAgICAgICAgICAgIFMudW5zaGlmdChwLmVkZ2UpO1xuICAgICAgICAgICAgUy51bnNoaWZ0KHAubm9kZSk7XG4gICAgICAgICAgICB1ID0gcC5ub2RlO1xuICAgICAgICAgICAgdWlkID0gdS5pZCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZWxlcy5zcGF3bihTKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG59O1xuXG52YXIgZWxlc2ZuJHQgPSB7XG4gIC8vIGtydXNrYWwncyBhbGdvcml0aG0gKGZpbmRzIG1pbiBzcGFubmluZyB0cmVlLCBhc3N1bWluZyB1bmRpcmVjdGVkIGdyYXBoKVxuICAvLyBpbXBsZW1lbnRlZCBmcm9tIHBzZXVkb2NvZGUgZnJvbSB3aWtpcGVkaWFcbiAga3J1c2thbDogZnVuY3Rpb24ga3J1c2thbCh3ZWlnaHRGbikge1xuICAgIHdlaWdodEZuID0gd2VpZ2h0Rm4gfHwgZnVuY3Rpb24gKGVkZ2UpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH07XG4gICAgdmFyIF90aGlzJGJ5R3JvdXAgPSB0aGlzLmJ5R3JvdXAoKSxcbiAgICAgIG5vZGVzID0gX3RoaXMkYnlHcm91cC5ub2RlcyxcbiAgICAgIGVkZ2VzID0gX3RoaXMkYnlHcm91cC5lZGdlcztcbiAgICB2YXIgbnVtTm9kZXMgPSBub2Rlcy5sZW5ndGg7XG4gICAgdmFyIGZvcmVzdCA9IG5ldyBBcnJheShudW1Ob2Rlcyk7XG4gICAgdmFyIEEgPSBub2RlczsgLy8gYXNzdW1lcyBieUdyb3VwKCkgY3JlYXRlcyBuZXcgY29sbGVjdGlvbnMgdGhhdCBjYW4gYmUgc2FmZWx5IG11dGF0ZWRcblxuICAgIHZhciBmaW5kU2V0SW5kZXggPSBmdW5jdGlvbiBmaW5kU2V0SW5kZXgoZWxlKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZvcmVzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZWxlcyA9IGZvcmVzdFtpXTtcbiAgICAgICAgaWYgKGVsZXMuaGFzKGVsZSkpIHtcbiAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBzdGFydCB3aXRoIG9uZSBmb3Jlc3QgcGVyIG5vZGVcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bU5vZGVzOyBpKyspIHtcbiAgICAgIGZvcmVzdFtpXSA9IHRoaXMuc3Bhd24obm9kZXNbaV0pO1xuICAgIH1cbiAgICB2YXIgUyA9IGVkZ2VzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHJldHVybiB3ZWlnaHRGbihhKSAtIHdlaWdodEZuKGIpO1xuICAgIH0pO1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBTLmxlbmd0aDsgX2krKykge1xuICAgICAgdmFyIGVkZ2UgPSBTW19pXTtcbiAgICAgIHZhciB1ID0gZWRnZS5zb3VyY2UoKVswXTtcbiAgICAgIHZhciB2ID0gZWRnZS50YXJnZXQoKVswXTtcbiAgICAgIHZhciBzZXRVSW5kZXggPSBmaW5kU2V0SW5kZXgodSk7XG4gICAgICB2YXIgc2V0VkluZGV4ID0gZmluZFNldEluZGV4KHYpO1xuICAgICAgdmFyIHNldFUgPSBmb3Jlc3Rbc2V0VUluZGV4XTtcbiAgICAgIHZhciBzZXRWID0gZm9yZXN0W3NldFZJbmRleF07XG4gICAgICBpZiAoc2V0VUluZGV4ICE9PSBzZXRWSW5kZXgpIHtcbiAgICAgICAgQS5tZXJnZShlZGdlKTtcblxuICAgICAgICAvLyBjb21iaW5lIGZvcmVzdHMgZm9yIHUgYW5kIHZcbiAgICAgICAgc2V0VS5tZXJnZShzZXRWKTtcbiAgICAgICAgZm9yZXN0LnNwbGljZShzZXRWSW5kZXgsIDEpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gQTtcbiAgfVxufTtcblxudmFyIGFTdGFyRGVmYXVsdHMgPSBkZWZhdWx0cyRnKHtcbiAgcm9vdDogbnVsbCxcbiAgZ29hbDogbnVsbCxcbiAgd2VpZ2h0OiBmdW5jdGlvbiB3ZWlnaHQoZWRnZSkge1xuICAgIHJldHVybiAxO1xuICB9LFxuICBoZXVyaXN0aWM6IGZ1bmN0aW9uIGhldXJpc3RpYyhlZGdlKSB7XG4gICAgcmV0dXJuIDA7XG4gIH0sXG4gIGRpcmVjdGVkOiBmYWxzZVxufSk7XG52YXIgZWxlc2ZuJHMgPSB7XG4gIC8vIEltcGxlbWVudGVkIGZyb20gcHNldWRvY29kZSBmcm9tIHdpa2lwZWRpYVxuICBhU3RhcjogZnVuY3Rpb24gYVN0YXIob3B0aW9ucykge1xuICAgIHZhciBjeSA9IHRoaXMuY3koKTtcbiAgICB2YXIgX2FTdGFyRGVmYXVsdHMgPSBhU3RhckRlZmF1bHRzKG9wdGlvbnMpLFxuICAgICAgcm9vdCA9IF9hU3RhckRlZmF1bHRzLnJvb3QsXG4gICAgICBnb2FsID0gX2FTdGFyRGVmYXVsdHMuZ29hbCxcbiAgICAgIGhldXJpc3RpYyA9IF9hU3RhckRlZmF1bHRzLmhldXJpc3RpYyxcbiAgICAgIGRpcmVjdGVkID0gX2FTdGFyRGVmYXVsdHMuZGlyZWN0ZWQsXG4gICAgICB3ZWlnaHQgPSBfYVN0YXJEZWZhdWx0cy53ZWlnaHQ7XG4gICAgcm9vdCA9IGN5LmNvbGxlY3Rpb24ocm9vdClbMF07XG4gICAgZ29hbCA9IGN5LmNvbGxlY3Rpb24oZ29hbClbMF07XG4gICAgdmFyIHNpZCA9IHJvb3QuaWQoKTtcbiAgICB2YXIgdGlkID0gZ29hbC5pZCgpO1xuICAgIHZhciBnU2NvcmUgPSB7fTtcbiAgICB2YXIgZlNjb3JlID0ge307XG4gICAgdmFyIGNsb3NlZFNldElkcyA9IHt9O1xuICAgIHZhciBvcGVuU2V0ID0gbmV3IGhlYXAoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHJldHVybiBmU2NvcmVbYS5pZCgpXSAtIGZTY29yZVtiLmlkKCldO1xuICAgIH0pO1xuICAgIHZhciBvcGVuU2V0SWRzID0gbmV3IFNldCQxKCk7XG4gICAgdmFyIGNhbWVGcm9tID0ge307XG4gICAgdmFyIGNhbWVGcm9tRWRnZSA9IHt9O1xuICAgIHZhciBhZGRUb09wZW5TZXQgPSBmdW5jdGlvbiBhZGRUb09wZW5TZXQoZWxlLCBpZCkge1xuICAgICAgb3BlblNldC5wdXNoKGVsZSk7XG4gICAgICBvcGVuU2V0SWRzLmFkZChpZCk7XG4gICAgfTtcbiAgICB2YXIgY01pbiwgY01pbklkO1xuICAgIHZhciBwb3BGcm9tT3BlblNldCA9IGZ1bmN0aW9uIHBvcEZyb21PcGVuU2V0KCkge1xuICAgICAgY01pbiA9IG9wZW5TZXQucG9wKCk7XG4gICAgICBjTWluSWQgPSBjTWluLmlkKCk7XG4gICAgICBvcGVuU2V0SWRzW1wiZGVsZXRlXCJdKGNNaW5JZCk7XG4gICAgfTtcbiAgICB2YXIgaXNJbk9wZW5TZXQgPSBmdW5jdGlvbiBpc0luT3BlblNldChpZCkge1xuICAgICAgcmV0dXJuIG9wZW5TZXRJZHMuaGFzKGlkKTtcbiAgICB9O1xuICAgIGFkZFRvT3BlblNldChyb290LCBzaWQpO1xuICAgIGdTY29yZVtzaWRdID0gMDtcbiAgICBmU2NvcmVbc2lkXSA9IGhldXJpc3RpYyhyb290KTtcblxuICAgIC8vIENvdW50ZXJcbiAgICB2YXIgc3RlcHMgPSAwO1xuXG4gICAgLy8gTWFpbiBsb29wXG4gICAgd2hpbGUgKG9wZW5TZXQuc2l6ZSgpID4gMCkge1xuICAgICAgcG9wRnJvbU9wZW5TZXQoKTtcbiAgICAgIHN0ZXBzKys7XG5cbiAgICAgIC8vIElmIHdlJ3ZlIGZvdW5kIG91ciBnb2FsLCB0aGVuIHdlIGFyZSBkb25lXG4gICAgICBpZiAoY01pbklkID09PSB0aWQpIHtcbiAgICAgICAgdmFyIHBhdGggPSBbXTtcbiAgICAgICAgdmFyIHBhdGhOb2RlID0gZ29hbDtcbiAgICAgICAgdmFyIHBhdGhOb2RlSWQgPSB0aWQ7XG4gICAgICAgIHZhciBwYXRoRWRnZSA9IGNhbWVGcm9tRWRnZVtwYXRoTm9kZUlkXTtcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgIHBhdGgudW5zaGlmdChwYXRoTm9kZSk7XG4gICAgICAgICAgaWYgKHBhdGhFZGdlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHBhdGgudW5zaGlmdChwYXRoRWRnZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHBhdGhOb2RlID0gY2FtZUZyb21bcGF0aE5vZGVJZF07XG4gICAgICAgICAgaWYgKHBhdGhOb2RlID09IG51bGwpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwYXRoTm9kZUlkID0gcGF0aE5vZGUuaWQoKTtcbiAgICAgICAgICBwYXRoRWRnZSA9IGNhbWVGcm9tRWRnZVtwYXRoTm9kZUlkXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGZvdW5kOiB0cnVlLFxuICAgICAgICAgIGRpc3RhbmNlOiBnU2NvcmVbY01pbklkXSxcbiAgICAgICAgICBwYXRoOiB0aGlzLnNwYXduKHBhdGgpLFxuICAgICAgICAgIHN0ZXBzOiBzdGVwc1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICAvLyBBZGQgY01pbiB0byBwcm9jZXNzZWQgbm9kZXNcbiAgICAgIGNsb3NlZFNldElkc1tjTWluSWRdID0gdHJ1ZTtcblxuICAgICAgLy8gVXBkYXRlIHNjb3JlcyBmb3IgbmVpZ2hib3JzIG9mIGNNaW5cbiAgICAgIC8vIFRha2UgaW50byBhY2NvdW50IGlmIGdyYXBoIGlzIGRpcmVjdGVkIG9yIG5vdFxuICAgICAgdmFyIHZ3RWRnZXMgPSBjTWluLl9wcml2YXRlLmVkZ2VzO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2d0VkZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlID0gdndFZGdlc1tpXTtcblxuICAgICAgICAvLyBlZGdlIG11c3QgYmUgaW4gc2V0IG9mIGNhbGxpbmcgZWxlc1xuICAgICAgICBpZiAoIXRoaXMuaGFzRWxlbWVudFdpdGhJZChlLmlkKCkpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjTWluIG11c3QgYmUgdGhlIHNvdXJjZSBvZiBlZGdlIGlmIGRpcmVjdGVkXG4gICAgICAgIGlmIChkaXJlY3RlZCAmJiBlLmRhdGEoJ3NvdXJjZScpICE9PSBjTWluSWQpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgd1NyYyA9IGUuc291cmNlKCk7XG4gICAgICAgIHZhciB3VGd0ID0gZS50YXJnZXQoKTtcbiAgICAgICAgdmFyIHcgPSB3U3JjLmlkKCkgIT09IGNNaW5JZCA/IHdTcmMgOiB3VGd0O1xuICAgICAgICB2YXIgd2lkID0gdy5pZCgpO1xuXG4gICAgICAgIC8vIG5vZGUgbXVzdCBiZSBpbiBzZXQgb2YgY2FsbGluZyBlbGVzXG4gICAgICAgIGlmICghdGhpcy5oYXNFbGVtZW50V2l0aElkKHdpZCkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIG5vZGUgaXMgaW4gY2xvc2VkU2V0LCBpZ25vcmUgaXRcbiAgICAgICAgaWYgKGNsb3NlZFNldElkc1t3aWRdKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBOZXcgdGVudGF0aXZlIHNjb3JlIGZvciBub2RlIHdcbiAgICAgICAgdmFyIHRlbXBTY29yZSA9IGdTY29yZVtjTWluSWRdICsgd2VpZ2h0KGUpO1xuXG4gICAgICAgIC8vIFVwZGF0ZSBnU2NvcmUgZm9yIG5vZGUgdyBpZjpcbiAgICAgICAgLy8gICB3IG5vdCBwcmVzZW50IGluIG9wZW5TZXRcbiAgICAgICAgLy8gT1JcbiAgICAgICAgLy8gICB0ZW50YXRpdmUgZ1Njb3JlIGlzIGxlc3MgdGhhbiBwcmV2aW91cyB2YWx1ZVxuXG4gICAgICAgIC8vIHcgbm90IGluIG9wZW5TZXRcbiAgICAgICAgaWYgKCFpc0luT3BlblNldCh3aWQpKSB7XG4gICAgICAgICAgZ1Njb3JlW3dpZF0gPSB0ZW1wU2NvcmU7XG4gICAgICAgICAgZlNjb3JlW3dpZF0gPSB0ZW1wU2NvcmUgKyBoZXVyaXN0aWModyk7XG4gICAgICAgICAgYWRkVG9PcGVuU2V0KHcsIHdpZCk7XG4gICAgICAgICAgY2FtZUZyb21bd2lkXSA9IGNNaW47XG4gICAgICAgICAgY2FtZUZyb21FZGdlW3dpZF0gPSBlO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdyBhbHJlYWR5IGluIG9wZW5TZXQsIGJ1dCB3aXRoIGdyZWF0ZXIgZ1Njb3JlXG4gICAgICAgIGlmICh0ZW1wU2NvcmUgPCBnU2NvcmVbd2lkXSkge1xuICAgICAgICAgIGdTY29yZVt3aWRdID0gdGVtcFNjb3JlO1xuICAgICAgICAgIGZTY29yZVt3aWRdID0gdGVtcFNjb3JlICsgaGV1cmlzdGljKHcpO1xuICAgICAgICAgIGNhbWVGcm9tW3dpZF0gPSBjTWluO1xuICAgICAgICAgIGNhbWVGcm9tRWRnZVt3aWRdID0gZTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBFbmQgb2YgbmVpZ2hib3JzIHVwZGF0ZVxuICAgIH0gLy8gRW5kIG9mIG1haW4gbG9vcFxuXG4gICAgLy8gSWYgd2UndmUgcmVhY2hlZCBoZXJlLCB0aGVuIHdlJ3ZlIG5vdCByZWFjaGVkIG91ciBnb2FsXG4gICAgcmV0dXJuIHtcbiAgICAgIGZvdW5kOiBmYWxzZSxcbiAgICAgIGRpc3RhbmNlOiB1bmRlZmluZWQsXG4gICAgICBwYXRoOiB1bmRlZmluZWQsXG4gICAgICBzdGVwczogc3RlcHNcbiAgICB9O1xuICB9XG59OyAvLyBlbGVzZm5cblxudmFyIGZsb3lkV2Fyc2hhbGxEZWZhdWx0cyA9IGRlZmF1bHRzJGcoe1xuICB3ZWlnaHQ6IGZ1bmN0aW9uIHdlaWdodChlZGdlKSB7XG4gICAgcmV0dXJuIDE7XG4gIH0sXG4gIGRpcmVjdGVkOiBmYWxzZVxufSk7XG52YXIgZWxlc2ZuJHIgPSB7XG4gIC8vIEltcGxlbWVudGVkIGZyb20gcHNldWRvY29kZSBmcm9tIHdpa2lwZWRpYVxuICBmbG95ZFdhcnNoYWxsOiBmdW5jdGlvbiBmbG95ZFdhcnNoYWxsKG9wdGlvbnMpIHtcbiAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG4gICAgdmFyIF9mbG95ZFdhcnNoYWxsRGVmYXVsdCA9IGZsb3lkV2Fyc2hhbGxEZWZhdWx0cyhvcHRpb25zKSxcbiAgICAgIHdlaWdodCA9IF9mbG95ZFdhcnNoYWxsRGVmYXVsdC53ZWlnaHQsXG4gICAgICBkaXJlY3RlZCA9IF9mbG95ZFdhcnNoYWxsRGVmYXVsdC5kaXJlY3RlZDtcbiAgICB2YXIgd2VpZ2h0Rm4gPSB3ZWlnaHQ7XG4gICAgdmFyIF90aGlzJGJ5R3JvdXAgPSB0aGlzLmJ5R3JvdXAoKSxcbiAgICAgIG5vZGVzID0gX3RoaXMkYnlHcm91cC5ub2RlcyxcbiAgICAgIGVkZ2VzID0gX3RoaXMkYnlHcm91cC5lZGdlcztcbiAgICB2YXIgTiA9IG5vZGVzLmxlbmd0aDtcbiAgICB2YXIgTnNxID0gTiAqIE47XG4gICAgdmFyIGluZGV4T2YgPSBmdW5jdGlvbiBpbmRleE9mKG5vZGUpIHtcbiAgICAgIHJldHVybiBub2Rlcy5pbmRleE9mKG5vZGUpO1xuICAgIH07XG4gICAgdmFyIGF0SW5kZXggPSBmdW5jdGlvbiBhdEluZGV4KGkpIHtcbiAgICAgIHJldHVybiBub2Rlc1tpXTtcbiAgICB9O1xuXG4gICAgLy8gSW5pdGlhbGl6ZSBkaXN0YW5jZSBtYXRyaXhcbiAgICB2YXIgZGlzdCA9IG5ldyBBcnJheShOc3EpO1xuICAgIGZvciAodmFyIG4gPSAwOyBuIDwgTnNxOyBuKyspIHtcbiAgICAgIHZhciBqID0gbiAlIE47XG4gICAgICB2YXIgaSA9IChuIC0gaikgLyBOO1xuICAgICAgaWYgKGkgPT09IGopIHtcbiAgICAgICAgZGlzdFtuXSA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkaXN0W25dID0gSW5maW5pdHk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSW5pdGlhbGl6ZSBtYXRyaXggdXNlZCBmb3IgcGF0aCByZWNvbnN0cnVjdGlvblxuICAgIC8vIEluaXRpYWxpemUgZGlzdGFuY2UgbWF0cml4XG4gICAgdmFyIG5leHQgPSBuZXcgQXJyYXkoTnNxKTtcbiAgICB2YXIgZWRnZU5leHQgPSBuZXcgQXJyYXkoTnNxKTtcblxuICAgIC8vIFByb2Nlc3MgZWRnZXNcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgZWRnZXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICB2YXIgZWRnZSA9IGVkZ2VzW19pXTtcbiAgICAgIHZhciBzcmMgPSBlZGdlLnNvdXJjZSgpWzBdO1xuICAgICAgdmFyIHRndCA9IGVkZ2UudGFyZ2V0KClbMF07XG4gICAgICBpZiAoc3JjID09PSB0Z3QpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IC8vIGV4Y2x1ZGUgbG9vcHNcblxuICAgICAgdmFyIHMgPSBpbmRleE9mKHNyYyk7XG4gICAgICB2YXIgdCA9IGluZGV4T2YodGd0KTtcbiAgICAgIHZhciBzdCA9IHMgKiBOICsgdDsgLy8gc291cmNlIHRvIHRhcmdldCBpbmRleFxuICAgICAgdmFyIF93ZWlnaHQgPSB3ZWlnaHRGbihlZGdlKTtcblxuICAgICAgLy8gQ2hlY2sgaWYgYWxyZWFkeSBwcm9jZXNzIGFub3RoZXIgZWRnZSBiZXR3ZWVuIHNhbWUgMiBub2Rlc1xuICAgICAgaWYgKGRpc3Rbc3RdID4gX3dlaWdodCkge1xuICAgICAgICBkaXN0W3N0XSA9IF93ZWlnaHQ7XG4gICAgICAgIG5leHRbc3RdID0gdDtcbiAgICAgICAgZWRnZU5leHRbc3RdID0gZWRnZTtcbiAgICAgIH1cblxuICAgICAgLy8gSWYgdW5kaXJlY3RlZCBncmFwaCwgcHJvY2VzcyAncmV2ZXJzZWQnIGVkZ2VcbiAgICAgIGlmICghZGlyZWN0ZWQpIHtcbiAgICAgICAgdmFyIHRzID0gdCAqIE4gKyBzOyAvLyB0YXJnZXQgdG8gc291cmNlIGluZGV4XG5cbiAgICAgICAgaWYgKCFkaXJlY3RlZCAmJiBkaXN0W3RzXSA+IF93ZWlnaHQpIHtcbiAgICAgICAgICBkaXN0W3RzXSA9IF93ZWlnaHQ7XG4gICAgICAgICAgbmV4dFt0c10gPSBzO1xuICAgICAgICAgIGVkZ2VOZXh0W3RzXSA9IGVkZ2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBNYWluIGxvb3BcbiAgICBmb3IgKHZhciBrID0gMDsgayA8IE47IGsrKykge1xuICAgICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgTjsgX2kyKyspIHtcbiAgICAgICAgdmFyIGlrID0gX2kyICogTiArIGs7XG4gICAgICAgIGZvciAodmFyIF9qID0gMDsgX2ogPCBOOyBfaisrKSB7XG4gICAgICAgICAgdmFyIGlqID0gX2kyICogTiArIF9qO1xuICAgICAgICAgIHZhciBraiA9IGsgKiBOICsgX2o7XG4gICAgICAgICAgaWYgKGRpc3RbaWtdICsgZGlzdFtral0gPCBkaXN0W2lqXSkge1xuICAgICAgICAgICAgZGlzdFtpal0gPSBkaXN0W2lrXSArIGRpc3Rba2pdO1xuICAgICAgICAgICAgbmV4dFtpal0gPSBuZXh0W2lrXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIGdldEFyZ0VsZSA9IGZ1bmN0aW9uIGdldEFyZ0VsZShlbGUpIHtcbiAgICAgIHJldHVybiAoc3RyaW5nKGVsZSkgPyBjeS5maWx0ZXIoZWxlKSA6IGVsZSlbMF07XG4gICAgfTtcbiAgICB2YXIgaW5kZXhPZkFyZ0VsZSA9IGZ1bmN0aW9uIGluZGV4T2ZBcmdFbGUoZWxlKSB7XG4gICAgICByZXR1cm4gaW5kZXhPZihnZXRBcmdFbGUoZWxlKSk7XG4gICAgfTtcbiAgICB2YXIgcmVzID0ge1xuICAgICAgZGlzdGFuY2U6IGZ1bmN0aW9uIGRpc3RhbmNlKGZyb20sIHRvKSB7XG4gICAgICAgIHZhciBpID0gaW5kZXhPZkFyZ0VsZShmcm9tKTtcbiAgICAgICAgdmFyIGogPSBpbmRleE9mQXJnRWxlKHRvKTtcbiAgICAgICAgcmV0dXJuIGRpc3RbaSAqIE4gKyBqXTtcbiAgICAgIH0sXG4gICAgICBwYXRoOiBmdW5jdGlvbiBwYXRoKGZyb20sIHRvKSB7XG4gICAgICAgIHZhciBpID0gaW5kZXhPZkFyZ0VsZShmcm9tKTtcbiAgICAgICAgdmFyIGogPSBpbmRleE9mQXJnRWxlKHRvKTtcbiAgICAgICAgdmFyIGZyb21Ob2RlID0gYXRJbmRleChpKTtcbiAgICAgICAgaWYgKGkgPT09IGopIHtcbiAgICAgICAgICByZXR1cm4gZnJvbU5vZGUuY29sbGVjdGlvbigpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuZXh0W2kgKiBOICsgal0gPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBjeS5jb2xsZWN0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBhdGggPSBjeS5jb2xsZWN0aW9uKCk7XG4gICAgICAgIHZhciBwcmV2ID0gaTtcbiAgICAgICAgdmFyIGVkZ2U7XG4gICAgICAgIHBhdGgubWVyZ2UoZnJvbU5vZGUpO1xuICAgICAgICB3aGlsZSAoaSAhPT0gaikge1xuICAgICAgICAgIHByZXYgPSBpO1xuICAgICAgICAgIGkgPSBuZXh0W2kgKiBOICsgal07XG4gICAgICAgICAgZWRnZSA9IGVkZ2VOZXh0W3ByZXYgKiBOICsgaV07XG4gICAgICAgICAgcGF0aC5tZXJnZShlZGdlKTtcbiAgICAgICAgICBwYXRoLm1lcmdlKGF0SW5kZXgoaSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXRoO1xuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIHJlcztcbiAgfSAvLyBmbG95ZFdhcnNoYWxsXG59OyAvLyBlbGVzZm5cblxudmFyIGJlbGxtYW5Gb3JkRGVmYXVsdHMgPSBkZWZhdWx0cyRnKHtcbiAgd2VpZ2h0OiBmdW5jdGlvbiB3ZWlnaHQoZWRnZSkge1xuICAgIHJldHVybiAxO1xuICB9LFxuICBkaXJlY3RlZDogZmFsc2UsXG4gIHJvb3Q6IG51bGxcbn0pO1xudmFyIGVsZXNmbiRxID0ge1xuICAvLyBJbXBsZW1lbnRlZCBmcm9tIHBzZXVkb2NvZGUgZnJvbSB3aWtpcGVkaWFcbiAgYmVsbG1hbkZvcmQ6IGZ1bmN0aW9uIGJlbGxtYW5Gb3JkKG9wdGlvbnMpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIHZhciBfYmVsbG1hbkZvcmREZWZhdWx0cyA9IGJlbGxtYW5Gb3JkRGVmYXVsdHMob3B0aW9ucyksXG4gICAgICB3ZWlnaHQgPSBfYmVsbG1hbkZvcmREZWZhdWx0cy53ZWlnaHQsXG4gICAgICBkaXJlY3RlZCA9IF9iZWxsbWFuRm9yZERlZmF1bHRzLmRpcmVjdGVkLFxuICAgICAgcm9vdCA9IF9iZWxsbWFuRm9yZERlZmF1bHRzLnJvb3Q7XG4gICAgdmFyIHdlaWdodEZuID0gd2VpZ2h0O1xuICAgIHZhciBlbGVzID0gdGhpcztcbiAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG4gICAgdmFyIF90aGlzJGJ5R3JvdXAgPSB0aGlzLmJ5R3JvdXAoKSxcbiAgICAgIGVkZ2VzID0gX3RoaXMkYnlHcm91cC5lZGdlcyxcbiAgICAgIG5vZGVzID0gX3RoaXMkYnlHcm91cC5ub2RlcztcbiAgICB2YXIgbnVtTm9kZXMgPSBub2Rlcy5sZW5ndGg7XG4gICAgdmFyIGluZm9NYXAgPSBuZXcgTWFwJDIoKTtcbiAgICB2YXIgaGFzTmVnYXRpdmVXZWlnaHRDeWNsZSA9IGZhbHNlO1xuICAgIHZhciBuZWdhdGl2ZVdlaWdodEN5Y2xlcyA9IFtdO1xuICAgIHJvb3QgPSBjeS5jb2xsZWN0aW9uKHJvb3QpWzBdOyAvLyBpbiBjYXNlIHNlbGVjdG9yIHBhc3NlZFxuXG4gICAgZWRnZXMudW5tZXJnZUJ5KGZ1bmN0aW9uIChlZGdlKSB7XG4gICAgICByZXR1cm4gZWRnZS5pc0xvb3AoKTtcbiAgICB9KTtcbiAgICB2YXIgbnVtRWRnZXMgPSBlZGdlcy5sZW5ndGg7XG4gICAgdmFyIGdldEluZm8gPSBmdW5jdGlvbiBnZXRJbmZvKG5vZGUpIHtcbiAgICAgIHZhciBvYmogPSBpbmZvTWFwLmdldChub2RlLmlkKCkpO1xuICAgICAgaWYgKCFvYmopIHtcbiAgICAgICAgb2JqID0ge307XG4gICAgICAgIGluZm9NYXAuc2V0KG5vZGUuaWQoKSwgb2JqKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmo7XG4gICAgfTtcbiAgICB2YXIgZ2V0Tm9kZUZyb21UbyA9IGZ1bmN0aW9uIGdldE5vZGVGcm9tVG8odG8pIHtcbiAgICAgIHJldHVybiAoc3RyaW5nKHRvKSA/IGN5LiQodG8pIDogdG8pWzBdO1xuICAgIH07XG4gICAgdmFyIGRpc3RhbmNlVG8gPSBmdW5jdGlvbiBkaXN0YW5jZVRvKHRvKSB7XG4gICAgICByZXR1cm4gZ2V0SW5mbyhnZXROb2RlRnJvbVRvKHRvKSkuZGlzdDtcbiAgICB9O1xuICAgIHZhciBwYXRoVG8gPSBmdW5jdGlvbiBwYXRoVG8odG8pIHtcbiAgICAgIHZhciB0aGlzU3RhcnQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHJvb3Q7XG4gICAgICB2YXIgZW5kID0gZ2V0Tm9kZUZyb21Ubyh0byk7XG4gICAgICB2YXIgcGF0aCA9IFtdO1xuICAgICAgdmFyIG5vZGUgPSBlbmQ7XG4gICAgICBmb3IgKDs7KSB7XG4gICAgICAgIGlmIChub2RlID09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMuc3Bhd24oKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgX2dldEluZm8gPSBnZXRJbmZvKG5vZGUpLFxuICAgICAgICAgIGVkZ2UgPSBfZ2V0SW5mby5lZGdlLFxuICAgICAgICAgIHByZWQgPSBfZ2V0SW5mby5wcmVkO1xuICAgICAgICBwYXRoLnVuc2hpZnQobm9kZVswXSk7XG4gICAgICAgIGlmIChub2RlLnNhbWUodGhpc1N0YXJ0KSAmJiBwYXRoLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoZWRnZSAhPSBudWxsKSB7XG4gICAgICAgICAgcGF0aC51bnNoaWZ0KGVkZ2UpO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUgPSBwcmVkO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGVsZXMuc3Bhd24ocGF0aCk7XG4gICAgfTtcblxuICAgIC8vIEluaXRpYWxpemF0aW9ucyB7IGRpc3QsIHByZWQsIGVkZ2UgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtTm9kZXM7IGkrKykge1xuICAgICAgdmFyIG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgIHZhciBpbmZvID0gZ2V0SW5mbyhub2RlKTtcbiAgICAgIGlmIChub2RlLnNhbWUocm9vdCkpIHtcbiAgICAgICAgaW5mby5kaXN0ID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluZm8uZGlzdCA9IEluZmluaXR5O1xuICAgICAgfVxuICAgICAgaW5mby5wcmVkID0gbnVsbDtcbiAgICAgIGluZm8uZWRnZSA9IG51bGw7XG4gICAgfVxuXG4gICAgLy8gRWRnZXMgcmVsYXhhdGlvblxuICAgIHZhciByZXBsYWNlZEVkZ2UgPSBmYWxzZTtcbiAgICB2YXIgY2hlY2tGb3JFZGdlUmVwbGFjZW1lbnQgPSBmdW5jdGlvbiBjaGVja0ZvckVkZ2VSZXBsYWNlbWVudChub2RlMSwgbm9kZTIsIGVkZ2UsIGluZm8xLCBpbmZvMiwgd2VpZ2h0KSB7XG4gICAgICB2YXIgZGlzdCA9IGluZm8xLmRpc3QgKyB3ZWlnaHQ7XG4gICAgICBpZiAoZGlzdCA8IGluZm8yLmRpc3QgJiYgIWVkZ2Uuc2FtZShpbmZvMS5lZGdlKSkge1xuICAgICAgICBpbmZvMi5kaXN0ID0gZGlzdDtcbiAgICAgICAgaW5mbzIucHJlZCA9IG5vZGUxO1xuICAgICAgICBpbmZvMi5lZGdlID0gZWRnZTtcbiAgICAgICAgcmVwbGFjZWRFZGdlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBudW1Ob2RlczsgX2krKykge1xuICAgICAgcmVwbGFjZWRFZGdlID0gZmFsc2U7XG4gICAgICBmb3IgKHZhciBlID0gMDsgZSA8IG51bUVkZ2VzOyBlKyspIHtcbiAgICAgICAgdmFyIGVkZ2UgPSBlZGdlc1tlXTtcbiAgICAgICAgdmFyIHNyYyA9IGVkZ2Uuc291cmNlKCk7XG4gICAgICAgIHZhciB0Z3QgPSBlZGdlLnRhcmdldCgpO1xuICAgICAgICB2YXIgX3dlaWdodCA9IHdlaWdodEZuKGVkZ2UpO1xuICAgICAgICB2YXIgc3JjSW5mbyA9IGdldEluZm8oc3JjKTtcbiAgICAgICAgdmFyIHRndEluZm8gPSBnZXRJbmZvKHRndCk7XG4gICAgICAgIGNoZWNrRm9yRWRnZVJlcGxhY2VtZW50KHNyYywgdGd0LCBlZGdlLCBzcmNJbmZvLCB0Z3RJbmZvLCBfd2VpZ2h0KTtcblxuICAgICAgICAvLyBJZiB1bmRpcmVjdGVkIGdyYXBoLCB3ZSBuZWVkIHRvIHRha2UgaW50byBhY2NvdW50IHRoZSAncmV2ZXJzZScgZWRnZVxuICAgICAgICBpZiAoIWRpcmVjdGVkKSB7XG4gICAgICAgICAgY2hlY2tGb3JFZGdlUmVwbGFjZW1lbnQodGd0LCBzcmMsIGVkZ2UsIHRndEluZm8sIHNyY0luZm8sIF93ZWlnaHQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIXJlcGxhY2VkRWRnZSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHJlcGxhY2VkRWRnZSkge1xuICAgICAgLy8gQ2hlY2sgZm9yIG5lZ2F0aXZlIHdlaWdodCBjeWNsZXNcbiAgICAgIHZhciBuZWdhdGl2ZVdlaWdodEN5Y2xlSWRzID0gW107XG4gICAgICBmb3IgKHZhciBfZSA9IDA7IF9lIDwgbnVtRWRnZXM7IF9lKyspIHtcbiAgICAgICAgdmFyIF9lZGdlID0gZWRnZXNbX2VdO1xuICAgICAgICB2YXIgX3NyYyA9IF9lZGdlLnNvdXJjZSgpO1xuICAgICAgICB2YXIgX3RndCA9IF9lZGdlLnRhcmdldCgpO1xuICAgICAgICB2YXIgX3dlaWdodDIgPSB3ZWlnaHRGbihfZWRnZSk7XG4gICAgICAgIHZhciBzcmNEaXN0ID0gZ2V0SW5mbyhfc3JjKS5kaXN0O1xuICAgICAgICB2YXIgdGd0RGlzdCA9IGdldEluZm8oX3RndCkuZGlzdDtcbiAgICAgICAgaWYgKHNyY0Rpc3QgKyBfd2VpZ2h0MiA8IHRndERpc3QgfHwgIWRpcmVjdGVkICYmIHRndERpc3QgKyBfd2VpZ2h0MiA8IHNyY0Rpc3QpIHtcbiAgICAgICAgICBpZiAoIWhhc05lZ2F0aXZlV2VpZ2h0Q3ljbGUpIHtcbiAgICAgICAgICAgIHdhcm4oJ0dyYXBoIGNvbnRhaW5zIGEgbmVnYXRpdmUgd2VpZ2h0IGN5Y2xlIGZvciBCZWxsbWFuLUZvcmQnKTtcbiAgICAgICAgICAgIGhhc05lZ2F0aXZlV2VpZ2h0Q3ljbGUgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAob3B0aW9ucy5maW5kTmVnYXRpdmVXZWlnaHRDeWNsZXMgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICB2YXIgbmVnYXRpdmVOb2RlcyA9IFtdO1xuICAgICAgICAgICAgaWYgKHNyY0Rpc3QgKyBfd2VpZ2h0MiA8IHRndERpc3QpIHtcbiAgICAgICAgICAgICAgbmVnYXRpdmVOb2Rlcy5wdXNoKF9zcmMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFkaXJlY3RlZCAmJiB0Z3REaXN0ICsgX3dlaWdodDIgPCBzcmNEaXN0KSB7XG4gICAgICAgICAgICAgIG5lZ2F0aXZlTm9kZXMucHVzaChfdGd0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBudW1OZWdhdGl2ZU5vZGVzID0gbmVnYXRpdmVOb2Rlcy5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKHZhciBuID0gMDsgbiA8IG51bU5lZ2F0aXZlTm9kZXM7IG4rKykge1xuICAgICAgICAgICAgICB2YXIgc3RhcnQgPSBuZWdhdGl2ZU5vZGVzW25dO1xuICAgICAgICAgICAgICB2YXIgY3ljbGUgPSBbc3RhcnRdO1xuICAgICAgICAgICAgICBjeWNsZS5wdXNoKGdldEluZm8oc3RhcnQpLmVkZ2UpO1xuICAgICAgICAgICAgICB2YXIgX25vZGUgPSBnZXRJbmZvKHN0YXJ0KS5wcmVkO1xuICAgICAgICAgICAgICB3aGlsZSAoY3ljbGUuaW5kZXhPZihfbm9kZSkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgY3ljbGUucHVzaChfbm9kZSk7XG4gICAgICAgICAgICAgICAgY3ljbGUucHVzaChnZXRJbmZvKF9ub2RlKS5lZGdlKTtcbiAgICAgICAgICAgICAgICBfbm9kZSA9IGdldEluZm8oX25vZGUpLnByZWQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY3ljbGUgPSBjeWNsZS5zbGljZShjeWNsZS5pbmRleE9mKF9ub2RlKSk7XG4gICAgICAgICAgICAgIHZhciBzbWFsbGVzdElkID0gY3ljbGVbMF0uaWQoKTtcbiAgICAgICAgICAgICAgdmFyIHNtYWxsZXN0SW5kZXggPSAwO1xuICAgICAgICAgICAgICBmb3IgKHZhciBjID0gMjsgYyA8IGN5Y2xlLmxlbmd0aDsgYyArPSAyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGN5Y2xlW2NdLmlkKCkgPCBzbWFsbGVzdElkKSB7XG4gICAgICAgICAgICAgICAgICBzbWFsbGVzdElkID0gY3ljbGVbY10uaWQoKTtcbiAgICAgICAgICAgICAgICAgIHNtYWxsZXN0SW5kZXggPSBjO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjeWNsZSA9IGN5Y2xlLnNsaWNlKHNtYWxsZXN0SW5kZXgpLmNvbmNhdChjeWNsZS5zbGljZSgwLCBzbWFsbGVzdEluZGV4KSk7XG4gICAgICAgICAgICAgIGN5Y2xlLnB1c2goY3ljbGVbMF0pO1xuICAgICAgICAgICAgICB2YXIgY3ljbGVJZCA9IGN5Y2xlLm1hcChmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZWwuaWQoKTtcbiAgICAgICAgICAgICAgfSkuam9pbihcIixcIik7XG4gICAgICAgICAgICAgIGlmIChuZWdhdGl2ZVdlaWdodEN5Y2xlSWRzLmluZGV4T2YoY3ljbGVJZCkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgbmVnYXRpdmVXZWlnaHRDeWNsZXMucHVzaChlbGVzLnNwYXduKGN5Y2xlKSk7XG4gICAgICAgICAgICAgICAgbmVnYXRpdmVXZWlnaHRDeWNsZUlkcy5wdXNoKGN5Y2xlSWQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgZGlzdGFuY2VUbzogZGlzdGFuY2VUbyxcbiAgICAgIHBhdGhUbzogcGF0aFRvLFxuICAgICAgaGFzTmVnYXRpdmVXZWlnaHRDeWNsZTogaGFzTmVnYXRpdmVXZWlnaHRDeWNsZSxcbiAgICAgIG5lZ2F0aXZlV2VpZ2h0Q3ljbGVzOiBuZWdhdGl2ZVdlaWdodEN5Y2xlc1xuICAgIH07XG4gIH0gLy8gYmVsbG1hbkZvcmRcbn07IC8vIGVsZXNmblxuXG52YXIgc3FydDIgPSBNYXRoLnNxcnQoMik7XG5cbi8vIEZ1bmN0aW9uIHdoaWNoIGNvbGFwc2VzIDIgKG1ldGEpIG5vZGVzIGludG8gb25lXG4vLyBVcGRhdGVzIHRoZSByZW1haW5pbmcgZWRnZSBsaXN0c1xuLy8gUmVjZWl2ZXMgYXMgYSBwYXJhbWF0ZXIgdGhlIGVkZ2Ugd2hpY2ggY2F1c2VzIHRoZSBjb2xsYXBzZVxudmFyIGNvbGxhcHNlID0gZnVuY3Rpb24gY29sbGFwc2UoZWRnZUluZGV4LCBub2RlTWFwLCByZW1haW5pbmdFZGdlcykge1xuICBpZiAocmVtYWluaW5nRWRnZXMubGVuZ3RoID09PSAwKSB7XG4gICAgZXJyb3IoXCJLYXJnZXItU3RlaW4gbXVzdCBiZSBydW4gb24gYSBjb25uZWN0ZWQgKHN1YilncmFwaFwiKTtcbiAgfVxuICB2YXIgZWRnZUluZm8gPSByZW1haW5pbmdFZGdlc1tlZGdlSW5kZXhdO1xuICB2YXIgc291cmNlSW4gPSBlZGdlSW5mb1sxXTtcbiAgdmFyIHRhcmdldEluID0gZWRnZUluZm9bMl07XG4gIHZhciBwYXJ0aXRpb24xID0gbm9kZU1hcFtzb3VyY2VJbl07XG4gIHZhciBwYXJ0aXRpb24yID0gbm9kZU1hcFt0YXJnZXRJbl07XG4gIHZhciBuZXdFZGdlcyA9IHJlbWFpbmluZ0VkZ2VzOyAvLyByZS11c2UgYXJyYXlcblxuICAvLyBEZWxldGUgYWxsIGVkZ2VzIGJldHdlZW4gcGFydGl0aW9uMSBhbmQgcGFydGl0aW9uMlxuICBmb3IgKHZhciBpID0gbmV3RWRnZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICB2YXIgZWRnZSA9IG5ld0VkZ2VzW2ldO1xuICAgIHZhciBzcmMgPSBlZGdlWzFdO1xuICAgIHZhciB0Z3QgPSBlZGdlWzJdO1xuICAgIGlmIChub2RlTWFwW3NyY10gPT09IHBhcnRpdGlvbjEgJiYgbm9kZU1hcFt0Z3RdID09PSBwYXJ0aXRpb24yIHx8IG5vZGVNYXBbc3JjXSA9PT0gcGFydGl0aW9uMiAmJiBub2RlTWFwW3RndF0gPT09IHBhcnRpdGlvbjEpIHtcbiAgICAgIG5ld0VkZ2VzLnNwbGljZShpLCAxKTtcbiAgICB9XG4gIH1cblxuICAvLyBBbGwgZWRnZXMgcG9pbnRpbmcgdG8gcGFydGl0aW9uMiBzaG91bGQgbm93IHBvaW50IHRvIHBhcnRpdGlvbjFcbiAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IG5ld0VkZ2VzLmxlbmd0aDsgX2krKykge1xuICAgIHZhciBfZWRnZSA9IG5ld0VkZ2VzW19pXTtcbiAgICBpZiAoX2VkZ2VbMV0gPT09IHBhcnRpdGlvbjIpIHtcbiAgICAgIC8vIENoZWNrIHNvdXJjZVxuICAgICAgbmV3RWRnZXNbX2ldID0gX2VkZ2Uuc2xpY2UoKTsgLy8gY29weVxuICAgICAgbmV3RWRnZXNbX2ldWzFdID0gcGFydGl0aW9uMTtcbiAgICB9IGVsc2UgaWYgKF9lZGdlWzJdID09PSBwYXJ0aXRpb24yKSB7XG4gICAgICAvLyBDaGVjayB0YXJnZXRcbiAgICAgIG5ld0VkZ2VzW19pXSA9IF9lZGdlLnNsaWNlKCk7IC8vIGNvcHlcbiAgICAgIG5ld0VkZ2VzW19pXVsyXSA9IHBhcnRpdGlvbjE7XG4gICAgfVxuICB9XG5cbiAgLy8gTW92ZSBhbGwgbm9kZXMgZnJvbSBwYXJ0aXRpb24yIHRvIHBhcnRpdGlvbjFcbiAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgbm9kZU1hcC5sZW5ndGg7IF9pMisrKSB7XG4gICAgaWYgKG5vZGVNYXBbX2kyXSA9PT0gcGFydGl0aW9uMikge1xuICAgICAgbm9kZU1hcFtfaTJdID0gcGFydGl0aW9uMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5ld0VkZ2VzO1xufTtcblxuLy8gQ29udHJhY3RzIGEgZ3JhcGggdW50aWwgd2UgcmVhY2ggYSBjZXJ0YWluIG51bWJlciBvZiBtZXRhIG5vZGVzXG52YXIgY29udHJhY3RVbnRpbCA9IGZ1bmN0aW9uIGNvbnRyYWN0VW50aWwobWV0YU5vZGVNYXAsIHJlbWFpbmluZ0VkZ2VzLCBzaXplLCBzaXplTGltaXQpIHtcbiAgd2hpbGUgKHNpemUgPiBzaXplTGltaXQpIHtcbiAgICAvLyBDaG9vc2UgYW4gZWRnZSByYW5kb21seVxuICAgIHZhciBlZGdlSW5kZXggPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiByZW1haW5pbmdFZGdlcy5sZW5ndGgpO1xuXG4gICAgLy8gQ29sbGFwc2UgZ3JhcGggYmFzZWQgb24gZWRnZVxuICAgIHJlbWFpbmluZ0VkZ2VzID0gY29sbGFwc2UoZWRnZUluZGV4LCBtZXRhTm9kZU1hcCwgcmVtYWluaW5nRWRnZXMpO1xuICAgIHNpemUtLTtcbiAgfVxuICByZXR1cm4gcmVtYWluaW5nRWRnZXM7XG59O1xudmFyIGVsZXNmbiRwID0ge1xuICAvLyBDb21wdXRlcyB0aGUgbWluaW11bSBjdXQgb2YgYW4gdW5kaXJlY3RlZCBncmFwaFxuICAvLyBSZXR1cm5zIHRoZSBjb3JyZWN0IGFuc3dlciB3aXRoIGhpZ2ggcHJvYmFiaWxpdHlcbiAga2FyZ2VyU3RlaW46IGZ1bmN0aW9uIGthcmdlclN0ZWluKCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgdmFyIF90aGlzJGJ5R3JvdXAgPSB0aGlzLmJ5R3JvdXAoKSxcbiAgICAgIG5vZGVzID0gX3RoaXMkYnlHcm91cC5ub2RlcyxcbiAgICAgIGVkZ2VzID0gX3RoaXMkYnlHcm91cC5lZGdlcztcbiAgICBlZGdlcy51bm1lcmdlQnkoZnVuY3Rpb24gKGVkZ2UpIHtcbiAgICAgIHJldHVybiBlZGdlLmlzTG9vcCgpO1xuICAgIH0pO1xuICAgIHZhciBudW1Ob2RlcyA9IG5vZGVzLmxlbmd0aDtcbiAgICB2YXIgbnVtRWRnZXMgPSBlZGdlcy5sZW5ndGg7XG4gICAgdmFyIG51bUl0ZXIgPSBNYXRoLmNlaWwoTWF0aC5wb3coTWF0aC5sb2cobnVtTm9kZXMpIC8gTWF0aC5MTjIsIDIpKTtcbiAgICB2YXIgc3RvcFNpemUgPSBNYXRoLmZsb29yKG51bU5vZGVzIC8gc3FydDIpO1xuICAgIGlmIChudW1Ob2RlcyA8IDIpIHtcbiAgICAgIGVycm9yKCdBdCBsZWFzdCAyIG5vZGVzIGFyZSByZXF1aXJlZCBmb3IgS2FyZ2VyLVN0ZWluIGFsZ29yaXRobScpO1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvLyBOb3cgc3RvcmUgZWRnZSBkZXN0aW5hdGlvbiBhcyBpbmRleGVzXG4gICAgLy8gRm9ybWF0IGZvciBlYWNoIGVkZ2UgKGVkZ2UgaW5kZXgsIHNvdXJjZSBub2RlIGluZGV4LCB0YXJnZXQgbm9kZSBpbmRleClcbiAgICB2YXIgZWRnZUluZGV4ZXMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bUVkZ2VzOyBpKyspIHtcbiAgICAgIHZhciBlID0gZWRnZXNbaV07XG4gICAgICBlZGdlSW5kZXhlcy5wdXNoKFtpLCBub2Rlcy5pbmRleE9mKGUuc291cmNlKCkpLCBub2Rlcy5pbmRleE9mKGUudGFyZ2V0KCkpXSk7XG4gICAgfVxuXG4gICAgLy8gV2Ugd2lsbCBzdG9yZSB0aGUgYmVzdCBjdXQgZm91bmQgaGVyZVxuICAgIHZhciBtaW5DdXRTaXplID0gSW5maW5pdHk7XG4gICAgdmFyIG1pbkN1dEVkZ2VJbmRleGVzID0gW107XG4gICAgdmFyIG1pbkN1dE5vZGVNYXAgPSBuZXcgQXJyYXkobnVtTm9kZXMpO1xuXG4gICAgLy8gSW5pdGlhbCBtZXRhIG5vZGUgcGFydGl0aW9uXG4gICAgdmFyIG1ldGFOb2RlTWFwID0gbmV3IEFycmF5KG51bU5vZGVzKTtcbiAgICB2YXIgbWV0YU5vZGVNYXAyID0gbmV3IEFycmF5KG51bU5vZGVzKTtcbiAgICB2YXIgY29weU5vZGVzTWFwID0gZnVuY3Rpb24gY29weU5vZGVzTWFwKGZyb20sIHRvKSB7XG4gICAgICBmb3IgKHZhciBfaTMgPSAwOyBfaTMgPCBudW1Ob2RlczsgX2kzKyspIHtcbiAgICAgICAgdG9bX2kzXSA9IGZyb21bX2kzXTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gTWFpbiBsb29wXG4gICAgZm9yICh2YXIgaXRlciA9IDA7IGl0ZXIgPD0gbnVtSXRlcjsgaXRlcisrKSB7XG4gICAgICAvLyBSZXNldCBtZXRhIG5vZGUgcGFydGl0aW9uXG4gICAgICBmb3IgKHZhciBfaTQgPSAwOyBfaTQgPCBudW1Ob2RlczsgX2k0KyspIHtcbiAgICAgICAgbWV0YU5vZGVNYXBbX2k0XSA9IF9pNDtcbiAgICAgIH1cblxuICAgICAgLy8gQ29udHJhY3QgdW50aWwgc3RvcCBwb2ludCAoc3RvcFNpemUgbm9kZXMpXG4gICAgICB2YXIgZWRnZXNTdGF0ZSA9IGNvbnRyYWN0VW50aWwobWV0YU5vZGVNYXAsIGVkZ2VJbmRleGVzLnNsaWNlKCksIG51bU5vZGVzLCBzdG9wU2l6ZSk7XG4gICAgICB2YXIgZWRnZXNTdGF0ZTIgPSBlZGdlc1N0YXRlLnNsaWNlKCk7IC8vIGNvcHlcblxuICAgICAgLy8gQ3JlYXRlIGEgY29weSBvZiB0aGUgY29sYXBzZWQgbm9kZXMgc3RhdGVcbiAgICAgIGNvcHlOb2Rlc01hcChtZXRhTm9kZU1hcCwgbWV0YU5vZGVNYXAyKTtcblxuICAgICAgLy8gUnVuIDIgaXRlcmF0aW9ucyBzdGFydGluZyBpbiB0aGUgc3RvcCBzdGF0ZVxuICAgICAgdmFyIHJlczEgPSBjb250cmFjdFVudGlsKG1ldGFOb2RlTWFwLCBlZGdlc1N0YXRlLCBzdG9wU2l6ZSwgMik7XG4gICAgICB2YXIgcmVzMiA9IGNvbnRyYWN0VW50aWwobWV0YU5vZGVNYXAyLCBlZGdlc1N0YXRlMiwgc3RvcFNpemUsIDIpO1xuXG4gICAgICAvLyBJcyBhbnkgb2YgdGhlIDIgcmVzdWx0cyB0aGUgYmVzdCBjdXQgc28gZmFyP1xuICAgICAgaWYgKHJlczEubGVuZ3RoIDw9IHJlczIubGVuZ3RoICYmIHJlczEubGVuZ3RoIDwgbWluQ3V0U2l6ZSkge1xuICAgICAgICBtaW5DdXRTaXplID0gcmVzMS5sZW5ndGg7XG4gICAgICAgIG1pbkN1dEVkZ2VJbmRleGVzID0gcmVzMTtcbiAgICAgICAgY29weU5vZGVzTWFwKG1ldGFOb2RlTWFwLCBtaW5DdXROb2RlTWFwKTtcbiAgICAgIH0gZWxzZSBpZiAocmVzMi5sZW5ndGggPD0gcmVzMS5sZW5ndGggJiYgcmVzMi5sZW5ndGggPCBtaW5DdXRTaXplKSB7XG4gICAgICAgIG1pbkN1dFNpemUgPSByZXMyLmxlbmd0aDtcbiAgICAgICAgbWluQ3V0RWRnZUluZGV4ZXMgPSByZXMyO1xuICAgICAgICBjb3B5Tm9kZXNNYXAobWV0YU5vZGVNYXAyLCBtaW5DdXROb2RlTWFwKTtcbiAgICAgIH1cbiAgICB9IC8vIGVuZCBvZiBtYWluIGxvb3BcblxuICAgIC8vIENvbnN0cnVjdCByZXN1bHRcbiAgICB2YXIgY3V0ID0gdGhpcy5zcGF3bihtaW5DdXRFZGdlSW5kZXhlcy5tYXAoZnVuY3Rpb24gKGUpIHtcbiAgICAgIHJldHVybiBlZGdlc1tlWzBdXTtcbiAgICB9KSk7XG4gICAgdmFyIHBhcnRpdGlvbjEgPSB0aGlzLnNwYXduKCk7XG4gICAgdmFyIHBhcnRpdGlvbjIgPSB0aGlzLnNwYXduKCk7XG5cbiAgICAvLyB0cmF2ZXJzZSBtZXRhTm9kZU1hcCBmb3IgYmVzdCBjdXRcbiAgICB2YXIgd2l0bmVzc05vZGVQYXJ0aXRpb24gPSBtaW5DdXROb2RlTWFwWzBdO1xuICAgIGZvciAodmFyIF9pNSA9IDA7IF9pNSA8IG1pbkN1dE5vZGVNYXAubGVuZ3RoOyBfaTUrKykge1xuICAgICAgdmFyIHBhcnRpdGlvbklkID0gbWluQ3V0Tm9kZU1hcFtfaTVdO1xuICAgICAgdmFyIG5vZGUgPSBub2Rlc1tfaTVdO1xuICAgICAgaWYgKHBhcnRpdGlvbklkID09PSB3aXRuZXNzTm9kZVBhcnRpdGlvbikge1xuICAgICAgICBwYXJ0aXRpb24xLm1lcmdlKG5vZGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFydGl0aW9uMi5tZXJnZShub2RlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBjb25zdHJ1Y3QgY29tcG9uZW50cyBjb3JyZXNwb25kaW5nIHRvIGVhY2ggZGlzam9pbnQgc3Vic2V0IG9mIG5vZGVzXG4gICAgdmFyIGNvbnN0cnVjdENvbXBvbmVudCA9IGZ1bmN0aW9uIGNvbnN0cnVjdENvbXBvbmVudChzdWJzZXQpIHtcbiAgICAgIHZhciBjb21wb25lbnQgPSBfdGhpcy5zcGF3bigpO1xuICAgICAgc3Vic2V0LmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgY29tcG9uZW50Lm1lcmdlKG5vZGUpO1xuICAgICAgICBub2RlLmNvbm5lY3RlZEVkZ2VzKCkuZm9yRWFjaChmdW5jdGlvbiAoZWRnZSkge1xuICAgICAgICAgIC8vIGVuc3VyZSBlZGdlIGlzIHdpdGhpbiBjYWxsaW5nIGNvbGxlY3Rpb24gYW5kIGVkZ2UgaXMgbm90IGluIGN1dFxuICAgICAgICAgIGlmIChfdGhpcy5jb250YWlucyhlZGdlKSAmJiAhY3V0LmNvbnRhaW5zKGVkZ2UpKSB7XG4gICAgICAgICAgICBjb21wb25lbnQubWVyZ2UoZWRnZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGNvbXBvbmVudDtcbiAgICB9O1xuICAgIHZhciBjb21wb25lbnRzID0gW2NvbnN0cnVjdENvbXBvbmVudChwYXJ0aXRpb24xKSwgY29uc3RydWN0Q29tcG9uZW50KHBhcnRpdGlvbjIpXTtcbiAgICB2YXIgcmV0ID0ge1xuICAgICAgY3V0OiBjdXQsXG4gICAgICBjb21wb25lbnRzOiBjb21wb25lbnRzLFxuICAgICAgLy8gbi5iLiBwYXJ0aXRpb25zIGFyZSBpbmNsdWRlZCB0byBiZSBjb21wYXRpYmxlIHdpdGggdGhlIG9sZCBhcGkgc3BlY1xuICAgICAgLy8gKGNvdWxkIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgbWFqb3IgdmVyc2lvbilcbiAgICAgIHBhcnRpdGlvbjE6IHBhcnRpdGlvbjEsXG4gICAgICBwYXJ0aXRpb24yOiBwYXJ0aXRpb24yXG4gICAgfTtcbiAgICByZXR1cm4gcmV0O1xuICB9XG59OyAvLyBlbGVzZm5cblxudmFyIGNvcHlQb3NpdGlvbiA9IGZ1bmN0aW9uIGNvcHlQb3NpdGlvbihwKSB7XG4gIHJldHVybiB7XG4gICAgeDogcC54LFxuICAgIHk6IHAueVxuICB9O1xufTtcbnZhciBtb2RlbFRvUmVuZGVyZWRQb3NpdGlvbiA9IGZ1bmN0aW9uIG1vZGVsVG9SZW5kZXJlZFBvc2l0aW9uKHAsIHpvb20sIHBhbikge1xuICByZXR1cm4ge1xuICAgIHg6IHAueCAqIHpvb20gKyBwYW4ueCxcbiAgICB5OiBwLnkgKiB6b29tICsgcGFuLnlcbiAgfTtcbn07XG52YXIgcmVuZGVyZWRUb01vZGVsUG9zaXRpb24gPSBmdW5jdGlvbiByZW5kZXJlZFRvTW9kZWxQb3NpdGlvbihwLCB6b29tLCBwYW4pIHtcbiAgcmV0dXJuIHtcbiAgICB4OiAocC54IC0gcGFuLngpIC8gem9vbSxcbiAgICB5OiAocC55IC0gcGFuLnkpIC8gem9vbVxuICB9O1xufTtcbnZhciBhcnJheTJwb2ludCA9IGZ1bmN0aW9uIGFycmF5MnBvaW50KGFycikge1xuICByZXR1cm4ge1xuICAgIHg6IGFyclswXSxcbiAgICB5OiBhcnJbMV1cbiAgfTtcbn07XG52YXIgbWluID0gZnVuY3Rpb24gbWluKGFycikge1xuICB2YXIgYmVnaW4gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDA7XG4gIHZhciBlbmQgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGFyci5sZW5ndGg7XG4gIHZhciBtaW4gPSBJbmZpbml0eTtcbiAgZm9yICh2YXIgaSA9IGJlZ2luOyBpIDwgZW5kOyBpKyspIHtcbiAgICB2YXIgdmFsID0gYXJyW2ldO1xuICAgIGlmIChpc0Zpbml0ZSh2YWwpKSB7XG4gICAgICBtaW4gPSBNYXRoLm1pbih2YWwsIG1pbik7XG4gICAgfVxuICB9XG4gIHJldHVybiBtaW47XG59O1xudmFyIG1heCA9IGZ1bmN0aW9uIG1heChhcnIpIHtcbiAgdmFyIGJlZ2luID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAwO1xuICB2YXIgZW5kID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBhcnIubGVuZ3RoO1xuICB2YXIgbWF4ID0gLUluZmluaXR5O1xuICBmb3IgKHZhciBpID0gYmVnaW47IGkgPCBlbmQ7IGkrKykge1xuICAgIHZhciB2YWwgPSBhcnJbaV07XG4gICAgaWYgKGlzRmluaXRlKHZhbCkpIHtcbiAgICAgIG1heCA9IE1hdGgubWF4KHZhbCwgbWF4KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1heDtcbn07XG52YXIgbWVhbiA9IGZ1bmN0aW9uIG1lYW4oYXJyKSB7XG4gIHZhciBiZWdpbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMDtcbiAgdmFyIGVuZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogYXJyLmxlbmd0aDtcbiAgdmFyIHRvdGFsID0gMDtcbiAgdmFyIG4gPSAwO1xuICBmb3IgKHZhciBpID0gYmVnaW47IGkgPCBlbmQ7IGkrKykge1xuICAgIHZhciB2YWwgPSBhcnJbaV07XG4gICAgaWYgKGlzRmluaXRlKHZhbCkpIHtcbiAgICAgIHRvdGFsICs9IHZhbDtcbiAgICAgIG4rKztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRvdGFsIC8gbjtcbn07XG52YXIgbWVkaWFuID0gZnVuY3Rpb24gbWVkaWFuKGFycikge1xuICB2YXIgYmVnaW4gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDA7XG4gIHZhciBlbmQgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGFyci5sZW5ndGg7XG4gIHZhciBjb3B5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiB0cnVlO1xuICB2YXIgc29ydCA9IGFyZ3VtZW50cy5sZW5ndGggPiA0ICYmIGFyZ3VtZW50c1s0XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzRdIDogdHJ1ZTtcbiAgdmFyIGluY2x1ZGVIb2xlcyA9IGFyZ3VtZW50cy5sZW5ndGggPiA1ICYmIGFyZ3VtZW50c1s1XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzVdIDogdHJ1ZTtcbiAgaWYgKGNvcHkpIHtcbiAgICBhcnIgPSBhcnIuc2xpY2UoYmVnaW4sIGVuZCk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKGVuZCA8IGFyci5sZW5ndGgpIHtcbiAgICAgIGFyci5zcGxpY2UoZW5kLCBhcnIubGVuZ3RoIC0gZW5kKTtcbiAgICB9XG4gICAgaWYgKGJlZ2luID4gMCkge1xuICAgICAgYXJyLnNwbGljZSgwLCBiZWdpbik7XG4gICAgfVxuICB9XG5cbiAgLy8gYWxsIG5vbiBmaW5pdGUgKGUuZy4gSW5maW5pdHksIE5hTikgZWxlbWVudHMgbXVzdCBiZSAtSW5maW5pdHkgc28gdGhleSBnbyB0byB0aGUgc3RhcnRcbiAgdmFyIG9mZiA9IDA7IC8vIG9mZnNldCBmcm9tIG5vbi1maW5pdGUgdmFsdWVzXG4gIGZvciAodmFyIGkgPSBhcnIubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICB2YXIgdiA9IGFycltpXTtcbiAgICBpZiAoaW5jbHVkZUhvbGVzKSB7XG4gICAgICBpZiAoIWlzRmluaXRlKHYpKSB7XG4gICAgICAgIGFycltpXSA9IC1JbmZpbml0eTtcbiAgICAgICAgb2ZmKys7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGp1c3QgcmVtb3ZlIGl0IGlmIHdlIGRvbid0IHdhbnQgdG8gY29uc2lkZXIgaG9sZXNcbiAgICAgIGFyci5zcGxpY2UoaSwgMSk7XG4gICAgfVxuICB9XG4gIGlmIChzb3J0KSB7XG4gICAgYXJyLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHJldHVybiBhIC0gYjtcbiAgICB9KTsgLy8gcmVxdWlyZXMgY29weSA9IHRydWUgaWYgeW91IGRvbid0IHdhbnQgdG8gY2hhbmdlIHRoZSBvcmlnXG4gIH1cblxuICB2YXIgbGVuID0gYXJyLmxlbmd0aDtcbiAgdmFyIG1pZCA9IE1hdGguZmxvb3IobGVuIC8gMik7XG4gIGlmIChsZW4gJSAyICE9PSAwKSB7XG4gICAgcmV0dXJuIGFyclttaWQgKyAxICsgb2ZmXTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gKGFyclttaWQgLSAxICsgb2ZmXSArIGFyclttaWQgKyBvZmZdKSAvIDI7XG4gIH1cbn07XG52YXIgZGVnMnJhZCA9IGZ1bmN0aW9uIGRlZzJyYWQoZGVnKSB7XG4gIHJldHVybiBNYXRoLlBJICogZGVnIC8gMTgwO1xufTtcbnZhciBnZXRBbmdsZUZyb21EaXNwID0gZnVuY3Rpb24gZ2V0QW5nbGVGcm9tRGlzcChkaXNwWCwgZGlzcFkpIHtcbiAgcmV0dXJuIE1hdGguYXRhbjIoZGlzcFksIGRpc3BYKSAtIE1hdGguUEkgLyAyO1xufTtcbnZhciBsb2cyID0gTWF0aC5sb2cyIHx8IGZ1bmN0aW9uIChuKSB7XG4gIHJldHVybiBNYXRoLmxvZyhuKSAvIE1hdGgubG9nKDIpO1xufTtcbnZhciBzaWdudW0gPSBmdW5jdGlvbiBzaWdudW0oeCkge1xuICBpZiAoeCA+IDApIHtcbiAgICByZXR1cm4gMTtcbiAgfSBlbHNlIGlmICh4IDwgMCkge1xuICAgIHJldHVybiAtMTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gMDtcbiAgfVxufTtcbnZhciBkaXN0ID0gZnVuY3Rpb24gZGlzdChwMSwgcDIpIHtcbiAgcmV0dXJuIE1hdGguc3FydChzcWRpc3QocDEsIHAyKSk7XG59O1xudmFyIHNxZGlzdCA9IGZ1bmN0aW9uIHNxZGlzdChwMSwgcDIpIHtcbiAgdmFyIGR4ID0gcDIueCAtIHAxLng7XG4gIHZhciBkeSA9IHAyLnkgLSBwMS55O1xuICByZXR1cm4gZHggKiBkeCArIGR5ICogZHk7XG59O1xudmFyIGluUGxhY2VTdW1Ob3JtYWxpemUgPSBmdW5jdGlvbiBpblBsYWNlU3VtTm9ybWFsaXplKHYpIHtcbiAgdmFyIGxlbmd0aCA9IHYubGVuZ3RoO1xuXG4gIC8vIEZpcnN0LCBnZXQgc3VtIG9mIGFsbCBlbGVtZW50c1xuICB2YXIgdG90YWwgPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgdG90YWwgKz0gdltpXTtcbiAgfVxuXG4gIC8vIE5vdywgZGl2aWRlIGVhY2ggYnkgdGhlIHN1bSBvZiBhbGwgZWxlbWVudHNcbiAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGxlbmd0aDsgX2krKykge1xuICAgIHZbX2ldID0gdltfaV0gLyB0b3RhbDtcbiAgfVxuICByZXR1cm4gdjtcbn07XG5cbi8vIGZyb20gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Cw6l6aWVyX2N1cnZlI1F1YWRyYXRpY19jdXJ2ZXNcbnZhciBxYmV6aWVyQXQgPSBmdW5jdGlvbiBxYmV6aWVyQXQocDAsIHAxLCBwMiwgdCkge1xuICByZXR1cm4gKDEgLSB0KSAqICgxIC0gdCkgKiBwMCArIDIgKiAoMSAtIHQpICogdCAqIHAxICsgdCAqIHQgKiBwMjtcbn07XG52YXIgcWJlemllclB0QXQgPSBmdW5jdGlvbiBxYmV6aWVyUHRBdChwMCwgcDEsIHAyLCB0KSB7XG4gIHJldHVybiB7XG4gICAgeDogcWJlemllckF0KHAwLngsIHAxLngsIHAyLngsIHQpLFxuICAgIHk6IHFiZXppZXJBdChwMC55LCBwMS55LCBwMi55LCB0KVxuICB9O1xufTtcbnZhciBsaW5lQXQgPSBmdW5jdGlvbiBsaW5lQXQocDAsIHAxLCB0LCBkKSB7XG4gIHZhciB2ZWMgPSB7XG4gICAgeDogcDEueCAtIHAwLngsXG4gICAgeTogcDEueSAtIHAwLnlcbiAgfTtcbiAgdmFyIHZlY0Rpc3QgPSBkaXN0KHAwLCBwMSk7XG4gIHZhciBub3JtVmVjID0ge1xuICAgIHg6IHZlYy54IC8gdmVjRGlzdCxcbiAgICB5OiB2ZWMueSAvIHZlY0Rpc3RcbiAgfTtcbiAgdCA9IHQgPT0gbnVsbCA/IDAgOiB0O1xuICBkID0gZCAhPSBudWxsID8gZCA6IHQgKiB2ZWNEaXN0O1xuICByZXR1cm4ge1xuICAgIHg6IHAwLnggKyBub3JtVmVjLnggKiBkLFxuICAgIHk6IHAwLnkgKyBub3JtVmVjLnkgKiBkXG4gIH07XG59O1xudmFyIGJvdW5kID0gZnVuY3Rpb24gYm91bmQobWluLCB2YWwsIG1heCkge1xuICByZXR1cm4gTWF0aC5tYXgobWluLCBNYXRoLm1pbihtYXgsIHZhbCkpO1xufTtcblxuLy8gbWFrZXMgYSBmdWxsIGJiICh4MSwgeTEsIHgyLCB5MiwgdywgaCkgZnJvbSBpbXBsaWNpdCBwYXJhbXNcbnZhciBtYWtlQm91bmRpbmdCb3ggPSBmdW5jdGlvbiBtYWtlQm91bmRpbmdCb3goYmIpIHtcbiAgaWYgKGJiID09IG51bGwpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDE6IEluZmluaXR5LFxuICAgICAgeTE6IEluZmluaXR5LFxuICAgICAgeDI6IC1JbmZpbml0eSxcbiAgICAgIHkyOiAtSW5maW5pdHksXG4gICAgICB3OiAwLFxuICAgICAgaDogMFxuICAgIH07XG4gIH0gZWxzZSBpZiAoYmIueDEgIT0gbnVsbCAmJiBiYi55MSAhPSBudWxsKSB7XG4gICAgaWYgKGJiLngyICE9IG51bGwgJiYgYmIueTIgIT0gbnVsbCAmJiBiYi54MiA+PSBiYi54MSAmJiBiYi55MiA+PSBiYi55MSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDE6IGJiLngxLFxuICAgICAgICB5MTogYmIueTEsXG4gICAgICAgIHgyOiBiYi54MixcbiAgICAgICAgeTI6IGJiLnkyLFxuICAgICAgICB3OiBiYi54MiAtIGJiLngxLFxuICAgICAgICBoOiBiYi55MiAtIGJiLnkxXG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAoYmIudyAhPSBudWxsICYmIGJiLmggIT0gbnVsbCAmJiBiYi53ID49IDAgJiYgYmIuaCA+PSAwKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4MTogYmIueDEsXG4gICAgICAgIHkxOiBiYi55MSxcbiAgICAgICAgeDI6IGJiLngxICsgYmIudyxcbiAgICAgICAgeTI6IGJiLnkxICsgYmIuaCxcbiAgICAgICAgdzogYmIudyxcbiAgICAgICAgaDogYmIuaFxuICAgICAgfTtcbiAgICB9XG4gIH1cbn07XG52YXIgY29weUJvdW5kaW5nQm94ID0gZnVuY3Rpb24gY29weUJvdW5kaW5nQm94KGJiKSB7XG4gIHJldHVybiB7XG4gICAgeDE6IGJiLngxLFxuICAgIHgyOiBiYi54MixcbiAgICB3OiBiYi53LFxuICAgIHkxOiBiYi55MSxcbiAgICB5MjogYmIueTIsXG4gICAgaDogYmIuaFxuICB9O1xufTtcbnZhciBjbGVhckJvdW5kaW5nQm94ID0gZnVuY3Rpb24gY2xlYXJCb3VuZGluZ0JveChiYikge1xuICBiYi54MSA9IEluZmluaXR5O1xuICBiYi55MSA9IEluZmluaXR5O1xuICBiYi54MiA9IC1JbmZpbml0eTtcbiAgYmIueTIgPSAtSW5maW5pdHk7XG4gIGJiLncgPSAwO1xuICBiYi5oID0gMDtcbn07XG52YXIgc2hpZnRCb3VuZGluZ0JveCA9IGZ1bmN0aW9uIHNoaWZ0Qm91bmRpbmdCb3goYmIsIGR4LCBkeSkge1xuICByZXR1cm4ge1xuICAgIHgxOiBiYi54MSArIGR4LFxuICAgIHgyOiBiYi54MiArIGR4LFxuICAgIHkxOiBiYi55MSArIGR5LFxuICAgIHkyOiBiYi55MiArIGR5LFxuICAgIHc6IGJiLncsXG4gICAgaDogYmIuaFxuICB9O1xufTtcbnZhciB1cGRhdGVCb3VuZGluZ0JveCA9IGZ1bmN0aW9uIHVwZGF0ZUJvdW5kaW5nQm94KGJiMSwgYmIyKSB7XG4gIC8vIHVwZGF0ZSBiYjEgd2l0aCBiYjIgYm91bmRzXG5cbiAgYmIxLngxID0gTWF0aC5taW4oYmIxLngxLCBiYjIueDEpO1xuICBiYjEueDIgPSBNYXRoLm1heChiYjEueDIsIGJiMi54Mik7XG4gIGJiMS53ID0gYmIxLngyIC0gYmIxLngxO1xuICBiYjEueTEgPSBNYXRoLm1pbihiYjEueTEsIGJiMi55MSk7XG4gIGJiMS55MiA9IE1hdGgubWF4KGJiMS55MiwgYmIyLnkyKTtcbiAgYmIxLmggPSBiYjEueTIgLSBiYjEueTE7XG59O1xudmFyIGV4cGFuZEJvdW5kaW5nQm94QnlQb2ludCA9IGZ1bmN0aW9uIGV4cGFuZEJvdW5kaW5nQm94QnlQb2ludChiYiwgeCwgeSkge1xuICBiYi54MSA9IE1hdGgubWluKGJiLngxLCB4KTtcbiAgYmIueDIgPSBNYXRoLm1heChiYi54MiwgeCk7XG4gIGJiLncgPSBiYi54MiAtIGJiLngxO1xuICBiYi55MSA9IE1hdGgubWluKGJiLnkxLCB5KTtcbiAgYmIueTIgPSBNYXRoLm1heChiYi55MiwgeSk7XG4gIGJiLmggPSBiYi55MiAtIGJiLnkxO1xufTtcbnZhciBleHBhbmRCb3VuZGluZ0JveCA9IGZ1bmN0aW9uIGV4cGFuZEJvdW5kaW5nQm94KGJiKSB7XG4gIHZhciBwYWRkaW5nID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAwO1xuICBiYi54MSAtPSBwYWRkaW5nO1xuICBiYi54MiArPSBwYWRkaW5nO1xuICBiYi55MSAtPSBwYWRkaW5nO1xuICBiYi55MiArPSBwYWRkaW5nO1xuICBiYi53ID0gYmIueDIgLSBiYi54MTtcbiAgYmIuaCA9IGJiLnkyIC0gYmIueTE7XG4gIHJldHVybiBiYjtcbn07XG52YXIgZXhwYW5kQm91bmRpbmdCb3hTaWRlcyA9IGZ1bmN0aW9uIGV4cGFuZEJvdW5kaW5nQm94U2lkZXMoYmIpIHtcbiAgdmFyIHBhZGRpbmcgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IFswXTtcbiAgdmFyIHRvcCwgcmlnaHQsIGJvdHRvbSwgbGVmdDtcbiAgaWYgKHBhZGRpbmcubGVuZ3RoID09PSAxKSB7XG4gICAgdG9wID0gcmlnaHQgPSBib3R0b20gPSBsZWZ0ID0gcGFkZGluZ1swXTtcbiAgfSBlbHNlIGlmIChwYWRkaW5nLmxlbmd0aCA9PT0gMikge1xuICAgIHRvcCA9IGJvdHRvbSA9IHBhZGRpbmdbMF07XG4gICAgbGVmdCA9IHJpZ2h0ID0gcGFkZGluZ1sxXTtcbiAgfSBlbHNlIGlmIChwYWRkaW5nLmxlbmd0aCA9PT0gNCkge1xuICAgIHZhciBfcGFkZGluZyA9IF9zbGljZWRUb0FycmF5KHBhZGRpbmcsIDQpO1xuICAgIHRvcCA9IF9wYWRkaW5nWzBdO1xuICAgIHJpZ2h0ID0gX3BhZGRpbmdbMV07XG4gICAgYm90dG9tID0gX3BhZGRpbmdbMl07XG4gICAgbGVmdCA9IF9wYWRkaW5nWzNdO1xuICB9XG4gIGJiLngxIC09IGxlZnQ7XG4gIGJiLngyICs9IHJpZ2h0O1xuICBiYi55MSAtPSB0b3A7XG4gIGJiLnkyICs9IGJvdHRvbTtcbiAgYmIudyA9IGJiLngyIC0gYmIueDE7XG4gIGJiLmggPSBiYi55MiAtIGJiLnkxO1xuICByZXR1cm4gYmI7XG59O1xuXG4vLyBhc3NpZ24gdGhlIHZhbHVlcyBvZiBiYjIgaW50byBiYjFcbnZhciBhc3NpZ25Cb3VuZGluZ0JveCA9IGZ1bmN0aW9uIGFzc2lnbkJvdW5kaW5nQm94KGJiMSwgYmIyKSB7XG4gIGJiMS54MSA9IGJiMi54MTtcbiAgYmIxLnkxID0gYmIyLnkxO1xuICBiYjEueDIgPSBiYjIueDI7XG4gIGJiMS55MiA9IGJiMi55MjtcbiAgYmIxLncgPSBiYjEueDIgLSBiYjEueDE7XG4gIGJiMS5oID0gYmIxLnkyIC0gYmIxLnkxO1xufTtcbnZhciBib3VuZGluZ0JveGVzSW50ZXJzZWN0ID0gZnVuY3Rpb24gYm91bmRpbmdCb3hlc0ludGVyc2VjdChiYjEsIGJiMikge1xuICAvLyBjYXNlOiBvbmUgYmIgdG8gcmlnaHQgb2Ygb3RoZXJcbiAgaWYgKGJiMS54MSA+IGJiMi54Mikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoYmIyLngxID4gYmIxLngyKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gY2FzZTogb25lIGJiIHRvIGxlZnQgb2Ygb3RoZXJcbiAgaWYgKGJiMS54MiA8IGJiMi54MSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoYmIyLngyIDwgYmIxLngxKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gY2FzZTogb25lIGJiIGFib3ZlIG90aGVyXG4gIGlmIChiYjEueTIgPCBiYjIueTEpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGJiMi55MiA8IGJiMS55MSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIGNhc2U6IG9uZSBiYiBiZWxvdyBvdGhlclxuICBpZiAoYmIxLnkxID4gYmIyLnkyKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChiYjIueTEgPiBiYjEueTIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBvdGhlcndpc2UsIG11c3QgaGF2ZSBzb21lIG92ZXJsYXBcbiAgcmV0dXJuIHRydWU7XG59O1xudmFyIGluQm91bmRpbmdCb3ggPSBmdW5jdGlvbiBpbkJvdW5kaW5nQm94KGJiLCB4LCB5KSB7XG4gIHJldHVybiBiYi54MSA8PSB4ICYmIHggPD0gYmIueDIgJiYgYmIueTEgPD0geSAmJiB5IDw9IGJiLnkyO1xufTtcbnZhciBwb2ludEluQm91bmRpbmdCb3ggPSBmdW5jdGlvbiBwb2ludEluQm91bmRpbmdCb3goYmIsIHB0KSB7XG4gIHJldHVybiBpbkJvdW5kaW5nQm94KGJiLCBwdC54LCBwdC55KTtcbn07XG52YXIgYm91bmRpbmdCb3hJbkJvdW5kaW5nQm94ID0gZnVuY3Rpb24gYm91bmRpbmdCb3hJbkJvdW5kaW5nQm94KGJiMSwgYmIyKSB7XG4gIHJldHVybiBpbkJvdW5kaW5nQm94KGJiMSwgYmIyLngxLCBiYjIueTEpICYmIGluQm91bmRpbmdCb3goYmIxLCBiYjIueDIsIGJiMi55Mik7XG59O1xudmFyIHJvdW5kUmVjdGFuZ2xlSW50ZXJzZWN0TGluZSA9IGZ1bmN0aW9uIHJvdW5kUmVjdGFuZ2xlSW50ZXJzZWN0TGluZSh4LCB5LCBub2RlWCwgbm9kZVksIHdpZHRoLCBoZWlnaHQsIHBhZGRpbmcpIHtcbiAgdmFyIHJhZGl1cyA9IGFyZ3VtZW50cy5sZW5ndGggPiA3ICYmIGFyZ3VtZW50c1s3XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzddIDogJ2F1dG8nO1xuICB2YXIgY29ybmVyUmFkaXVzID0gcmFkaXVzID09PSAnYXV0bycgPyBnZXRSb3VuZFJlY3RhbmdsZVJhZGl1cyh3aWR0aCwgaGVpZ2h0KSA6IHJhZGl1cztcbiAgdmFyIGhhbGZXaWR0aCA9IHdpZHRoIC8gMjtcbiAgdmFyIGhhbGZIZWlnaHQgPSBoZWlnaHQgLyAyO1xuICBjb3JuZXJSYWRpdXMgPSBNYXRoLm1pbihjb3JuZXJSYWRpdXMsIGhhbGZXaWR0aCwgaGFsZkhlaWdodCk7XG4gIHZhciBkb1dpZHRoID0gY29ybmVyUmFkaXVzICE9PSBoYWxmV2lkdGgsXG4gICAgZG9IZWlnaHQgPSBjb3JuZXJSYWRpdXMgIT09IGhhbGZIZWlnaHQ7XG5cbiAgLy8gQ2hlY2sgaW50ZXJzZWN0aW9ucyB3aXRoIHN0cmFpZ2h0IGxpbmUgc2VnbWVudHNcbiAgdmFyIHN0cmFpZ2h0TGluZUludGVyc2VjdGlvbnM7XG5cbiAgLy8gVG9wIHNlZ21lbnQsIGxlZnQgdG8gcmlnaHRcbiAgaWYgKGRvV2lkdGgpIHtcbiAgICB2YXIgdG9wU3RhcnRYID0gbm9kZVggLSBoYWxmV2lkdGggKyBjb3JuZXJSYWRpdXMgLSBwYWRkaW5nO1xuICAgIHZhciB0b3BTdGFydFkgPSBub2RlWSAtIGhhbGZIZWlnaHQgLSBwYWRkaW5nO1xuICAgIHZhciB0b3BFbmRYID0gbm9kZVggKyBoYWxmV2lkdGggLSBjb3JuZXJSYWRpdXMgKyBwYWRkaW5nO1xuICAgIHZhciB0b3BFbmRZID0gdG9wU3RhcnRZO1xuICAgIHN0cmFpZ2h0TGluZUludGVyc2VjdGlvbnMgPSBmaW5pdGVMaW5lc0ludGVyc2VjdCh4LCB5LCBub2RlWCwgbm9kZVksIHRvcFN0YXJ0WCwgdG9wU3RhcnRZLCB0b3BFbmRYLCB0b3BFbmRZLCBmYWxzZSk7XG4gICAgaWYgKHN0cmFpZ2h0TGluZUludGVyc2VjdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgcmV0dXJuIHN0cmFpZ2h0TGluZUludGVyc2VjdGlvbnM7XG4gICAgfVxuICB9XG5cbiAgLy8gUmlnaHQgc2VnbWVudCwgdG9wIHRvIGJvdHRvbVxuICBpZiAoZG9IZWlnaHQpIHtcbiAgICB2YXIgcmlnaHRTdGFydFggPSBub2RlWCArIGhhbGZXaWR0aCArIHBhZGRpbmc7XG4gICAgdmFyIHJpZ2h0U3RhcnRZID0gbm9kZVkgLSBoYWxmSGVpZ2h0ICsgY29ybmVyUmFkaXVzIC0gcGFkZGluZztcbiAgICB2YXIgcmlnaHRFbmRYID0gcmlnaHRTdGFydFg7XG4gICAgdmFyIHJpZ2h0RW5kWSA9IG5vZGVZICsgaGFsZkhlaWdodCAtIGNvcm5lclJhZGl1cyArIHBhZGRpbmc7XG4gICAgc3RyYWlnaHRMaW5lSW50ZXJzZWN0aW9ucyA9IGZpbml0ZUxpbmVzSW50ZXJzZWN0KHgsIHksIG5vZGVYLCBub2RlWSwgcmlnaHRTdGFydFgsIHJpZ2h0U3RhcnRZLCByaWdodEVuZFgsIHJpZ2h0RW5kWSwgZmFsc2UpO1xuICAgIGlmIChzdHJhaWdodExpbmVJbnRlcnNlY3Rpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgIHJldHVybiBzdHJhaWdodExpbmVJbnRlcnNlY3Rpb25zO1xuICAgIH1cbiAgfVxuXG4gIC8vIEJvdHRvbSBzZWdtZW50LCBsZWZ0IHRvIHJpZ2h0XG4gIGlmIChkb1dpZHRoKSB7XG4gICAgdmFyIGJvdHRvbVN0YXJ0WCA9IG5vZGVYIC0gaGFsZldpZHRoICsgY29ybmVyUmFkaXVzIC0gcGFkZGluZztcbiAgICB2YXIgYm90dG9tU3RhcnRZID0gbm9kZVkgKyBoYWxmSGVpZ2h0ICsgcGFkZGluZztcbiAgICB2YXIgYm90dG9tRW5kWCA9IG5vZGVYICsgaGFsZldpZHRoIC0gY29ybmVyUmFkaXVzICsgcGFkZGluZztcbiAgICB2YXIgYm90dG9tRW5kWSA9IGJvdHRvbVN0YXJ0WTtcbiAgICBzdHJhaWdodExpbmVJbnRlcnNlY3Rpb25zID0gZmluaXRlTGluZXNJbnRlcnNlY3QoeCwgeSwgbm9kZVgsIG5vZGVZLCBib3R0b21TdGFydFgsIGJvdHRvbVN0YXJ0WSwgYm90dG9tRW5kWCwgYm90dG9tRW5kWSwgZmFsc2UpO1xuICAgIGlmIChzdHJhaWdodExpbmVJbnRlcnNlY3Rpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgIHJldHVybiBzdHJhaWdodExpbmVJbnRlcnNlY3Rpb25zO1xuICAgIH1cbiAgfVxuXG4gIC8vIExlZnQgc2VnbWVudCwgdG9wIHRvIGJvdHRvbVxuICBpZiAoZG9IZWlnaHQpIHtcbiAgICB2YXIgbGVmdFN0YXJ0WCA9IG5vZGVYIC0gaGFsZldpZHRoIC0gcGFkZGluZztcbiAgICB2YXIgbGVmdFN0YXJ0WSA9IG5vZGVZIC0gaGFsZkhlaWdodCArIGNvcm5lclJhZGl1cyAtIHBhZGRpbmc7XG4gICAgdmFyIGxlZnRFbmRYID0gbGVmdFN0YXJ0WDtcbiAgICB2YXIgbGVmdEVuZFkgPSBub2RlWSArIGhhbGZIZWlnaHQgLSBjb3JuZXJSYWRpdXMgKyBwYWRkaW5nO1xuICAgIHN0cmFpZ2h0TGluZUludGVyc2VjdGlvbnMgPSBmaW5pdGVMaW5lc0ludGVyc2VjdCh4LCB5LCBub2RlWCwgbm9kZVksIGxlZnRTdGFydFgsIGxlZnRTdGFydFksIGxlZnRFbmRYLCBsZWZ0RW5kWSwgZmFsc2UpO1xuICAgIGlmIChzdHJhaWdodExpbmVJbnRlcnNlY3Rpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgIHJldHVybiBzdHJhaWdodExpbmVJbnRlcnNlY3Rpb25zO1xuICAgIH1cbiAgfVxuXG4gIC8vIENoZWNrIGludGVyc2VjdGlvbnMgd2l0aCBhcmMgc2VnbWVudHNcbiAgdmFyIGFyY0ludGVyc2VjdGlvbnM7XG5cbiAgLy8gVG9wIExlZnRcbiAge1xuICAgIHZhciB0b3BMZWZ0Q2VudGVyWCA9IG5vZGVYIC0gaGFsZldpZHRoICsgY29ybmVyUmFkaXVzO1xuICAgIHZhciB0b3BMZWZ0Q2VudGVyWSA9IG5vZGVZIC0gaGFsZkhlaWdodCArIGNvcm5lclJhZGl1cztcbiAgICBhcmNJbnRlcnNlY3Rpb25zID0gaW50ZXJzZWN0TGluZUNpcmNsZSh4LCB5LCBub2RlWCwgbm9kZVksIHRvcExlZnRDZW50ZXJYLCB0b3BMZWZ0Q2VudGVyWSwgY29ybmVyUmFkaXVzICsgcGFkZGluZyk7XG5cbiAgICAvLyBFbnN1cmUgdGhlIGludGVyc2VjdGlvbiBpcyBvbiB0aGUgZGVzaXJlZCBxdWFydGVyIG9mIHRoZSBjaXJjbGVcbiAgICBpZiAoYXJjSW50ZXJzZWN0aW9ucy5sZW5ndGggPiAwICYmIGFyY0ludGVyc2VjdGlvbnNbMF0gPD0gdG9wTGVmdENlbnRlclggJiYgYXJjSW50ZXJzZWN0aW9uc1sxXSA8PSB0b3BMZWZ0Q2VudGVyWSkge1xuICAgICAgcmV0dXJuIFthcmNJbnRlcnNlY3Rpb25zWzBdLCBhcmNJbnRlcnNlY3Rpb25zWzFdXTtcbiAgICB9XG4gIH1cblxuICAvLyBUb3AgUmlnaHRcbiAge1xuICAgIHZhciB0b3BSaWdodENlbnRlclggPSBub2RlWCArIGhhbGZXaWR0aCAtIGNvcm5lclJhZGl1cztcbiAgICB2YXIgdG9wUmlnaHRDZW50ZXJZID0gbm9kZVkgLSBoYWxmSGVpZ2h0ICsgY29ybmVyUmFkaXVzO1xuICAgIGFyY0ludGVyc2VjdGlvbnMgPSBpbnRlcnNlY3RMaW5lQ2lyY2xlKHgsIHksIG5vZGVYLCBub2RlWSwgdG9wUmlnaHRDZW50ZXJYLCB0b3BSaWdodENlbnRlclksIGNvcm5lclJhZGl1cyArIHBhZGRpbmcpO1xuXG4gICAgLy8gRW5zdXJlIHRoZSBpbnRlcnNlY3Rpb24gaXMgb24gdGhlIGRlc2lyZWQgcXVhcnRlciBvZiB0aGUgY2lyY2xlXG4gICAgaWYgKGFyY0ludGVyc2VjdGlvbnMubGVuZ3RoID4gMCAmJiBhcmNJbnRlcnNlY3Rpb25zWzBdID49IHRvcFJpZ2h0Q2VudGVyWCAmJiBhcmNJbnRlcnNlY3Rpb25zWzFdIDw9IHRvcFJpZ2h0Q2VudGVyWSkge1xuICAgICAgcmV0dXJuIFthcmNJbnRlcnNlY3Rpb25zWzBdLCBhcmNJbnRlcnNlY3Rpb25zWzFdXTtcbiAgICB9XG4gIH1cblxuICAvLyBCb3R0b20gUmlnaHRcbiAge1xuICAgIHZhciBib3R0b21SaWdodENlbnRlclggPSBub2RlWCArIGhhbGZXaWR0aCAtIGNvcm5lclJhZGl1cztcbiAgICB2YXIgYm90dG9tUmlnaHRDZW50ZXJZID0gbm9kZVkgKyBoYWxmSGVpZ2h0IC0gY29ybmVyUmFkaXVzO1xuICAgIGFyY0ludGVyc2VjdGlvbnMgPSBpbnRlcnNlY3RMaW5lQ2lyY2xlKHgsIHksIG5vZGVYLCBub2RlWSwgYm90dG9tUmlnaHRDZW50ZXJYLCBib3R0b21SaWdodENlbnRlclksIGNvcm5lclJhZGl1cyArIHBhZGRpbmcpO1xuXG4gICAgLy8gRW5zdXJlIHRoZSBpbnRlcnNlY3Rpb24gaXMgb24gdGhlIGRlc2lyZWQgcXVhcnRlciBvZiB0aGUgY2lyY2xlXG4gICAgaWYgKGFyY0ludGVyc2VjdGlvbnMubGVuZ3RoID4gMCAmJiBhcmNJbnRlcnNlY3Rpb25zWzBdID49IGJvdHRvbVJpZ2h0Q2VudGVyWCAmJiBhcmNJbnRlcnNlY3Rpb25zWzFdID49IGJvdHRvbVJpZ2h0Q2VudGVyWSkge1xuICAgICAgcmV0dXJuIFthcmNJbnRlcnNlY3Rpb25zWzBdLCBhcmNJbnRlcnNlY3Rpb25zWzFdXTtcbiAgICB9XG4gIH1cblxuICAvLyBCb3R0b20gTGVmdFxuICB7XG4gICAgdmFyIGJvdHRvbUxlZnRDZW50ZXJYID0gbm9kZVggLSBoYWxmV2lkdGggKyBjb3JuZXJSYWRpdXM7XG4gICAgdmFyIGJvdHRvbUxlZnRDZW50ZXJZID0gbm9kZVkgKyBoYWxmSGVpZ2h0IC0gY29ybmVyUmFkaXVzO1xuICAgIGFyY0ludGVyc2VjdGlvbnMgPSBpbnRlcnNlY3RMaW5lQ2lyY2xlKHgsIHksIG5vZGVYLCBub2RlWSwgYm90dG9tTGVmdENlbnRlclgsIGJvdHRvbUxlZnRDZW50ZXJZLCBjb3JuZXJSYWRpdXMgKyBwYWRkaW5nKTtcblxuICAgIC8vIEVuc3VyZSB0aGUgaW50ZXJzZWN0aW9uIGlzIG9uIHRoZSBkZXNpcmVkIHF1YXJ0ZXIgb2YgdGhlIGNpcmNsZVxuICAgIGlmIChhcmNJbnRlcnNlY3Rpb25zLmxlbmd0aCA+IDAgJiYgYXJjSW50ZXJzZWN0aW9uc1swXSA8PSBib3R0b21MZWZ0Q2VudGVyWCAmJiBhcmNJbnRlcnNlY3Rpb25zWzFdID49IGJvdHRvbUxlZnRDZW50ZXJZKSB7XG4gICAgICByZXR1cm4gW2FyY0ludGVyc2VjdGlvbnNbMF0sIGFyY0ludGVyc2VjdGlvbnNbMV1dO1xuICAgIH1cbiAgfVxuICByZXR1cm4gW107IC8vIGlmIG5vdGhpbmdcbn07XG5cbnZhciBpbkxpbmVWaWNpbml0eSA9IGZ1bmN0aW9uIGluTGluZVZpY2luaXR5KHgsIHksIGx4MSwgbHkxLCBseDIsIGx5MiwgdG9sZXJhbmNlKSB7XG4gIHZhciB0ID0gdG9sZXJhbmNlO1xuICB2YXIgeDEgPSBNYXRoLm1pbihseDEsIGx4Mik7XG4gIHZhciB4MiA9IE1hdGgubWF4KGx4MSwgbHgyKTtcbiAgdmFyIHkxID0gTWF0aC5taW4obHkxLCBseTIpO1xuICB2YXIgeTIgPSBNYXRoLm1heChseTEsIGx5Mik7XG4gIHJldHVybiB4MSAtIHQgPD0geCAmJiB4IDw9IHgyICsgdCAmJiB5MSAtIHQgPD0geSAmJiB5IDw9IHkyICsgdDtcbn07XG52YXIgaW5CZXppZXJWaWNpbml0eSA9IGZ1bmN0aW9uIGluQmV6aWVyVmljaW5pdHkoeCwgeSwgeDEsIHkxLCB4MiwgeTIsIHgzLCB5MywgdG9sZXJhbmNlKSB7XG4gIHZhciBiYiA9IHtcbiAgICB4MTogTWF0aC5taW4oeDEsIHgzLCB4MikgLSB0b2xlcmFuY2UsXG4gICAgeDI6IE1hdGgubWF4KHgxLCB4MywgeDIpICsgdG9sZXJhbmNlLFxuICAgIHkxOiBNYXRoLm1pbih5MSwgeTMsIHkyKSAtIHRvbGVyYW5jZSxcbiAgICB5MjogTWF0aC5tYXgoeTEsIHkzLCB5MikgKyB0b2xlcmFuY2VcbiAgfTtcblxuICAvLyBpZiBvdXRzaWRlIHRoZSByb3VnaCBib3VuZGluZyBib3ggZm9yIHRoZSBiZXppZXIsIHRoZW4gaXQgY2FuJ3QgYmUgYSBoaXRcbiAgaWYgKHggPCBiYi54MSB8fCB4ID4gYmIueDIgfHwgeSA8IGJiLnkxIHx8IHkgPiBiYi55Mikge1xuICAgIC8vIGNvbnNvbGUubG9nKCdiZXppZXIgb3V0IG9mIHJvdWdoIGJiJylcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gZWxzZSB7XG4gICAgLy8gY29uc29sZS5sb2coJ2RvIG1vcmUgZXhwZW5zaXZlIGNoZWNrJyk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn07XG52YXIgc29sdmVRdWFkcmF0aWMgPSBmdW5jdGlvbiBzb2x2ZVF1YWRyYXRpYyhhLCBiLCBjLCB2YWwpIHtcbiAgYyAtPSB2YWw7XG4gIHZhciByID0gYiAqIGIgLSA0ICogYSAqIGM7XG4gIGlmIChyIDwgMCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICB2YXIgc3FydFIgPSBNYXRoLnNxcnQocik7XG4gIHZhciBkZW5vbSA9IDIgKiBhO1xuICB2YXIgcm9vdDEgPSAoLWIgKyBzcXJ0UikgLyBkZW5vbTtcbiAgdmFyIHJvb3QyID0gKC1iIC0gc3FydFIpIC8gZGVub207XG4gIHJldHVybiBbcm9vdDEsIHJvb3QyXTtcbn07XG52YXIgc29sdmVDdWJpYyA9IGZ1bmN0aW9uIHNvbHZlQ3ViaWMoYSwgYiwgYywgZCwgcmVzdWx0KSB7XG4gIC8vIFNvbHZlcyBhIGN1YmljIGZ1bmN0aW9uLCByZXR1cm5zIHJvb3QgaW4gZm9ybSBbcjEsIGkxLCByMiwgaTIsIHIzLCBpM10sIHdoZXJlXG4gIC8vIHIgaXMgdGhlIHJlYWwgY29tcG9uZW50LCBpIGlzIHRoZSBpbWFnaW5hcnkgY29tcG9uZW50XG5cbiAgLy8gQW4gaW1wbGVtZW50YXRpb24gb2YgdGhlIENhcmRhbm8gbWV0aG9kIGZyb20gdGhlIHllYXIgMTU0NVxuICAvLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0N1YmljX2Z1bmN0aW9uI1RoZV9uYXR1cmVfb2ZfdGhlX3Jvb3RzXG5cbiAgdmFyIGVwc2lsb24gPSAwLjAwMDAxO1xuXG4gIC8vIGF2b2lkIGRpdmlzaW9uIGJ5IHplcm8gd2hpbGUga2VlcGluZyB0aGUgb3ZlcmFsbCBleHByZXNzaW9uIGNsb3NlIGluIHZhbHVlXG4gIGlmIChhID09PSAwKSB7XG4gICAgYSA9IGVwc2lsb247XG4gIH1cbiAgYiAvPSBhO1xuICBjIC89IGE7XG4gIGQgLz0gYTtcbiAgdmFyIGRpc2NyaW1pbmFudCwgcSwgciwgZHVtMSwgcywgdCwgdGVybTEsIHIxMztcbiAgcSA9ICgzLjAgKiBjIC0gYiAqIGIpIC8gOS4wO1xuICByID0gLSgyNy4wICogZCkgKyBiICogKDkuMCAqIGMgLSAyLjAgKiAoYiAqIGIpKTtcbiAgciAvPSA1NC4wO1xuICBkaXNjcmltaW5hbnQgPSBxICogcSAqIHEgKyByICogcjtcbiAgcmVzdWx0WzFdID0gMDtcbiAgdGVybTEgPSBiIC8gMy4wO1xuICBpZiAoZGlzY3JpbWluYW50ID4gMCkge1xuICAgIHMgPSByICsgTWF0aC5zcXJ0KGRpc2NyaW1pbmFudCk7XG4gICAgcyA9IHMgPCAwID8gLU1hdGgucG93KC1zLCAxLjAgLyAzLjApIDogTWF0aC5wb3cocywgMS4wIC8gMy4wKTtcbiAgICB0ID0gciAtIE1hdGguc3FydChkaXNjcmltaW5hbnQpO1xuICAgIHQgPSB0IDwgMCA/IC1NYXRoLnBvdygtdCwgMS4wIC8gMy4wKSA6IE1hdGgucG93KHQsIDEuMCAvIDMuMCk7XG4gICAgcmVzdWx0WzBdID0gLXRlcm0xICsgcyArIHQ7XG4gICAgdGVybTEgKz0gKHMgKyB0KSAvIDIuMDtcbiAgICByZXN1bHRbNF0gPSByZXN1bHRbMl0gPSAtdGVybTE7XG4gICAgdGVybTEgPSBNYXRoLnNxcnQoMy4wKSAqICgtdCArIHMpIC8gMjtcbiAgICByZXN1bHRbM10gPSB0ZXJtMTtcbiAgICByZXN1bHRbNV0gPSAtdGVybTE7XG4gICAgcmV0dXJuO1xuICB9XG4gIHJlc3VsdFs1XSA9IHJlc3VsdFszXSA9IDA7XG4gIGlmIChkaXNjcmltaW5hbnQgPT09IDApIHtcbiAgICByMTMgPSByIDwgMCA/IC1NYXRoLnBvdygtciwgMS4wIC8gMy4wKSA6IE1hdGgucG93KHIsIDEuMCAvIDMuMCk7XG4gICAgcmVzdWx0WzBdID0gLXRlcm0xICsgMi4wICogcjEzO1xuICAgIHJlc3VsdFs0XSA9IHJlc3VsdFsyXSA9IC0ocjEzICsgdGVybTEpO1xuICAgIHJldHVybjtcbiAgfVxuICBxID0gLXE7XG4gIGR1bTEgPSBxICogcSAqIHE7XG4gIGR1bTEgPSBNYXRoLmFjb3MociAvIE1hdGguc3FydChkdW0xKSk7XG4gIHIxMyA9IDIuMCAqIE1hdGguc3FydChxKTtcbiAgcmVzdWx0WzBdID0gLXRlcm0xICsgcjEzICogTWF0aC5jb3MoZHVtMSAvIDMuMCk7XG4gIHJlc3VsdFsyXSA9IC10ZXJtMSArIHIxMyAqIE1hdGguY29zKChkdW0xICsgMi4wICogTWF0aC5QSSkgLyAzLjApO1xuICByZXN1bHRbNF0gPSAtdGVybTEgKyByMTMgKiBNYXRoLmNvcygoZHVtMSArIDQuMCAqIE1hdGguUEkpIC8gMy4wKTtcbiAgcmV0dXJuO1xufTtcbnZhciBzcWRpc3RUb1F1YWRyYXRpY0JlemllciA9IGZ1bmN0aW9uIHNxZGlzdFRvUXVhZHJhdGljQmV6aWVyKHgsIHksIHgxLCB5MSwgeDIsIHkyLCB4MywgeTMpIHtcbiAgLy8gRmluZCBtaW5pbXVtIGRpc3RhbmNlIGJ5IHVzaW5nIHRoZSBtaW5pbXVtIG9mIHRoZSBkaXN0YW5jZVxuICAvLyBmdW5jdGlvbiBiZXR3ZWVuIHRoZSBnaXZlbiBwb2ludCBhbmQgdGhlIGN1cnZlXG5cbiAgLy8gVGhpcyBnaXZlcyB0aGUgY29lZmZpY2llbnRzIG9mIHRoZSByZXN1bHRpbmcgY3ViaWMgZXF1YXRpb25cbiAgLy8gd2hvc2Ugcm9vdHMgdGVsbCB1cyB3aGVyZSBhIHBvc3NpYmxlIG1pbmltdW0gaXNcbiAgLy8gKENvZWZmaWNpZW50cyBhcmUgZGl2aWRlZCBieSA0KVxuXG4gIHZhciBhID0gMS4wICogeDEgKiB4MSAtIDQgKiB4MSAqIHgyICsgMiAqIHgxICogeDMgKyA0ICogeDIgKiB4MiAtIDQgKiB4MiAqIHgzICsgeDMgKiB4MyArIHkxICogeTEgLSA0ICogeTEgKiB5MiArIDIgKiB5MSAqIHkzICsgNCAqIHkyICogeTIgLSA0ICogeTIgKiB5MyArIHkzICogeTM7XG4gIHZhciBiID0gMS4wICogOSAqIHgxICogeDIgLSAzICogeDEgKiB4MSAtIDMgKiB4MSAqIHgzIC0gNiAqIHgyICogeDIgKyAzICogeDIgKiB4MyArIDkgKiB5MSAqIHkyIC0gMyAqIHkxICogeTEgLSAzICogeTEgKiB5MyAtIDYgKiB5MiAqIHkyICsgMyAqIHkyICogeTM7XG4gIHZhciBjID0gMS4wICogMyAqIHgxICogeDEgLSA2ICogeDEgKiB4MiArIHgxICogeDMgLSB4MSAqIHggKyAyICogeDIgKiB4MiArIDIgKiB4MiAqIHggLSB4MyAqIHggKyAzICogeTEgKiB5MSAtIDYgKiB5MSAqIHkyICsgeTEgKiB5MyAtIHkxICogeSArIDIgKiB5MiAqIHkyICsgMiAqIHkyICogeSAtIHkzICogeTtcbiAgdmFyIGQgPSAxLjAgKiB4MSAqIHgyIC0geDEgKiB4MSArIHgxICogeCAtIHgyICogeCArIHkxICogeTIgLSB5MSAqIHkxICsgeTEgKiB5IC0geTIgKiB5O1xuXG4gIC8vIGRlYnVnKFwiY29lZmZpY2llbnRzOiBcIiArIGEgLyBhICsgXCIsIFwiICsgYiAvIGEgKyBcIiwgXCIgKyBjIC8gYSArIFwiLCBcIiArIGQgLyBhKTtcblxuICB2YXIgcm9vdHMgPSBbXTtcblxuICAvLyBVc2UgdGhlIGN1YmljIHNvbHZpbmcgYWxnb3JpdGhtXG4gIHNvbHZlQ3ViaWMoYSwgYiwgYywgZCwgcm9vdHMpO1xuICB2YXIgemVyb1RocmVzaG9sZCA9IDAuMDAwMDAwMTtcbiAgdmFyIHBhcmFtcyA9IFtdO1xuICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgNjsgaW5kZXggKz0gMikge1xuICAgIGlmIChNYXRoLmFicyhyb290c1tpbmRleCArIDFdKSA8IHplcm9UaHJlc2hvbGQgJiYgcm9vdHNbaW5kZXhdID49IDAgJiYgcm9vdHNbaW5kZXhdIDw9IDEuMCkge1xuICAgICAgcGFyYW1zLnB1c2gocm9vdHNbaW5kZXhdKTtcbiAgICB9XG4gIH1cbiAgcGFyYW1zLnB1c2goMS4wKTtcbiAgcGFyYW1zLnB1c2goMC4wKTtcbiAgdmFyIG1pbkRpc3RhbmNlU3F1YXJlZCA9IC0xO1xuICB2YXIgY3VyWCwgY3VyWSwgZGlzdFNxdWFyZWQ7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcGFyYW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgY3VyWCA9IE1hdGgucG93KDEuMCAtIHBhcmFtc1tpXSwgMi4wKSAqIHgxICsgMi4wICogKDEgLSBwYXJhbXNbaV0pICogcGFyYW1zW2ldICogeDIgKyBwYXJhbXNbaV0gKiBwYXJhbXNbaV0gKiB4MztcbiAgICBjdXJZID0gTWF0aC5wb3coMSAtIHBhcmFtc1tpXSwgMi4wKSAqIHkxICsgMiAqICgxLjAgLSBwYXJhbXNbaV0pICogcGFyYW1zW2ldICogeTIgKyBwYXJhbXNbaV0gKiBwYXJhbXNbaV0gKiB5MztcbiAgICBkaXN0U3F1YXJlZCA9IE1hdGgucG93KGN1clggLSB4LCAyKSArIE1hdGgucG93KGN1clkgLSB5LCAyKTtcbiAgICAvLyBkZWJ1ZygnZGlzdGFuY2UgZm9yIHBhcmFtICcgKyBwYXJhbXNbaV0gKyBcIjogXCIgKyBNYXRoLnNxcnQoZGlzdFNxdWFyZWQpKTtcbiAgICBpZiAobWluRGlzdGFuY2VTcXVhcmVkID49IDApIHtcbiAgICAgIGlmIChkaXN0U3F1YXJlZCA8IG1pbkRpc3RhbmNlU3F1YXJlZCkge1xuICAgICAgICBtaW5EaXN0YW5jZVNxdWFyZWQgPSBkaXN0U3F1YXJlZDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbWluRGlzdGFuY2VTcXVhcmVkID0gZGlzdFNxdWFyZWQ7XG4gICAgfVxuICB9XG4gIHJldHVybiBtaW5EaXN0YW5jZVNxdWFyZWQ7XG59O1xudmFyIHNxZGlzdFRvRmluaXRlTGluZSA9IGZ1bmN0aW9uIHNxZGlzdFRvRmluaXRlTGluZSh4LCB5LCB4MSwgeTEsIHgyLCB5Mikge1xuICB2YXIgb2Zmc2V0ID0gW3ggLSB4MSwgeSAtIHkxXTtcbiAgdmFyIGxpbmUgPSBbeDIgLSB4MSwgeTIgLSB5MV07XG4gIHZhciBsaW5lU3EgPSBsaW5lWzBdICogbGluZVswXSArIGxpbmVbMV0gKiBsaW5lWzFdO1xuICB2YXIgaHlwU3EgPSBvZmZzZXRbMF0gKiBvZmZzZXRbMF0gKyBvZmZzZXRbMV0gKiBvZmZzZXRbMV07XG4gIHZhciBkb3RQcm9kdWN0ID0gb2Zmc2V0WzBdICogbGluZVswXSArIG9mZnNldFsxXSAqIGxpbmVbMV07XG4gIHZhciBhZGpTcSA9IGRvdFByb2R1Y3QgKiBkb3RQcm9kdWN0IC8gbGluZVNxO1xuICBpZiAoZG90UHJvZHVjdCA8IDApIHtcbiAgICByZXR1cm4gaHlwU3E7XG4gIH1cbiAgaWYgKGFkalNxID4gbGluZVNxKSB7XG4gICAgcmV0dXJuICh4IC0geDIpICogKHggLSB4MikgKyAoeSAtIHkyKSAqICh5IC0geTIpO1xuICB9XG4gIHJldHVybiBoeXBTcSAtIGFkalNxO1xufTtcbnZhciBwb2ludEluc2lkZVBvbHlnb25Qb2ludHMgPSBmdW5jdGlvbiBwb2ludEluc2lkZVBvbHlnb25Qb2ludHMoeCwgeSwgcG9pbnRzKSB7XG4gIHZhciB4MSwgeTEsIHgyLCB5MjtcbiAgdmFyIHkzO1xuXG4gIC8vIEludGVyc2VjdCB3aXRoIHZlcnRpY2FsIGxpbmUgdGhyb3VnaCAoeCwgeSlcbiAgdmFyIHVwID0gMDtcbiAgLy8gbGV0IGRvd24gPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGggLyAyOyBpKyspIHtcbiAgICB4MSA9IHBvaW50c1tpICogMl07XG4gICAgeTEgPSBwb2ludHNbaSAqIDIgKyAxXTtcbiAgICBpZiAoaSArIDEgPCBwb2ludHMubGVuZ3RoIC8gMikge1xuICAgICAgeDIgPSBwb2ludHNbKGkgKyAxKSAqIDJdO1xuICAgICAgeTIgPSBwb2ludHNbKGkgKyAxKSAqIDIgKyAxXTtcbiAgICB9IGVsc2Uge1xuICAgICAgeDIgPSBwb2ludHNbKGkgKyAxIC0gcG9pbnRzLmxlbmd0aCAvIDIpICogMl07XG4gICAgICB5MiA9IHBvaW50c1soaSArIDEgLSBwb2ludHMubGVuZ3RoIC8gMikgKiAyICsgMV07XG4gICAgfVxuICAgIGlmICh4MSA9PSB4ICYmIHgyID09IHgpIDsgZWxzZSBpZiAoeDEgPj0geCAmJiB4ID49IHgyIHx8IHgxIDw9IHggJiYgeCA8PSB4Mikge1xuICAgICAgeTMgPSAoeCAtIHgxKSAvICh4MiAtIHgxKSAqICh5MiAtIHkxKSArIHkxO1xuICAgICAgaWYgKHkzID4geSkge1xuICAgICAgICB1cCsrO1xuICAgICAgfVxuXG4gICAgICAvLyBpZiggeTMgPCB5ICl7XG4gICAgICAvLyBkb3duKys7XG4gICAgICAvLyB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgfVxuICBpZiAodXAgJSAyID09PSAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59O1xudmFyIHBvaW50SW5zaWRlUG9seWdvbiA9IGZ1bmN0aW9uIHBvaW50SW5zaWRlUG9seWdvbih4LCB5LCBiYXNlUG9pbnRzLCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0LCBkaXJlY3Rpb24sIHBhZGRpbmcpIHtcbiAgdmFyIHRyYW5zZm9ybWVkUG9pbnRzID0gbmV3IEFycmF5KGJhc2VQb2ludHMubGVuZ3RoKTtcblxuICAvLyBHaXZlcyBuZWdhdGl2ZSBhbmdsZVxuICB2YXIgYW5nbGU7XG4gIGlmIChkaXJlY3Rpb25bMF0gIT0gbnVsbCkge1xuICAgIGFuZ2xlID0gTWF0aC5hdGFuKGRpcmVjdGlvblsxXSAvIGRpcmVjdGlvblswXSk7XG4gICAgaWYgKGRpcmVjdGlvblswXSA8IDApIHtcbiAgICAgIGFuZ2xlID0gYW5nbGUgKyBNYXRoLlBJIC8gMjtcbiAgICB9IGVsc2Uge1xuICAgICAgYW5nbGUgPSAtYW5nbGUgLSBNYXRoLlBJIC8gMjtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgYW5nbGUgPSBkaXJlY3Rpb247XG4gIH1cbiAgdmFyIGNvcyA9IE1hdGguY29zKC1hbmdsZSk7XG4gIHZhciBzaW4gPSBNYXRoLnNpbigtYW5nbGUpO1xuXG4gIC8vICAgIGNvbnNvbGUubG9nKFwiYmFzZTogXCIgKyBiYXNlUG9pbnRzKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmFuc2Zvcm1lZFBvaW50cy5sZW5ndGggLyAyOyBpKyspIHtcbiAgICB0cmFuc2Zvcm1lZFBvaW50c1tpICogMl0gPSB3aWR0aCAvIDIgKiAoYmFzZVBvaW50c1tpICogMl0gKiBjb3MgLSBiYXNlUG9pbnRzW2kgKiAyICsgMV0gKiBzaW4pO1xuICAgIHRyYW5zZm9ybWVkUG9pbnRzW2kgKiAyICsgMV0gPSBoZWlnaHQgLyAyICogKGJhc2VQb2ludHNbaSAqIDIgKyAxXSAqIGNvcyArIGJhc2VQb2ludHNbaSAqIDJdICogc2luKTtcbiAgICB0cmFuc2Zvcm1lZFBvaW50c1tpICogMl0gKz0gY2VudGVyWDtcbiAgICB0cmFuc2Zvcm1lZFBvaW50c1tpICogMiArIDFdICs9IGNlbnRlclk7XG4gIH1cbiAgdmFyIHBvaW50cztcbiAgaWYgKHBhZGRpbmcgPiAwKSB7XG4gICAgdmFyIGV4cGFuZGVkTGluZVNldCA9IGV4cGFuZFBvbHlnb24odHJhbnNmb3JtZWRQb2ludHMsIC1wYWRkaW5nKTtcbiAgICBwb2ludHMgPSBqb2luTGluZXMoZXhwYW5kZWRMaW5lU2V0KTtcbiAgfSBlbHNlIHtcbiAgICBwb2ludHMgPSB0cmFuc2Zvcm1lZFBvaW50cztcbiAgfVxuICByZXR1cm4gcG9pbnRJbnNpZGVQb2x5Z29uUG9pbnRzKHgsIHksIHBvaW50cyk7XG59O1xudmFyIHBvaW50SW5zaWRlUm91bmRQb2x5Z29uID0gZnVuY3Rpb24gcG9pbnRJbnNpZGVSb3VuZFBvbHlnb24oeCwgeSwgYmFzZVBvaW50cywgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCwgY29ybmVycykge1xuICB2YXIgY3V0UG9seWdvblBvaW50cyA9IG5ldyBBcnJheShiYXNlUG9pbnRzLmxlbmd0aCAqIDIpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNvcm5lcnMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgY29ybmVyID0gY29ybmVyc1tpXTtcbiAgICBjdXRQb2x5Z29uUG9pbnRzW2kgKiA0ICsgMF0gPSBjb3JuZXIuc3RhcnRYO1xuICAgIGN1dFBvbHlnb25Qb2ludHNbaSAqIDQgKyAxXSA9IGNvcm5lci5zdGFydFk7XG4gICAgY3V0UG9seWdvblBvaW50c1tpICogNCArIDJdID0gY29ybmVyLnN0b3BYO1xuICAgIGN1dFBvbHlnb25Qb2ludHNbaSAqIDQgKyAzXSA9IGNvcm5lci5zdG9wWTtcbiAgICB2YXIgc3F1YXJlZERpc3RhbmNlID0gTWF0aC5wb3coY29ybmVyLmN4IC0geCwgMikgKyBNYXRoLnBvdyhjb3JuZXIuY3kgLSB5LCAyKTtcbiAgICBpZiAoc3F1YXJlZERpc3RhbmNlIDw9IE1hdGgucG93KGNvcm5lci5yYWRpdXMsIDIpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHBvaW50SW5zaWRlUG9seWdvblBvaW50cyh4LCB5LCBjdXRQb2x5Z29uUG9pbnRzKTtcbn07XG52YXIgam9pbkxpbmVzID0gZnVuY3Rpb24gam9pbkxpbmVzKGxpbmVTZXQpIHtcbiAgdmFyIHZlcnRpY2VzID0gbmV3IEFycmF5KGxpbmVTZXQubGVuZ3RoIC8gMik7XG4gIHZhciBjdXJyZW50TGluZVN0YXJ0WCwgY3VycmVudExpbmVTdGFydFksIGN1cnJlbnRMaW5lRW5kWCwgY3VycmVudExpbmVFbmRZO1xuICB2YXIgbmV4dExpbmVTdGFydFgsIG5leHRMaW5lU3RhcnRZLCBuZXh0TGluZUVuZFgsIG5leHRMaW5lRW5kWTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lU2V0Lmxlbmd0aCAvIDQ7IGkrKykge1xuICAgIGN1cnJlbnRMaW5lU3RhcnRYID0gbGluZVNldFtpICogNF07XG4gICAgY3VycmVudExpbmVTdGFydFkgPSBsaW5lU2V0W2kgKiA0ICsgMV07XG4gICAgY3VycmVudExpbmVFbmRYID0gbGluZVNldFtpICogNCArIDJdO1xuICAgIGN1cnJlbnRMaW5lRW5kWSA9IGxpbmVTZXRbaSAqIDQgKyAzXTtcbiAgICBpZiAoaSA8IGxpbmVTZXQubGVuZ3RoIC8gNCAtIDEpIHtcbiAgICAgIG5leHRMaW5lU3RhcnRYID0gbGluZVNldFsoaSArIDEpICogNF07XG4gICAgICBuZXh0TGluZVN0YXJ0WSA9IGxpbmVTZXRbKGkgKyAxKSAqIDQgKyAxXTtcbiAgICAgIG5leHRMaW5lRW5kWCA9IGxpbmVTZXRbKGkgKyAxKSAqIDQgKyAyXTtcbiAgICAgIG5leHRMaW5lRW5kWSA9IGxpbmVTZXRbKGkgKyAxKSAqIDQgKyAzXTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmV4dExpbmVTdGFydFggPSBsaW5lU2V0WzBdO1xuICAgICAgbmV4dExpbmVTdGFydFkgPSBsaW5lU2V0WzFdO1xuICAgICAgbmV4dExpbmVFbmRYID0gbGluZVNldFsyXTtcbiAgICAgIG5leHRMaW5lRW5kWSA9IGxpbmVTZXRbM107XG4gICAgfVxuICAgIHZhciBpbnRlcnNlY3Rpb24gPSBmaW5pdGVMaW5lc0ludGVyc2VjdChjdXJyZW50TGluZVN0YXJ0WCwgY3VycmVudExpbmVTdGFydFksIGN1cnJlbnRMaW5lRW5kWCwgY3VycmVudExpbmVFbmRZLCBuZXh0TGluZVN0YXJ0WCwgbmV4dExpbmVTdGFydFksIG5leHRMaW5lRW5kWCwgbmV4dExpbmVFbmRZLCB0cnVlKTtcbiAgICB2ZXJ0aWNlc1tpICogMl0gPSBpbnRlcnNlY3Rpb25bMF07XG4gICAgdmVydGljZXNbaSAqIDIgKyAxXSA9IGludGVyc2VjdGlvblsxXTtcbiAgfVxuICByZXR1cm4gdmVydGljZXM7XG59O1xudmFyIGV4cGFuZFBvbHlnb24gPSBmdW5jdGlvbiBleHBhbmRQb2x5Z29uKHBvaW50cywgcGFkKSB7XG4gIHZhciBleHBhbmRlZExpbmVTZXQgPSBuZXcgQXJyYXkocG9pbnRzLmxlbmd0aCAqIDIpO1xuICB2YXIgY3VycmVudFBvaW50WCwgY3VycmVudFBvaW50WSwgbmV4dFBvaW50WCwgbmV4dFBvaW50WTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoIC8gMjsgaSsrKSB7XG4gICAgY3VycmVudFBvaW50WCA9IHBvaW50c1tpICogMl07XG4gICAgY3VycmVudFBvaW50WSA9IHBvaW50c1tpICogMiArIDFdO1xuICAgIGlmIChpIDwgcG9pbnRzLmxlbmd0aCAvIDIgLSAxKSB7XG4gICAgICBuZXh0UG9pbnRYID0gcG9pbnRzWyhpICsgMSkgKiAyXTtcbiAgICAgIG5leHRQb2ludFkgPSBwb2ludHNbKGkgKyAxKSAqIDIgKyAxXTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmV4dFBvaW50WCA9IHBvaW50c1swXTtcbiAgICAgIG5leHRQb2ludFkgPSBwb2ludHNbMV07XG4gICAgfVxuXG4gICAgLy8gQ3VycmVudCBsaW5lOiBbY3VycmVudFBvaW50WCwgY3VycmVudFBvaW50WV0gdG8gW25leHRQb2ludFgsIG5leHRQb2ludFldXG5cbiAgICAvLyBBc3N1bWUgQ0NXIHBvbHlnb24gd2luZGluZ1xuXG4gICAgdmFyIG9mZnNldFggPSBuZXh0UG9pbnRZIC0gY3VycmVudFBvaW50WTtcbiAgICB2YXIgb2Zmc2V0WSA9IC0obmV4dFBvaW50WCAtIGN1cnJlbnRQb2ludFgpO1xuXG4gICAgLy8gTm9ybWFsaXplXG4gICAgdmFyIG9mZnNldExlbmd0aCA9IE1hdGguc3FydChvZmZzZXRYICogb2Zmc2V0WCArIG9mZnNldFkgKiBvZmZzZXRZKTtcbiAgICB2YXIgbm9ybWFsaXplZE9mZnNldFggPSBvZmZzZXRYIC8gb2Zmc2V0TGVuZ3RoO1xuICAgIHZhciBub3JtYWxpemVkT2Zmc2V0WSA9IG9mZnNldFkgLyBvZmZzZXRMZW5ndGg7XG4gICAgZXhwYW5kZWRMaW5lU2V0W2kgKiA0XSA9IGN1cnJlbnRQb2ludFggKyBub3JtYWxpemVkT2Zmc2V0WCAqIHBhZDtcbiAgICBleHBhbmRlZExpbmVTZXRbaSAqIDQgKyAxXSA9IGN1cnJlbnRQb2ludFkgKyBub3JtYWxpemVkT2Zmc2V0WSAqIHBhZDtcbiAgICBleHBhbmRlZExpbmVTZXRbaSAqIDQgKyAyXSA9IG5leHRQb2ludFggKyBub3JtYWxpemVkT2Zmc2V0WCAqIHBhZDtcbiAgICBleHBhbmRlZExpbmVTZXRbaSAqIDQgKyAzXSA9IG5leHRQb2ludFkgKyBub3JtYWxpemVkT2Zmc2V0WSAqIHBhZDtcbiAgfVxuICByZXR1cm4gZXhwYW5kZWRMaW5lU2V0O1xufTtcbnZhciBpbnRlcnNlY3RMaW5lRWxsaXBzZSA9IGZ1bmN0aW9uIGludGVyc2VjdExpbmVFbGxpcHNlKHgsIHksIGNlbnRlclgsIGNlbnRlclksIGVsbGlwc2VXcmFkaXVzLCBlbGxpcHNlSHJhZGl1cykge1xuICB2YXIgZGlzcFggPSBjZW50ZXJYIC0geDtcbiAgdmFyIGRpc3BZID0gY2VudGVyWSAtIHk7XG4gIGRpc3BYIC89IGVsbGlwc2VXcmFkaXVzO1xuICBkaXNwWSAvPSBlbGxpcHNlSHJhZGl1cztcbiAgdmFyIGxlbiA9IE1hdGguc3FydChkaXNwWCAqIGRpc3BYICsgZGlzcFkgKiBkaXNwWSk7XG4gIHZhciBuZXdMZW5ndGggPSBsZW4gLSAxO1xuICBpZiAobmV3TGVuZ3RoIDwgMCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICB2YXIgbGVuUHJvcG9ydGlvbiA9IG5ld0xlbmd0aCAvIGxlbjtcbiAgcmV0dXJuIFsoY2VudGVyWCAtIHgpICogbGVuUHJvcG9ydGlvbiArIHgsIChjZW50ZXJZIC0geSkgKiBsZW5Qcm9wb3J0aW9uICsgeV07XG59O1xudmFyIGNoZWNrSW5FbGxpcHNlID0gZnVuY3Rpb24gY2hlY2tJbkVsbGlwc2UoeCwgeSwgd2lkdGgsIGhlaWdodCwgY2VudGVyWCwgY2VudGVyWSwgcGFkZGluZykge1xuICB4IC09IGNlbnRlclg7XG4gIHkgLT0gY2VudGVyWTtcbiAgeCAvPSB3aWR0aCAvIDIgKyBwYWRkaW5nO1xuICB5IC89IGhlaWdodCAvIDIgKyBwYWRkaW5nO1xuICByZXR1cm4geCAqIHggKyB5ICogeSA8PSAxO1xufTtcblxuLy8gUmV0dXJucyBpbnRlcnNlY3Rpb25zIG9mIGluY3JlYXNpbmcgZGlzdGFuY2UgZnJvbSBsaW5lJ3Mgc3RhcnQgcG9pbnRcbnZhciBpbnRlcnNlY3RMaW5lQ2lyY2xlID0gZnVuY3Rpb24gaW50ZXJzZWN0TGluZUNpcmNsZSh4MSwgeTEsIHgyLCB5MiwgY2VudGVyWCwgY2VudGVyWSwgcmFkaXVzKSB7XG4gIC8vIENhbGN1bGF0ZSBkLCBkaXJlY3Rpb24gdmVjdG9yIG9mIGxpbmVcbiAgdmFyIGQgPSBbeDIgLSB4MSwgeTIgLSB5MV07IC8vIERpcmVjdGlvbiB2ZWN0b3Igb2YgbGluZVxuICB2YXIgZiA9IFt4MSAtIGNlbnRlclgsIHkxIC0gY2VudGVyWV07XG4gIHZhciBhID0gZFswXSAqIGRbMF0gKyBkWzFdICogZFsxXTtcbiAgdmFyIGIgPSAyICogKGZbMF0gKiBkWzBdICsgZlsxXSAqIGRbMV0pO1xuICB2YXIgYyA9IGZbMF0gKiBmWzBdICsgZlsxXSAqIGZbMV0gLSByYWRpdXMgKiByYWRpdXM7XG4gIHZhciBkaXNjcmltaW5hbnQgPSBiICogYiAtIDQgKiBhICogYztcbiAgaWYgKGRpc2NyaW1pbmFudCA8IDApIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgdmFyIHQxID0gKC1iICsgTWF0aC5zcXJ0KGRpc2NyaW1pbmFudCkpIC8gKDIgKiBhKTtcbiAgdmFyIHQyID0gKC1iIC0gTWF0aC5zcXJ0KGRpc2NyaW1pbmFudCkpIC8gKDIgKiBhKTtcbiAgdmFyIHRNaW4gPSBNYXRoLm1pbih0MSwgdDIpO1xuICB2YXIgdE1heCA9IE1hdGgubWF4KHQxLCB0Mik7XG4gIHZhciBpblJhbmdlUGFyYW1zID0gW107XG4gIGlmICh0TWluID49IDAgJiYgdE1pbiA8PSAxKSB7XG4gICAgaW5SYW5nZVBhcmFtcy5wdXNoKHRNaW4pO1xuICB9XG4gIGlmICh0TWF4ID49IDAgJiYgdE1heCA8PSAxKSB7XG4gICAgaW5SYW5nZVBhcmFtcy5wdXNoKHRNYXgpO1xuICB9XG4gIGlmIChpblJhbmdlUGFyYW1zLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICB2YXIgbmVhckludGVyc2VjdGlvblggPSBpblJhbmdlUGFyYW1zWzBdICogZFswXSArIHgxO1xuICB2YXIgbmVhckludGVyc2VjdGlvblkgPSBpblJhbmdlUGFyYW1zWzBdICogZFsxXSArIHkxO1xuICBpZiAoaW5SYW5nZVBhcmFtcy5sZW5ndGggPiAxKSB7XG4gICAgaWYgKGluUmFuZ2VQYXJhbXNbMF0gPT0gaW5SYW5nZVBhcmFtc1sxXSkge1xuICAgICAgcmV0dXJuIFtuZWFySW50ZXJzZWN0aW9uWCwgbmVhckludGVyc2VjdGlvblldO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZmFySW50ZXJzZWN0aW9uWCA9IGluUmFuZ2VQYXJhbXNbMV0gKiBkWzBdICsgeDE7XG4gICAgICB2YXIgZmFySW50ZXJzZWN0aW9uWSA9IGluUmFuZ2VQYXJhbXNbMV0gKiBkWzFdICsgeTE7XG4gICAgICByZXR1cm4gW25lYXJJbnRlcnNlY3Rpb25YLCBuZWFySW50ZXJzZWN0aW9uWSwgZmFySW50ZXJzZWN0aW9uWCwgZmFySW50ZXJzZWN0aW9uWV07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBbbmVhckludGVyc2VjdGlvblgsIG5lYXJJbnRlcnNlY3Rpb25ZXTtcbiAgfVxufTtcbnZhciBtaWRPZlRocmVlID0gZnVuY3Rpb24gbWlkT2ZUaHJlZShhLCBiLCBjKSB7XG4gIGlmIChiIDw9IGEgJiYgYSA8PSBjIHx8IGMgPD0gYSAmJiBhIDw9IGIpIHtcbiAgICByZXR1cm4gYTtcbiAgfSBlbHNlIGlmIChhIDw9IGIgJiYgYiA8PSBjIHx8IGMgPD0gYiAmJiBiIDw9IGEpIHtcbiAgICByZXR1cm4gYjtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYztcbiAgfVxufTtcblxuLy8gKHgxLHkxKT0+KHgyLHkyKSBpbnRlcnNlY3Qgd2l0aCAoeDMseTMpPT4oeDQseTQpXG52YXIgZmluaXRlTGluZXNJbnRlcnNlY3QgPSBmdW5jdGlvbiBmaW5pdGVMaW5lc0ludGVyc2VjdCh4MSwgeTEsIHgyLCB5MiwgeDMsIHkzLCB4NCwgeTQsIGluZmluaXRlTGluZXMpIHtcbiAgdmFyIGR4MTMgPSB4MSAtIHgzO1xuICB2YXIgZHgyMSA9IHgyIC0geDE7XG4gIHZhciBkeDQzID0geDQgLSB4MztcbiAgdmFyIGR5MTMgPSB5MSAtIHkzO1xuICB2YXIgZHkyMSA9IHkyIC0geTE7XG4gIHZhciBkeTQzID0geTQgLSB5MztcbiAgdmFyIHVhX3QgPSBkeDQzICogZHkxMyAtIGR5NDMgKiBkeDEzO1xuICB2YXIgdWJfdCA9IGR4MjEgKiBkeTEzIC0gZHkyMSAqIGR4MTM7XG4gIHZhciB1X2IgPSBkeTQzICogZHgyMSAtIGR4NDMgKiBkeTIxO1xuICBpZiAodV9iICE9PSAwKSB7XG4gICAgdmFyIHVhID0gdWFfdCAvIHVfYjtcbiAgICB2YXIgdWIgPSB1Yl90IC8gdV9iO1xuICAgIHZhciBmbHB0VGhyZXNob2xkID0gMC4wMDE7XG4gICAgdmFyIF9taW4gPSAwIC0gZmxwdFRocmVzaG9sZDtcbiAgICB2YXIgX21heCA9IDEgKyBmbHB0VGhyZXNob2xkO1xuICAgIGlmIChfbWluIDw9IHVhICYmIHVhIDw9IF9tYXggJiYgX21pbiA8PSB1YiAmJiB1YiA8PSBfbWF4KSB7XG4gICAgICByZXR1cm4gW3gxICsgdWEgKiBkeDIxLCB5MSArIHVhICogZHkyMV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghaW5maW5pdGVMaW5lcykge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gW3gxICsgdWEgKiBkeDIxLCB5MSArIHVhICogZHkyMV07XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmICh1YV90ID09PSAwIHx8IHViX3QgPT09IDApIHtcbiAgICAgIC8vIFBhcmFsbGVsLCBjb2luY2lkZW50IGxpbmVzLiBDaGVjayBpZiBvdmVybGFwXG5cbiAgICAgIC8vIENoZWNrIGVuZHBvaW50IG9mIHNlY29uZCBsaW5lXG4gICAgICBpZiAobWlkT2ZUaHJlZSh4MSwgeDIsIHg0KSA9PT0geDQpIHtcbiAgICAgICAgcmV0dXJuIFt4NCwgeTRdO1xuICAgICAgfVxuXG4gICAgICAvLyBDaGVjayBzdGFydCBwb2ludCBvZiBzZWNvbmQgbGluZVxuICAgICAgaWYgKG1pZE9mVGhyZWUoeDEsIHgyLCB4MykgPT09IHgzKSB7XG4gICAgICAgIHJldHVybiBbeDMsIHkzXTtcbiAgICAgIH1cblxuICAgICAgLy8gRW5kcG9pbnQgb2YgZmlyc3QgbGluZVxuICAgICAgaWYgKG1pZE9mVGhyZWUoeDMsIHg0LCB4MikgPT09IHgyKSB7XG4gICAgICAgIHJldHVybiBbeDIsIHkyXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBbXTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUGFyYWxsZWwsIG5vbi1jb2luY2lkZW50XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICB9XG59O1xuXG4vLyBtYXRoLnBvbHlnb25JbnRlcnNlY3RMaW5lKCB4LCB5LCBiYXNlUG9pbnRzLCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0LCBwYWRkaW5nIClcbi8vIGludGVyc2VjdCBhIG5vZGUgcG9seWdvbiAocHRzIHRyYW5zZm9ybWVkKVxuLy9cbi8vIG1hdGgucG9seWdvbkludGVyc2VjdExpbmUoIHgsIHksIGJhc2VQb2ludHMsIGNlbnRlclgsIGNlbnRlclkgKVxuLy8gaW50ZXJzZWN0IHRoZSBwb2ludHMgKG5vIHRyYW5zZm9ybSlcbnZhciBwb2x5Z29uSW50ZXJzZWN0TGluZSA9IGZ1bmN0aW9uIHBvbHlnb25JbnRlcnNlY3RMaW5lKHgsIHksIGJhc2VQb2ludHMsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQsIHBhZGRpbmcpIHtcbiAgdmFyIGludGVyc2VjdGlvbnMgPSBbXTtcbiAgdmFyIGludGVyc2VjdGlvbjtcbiAgdmFyIHRyYW5zZm9ybWVkUG9pbnRzID0gbmV3IEFycmF5KGJhc2VQb2ludHMubGVuZ3RoKTtcbiAgdmFyIGRvVHJhbnNmb3JtID0gdHJ1ZTtcbiAgaWYgKHdpZHRoID09IG51bGwpIHtcbiAgICBkb1RyYW5zZm9ybSA9IGZhbHNlO1xuICB9XG4gIHZhciBwb2ludHM7XG4gIGlmIChkb1RyYW5zZm9ybSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHJhbnNmb3JtZWRQb2ludHMubGVuZ3RoIC8gMjsgaSsrKSB7XG4gICAgICB0cmFuc2Zvcm1lZFBvaW50c1tpICogMl0gPSBiYXNlUG9pbnRzW2kgKiAyXSAqIHdpZHRoICsgY2VudGVyWDtcbiAgICAgIHRyYW5zZm9ybWVkUG9pbnRzW2kgKiAyICsgMV0gPSBiYXNlUG9pbnRzW2kgKiAyICsgMV0gKiBoZWlnaHQgKyBjZW50ZXJZO1xuICAgIH1cbiAgICBpZiAocGFkZGluZyA+IDApIHtcbiAgICAgIHZhciBleHBhbmRlZExpbmVTZXQgPSBleHBhbmRQb2x5Z29uKHRyYW5zZm9ybWVkUG9pbnRzLCAtcGFkZGluZyk7XG4gICAgICBwb2ludHMgPSBqb2luTGluZXMoZXhwYW5kZWRMaW5lU2V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcG9pbnRzID0gdHJhbnNmb3JtZWRQb2ludHM7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHBvaW50cyA9IGJhc2VQb2ludHM7XG4gIH1cbiAgdmFyIGN1cnJlbnRYLCBjdXJyZW50WSwgbmV4dFgsIG5leHRZO1xuICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBwb2ludHMubGVuZ3RoIC8gMjsgX2kyKyspIHtcbiAgICBjdXJyZW50WCA9IHBvaW50c1tfaTIgKiAyXTtcbiAgICBjdXJyZW50WSA9IHBvaW50c1tfaTIgKiAyICsgMV07XG4gICAgaWYgKF9pMiA8IHBvaW50cy5sZW5ndGggLyAyIC0gMSkge1xuICAgICAgbmV4dFggPSBwb2ludHNbKF9pMiArIDEpICogMl07XG4gICAgICBuZXh0WSA9IHBvaW50c1soX2kyICsgMSkgKiAyICsgMV07XG4gICAgfSBlbHNlIHtcbiAgICAgIG5leHRYID0gcG9pbnRzWzBdO1xuICAgICAgbmV4dFkgPSBwb2ludHNbMV07XG4gICAgfVxuICAgIGludGVyc2VjdGlvbiA9IGZpbml0ZUxpbmVzSW50ZXJzZWN0KHgsIHksIGNlbnRlclgsIGNlbnRlclksIGN1cnJlbnRYLCBjdXJyZW50WSwgbmV4dFgsIG5leHRZKTtcbiAgICBpZiAoaW50ZXJzZWN0aW9uLmxlbmd0aCAhPT0gMCkge1xuICAgICAgaW50ZXJzZWN0aW9ucy5wdXNoKGludGVyc2VjdGlvblswXSwgaW50ZXJzZWN0aW9uWzFdKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGludGVyc2VjdGlvbnM7XG59O1xudmFyIHJvdW5kUG9seWdvbkludGVyc2VjdExpbmUgPSBmdW5jdGlvbiByb3VuZFBvbHlnb25JbnRlcnNlY3RMaW5lKHgsIHksIGJhc2VQb2ludHMsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQsIHBhZGRpbmcsIGNvcm5lcnMpIHtcbiAgdmFyIGludGVyc2VjdGlvbnMgPSBbXTtcbiAgdmFyIGludGVyc2VjdGlvbjtcbiAgdmFyIGxpbmVzID0gbmV3IEFycmF5KGJhc2VQb2ludHMubGVuZ3RoICogMik7XG4gIGNvcm5lcnMuZm9yRWFjaChmdW5jdGlvbiAoY29ybmVyLCBpKSB7XG4gICAgaWYgKGkgPT09IDApIHtcbiAgICAgIGxpbmVzW2xpbmVzLmxlbmd0aCAtIDJdID0gY29ybmVyLnN0YXJ0WDtcbiAgICAgIGxpbmVzW2xpbmVzLmxlbmd0aCAtIDFdID0gY29ybmVyLnN0YXJ0WTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGluZXNbaSAqIDQgLSAyXSA9IGNvcm5lci5zdGFydFg7XG4gICAgICBsaW5lc1tpICogNCAtIDFdID0gY29ybmVyLnN0YXJ0WTtcbiAgICB9XG4gICAgbGluZXNbaSAqIDRdID0gY29ybmVyLnN0b3BYO1xuICAgIGxpbmVzW2kgKiA0ICsgMV0gPSBjb3JuZXIuc3RvcFk7XG4gICAgaW50ZXJzZWN0aW9uID0gaW50ZXJzZWN0TGluZUNpcmNsZSh4LCB5LCBjZW50ZXJYLCBjZW50ZXJZLCBjb3JuZXIuY3gsIGNvcm5lci5jeSwgY29ybmVyLnJhZGl1cyk7XG4gICAgaWYgKGludGVyc2VjdGlvbi5sZW5ndGggIT09IDApIHtcbiAgICAgIGludGVyc2VjdGlvbnMucHVzaChpbnRlcnNlY3Rpb25bMF0sIGludGVyc2VjdGlvblsxXSk7XG4gICAgfVxuICB9KTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGggLyA0OyBpKyspIHtcbiAgICBpbnRlcnNlY3Rpb24gPSBmaW5pdGVMaW5lc0ludGVyc2VjdCh4LCB5LCBjZW50ZXJYLCBjZW50ZXJZLCBsaW5lc1tpICogNF0sIGxpbmVzW2kgKiA0ICsgMV0sIGxpbmVzW2kgKiA0ICsgMl0sIGxpbmVzW2kgKiA0ICsgM10sIGZhbHNlKTtcbiAgICBpZiAoaW50ZXJzZWN0aW9uLmxlbmd0aCAhPT0gMCkge1xuICAgICAgaW50ZXJzZWN0aW9ucy5wdXNoKGludGVyc2VjdGlvblswXSwgaW50ZXJzZWN0aW9uWzFdKTtcbiAgICB9XG4gIH1cbiAgaWYgKGludGVyc2VjdGlvbnMubGVuZ3RoID4gMikge1xuICAgIHZhciBsb3dlc3RJbnRlcnNlY3Rpb24gPSBbaW50ZXJzZWN0aW9uc1swXSwgaW50ZXJzZWN0aW9uc1sxXV07XG4gICAgdmFyIGxvd2VzdFNxdWFyZWREaXN0YW5jZSA9IE1hdGgucG93KGxvd2VzdEludGVyc2VjdGlvblswXSAtIHgsIDIpICsgTWF0aC5wb3cobG93ZXN0SW50ZXJzZWN0aW9uWzFdIC0geSwgMik7XG4gICAgZm9yICh2YXIgX2kzID0gMTsgX2kzIDwgaW50ZXJzZWN0aW9ucy5sZW5ndGggLyAyOyBfaTMrKykge1xuICAgICAgdmFyIHNxdWFyZWREaXN0YW5jZSA9IE1hdGgucG93KGludGVyc2VjdGlvbnNbX2kzICogMl0gLSB4LCAyKSArIE1hdGgucG93KGludGVyc2VjdGlvbnNbX2kzICogMiArIDFdIC0geSwgMik7XG4gICAgICBpZiAoc3F1YXJlZERpc3RhbmNlIDw9IGxvd2VzdFNxdWFyZWREaXN0YW5jZSkge1xuICAgICAgICBsb3dlc3RJbnRlcnNlY3Rpb25bMF0gPSBpbnRlcnNlY3Rpb25zW19pMyAqIDJdO1xuICAgICAgICBsb3dlc3RJbnRlcnNlY3Rpb25bMV0gPSBpbnRlcnNlY3Rpb25zW19pMyAqIDIgKyAxXTtcbiAgICAgICAgbG93ZXN0U3F1YXJlZERpc3RhbmNlID0gc3F1YXJlZERpc3RhbmNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbG93ZXN0SW50ZXJzZWN0aW9uO1xuICB9XG4gIHJldHVybiBpbnRlcnNlY3Rpb25zO1xufTtcbnZhciBzaG9ydGVuSW50ZXJzZWN0aW9uID0gZnVuY3Rpb24gc2hvcnRlbkludGVyc2VjdGlvbihpbnRlcnNlY3Rpb24sIG9mZnNldCwgYW1vdW50KSB7XG4gIHZhciBkaXNwID0gW2ludGVyc2VjdGlvblswXSAtIG9mZnNldFswXSwgaW50ZXJzZWN0aW9uWzFdIC0gb2Zmc2V0WzFdXTtcbiAgdmFyIGxlbmd0aCA9IE1hdGguc3FydChkaXNwWzBdICogZGlzcFswXSArIGRpc3BbMV0gKiBkaXNwWzFdKTtcbiAgdmFyIGxlblJhdGlvID0gKGxlbmd0aCAtIGFtb3VudCkgLyBsZW5ndGg7XG4gIGlmIChsZW5SYXRpbyA8IDApIHtcbiAgICBsZW5SYXRpbyA9IDAuMDAwMDE7XG4gIH1cbiAgcmV0dXJuIFtvZmZzZXRbMF0gKyBsZW5SYXRpbyAqIGRpc3BbMF0sIG9mZnNldFsxXSArIGxlblJhdGlvICogZGlzcFsxXV07XG59O1xudmFyIGdlbmVyYXRlVW5pdE5nb25Qb2ludHNGaXRUb1NxdWFyZSA9IGZ1bmN0aW9uIGdlbmVyYXRlVW5pdE5nb25Qb2ludHNGaXRUb1NxdWFyZShzaWRlcywgcm90YXRpb25SYWRpYW5zKSB7XG4gIHZhciBwb2ludHMgPSBnZW5lcmF0ZVVuaXROZ29uUG9pbnRzKHNpZGVzLCByb3RhdGlvblJhZGlhbnMpO1xuICBwb2ludHMgPSBmaXRQb2x5Z29uVG9TcXVhcmUocG9pbnRzKTtcbiAgcmV0dXJuIHBvaW50cztcbn07XG52YXIgZml0UG9seWdvblRvU3F1YXJlID0gZnVuY3Rpb24gZml0UG9seWdvblRvU3F1YXJlKHBvaW50cykge1xuICB2YXIgeCwgeTtcbiAgdmFyIHNpZGVzID0gcG9pbnRzLmxlbmd0aCAvIDI7XG4gIHZhciBtaW5YID0gSW5maW5pdHksXG4gICAgbWluWSA9IEluZmluaXR5LFxuICAgIG1heFggPSAtSW5maW5pdHksXG4gICAgbWF4WSA9IC1JbmZpbml0eTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaWRlczsgaSsrKSB7XG4gICAgeCA9IHBvaW50c1syICogaV07XG4gICAgeSA9IHBvaW50c1syICogaSArIDFdO1xuICAgIG1pblggPSBNYXRoLm1pbihtaW5YLCB4KTtcbiAgICBtYXhYID0gTWF0aC5tYXgobWF4WCwgeCk7XG4gICAgbWluWSA9IE1hdGgubWluKG1pblksIHkpO1xuICAgIG1heFkgPSBNYXRoLm1heChtYXhZLCB5KTtcbiAgfVxuXG4gIC8vIHN0cmV0Y2ggZmFjdG9yc1xuICB2YXIgc3ggPSAyIC8gKG1heFggLSBtaW5YKTtcbiAgdmFyIHN5ID0gMiAvIChtYXhZIC0gbWluWSk7XG4gIGZvciAodmFyIF9pNCA9IDA7IF9pNCA8IHNpZGVzOyBfaTQrKykge1xuICAgIHggPSBwb2ludHNbMiAqIF9pNF0gPSBwb2ludHNbMiAqIF9pNF0gKiBzeDtcbiAgICB5ID0gcG9pbnRzWzIgKiBfaTQgKyAxXSA9IHBvaW50c1syICogX2k0ICsgMV0gKiBzeTtcbiAgICBtaW5YID0gTWF0aC5taW4obWluWCwgeCk7XG4gICAgbWF4WCA9IE1hdGgubWF4KG1heFgsIHgpO1xuICAgIG1pblkgPSBNYXRoLm1pbihtaW5ZLCB5KTtcbiAgICBtYXhZID0gTWF0aC5tYXgobWF4WSwgeSk7XG4gIH1cbiAgaWYgKG1pblkgPCAtMSkge1xuICAgIGZvciAodmFyIF9pNSA9IDA7IF9pNSA8IHNpZGVzOyBfaTUrKykge1xuICAgICAgeSA9IHBvaW50c1syICogX2k1ICsgMV0gPSBwb2ludHNbMiAqIF9pNSArIDFdICsgKC0xIC0gbWluWSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBwb2ludHM7XG59O1xudmFyIGdlbmVyYXRlVW5pdE5nb25Qb2ludHMgPSBmdW5jdGlvbiBnZW5lcmF0ZVVuaXROZ29uUG9pbnRzKHNpZGVzLCByb3RhdGlvblJhZGlhbnMpIHtcbiAgdmFyIGluY3JlbWVudCA9IDEuMCAvIHNpZGVzICogMiAqIE1hdGguUEk7XG4gIHZhciBzdGFydEFuZ2xlID0gc2lkZXMgJSAyID09PSAwID8gTWF0aC5QSSAvIDIuMCArIGluY3JlbWVudCAvIDIuMCA6IE1hdGguUEkgLyAyLjA7XG4gIHN0YXJ0QW5nbGUgKz0gcm90YXRpb25SYWRpYW5zO1xuICB2YXIgcG9pbnRzID0gbmV3IEFycmF5KHNpZGVzICogMik7XG4gIHZhciBjdXJyZW50QW5nbGU7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc2lkZXM7IGkrKykge1xuICAgIGN1cnJlbnRBbmdsZSA9IGkgKiBpbmNyZW1lbnQgKyBzdGFydEFuZ2xlO1xuICAgIHBvaW50c1syICogaV0gPSBNYXRoLmNvcyhjdXJyZW50QW5nbGUpOyAvLyB4XG4gICAgcG9pbnRzWzIgKiBpICsgMV0gPSBNYXRoLnNpbigtY3VycmVudEFuZ2xlKTsgLy8geVxuICB9XG5cbiAgcmV0dXJuIHBvaW50cztcbn07XG5cbi8vIFNldCB0aGUgZGVmYXVsdCByYWRpdXMsIHVubGVzcyBoYWxmIG9mIHdpZHRoIG9yIGhlaWdodCBpcyBzbWFsbGVyIHRoYW4gZGVmYXVsdFxudmFyIGdldFJvdW5kUmVjdGFuZ2xlUmFkaXVzID0gZnVuY3Rpb24gZ2V0Um91bmRSZWN0YW5nbGVSYWRpdXMod2lkdGgsIGhlaWdodCkge1xuICByZXR1cm4gTWF0aC5taW4od2lkdGggLyA0LCBoZWlnaHQgLyA0LCA4KTtcbn07XG5cbi8vIFNldCB0aGUgZGVmYXVsdCByYWRpdXNcbnZhciBnZXRSb3VuZFBvbHlnb25SYWRpdXMgPSBmdW5jdGlvbiBnZXRSb3VuZFBvbHlnb25SYWRpdXMod2lkdGgsIGhlaWdodCkge1xuICByZXR1cm4gTWF0aC5taW4od2lkdGggLyAxMCwgaGVpZ2h0IC8gMTAsIDgpO1xufTtcbnZhciBnZXRDdXRSZWN0YW5nbGVDb3JuZXJMZW5ndGggPSBmdW5jdGlvbiBnZXRDdXRSZWN0YW5nbGVDb3JuZXJMZW5ndGgoKSB7XG4gIHJldHVybiA4O1xufTtcbnZhciBiZXppZXJQdHNUb1F1YWRDb2VmZiA9IGZ1bmN0aW9uIGJlemllclB0c1RvUXVhZENvZWZmKHAwLCBwMSwgcDIpIHtcbiAgcmV0dXJuIFtwMCAtIDIgKiBwMSArIHAyLCAyICogKHAxIC0gcDApLCBwMF07XG59O1xuXG4vLyBnZXQgY3VydmUgd2lkdGgsIGhlaWdodCwgYW5kIGNvbnRyb2wgcG9pbnQgcG9zaXRpb24gb2Zmc2V0cyBhcyBhIHBlcmNlbnRhZ2Ugb2Ygbm9kZSBoZWlnaHQgLyB3aWR0aFxudmFyIGdldEJhcnJlbEN1cnZlQ29uc3RhbnRzID0gZnVuY3Rpb24gZ2V0QmFycmVsQ3VydmVDb25zdGFudHMod2lkdGgsIGhlaWdodCkge1xuICByZXR1cm4ge1xuICAgIGhlaWdodE9mZnNldDogTWF0aC5taW4oMTUsIDAuMDUgKiBoZWlnaHQpLFxuICAgIHdpZHRoT2Zmc2V0OiBNYXRoLm1pbigxMDAsIDAuMjUgKiB3aWR0aCksXG4gICAgY3RybFB0T2Zmc2V0UGN0OiAwLjA1XG4gIH07XG59O1xuXG52YXIgcGFnZVJhbmtEZWZhdWx0cyA9IGRlZmF1bHRzJGcoe1xuICBkYW1waW5nRmFjdG9yOiAwLjgsXG4gIHByZWNpc2lvbjogMC4wMDAwMDEsXG4gIGl0ZXJhdGlvbnM6IDIwMCxcbiAgd2VpZ2h0OiBmdW5jdGlvbiB3ZWlnaHQoZWRnZSkge1xuICAgIHJldHVybiAxO1xuICB9XG59KTtcbnZhciBlbGVzZm4kbyA9IHtcbiAgcGFnZVJhbms6IGZ1bmN0aW9uIHBhZ2VSYW5rKG9wdGlvbnMpIHtcbiAgICB2YXIgX3BhZ2VSYW5rRGVmYXVsdHMgPSBwYWdlUmFua0RlZmF1bHRzKG9wdGlvbnMpLFxuICAgICAgZGFtcGluZ0ZhY3RvciA9IF9wYWdlUmFua0RlZmF1bHRzLmRhbXBpbmdGYWN0b3IsXG4gICAgICBwcmVjaXNpb24gPSBfcGFnZVJhbmtEZWZhdWx0cy5wcmVjaXNpb24sXG4gICAgICBpdGVyYXRpb25zID0gX3BhZ2VSYW5rRGVmYXVsdHMuaXRlcmF0aW9ucyxcbiAgICAgIHdlaWdodCA9IF9wYWdlUmFua0RlZmF1bHRzLndlaWdodDtcbiAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5O1xuICAgIHZhciBfdGhpcyRieUdyb3VwID0gdGhpcy5ieUdyb3VwKCksXG4gICAgICBub2RlcyA9IF90aGlzJGJ5R3JvdXAubm9kZXMsXG4gICAgICBlZGdlcyA9IF90aGlzJGJ5R3JvdXAuZWRnZXM7XG4gICAgdmFyIG51bU5vZGVzID0gbm9kZXMubGVuZ3RoO1xuICAgIHZhciBudW1Ob2Rlc1NxZCA9IG51bU5vZGVzICogbnVtTm9kZXM7XG4gICAgdmFyIG51bUVkZ2VzID0gZWRnZXMubGVuZ3RoO1xuXG4gICAgLy8gQ29uc3RydWN0IHRyYW5zcG9zZWQgYWRqYWNlbmN5IG1hdHJpeFxuICAgIC8vIEZpcnN0IGxldHMgaGF2ZSBhIHplcm9lZCBtYXRyaXggb2YgdGhlIHJpZ2h0IHNpemVcbiAgICAvLyBXZSdsbCBhbHNvIGtlZXAgdHJhY2sgb2YgdGhlIHN1bSBvZiBlYWNoIGNvbHVtblxuICAgIHZhciBtYXRyaXggPSBuZXcgQXJyYXkobnVtTm9kZXNTcWQpO1xuICAgIHZhciBjb2x1bW5TdW0gPSBuZXcgQXJyYXkobnVtTm9kZXMpO1xuICAgIHZhciBhZGRpdGlvbmFsUHJvYiA9ICgxIC0gZGFtcGluZ0ZhY3RvcikgLyBudW1Ob2RlcztcblxuICAgIC8vIENyZWF0ZSBudWxsIG1hdHJpeFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtTm9kZXM7IGkrKykge1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBudW1Ob2RlczsgaisrKSB7XG4gICAgICAgIHZhciBuID0gaSAqIG51bU5vZGVzICsgajtcbiAgICAgICAgbWF0cml4W25dID0gMDtcbiAgICAgIH1cbiAgICAgIGNvbHVtblN1bVtpXSA9IDA7XG4gICAgfVxuXG4gICAgLy8gTm93LCBwcm9jZXNzIGVkZ2VzXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IG51bUVkZ2VzOyBfaSsrKSB7XG4gICAgICB2YXIgZWRnZSA9IGVkZ2VzW19pXTtcbiAgICAgIHZhciBzcmNJZCA9IGVkZ2UuZGF0YSgnc291cmNlJyk7XG4gICAgICB2YXIgdGd0SWQgPSBlZGdlLmRhdGEoJ3RhcmdldCcpO1xuXG4gICAgICAvLyBEb24ndCBpbmNsdWRlIGxvb3BzIGluIHRoZSBtYXRyaXhcbiAgICAgIGlmIChzcmNJZCA9PT0gdGd0SWQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB2YXIgcyA9IG5vZGVzLmluZGV4T2ZJZChzcmNJZCk7XG4gICAgICB2YXIgdCA9IG5vZGVzLmluZGV4T2ZJZCh0Z3RJZCk7XG4gICAgICB2YXIgdyA9IHdlaWdodChlZGdlKTtcbiAgICAgIHZhciBfbiA9IHQgKiBudW1Ob2RlcyArIHM7XG5cbiAgICAgIC8vIFVwZGF0ZSBtYXRyaXhcbiAgICAgIG1hdHJpeFtfbl0gKz0gdztcblxuICAgICAgLy8gVXBkYXRlIGNvbHVtbiBzdW1cbiAgICAgIGNvbHVtblN1bVtzXSArPSB3O1xuICAgIH1cblxuICAgIC8vIEFkZCBhZGRpdGlvbmFsIHByb2JhYmlsaXR5IGJhc2VkIG9uIGRhbXBpbmcgZmFjdG9yXG4gICAgLy8gQWxzbywgdGFrZSBpbnRvIGFjY291bnQgY29sdW1ucyB0aGF0IGhhdmUgc3VtID0gMFxuICAgIHZhciBwID0gMS4wIC8gbnVtTm9kZXMgKyBhZGRpdGlvbmFsUHJvYjsgLy8gU2hvcnRoYW5kXG5cbiAgICAvLyBUcmF2ZXJzZSBtYXRyaXgsIGNvbHVtbiBieSBjb2x1bW5cbiAgICBmb3IgKHZhciBfaiA9IDA7IF9qIDwgbnVtTm9kZXM7IF9qKyspIHtcbiAgICAgIGlmIChjb2x1bW5TdW1bX2pdID09PSAwKSB7XG4gICAgICAgIC8vIE5vICdsaW5rcycgb3V0IGZyb20gbm9kZSBqdGgsIGFzc3VtZSBlcXVhbCBwcm9iYWJpbGl0eSBmb3IgZWFjaCBwb3NzaWJsZSBub2RlXG4gICAgICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IG51bU5vZGVzOyBfaTIrKykge1xuICAgICAgICAgIHZhciBfbjIgPSBfaTIgKiBudW1Ob2RlcyArIF9qO1xuICAgICAgICAgIG1hdHJpeFtfbjJdID0gcDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gTm9kZSBqdGggaGFzIG91dGdvaW5nIGxpbmssIGNvbXB1dGUgbm9ybWFsaXplZCBwcm9iYWJpbGl0aWVzXG4gICAgICAgIGZvciAodmFyIF9pMyA9IDA7IF9pMyA8IG51bU5vZGVzOyBfaTMrKykge1xuICAgICAgICAgIHZhciBfbjMgPSBfaTMgKiBudW1Ob2RlcyArIF9qO1xuICAgICAgICAgIG1hdHJpeFtfbjNdID0gbWF0cml4W19uM10gLyBjb2x1bW5TdW1bX2pdICsgYWRkaXRpb25hbFByb2I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBDb21wdXRlIGRvbWluYW50IGVpZ2VudmVjdG9yIHVzaW5nIHBvd2VyIG1ldGhvZFxuICAgIHZhciBlaWdlbnZlY3RvciA9IG5ldyBBcnJheShudW1Ob2Rlcyk7XG4gICAgdmFyIHRlbXAgPSBuZXcgQXJyYXkobnVtTm9kZXMpO1xuICAgIHZhciBwcmV2aW91cztcblxuICAgIC8vIFN0YXJ0IHdpdGggYSB2ZWN0b3Igb2YgYWxsIDEnc1xuICAgIC8vIEFsc28sIGluaXRpYWxpemUgYSBudWxsIHZlY3RvciB3aGljaCB3aWxsIGJlIHVzZWQgYXMgc2hvcnRoYW5kXG4gICAgZm9yICh2YXIgX2k0ID0gMDsgX2k0IDwgbnVtTm9kZXM7IF9pNCsrKSB7XG4gICAgICBlaWdlbnZlY3RvcltfaTRdID0gMTtcbiAgICB9XG4gICAgZm9yICh2YXIgaXRlciA9IDA7IGl0ZXIgPCBpdGVyYXRpb25zOyBpdGVyKyspIHtcbiAgICAgIC8vIFRlbXAgYXJyYXkgd2l0aCBhbGwgMCdzXG4gICAgICBmb3IgKHZhciBfaTUgPSAwOyBfaTUgPCBudW1Ob2RlczsgX2k1KyspIHtcbiAgICAgICAgdGVtcFtfaTVdID0gMDtcbiAgICAgIH1cblxuICAgICAgLy8gTXVsdGlwbHkgbWF0cml4IHdpdGggcHJldmlvdXMgcmVzdWx0XG4gICAgICBmb3IgKHZhciBfaTYgPSAwOyBfaTYgPCBudW1Ob2RlczsgX2k2KyspIHtcbiAgICAgICAgZm9yICh2YXIgX2oyID0gMDsgX2oyIDwgbnVtTm9kZXM7IF9qMisrKSB7XG4gICAgICAgICAgdmFyIF9uNCA9IF9pNiAqIG51bU5vZGVzICsgX2oyO1xuICAgICAgICAgIHRlbXBbX2k2XSArPSBtYXRyaXhbX240XSAqIGVpZ2VudmVjdG9yW19qMl07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGluUGxhY2VTdW1Ob3JtYWxpemUodGVtcCk7XG4gICAgICBwcmV2aW91cyA9IGVpZ2VudmVjdG9yO1xuICAgICAgZWlnZW52ZWN0b3IgPSB0ZW1wO1xuICAgICAgdGVtcCA9IHByZXZpb3VzO1xuICAgICAgdmFyIGRpZmYgPSAwO1xuICAgICAgLy8gQ29tcHV0ZSBkaWZmZXJlbmNlIChzcXVhcmVkIG1vZHVsZSkgb2YgYm90aCB2ZWN0b3JzXG4gICAgICBmb3IgKHZhciBfaTcgPSAwOyBfaTcgPCBudW1Ob2RlczsgX2k3KyspIHtcbiAgICAgICAgdmFyIGRlbHRhID0gcHJldmlvdXNbX2k3XSAtIGVpZ2VudmVjdG9yW19pN107XG4gICAgICAgIGRpZmYgKz0gZGVsdGEgKiBkZWx0YTtcbiAgICAgIH1cblxuICAgICAgLy8gSWYgZGlmZmVyZW5jZSBpcyBsZXNzIHRoYW4gdGhlIGRlc2lyZWQgdGhyZXNob2xkLCBzdG9wIGl0ZXJhdGluZ1xuICAgICAgaWYgKGRpZmYgPCBwcmVjaXNpb24pIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ29uc3RydWN0IHJlc3VsdFxuICAgIHZhciByZXMgPSB7XG4gICAgICByYW5rOiBmdW5jdGlvbiByYW5rKG5vZGUpIHtcbiAgICAgICAgbm9kZSA9IGN5LmNvbGxlY3Rpb24obm9kZSlbMF07XG4gICAgICAgIHJldHVybiBlaWdlbnZlY3Rvcltub2Rlcy5pbmRleE9mKG5vZGUpXTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiByZXM7XG4gIH0gLy8gcGFnZVJhbmtcbn07IC8vIGVsZXNmblxuXG52YXIgZGVmYXVsdHMkZiA9IGRlZmF1bHRzJGcoe1xuICByb290OiBudWxsLFxuICB3ZWlnaHQ6IGZ1bmN0aW9uIHdlaWdodChlZGdlKSB7XG4gICAgcmV0dXJuIDE7XG4gIH0sXG4gIGRpcmVjdGVkOiBmYWxzZSxcbiAgYWxwaGE6IDBcbn0pO1xudmFyIGVsZXNmbiRuID0ge1xuICBkZWdyZWVDZW50cmFsaXR5Tm9ybWFsaXplZDogZnVuY3Rpb24gZGVncmVlQ2VudHJhbGl0eU5vcm1hbGl6ZWQob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBkZWZhdWx0cyRmKG9wdGlvbnMpO1xuICAgIHZhciBjeSA9IHRoaXMuY3koKTtcbiAgICB2YXIgbm9kZXMgPSB0aGlzLm5vZGVzKCk7XG4gICAgdmFyIG51bU5vZGVzID0gbm9kZXMubGVuZ3RoO1xuICAgIGlmICghb3B0aW9ucy5kaXJlY3RlZCkge1xuICAgICAgdmFyIGRlZ3JlZXMgPSB7fTtcbiAgICAgIHZhciBtYXhEZWdyZWUgPSAwO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1Ob2RlczsgaSsrKSB7XG4gICAgICAgIHZhciBub2RlID0gbm9kZXNbaV07XG5cbiAgICAgICAgLy8gYWRkIGN1cnJlbnQgbm9kZSB0byB0aGUgY3VycmVudCBvcHRpb25zIG9iamVjdCBhbmQgY2FsbCBkZWdyZWVDZW50cmFsaXR5XG4gICAgICAgIG9wdGlvbnMucm9vdCA9IG5vZGU7XG4gICAgICAgIHZhciBjdXJyRGVncmVlID0gdGhpcy5kZWdyZWVDZW50cmFsaXR5KG9wdGlvbnMpO1xuICAgICAgICBpZiAobWF4RGVncmVlIDwgY3VyckRlZ3JlZS5kZWdyZWUpIHtcbiAgICAgICAgICBtYXhEZWdyZWUgPSBjdXJyRGVncmVlLmRlZ3JlZTtcbiAgICAgICAgfVxuICAgICAgICBkZWdyZWVzW25vZGUuaWQoKV0gPSBjdXJyRGVncmVlLmRlZ3JlZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRlZ3JlZTogZnVuY3Rpb24gZGVncmVlKG5vZGUpIHtcbiAgICAgICAgICBpZiAobWF4RGVncmVlID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHN0cmluZyhub2RlKSkge1xuICAgICAgICAgICAgLy8gZnJvbSBpcyBhIHNlbGVjdG9yIHN0cmluZ1xuICAgICAgICAgICAgbm9kZSA9IGN5LmZpbHRlcihub2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGRlZ3JlZXNbbm9kZS5pZCgpXSAvIG1heERlZ3JlZTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGluZGVncmVlcyA9IHt9O1xuICAgICAgdmFyIG91dGRlZ3JlZXMgPSB7fTtcbiAgICAgIHZhciBtYXhJbmRlZ3JlZSA9IDA7XG4gICAgICB2YXIgbWF4T3V0ZGVncmVlID0gMDtcbiAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBudW1Ob2RlczsgX2krKykge1xuICAgICAgICB2YXIgX25vZGUgPSBub2Rlc1tfaV07XG4gICAgICAgIHZhciBpZCA9IF9ub2RlLmlkKCk7XG5cbiAgICAgICAgLy8gYWRkIGN1cnJlbnQgbm9kZSB0byB0aGUgY3VycmVudCBvcHRpb25zIG9iamVjdCBhbmQgY2FsbCBkZWdyZWVDZW50cmFsaXR5XG4gICAgICAgIG9wdGlvbnMucm9vdCA9IF9ub2RlO1xuICAgICAgICB2YXIgX2N1cnJEZWdyZWUgPSB0aGlzLmRlZ3JlZUNlbnRyYWxpdHkob3B0aW9ucyk7XG4gICAgICAgIGlmIChtYXhJbmRlZ3JlZSA8IF9jdXJyRGVncmVlLmluZGVncmVlKSBtYXhJbmRlZ3JlZSA9IF9jdXJyRGVncmVlLmluZGVncmVlO1xuICAgICAgICBpZiAobWF4T3V0ZGVncmVlIDwgX2N1cnJEZWdyZWUub3V0ZGVncmVlKSBtYXhPdXRkZWdyZWUgPSBfY3VyckRlZ3JlZS5vdXRkZWdyZWU7XG4gICAgICAgIGluZGVncmVlc1tpZF0gPSBfY3VyckRlZ3JlZS5pbmRlZ3JlZTtcbiAgICAgICAgb3V0ZGVncmVlc1tpZF0gPSBfY3VyckRlZ3JlZS5vdXRkZWdyZWU7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpbmRlZ3JlZTogZnVuY3Rpb24gaW5kZWdyZWUobm9kZSkge1xuICAgICAgICAgIGlmIChtYXhJbmRlZ3JlZSA9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHN0cmluZyhub2RlKSkge1xuICAgICAgICAgICAgLy8gZnJvbSBpcyBhIHNlbGVjdG9yIHN0cmluZ1xuICAgICAgICAgICAgbm9kZSA9IGN5LmZpbHRlcihub2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGluZGVncmVlc1tub2RlLmlkKCldIC8gbWF4SW5kZWdyZWU7XG4gICAgICAgIH0sXG4gICAgICAgIG91dGRlZ3JlZTogZnVuY3Rpb24gb3V0ZGVncmVlKG5vZGUpIHtcbiAgICAgICAgICBpZiAobWF4T3V0ZGVncmVlID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHN0cmluZyhub2RlKSkge1xuICAgICAgICAgICAgLy8gZnJvbSBpcyBhIHNlbGVjdG9yIHN0cmluZ1xuICAgICAgICAgICAgbm9kZSA9IGN5LmZpbHRlcihub2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG91dGRlZ3JlZXNbbm9kZS5pZCgpXSAvIG1heE91dGRlZ3JlZTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gIH0sXG4gIC8vIGRlZ3JlZUNlbnRyYWxpdHlOb3JtYWxpemVkXG5cbiAgLy8gSW1wbGVtZW50ZWQgZnJvbSB0aGUgYWxnb3JpdGhtIGluIE9wc2FobCdzIHBhcGVyXG4gIC8vIFwiTm9kZSBjZW50cmFsaXR5IGluIHdlaWdodGVkIG5ldHdvcmtzOiBHZW5lcmFsaXppbmcgZGVncmVlIGFuZCBzaG9ydGVzdCBwYXRoc1wiXG4gIC8vIGNoZWNrIHRoZSBoZWFkaW5nIDIgXCJEZWdyZWVcIlxuICBkZWdyZWVDZW50cmFsaXR5OiBmdW5jdGlvbiBkZWdyZWVDZW50cmFsaXR5KG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gZGVmYXVsdHMkZihvcHRpb25zKTtcbiAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG4gICAgdmFyIGNhbGxpbmdFbGVzID0gdGhpcztcbiAgICB2YXIgX29wdGlvbnMgPSBvcHRpb25zLFxuICAgICAgcm9vdCA9IF9vcHRpb25zLnJvb3QsXG4gICAgICB3ZWlnaHQgPSBfb3B0aW9ucy53ZWlnaHQsXG4gICAgICBkaXJlY3RlZCA9IF9vcHRpb25zLmRpcmVjdGVkLFxuICAgICAgYWxwaGEgPSBfb3B0aW9ucy5hbHBoYTtcbiAgICByb290ID0gY3kuY29sbGVjdGlvbihyb290KVswXTtcbiAgICBpZiAoIWRpcmVjdGVkKSB7XG4gICAgICB2YXIgY29ubkVkZ2VzID0gcm9vdC5jb25uZWN0ZWRFZGdlcygpLmludGVyc2VjdGlvbihjYWxsaW5nRWxlcyk7XG4gICAgICB2YXIgayA9IGNvbm5FZGdlcy5sZW5ndGg7XG4gICAgICB2YXIgcyA9IDA7XG5cbiAgICAgIC8vIE5vdywgc3VtIGVkZ2Ugd2VpZ2h0c1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb25uRWRnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcyArPSB3ZWlnaHQoY29ubkVkZ2VzW2ldKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRlZ3JlZTogTWF0aC5wb3coaywgMSAtIGFscGhhKSAqIE1hdGgucG93KHMsIGFscGhhKVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGVkZ2VzID0gcm9vdC5jb25uZWN0ZWRFZGdlcygpO1xuICAgICAgdmFyIGluY29taW5nID0gZWRnZXMuZmlsdGVyKGZ1bmN0aW9uIChlZGdlKSB7XG4gICAgICAgIHJldHVybiBlZGdlLnRhcmdldCgpLnNhbWUocm9vdCkgJiYgY2FsbGluZ0VsZXMuaGFzKGVkZ2UpO1xuICAgICAgfSk7XG4gICAgICB2YXIgb3V0Z29pbmcgPSBlZGdlcy5maWx0ZXIoZnVuY3Rpb24gKGVkZ2UpIHtcbiAgICAgICAgcmV0dXJuIGVkZ2Uuc291cmNlKCkuc2FtZShyb290KSAmJiBjYWxsaW5nRWxlcy5oYXMoZWRnZSk7XG4gICAgICB9KTtcbiAgICAgIHZhciBrX2luID0gaW5jb21pbmcubGVuZ3RoO1xuICAgICAgdmFyIGtfb3V0ID0gb3V0Z29pbmcubGVuZ3RoO1xuICAgICAgdmFyIHNfaW4gPSAwO1xuICAgICAgdmFyIHNfb3V0ID0gMDtcblxuICAgICAgLy8gTm93LCBzdW0gaW5jb21pbmcgZWRnZSB3ZWlnaHRzXG4gICAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBpbmNvbWluZy5sZW5ndGg7IF9pMisrKSB7XG4gICAgICAgIHNfaW4gKz0gd2VpZ2h0KGluY29taW5nW19pMl0pO1xuICAgICAgfVxuXG4gICAgICAvLyBOb3csIHN1bSBvdXRnb2luZyBlZGdlIHdlaWdodHNcbiAgICAgIGZvciAodmFyIF9pMyA9IDA7IF9pMyA8IG91dGdvaW5nLmxlbmd0aDsgX2kzKyspIHtcbiAgICAgICAgc19vdXQgKz0gd2VpZ2h0KG91dGdvaW5nW19pM10pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaW5kZWdyZWU6IE1hdGgucG93KGtfaW4sIDEgLSBhbHBoYSkgKiBNYXRoLnBvdyhzX2luLCBhbHBoYSksXG4gICAgICAgIG91dGRlZ3JlZTogTWF0aC5wb3coa19vdXQsIDEgLSBhbHBoYSkgKiBNYXRoLnBvdyhzX291dCwgYWxwaGEpXG4gICAgICB9O1xuICAgIH1cbiAgfSAvLyBkZWdyZWVDZW50cmFsaXR5XG59OyAvLyBlbGVzZm5cblxuLy8gbmljZSwgc2hvcnQgbWF0aGVtYXRpY2FsIGFsaWFzXG5lbGVzZm4kbi5kYyA9IGVsZXNmbiRuLmRlZ3JlZUNlbnRyYWxpdHk7XG5lbGVzZm4kbi5kY24gPSBlbGVzZm4kbi5kZWdyZWVDZW50cmFsaXR5Tm9ybWFsaXNlZCA9IGVsZXNmbiRuLmRlZ3JlZUNlbnRyYWxpdHlOb3JtYWxpemVkO1xuXG52YXIgZGVmYXVsdHMkZSA9IGRlZmF1bHRzJGcoe1xuICBoYXJtb25pYzogdHJ1ZSxcbiAgd2VpZ2h0OiBmdW5jdGlvbiB3ZWlnaHQoKSB7XG4gICAgcmV0dXJuIDE7XG4gIH0sXG4gIGRpcmVjdGVkOiBmYWxzZSxcbiAgcm9vdDogbnVsbFxufSk7XG52YXIgZWxlc2ZuJG0gPSB7XG4gIGNsb3NlbmVzc0NlbnRyYWxpdHlOb3JtYWxpemVkOiBmdW5jdGlvbiBjbG9zZW5lc3NDZW50cmFsaXR5Tm9ybWFsaXplZChvcHRpb25zKSB7XG4gICAgdmFyIF9kZWZhdWx0cyA9IGRlZmF1bHRzJGUob3B0aW9ucyksXG4gICAgICBoYXJtb25pYyA9IF9kZWZhdWx0cy5oYXJtb25pYyxcbiAgICAgIHdlaWdodCA9IF9kZWZhdWx0cy53ZWlnaHQsXG4gICAgICBkaXJlY3RlZCA9IF9kZWZhdWx0cy5kaXJlY3RlZDtcbiAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG4gICAgdmFyIGNsb3NlbmVzc2VzID0ge307XG4gICAgdmFyIG1heENsb3NlbmVzcyA9IDA7XG4gICAgdmFyIG5vZGVzID0gdGhpcy5ub2RlcygpO1xuICAgIHZhciBmdyA9IHRoaXMuZmxveWRXYXJzaGFsbCh7XG4gICAgICB3ZWlnaHQ6IHdlaWdodCxcbiAgICAgIGRpcmVjdGVkOiBkaXJlY3RlZFxuICAgIH0pO1xuXG4gICAgLy8gQ29tcHV0ZSBjbG9zZW5lc3MgZm9yIGV2ZXJ5IG5vZGUgYW5kIGZpbmQgdGhlIG1heGltdW0gY2xvc2VuZXNzXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGN1cnJDbG9zZW5lc3MgPSAwO1xuICAgICAgdmFyIG5vZGVfaSA9IG5vZGVzW2ldO1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBub2Rlcy5sZW5ndGg7IGorKykge1xuICAgICAgICBpZiAoaSAhPT0gaikge1xuICAgICAgICAgIHZhciBkID0gZncuZGlzdGFuY2Uobm9kZV9pLCBub2Rlc1tqXSk7XG4gICAgICAgICAgaWYgKGhhcm1vbmljKSB7XG4gICAgICAgICAgICBjdXJyQ2xvc2VuZXNzICs9IDEgLyBkO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjdXJyQ2xvc2VuZXNzICs9IGQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIWhhcm1vbmljKSB7XG4gICAgICAgIGN1cnJDbG9zZW5lc3MgPSAxIC8gY3VyckNsb3NlbmVzcztcbiAgICAgIH1cbiAgICAgIGlmIChtYXhDbG9zZW5lc3MgPCBjdXJyQ2xvc2VuZXNzKSB7XG4gICAgICAgIG1heENsb3NlbmVzcyA9IGN1cnJDbG9zZW5lc3M7XG4gICAgICB9XG4gICAgICBjbG9zZW5lc3Nlc1tub2RlX2kuaWQoKV0gPSBjdXJyQ2xvc2VuZXNzO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgY2xvc2VuZXNzOiBmdW5jdGlvbiBjbG9zZW5lc3Mobm9kZSkge1xuICAgICAgICBpZiAobWF4Q2xvc2VuZXNzID09IDApIHtcbiAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RyaW5nKG5vZGUpKSB7XG4gICAgICAgICAgLy8gZnJvbSBpcyBhIHNlbGVjdG9yIHN0cmluZ1xuICAgICAgICAgIG5vZGUgPSBjeS5maWx0ZXIobm9kZSlbMF0uaWQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBmcm9tIGlzIGEgbm9kZVxuICAgICAgICAgIG5vZGUgPSBub2RlLmlkKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNsb3NlbmVzc2VzW25vZGVdIC8gbWF4Q2xvc2VuZXNzO1xuICAgICAgfVxuICAgIH07XG4gIH0sXG4gIC8vIEltcGxlbWVudGVkIGZyb20gcHNldWRvY29kZSBmcm9tIHdpa2lwZWRpYVxuICBjbG9zZW5lc3NDZW50cmFsaXR5OiBmdW5jdGlvbiBjbG9zZW5lc3NDZW50cmFsaXR5KG9wdGlvbnMpIHtcbiAgICB2YXIgX2RlZmF1bHRzMiA9IGRlZmF1bHRzJGUob3B0aW9ucyksXG4gICAgICByb290ID0gX2RlZmF1bHRzMi5yb290LFxuICAgICAgd2VpZ2h0ID0gX2RlZmF1bHRzMi53ZWlnaHQsXG4gICAgICBkaXJlY3RlZCA9IF9kZWZhdWx0czIuZGlyZWN0ZWQsXG4gICAgICBoYXJtb25pYyA9IF9kZWZhdWx0czIuaGFybW9uaWM7XG4gICAgcm9vdCA9IHRoaXMuZmlsdGVyKHJvb3QpWzBdO1xuXG4gICAgLy8gd2UgbmVlZCBkaXN0YW5jZSBmcm9tIHRoaXMgbm9kZSB0byBldmVyeSBvdGhlciBub2RlXG4gICAgdmFyIGRpamtzdHJhID0gdGhpcy5kaWprc3RyYSh7XG4gICAgICByb290OiByb290LFxuICAgICAgd2VpZ2h0OiB3ZWlnaHQsXG4gICAgICBkaXJlY3RlZDogZGlyZWN0ZWRcbiAgICB9KTtcbiAgICB2YXIgdG90YWxEaXN0YW5jZSA9IDA7XG4gICAgdmFyIG5vZGVzID0gdGhpcy5ub2RlcygpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBuID0gbm9kZXNbaV07XG4gICAgICBpZiAoIW4uc2FtZShyb290KSkge1xuICAgICAgICB2YXIgZCA9IGRpamtzdHJhLmRpc3RhbmNlVG8obik7XG4gICAgICAgIGlmIChoYXJtb25pYykge1xuICAgICAgICAgIHRvdGFsRGlzdGFuY2UgKz0gMSAvIGQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdG90YWxEaXN0YW5jZSArPSBkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBoYXJtb25pYyA/IHRvdGFsRGlzdGFuY2UgOiAxIC8gdG90YWxEaXN0YW5jZTtcbiAgfSAvLyBjbG9zZW5lc3NDZW50cmFsaXR5XG59OyAvLyBlbGVzZm5cblxuLy8gbmljZSwgc2hvcnQgbWF0aGVtYXRpY2FsIGFsaWFzXG5lbGVzZm4kbS5jYyA9IGVsZXNmbiRtLmNsb3NlbmVzc0NlbnRyYWxpdHk7XG5lbGVzZm4kbS5jY24gPSBlbGVzZm4kbS5jbG9zZW5lc3NDZW50cmFsaXR5Tm9ybWFsaXNlZCA9IGVsZXNmbiRtLmNsb3NlbmVzc0NlbnRyYWxpdHlOb3JtYWxpemVkO1xuXG52YXIgZGVmYXVsdHMkZCA9IGRlZmF1bHRzJGcoe1xuICB3ZWlnaHQ6IG51bGwsXG4gIGRpcmVjdGVkOiBmYWxzZVxufSk7XG52YXIgZWxlc2ZuJGwgPSB7XG4gIC8vIEltcGxlbWVudGVkIGZyb20gdGhlIGFsZ29yaXRobSBpbiB0aGUgcGFwZXIgXCJPbiBWYXJpYW50cyBvZiBTaG9ydGVzdC1QYXRoIEJldHdlZW5uZXNzIENlbnRyYWxpdHkgYW5kIHRoZWlyIEdlbmVyaWMgQ29tcHV0YXRpb25cIiBieSBVbHJpayBCcmFuZGVzXG4gIGJldHdlZW5uZXNzQ2VudHJhbGl0eTogZnVuY3Rpb24gYmV0d2Vlbm5lc3NDZW50cmFsaXR5KG9wdGlvbnMpIHtcbiAgICB2YXIgX2RlZmF1bHRzID0gZGVmYXVsdHMkZChvcHRpb25zKSxcbiAgICAgIGRpcmVjdGVkID0gX2RlZmF1bHRzLmRpcmVjdGVkLFxuICAgICAgd2VpZ2h0ID0gX2RlZmF1bHRzLndlaWdodDtcbiAgICB2YXIgd2VpZ2h0ZWQgPSB3ZWlnaHQgIT0gbnVsbDtcbiAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG5cbiAgICAvLyBzdGFydGluZ1xuICAgIHZhciBWID0gdGhpcy5ub2RlcygpO1xuICAgIHZhciBBID0ge307XG4gICAgdmFyIF9DID0ge307XG4gICAgdmFyIG1heCA9IDA7XG4gICAgdmFyIEMgPSB7XG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldChrZXksIHZhbCkge1xuICAgICAgICBfQ1trZXldID0gdmFsO1xuICAgICAgICBpZiAodmFsID4gbWF4KSB7XG4gICAgICAgICAgbWF4ID0gdmFsO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoa2V5KSB7XG4gICAgICAgIHJldHVybiBfQ1trZXldO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBBIGNvbnRhaW5zIHRoZSBuZWlnaGJvcmhvb2RzIG9mIGV2ZXJ5IG5vZGVcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IFYubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB2ID0gVltpXTtcbiAgICAgIHZhciB2aWQgPSB2LmlkKCk7XG4gICAgICBpZiAoZGlyZWN0ZWQpIHtcbiAgICAgICAgQVt2aWRdID0gdi5vdXRnb2VycygpLm5vZGVzKCk7IC8vIGdldCBvdXRnb2VycyBvZiBldmVyeSBub2RlXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBBW3ZpZF0gPSB2Lm9wZW5OZWlnaGJvcmhvb2QoKS5ub2RlcygpOyAvLyBnZXQgbmVpZ2hib3JzIG9mIGV2ZXJ5IG5vZGVcbiAgICAgIH1cblxuICAgICAgQy5zZXQodmlkLCAwKTtcbiAgICB9XG4gICAgdmFyIF9sb29wID0gZnVuY3Rpb24gX2xvb3Aocykge1xuICAgICAgdmFyIHNpZCA9IFZbc10uaWQoKTtcbiAgICAgIHZhciBTID0gW107IC8vIHN0YWNrXG4gICAgICB2YXIgUCA9IHt9O1xuICAgICAgdmFyIGcgPSB7fTtcbiAgICAgIHZhciBkID0ge307XG4gICAgICB2YXIgUSA9IG5ldyBoZWFwKGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiBkW2FdIC0gZFtiXTtcbiAgICAgIH0pOyAvLyBxdWV1ZVxuXG4gICAgICAvLyBpbml0IGRpY3Rpb25hcmllc1xuICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IFYubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciBfdmlkID0gVltfaV0uaWQoKTtcbiAgICAgICAgUFtfdmlkXSA9IFtdO1xuICAgICAgICBnW192aWRdID0gMDtcbiAgICAgICAgZFtfdmlkXSA9IEluZmluaXR5O1xuICAgICAgfVxuICAgICAgZ1tzaWRdID0gMTsgLy8gc2lnbWFcbiAgICAgIGRbc2lkXSA9IDA7IC8vIGRpc3RhbmNlIHRvIHNcblxuICAgICAgUS5wdXNoKHNpZCk7XG4gICAgICB3aGlsZSAoIVEuZW1wdHkoKSkge1xuICAgICAgICB2YXIgX3YgPSBRLnBvcCgpO1xuICAgICAgICBTLnB1c2goX3YpO1xuICAgICAgICBpZiAod2VpZ2h0ZWQpIHtcbiAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IEFbX3ZdLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICB2YXIgdyA9IEFbX3ZdW2pdO1xuICAgICAgICAgICAgdmFyIHZFbGUgPSBjeS5nZXRFbGVtZW50QnlJZChfdik7XG4gICAgICAgICAgICB2YXIgZWRnZSA9IHZvaWQgMDtcbiAgICAgICAgICAgIGlmICh2RWxlLmVkZ2VzVG8odykubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICBlZGdlID0gdkVsZS5lZGdlc1RvKHcpWzBdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZWRnZSA9IHcuZWRnZXNUbyh2RWxlKVswXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBlZGdlV2VpZ2h0ID0gd2VpZ2h0KGVkZ2UpO1xuICAgICAgICAgICAgdyA9IHcuaWQoKTtcbiAgICAgICAgICAgIGlmIChkW3ddID4gZFtfdl0gKyBlZGdlV2VpZ2h0KSB7XG4gICAgICAgICAgICAgIGRbd10gPSBkW192XSArIGVkZ2VXZWlnaHQ7XG4gICAgICAgICAgICAgIGlmIChRLm5vZGVzLmluZGV4T2YodykgPCAwKSB7XG4gICAgICAgICAgICAgICAgLy9pZiB3IGlzIG5vdCBpbiBRXG4gICAgICAgICAgICAgICAgUS5wdXNoKHcpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHVwZGF0ZSBwb3NpdGlvbiBpZiB3IGlzIGluIFFcbiAgICAgICAgICAgICAgICBRLnVwZGF0ZUl0ZW0odyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZ1t3XSA9IDA7XG4gICAgICAgICAgICAgIFBbd10gPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkW3ddID09IGRbX3ZdICsgZWRnZVdlaWdodCkge1xuICAgICAgICAgICAgICBnW3ddID0gZ1t3XSArIGdbX3ZdO1xuICAgICAgICAgICAgICBQW3ddLnB1c2goX3YpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmb3IgKHZhciBfaiA9IDA7IF9qIDwgQVtfdl0ubGVuZ3RoOyBfaisrKSB7XG4gICAgICAgICAgICB2YXIgX3cgPSBBW192XVtfal0uaWQoKTtcbiAgICAgICAgICAgIGlmIChkW193XSA9PSBJbmZpbml0eSkge1xuICAgICAgICAgICAgICBRLnB1c2goX3cpO1xuICAgICAgICAgICAgICBkW193XSA9IGRbX3ZdICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkW193XSA9PSBkW192XSArIDEpIHtcbiAgICAgICAgICAgICAgZ1tfd10gPSBnW193XSArIGdbX3ZdO1xuICAgICAgICAgICAgICBQW193XS5wdXNoKF92KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBlID0ge307XG4gICAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBWLmxlbmd0aDsgX2kyKyspIHtcbiAgICAgICAgZVtWW19pMl0uaWQoKV0gPSAwO1xuICAgICAgfVxuICAgICAgd2hpbGUgKFMubGVuZ3RoID4gMCkge1xuICAgICAgICB2YXIgX3cyID0gUy5wb3AoKTtcbiAgICAgICAgZm9yICh2YXIgX2oyID0gMDsgX2oyIDwgUFtfdzJdLmxlbmd0aDsgX2oyKyspIHtcbiAgICAgICAgICB2YXIgX3YyID0gUFtfdzJdW19qMl07XG4gICAgICAgICAgZVtfdjJdID0gZVtfdjJdICsgZ1tfdjJdIC8gZ1tfdzJdICogKDEgKyBlW193Ml0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChfdzIgIT0gVltzXS5pZCgpKSB7XG4gICAgICAgICAgQy5zZXQoX3cyLCBDLmdldChfdzIpICsgZVtfdzJdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgZm9yICh2YXIgcyA9IDA7IHMgPCBWLmxlbmd0aDsgcysrKSB7XG4gICAgICBfbG9vcChzKTtcbiAgICB9XG4gICAgdmFyIHJldCA9IHtcbiAgICAgIGJldHdlZW5uZXNzOiBmdW5jdGlvbiBiZXR3ZWVubmVzcyhub2RlKSB7XG4gICAgICAgIHZhciBpZCA9IGN5LmNvbGxlY3Rpb24obm9kZSkuaWQoKTtcbiAgICAgICAgcmV0dXJuIEMuZ2V0KGlkKTtcbiAgICAgIH0sXG4gICAgICBiZXR3ZWVubmVzc05vcm1hbGl6ZWQ6IGZ1bmN0aW9uIGJldHdlZW5uZXNzTm9ybWFsaXplZChub2RlKSB7XG4gICAgICAgIGlmIChtYXggPT0gMCkge1xuICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpZCA9IGN5LmNvbGxlY3Rpb24obm9kZSkuaWQoKTtcbiAgICAgICAgcmV0dXJuIEMuZ2V0KGlkKSAvIG1heDtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gYWxpYXNcbiAgICByZXQuYmV0d2Vlbm5lc3NOb3JtYWxpc2VkID0gcmV0LmJldHdlZW5uZXNzTm9ybWFsaXplZDtcbiAgICByZXR1cm4gcmV0O1xuICB9IC8vIGJldHdlZW5uZXNzQ2VudHJhbGl0eVxufTsgLy8gZWxlc2ZuXG5cbi8vIG5pY2UsIHNob3J0IG1hdGhlbWF0aWNhbCBhbGlhc1xuZWxlc2ZuJGwuYmMgPSBlbGVzZm4kbC5iZXR3ZWVubmVzc0NlbnRyYWxpdHk7XG5cbi8vIEltcGxlbWVudGVkIGJ5IFpvZSBYaSBAem9leGkgZm9yIEdTT0MgMjAxNlxuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xudmFyIGRlZmF1bHRzJGMgPSBkZWZhdWx0cyRnKHtcbiAgZXhwYW5kRmFjdG9yOiAyLFxuICAvLyBhZmZlY3RzIHRpbWUgb2YgY29tcHV0YXRpb24gYW5kIGNsdXN0ZXIgZ3JhbnVsYXJpdHkgdG8gc29tZSBleHRlbnQ6IE0gKiBNXG4gIGluZmxhdGVGYWN0b3I6IDIsXG4gIC8vIGFmZmVjdHMgY2x1c3RlciBncmFudWxhcml0eSAodGhlIGdyZWF0ZXIgdGhlIHZhbHVlLCB0aGUgbW9yZSBjbHVzdGVycyk6IE0oaSxqKSAvIEUoailcbiAgbXVsdEZhY3RvcjogMSxcbiAgLy8gb3B0aW9uYWwgc2VsZiBsb29wcyBmb3IgZWFjaCBub2RlLiBVc2UgYSBuZXV0cmFsIHZhbHVlIHRvIGltcHJvdmUgY2x1c3RlciBjb21wdXRhdGlvbnMuXG4gIG1heEl0ZXJhdGlvbnM6IDIwLFxuICAvLyBtYXhpbXVtIG51bWJlciBvZiBpdGVyYXRpb25zIG9mIHRoZSBNQ0wgYWxnb3JpdGhtIGluIGEgc2luZ2xlIHJ1blxuICBhdHRyaWJ1dGVzOiBbXG4gIC8vIGF0dHJpYnV0ZXMvZmVhdHVyZXMgdXNlZCB0byBncm91cCBub2RlcywgaWUuIHNpbWlsYXJpdHkgdmFsdWVzIGJldHdlZW4gbm9kZXNcbiAgZnVuY3Rpb24gKGVkZ2UpIHtcbiAgICByZXR1cm4gMTtcbiAgfV1cbn0pO1xuLyogZXNsaW50LWVuYWJsZSAqL1xuXG52YXIgc2V0T3B0aW9ucyQzID0gZnVuY3Rpb24gc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gIHJldHVybiBkZWZhdWx0cyRjKG9wdGlvbnMpO1xufTtcbi8qIGVzbGludC1lbmFibGUgKi9cblxudmFyIGdldFNpbWlsYXJpdHkkMSA9IGZ1bmN0aW9uIGdldFNpbWlsYXJpdHkoZWRnZSwgYXR0cmlidXRlcykge1xuICB2YXIgdG90YWwgPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGF0dHJpYnV0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICB0b3RhbCArPSBhdHRyaWJ1dGVzW2ldKGVkZ2UpO1xuICB9XG4gIHJldHVybiB0b3RhbDtcbn07XG52YXIgYWRkTG9vcHMgPSBmdW5jdGlvbiBhZGRMb29wcyhNLCBuLCB2YWwpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICBNW2kgKiBuICsgaV0gPSB2YWw7XG4gIH1cbn07XG52YXIgbm9ybWFsaXplID0gZnVuY3Rpb24gbm9ybWFsaXplKE0sIG4pIHtcbiAgdmFyIHN1bTtcbiAgZm9yICh2YXIgY29sID0gMDsgY29sIDwgbjsgY29sKyspIHtcbiAgICBzdW0gPSAwO1xuICAgIGZvciAodmFyIHJvdyA9IDA7IHJvdyA8IG47IHJvdysrKSB7XG4gICAgICBzdW0gKz0gTVtyb3cgKiBuICsgY29sXTtcbiAgICB9XG4gICAgZm9yICh2YXIgX3JvdyA9IDA7IF9yb3cgPCBuOyBfcm93KyspIHtcbiAgICAgIE1bX3JvdyAqIG4gKyBjb2xdID0gTVtfcm93ICogbiArIGNvbF0gLyBzdW07XG4gICAgfVxuICB9XG59O1xuXG4vLyBUT0RPOiBibG9ja2VkIG1hdHJpeCBtdWx0aXBsaWNhdGlvbj9cbnZhciBtbXVsdCA9IGZ1bmN0aW9uIG1tdWx0KEEsIEIsIG4pIHtcbiAgdmFyIEMgPSBuZXcgQXJyYXkobiAqIG4pO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgbjsgaisrKSB7XG4gICAgICBDW2kgKiBuICsgal0gPSAwO1xuICAgIH1cbiAgICBmb3IgKHZhciBrID0gMDsgayA8IG47IGsrKykge1xuICAgICAgZm9yICh2YXIgX2ogPSAwOyBfaiA8IG47IF9qKyspIHtcbiAgICAgICAgQ1tpICogbiArIF9qXSArPSBBW2kgKiBuICsga10gKiBCW2sgKiBuICsgX2pdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gQztcbn07XG52YXIgZXhwYW5kID0gZnVuY3Rpb24gZXhwYW5kKE0sIG4sIGV4cGFuZEZhY3RvciAvKiogcG93ZXIgKiovKSB7XG4gIHZhciBfTSA9IE0uc2xpY2UoMCk7XG4gIGZvciAodmFyIHAgPSAxOyBwIDwgZXhwYW5kRmFjdG9yOyBwKyspIHtcbiAgICBNID0gbW11bHQoTSwgX00sIG4pO1xuICB9XG4gIHJldHVybiBNO1xufTtcbnZhciBpbmZsYXRlID0gZnVuY3Rpb24gaW5mbGF0ZShNLCBuLCBpbmZsYXRlRmFjdG9yIC8qKiByICoqLykge1xuICB2YXIgX00gPSBuZXcgQXJyYXkobiAqIG4pO1xuXG4gIC8vIE0oaSxqKSBeIGluZmxhdGVQb3dlclxuICBmb3IgKHZhciBpID0gMDsgaSA8IG4gKiBuOyBpKyspIHtcbiAgICBfTVtpXSA9IE1hdGgucG93KE1baV0sIGluZmxhdGVGYWN0b3IpO1xuICB9XG4gIG5vcm1hbGl6ZShfTSwgbik7XG4gIHJldHVybiBfTTtcbn07XG52YXIgaGFzQ29udmVyZ2VkID0gZnVuY3Rpb24gaGFzQ29udmVyZ2VkKE0sIF9NLCBuMiwgcm91bmRGYWN0b3IpIHtcbiAgLy8gQ2hlY2sgdGhhdCBib3RoIG1hdHJpY2VzIGhhdmUgdGhlIHNhbWUgZWxlbWVudHMgKGksailcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuMjsgaSsrKSB7XG4gICAgdmFyIHYxID0gTWF0aC5yb3VuZChNW2ldICogTWF0aC5wb3coMTAsIHJvdW5kRmFjdG9yKSkgLyBNYXRoLnBvdygxMCwgcm91bmRGYWN0b3IpOyAvLyB0cnVuY2F0ZSB0byAncm91bmRGYWN0b3InIGRlY2ltYWwgcGxhY2VzXG4gICAgdmFyIHYyID0gTWF0aC5yb3VuZChfTVtpXSAqIE1hdGgucG93KDEwLCByb3VuZEZhY3RvcikpIC8gTWF0aC5wb3coMTAsIHJvdW5kRmFjdG9yKTtcbiAgICBpZiAodjEgIT09IHYyKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufTtcbnZhciBhc3NpZ24kMiA9IGZ1bmN0aW9uIGFzc2lnbihNLCBuLCBub2RlcywgY3kpIHtcbiAgdmFyIGNsdXN0ZXJzID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgdmFyIGNsdXN0ZXIgPSBbXTtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IG47IGorKykge1xuICAgICAgLy8gUm93LXdpc2UgYXR0cmFjdG9ycyBhbmQgZWxlbWVudHMgdGhhdCB0aGV5IGF0dHJhY3QgYmVsb25nIGluIHNhbWUgY2x1c3RlclxuICAgICAgaWYgKE1hdGgucm91bmQoTVtpICogbiArIGpdICogMTAwMCkgLyAxMDAwID4gMCkge1xuICAgICAgICBjbHVzdGVyLnB1c2gobm9kZXNbal0pO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoY2x1c3Rlci5sZW5ndGggIT09IDApIHtcbiAgICAgIGNsdXN0ZXJzLnB1c2goY3kuY29sbGVjdGlvbihjbHVzdGVyKSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBjbHVzdGVycztcbn07XG52YXIgaXNEdXBsaWNhdGUgPSBmdW5jdGlvbiBpc0R1cGxpY2F0ZShjMSwgYzIpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjMS5sZW5ndGg7IGkrKykge1xuICAgIGlmICghYzJbaV0gfHwgYzFbaV0uaWQoKSAhPT0gYzJbaV0uaWQoKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn07XG52YXIgcmVtb3ZlRHVwbGljYXRlcyA9IGZ1bmN0aW9uIHJlbW92ZUR1cGxpY2F0ZXMoY2x1c3RlcnMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbHVzdGVycy5sZW5ndGg7IGkrKykge1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgY2x1c3RlcnMubGVuZ3RoOyBqKyspIHtcbiAgICAgIGlmIChpICE9IGogJiYgaXNEdXBsaWNhdGUoY2x1c3RlcnNbaV0sIGNsdXN0ZXJzW2pdKSkge1xuICAgICAgICBjbHVzdGVycy5zcGxpY2UoaiwgMSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBjbHVzdGVycztcbn07XG52YXIgbWFya292Q2x1c3RlcmluZyA9IGZ1bmN0aW9uIG1hcmtvdkNsdXN0ZXJpbmcob3B0aW9ucykge1xuICB2YXIgbm9kZXMgPSB0aGlzLm5vZGVzKCk7XG4gIHZhciBlZGdlcyA9IHRoaXMuZWRnZXMoKTtcbiAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuXG4gIC8vIFNldCBwYXJhbWV0ZXJzIG9mIGFsZ29yaXRobTpcbiAgdmFyIG9wdHMgPSBzZXRPcHRpb25zJDMob3B0aW9ucyk7XG5cbiAgLy8gTWFwIGVhY2ggbm9kZSB0byBpdHMgcG9zaXRpb24gaW4gbm9kZSBhcnJheVxuICB2YXIgaWQycG9zaXRpb24gPSB7fTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIGlkMnBvc2l0aW9uW25vZGVzW2ldLmlkKCldID0gaTtcbiAgfVxuXG4gIC8vIEdlbmVyYXRlIHN0b2NoYXN0aWMgbWF0cml4IE0gZnJvbSBpbnB1dCBncmFwaCBHIChzaG91bGQgYmUgc3ltbWV0cmljL3VuZGlyZWN0ZWQpXG4gIHZhciBuID0gbm9kZXMubGVuZ3RoLFxuICAgIG4yID0gbiAqIG47XG4gIHZhciBNID0gbmV3IEFycmF5KG4yKSxcbiAgICBfTTtcbiAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IG4yOyBfaSsrKSB7XG4gICAgTVtfaV0gPSAwO1xuICB9XG4gIGZvciAodmFyIGUgPSAwOyBlIDwgZWRnZXMubGVuZ3RoOyBlKyspIHtcbiAgICB2YXIgZWRnZSA9IGVkZ2VzW2VdO1xuICAgIHZhciBfaTIgPSBpZDJwb3NpdGlvbltlZGdlLnNvdXJjZSgpLmlkKCldO1xuICAgIHZhciBqID0gaWQycG9zaXRpb25bZWRnZS50YXJnZXQoKS5pZCgpXTtcbiAgICB2YXIgc2ltID0gZ2V0U2ltaWxhcml0eSQxKGVkZ2UsIG9wdHMuYXR0cmlidXRlcyk7XG4gICAgTVtfaTIgKiBuICsgal0gKz0gc2ltOyAvLyBHIHNob3VsZCBiZSBzeW1tZXRyaWMgYW5kIHVuZGlyZWN0ZWRcbiAgICBNW2ogKiBuICsgX2kyXSArPSBzaW07XG4gIH1cblxuICAvLyBCZWdpbiBNYXJrb3YgY2x1c3RlciBhbGdvcml0aG1cblxuICAvLyBTdGVwIDE6IEFkZCBzZWxmIGxvb3BzIHRvIGVhY2ggbm9kZSwgaWUuIGFkZCBtdWx0RmFjdG9yIHRvIG1hdHJpeCBkaWFnb25hbFxuICBhZGRMb29wcyhNLCBuLCBvcHRzLm11bHRGYWN0b3IpO1xuXG4gIC8vIFN0ZXAgMjogTSA9IG5vcm1hbGl6ZSggTSApO1xuICBub3JtYWxpemUoTSwgbik7XG4gIHZhciBpc1N0aWxsTW92aW5nID0gdHJ1ZTtcbiAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuICB3aGlsZSAoaXNTdGlsbE1vdmluZyAmJiBpdGVyYXRpb25zIDwgb3B0cy5tYXhJdGVyYXRpb25zKSB7XG4gICAgaXNTdGlsbE1vdmluZyA9IGZhbHNlO1xuXG4gICAgLy8gU3RlcCAzOlxuICAgIF9NID0gZXhwYW5kKE0sIG4sIG9wdHMuZXhwYW5kRmFjdG9yKTtcblxuICAgIC8vIFN0ZXAgNDpcbiAgICBNID0gaW5mbGF0ZShfTSwgbiwgb3B0cy5pbmZsYXRlRmFjdG9yKTtcblxuICAgIC8vIFN0ZXAgNTogY2hlY2sgdG8gc2VlIGlmIH5zdGVhZHkgc3RhdGUgaGFzIGJlZW4gcmVhY2hlZFxuICAgIGlmICghaGFzQ29udmVyZ2VkKE0sIF9NLCBuMiwgNCkpIHtcbiAgICAgIGlzU3RpbGxNb3ZpbmcgPSB0cnVlO1xuICAgIH1cbiAgICBpdGVyYXRpb25zKys7XG4gIH1cblxuICAvLyBCdWlsZCBjbHVzdGVycyBmcm9tIG1hdHJpeFxuICB2YXIgY2x1c3RlcnMgPSBhc3NpZ24kMihNLCBuLCBub2RlcywgY3kpO1xuXG4gIC8vIFJlbW92ZSBkdXBsaWNhdGUgY2x1c3RlcnMgZHVlIHRvIHN5bW1ldHJ5IG9mIGdyYXBoIGFuZCBNIG1hdHJpeFxuICBjbHVzdGVycyA9IHJlbW92ZUR1cGxpY2F0ZXMoY2x1c3RlcnMpO1xuICByZXR1cm4gY2x1c3RlcnM7XG59O1xudmFyIG1hcmtvdkNsdXN0ZXJpbmckMSA9IHtcbiAgbWFya292Q2x1c3RlcmluZzogbWFya292Q2x1c3RlcmluZyxcbiAgbWNsOiBtYXJrb3ZDbHVzdGVyaW5nXG59O1xuXG4vLyBDb21tb24gZGlzdGFuY2UgbWV0cmljcyBmb3IgY2x1c3RlcmluZyBhbGdvcml0aG1zXG52YXIgaWRlbnRpdHkgPSBmdW5jdGlvbiBpZGVudGl0eSh4KSB7XG4gIHJldHVybiB4O1xufTtcbnZhciBhYnNEaWZmID0gZnVuY3Rpb24gYWJzRGlmZihwLCBxKSB7XG4gIHJldHVybiBNYXRoLmFicyhxIC0gcCk7XG59O1xudmFyIGFkZEFic0RpZmYgPSBmdW5jdGlvbiBhZGRBYnNEaWZmKHRvdGFsLCBwLCBxKSB7XG4gIHJldHVybiB0b3RhbCArIGFic0RpZmYocCwgcSk7XG59O1xudmFyIGFkZFNxdWFyZWREaWZmID0gZnVuY3Rpb24gYWRkU3F1YXJlZERpZmYodG90YWwsIHAsIHEpIHtcbiAgcmV0dXJuIHRvdGFsICsgTWF0aC5wb3cocSAtIHAsIDIpO1xufTtcbnZhciBzcXJ0ID0gZnVuY3Rpb24gc3FydCh4KSB7XG4gIHJldHVybiBNYXRoLnNxcnQoeCk7XG59O1xudmFyIG1heEFic0RpZmYgPSBmdW5jdGlvbiBtYXhBYnNEaWZmKGN1cnJlbnRNYXgsIHAsIHEpIHtcbiAgcmV0dXJuIE1hdGgubWF4KGN1cnJlbnRNYXgsIGFic0RpZmYocCwgcSkpO1xufTtcbnZhciBnZXREaXN0YW5jZSA9IGZ1bmN0aW9uIGdldERpc3RhbmNlKGxlbmd0aCwgZ2V0UCwgZ2V0USwgaW5pdCwgdmlzaXQpIHtcbiAgdmFyIHBvc3QgPSBhcmd1bWVudHMubGVuZ3RoID4gNSAmJiBhcmd1bWVudHNbNV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s1XSA6IGlkZW50aXR5O1xuICB2YXIgcmV0ID0gaW5pdDtcbiAgdmFyIHAsIHE7XG4gIGZvciAodmFyIGRpbSA9IDA7IGRpbSA8IGxlbmd0aDsgZGltKyspIHtcbiAgICBwID0gZ2V0UChkaW0pO1xuICAgIHEgPSBnZXRRKGRpbSk7XG4gICAgcmV0ID0gdmlzaXQocmV0LCBwLCBxKTtcbiAgfVxuICByZXR1cm4gcG9zdChyZXQpO1xufTtcbnZhciBkaXN0YW5jZXMgPSB7XG4gIGV1Y2xpZGVhbjogZnVuY3Rpb24gZXVjbGlkZWFuKGxlbmd0aCwgZ2V0UCwgZ2V0USkge1xuICAgIGlmIChsZW5ndGggPj0gMikge1xuICAgICAgcmV0dXJuIGdldERpc3RhbmNlKGxlbmd0aCwgZ2V0UCwgZ2V0USwgMCwgYWRkU3F1YXJlZERpZmYsIHNxcnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBmb3Igc2luZ2xlIGF0dHIgY2FzZSwgbW9yZSBlZmZpY2llbnQgdG8gYXZvaWQgc3FydFxuICAgICAgcmV0dXJuIGdldERpc3RhbmNlKGxlbmd0aCwgZ2V0UCwgZ2V0USwgMCwgYWRkQWJzRGlmZik7XG4gICAgfVxuICB9LFxuICBzcXVhcmVkRXVjbGlkZWFuOiBmdW5jdGlvbiBzcXVhcmVkRXVjbGlkZWFuKGxlbmd0aCwgZ2V0UCwgZ2V0USkge1xuICAgIHJldHVybiBnZXREaXN0YW5jZShsZW5ndGgsIGdldFAsIGdldFEsIDAsIGFkZFNxdWFyZWREaWZmKTtcbiAgfSxcbiAgbWFuaGF0dGFuOiBmdW5jdGlvbiBtYW5oYXR0YW4obGVuZ3RoLCBnZXRQLCBnZXRRKSB7XG4gICAgcmV0dXJuIGdldERpc3RhbmNlKGxlbmd0aCwgZ2V0UCwgZ2V0USwgMCwgYWRkQWJzRGlmZik7XG4gIH0sXG4gIG1heDogZnVuY3Rpb24gbWF4KGxlbmd0aCwgZ2V0UCwgZ2V0USkge1xuICAgIHJldHVybiBnZXREaXN0YW5jZShsZW5ndGgsIGdldFAsIGdldFEsIC1JbmZpbml0eSwgbWF4QWJzRGlmZik7XG4gIH1cbn07XG5cbi8vIGluIGNhc2UgdGhlIHVzZXIgYWNjaWRlbnRhbGx5IGRvZXNuJ3QgdXNlIGNhbWVsIGNhc2VcbmRpc3RhbmNlc1snc3F1YXJlZC1ldWNsaWRlYW4nXSA9IGRpc3RhbmNlc1snc3F1YXJlZEV1Y2xpZGVhbiddO1xuZGlzdGFuY2VzWydzcXVhcmVkZXVjbGlkZWFuJ10gPSBkaXN0YW5jZXNbJ3NxdWFyZWRFdWNsaWRlYW4nXTtcbmZ1bmN0aW9uIGNsdXN0ZXJpbmdEaXN0YW5jZSAobWV0aG9kLCBsZW5ndGgsIGdldFAsIGdldFEsIG5vZGVQLCBub2RlUSkge1xuICB2YXIgaW1wbDtcbiAgaWYgKGZuJDYobWV0aG9kKSkge1xuICAgIGltcGwgPSBtZXRob2Q7XG4gIH0gZWxzZSB7XG4gICAgaW1wbCA9IGRpc3RhbmNlc1ttZXRob2RdIHx8IGRpc3RhbmNlcy5ldWNsaWRlYW47XG4gIH1cbiAgaWYgKGxlbmd0aCA9PT0gMCAmJiBmbiQ2KG1ldGhvZCkpIHtcbiAgICByZXR1cm4gaW1wbChub2RlUCwgbm9kZVEpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBpbXBsKGxlbmd0aCwgZ2V0UCwgZ2V0USwgbm9kZVAsIG5vZGVRKTtcbiAgfVxufVxuXG52YXIgZGVmYXVsdHMkYiA9IGRlZmF1bHRzJGcoe1xuICBrOiAyLFxuICBtOiAyLFxuICBzZW5zaXRpdml0eVRocmVzaG9sZDogMC4wMDAxLFxuICBkaXN0YW5jZTogJ2V1Y2xpZGVhbicsXG4gIG1heEl0ZXJhdGlvbnM6IDEwLFxuICBhdHRyaWJ1dGVzOiBbXSxcbiAgdGVzdE1vZGU6IGZhbHNlLFxuICB0ZXN0Q2VudHJvaWRzOiBudWxsXG59KTtcbnZhciBzZXRPcHRpb25zJDIgPSBmdW5jdGlvbiBzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgcmV0dXJuIGRlZmF1bHRzJGIob3B0aW9ucyk7XG59O1xuXG52YXIgZ2V0RGlzdCA9IGZ1bmN0aW9uIGdldERpc3QodHlwZSwgbm9kZSwgY2VudHJvaWQsIGF0dHJpYnV0ZXMsIG1vZGUpIHtcbiAgdmFyIG5vTm9kZVAgPSBtb2RlICE9PSAna01lZG9pZHMnO1xuICB2YXIgZ2V0UCA9IG5vTm9kZVAgPyBmdW5jdGlvbiAoaSkge1xuICAgIHJldHVybiBjZW50cm9pZFtpXTtcbiAgfSA6IGZ1bmN0aW9uIChpKSB7XG4gICAgcmV0dXJuIGF0dHJpYnV0ZXNbaV0oY2VudHJvaWQpO1xuICB9O1xuICB2YXIgZ2V0USA9IGZ1bmN0aW9uIGdldFEoaSkge1xuICAgIHJldHVybiBhdHRyaWJ1dGVzW2ldKG5vZGUpO1xuICB9O1xuICB2YXIgbm9kZVAgPSBjZW50cm9pZDtcbiAgdmFyIG5vZGVRID0gbm9kZTtcbiAgcmV0dXJuIGNsdXN0ZXJpbmdEaXN0YW5jZSh0eXBlLCBhdHRyaWJ1dGVzLmxlbmd0aCwgZ2V0UCwgZ2V0USwgbm9kZVAsIG5vZGVRKTtcbn07XG52YXIgcmFuZG9tQ2VudHJvaWRzID0gZnVuY3Rpb24gcmFuZG9tQ2VudHJvaWRzKG5vZGVzLCBrLCBhdHRyaWJ1dGVzKSB7XG4gIHZhciBuZGltID0gYXR0cmlidXRlcy5sZW5ndGg7XG4gIHZhciBtaW4gPSBuZXcgQXJyYXkobmRpbSk7XG4gIHZhciBtYXggPSBuZXcgQXJyYXkobmRpbSk7XG4gIHZhciBjZW50cm9pZHMgPSBuZXcgQXJyYXkoayk7XG4gIHZhciBjZW50cm9pZCA9IG51bGw7XG5cbiAgLy8gRmluZCBtaW4sIG1heCB2YWx1ZXMgZm9yIGVhY2ggYXR0cmlidXRlIGRpbWVuc2lvblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG5kaW07IGkrKykge1xuICAgIG1pbltpXSA9IG5vZGVzLm1pbihhdHRyaWJ1dGVzW2ldKS52YWx1ZTtcbiAgICBtYXhbaV0gPSBub2Rlcy5tYXgoYXR0cmlidXRlc1tpXSkudmFsdWU7XG4gIH1cblxuICAvLyBCdWlsZCBrIGNlbnRyb2lkcywgZWFjaCByZXByZXNlbnRlZCBhcyBhbiBuLWRpbSBmZWF0dXJlIHZlY3RvclxuICBmb3IgKHZhciBjID0gMDsgYyA8IGs7IGMrKykge1xuICAgIGNlbnRyb2lkID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IG5kaW07IF9pKyspIHtcbiAgICAgIGNlbnRyb2lkW19pXSA9IE1hdGgucmFuZG9tKCkgKiAobWF4W19pXSAtIG1pbltfaV0pICsgbWluW19pXTsgLy8gcmFuZG9tIGluaXRpYWwgdmFsdWVcbiAgICB9XG5cbiAgICBjZW50cm9pZHNbY10gPSBjZW50cm9pZDtcbiAgfVxuICByZXR1cm4gY2VudHJvaWRzO1xufTtcbnZhciBjbGFzc2lmeSA9IGZ1bmN0aW9uIGNsYXNzaWZ5KG5vZGUsIGNlbnRyb2lkcywgZGlzdGFuY2UsIGF0dHJpYnV0ZXMsIHR5cGUpIHtcbiAgdmFyIG1pbiA9IEluZmluaXR5O1xuICB2YXIgaW5kZXggPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNlbnRyb2lkcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBkaXN0ID0gZ2V0RGlzdChkaXN0YW5jZSwgbm9kZSwgY2VudHJvaWRzW2ldLCBhdHRyaWJ1dGVzLCB0eXBlKTtcbiAgICBpZiAoZGlzdCA8IG1pbikge1xuICAgICAgbWluID0gZGlzdDtcbiAgICAgIGluZGV4ID0gaTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGluZGV4O1xufTtcbnZhciBidWlsZENsdXN0ZXIgPSBmdW5jdGlvbiBidWlsZENsdXN0ZXIoY2VudHJvaWQsIG5vZGVzLCBhc3NpZ25tZW50KSB7XG4gIHZhciBjbHVzdGVyID0gW107XG4gIHZhciBub2RlID0gbnVsbDtcbiAgZm9yICh2YXIgbiA9IDA7IG4gPCBub2Rlcy5sZW5ndGg7IG4rKykge1xuICAgIG5vZGUgPSBub2Rlc1tuXTtcbiAgICBpZiAoYXNzaWdubWVudFtub2RlLmlkKCldID09PSBjZW50cm9pZCkge1xuICAgICAgLy9jb25zb2xlLmxvZyhcIk5vZGUgXCIgKyBub2RlLmlkKCkgKyBcIiBpcyBhc3NvY2lhdGVkIHdpdGggbWVkb2lkICM6IFwiICsgbSk7XG4gICAgICBjbHVzdGVyLnB1c2gobm9kZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBjbHVzdGVyO1xufTtcbnZhciBoYXZlVmFsdWVzQ29udmVyZ2VkID0gZnVuY3Rpb24gaGF2ZVZhbHVlc0NvbnZlcmdlZCh2MSwgdjIsIHNlbnNpdGl2aXR5VGhyZXNob2xkKSB7XG4gIHJldHVybiBNYXRoLmFicyh2MiAtIHYxKSA8PSBzZW5zaXRpdml0eVRocmVzaG9sZDtcbn07XG52YXIgaGF2ZU1hdHJpY2VzQ29udmVyZ2VkID0gZnVuY3Rpb24gaGF2ZU1hdHJpY2VzQ29udmVyZ2VkKHYxLCB2Miwgc2Vuc2l0aXZpdHlUaHJlc2hvbGQpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB2MS5sZW5ndGg7IGkrKykge1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgdjFbaV0ubGVuZ3RoOyBqKyspIHtcbiAgICAgIHZhciBkaWZmID0gTWF0aC5hYnModjFbaV1bal0gLSB2MltpXVtqXSk7XG4gICAgICBpZiAoZGlmZiA+IHNlbnNpdGl2aXR5VGhyZXNob2xkKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xudmFyIHNlZW5CZWZvcmUgPSBmdW5jdGlvbiBzZWVuQmVmb3JlKG5vZGUsIG1lZG9pZHMsIG4pIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICBpZiAobm9kZSA9PT0gbWVkb2lkc1tpXSkgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcbnZhciByYW5kb21NZWRvaWRzID0gZnVuY3Rpb24gcmFuZG9tTWVkb2lkcyhub2Rlcywgaykge1xuICB2YXIgbWVkb2lkcyA9IG5ldyBBcnJheShrKTtcblxuICAvLyBGb3Igc21hbGwgZGF0YSBzZXRzLCB0aGUgcHJvYmFiaWxpdHkgb2YgbWVkb2lkIGNvbmZsaWN0IGlzIGdyZWF0ZXIsXG4gIC8vIHNvIHdlIG5lZWQgdG8gY2hlY2sgdG8gc2VlIGlmIHdlJ3ZlIGFscmVhZHkgc2VlbiBvciBjaG9zZSB0aGlzIG5vZGUgYmVmb3JlLlxuICBpZiAobm9kZXMubGVuZ3RoIDwgNTApIHtcbiAgICAvLyBSYW5kb21seSBzZWxlY3QgayBtZWRvaWRzIGZyb20gdGhlIG4gbm9kZXNcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGs7IGkrKykge1xuICAgICAgdmFyIG5vZGUgPSBub2Rlc1tNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBub2Rlcy5sZW5ndGgpXTtcblxuICAgICAgLy8gSWYgd2UndmUgYWxyZWFkeSBjaG9zZW4gdGhpcyBub2RlIHRvIGJlIGEgbWVkb2lkLCBkb24ndCBjaG9vc2UgaXQgYWdhaW4gKGZvciBzbWFsbCBkYXRhIHNldHMpLlxuICAgICAgLy8gSW5zdGVhZCBjaG9vc2UgYSBkaWZmZXJlbnQgcmFuZG9tIG5vZGUuXG4gICAgICB3aGlsZSAoc2VlbkJlZm9yZShub2RlLCBtZWRvaWRzLCBpKSkge1xuICAgICAgICBub2RlID0gbm9kZXNbTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogbm9kZXMubGVuZ3RoKV07XG4gICAgICB9XG4gICAgICBtZWRvaWRzW2ldID0gbm9kZTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gUmVsYXRpdmVseSBsYXJnZSBkYXRhIHNldCwgc28gcHJldHR5IHNhZmUgdG8gbm90IGNoZWNrIGFuZCBqdXN0IHNlbGVjdCByYW5kb20gbm9kZXNcbiAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBrOyBfaTIrKykge1xuICAgICAgbWVkb2lkc1tfaTJdID0gbm9kZXNbTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogbm9kZXMubGVuZ3RoKV07XG4gICAgfVxuICB9XG4gIHJldHVybiBtZWRvaWRzO1xufTtcbnZhciBmaW5kQ29zdCA9IGZ1bmN0aW9uIGZpbmRDb3N0KHBvdGVudGlhbE5ld01lZG9pZCwgY2x1c3RlciwgYXR0cmlidXRlcykge1xuICB2YXIgY29zdCA9IDA7XG4gIGZvciAodmFyIG4gPSAwOyBuIDwgY2x1c3Rlci5sZW5ndGg7IG4rKykge1xuICAgIGNvc3QgKz0gZ2V0RGlzdCgnbWFuaGF0dGFuJywgY2x1c3RlcltuXSwgcG90ZW50aWFsTmV3TWVkb2lkLCBhdHRyaWJ1dGVzLCAna01lZG9pZHMnKTtcbiAgfVxuICByZXR1cm4gY29zdDtcbn07XG52YXIga01lYW5zID0gZnVuY3Rpb24ga01lYW5zKG9wdGlvbnMpIHtcbiAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuICB2YXIgbm9kZXMgPSB0aGlzLm5vZGVzKCk7XG4gIHZhciBub2RlID0gbnVsbDtcblxuICAvLyBTZXQgcGFyYW1ldGVycyBvZiBhbGdvcml0aG06ICMgb2YgY2x1c3RlcnMsIGRpc3RhbmNlIG1ldHJpYywgZXRjLlxuICB2YXIgb3B0cyA9IHNldE9wdGlvbnMkMihvcHRpb25zKTtcblxuICAvLyBCZWdpbiBrLW1lYW5zIGFsZ29yaXRobVxuICB2YXIgY2x1c3RlcnMgPSBuZXcgQXJyYXkob3B0cy5rKTtcbiAgdmFyIGFzc2lnbm1lbnQgPSB7fTtcbiAgdmFyIGNlbnRyb2lkcztcblxuICAvLyBTdGVwIDE6IEluaXRpYWxpemUgY2VudHJvaWQgcG9zaXRpb25zXG4gIGlmIChvcHRzLnRlc3RNb2RlKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzLnRlc3RDZW50cm9pZHMgPT09ICdudW1iZXInKSB7XG4gICAgICAvLyBUT0RPOiBpbXBsZW1lbnQgYSBzZWVkZWQgcmFuZG9tIG51bWJlciBnZW5lcmF0b3IuXG4gICAgICBvcHRzLnRlc3RDZW50cm9pZHM7XG4gICAgICBjZW50cm9pZHMgPSByYW5kb21DZW50cm9pZHMobm9kZXMsIG9wdHMuaywgb3B0cy5hdHRyaWJ1dGVzKTtcbiAgICB9IGVsc2UgaWYgKF90eXBlb2Yob3B0cy50ZXN0Q2VudHJvaWRzKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGNlbnRyb2lkcyA9IG9wdHMudGVzdENlbnRyb2lkcztcbiAgICB9IGVsc2Uge1xuICAgICAgY2VudHJvaWRzID0gcmFuZG9tQ2VudHJvaWRzKG5vZGVzLCBvcHRzLmssIG9wdHMuYXR0cmlidXRlcyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGNlbnRyb2lkcyA9IHJhbmRvbUNlbnRyb2lkcyhub2Rlcywgb3B0cy5rLCBvcHRzLmF0dHJpYnV0ZXMpO1xuICB9XG4gIHZhciBpc1N0aWxsTW92aW5nID0gdHJ1ZTtcbiAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuICB3aGlsZSAoaXNTdGlsbE1vdmluZyAmJiBpdGVyYXRpb25zIDwgb3B0cy5tYXhJdGVyYXRpb25zKSB7XG4gICAgLy8gU3RlcCAyOiBBc3NpZ24gbm9kZXMgdG8gdGhlIG5lYXJlc3QgY2VudHJvaWRcbiAgICBmb3IgKHZhciBuID0gMDsgbiA8IG5vZGVzLmxlbmd0aDsgbisrKSB7XG4gICAgICBub2RlID0gbm9kZXNbbl07XG4gICAgICAvLyBEZXRlcm1pbmUgd2hpY2ggY2x1c3RlciB0aGlzIG5vZGUgYmVsb25ncyB0bzogbm9kZSBpZCA9PiBjbHVzdGVyICNcbiAgICAgIGFzc2lnbm1lbnRbbm9kZS5pZCgpXSA9IGNsYXNzaWZ5KG5vZGUsIGNlbnRyb2lkcywgb3B0cy5kaXN0YW5jZSwgb3B0cy5hdHRyaWJ1dGVzLCAna01lYW5zJyk7XG4gICAgfVxuXG4gICAgLy8gU3RlcCAzOiBGb3IgZWFjaCBvZiB0aGUgayBjbHVzdGVycywgdXBkYXRlIGl0cyBjZW50cm9pZFxuICAgIGlzU3RpbGxNb3ZpbmcgPSBmYWxzZTtcbiAgICBmb3IgKHZhciBjID0gMDsgYyA8IG9wdHMuazsgYysrKSB7XG4gICAgICAvLyBHZXQgYWxsIG5vZGVzIHRoYXQgYmVsb25nIHRvIHRoaXMgY2x1c3RlclxuICAgICAgdmFyIGNsdXN0ZXIgPSBidWlsZENsdXN0ZXIoYywgbm9kZXMsIGFzc2lnbm1lbnQpO1xuICAgICAgaWYgKGNsdXN0ZXIubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIC8vIElmIGNsdXN0ZXIgaXMgZW1wdHksIGJyZWFrIG91dCBlYXJseSAmIG1vdmUgdG8gbmV4dCBjbHVzdGVyXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBVcGRhdGUgY2VudHJvaWRzIGJ5IGNhbGN1bGF0aW5nIGF2ZyBvZiBhbGwgbm9kZXMgd2l0aGluIHRoZSBjbHVzdGVyLlxuICAgICAgdmFyIG5kaW0gPSBvcHRzLmF0dHJpYnV0ZXMubGVuZ3RoO1xuICAgICAgdmFyIGNlbnRyb2lkID0gY2VudHJvaWRzW2NdOyAvLyBbIGRpbV8xLCBkaW1fMiwgZGltXzMsIC4uLiAsIGRpbV9uIF1cbiAgICAgIHZhciBuZXdDZW50cm9pZCA9IG5ldyBBcnJheShuZGltKTtcbiAgICAgIHZhciBzdW0gPSBuZXcgQXJyYXkobmRpbSk7XG4gICAgICBmb3IgKHZhciBkID0gMDsgZCA8IG5kaW07IGQrKykge1xuICAgICAgICBzdW1bZF0gPSAwLjA7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2x1c3Rlci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIG5vZGUgPSBjbHVzdGVyW2ldO1xuICAgICAgICAgIHN1bVtkXSArPSBvcHRzLmF0dHJpYnV0ZXNbZF0obm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgbmV3Q2VudHJvaWRbZF0gPSBzdW1bZF0gLyBjbHVzdGVyLmxlbmd0aDtcblxuICAgICAgICAvLyBDaGVjayB0byBzZWUgaWYgYWxnb3JpdGhtIGhhcyBjb252ZXJnZWQsIGkuZS4gd2hlbiBjZW50cm9pZHMgbm8gbG9uZ2VyIGNoYW5nZVxuICAgICAgICBpZiAoIWhhdmVWYWx1ZXNDb252ZXJnZWQobmV3Q2VudHJvaWRbZF0sIGNlbnRyb2lkW2RdLCBvcHRzLnNlbnNpdGl2aXR5VGhyZXNob2xkKSkge1xuICAgICAgICAgIGlzU3RpbGxNb3ZpbmcgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjZW50cm9pZHNbY10gPSBuZXdDZW50cm9pZDtcbiAgICAgIGNsdXN0ZXJzW2NdID0gY3kuY29sbGVjdGlvbihjbHVzdGVyKTtcbiAgICB9XG4gICAgaXRlcmF0aW9ucysrO1xuICB9XG4gIHJldHVybiBjbHVzdGVycztcbn07XG52YXIga01lZG9pZHMgPSBmdW5jdGlvbiBrTWVkb2lkcyhvcHRpb25zKSB7XG4gIHZhciBjeSA9IHRoaXMuY3koKTtcbiAgdmFyIG5vZGVzID0gdGhpcy5ub2RlcygpO1xuICB2YXIgbm9kZSA9IG51bGw7XG4gIHZhciBvcHRzID0gc2V0T3B0aW9ucyQyKG9wdGlvbnMpO1xuXG4gIC8vIEJlZ2luIGstbWVkb2lkcyBhbGdvcml0aG1cbiAgdmFyIGNsdXN0ZXJzID0gbmV3IEFycmF5KG9wdHMuayk7XG4gIHZhciBtZWRvaWRzO1xuICB2YXIgYXNzaWdubWVudCA9IHt9O1xuICB2YXIgY3VyQ29zdDtcbiAgdmFyIG1pbkNvc3RzID0gbmV3IEFycmF5KG9wdHMuayk7IC8vIG1pbmltdW0gY29zdCBjb25maWd1cmF0aW9uIGZvciBlYWNoIGNsdXN0ZXJcblxuICAvLyBTdGVwIDE6IEluaXRpYWxpemUgayBtZWRvaWRzXG4gIGlmIChvcHRzLnRlc3RNb2RlKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzLnRlc3RDZW50cm9pZHMgPT09ICdudW1iZXInKSA7IGVsc2UgaWYgKF90eXBlb2Yob3B0cy50ZXN0Q2VudHJvaWRzKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIG1lZG9pZHMgPSBvcHRzLnRlc3RDZW50cm9pZHM7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1lZG9pZHMgPSByYW5kb21NZWRvaWRzKG5vZGVzLCBvcHRzLmspO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBtZWRvaWRzID0gcmFuZG9tTWVkb2lkcyhub2Rlcywgb3B0cy5rKTtcbiAgfVxuICB2YXIgaXNTdGlsbE1vdmluZyA9IHRydWU7XG4gIHZhciBpdGVyYXRpb25zID0gMDtcbiAgd2hpbGUgKGlzU3RpbGxNb3ZpbmcgJiYgaXRlcmF0aW9ucyA8IG9wdHMubWF4SXRlcmF0aW9ucykge1xuICAgIC8vIFN0ZXAgMjogQXNzaWduIG5vZGVzIHRvIHRoZSBuZWFyZXN0IG1lZG9pZFxuICAgIGZvciAodmFyIG4gPSAwOyBuIDwgbm9kZXMubGVuZ3RoOyBuKyspIHtcbiAgICAgIG5vZGUgPSBub2Rlc1tuXTtcbiAgICAgIC8vIERldGVybWluZSB3aGljaCBjbHVzdGVyIHRoaXMgbm9kZSBiZWxvbmdzIHRvOiBub2RlIGlkID0+IGNsdXN0ZXIgI1xuICAgICAgYXNzaWdubWVudFtub2RlLmlkKCldID0gY2xhc3NpZnkobm9kZSwgbWVkb2lkcywgb3B0cy5kaXN0YW5jZSwgb3B0cy5hdHRyaWJ1dGVzLCAna01lZG9pZHMnKTtcbiAgICB9XG4gICAgaXNTdGlsbE1vdmluZyA9IGZhbHNlO1xuICAgIC8vIFN0ZXAgMzogRm9yIGVhY2ggbWVkb2lkIG0sIGFuZCBmb3IgZWFjaCBub2RlIGFzc29jaWF0ZWQgd2l0aCBtZWRpb2QgbSxcbiAgICAvLyBzZWxlY3QgdGhlIG5vZGUgd2l0aCB0aGUgbG93ZXN0IGNvbmZpZ3VyYXRpb24gY29zdCBhcyBuZXcgbWVkb2lkLlxuICAgIGZvciAodmFyIG0gPSAwOyBtIDwgbWVkb2lkcy5sZW5ndGg7IG0rKykge1xuICAgICAgLy8gR2V0IGFsbCBub2RlcyB0aGF0IGJlbG9uZyB0byB0aGlzIG1lZG9pZFxuICAgICAgdmFyIGNsdXN0ZXIgPSBidWlsZENsdXN0ZXIobSwgbm9kZXMsIGFzc2lnbm1lbnQpO1xuICAgICAgaWYgKGNsdXN0ZXIubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIC8vIElmIGNsdXN0ZXIgaXMgZW1wdHksIGJyZWFrIG91dCBlYXJseSAmIG1vdmUgdG8gbmV4dCBjbHVzdGVyXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgbWluQ29zdHNbbV0gPSBmaW5kQ29zdChtZWRvaWRzW21dLCBjbHVzdGVyLCBvcHRzLmF0dHJpYnV0ZXMpOyAvLyBvcmlnaW5hbCBjb3N0XG5cbiAgICAgIC8vIFNlbGVjdCBkaWZmZXJlbnQgbWVkb2lkIGlmIGl0cyBjb25maWd1cmF0aW9uIGhhcyB0aGUgbG93ZXN0IGNvc3RcbiAgICAgIGZvciAodmFyIF9uID0gMDsgX24gPCBjbHVzdGVyLmxlbmd0aDsgX24rKykge1xuICAgICAgICBjdXJDb3N0ID0gZmluZENvc3QoY2x1c3Rlcltfbl0sIGNsdXN0ZXIsIG9wdHMuYXR0cmlidXRlcyk7XG4gICAgICAgIGlmIChjdXJDb3N0IDwgbWluQ29zdHNbbV0pIHtcbiAgICAgICAgICBtaW5Db3N0c1ttXSA9IGN1ckNvc3Q7XG4gICAgICAgICAgbWVkb2lkc1ttXSA9IGNsdXN0ZXJbX25dO1xuICAgICAgICAgIGlzU3RpbGxNb3ZpbmcgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjbHVzdGVyc1ttXSA9IGN5LmNvbGxlY3Rpb24oY2x1c3Rlcik7XG4gICAgfVxuICAgIGl0ZXJhdGlvbnMrKztcbiAgfVxuICByZXR1cm4gY2x1c3RlcnM7XG59O1xudmFyIHVwZGF0ZUNlbnRyb2lkcyA9IGZ1bmN0aW9uIHVwZGF0ZUNlbnRyb2lkcyhjZW50cm9pZHMsIG5vZGVzLCBVLCB3ZWlnaHQsIG9wdHMpIHtcbiAgdmFyIG51bWVyYXRvciwgZGVub21pbmF0b3I7XG4gIGZvciAodmFyIG4gPSAwOyBuIDwgbm9kZXMubGVuZ3RoOyBuKyspIHtcbiAgICBmb3IgKHZhciBjID0gMDsgYyA8IGNlbnRyb2lkcy5sZW5ndGg7IGMrKykge1xuICAgICAgd2VpZ2h0W25dW2NdID0gTWF0aC5wb3coVVtuXVtjXSwgb3B0cy5tKTtcbiAgICB9XG4gIH1cbiAgZm9yICh2YXIgX2MgPSAwOyBfYyA8IGNlbnRyb2lkcy5sZW5ndGg7IF9jKyspIHtcbiAgICBmb3IgKHZhciBkaW0gPSAwOyBkaW0gPCBvcHRzLmF0dHJpYnV0ZXMubGVuZ3RoOyBkaW0rKykge1xuICAgICAgbnVtZXJhdG9yID0gMDtcbiAgICAgIGRlbm9taW5hdG9yID0gMDtcbiAgICAgIGZvciAodmFyIF9uMiA9IDA7IF9uMiA8IG5vZGVzLmxlbmd0aDsgX24yKyspIHtcbiAgICAgICAgbnVtZXJhdG9yICs9IHdlaWdodFtfbjJdW19jXSAqIG9wdHMuYXR0cmlidXRlc1tkaW1dKG5vZGVzW19uMl0pO1xuICAgICAgICBkZW5vbWluYXRvciArPSB3ZWlnaHRbX24yXVtfY107XG4gICAgICB9XG4gICAgICBjZW50cm9pZHNbX2NdW2RpbV0gPSBudW1lcmF0b3IgLyBkZW5vbWluYXRvcjtcbiAgICB9XG4gIH1cbn07XG52YXIgdXBkYXRlTWVtYmVyc2hpcCA9IGZ1bmN0aW9uIHVwZGF0ZU1lbWJlcnNoaXAoVSwgX1UsIGNlbnRyb2lkcywgbm9kZXMsIG9wdHMpIHtcbiAgLy8gU2F2ZSBwcmV2aW91cyBzdGVwXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgVS5sZW5ndGg7IGkrKykge1xuICAgIF9VW2ldID0gVVtpXS5zbGljZSgpO1xuICB9XG4gIHZhciBzdW0sIG51bWVyYXRvciwgZGVub21pbmF0b3I7XG4gIHZhciBwb3cgPSAyIC8gKG9wdHMubSAtIDEpO1xuICBmb3IgKHZhciBjID0gMDsgYyA8IGNlbnRyb2lkcy5sZW5ndGg7IGMrKykge1xuICAgIGZvciAodmFyIG4gPSAwOyBuIDwgbm9kZXMubGVuZ3RoOyBuKyspIHtcbiAgICAgIHN1bSA9IDA7XG4gICAgICBmb3IgKHZhciBrID0gMDsgayA8IGNlbnRyb2lkcy5sZW5ndGg7IGsrKykge1xuICAgICAgICAvLyBhZ2FpbnN0IGFsbCBvdGhlciBjZW50cm9pZHNcbiAgICAgICAgbnVtZXJhdG9yID0gZ2V0RGlzdChvcHRzLmRpc3RhbmNlLCBub2Rlc1tuXSwgY2VudHJvaWRzW2NdLCBvcHRzLmF0dHJpYnV0ZXMsICdjbWVhbnMnKTtcbiAgICAgICAgZGVub21pbmF0b3IgPSBnZXREaXN0KG9wdHMuZGlzdGFuY2UsIG5vZGVzW25dLCBjZW50cm9pZHNba10sIG9wdHMuYXR0cmlidXRlcywgJ2NtZWFucycpO1xuICAgICAgICBzdW0gKz0gTWF0aC5wb3cobnVtZXJhdG9yIC8gZGVub21pbmF0b3IsIHBvdyk7XG4gICAgICB9XG4gICAgICBVW25dW2NdID0gMSAvIHN1bTtcbiAgICB9XG4gIH1cbn07XG52YXIgYXNzaWduJDEgPSBmdW5jdGlvbiBhc3NpZ24obm9kZXMsIFUsIG9wdHMsIGN5KSB7XG4gIHZhciBjbHVzdGVycyA9IG5ldyBBcnJheShvcHRzLmspO1xuICBmb3IgKHZhciBjID0gMDsgYyA8IGNsdXN0ZXJzLmxlbmd0aDsgYysrKSB7XG4gICAgY2x1c3RlcnNbY10gPSBbXTtcbiAgfVxuICB2YXIgbWF4O1xuICB2YXIgaW5kZXg7XG4gIGZvciAodmFyIG4gPSAwOyBuIDwgVS5sZW5ndGg7IG4rKykge1xuICAgIC8vIGZvciBlYWNoIG5vZGUgKFUgaXMgTiB4IEMgbWF0cml4KVxuICAgIG1heCA9IC1JbmZpbml0eTtcbiAgICBpbmRleCA9IC0xO1xuICAgIC8vIERldGVybWluZSB3aGljaCBjbHVzdGVyIHRoZSBub2RlIGlzIG1vc3QgbGlrZWx5IHRvIGJlbG9uZyBpblxuICAgIGZvciAodmFyIF9jMiA9IDA7IF9jMiA8IFVbMF0ubGVuZ3RoOyBfYzIrKykge1xuICAgICAgaWYgKFVbbl1bX2MyXSA+IG1heCkge1xuICAgICAgICBtYXggPSBVW25dW19jMl07XG4gICAgICAgIGluZGV4ID0gX2MyO1xuICAgICAgfVxuICAgIH1cbiAgICBjbHVzdGVyc1tpbmRleF0ucHVzaChub2Rlc1tuXSk7XG4gIH1cblxuICAvLyBUdXJuIGV2ZXJ5IGFycmF5IGludG8gYSBjb2xsZWN0aW9uIG9mIG5vZGVzXG4gIGZvciAodmFyIF9jMyA9IDA7IF9jMyA8IGNsdXN0ZXJzLmxlbmd0aDsgX2MzKyspIHtcbiAgICBjbHVzdGVyc1tfYzNdID0gY3kuY29sbGVjdGlvbihjbHVzdGVyc1tfYzNdKTtcbiAgfVxuICByZXR1cm4gY2x1c3RlcnM7XG59O1xudmFyIGZ1enp5Q01lYW5zID0gZnVuY3Rpb24gZnV6enlDTWVhbnMob3B0aW9ucykge1xuICB2YXIgY3kgPSB0aGlzLmN5KCk7XG4gIHZhciBub2RlcyA9IHRoaXMubm9kZXMoKTtcbiAgdmFyIG9wdHMgPSBzZXRPcHRpb25zJDIob3B0aW9ucyk7XG5cbiAgLy8gQmVnaW4gZnV6enkgYy1tZWFucyBhbGdvcml0aG1cbiAgdmFyIGNsdXN0ZXJzO1xuICB2YXIgY2VudHJvaWRzO1xuICB2YXIgVTtcbiAgdmFyIF9VO1xuICB2YXIgd2VpZ2h0O1xuXG4gIC8vIFN0ZXAgMTogSW5pdGlhbGl6ZSBsZXRpYWJsZXMuXG4gIF9VID0gbmV3IEFycmF5KG5vZGVzLmxlbmd0aCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAvLyBOIHggQyBtYXRyaXhcbiAgICBfVVtpXSA9IG5ldyBBcnJheShvcHRzLmspO1xuICB9XG4gIFUgPSBuZXcgQXJyYXkobm9kZXMubGVuZ3RoKTtcbiAgZm9yICh2YXIgX2kzID0gMDsgX2kzIDwgbm9kZXMubGVuZ3RoOyBfaTMrKykge1xuICAgIC8vIE4geCBDIG1hdHJpeFxuICAgIFVbX2kzXSA9IG5ldyBBcnJheShvcHRzLmspO1xuICB9XG4gIGZvciAodmFyIF9pNCA9IDA7IF9pNCA8IG5vZGVzLmxlbmd0aDsgX2k0KyspIHtcbiAgICB2YXIgdG90YWwgPSAwO1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgb3B0cy5rOyBqKyspIHtcbiAgICAgIFVbX2k0XVtqXSA9IE1hdGgucmFuZG9tKCk7XG4gICAgICB0b3RhbCArPSBVW19pNF1bal07XG4gICAgfVxuICAgIGZvciAodmFyIF9qID0gMDsgX2ogPCBvcHRzLms7IF9qKyspIHtcbiAgICAgIFVbX2k0XVtfal0gPSBVW19pNF1bX2pdIC8gdG90YWw7XG4gICAgfVxuICB9XG4gIGNlbnRyb2lkcyA9IG5ldyBBcnJheShvcHRzLmspO1xuICBmb3IgKHZhciBfaTUgPSAwOyBfaTUgPCBvcHRzLms7IF9pNSsrKSB7XG4gICAgY2VudHJvaWRzW19pNV0gPSBuZXcgQXJyYXkob3B0cy5hdHRyaWJ1dGVzLmxlbmd0aCk7XG4gIH1cbiAgd2VpZ2h0ID0gbmV3IEFycmF5KG5vZGVzLmxlbmd0aCk7XG4gIGZvciAodmFyIF9pNiA9IDA7IF9pNiA8IG5vZGVzLmxlbmd0aDsgX2k2KyspIHtcbiAgICAvLyBOIHggQyBtYXRyaXhcbiAgICB3ZWlnaHRbX2k2XSA9IG5ldyBBcnJheShvcHRzLmspO1xuICB9XG4gIC8vIGVuZCBpbml0IEZDTVxuXG4gIHZhciBpc1N0aWxsTW92aW5nID0gdHJ1ZTtcbiAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuICB3aGlsZSAoaXNTdGlsbE1vdmluZyAmJiBpdGVyYXRpb25zIDwgb3B0cy5tYXhJdGVyYXRpb25zKSB7XG4gICAgaXNTdGlsbE1vdmluZyA9IGZhbHNlO1xuXG4gICAgLy8gU3RlcCAyOiBDYWxjdWxhdGUgdGhlIGNlbnRyb2lkcyBmb3IgZWFjaCBzdGVwLlxuICAgIHVwZGF0ZUNlbnRyb2lkcyhjZW50cm9pZHMsIG5vZGVzLCBVLCB3ZWlnaHQsIG9wdHMpO1xuXG4gICAgLy8gU3RlcCAzOiBVcGRhdGUgdGhlIHBhcnRpdGlvbiBtYXRyaXggVS5cbiAgICB1cGRhdGVNZW1iZXJzaGlwKFUsIF9VLCBjZW50cm9pZHMsIG5vZGVzLCBvcHRzKTtcblxuICAgIC8vIFN0ZXAgNDogQ2hlY2sgZm9yIGNvbnZlcmdlbmNlLlxuICAgIGlmICghaGF2ZU1hdHJpY2VzQ29udmVyZ2VkKFUsIF9VLCBvcHRzLnNlbnNpdGl2aXR5VGhyZXNob2xkKSkge1xuICAgICAgaXNTdGlsbE1vdmluZyA9IHRydWU7XG4gICAgfVxuICAgIGl0ZXJhdGlvbnMrKztcbiAgfVxuXG4gIC8vIEFzc2lnbiBub2RlcyB0byBjbHVzdGVycyB3aXRoIGhpZ2hlc3QgcHJvYmFiaWxpdHkuXG4gIGNsdXN0ZXJzID0gYXNzaWduJDEobm9kZXMsIFUsIG9wdHMsIGN5KTtcbiAgcmV0dXJuIHtcbiAgICBjbHVzdGVyczogY2x1c3RlcnMsXG4gICAgZGVncmVlT2ZNZW1iZXJzaGlwOiBVXG4gIH07XG59O1xudmFyIGtDbHVzdGVyaW5nID0ge1xuICBrTWVhbnM6IGtNZWFucyxcbiAga01lZG9pZHM6IGtNZWRvaWRzLFxuICBmdXp6eUNNZWFuczogZnV6enlDTWVhbnMsXG4gIGZjbTogZnV6enlDTWVhbnNcbn07XG5cbi8vIEltcGxlbWVudGVkIGJ5IFpvZSBYaSBAem9leGkgZm9yIEdTT0MgMjAxNlxudmFyIGRlZmF1bHRzJGEgPSBkZWZhdWx0cyRnKHtcbiAgZGlzdGFuY2U6ICdldWNsaWRlYW4nLFxuICAvLyBkaXN0YW5jZSBtZXRyaWMgdG8gY29tcGFyZSBub2Rlc1xuICBsaW5rYWdlOiAnbWluJyxcbiAgLy8gbGlua2FnZSBjcml0ZXJpb24gOiBob3cgdG8gZGV0ZXJtaW5lIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIGNsdXN0ZXJzIG9mIG5vZGVzXG4gIG1vZGU6ICd0aHJlc2hvbGQnLFxuICAvLyBtb2RlOid0aHJlc2hvbGQnID0+IGNsdXN0ZXJzIG11c3QgYmUgdGhyZXNob2xkIGRpc3RhbmNlIGFwYXJ0XG4gIHRocmVzaG9sZDogSW5maW5pdHksXG4gIC8vIHRoZSBkaXN0YW5jZSB0aHJlc2hvbGRcbiAgLy8gbW9kZTonZGVuZHJvZ3JhbScgPT4gdGhlIG5vZGVzIGFyZSBvcmdhbmlzZWQgYXMgbGVhdmVzIGluIGEgdHJlZSAoc2libGluZ3MgYXJlIGNsb3NlKSwgbWVyZ2luZyBtYWtlcyBjbHVzdGVyc1xuICBhZGREZW5kcm9ncmFtOiBmYWxzZSxcbiAgLy8gd2hldGhlciB0byBhZGQgdGhlIGRlbmRyb2dyYW0gdG8gdGhlIGdyYXBoIGZvciB2aXpcbiAgZGVuZHJvZ3JhbURlcHRoOiAwLFxuICAvLyBkZXB0aCBhdCB3aGljaCBkZW5kcm9ncmFtIGJyYW5jaGVzIGFyZSBtZXJnZWQgaW50byB0aGUgcmV0dXJuZWQgY2x1c3RlcnNcbiAgYXR0cmlidXRlczogW10gLy8gYXJyYXkgb2YgYXR0ciBmdW5jdGlvbnNcbn0pO1xuXG52YXIgbGlua2FnZUFsaWFzZXMgPSB7XG4gICdzaW5nbGUnOiAnbWluJyxcbiAgJ2NvbXBsZXRlJzogJ21heCdcbn07XG52YXIgc2V0T3B0aW9ucyQxID0gZnVuY3Rpb24gc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gIHZhciBvcHRzID0gZGVmYXVsdHMkYShvcHRpb25zKTtcbiAgdmFyIHByZWZlcnJlZEFsaWFzID0gbGlua2FnZUFsaWFzZXNbb3B0cy5saW5rYWdlXTtcbiAgaWYgKHByZWZlcnJlZEFsaWFzICE9IG51bGwpIHtcbiAgICBvcHRzLmxpbmthZ2UgPSBwcmVmZXJyZWRBbGlhcztcbiAgfVxuICByZXR1cm4gb3B0cztcbn07XG52YXIgbWVyZ2VDbG9zZXN0ID0gZnVuY3Rpb24gbWVyZ2VDbG9zZXN0KGNsdXN0ZXJzLCBpbmRleCwgZGlzdHMsIG1pbnMsIG9wdHMpIHtcbiAgLy8gRmluZCB0d28gY2xvc2VzdCBjbHVzdGVycyBmcm9tIGNhY2hlZCBtaW5zXG4gIHZhciBtaW5LZXkgPSAwO1xuICB2YXIgbWluID0gSW5maW5pdHk7XG4gIHZhciBkaXN0O1xuICB2YXIgYXR0cnMgPSBvcHRzLmF0dHJpYnV0ZXM7XG4gIHZhciBnZXREaXN0ID0gZnVuY3Rpb24gZ2V0RGlzdChuMSwgbjIpIHtcbiAgICByZXR1cm4gY2x1c3RlcmluZ0Rpc3RhbmNlKG9wdHMuZGlzdGFuY2UsIGF0dHJzLmxlbmd0aCwgZnVuY3Rpb24gKGkpIHtcbiAgICAgIHJldHVybiBhdHRyc1tpXShuMSk7XG4gICAgfSwgZnVuY3Rpb24gKGkpIHtcbiAgICAgIHJldHVybiBhdHRyc1tpXShuMik7XG4gICAgfSwgbjEsIG4yKTtcbiAgfTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbHVzdGVycy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBrZXkgPSBjbHVzdGVyc1tpXS5rZXk7XG4gICAgdmFyIF9kaXN0ID0gZGlzdHNba2V5XVttaW5zW2tleV1dO1xuICAgIGlmIChfZGlzdCA8IG1pbikge1xuICAgICAgbWluS2V5ID0ga2V5O1xuICAgICAgbWluID0gX2Rpc3Q7XG4gICAgfVxuICB9XG4gIGlmIChvcHRzLm1vZGUgPT09ICd0aHJlc2hvbGQnICYmIG1pbiA+PSBvcHRzLnRocmVzaG9sZCB8fCBvcHRzLm1vZGUgPT09ICdkZW5kcm9ncmFtJyAmJiBjbHVzdGVycy5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIGMxID0gaW5kZXhbbWluS2V5XTtcbiAgdmFyIGMyID0gaW5kZXhbbWluc1ttaW5LZXldXTtcbiAgdmFyIG1lcmdlZDtcblxuICAvLyBNZXJnZSB0d28gY2xvc2VzdCBjbHVzdGVyc1xuICBpZiAob3B0cy5tb2RlID09PSAnZGVuZHJvZ3JhbScpIHtcbiAgICBtZXJnZWQgPSB7XG4gICAgICBsZWZ0OiBjMSxcbiAgICAgIHJpZ2h0OiBjMixcbiAgICAgIGtleTogYzEua2V5XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBtZXJnZWQgPSB7XG4gICAgICB2YWx1ZTogYzEudmFsdWUuY29uY2F0KGMyLnZhbHVlKSxcbiAgICAgIGtleTogYzEua2V5XG4gICAgfTtcbiAgfVxuICBjbHVzdGVyc1tjMS5pbmRleF0gPSBtZXJnZWQ7XG4gIGNsdXN0ZXJzLnNwbGljZShjMi5pbmRleCwgMSk7XG4gIGluZGV4W2MxLmtleV0gPSBtZXJnZWQ7XG5cbiAgLy8gVXBkYXRlIGRpc3RhbmNlcyB3aXRoIG5ldyBtZXJnZWQgY2x1c3RlclxuICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgY2x1c3RlcnMubGVuZ3RoOyBfaSsrKSB7XG4gICAgdmFyIGN1ciA9IGNsdXN0ZXJzW19pXTtcbiAgICBpZiAoYzEua2V5ID09PSBjdXIua2V5KSB7XG4gICAgICBkaXN0ID0gSW5maW5pdHk7XG4gICAgfSBlbHNlIGlmIChvcHRzLmxpbmthZ2UgPT09ICdtaW4nKSB7XG4gICAgICBkaXN0ID0gZGlzdHNbYzEua2V5XVtjdXIua2V5XTtcbiAgICAgIGlmIChkaXN0c1tjMS5rZXldW2N1ci5rZXldID4gZGlzdHNbYzIua2V5XVtjdXIua2V5XSkge1xuICAgICAgICBkaXN0ID0gZGlzdHNbYzIua2V5XVtjdXIua2V5XTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG9wdHMubGlua2FnZSA9PT0gJ21heCcpIHtcbiAgICAgIGRpc3QgPSBkaXN0c1tjMS5rZXldW2N1ci5rZXldO1xuICAgICAgaWYgKGRpc3RzW2MxLmtleV1bY3VyLmtleV0gPCBkaXN0c1tjMi5rZXldW2N1ci5rZXldKSB7XG4gICAgICAgIGRpc3QgPSBkaXN0c1tjMi5rZXldW2N1ci5rZXldO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAob3B0cy5saW5rYWdlID09PSAnbWVhbicpIHtcbiAgICAgIGRpc3QgPSAoZGlzdHNbYzEua2V5XVtjdXIua2V5XSAqIGMxLnNpemUgKyBkaXN0c1tjMi5rZXldW2N1ci5rZXldICogYzIuc2l6ZSkgLyAoYzEuc2l6ZSArIGMyLnNpemUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAob3B0cy5tb2RlID09PSAnZGVuZHJvZ3JhbScpIGRpc3QgPSBnZXREaXN0KGN1ci52YWx1ZSwgYzEudmFsdWUpO2Vsc2UgZGlzdCA9IGdldERpc3QoY3VyLnZhbHVlWzBdLCBjMS52YWx1ZVswXSk7XG4gICAgfVxuICAgIGRpc3RzW2MxLmtleV1bY3VyLmtleV0gPSBkaXN0c1tjdXIua2V5XVtjMS5rZXldID0gZGlzdDsgLy8gZGlzdGFuY2UgbWF0cml4IGlzIHN5bW1ldHJpY1xuICB9XG5cbiAgLy8gVXBkYXRlIGNhY2hlZCBtaW5zXG4gIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IGNsdXN0ZXJzLmxlbmd0aDsgX2kyKyspIHtcbiAgICB2YXIga2V5MSA9IGNsdXN0ZXJzW19pMl0ua2V5O1xuICAgIGlmIChtaW5zW2tleTFdID09PSBjMS5rZXkgfHwgbWluc1trZXkxXSA9PT0gYzIua2V5KSB7XG4gICAgICB2YXIgX21pbiA9IGtleTE7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGNsdXN0ZXJzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHZhciBrZXkyID0gY2x1c3RlcnNbal0ua2V5O1xuICAgICAgICBpZiAoZGlzdHNba2V5MV1ba2V5Ml0gPCBkaXN0c1trZXkxXVtfbWluXSkge1xuICAgICAgICAgIF9taW4gPSBrZXkyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBtaW5zW2tleTFdID0gX21pbjtcbiAgICB9XG4gICAgY2x1c3RlcnNbX2kyXS5pbmRleCA9IF9pMjtcbiAgfVxuXG4gIC8vIENsZWFuIHVwIG1ldGEgZGF0YSB1c2VkIGZvciBjbHVzdGVyaW5nXG4gIGMxLmtleSA9IGMyLmtleSA9IGMxLmluZGV4ID0gYzIuaW5kZXggPSBudWxsO1xuICByZXR1cm4gdHJ1ZTtcbn07XG52YXIgZ2V0QWxsQ2hpbGRyZW4gPSBmdW5jdGlvbiBnZXRBbGxDaGlsZHJlbihyb290LCBhcnIsIGN5KSB7XG4gIGlmICghcm9vdCkgcmV0dXJuO1xuICBpZiAocm9vdC52YWx1ZSkge1xuICAgIGFyci5wdXNoKHJvb3QudmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIGlmIChyb290LmxlZnQpIGdldEFsbENoaWxkcmVuKHJvb3QubGVmdCwgYXJyKTtcbiAgICBpZiAocm9vdC5yaWdodCkgZ2V0QWxsQ2hpbGRyZW4ocm9vdC5yaWdodCwgYXJyKTtcbiAgfVxufTtcbnZhciBidWlsZERlbmRyb2dyYW0gPSBmdW5jdGlvbiBidWlsZERlbmRyb2dyYW0ocm9vdCwgY3kpIHtcbiAgaWYgKCFyb290KSByZXR1cm4gJyc7XG4gIGlmIChyb290LmxlZnQgJiYgcm9vdC5yaWdodCkge1xuICAgIHZhciBsZWZ0U3RyID0gYnVpbGREZW5kcm9ncmFtKHJvb3QubGVmdCwgY3kpO1xuICAgIHZhciByaWdodFN0ciA9IGJ1aWxkRGVuZHJvZ3JhbShyb290LnJpZ2h0LCBjeSk7XG4gICAgdmFyIG5vZGUgPSBjeS5hZGQoe1xuICAgICAgZ3JvdXA6ICdub2RlcycsXG4gICAgICBkYXRhOiB7XG4gICAgICAgIGlkOiBsZWZ0U3RyICsgJywnICsgcmlnaHRTdHJcbiAgICAgIH1cbiAgICB9KTtcbiAgICBjeS5hZGQoe1xuICAgICAgZ3JvdXA6ICdlZGdlcycsXG4gICAgICBkYXRhOiB7XG4gICAgICAgIHNvdXJjZTogbGVmdFN0cixcbiAgICAgICAgdGFyZ2V0OiBub2RlLmlkKClcbiAgICAgIH1cbiAgICB9KTtcbiAgICBjeS5hZGQoe1xuICAgICAgZ3JvdXA6ICdlZGdlcycsXG4gICAgICBkYXRhOiB7XG4gICAgICAgIHNvdXJjZTogcmlnaHRTdHIsXG4gICAgICAgIHRhcmdldDogbm9kZS5pZCgpXG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIG5vZGUuaWQoKTtcbiAgfSBlbHNlIGlmIChyb290LnZhbHVlKSB7XG4gICAgcmV0dXJuIHJvb3QudmFsdWUuaWQoKTtcbiAgfVxufTtcbnZhciBidWlsZENsdXN0ZXJzRnJvbVRyZWUgPSBmdW5jdGlvbiBidWlsZENsdXN0ZXJzRnJvbVRyZWUocm9vdCwgaywgY3kpIHtcbiAgaWYgKCFyb290KSByZXR1cm4gW107XG4gIHZhciBsZWZ0ID0gW10sXG4gICAgcmlnaHQgPSBbXSxcbiAgICBsZWF2ZXMgPSBbXTtcbiAgaWYgKGsgPT09IDApIHtcbiAgICAvLyBkb24ndCBjdXQgdHJlZSwgc2ltcGx5IHJldHVybiBhbGwgbm9kZXMgYXMgMSBzaW5nbGUgY2x1c3RlclxuICAgIGlmIChyb290LmxlZnQpIGdldEFsbENoaWxkcmVuKHJvb3QubGVmdCwgbGVmdCk7XG4gICAgaWYgKHJvb3QucmlnaHQpIGdldEFsbENoaWxkcmVuKHJvb3QucmlnaHQsIHJpZ2h0KTtcbiAgICBsZWF2ZXMgPSBsZWZ0LmNvbmNhdChyaWdodCk7XG4gICAgcmV0dXJuIFtjeS5jb2xsZWN0aW9uKGxlYXZlcyldO1xuICB9IGVsc2UgaWYgKGsgPT09IDEpIHtcbiAgICAvLyBjdXQgYXQgcm9vdFxuXG4gICAgaWYgKHJvb3QudmFsdWUpIHtcbiAgICAgIC8vIGxlYWYgbm9kZVxuICAgICAgcmV0dXJuIFtjeS5jb2xsZWN0aW9uKHJvb3QudmFsdWUpXTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHJvb3QubGVmdCkgZ2V0QWxsQ2hpbGRyZW4ocm9vdC5sZWZ0LCBsZWZ0KTtcbiAgICAgIGlmIChyb290LnJpZ2h0KSBnZXRBbGxDaGlsZHJlbihyb290LnJpZ2h0LCByaWdodCk7XG4gICAgICByZXR1cm4gW2N5LmNvbGxlY3Rpb24obGVmdCksIGN5LmNvbGxlY3Rpb24ocmlnaHQpXTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKHJvb3QudmFsdWUpIHtcbiAgICAgIHJldHVybiBbY3kuY29sbGVjdGlvbihyb290LnZhbHVlKV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChyb290LmxlZnQpIGxlZnQgPSBidWlsZENsdXN0ZXJzRnJvbVRyZWUocm9vdC5sZWZ0LCBrIC0gMSwgY3kpO1xuICAgICAgaWYgKHJvb3QucmlnaHQpIHJpZ2h0ID0gYnVpbGRDbHVzdGVyc0Zyb21UcmVlKHJvb3QucmlnaHQsIGsgLSAxLCBjeSk7XG4gICAgICByZXR1cm4gbGVmdC5jb25jYXQocmlnaHQpO1xuICAgIH1cbiAgfVxufTtcblxudmFyIGhpZXJhcmNoaWNhbENsdXN0ZXJpbmcgPSBmdW5jdGlvbiBoaWVyYXJjaGljYWxDbHVzdGVyaW5nKG9wdGlvbnMpIHtcbiAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuICB2YXIgbm9kZXMgPSB0aGlzLm5vZGVzKCk7XG5cbiAgLy8gU2V0IHBhcmFtZXRlcnMgb2YgYWxnb3JpdGhtOiBsaW5rYWdlIHR5cGUsIGRpc3RhbmNlIG1ldHJpYywgZXRjLlxuICB2YXIgb3B0cyA9IHNldE9wdGlvbnMkMShvcHRpb25zKTtcbiAgdmFyIGF0dHJzID0gb3B0cy5hdHRyaWJ1dGVzO1xuICB2YXIgZ2V0RGlzdCA9IGZ1bmN0aW9uIGdldERpc3QobjEsIG4yKSB7XG4gICAgcmV0dXJuIGNsdXN0ZXJpbmdEaXN0YW5jZShvcHRzLmRpc3RhbmNlLCBhdHRycy5sZW5ndGgsIGZ1bmN0aW9uIChpKSB7XG4gICAgICByZXR1cm4gYXR0cnNbaV0objEpO1xuICAgIH0sIGZ1bmN0aW9uIChpKSB7XG4gICAgICByZXR1cm4gYXR0cnNbaV0objIpO1xuICAgIH0sIG4xLCBuMik7XG4gIH07XG5cbiAgLy8gQmVnaW4gaGllcmFyY2hpY2FsIGFsZ29yaXRobVxuICB2YXIgY2x1c3RlcnMgPSBbXTtcbiAgdmFyIGRpc3RzID0gW107IC8vIGRpc3RhbmNlcyBiZXR3ZWVuIGVhY2ggcGFpciBvZiBjbHVzdGVyc1xuICB2YXIgbWlucyA9IFtdOyAvLyBjbG9zZXN0IGNsdXN0ZXIgZm9yIGVhY2ggY2x1c3RlclxuICB2YXIgaW5kZXggPSBbXTsgLy8gaGFzaCBvZiBhbGwgY2x1c3RlcnMgYnkga2V5XG5cbiAgLy8gSW4gYWdnbG9tZXJhdGl2ZSAoYm90dG9tLXVwKSBjbHVzdGVyaW5nLCBlYWNoIG5vZGUgc3RhcnRzIGFzIGl0cyBvd24gY2x1c3RlclxuICBmb3IgKHZhciBuID0gMDsgbiA8IG5vZGVzLmxlbmd0aDsgbisrKSB7XG4gICAgdmFyIGNsdXN0ZXIgPSB7XG4gICAgICB2YWx1ZTogb3B0cy5tb2RlID09PSAnZGVuZHJvZ3JhbScgPyBub2Rlc1tuXSA6IFtub2Rlc1tuXV0sXG4gICAgICBrZXk6IG4sXG4gICAgICBpbmRleDogblxuICAgIH07XG4gICAgY2x1c3RlcnNbbl0gPSBjbHVzdGVyO1xuICAgIGluZGV4W25dID0gY2x1c3RlcjtcbiAgICBkaXN0c1tuXSA9IFtdO1xuICAgIG1pbnNbbl0gPSAwO1xuICB9XG5cbiAgLy8gQ2FsY3VsYXRlIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIGVhY2ggcGFpciBvZiBjbHVzdGVyc1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNsdXN0ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPD0gaTsgaisrKSB7XG4gICAgICB2YXIgZGlzdCA9IHZvaWQgMDtcbiAgICAgIGlmIChvcHRzLm1vZGUgPT09ICdkZW5kcm9ncmFtJykge1xuICAgICAgICAvLyBtb2RlcyBzdG9yZSBjbHVzdGVyIHZhbHVlcyBkaWZmZXJlbnRseVxuICAgICAgICBkaXN0ID0gaSA9PT0gaiA/IEluZmluaXR5IDogZ2V0RGlzdChjbHVzdGVyc1tpXS52YWx1ZSwgY2x1c3RlcnNbal0udmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGlzdCA9IGkgPT09IGogPyBJbmZpbml0eSA6IGdldERpc3QoY2x1c3RlcnNbaV0udmFsdWVbMF0sIGNsdXN0ZXJzW2pdLnZhbHVlWzBdKTtcbiAgICAgIH1cbiAgICAgIGRpc3RzW2ldW2pdID0gZGlzdDtcbiAgICAgIGRpc3RzW2pdW2ldID0gZGlzdDtcbiAgICAgIGlmIChkaXN0IDwgZGlzdHNbaV1bbWluc1tpXV0pIHtcbiAgICAgICAgbWluc1tpXSA9IGo7IC8vIENhY2hlIG1pbnM6IGNsb3Nlc3QgY2x1c3RlciB0byBjbHVzdGVyIGkgaXMgY2x1c3RlciBqXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gRmluZCB0aGUgY2xvc2VzdCBwYWlyIG9mIGNsdXN0ZXJzIGFuZCBtZXJnZSB0aGVtIGludG8gYSBzaW5nbGUgY2x1c3Rlci5cbiAgLy8gVXBkYXRlIGRpc3RhbmNlcyBiZXR3ZWVuIG5ldyBjbHVzdGVyIGFuZCBlYWNoIG9mIHRoZSBvbGQgY2x1c3RlcnMsIGFuZCBsb29wIHVudGlsIHRocmVzaG9sZCByZWFjaGVkLlxuICB2YXIgbWVyZ2VkID0gbWVyZ2VDbG9zZXN0KGNsdXN0ZXJzLCBpbmRleCwgZGlzdHMsIG1pbnMsIG9wdHMpO1xuICB3aGlsZSAobWVyZ2VkKSB7XG4gICAgbWVyZ2VkID0gbWVyZ2VDbG9zZXN0KGNsdXN0ZXJzLCBpbmRleCwgZGlzdHMsIG1pbnMsIG9wdHMpO1xuICB9XG4gIHZhciByZXRDbHVzdGVycztcblxuICAvLyBEZW5kcm9ncmFtIG1vZGUgYnVpbGRzIHRoZSBoaWVyYXJjaHkgYW5kIGFkZHMgaW50ZXJtZWRpYXJ5IG5vZGVzICsgZWRnZXNcbiAgLy8gaW4gYWRkaXRpb24gdG8gcmV0dXJuaW5nIHRoZSBjbHVzdGVycy5cbiAgaWYgKG9wdHMubW9kZSA9PT0gJ2RlbmRyb2dyYW0nKSB7XG4gICAgcmV0Q2x1c3RlcnMgPSBidWlsZENsdXN0ZXJzRnJvbVRyZWUoY2x1c3RlcnNbMF0sIG9wdHMuZGVuZHJvZ3JhbURlcHRoLCBjeSk7XG4gICAgaWYgKG9wdHMuYWRkRGVuZHJvZ3JhbSkgYnVpbGREZW5kcm9ncmFtKGNsdXN0ZXJzWzBdLCBjeSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gUmVndWxhciBtb2RlIHNpbXBseSByZXR1cm5zIHRoZSBjbHVzdGVyc1xuXG4gICAgcmV0Q2x1c3RlcnMgPSBuZXcgQXJyYXkoY2x1c3RlcnMubGVuZ3RoKTtcbiAgICBjbHVzdGVycy5mb3JFYWNoKGZ1bmN0aW9uIChjbHVzdGVyLCBpKSB7XG4gICAgICAvLyBDbGVhbiB1cCBtZXRhIGRhdGEgdXNlZCBmb3IgY2x1c3RlcmluZ1xuICAgICAgY2x1c3Rlci5rZXkgPSBjbHVzdGVyLmluZGV4ID0gbnVsbDtcbiAgICAgIHJldENsdXN0ZXJzW2ldID0gY3kuY29sbGVjdGlvbihjbHVzdGVyLnZhbHVlKTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gcmV0Q2x1c3RlcnM7XG59O1xudmFyIGhpZXJhcmNoaWNhbENsdXN0ZXJpbmckMSA9IHtcbiAgaGllcmFyY2hpY2FsQ2x1c3RlcmluZzogaGllcmFyY2hpY2FsQ2x1c3RlcmluZyxcbiAgaGNhOiBoaWVyYXJjaGljYWxDbHVzdGVyaW5nXG59O1xuXG4vLyBJbXBsZW1lbnRlZCBieSBab2UgWGkgQHpvZXhpIGZvciBHU09DIDIwMTZcbnZhciBkZWZhdWx0cyQ5ID0gZGVmYXVsdHMkZyh7XG4gIGRpc3RhbmNlOiAnZXVjbGlkZWFuJyxcbiAgLy8gZGlzdGFuY2UgbWV0cmljIHRvIGNvbXBhcmUgYXR0cmlidXRlcyBiZXR3ZWVuIHR3byBub2Rlc1xuICBwcmVmZXJlbmNlOiAnbWVkaWFuJyxcbiAgLy8gc3VpdGFiaWxpdHkgb2YgYSBkYXRhIHBvaW50IHRvIHNlcnZlIGFzIGFuIGV4ZW1wbGFyXG4gIGRhbXBpbmc6IDAuOCxcbiAgLy8gZGFtcGluZyBmYWN0b3IgYmV0d2VlbiBbMC41LCAxKVxuICBtYXhJdGVyYXRpb25zOiAxMDAwLFxuICAvLyBtYXggbnVtYmVyIG9mIGl0ZXJhdGlvbnMgdG8gcnVuXG4gIG1pbkl0ZXJhdGlvbnM6IDEwMCxcbiAgLy8gbWluIG51bWJlciBvZiBpdGVyYXRpb25zIHRvIHJ1biBpbiBvcmRlciBmb3IgY2x1c3RlcmluZyB0byBzdG9wXG4gIGF0dHJpYnV0ZXM6IFsvLyBmdW5jdGlvbnMgdG8gcXVhbnRpZnkgdGhlIHNpbWlsYXJpdHkgYmV0d2VlbiBhbnkgdHdvIHBvaW50c1xuICAgIC8vIGUuZy4gbm9kZSA9PiBub2RlLmRhdGEoJ3dlaWdodCcpXG4gIF1cbn0pO1xudmFyIHNldE9wdGlvbnMgPSBmdW5jdGlvbiBzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgdmFyIGRtcCA9IG9wdGlvbnMuZGFtcGluZztcbiAgdmFyIHByZWYgPSBvcHRpb25zLnByZWZlcmVuY2U7XG4gIGlmICghKDAuNSA8PSBkbXAgJiYgZG1wIDwgMSkpIHtcbiAgICBlcnJvcihcIkRhbXBpbmcgbXVzdCByYW5nZSBvbiBbMC41LCAxKS4gIEdvdDogXCIuY29uY2F0KGRtcCkpO1xuICB9XG4gIHZhciB2YWxpZFByZWZzID0gWydtZWRpYW4nLCAnbWVhbicsICdtaW4nLCAnbWF4J107XG4gIGlmICghKHZhbGlkUHJlZnMuc29tZShmdW5jdGlvbiAodikge1xuICAgIHJldHVybiB2ID09PSBwcmVmO1xuICB9KSB8fCBudW1iZXIkMShwcmVmKSkpIHtcbiAgICBlcnJvcihcIlByZWZlcmVuY2UgbXVzdCBiZSBvbmUgb2YgW1wiLmNvbmNhdCh2YWxpZFByZWZzLm1hcChmdW5jdGlvbiAocCkge1xuICAgICAgcmV0dXJuIFwiJ1wiLmNvbmNhdChwLCBcIidcIik7XG4gICAgfSkuam9pbignLCAnKSwgXCJdIG9yIGEgbnVtYmVyLiAgR290OiBcIikuY29uY2F0KHByZWYpKTtcbiAgfVxuICByZXR1cm4gZGVmYXVsdHMkOShvcHRpb25zKTtcbn07XG5cbnZhciBnZXRTaW1pbGFyaXR5ID0gZnVuY3Rpb24gZ2V0U2ltaWxhcml0eSh0eXBlLCBuMSwgbjIsIGF0dHJpYnV0ZXMpIHtcbiAgdmFyIGF0dHIgPSBmdW5jdGlvbiBhdHRyKG4sIGkpIHtcbiAgICByZXR1cm4gYXR0cmlidXRlc1tpXShuKTtcbiAgfTtcblxuICAvLyBuYiBuZWdhdGl2ZSBiZWNhdXNlIHNpbWlsYXJpdHkgc2hvdWxkIGhhdmUgYW4gaW52ZXJzZSByZWxhdGlvbnNoaXAgdG8gZGlzdGFuY2VcbiAgcmV0dXJuIC1jbHVzdGVyaW5nRGlzdGFuY2UodHlwZSwgYXR0cmlidXRlcy5sZW5ndGgsIGZ1bmN0aW9uIChpKSB7XG4gICAgcmV0dXJuIGF0dHIobjEsIGkpO1xuICB9LCBmdW5jdGlvbiAoaSkge1xuICAgIHJldHVybiBhdHRyKG4yLCBpKTtcbiAgfSwgbjEsIG4yKTtcbn07XG52YXIgZ2V0UHJlZmVyZW5jZSA9IGZ1bmN0aW9uIGdldFByZWZlcmVuY2UoUywgcHJlZmVyZW5jZSkge1xuICAvLyBsYXJnZXIgcHJlZmVyZW5jZSA9IGdyZWF0ZXIgIyBvZiBjbHVzdGVyc1xuICB2YXIgcCA9IG51bGw7XG4gIGlmIChwcmVmZXJlbmNlID09PSAnbWVkaWFuJykge1xuICAgIHAgPSBtZWRpYW4oUyk7XG4gIH0gZWxzZSBpZiAocHJlZmVyZW5jZSA9PT0gJ21lYW4nKSB7XG4gICAgcCA9IG1lYW4oUyk7XG4gIH0gZWxzZSBpZiAocHJlZmVyZW5jZSA9PT0gJ21pbicpIHtcbiAgICBwID0gbWluKFMpO1xuICB9IGVsc2UgaWYgKHByZWZlcmVuY2UgPT09ICdtYXgnKSB7XG4gICAgcCA9IG1heChTKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBDdXN0b20gcHJlZmVyZW5jZSBudW1iZXIsIGFzIHNldCBieSB1c2VyXG4gICAgcCA9IHByZWZlcmVuY2U7XG4gIH1cbiAgcmV0dXJuIHA7XG59O1xudmFyIGZpbmRFeGVtcGxhcnMgPSBmdW5jdGlvbiBmaW5kRXhlbXBsYXJzKG4sIFIsIEEpIHtcbiAgdmFyIGluZGljZXMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICBpZiAoUltpICogbiArIGldICsgQVtpICogbiArIGldID4gMCkge1xuICAgICAgaW5kaWNlcy5wdXNoKGkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gaW5kaWNlcztcbn07XG52YXIgYXNzaWduQ2x1c3RlcnMgPSBmdW5jdGlvbiBhc3NpZ25DbHVzdGVycyhuLCBTLCBleGVtcGxhcnMpIHtcbiAgdmFyIGNsdXN0ZXJzID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgdmFyIGluZGV4ID0gLTE7XG4gICAgdmFyIG1heCA9IC1JbmZpbml0eTtcbiAgICBmb3IgKHZhciBlaSA9IDA7IGVpIDwgZXhlbXBsYXJzLmxlbmd0aDsgZWkrKykge1xuICAgICAgdmFyIGUgPSBleGVtcGxhcnNbZWldO1xuICAgICAgaWYgKFNbaSAqIG4gKyBlXSA+IG1heCkge1xuICAgICAgICBpbmRleCA9IGU7XG4gICAgICAgIG1heCA9IFNbaSAqIG4gKyBlXTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGluZGV4ID4gMCkge1xuICAgICAgY2x1c3RlcnMucHVzaChpbmRleCk7XG4gICAgfVxuICB9XG4gIGZvciAodmFyIF9laSA9IDA7IF9laSA8IGV4ZW1wbGFycy5sZW5ndGg7IF9laSsrKSB7XG4gICAgY2x1c3RlcnNbZXhlbXBsYXJzW19laV1dID0gZXhlbXBsYXJzW19laV07XG4gIH1cbiAgcmV0dXJuIGNsdXN0ZXJzO1xufTtcbnZhciBhc3NpZ24gPSBmdW5jdGlvbiBhc3NpZ24obiwgUywgZXhlbXBsYXJzKSB7XG4gIHZhciBjbHVzdGVycyA9IGFzc2lnbkNsdXN0ZXJzKG4sIFMsIGV4ZW1wbGFycyk7XG4gIGZvciAodmFyIGVpID0gMDsgZWkgPCBleGVtcGxhcnMubGVuZ3RoOyBlaSsrKSB7XG4gICAgdmFyIGlpID0gW107XG4gICAgZm9yICh2YXIgYyA9IDA7IGMgPCBjbHVzdGVycy5sZW5ndGg7IGMrKykge1xuICAgICAgaWYgKGNsdXN0ZXJzW2NdID09PSBleGVtcGxhcnNbZWldKSB7XG4gICAgICAgIGlpLnB1c2goYyk7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBtYXhJID0gLTE7XG4gICAgdmFyIG1heFN1bSA9IC1JbmZpbml0eTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlpLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc3VtID0gMDtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgaWkubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgc3VtICs9IFNbaWlbal0gKiBuICsgaWlbaV1dO1xuICAgICAgfVxuICAgICAgaWYgKHN1bSA+IG1heFN1bSkge1xuICAgICAgICBtYXhJID0gaTtcbiAgICAgICAgbWF4U3VtID0gc3VtO1xuICAgICAgfVxuICAgIH1cbiAgICBleGVtcGxhcnNbZWldID0gaWlbbWF4SV07XG4gIH1cbiAgY2x1c3RlcnMgPSBhc3NpZ25DbHVzdGVycyhuLCBTLCBleGVtcGxhcnMpO1xuICByZXR1cm4gY2x1c3RlcnM7XG59O1xudmFyIGFmZmluaXR5UHJvcGFnYXRpb24gPSBmdW5jdGlvbiBhZmZpbml0eVByb3BhZ2F0aW9uKG9wdGlvbnMpIHtcbiAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuICB2YXIgbm9kZXMgPSB0aGlzLm5vZGVzKCk7XG4gIHZhciBvcHRzID0gc2V0T3B0aW9ucyhvcHRpb25zKTtcblxuICAvLyBNYXAgZWFjaCBub2RlIHRvIGl0cyBwb3NpdGlvbiBpbiBub2RlIGFycmF5XG4gIHZhciBpZDJwb3NpdGlvbiA9IHt9O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWQycG9zaXRpb25bbm9kZXNbaV0uaWQoKV0gPSBpO1xuICB9XG5cbiAgLy8gQmVnaW4gYWZmaW5pdHkgcHJvcGFnYXRpb24gYWxnb3JpdGhtXG5cbiAgdmFyIG47IC8vIG51bWJlciBvZiBkYXRhIHBvaW50c1xuICB2YXIgbjI7IC8vIHNpemUgb2YgbWF0cmljZXNcbiAgdmFyIFM7IC8vIHNpbWlsYXJpdHkgbWF0cml4ICgxRCBhcnJheSlcbiAgdmFyIHA7IC8vIHByZWZlcmVuY2Uvc3VpdGFiaWxpdHkgb2YgYSBkYXRhIHBvaW50IHRvIHNlcnZlIGFzIGFuIGV4ZW1wbGFyXG4gIHZhciBSOyAvLyByZXNwb25zaWJpbGl0eSBtYXRyaXggKDFEIGFycmF5KVxuICB2YXIgQTsgLy8gYXZhaWxhYmlsaXR5IG1hdHJpeCAoMUQgYXJyYXkpXG5cbiAgbiA9IG5vZGVzLmxlbmd0aDtcbiAgbjIgPSBuICogbjtcblxuICAvLyBJbml0aWFsaXplIGFuZCBidWlsZCBTIHNpbWlsYXJpdHkgbWF0cml4XG4gIFMgPSBuZXcgQXJyYXkobjIpO1xuICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgbjI7IF9pKyspIHtcbiAgICBTW19pXSA9IC1JbmZpbml0eTsgLy8gZm9yIGNhc2VzIHdoZXJlIHR3byBkYXRhIHBvaW50cyBzaG91bGRuJ3QgYmUgbGlua2VkIHRvZ2V0aGVyXG4gIH1cblxuICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBuOyBfaTIrKykge1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgbjsgaisrKSB7XG4gICAgICBpZiAoX2kyICE9PSBqKSB7XG4gICAgICAgIFNbX2kyICogbiArIGpdID0gZ2V0U2ltaWxhcml0eShvcHRzLmRpc3RhbmNlLCBub2Rlc1tfaTJdLCBub2Rlc1tqXSwgb3B0cy5hdHRyaWJ1dGVzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBQbGFjZSBwcmVmZXJlbmNlcyBvbiB0aGUgZGlhZ29uYWwgb2YgU1xuICBwID0gZ2V0UHJlZmVyZW5jZShTLCBvcHRzLnByZWZlcmVuY2UpO1xuICBmb3IgKHZhciBfaTMgPSAwOyBfaTMgPCBuOyBfaTMrKykge1xuICAgIFNbX2kzICogbiArIF9pM10gPSBwO1xuICB9XG5cbiAgLy8gSW5pdGlhbGl6ZSBSIHJlc3BvbnNpYmlsaXR5IG1hdHJpeFxuICBSID0gbmV3IEFycmF5KG4yKTtcbiAgZm9yICh2YXIgX2k0ID0gMDsgX2k0IDwgbjI7IF9pNCsrKSB7XG4gICAgUltfaTRdID0gMC4wO1xuICB9XG5cbiAgLy8gSW5pdGlhbGl6ZSBBIGF2YWlsYWJpbGl0eSBtYXRyaXhcbiAgQSA9IG5ldyBBcnJheShuMik7XG4gIGZvciAodmFyIF9pNSA9IDA7IF9pNSA8IG4yOyBfaTUrKykge1xuICAgIEFbX2k1XSA9IDAuMDtcbiAgfVxuICB2YXIgb2xkID0gbmV3IEFycmF5KG4pO1xuICB2YXIgUnAgPSBuZXcgQXJyYXkobik7XG4gIHZhciBzZSA9IG5ldyBBcnJheShuKTtcbiAgZm9yICh2YXIgX2k2ID0gMDsgX2k2IDwgbjsgX2k2KyspIHtcbiAgICBvbGRbX2k2XSA9IDAuMDtcbiAgICBScFtfaTZdID0gMC4wO1xuICAgIHNlW19pNl0gPSAwO1xuICB9XG4gIHZhciBlID0gbmV3IEFycmF5KG4gKiBvcHRzLm1pbkl0ZXJhdGlvbnMpO1xuICBmb3IgKHZhciBfaTcgPSAwOyBfaTcgPCBlLmxlbmd0aDsgX2k3KyspIHtcbiAgICBlW19pN10gPSAwO1xuICB9XG4gIHZhciBpdGVyO1xuICBmb3IgKGl0ZXIgPSAwOyBpdGVyIDwgb3B0cy5tYXhJdGVyYXRpb25zOyBpdGVyKyspIHtcbiAgICAvLyBtYWluIGFsZ29yaXRobWljIGxvb3BcblxuICAgIC8vIFVwZGF0ZSBSIHJlc3BvbnNpYmlsaXR5IG1hdHJpeFxuICAgIGZvciAodmFyIF9pOCA9IDA7IF9pOCA8IG47IF9pOCsrKSB7XG4gICAgICB2YXIgbWF4ID0gLUluZmluaXR5LFxuICAgICAgICBtYXgyID0gLUluZmluaXR5LFxuICAgICAgICBtYXhJID0gLTEsXG4gICAgICAgIEFTID0gMC4wO1xuICAgICAgZm9yICh2YXIgX2ogPSAwOyBfaiA8IG47IF9qKyspIHtcbiAgICAgICAgb2xkW19qXSA9IFJbX2k4ICogbiArIF9qXTtcbiAgICAgICAgQVMgPSBBW19pOCAqIG4gKyBfal0gKyBTW19pOCAqIG4gKyBfal07XG4gICAgICAgIGlmIChBUyA+PSBtYXgpIHtcbiAgICAgICAgICBtYXgyID0gbWF4O1xuICAgICAgICAgIG1heCA9IEFTO1xuICAgICAgICAgIG1heEkgPSBfajtcbiAgICAgICAgfSBlbHNlIGlmIChBUyA+IG1heDIpIHtcbiAgICAgICAgICBtYXgyID0gQVM7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZvciAodmFyIF9qMiA9IDA7IF9qMiA8IG47IF9qMisrKSB7XG4gICAgICAgIFJbX2k4ICogbiArIF9qMl0gPSAoMSAtIG9wdHMuZGFtcGluZykgKiAoU1tfaTggKiBuICsgX2oyXSAtIG1heCkgKyBvcHRzLmRhbXBpbmcgKiBvbGRbX2oyXTtcbiAgICAgIH1cbiAgICAgIFJbX2k4ICogbiArIG1heEldID0gKDEgLSBvcHRzLmRhbXBpbmcpICogKFNbX2k4ICogbiArIG1heEldIC0gbWF4MikgKyBvcHRzLmRhbXBpbmcgKiBvbGRbbWF4SV07XG4gICAgfVxuXG4gICAgLy8gVXBkYXRlIEEgYXZhaWxhYmlsaXR5IG1hdHJpeFxuICAgIGZvciAodmFyIF9pOSA9IDA7IF9pOSA8IG47IF9pOSsrKSB7XG4gICAgICB2YXIgc3VtID0gMDtcbiAgICAgIGZvciAodmFyIF9qMyA9IDA7IF9qMyA8IG47IF9qMysrKSB7XG4gICAgICAgIG9sZFtfajNdID0gQVtfajMgKiBuICsgX2k5XTtcbiAgICAgICAgUnBbX2ozXSA9IE1hdGgubWF4KDAsIFJbX2ozICogbiArIF9pOV0pO1xuICAgICAgICBzdW0gKz0gUnBbX2ozXTtcbiAgICAgIH1cbiAgICAgIHN1bSAtPSBScFtfaTldO1xuICAgICAgUnBbX2k5XSA9IFJbX2k5ICogbiArIF9pOV07XG4gICAgICBzdW0gKz0gUnBbX2k5XTtcbiAgICAgIGZvciAodmFyIF9qNCA9IDA7IF9qNCA8IG47IF9qNCsrKSB7XG4gICAgICAgIEFbX2o0ICogbiArIF9pOV0gPSAoMSAtIG9wdHMuZGFtcGluZykgKiBNYXRoLm1pbigwLCBzdW0gLSBScFtfajRdKSArIG9wdHMuZGFtcGluZyAqIG9sZFtfajRdO1xuICAgICAgfVxuICAgICAgQVtfaTkgKiBuICsgX2k5XSA9ICgxIC0gb3B0cy5kYW1waW5nKSAqIChzdW0gLSBScFtfaTldKSArIG9wdHMuZGFtcGluZyAqIG9sZFtfaTldO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGZvciBjb252ZXJnZW5jZVxuICAgIHZhciBLID0gMDtcbiAgICBmb3IgKHZhciBfaTEwID0gMDsgX2kxMCA8IG47IF9pMTArKykge1xuICAgICAgdmFyIEUgPSBBW19pMTAgKiBuICsgX2kxMF0gKyBSW19pMTAgKiBuICsgX2kxMF0gPiAwID8gMSA6IDA7XG4gICAgICBlW2l0ZXIgJSBvcHRzLm1pbkl0ZXJhdGlvbnMgKiBuICsgX2kxMF0gPSBFO1xuICAgICAgSyArPSBFO1xuICAgIH1cbiAgICBpZiAoSyA+IDAgJiYgKGl0ZXIgPj0gb3B0cy5taW5JdGVyYXRpb25zIC0gMSB8fCBpdGVyID09IG9wdHMubWF4SXRlcmF0aW9ucyAtIDEpKSB7XG4gICAgICB2YXIgX3N1bSA9IDA7XG4gICAgICBmb3IgKHZhciBfaTExID0gMDsgX2kxMSA8IG47IF9pMTErKykge1xuICAgICAgICBzZVtfaTExXSA9IDA7XG4gICAgICAgIGZvciAodmFyIF9qNSA9IDA7IF9qNSA8IG9wdHMubWluSXRlcmF0aW9uczsgX2o1KyspIHtcbiAgICAgICAgICBzZVtfaTExXSArPSBlW19qNSAqIG4gKyBfaTExXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2VbX2kxMV0gPT09IDAgfHwgc2VbX2kxMV0gPT09IG9wdHMubWluSXRlcmF0aW9ucykge1xuICAgICAgICAgIF9zdW0rKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKF9zdW0gPT09IG4pIHtcbiAgICAgICAgLy8gdGhlbiB3ZSBoYXZlIGNvbnZlcmdlbmNlXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIElkZW50aWZ5IGV4ZW1wbGFycyAoY2x1c3RlciBjZW50ZXJzKVxuICB2YXIgZXhlbXBsYXJzSW5kaWNlcyA9IGZpbmRFeGVtcGxhcnMobiwgUiwgQSk7XG5cbiAgLy8gQXNzaWduIG5vZGVzIHRvIGNsdXN0ZXJzXG4gIHZhciBjbHVzdGVySW5kaWNlcyA9IGFzc2lnbihuLCBTLCBleGVtcGxhcnNJbmRpY2VzKTtcbiAgdmFyIGNsdXN0ZXJzID0ge307XG4gIGZvciAodmFyIGMgPSAwOyBjIDwgZXhlbXBsYXJzSW5kaWNlcy5sZW5ndGg7IGMrKykge1xuICAgIGNsdXN0ZXJzW2V4ZW1wbGFyc0luZGljZXNbY11dID0gW107XG4gIH1cbiAgZm9yICh2YXIgX2kxMiA9IDA7IF9pMTIgPCBub2Rlcy5sZW5ndGg7IF9pMTIrKykge1xuICAgIHZhciBwb3MgPSBpZDJwb3NpdGlvbltub2Rlc1tfaTEyXS5pZCgpXTtcbiAgICB2YXIgY2x1c3RlckluZGV4ID0gY2x1c3RlckluZGljZXNbcG9zXTtcbiAgICBpZiAoY2x1c3RlckluZGV4ICE9IG51bGwpIHtcbiAgICAgIC8vIHRoZSBub2RlIG1heSBoYXZlIG5vdCBiZWVuIGFzc2lnbmVkIGEgY2x1c3RlciBpZiBubyB2YWxpZCBhdHRyaWJ1dGVzIHdlcmUgc3BlY2lmaWVkXG4gICAgICBjbHVzdGVyc1tjbHVzdGVySW5kZXhdLnB1c2gobm9kZXNbX2kxMl0pO1xuICAgIH1cbiAgfVxuICB2YXIgcmV0Q2x1c3RlcnMgPSBuZXcgQXJyYXkoZXhlbXBsYXJzSW5kaWNlcy5sZW5ndGgpO1xuICBmb3IgKHZhciBfYyA9IDA7IF9jIDwgZXhlbXBsYXJzSW5kaWNlcy5sZW5ndGg7IF9jKyspIHtcbiAgICByZXRDbHVzdGVyc1tfY10gPSBjeS5jb2xsZWN0aW9uKGNsdXN0ZXJzW2V4ZW1wbGFyc0luZGljZXNbX2NdXSk7XG4gIH1cbiAgcmV0dXJuIHJldENsdXN0ZXJzO1xufTtcbnZhciBhZmZpbml0eVByb3BhZ2F0aW9uJDEgPSB7XG4gIGFmZmluaXR5UHJvcGFnYXRpb246IGFmZmluaXR5UHJvcGFnYXRpb24sXG4gIGFwOiBhZmZpbml0eVByb3BhZ2F0aW9uXG59O1xuXG52YXIgaGllcmhvbHplckRlZmF1bHRzID0gZGVmYXVsdHMkZyh7XG4gIHJvb3Q6IHVuZGVmaW5lZCxcbiAgZGlyZWN0ZWQ6IGZhbHNlXG59KTtcbnZhciBlbGVzZm4kayA9IHtcbiAgaGllcmhvbHplcjogZnVuY3Rpb24gaGllcmhvbHplcihvcHRpb25zKSB7XG4gICAgaWYgKCFwbGFpbk9iamVjdChvcHRpb25zKSkge1xuICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICBvcHRpb25zID0ge1xuICAgICAgICByb290OiBhcmdzWzBdLFxuICAgICAgICBkaXJlY3RlZDogYXJnc1sxXVxuICAgICAgfTtcbiAgICB9XG4gICAgdmFyIF9oaWVyaG9semVyRGVmYXVsdHMgPSBoaWVyaG9semVyRGVmYXVsdHMob3B0aW9ucyksXG4gICAgICByb290ID0gX2hpZXJob2x6ZXJEZWZhdWx0cy5yb290LFxuICAgICAgZGlyZWN0ZWQgPSBfaGllcmhvbHplckRlZmF1bHRzLmRpcmVjdGVkO1xuICAgIHZhciBlbGVzID0gdGhpcztcbiAgICB2YXIgZGZsYWcgPSBmYWxzZTtcbiAgICB2YXIgb2RkSW47XG4gICAgdmFyIG9kZE91dDtcbiAgICB2YXIgc3RhcnRWZXJ0ZXg7XG4gICAgaWYgKHJvb3QpIHN0YXJ0VmVydGV4ID0gc3RyaW5nKHJvb3QpID8gdGhpcy5maWx0ZXIocm9vdClbMF0uaWQoKSA6IHJvb3RbMF0uaWQoKTtcbiAgICB2YXIgbm9kZXMgPSB7fTtcbiAgICB2YXIgZWRnZXMgPSB7fTtcbiAgICBpZiAoZGlyZWN0ZWQpIHtcbiAgICAgIGVsZXMuZm9yRWFjaChmdW5jdGlvbiAoZWxlKSB7XG4gICAgICAgIHZhciBpZCA9IGVsZS5pZCgpO1xuICAgICAgICBpZiAoZWxlLmlzTm9kZSgpKSB7XG4gICAgICAgICAgdmFyIGluZCA9IGVsZS5pbmRlZ3JlZSh0cnVlKTtcbiAgICAgICAgICB2YXIgb3V0ZCA9IGVsZS5vdXRkZWdyZWUodHJ1ZSk7XG4gICAgICAgICAgdmFyIGQxID0gaW5kIC0gb3V0ZDtcbiAgICAgICAgICB2YXIgZDIgPSBvdXRkIC0gaW5kO1xuICAgICAgICAgIGlmIChkMSA9PSAxKSB7XG4gICAgICAgICAgICBpZiAob2RkSW4pIGRmbGFnID0gdHJ1ZTtlbHNlIG9kZEluID0gaWQ7XG4gICAgICAgICAgfSBlbHNlIGlmIChkMiA9PSAxKSB7XG4gICAgICAgICAgICBpZiAob2RkT3V0KSBkZmxhZyA9IHRydWU7ZWxzZSBvZGRPdXQgPSBpZDtcbiAgICAgICAgICB9IGVsc2UgaWYgKGQyID4gMSB8fCBkMSA+IDEpIHtcbiAgICAgICAgICAgIGRmbGFnID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbm9kZXNbaWRdID0gW107XG4gICAgICAgICAgZWxlLm91dGdvZXJzKCkuZm9yRWFjaChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgaWYgKGUuaXNFZGdlKCkpIG5vZGVzW2lkXS5wdXNoKGUuaWQoKSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZWRnZXNbaWRdID0gW3VuZGVmaW5lZCwgZWxlLnRhcmdldCgpLmlkKCldO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWxlcy5mb3JFYWNoKGZ1bmN0aW9uIChlbGUpIHtcbiAgICAgICAgdmFyIGlkID0gZWxlLmlkKCk7XG4gICAgICAgIGlmIChlbGUuaXNOb2RlKCkpIHtcbiAgICAgICAgICB2YXIgZCA9IGVsZS5kZWdyZWUodHJ1ZSk7XG4gICAgICAgICAgaWYgKGQgJSAyKSB7XG4gICAgICAgICAgICBpZiAoIW9kZEluKSBvZGRJbiA9IGlkO2Vsc2UgaWYgKCFvZGRPdXQpIG9kZE91dCA9IGlkO2Vsc2UgZGZsYWcgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBub2Rlc1tpZF0gPSBbXTtcbiAgICAgICAgICBlbGUuY29ubmVjdGVkRWRnZXMoKS5mb3JFYWNoKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gbm9kZXNbaWRdLnB1c2goZS5pZCgpKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlZGdlc1tpZF0gPSBbZWxlLnNvdXJjZSgpLmlkKCksIGVsZS50YXJnZXQoKS5pZCgpXTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIHZhciByZXN1bHQgPSB7XG4gICAgICBmb3VuZDogZmFsc2UsXG4gICAgICB0cmFpbDogdW5kZWZpbmVkXG4gICAgfTtcbiAgICBpZiAoZGZsYWcpIHJldHVybiByZXN1bHQ7ZWxzZSBpZiAob2RkT3V0ICYmIG9kZEluKSB7XG4gICAgICBpZiAoZGlyZWN0ZWQpIHtcbiAgICAgICAgaWYgKHN0YXJ0VmVydGV4ICYmIG9kZE91dCAhPSBzdGFydFZlcnRleCkge1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgc3RhcnRWZXJ0ZXggPSBvZGRPdXQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoc3RhcnRWZXJ0ZXggJiYgb2RkT3V0ICE9IHN0YXJ0VmVydGV4ICYmIG9kZEluICE9IHN0YXJ0VmVydGV4KSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSBlbHNlIGlmICghc3RhcnRWZXJ0ZXgpIHtcbiAgICAgICAgICBzdGFydFZlcnRleCA9IG9kZE91dDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIXN0YXJ0VmVydGV4KSBzdGFydFZlcnRleCA9IGVsZXNbMF0uaWQoKTtcbiAgICB9XG4gICAgdmFyIHdhbGsgPSBmdW5jdGlvbiB3YWxrKHYpIHtcbiAgICAgIHZhciBjdXJyZW50Tm9kZSA9IHY7XG4gICAgICB2YXIgc3VidG91ciA9IFt2XTtcbiAgICAgIHZhciBhZGosIGFkalRhaWwsIGFkakhlYWQ7XG4gICAgICB3aGlsZSAobm9kZXNbY3VycmVudE5vZGVdLmxlbmd0aCkge1xuICAgICAgICBhZGogPSBub2Rlc1tjdXJyZW50Tm9kZV0uc2hpZnQoKTtcbiAgICAgICAgYWRqVGFpbCA9IGVkZ2VzW2Fkal1bMF07XG4gICAgICAgIGFkakhlYWQgPSBlZGdlc1thZGpdWzFdO1xuICAgICAgICBpZiAoY3VycmVudE5vZGUgIT0gYWRqSGVhZCkge1xuICAgICAgICAgIG5vZGVzW2FkakhlYWRdID0gbm9kZXNbYWRqSGVhZF0uZmlsdGVyKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gZSAhPSBhZGo7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgY3VycmVudE5vZGUgPSBhZGpIZWFkO1xuICAgICAgICB9IGVsc2UgaWYgKCFkaXJlY3RlZCAmJiBjdXJyZW50Tm9kZSAhPSBhZGpUYWlsKSB7XG4gICAgICAgICAgbm9kZXNbYWRqVGFpbF0gPSBub2Rlc1thZGpUYWlsXS5maWx0ZXIoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBlICE9IGFkajtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBjdXJyZW50Tm9kZSA9IGFkalRhaWw7XG4gICAgICAgIH1cbiAgICAgICAgc3VidG91ci51bnNoaWZ0KGFkaik7XG4gICAgICAgIHN1YnRvdXIudW5zaGlmdChjdXJyZW50Tm9kZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc3VidG91cjtcbiAgICB9O1xuICAgIHZhciB0cmFpbCA9IFtdO1xuICAgIHZhciBzdWJ0b3VyID0gW107XG4gICAgc3VidG91ciA9IHdhbGsoc3RhcnRWZXJ0ZXgpO1xuICAgIHdoaWxlIChzdWJ0b3VyLmxlbmd0aCAhPSAxKSB7XG4gICAgICBpZiAobm9kZXNbc3VidG91clswXV0ubGVuZ3RoID09IDApIHtcbiAgICAgICAgdHJhaWwudW5zaGlmdChlbGVzLmdldEVsZW1lbnRCeUlkKHN1YnRvdXIuc2hpZnQoKSkpO1xuICAgICAgICB0cmFpbC51bnNoaWZ0KGVsZXMuZ2V0RWxlbWVudEJ5SWQoc3VidG91ci5zaGlmdCgpKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdWJ0b3VyID0gd2FsayhzdWJ0b3VyLnNoaWZ0KCkpLmNvbmNhdChzdWJ0b3VyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdHJhaWwudW5zaGlmdChlbGVzLmdldEVsZW1lbnRCeUlkKHN1YnRvdXIuc2hpZnQoKSkpOyAvLyBmaW5hbCBub2RlXG5cbiAgICBmb3IgKHZhciBkIGluIG5vZGVzKSB7XG4gICAgICBpZiAobm9kZXNbZF0ubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgfVxuICAgIHJlc3VsdC5mb3VuZCA9IHRydWU7XG4gICAgcmVzdWx0LnRyYWlsID0gdGhpcy5zcGF3bih0cmFpbCwgdHJ1ZSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufTtcblxudmFyIGhvcGNyb2Z0VGFyamFuQmljb25uZWN0ZWQgPSBmdW5jdGlvbiBob3Bjcm9mdFRhcmphbkJpY29ubmVjdGVkKCkge1xuICB2YXIgZWxlcyA9IHRoaXM7XG4gIHZhciBub2RlcyA9IHt9O1xuICB2YXIgaWQgPSAwO1xuICB2YXIgZWRnZUNvdW50ID0gMDtcbiAgdmFyIGNvbXBvbmVudHMgPSBbXTtcbiAgdmFyIHN0YWNrID0gW107XG4gIHZhciB2aXNpdGVkRWRnZXMgPSB7fTtcbiAgdmFyIGJ1aWxkQ29tcG9uZW50ID0gZnVuY3Rpb24gYnVpbGRDb21wb25lbnQoeCwgeSkge1xuICAgIHZhciBpID0gc3RhY2subGVuZ3RoIC0gMTtcbiAgICB2YXIgY3V0c2V0ID0gW107XG4gICAgdmFyIGNvbXBvbmVudCA9IGVsZXMuc3Bhd24oKTtcbiAgICB3aGlsZSAoc3RhY2tbaV0ueCAhPSB4IHx8IHN0YWNrW2ldLnkgIT0geSkge1xuICAgICAgY3V0c2V0LnB1c2goc3RhY2sucG9wKCkuZWRnZSk7XG4gICAgICBpLS07XG4gICAgfVxuICAgIGN1dHNldC5wdXNoKHN0YWNrLnBvcCgpLmVkZ2UpO1xuICAgIGN1dHNldC5mb3JFYWNoKGZ1bmN0aW9uIChlZGdlKSB7XG4gICAgICB2YXIgY29ubmVjdGVkTm9kZXMgPSBlZGdlLmNvbm5lY3RlZE5vZGVzKCkuaW50ZXJzZWN0aW9uKGVsZXMpO1xuICAgICAgY29tcG9uZW50Lm1lcmdlKGVkZ2UpO1xuICAgICAgY29ubmVjdGVkTm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICB2YXIgbm9kZUlkID0gbm9kZS5pZCgpO1xuICAgICAgICB2YXIgY29ubmVjdGVkRWRnZXMgPSBub2RlLmNvbm5lY3RlZEVkZ2VzKCkuaW50ZXJzZWN0aW9uKGVsZXMpO1xuICAgICAgICBjb21wb25lbnQubWVyZ2Uobm9kZSk7XG4gICAgICAgIGlmICghbm9kZXNbbm9kZUlkXS5jdXRWZXJ0ZXgpIHtcbiAgICAgICAgICBjb21wb25lbnQubWVyZ2UoY29ubmVjdGVkRWRnZXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbXBvbmVudC5tZXJnZShjb25uZWN0ZWRFZGdlcy5maWx0ZXIoZnVuY3Rpb24gKGVkZ2UpIHtcbiAgICAgICAgICAgIHJldHVybiBlZGdlLmlzTG9vcCgpO1xuICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgY29tcG9uZW50cy5wdXNoKGNvbXBvbmVudCk7XG4gIH07XG4gIHZhciBiaWNvbm5lY3RlZFNlYXJjaCA9IGZ1bmN0aW9uIGJpY29ubmVjdGVkU2VhcmNoKHJvb3QsIGN1cnJlbnROb2RlLCBwYXJlbnQpIHtcbiAgICBpZiAocm9vdCA9PT0gcGFyZW50KSBlZGdlQ291bnQgKz0gMTtcbiAgICBub2Rlc1tjdXJyZW50Tm9kZV0gPSB7XG4gICAgICBpZDogaWQsXG4gICAgICBsb3c6IGlkKyssXG4gICAgICBjdXRWZXJ0ZXg6IGZhbHNlXG4gICAgfTtcbiAgICB2YXIgZWRnZXMgPSBlbGVzLmdldEVsZW1lbnRCeUlkKGN1cnJlbnROb2RlKS5jb25uZWN0ZWRFZGdlcygpLmludGVyc2VjdGlvbihlbGVzKTtcbiAgICBpZiAoZWRnZXMuc2l6ZSgpID09PSAwKSB7XG4gICAgICBjb21wb25lbnRzLnB1c2goZWxlcy5zcGF3bihlbGVzLmdldEVsZW1lbnRCeUlkKGN1cnJlbnROb2RlKSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgc291cmNlSWQsIHRhcmdldElkLCBvdGhlck5vZGVJZCwgZWRnZUlkO1xuICAgICAgZWRnZXMuZm9yRWFjaChmdW5jdGlvbiAoZWRnZSkge1xuICAgICAgICBzb3VyY2VJZCA9IGVkZ2Uuc291cmNlKCkuaWQoKTtcbiAgICAgICAgdGFyZ2V0SWQgPSBlZGdlLnRhcmdldCgpLmlkKCk7XG4gICAgICAgIG90aGVyTm9kZUlkID0gc291cmNlSWQgPT09IGN1cnJlbnROb2RlID8gdGFyZ2V0SWQgOiBzb3VyY2VJZDtcbiAgICAgICAgaWYgKG90aGVyTm9kZUlkICE9PSBwYXJlbnQpIHtcbiAgICAgICAgICBlZGdlSWQgPSBlZGdlLmlkKCk7XG4gICAgICAgICAgaWYgKCF2aXNpdGVkRWRnZXNbZWRnZUlkXSkge1xuICAgICAgICAgICAgdmlzaXRlZEVkZ2VzW2VkZ2VJZF0gPSB0cnVlO1xuICAgICAgICAgICAgc3RhY2sucHVzaCh7XG4gICAgICAgICAgICAgIHg6IGN1cnJlbnROb2RlLFxuICAgICAgICAgICAgICB5OiBvdGhlck5vZGVJZCxcbiAgICAgICAgICAgICAgZWRnZTogZWRnZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghKG90aGVyTm9kZUlkIGluIG5vZGVzKSkge1xuICAgICAgICAgICAgYmljb25uZWN0ZWRTZWFyY2gocm9vdCwgb3RoZXJOb2RlSWQsIGN1cnJlbnROb2RlKTtcbiAgICAgICAgICAgIG5vZGVzW2N1cnJlbnROb2RlXS5sb3cgPSBNYXRoLm1pbihub2Rlc1tjdXJyZW50Tm9kZV0ubG93LCBub2Rlc1tvdGhlck5vZGVJZF0ubG93KTtcbiAgICAgICAgICAgIGlmIChub2Rlc1tjdXJyZW50Tm9kZV0uaWQgPD0gbm9kZXNbb3RoZXJOb2RlSWRdLmxvdykge1xuICAgICAgICAgICAgICBub2Rlc1tjdXJyZW50Tm9kZV0uY3V0VmVydGV4ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgYnVpbGRDb21wb25lbnQoY3VycmVudE5vZGUsIG90aGVyTm9kZUlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbm9kZXNbY3VycmVudE5vZGVdLmxvdyA9IE1hdGgubWluKG5vZGVzW2N1cnJlbnROb2RlXS5sb3csIG5vZGVzW290aGVyTm9kZUlkXS5pZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG4gIGVsZXMuZm9yRWFjaChmdW5jdGlvbiAoZWxlKSB7XG4gICAgaWYgKGVsZS5pc05vZGUoKSkge1xuICAgICAgdmFyIG5vZGVJZCA9IGVsZS5pZCgpO1xuICAgICAgaWYgKCEobm9kZUlkIGluIG5vZGVzKSkge1xuICAgICAgICBlZGdlQ291bnQgPSAwO1xuICAgICAgICBiaWNvbm5lY3RlZFNlYXJjaChub2RlSWQsIG5vZGVJZCk7XG4gICAgICAgIG5vZGVzW25vZGVJZF0uY3V0VmVydGV4ID0gZWRnZUNvdW50ID4gMTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICB2YXIgY3V0VmVydGljZXMgPSBPYmplY3Qua2V5cyhub2RlcykuZmlsdGVyKGZ1bmN0aW9uIChpZCkge1xuICAgIHJldHVybiBub2Rlc1tpZF0uY3V0VmVydGV4O1xuICB9KS5tYXAoZnVuY3Rpb24gKGlkKSB7XG4gICAgcmV0dXJuIGVsZXMuZ2V0RWxlbWVudEJ5SWQoaWQpO1xuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBjdXQ6IGVsZXMuc3Bhd24oY3V0VmVydGljZXMpLFxuICAgIGNvbXBvbmVudHM6IGNvbXBvbmVudHNcbiAgfTtcbn07XG52YXIgaG9wY3JvZnRUYXJqYW5CaWNvbm5lY3RlZCQxID0ge1xuICBob3Bjcm9mdFRhcmphbkJpY29ubmVjdGVkOiBob3Bjcm9mdFRhcmphbkJpY29ubmVjdGVkLFxuICBodGJjOiBob3Bjcm9mdFRhcmphbkJpY29ubmVjdGVkLFxuICBodGI6IGhvcGNyb2Z0VGFyamFuQmljb25uZWN0ZWQsXG4gIGhvcGNyb2Z0VGFyamFuQmljb25uZWN0ZWRDb21wb25lbnRzOiBob3Bjcm9mdFRhcmphbkJpY29ubmVjdGVkXG59O1xuXG52YXIgdGFyamFuU3Ryb25nbHlDb25uZWN0ZWQgPSBmdW5jdGlvbiB0YXJqYW5TdHJvbmdseUNvbm5lY3RlZCgpIHtcbiAgdmFyIGVsZXMgPSB0aGlzO1xuICB2YXIgbm9kZXMgPSB7fTtcbiAgdmFyIGluZGV4ID0gMDtcbiAgdmFyIGNvbXBvbmVudHMgPSBbXTtcbiAgdmFyIHN0YWNrID0gW107XG4gIHZhciBjdXQgPSBlbGVzLnNwYXduKGVsZXMpO1xuICB2YXIgc3Ryb25nbHlDb25uZWN0ZWRTZWFyY2ggPSBmdW5jdGlvbiBzdHJvbmdseUNvbm5lY3RlZFNlYXJjaChzb3VyY2VOb2RlSWQpIHtcbiAgICBzdGFjay5wdXNoKHNvdXJjZU5vZGVJZCk7XG4gICAgbm9kZXNbc291cmNlTm9kZUlkXSA9IHtcbiAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgIGxvdzogaW5kZXgrKyxcbiAgICAgIGV4cGxvcmVkOiBmYWxzZVxuICAgIH07XG4gICAgdmFyIGNvbm5lY3RlZEVkZ2VzID0gZWxlcy5nZXRFbGVtZW50QnlJZChzb3VyY2VOb2RlSWQpLmNvbm5lY3RlZEVkZ2VzKCkuaW50ZXJzZWN0aW9uKGVsZXMpO1xuICAgIGNvbm5lY3RlZEVkZ2VzLmZvckVhY2goZnVuY3Rpb24gKGVkZ2UpIHtcbiAgICAgIHZhciB0YXJnZXROb2RlSWQgPSBlZGdlLnRhcmdldCgpLmlkKCk7XG4gICAgICBpZiAodGFyZ2V0Tm9kZUlkICE9PSBzb3VyY2VOb2RlSWQpIHtcbiAgICAgICAgaWYgKCEodGFyZ2V0Tm9kZUlkIGluIG5vZGVzKSkge1xuICAgICAgICAgIHN0cm9uZ2x5Q29ubmVjdGVkU2VhcmNoKHRhcmdldE5vZGVJZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFub2Rlc1t0YXJnZXROb2RlSWRdLmV4cGxvcmVkKSB7XG4gICAgICAgICAgbm9kZXNbc291cmNlTm9kZUlkXS5sb3cgPSBNYXRoLm1pbihub2Rlc1tzb3VyY2VOb2RlSWRdLmxvdywgbm9kZXNbdGFyZ2V0Tm9kZUlkXS5sb3cpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKG5vZGVzW3NvdXJjZU5vZGVJZF0uaW5kZXggPT09IG5vZGVzW3NvdXJjZU5vZGVJZF0ubG93KSB7XG4gICAgICB2YXIgY29tcG9uZW50Tm9kZXMgPSBlbGVzLnNwYXduKCk7XG4gICAgICBmb3IgKDs7KSB7XG4gICAgICAgIHZhciBub2RlSWQgPSBzdGFjay5wb3AoKTtcbiAgICAgICAgY29tcG9uZW50Tm9kZXMubWVyZ2UoZWxlcy5nZXRFbGVtZW50QnlJZChub2RlSWQpKTtcbiAgICAgICAgbm9kZXNbbm9kZUlkXS5sb3cgPSBub2Rlc1tzb3VyY2VOb2RlSWRdLmluZGV4O1xuICAgICAgICBub2Rlc1tub2RlSWRdLmV4cGxvcmVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKG5vZGVJZCA9PT0gc291cmNlTm9kZUlkKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBjb21wb25lbnRFZGdlcyA9IGNvbXBvbmVudE5vZGVzLmVkZ2VzV2l0aChjb21wb25lbnROb2Rlcyk7XG4gICAgICB2YXIgY29tcG9uZW50ID0gY29tcG9uZW50Tm9kZXMubWVyZ2UoY29tcG9uZW50RWRnZXMpO1xuICAgICAgY29tcG9uZW50cy5wdXNoKGNvbXBvbmVudCk7XG4gICAgICBjdXQgPSBjdXQuZGlmZmVyZW5jZShjb21wb25lbnQpO1xuICAgIH1cbiAgfTtcbiAgZWxlcy5mb3JFYWNoKGZ1bmN0aW9uIChlbGUpIHtcbiAgICBpZiAoZWxlLmlzTm9kZSgpKSB7XG4gICAgICB2YXIgbm9kZUlkID0gZWxlLmlkKCk7XG4gICAgICBpZiAoIShub2RlSWQgaW4gbm9kZXMpKSB7XG4gICAgICAgIHN0cm9uZ2x5Q29ubmVjdGVkU2VhcmNoKG5vZGVJZCk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBjdXQ6IGN1dCxcbiAgICBjb21wb25lbnRzOiBjb21wb25lbnRzXG4gIH07XG59O1xudmFyIHRhcmphblN0cm9uZ2x5Q29ubmVjdGVkJDEgPSB7XG4gIHRhcmphblN0cm9uZ2x5Q29ubmVjdGVkOiB0YXJqYW5TdHJvbmdseUNvbm5lY3RlZCxcbiAgdHNjOiB0YXJqYW5TdHJvbmdseUNvbm5lY3RlZCxcbiAgdHNjYzogdGFyamFuU3Ryb25nbHlDb25uZWN0ZWQsXG4gIHRhcmphblN0cm9uZ2x5Q29ubmVjdGVkQ29tcG9uZW50czogdGFyamFuU3Ryb25nbHlDb25uZWN0ZWRcbn07XG5cbnZhciBlbGVzZm4kaiA9IHt9O1xuW2VsZXNmbiR2LCBlbGVzZm4kdSwgZWxlc2ZuJHQsIGVsZXNmbiRzLCBlbGVzZm4kciwgZWxlc2ZuJHEsIGVsZXNmbiRwLCBlbGVzZm4kbywgZWxlc2ZuJG4sIGVsZXNmbiRtLCBlbGVzZm4kbCwgbWFya292Q2x1c3RlcmluZyQxLCBrQ2x1c3RlcmluZywgaGllcmFyY2hpY2FsQ2x1c3RlcmluZyQxLCBhZmZpbml0eVByb3BhZ2F0aW9uJDEsIGVsZXNmbiRrLCBob3Bjcm9mdFRhcmphbkJpY29ubmVjdGVkJDEsIHRhcmphblN0cm9uZ2x5Q29ubmVjdGVkJDFdLmZvckVhY2goZnVuY3Rpb24gKHByb3BzKSB7XG4gIGV4dGVuZChlbGVzZm4kaiwgcHJvcHMpO1xufSk7XG5cbi8qIVxuRW1iZWRkYWJsZSBNaW5pbXVtIFN0cmljdGx5LUNvbXBsaWFudCBQcm9taXNlcy9BKyAxLjEuMSBUaGVuYWJsZVxuQ29weXJpZ2h0IChjKSAyMDEzLTIwMTQgUmFsZiBTLiBFbmdlbHNjaGFsbCAoaHR0cDovL2VuZ2Vsc2NoYWxsLmNvbSlcbkxpY2Vuc2VkIHVuZGVyIFRoZSBNSVQgTGljZW5zZSAoaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVClcbiovXG5cbi8qICBwcm9taXNlIHN0YXRlcyBbUHJvbWlzZXMvQSsgMi4xXSAgKi9cbnZhciBTVEFURV9QRU5ESU5HID0gMDsgLyogIFtQcm9taXNlcy9BKyAyLjEuMV0gICovXG52YXIgU1RBVEVfRlVMRklMTEVEID0gMTsgLyogIFtQcm9taXNlcy9BKyAyLjEuMl0gICovXG52YXIgU1RBVEVfUkVKRUNURUQgPSAyOyAvKiAgW1Byb21pc2VzL0ErIDIuMS4zXSAgKi9cblxuLyogIHByb21pc2Ugb2JqZWN0IGNvbnN0cnVjdG9yICAqL1xudmFyIGFwaSA9IGZ1bmN0aW9uIGFwaShleGVjdXRvcikge1xuICAvKiAgb3B0aW9uYWxseSBzdXBwb3J0IG5vbi1jb25zdHJ1Y3Rvci9wbGFpbi1mdW5jdGlvbiBjYWxsICAqL1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgYXBpKSkgcmV0dXJuIG5ldyBhcGkoZXhlY3V0b3IpO1xuXG4gIC8qICBpbml0aWFsaXplIG9iamVjdCAgKi9cbiAgdGhpcy5pZCA9ICdUaGVuYWJsZS8xLjAuNyc7XG4gIHRoaXMuc3RhdGUgPSBTVEFURV9QRU5ESU5HOyAvKiAgaW5pdGlhbCBzdGF0ZSAgKi9cbiAgdGhpcy5mdWxmaWxsVmFsdWUgPSB1bmRlZmluZWQ7IC8qICBpbml0aWFsIHZhbHVlICAqLyAvKiAgW1Byb21pc2VzL0ErIDEuMywgMi4xLjIuMl0gICovXG4gIHRoaXMucmVqZWN0UmVhc29uID0gdW5kZWZpbmVkOyAvKiAgaW5pdGlhbCByZWFzb24gKi8gLyogIFtQcm9taXNlcy9BKyAxLjUsIDIuMS4zLjJdICAqL1xuICB0aGlzLm9uRnVsZmlsbGVkID0gW107IC8qICBpbml0aWFsIGhhbmRsZXJzICAqL1xuICB0aGlzLm9uUmVqZWN0ZWQgPSBbXTsgLyogIGluaXRpYWwgaGFuZGxlcnMgICovXG5cbiAgLyogIHByb3ZpZGUgb3B0aW9uYWwgaW5mb3JtYXRpb24taGlkaW5nIHByb3h5ICAqL1xuICB0aGlzLnByb3h5ID0ge1xuICAgIHRoZW46IHRoaXMudGhlbi5iaW5kKHRoaXMpXG4gIH07XG5cbiAgLyogIHN1cHBvcnQgb3B0aW9uYWwgZXhlY3V0b3IgZnVuY3Rpb24gICovXG4gIGlmICh0eXBlb2YgZXhlY3V0b3IgPT09ICdmdW5jdGlvbicpIGV4ZWN1dG9yLmNhbGwodGhpcywgdGhpcy5mdWxmaWxsLmJpbmQodGhpcyksIHRoaXMucmVqZWN0LmJpbmQodGhpcykpO1xufTtcblxuLyogIHByb21pc2UgQVBJIG1ldGhvZHMgICovXG5hcGkucHJvdG90eXBlID0ge1xuICAvKiAgcHJvbWlzZSByZXNvbHZpbmcgbWV0aG9kcyAgKi9cbiAgZnVsZmlsbDogZnVuY3Rpb24gZnVsZmlsbCh2YWx1ZSkge1xuICAgIHJldHVybiBkZWxpdmVyKHRoaXMsIFNUQVRFX0ZVTEZJTExFRCwgJ2Z1bGZpbGxWYWx1ZScsIHZhbHVlKTtcbiAgfSxcbiAgcmVqZWN0OiBmdW5jdGlvbiByZWplY3QodmFsdWUpIHtcbiAgICByZXR1cm4gZGVsaXZlcih0aGlzLCBTVEFURV9SRUpFQ1RFRCwgJ3JlamVjdFJlYXNvbicsIHZhbHVlKTtcbiAgfSxcbiAgLyogIFwiVGhlIHRoZW4gTWV0aG9kXCIgW1Byb21pc2VzL0ErIDEuMSwgMS4yLCAyLjJdICAqL1xuICB0aGVuOiBmdW5jdGlvbiB0aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKSB7XG4gICAgdmFyIGN1cnIgPSB0aGlzO1xuICAgIHZhciBuZXh0ID0gbmV3IGFwaSgpOyAvKiAgW1Byb21pc2VzL0ErIDIuMi43XSAgKi9cbiAgICBjdXJyLm9uRnVsZmlsbGVkLnB1c2gocmVzb2x2ZXIob25GdWxmaWxsZWQsIG5leHQsICdmdWxmaWxsJykpOyAvKiAgW1Byb21pc2VzL0ErIDIuMi4yLzIuMi42XSAgKi9cbiAgICBjdXJyLm9uUmVqZWN0ZWQucHVzaChyZXNvbHZlcihvblJlamVjdGVkLCBuZXh0LCAncmVqZWN0JykpOyAvKiAgW1Byb21pc2VzL0ErIDIuMi4zLzIuMi42XSAgKi9cbiAgICBleGVjdXRlKGN1cnIpO1xuICAgIHJldHVybiBuZXh0LnByb3h5OyAvKiAgW1Byb21pc2VzL0ErIDIuMi43LCAzLjNdICAqL1xuICB9XG59O1xuXG4vKiAgZGVsaXZlciBhbiBhY3Rpb24gICovXG52YXIgZGVsaXZlciA9IGZ1bmN0aW9uIGRlbGl2ZXIoY3Vyciwgc3RhdGUsIG5hbWUsIHZhbHVlKSB7XG4gIGlmIChjdXJyLnN0YXRlID09PSBTVEFURV9QRU5ESU5HKSB7XG4gICAgY3Vyci5zdGF0ZSA9IHN0YXRlOyAvKiAgW1Byb21pc2VzL0ErIDIuMS4yLjEsIDIuMS4zLjFdICAqL1xuICAgIGN1cnJbbmFtZV0gPSB2YWx1ZTsgLyogIFtQcm9taXNlcy9BKyAyLjEuMi4yLCAyLjEuMy4yXSAgKi9cbiAgICBleGVjdXRlKGN1cnIpO1xuICB9XG4gIHJldHVybiBjdXJyO1xufTtcblxuLyogIGV4ZWN1dGUgYWxsIGhhbmRsZXJzICAqL1xudmFyIGV4ZWN1dGUgPSBmdW5jdGlvbiBleGVjdXRlKGN1cnIpIHtcbiAgaWYgKGN1cnIuc3RhdGUgPT09IFNUQVRFX0ZVTEZJTExFRCkgZXhlY3V0ZV9oYW5kbGVycyhjdXJyLCAnb25GdWxmaWxsZWQnLCBjdXJyLmZ1bGZpbGxWYWx1ZSk7ZWxzZSBpZiAoY3Vyci5zdGF0ZSA9PT0gU1RBVEVfUkVKRUNURUQpIGV4ZWN1dGVfaGFuZGxlcnMoY3VyciwgJ29uUmVqZWN0ZWQnLCBjdXJyLnJlamVjdFJlYXNvbik7XG59O1xuXG4vKiAgZXhlY3V0ZSBwYXJ0aWN1bGFyIHNldCBvZiBoYW5kbGVycyAgKi9cbnZhciBleGVjdXRlX2hhbmRsZXJzID0gZnVuY3Rpb24gZXhlY3V0ZV9oYW5kbGVycyhjdXJyLCBuYW1lLCB2YWx1ZSkge1xuICAvKiBnbG9iYWwgc2V0SW1tZWRpYXRlOiB0cnVlICovXG4gIC8qIGdsb2JhbCBzZXRUaW1lb3V0OiB0cnVlICovXG5cbiAgLyogIHNob3J0LWNpcmN1aXQgcHJvY2Vzc2luZyAgKi9cbiAgaWYgKGN1cnJbbmFtZV0ubGVuZ3RoID09PSAwKSByZXR1cm47XG5cbiAgLyogIGl0ZXJhdGUgb3ZlciBhbGwgaGFuZGxlcnMsIGV4YWN0bHkgb25jZSAgKi9cbiAgdmFyIGhhbmRsZXJzID0gY3VycltuYW1lXTtcbiAgY3VycltuYW1lXSA9IFtdOyAvKiAgW1Byb21pc2VzL0ErIDIuMi4yLjMsIDIuMi4zLjNdICAqL1xuICB2YXIgZnVuYyA9IGZ1bmN0aW9uIGZ1bmMoKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBoYW5kbGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgaGFuZGxlcnNbaV0odmFsdWUpO1xuICAgIH0gLyogIFtQcm9taXNlcy9BKyAyLjIuNV0gICovXG4gIH07XG5cbiAgLyogIGV4ZWN1dGUgcHJvY2VkdXJlIGFzeW5jaHJvbm91c2x5ICAqLyAvKiAgW1Byb21pc2VzL0ErIDIuMi40LCAzLjFdICAqL1xuICBpZiAodHlwZW9mIHNldEltbWVkaWF0ZSA9PT0gJ2Z1bmN0aW9uJykgc2V0SW1tZWRpYXRlKGZ1bmMpO2Vsc2Ugc2V0VGltZW91dChmdW5jLCAwKTtcbn07XG5cbi8qICBnZW5lcmF0ZSBhIHJlc29sdmVyIGZ1bmN0aW9uICAqL1xudmFyIHJlc29sdmVyID0gZnVuY3Rpb24gcmVzb2x2ZXIoY2IsIG5leHQsIG1ldGhvZCkge1xuICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiBjYiAhPT0gJ2Z1bmN0aW9uJykgLyogIFtQcm9taXNlcy9BKyAyLjIuMSwgMi4yLjcuMywgMi4yLjcuNF0gICovXG4gICAgICBuZXh0W21ldGhvZF0uY2FsbChuZXh0LCB2YWx1ZSk7IC8qICBbUHJvbWlzZXMvQSsgMi4yLjcuMywgMi4yLjcuNF0gICovZWxzZSB7XG4gICAgICB2YXIgcmVzdWx0O1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmVzdWx0ID0gY2IodmFsdWUpO1xuICAgICAgfSAvKiAgW1Byb21pc2VzL0ErIDIuMi4yLjEsIDIuMi4zLjEsIDIuMi41LCAzLjJdICAqLyBjYXRjaCAoZSkge1xuICAgICAgICBuZXh0LnJlamVjdChlKTsgLyogIFtQcm9taXNlcy9BKyAyLjIuNy4yXSAgKi9cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcmVzb2x2ZShuZXh0LCByZXN1bHQpOyAvKiAgW1Byb21pc2VzL0ErIDIuMi43LjFdICAqL1xuICAgIH1cbiAgfTtcbn07XG5cbi8qICBcIlByb21pc2UgUmVzb2x1dGlvbiBQcm9jZWR1cmVcIiAgKi8gLyogIFtQcm9taXNlcy9BKyAyLjNdICAqL1xudmFyIHJlc29sdmUgPSBmdW5jdGlvbiByZXNvbHZlKHByb21pc2UsIHgpIHtcbiAgLyogIHNhbml0eSBjaGVjayBhcmd1bWVudHMgICovIC8qICBbUHJvbWlzZXMvQSsgMi4zLjFdICAqL1xuICBpZiAocHJvbWlzZSA9PT0geCB8fCBwcm9taXNlLnByb3h5ID09PSB4KSB7XG4gICAgcHJvbWlzZS5yZWplY3QobmV3IFR5cGVFcnJvcignY2Fubm90IHJlc29sdmUgcHJvbWlzZSB3aXRoIGl0c2VsZicpKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvKiAgc3VyZ2ljYWxseSBjaGVjayBmb3IgYSBcInRoZW5cIiBtZXRob2RcbiAgICAobWFpbmx5IHRvIGp1c3QgY2FsbCB0aGUgXCJnZXR0ZXJcIiBvZiBcInRoZW5cIiBvbmx5IG9uY2UpICAqL1xuICB2YXIgdGhlbjtcbiAgaWYgKF90eXBlb2YoeCkgPT09ICdvYmplY3QnICYmIHggIT09IG51bGwgfHwgdHlwZW9mIHggPT09ICdmdW5jdGlvbicpIHtcbiAgICB0cnkge1xuICAgICAgdGhlbiA9IHgudGhlbjtcbiAgICB9IC8qICBbUHJvbWlzZXMvQSsgMi4zLjMuMSwgMy41XSAgKi8gY2F0Y2ggKGUpIHtcbiAgICAgIHByb21pc2UucmVqZWN0KGUpOyAvKiAgW1Byb21pc2VzL0ErIDIuMy4zLjJdICAqL1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuXG4gIC8qICBoYW5kbGUgb3duIFRoZW5hYmxlcyAgICBbUHJvbWlzZXMvQSsgMi4zLjJdXG4gICAgYW5kIHNpbWlsYXIgXCJ0aGVuYWJsZXNcIiBbUHJvbWlzZXMvQSsgMi4zLjNdICAqL1xuICBpZiAodHlwZW9mIHRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgcmVzb2x2ZWQgPSBmYWxzZTtcbiAgICB0cnkge1xuICAgICAgLyogIGNhbGwgcmV0cmlldmVkIFwidGhlblwiIG1ldGhvZCAqLyAvKiAgW1Byb21pc2VzL0ErIDIuMy4zLjNdICAqL1xuICAgICAgdGhlbi5jYWxsKHgsIC8qICByZXNvbHZlUHJvbWlzZSAgKi8gLyogIFtQcm9taXNlcy9BKyAyLjMuMy4zLjFdICAqL1xuICAgICAgZnVuY3Rpb24gKHkpIHtcbiAgICAgICAgaWYgKHJlc29sdmVkKSByZXR1cm47XG4gICAgICAgIHJlc29sdmVkID0gdHJ1ZTsgLyogIFtQcm9taXNlcy9BKyAyLjMuMy4zLjNdICAqL1xuICAgICAgICBpZiAoeSA9PT0geCkgLyogIFtQcm9taXNlcy9BKyAzLjZdICAqL1xuICAgICAgICAgIHByb21pc2UucmVqZWN0KG5ldyBUeXBlRXJyb3IoJ2NpcmN1bGFyIHRoZW5hYmxlIGNoYWluJykpO2Vsc2UgcmVzb2x2ZShwcm9taXNlLCB5KTtcbiAgICAgIH0sIC8qICByZWplY3RQcm9taXNlICAqLyAvKiAgW1Byb21pc2VzL0ErIDIuMy4zLjMuMl0gICovXG4gICAgICBmdW5jdGlvbiAocikge1xuICAgICAgICBpZiAocmVzb2x2ZWQpIHJldHVybjtcbiAgICAgICAgcmVzb2x2ZWQgPSB0cnVlOyAvKiAgW1Byb21pc2VzL0ErIDIuMy4zLjMuM10gICovXG4gICAgICAgIHByb21pc2UucmVqZWN0KHIpO1xuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWYgKCFyZXNvbHZlZCkgLyogIFtQcm9taXNlcy9BKyAyLjMuMy4zLjNdICAqL1xuICAgICAgICBwcm9taXNlLnJlamVjdChlKTsgLyogIFtQcm9taXNlcy9BKyAyLjMuMy4zLjRdICAqL1xuICAgIH1cblxuICAgIHJldHVybjtcbiAgfVxuXG4gIC8qICBoYW5kbGUgb3RoZXIgdmFsdWVzICAqL1xuICBwcm9taXNlLmZ1bGZpbGwoeCk7IC8qICBbUHJvbWlzZXMvQSsgMi4zLjQsIDIuMy4zLjRdICAqL1xufTtcblxuLy8gc28gd2UgYWx3YXlzIGhhdmUgUHJvbWlzZS5hbGwoKVxuYXBpLmFsbCA9IGZ1bmN0aW9uIChwcykge1xuICByZXR1cm4gbmV3IGFwaShmdW5jdGlvbiAocmVzb2x2ZUFsbCwgcmVqZWN0QWxsKSB7XG4gICAgdmFyIHZhbHMgPSBuZXcgQXJyYXkocHMubGVuZ3RoKTtcbiAgICB2YXIgZG9uZUNvdW50ID0gMDtcbiAgICB2YXIgZnVsZmlsbCA9IGZ1bmN0aW9uIGZ1bGZpbGwoaSwgdmFsKSB7XG4gICAgICB2YWxzW2ldID0gdmFsO1xuICAgICAgZG9uZUNvdW50Kys7XG4gICAgICBpZiAoZG9uZUNvdW50ID09PSBwcy5sZW5ndGgpIHtcbiAgICAgICAgcmVzb2x2ZUFsbCh2YWxzKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIChmdW5jdGlvbiAoaSkge1xuICAgICAgICB2YXIgcCA9IHBzW2ldO1xuICAgICAgICB2YXIgaXNQcm9taXNlID0gcCAhPSBudWxsICYmIHAudGhlbiAhPSBudWxsO1xuICAgICAgICBpZiAoaXNQcm9taXNlKSB7XG4gICAgICAgICAgcC50aGVuKGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgIGZ1bGZpbGwoaSwgdmFsKTtcbiAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICByZWplY3RBbGwoZXJyKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgdmFsID0gcDtcbiAgICAgICAgICBmdWxmaWxsKGksIHZhbCk7XG4gICAgICAgIH1cbiAgICAgIH0pKGkpO1xuICAgIH1cbiAgfSk7XG59O1xuYXBpLnJlc29sdmUgPSBmdW5jdGlvbiAodmFsKSB7XG4gIHJldHVybiBuZXcgYXBpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICByZXNvbHZlKHZhbCk7XG4gIH0pO1xufTtcbmFwaS5yZWplY3QgPSBmdW5jdGlvbiAodmFsKSB7XG4gIHJldHVybiBuZXcgYXBpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICByZWplY3QodmFsKTtcbiAgfSk7XG59O1xudmFyIFByb21pc2UkMSA9IHR5cGVvZiBQcm9taXNlICE9PSAndW5kZWZpbmVkJyA/IFByb21pc2UgOiBhcGk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcblxudmFyIEFuaW1hdGlvbiA9IGZ1bmN0aW9uIEFuaW1hdGlvbih0YXJnZXQsIG9wdHMsIG9wdHMyKSB7XG4gIHZhciBpc0NvcmUgPSBjb3JlKHRhcmdldCk7XG4gIHZhciBpc0VsZSA9ICFpc0NvcmU7XG4gIHZhciBfcCA9IHRoaXMuX3ByaXZhdGUgPSBleHRlbmQoe1xuICAgIGR1cmF0aW9uOiAxMDAwXG4gIH0sIG9wdHMsIG9wdHMyKTtcbiAgX3AudGFyZ2V0ID0gdGFyZ2V0O1xuICBfcC5zdHlsZSA9IF9wLnN0eWxlIHx8IF9wLmNzcztcbiAgX3Auc3RhcnRlZCA9IGZhbHNlO1xuICBfcC5wbGF5aW5nID0gZmFsc2U7XG4gIF9wLmhvb2tlZCA9IGZhbHNlO1xuICBfcC5hcHBseWluZyA9IGZhbHNlO1xuICBfcC5wcm9ncmVzcyA9IDA7XG4gIF9wLmNvbXBsZXRlcyA9IFtdO1xuICBfcC5mcmFtZXMgPSBbXTtcbiAgaWYgKF9wLmNvbXBsZXRlICYmIGZuJDYoX3AuY29tcGxldGUpKSB7XG4gICAgX3AuY29tcGxldGVzLnB1c2goX3AuY29tcGxldGUpO1xuICB9XG4gIGlmIChpc0VsZSkge1xuICAgIHZhciBwb3MgPSB0YXJnZXQucG9zaXRpb24oKTtcbiAgICBfcC5zdGFydFBvc2l0aW9uID0gX3Auc3RhcnRQb3NpdGlvbiB8fCB7XG4gICAgICB4OiBwb3MueCxcbiAgICAgIHk6IHBvcy55XG4gICAgfTtcbiAgICBfcC5zdGFydFN0eWxlID0gX3Auc3RhcnRTdHlsZSB8fCB0YXJnZXQuY3koKS5zdHlsZSgpLmdldEFuaW1hdGlvblN0YXJ0U3R5bGUodGFyZ2V0LCBfcC5zdHlsZSk7XG4gIH1cbiAgaWYgKGlzQ29yZSkge1xuICAgIHZhciBwYW4gPSB0YXJnZXQucGFuKCk7XG4gICAgX3Auc3RhcnRQYW4gPSB7XG4gICAgICB4OiBwYW4ueCxcbiAgICAgIHk6IHBhbi55XG4gICAgfTtcbiAgICBfcC5zdGFydFpvb20gPSB0YXJnZXQuem9vbSgpO1xuICB9XG5cbiAgLy8gZm9yIGZ1dHVyZSB0aW1lbGluZS9hbmltYXRpb25zIGltcGxcbiAgdGhpcy5sZW5ndGggPSAxO1xuICB0aGlzWzBdID0gdGhpcztcbn07XG52YXIgYW5pZm4gPSBBbmltYXRpb24ucHJvdG90eXBlO1xuZXh0ZW5kKGFuaWZuLCB7XG4gIGluc3RhbmNlU3RyaW5nOiBmdW5jdGlvbiBpbnN0YW5jZVN0cmluZygpIHtcbiAgICByZXR1cm4gJ2FuaW1hdGlvbic7XG4gIH0sXG4gIGhvb2s6IGZ1bmN0aW9uIGhvb2soKSB7XG4gICAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZTtcbiAgICBpZiAoIV9wLmhvb2tlZCkge1xuICAgICAgLy8gYWRkIHRvIHRhcmdldCdzIGFuaW1hdGlvbiBxdWV1ZVxuICAgICAgdmFyIHE7XG4gICAgICB2YXIgdEFuaSA9IF9wLnRhcmdldC5fcHJpdmF0ZS5hbmltYXRpb247XG4gICAgICBpZiAoX3AucXVldWUpIHtcbiAgICAgICAgcSA9IHRBbmkucXVldWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBxID0gdEFuaS5jdXJyZW50O1xuICAgICAgfVxuICAgICAgcS5wdXNoKHRoaXMpO1xuXG4gICAgICAvLyBhZGQgdG8gdGhlIGFuaW1hdGlvbiBsb29wIHBvb2xcbiAgICAgIGlmIChlbGVtZW50T3JDb2xsZWN0aW9uKF9wLnRhcmdldCkpIHtcbiAgICAgICAgX3AudGFyZ2V0LmN5KCkuYWRkVG9BbmltYXRpb25Qb29sKF9wLnRhcmdldCk7XG4gICAgICB9XG4gICAgICBfcC5ob29rZWQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgcGxheTogZnVuY3Rpb24gcGxheSgpIHtcbiAgICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlO1xuXG4gICAgLy8gYXV0b3Jld2luZFxuICAgIGlmIChfcC5wcm9ncmVzcyA9PT0gMSkge1xuICAgICAgX3AucHJvZ3Jlc3MgPSAwO1xuICAgIH1cbiAgICBfcC5wbGF5aW5nID0gdHJ1ZTtcbiAgICBfcC5zdGFydGVkID0gZmFsc2U7IC8vIG5lZWRzIHRvIGJlIHN0YXJ0ZWQgYnkgYW5pbWF0aW9uIGxvb3BcbiAgICBfcC5zdG9wcGVkID0gZmFsc2U7XG4gICAgdGhpcy5ob29rKCk7XG5cbiAgICAvLyB0aGUgYW5pbWF0aW9uIGxvb3Agd2lsbCBzdGFydCB0aGUgYW5pbWF0aW9uLi4uXG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgcGxheWluZzogZnVuY3Rpb24gcGxheWluZygpIHtcbiAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5wbGF5aW5nO1xuICB9LFxuICBhcHBseTogZnVuY3Rpb24gYXBwbHkoKSB7XG4gICAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZTtcbiAgICBfcC5hcHBseWluZyA9IHRydWU7XG4gICAgX3Auc3RhcnRlZCA9IGZhbHNlOyAvLyBuZWVkcyB0byBiZSBzdGFydGVkIGJ5IGFuaW1hdGlvbiBsb29wXG4gICAgX3Auc3RvcHBlZCA9IGZhbHNlO1xuICAgIHRoaXMuaG9vaygpO1xuXG4gICAgLy8gdGhlIGFuaW1hdGlvbiBsb29wIHdpbGwgYXBwbHkgdGhlIGFuaW1hdGlvbiBhdCB0aGlzIHByb2dyZXNzXG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgYXBwbHlpbmc6IGZ1bmN0aW9uIGFwcGx5aW5nKCkge1xuICAgIHJldHVybiB0aGlzLl9wcml2YXRlLmFwcGx5aW5nO1xuICB9LFxuICBwYXVzZTogZnVuY3Rpb24gcGF1c2UoKSB7XG4gICAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZTtcbiAgICBfcC5wbGF5aW5nID0gZmFsc2U7XG4gICAgX3Auc3RhcnRlZCA9IGZhbHNlO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBzdG9wOiBmdW5jdGlvbiBzdG9wKCkge1xuICAgIHZhciBfcCA9IHRoaXMuX3ByaXZhdGU7XG4gICAgX3AucGxheWluZyA9IGZhbHNlO1xuICAgIF9wLnN0YXJ0ZWQgPSBmYWxzZTtcbiAgICBfcC5zdG9wcGVkID0gdHJ1ZTsgLy8gdG8gYmUgcmVtb3ZlZCBmcm9tIGFuaW1hdGlvbiBxdWV1ZXNcblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICByZXdpbmQ6IGZ1bmN0aW9uIHJld2luZCgpIHtcbiAgICByZXR1cm4gdGhpcy5wcm9ncmVzcygwKTtcbiAgfSxcbiAgZmFzdGZvcndhcmQ6IGZ1bmN0aW9uIGZhc3Rmb3J3YXJkKCkge1xuICAgIHJldHVybiB0aGlzLnByb2dyZXNzKDEpO1xuICB9LFxuICB0aW1lOiBmdW5jdGlvbiB0aW1lKHQpIHtcbiAgICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlO1xuICAgIGlmICh0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBfcC5wcm9ncmVzcyAqIF9wLmR1cmF0aW9uO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5wcm9ncmVzcyh0IC8gX3AuZHVyYXRpb24pO1xuICAgIH1cbiAgfSxcbiAgcHJvZ3Jlc3M6IGZ1bmN0aW9uIHByb2dyZXNzKHApIHtcbiAgICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlO1xuICAgIHZhciB3YXNQbGF5aW5nID0gX3AucGxheWluZztcbiAgICBpZiAocCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gX3AucHJvZ3Jlc3M7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh3YXNQbGF5aW5nKSB7XG4gICAgICAgIHRoaXMucGF1c2UoKTtcbiAgICAgIH1cbiAgICAgIF9wLnByb2dyZXNzID0gcDtcbiAgICAgIF9wLnN0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgIGlmICh3YXNQbGF5aW5nKSB7XG4gICAgICAgIHRoaXMucGxheSgpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgY29tcGxldGVkOiBmdW5jdGlvbiBjb21wbGV0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUucHJvZ3Jlc3MgPT09IDE7XG4gIH0sXG4gIHJldmVyc2U6IGZ1bmN0aW9uIHJldmVyc2UoKSB7XG4gICAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZTtcbiAgICB2YXIgd2FzUGxheWluZyA9IF9wLnBsYXlpbmc7XG4gICAgaWYgKHdhc1BsYXlpbmcpIHtcbiAgICAgIHRoaXMucGF1c2UoKTtcbiAgICB9XG4gICAgX3AucHJvZ3Jlc3MgPSAxIC0gX3AucHJvZ3Jlc3M7XG4gICAgX3Auc3RhcnRlZCA9IGZhbHNlO1xuICAgIHZhciBzd2FwID0gZnVuY3Rpb24gc3dhcChhLCBiKSB7XG4gICAgICB2YXIgX3BhID0gX3BbYV07XG4gICAgICBpZiAoX3BhID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgX3BbYV0gPSBfcFtiXTtcbiAgICAgIF9wW2JdID0gX3BhO1xuICAgIH07XG4gICAgc3dhcCgnem9vbScsICdzdGFydFpvb20nKTtcbiAgICBzd2FwKCdwYW4nLCAnc3RhcnRQYW4nKTtcbiAgICBzd2FwKCdwb3NpdGlvbicsICdzdGFydFBvc2l0aW9uJyk7XG5cbiAgICAvLyBzd2FwIHN0eWxlc1xuICAgIGlmIChfcC5zdHlsZSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBfcC5zdHlsZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcHJvcCA9IF9wLnN0eWxlW2ldO1xuICAgICAgICB2YXIgbmFtZSA9IHByb3AubmFtZTtcbiAgICAgICAgdmFyIHN0YXJ0U3R5bGVQcm9wID0gX3Auc3RhcnRTdHlsZVtuYW1lXTtcbiAgICAgICAgX3Auc3RhcnRTdHlsZVtuYW1lXSA9IHByb3A7XG4gICAgICAgIF9wLnN0eWxlW2ldID0gc3RhcnRTdHlsZVByb3A7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh3YXNQbGF5aW5nKSB7XG4gICAgICB0aGlzLnBsYXkoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIHByb21pc2U6IGZ1bmN0aW9uIHByb21pc2UodHlwZSkge1xuICAgIHZhciBfcCA9IHRoaXMuX3ByaXZhdGU7XG4gICAgdmFyIGFycjtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgJ2ZyYW1lJzpcbiAgICAgICAgYXJyID0gX3AuZnJhbWVzO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICBjYXNlICdjb21wbGV0ZSc6XG4gICAgICBjYXNlICdjb21wbGV0ZWQnOlxuICAgICAgICBhcnIgPSBfcC5jb21wbGV0ZXM7XG4gICAgfVxuICAgIHJldHVybiBuZXcgUHJvbWlzZSQxKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIGFyci5wdXNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbn0pO1xuYW5pZm4uY29tcGxldGUgPSBhbmlmbi5jb21wbGV0ZWQ7XG5hbmlmbi5ydW4gPSBhbmlmbi5wbGF5O1xuYW5pZm4ucnVubmluZyA9IGFuaWZuLnBsYXlpbmc7XG5cbnZhciBkZWZpbmUkMyA9IHtcbiAgYW5pbWF0ZWQ6IGZ1bmN0aW9uIGFuaW1hdGVkKCkge1xuICAgIHJldHVybiBmdW5jdGlvbiBhbmltYXRlZEltcGwoKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgc2VsZklzQXJyYXlMaWtlID0gc2VsZi5sZW5ndGggIT09IHVuZGVmaW5lZDtcbiAgICAgIHZhciBhbGwgPSBzZWxmSXNBcnJheUxpa2UgPyBzZWxmIDogW3NlbGZdOyAvLyBwdXQgaW4gYXJyYXkgaWYgbm90IGFycmF5LWxpa2VcbiAgICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3kgfHwgdGhpcztcbiAgICAgIGlmICghY3kuc3R5bGVFbmFibGVkKCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdmFyIGVsZSA9IGFsbFswXTtcbiAgICAgIGlmIChlbGUpIHtcbiAgICAgICAgcmV0dXJuIGVsZS5fcHJpdmF0ZS5hbmltYXRpb24uY3VycmVudC5sZW5ndGggPiAwO1xuICAgICAgfVxuICAgIH07XG4gIH0sXG4gIC8vIGFuaW1hdGVkXG5cbiAgY2xlYXJRdWV1ZTogZnVuY3Rpb24gY2xlYXJRdWV1ZSgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gY2xlYXJRdWV1ZUltcGwoKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgc2VsZklzQXJyYXlMaWtlID0gc2VsZi5sZW5ndGggIT09IHVuZGVmaW5lZDtcbiAgICAgIHZhciBhbGwgPSBzZWxmSXNBcnJheUxpa2UgPyBzZWxmIDogW3NlbGZdOyAvLyBwdXQgaW4gYXJyYXkgaWYgbm90IGFycmF5LWxpa2VcbiAgICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3kgfHwgdGhpcztcbiAgICAgIGlmICghY3kuc3R5bGVFbmFibGVkKCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFsbC5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZWxlID0gYWxsW2ldO1xuICAgICAgICBlbGUuX3ByaXZhdGUuYW5pbWF0aW9uLnF1ZXVlID0gW107XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICB9LFxuICAvLyBjbGVhclF1ZXVlXG5cbiAgZGVsYXk6IGZ1bmN0aW9uIGRlbGF5KCkge1xuICAgIHJldHVybiBmdW5jdGlvbiBkZWxheUltcGwodGltZSwgY29tcGxldGUpIHtcbiAgICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3kgfHwgdGhpcztcbiAgICAgIGlmICghY3kuc3R5bGVFbmFibGVkKCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5hbmltYXRlKHtcbiAgICAgICAgZGVsYXk6IHRpbWUsXG4gICAgICAgIGR1cmF0aW9uOiB0aW1lLFxuICAgICAgICBjb21wbGV0ZTogY29tcGxldGVcbiAgICAgIH0pO1xuICAgIH07XG4gIH0sXG4gIC8vIGRlbGF5XG5cbiAgZGVsYXlBbmltYXRpb246IGZ1bmN0aW9uIGRlbGF5QW5pbWF0aW9uKCkge1xuICAgIHJldHVybiBmdW5jdGlvbiBkZWxheUFuaW1hdGlvbkltcGwodGltZSwgY29tcGxldGUpIHtcbiAgICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3kgfHwgdGhpcztcbiAgICAgIGlmICghY3kuc3R5bGVFbmFibGVkKCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5hbmltYXRpb24oe1xuICAgICAgICBkZWxheTogdGltZSxcbiAgICAgICAgZHVyYXRpb246IHRpbWUsXG4gICAgICAgIGNvbXBsZXRlOiBjb21wbGV0ZVxuICAgICAgfSk7XG4gICAgfTtcbiAgfSxcbiAgLy8gZGVsYXlcblxuICBhbmltYXRpb246IGZ1bmN0aW9uIGFuaW1hdGlvbigpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gYW5pbWF0aW9uSW1wbChwcm9wZXJ0aWVzLCBwYXJhbXMpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciBzZWxmSXNBcnJheUxpa2UgPSBzZWxmLmxlbmd0aCAhPT0gdW5kZWZpbmVkO1xuICAgICAgdmFyIGFsbCA9IHNlbGZJc0FycmF5TGlrZSA/IHNlbGYgOiBbc2VsZl07IC8vIHB1dCBpbiBhcnJheSBpZiBub3QgYXJyYXktbGlrZVxuICAgICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeSB8fCB0aGlzO1xuICAgICAgdmFyIGlzQ29yZSA9ICFzZWxmSXNBcnJheUxpa2U7XG4gICAgICB2YXIgaXNFbGVzID0gIWlzQ29yZTtcbiAgICAgIGlmICghY3kuc3R5bGVFbmFibGVkKCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICB2YXIgc3R5bGUgPSBjeS5zdHlsZSgpO1xuICAgICAgcHJvcGVydGllcyA9IGV4dGVuZCh7fSwgcHJvcGVydGllcywgcGFyYW1zKTtcbiAgICAgIHZhciBwcm9wZXJ0aWVzRW1wdHkgPSBPYmplY3Qua2V5cyhwcm9wZXJ0aWVzKS5sZW5ndGggPT09IDA7XG4gICAgICBpZiAocHJvcGVydGllc0VtcHR5KSB7XG4gICAgICAgIHJldHVybiBuZXcgQW5pbWF0aW9uKGFsbFswXSwgcHJvcGVydGllcyk7IC8vIG5vdGhpbmcgdG8gYW5pbWF0ZVxuICAgICAgfVxuXG4gICAgICBpZiAocHJvcGVydGllcy5kdXJhdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHByb3BlcnRpZXMuZHVyYXRpb24gPSA0MDA7XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKHByb3BlcnRpZXMuZHVyYXRpb24pIHtcbiAgICAgICAgY2FzZSAnc2xvdyc6XG4gICAgICAgICAgcHJvcGVydGllcy5kdXJhdGlvbiA9IDYwMDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnZmFzdCc6XG4gICAgICAgICAgcHJvcGVydGllcy5kdXJhdGlvbiA9IDIwMDtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChpc0VsZXMpIHtcbiAgICAgICAgcHJvcGVydGllcy5zdHlsZSA9IHN0eWxlLmdldFByb3BzTGlzdChwcm9wZXJ0aWVzLnN0eWxlIHx8IHByb3BlcnRpZXMuY3NzKTtcbiAgICAgICAgcHJvcGVydGllcy5jc3MgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBpZiAoaXNFbGVzICYmIHByb3BlcnRpZXMucmVuZGVyZWRQb3NpdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHZhciBycG9zID0gcHJvcGVydGllcy5yZW5kZXJlZFBvc2l0aW9uO1xuICAgICAgICB2YXIgcGFuID0gY3kucGFuKCk7XG4gICAgICAgIHZhciB6b29tID0gY3kuem9vbSgpO1xuICAgICAgICBwcm9wZXJ0aWVzLnBvc2l0aW9uID0gcmVuZGVyZWRUb01vZGVsUG9zaXRpb24ocnBvcywgem9vbSwgcGFuKTtcbiAgICAgIH1cblxuICAgICAgLy8gb3ZlcnJpZGUgcGFuIHcvIHBhbkJ5IGlmIHNldFxuICAgICAgaWYgKGlzQ29yZSAmJiBwcm9wZXJ0aWVzLnBhbkJ5ICE9IG51bGwpIHtcbiAgICAgICAgdmFyIHBhbkJ5ID0gcHJvcGVydGllcy5wYW5CeTtcbiAgICAgICAgdmFyIGN5UGFuID0gY3kucGFuKCk7XG4gICAgICAgIHByb3BlcnRpZXMucGFuID0ge1xuICAgICAgICAgIHg6IGN5UGFuLnggKyBwYW5CeS54LFxuICAgICAgICAgIHk6IGN5UGFuLnkgKyBwYW5CeS55XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIC8vIG92ZXJyaWRlIHBhbiB3LyBjZW50ZXIgaWYgc2V0XG4gICAgICB2YXIgY2VudGVyID0gcHJvcGVydGllcy5jZW50ZXIgfHwgcHJvcGVydGllcy5jZW50cmU7XG4gICAgICBpZiAoaXNDb3JlICYmIGNlbnRlciAhPSBudWxsKSB7XG4gICAgICAgIHZhciBjZW50ZXJQYW4gPSBjeS5nZXRDZW50ZXJQYW4oY2VudGVyLmVsZXMsIHByb3BlcnRpZXMuem9vbSk7XG4gICAgICAgIGlmIChjZW50ZXJQYW4gIT0gbnVsbCkge1xuICAgICAgICAgIHByb3BlcnRpZXMucGFuID0gY2VudGVyUGFuO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIG92ZXJyaWRlIHBhbiAmIHpvb20gdy8gZml0IGlmIHNldFxuICAgICAgaWYgKGlzQ29yZSAmJiBwcm9wZXJ0aWVzLmZpdCAhPSBudWxsKSB7XG4gICAgICAgIHZhciBmaXQgPSBwcm9wZXJ0aWVzLmZpdDtcbiAgICAgICAgdmFyIGZpdFZwID0gY3kuZ2V0Rml0Vmlld3BvcnQoZml0LmVsZXMgfHwgZml0LmJvdW5kaW5nQm94LCBmaXQucGFkZGluZyk7XG4gICAgICAgIGlmIChmaXRWcCAhPSBudWxsKSB7XG4gICAgICAgICAgcHJvcGVydGllcy5wYW4gPSBmaXRWcC5wYW47XG4gICAgICAgICAgcHJvcGVydGllcy56b29tID0gZml0VnAuem9vbTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBvdmVycmlkZSB6b29tICgmIHBvdGVudGlhbGx5IHBhbikgdy8gem9vbSBvYmogaWYgc2V0XG4gICAgICBpZiAoaXNDb3JlICYmIHBsYWluT2JqZWN0KHByb3BlcnRpZXMuem9vbSkpIHtcbiAgICAgICAgdmFyIHZwID0gY3kuZ2V0Wm9vbWVkVmlld3BvcnQocHJvcGVydGllcy56b29tKTtcbiAgICAgICAgaWYgKHZwICE9IG51bGwpIHtcbiAgICAgICAgICBpZiAodnAuem9vbWVkKSB7XG4gICAgICAgICAgICBwcm9wZXJ0aWVzLnpvb20gPSB2cC56b29tO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodnAucGFubmVkKSB7XG4gICAgICAgICAgICBwcm9wZXJ0aWVzLnBhbiA9IHZwLnBhbjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJvcGVydGllcy56b29tID0gbnVsbDsgLy8gYW4gaW5hdmFsaWQgem9vbSAoZS5nLiBubyBkZWx0YSkgZ2V0cyBhdXRvbWF0aWNhbGx5IGRlc3Ryb3llZFxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgQW5pbWF0aW9uKGFsbFswXSwgcHJvcGVydGllcyk7XG4gICAgfTtcbiAgfSxcbiAgLy8gYW5pbWF0ZVxuXG4gIGFuaW1hdGU6IGZ1bmN0aW9uIGFuaW1hdGUoKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGFuaW1hdGVJbXBsKHByb3BlcnRpZXMsIHBhcmFtcykge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIHNlbGZJc0FycmF5TGlrZSA9IHNlbGYubGVuZ3RoICE9PSB1bmRlZmluZWQ7XG4gICAgICB2YXIgYWxsID0gc2VsZklzQXJyYXlMaWtlID8gc2VsZiA6IFtzZWxmXTsgLy8gcHV0IGluIGFycmF5IGlmIG5vdCBhcnJheS1saWtlXG4gICAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5IHx8IHRoaXM7XG4gICAgICBpZiAoIWN5LnN0eWxlRW5hYmxlZCgpKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgaWYgKHBhcmFtcykge1xuICAgICAgICBwcm9wZXJ0aWVzID0gZXh0ZW5kKHt9LCBwcm9wZXJ0aWVzLCBwYXJhbXMpO1xuICAgICAgfVxuXG4gICAgICAvLyBtYW51YWxseSBob29rIGFuZCBydW4gdGhlIGFuaW1hdGlvblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbGwubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGVsZSA9IGFsbFtpXTtcbiAgICAgICAgdmFyIHF1ZXVlID0gZWxlLmFuaW1hdGVkKCkgJiYgKHByb3BlcnRpZXMucXVldWUgPT09IHVuZGVmaW5lZCB8fCBwcm9wZXJ0aWVzLnF1ZXVlKTtcbiAgICAgICAgdmFyIGFuaSA9IGVsZS5hbmltYXRpb24ocHJvcGVydGllcywgcXVldWUgPyB7XG4gICAgICAgICAgcXVldWU6IHRydWVcbiAgICAgICAgfSA6IHVuZGVmaW5lZCk7XG4gICAgICAgIGFuaS5wbGF5KCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgICB9O1xuICB9LFxuXG4gIC8vIGFuaW1hdGVcblxuICBzdG9wOiBmdW5jdGlvbiBzdG9wKCkge1xuICAgIHJldHVybiBmdW5jdGlvbiBzdG9wSW1wbChjbGVhclF1ZXVlLCBqdW1wVG9FbmQpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciBzZWxmSXNBcnJheUxpa2UgPSBzZWxmLmxlbmd0aCAhPT0gdW5kZWZpbmVkO1xuICAgICAgdmFyIGFsbCA9IHNlbGZJc0FycmF5TGlrZSA/IHNlbGYgOiBbc2VsZl07IC8vIHB1dCBpbiBhcnJheSBpZiBub3QgYXJyYXktbGlrZVxuICAgICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeSB8fCB0aGlzO1xuICAgICAgaWYgKCFjeS5zdHlsZUVuYWJsZWQoKSkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYWxsLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlbGUgPSBhbGxbaV07XG4gICAgICAgIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgICAgICAgdmFyIGFuaXMgPSBfcC5hbmltYXRpb24uY3VycmVudDtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBhbmlzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgdmFyIGFuaSA9IGFuaXNbal07XG4gICAgICAgICAgdmFyIGFuaV9wID0gYW5pLl9wcml2YXRlO1xuICAgICAgICAgIGlmIChqdW1wVG9FbmQpIHtcbiAgICAgICAgICAgIC8vIG5leHQgaXRlcmF0aW9uIG9mIHRoZSBhbmltYXRpb24gbG9vcCwgdGhlIGFuaW1hdGlvblxuICAgICAgICAgICAgLy8gd2lsbCBnbyBzdHJhaWdodCB0byB0aGUgZW5kIGFuZCBiZSByZW1vdmVkXG4gICAgICAgICAgICBhbmlfcC5kdXJhdGlvbiA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gY2xlYXIgdGhlIHF1ZXVlIG9mIGZ1dHVyZSBhbmltYXRpb25zXG4gICAgICAgIGlmIChjbGVhclF1ZXVlKSB7XG4gICAgICAgICAgX3AuYW5pbWF0aW9uLnF1ZXVlID0gW107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFqdW1wVG9FbmQpIHtcbiAgICAgICAgICBfcC5hbmltYXRpb24uY3VycmVudCA9IFtdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIHdlIGhhdmUgdG8gbm90aWZ5ICh0aGUgYW5pbWF0aW9uIGxvb3AgZG9lc24ndCBkbyBpdCBmb3IgdXMgb24gYHN0b3BgKVxuICAgICAgY3kubm90aWZ5KCdkcmF3Jyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICB9IC8vIHN0b3Bcbn07IC8vIGRlZmluZVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYW4gYEFycmF5YCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5KGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXkoJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXkoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcblxudmFyIGlzQXJyYXlfMSA9IGlzQXJyYXk7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIHByb3BlcnR5IG5hbWVzIHdpdGhpbiBwcm9wZXJ0eSBwYXRocy4gKi9cbnZhciByZUlzRGVlcFByb3AgPSAvXFwufFxcWyg/OlteW1xcXV0qfChbXCInXSkoPzooPyFcXDEpW15cXFxcXXxcXFxcLikqP1xcMSlcXF0vLFxuICAgIHJlSXNQbGFpblByb3AgPSAvXlxcdyokLztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHByb3BlcnR5IG5hbWUgYW5kIG5vdCBhIHByb3BlcnR5IHBhdGguXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkga2V5cyBvbi5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcHJvcGVydHkgbmFtZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0tleSh2YWx1ZSwgb2JqZWN0KSB7XG4gIGlmIChpc0FycmF5XzEodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICBpZiAodHlwZSA9PSAnbnVtYmVyJyB8fCB0eXBlID09ICdzeW1ib2wnIHx8IHR5cGUgPT0gJ2Jvb2xlYW4nIHx8XG4gICAgICB2YWx1ZSA9PSBudWxsIHx8IGlzU3ltYm9sXzEodmFsdWUpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIHJlSXNQbGFpblByb3AudGVzdCh2YWx1ZSkgfHwgIXJlSXNEZWVwUHJvcC50ZXN0KHZhbHVlKSB8fFxuICAgIChvYmplY3QgIT0gbnVsbCAmJiB2YWx1ZSBpbiBPYmplY3Qob2JqZWN0KSk7XG59XG5cbnZhciBfaXNLZXkgPSBpc0tleTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFzeW5jVGFnID0gJ1tvYmplY3QgQXN5bmNGdW5jdGlvbl0nLFxuICAgIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgIGdlblRhZyA9ICdbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXScsXG4gICAgcHJveHlUYWcgPSAnW29iamVjdCBQcm94eV0nO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgRnVuY3Rpb25gIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGZ1bmN0aW9uLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNGdW5jdGlvbihfKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oL2FiYy8pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0XzEodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIFRoZSB1c2Ugb2YgYE9iamVjdCN0b1N0cmluZ2AgYXZvaWRzIGlzc3VlcyB3aXRoIHRoZSBgdHlwZW9mYCBvcGVyYXRvclxuICAvLyBpbiBTYWZhcmkgOSB3aGljaCByZXR1cm5zICdvYmplY3QnIGZvciB0eXBlZCBhcnJheXMgYW5kIG90aGVyIGNvbnN0cnVjdG9ycy5cbiAgdmFyIHRhZyA9IF9iYXNlR2V0VGFnKHZhbHVlKTtcbiAgcmV0dXJuIHRhZyA9PSBmdW5jVGFnIHx8IHRhZyA9PSBnZW5UYWcgfHwgdGFnID09IGFzeW5jVGFnIHx8IHRhZyA9PSBwcm94eVRhZztcbn1cblxudmFyIGlzRnVuY3Rpb25fMSA9IGlzRnVuY3Rpb247XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBvdmVycmVhY2hpbmcgY29yZS1qcyBzaGltcy4gKi9cbnZhciBjb3JlSnNEYXRhID0gX3Jvb3RbJ19fY29yZS1qc19zaGFyZWRfXyddO1xuXG52YXIgX2NvcmVKc0RhdGEgPSBjb3JlSnNEYXRhO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgbWV0aG9kcyBtYXNxdWVyYWRpbmcgYXMgbmF0aXZlLiAqL1xudmFyIG1hc2tTcmNLZXkgPSAoZnVuY3Rpb24oKSB7XG4gIHZhciB1aWQgPSAvW14uXSskLy5leGVjKF9jb3JlSnNEYXRhICYmIF9jb3JlSnNEYXRhLmtleXMgJiYgX2NvcmVKc0RhdGEua2V5cy5JRV9QUk9UTyB8fCAnJyk7XG4gIHJldHVybiB1aWQgPyAoJ1N5bWJvbChzcmMpXzEuJyArIHVpZCkgOiAnJztcbn0oKSk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBmdW5jYCBoYXMgaXRzIHNvdXJjZSBtYXNrZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBmdW5jYCBpcyBtYXNrZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNNYXNrZWQoZnVuYykge1xuICByZXR1cm4gISFtYXNrU3JjS2V5ICYmIChtYXNrU3JjS2V5IGluIGZ1bmMpO1xufVxuXG52YXIgX2lzTWFza2VkID0gaXNNYXNrZWQ7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBmdW5jUHJvdG8kMSA9IEZ1bmN0aW9uLnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xudmFyIGZ1bmNUb1N0cmluZyQxID0gZnVuY1Byb3RvJDEudG9TdHJpbmc7XG5cbi8qKlxuICogQ29udmVydHMgYGZ1bmNgIHRvIGl0cyBzb3VyY2UgY29kZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHNvdXJjZSBjb2RlLlxuICovXG5mdW5jdGlvbiB0b1NvdXJjZShmdW5jKSB7XG4gIGlmIChmdW5jICE9IG51bGwpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGZ1bmNUb1N0cmluZyQxLmNhbGwoZnVuYyk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIChmdW5jICsgJycpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG52YXIgX3RvU291cmNlID0gdG9Tb3VyY2U7XG5cbi8qKlxuICogVXNlZCB0byBtYXRjaCBgUmVnRXhwYFxuICogW3N5bnRheCBjaGFyYWN0ZXJzXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1wYXR0ZXJucykuXG4gKi9cbnZhciByZVJlZ0V4cENoYXIgPSAvW1xcXFxeJC4qKz8oKVtcXF17fXxdL2c7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBob3N0IGNvbnN0cnVjdG9ycyAoU2FmYXJpKS4gKi9cbnZhciByZUlzSG9zdEN0b3IgPSAvXlxcW29iamVjdCAuKz9Db25zdHJ1Y3RvclxcXSQvO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgZnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlLFxuICAgIG9iamVjdFByb3RvJDMgPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXG52YXIgZnVuY1RvU3RyaW5nID0gZnVuY1Byb3RvLnRvU3RyaW5nO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSQzID0gb2JqZWN0UHJvdG8kMy5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGlmIGEgbWV0aG9kIGlzIG5hdGl2ZS4gKi9cbnZhciByZUlzTmF0aXZlID0gUmVnRXhwKCdeJyArXG4gIGZ1bmNUb1N0cmluZy5jYWxsKGhhc093blByb3BlcnR5JDMpLnJlcGxhY2UocmVSZWdFeHBDaGFyLCAnXFxcXCQmJylcbiAgLnJlcGxhY2UoL2hhc093blByb3BlcnR5fChmdW5jdGlvbikuKj8oPz1cXFxcXFwoKXwgZm9yIC4rPyg/PVxcXFxcXF0pL2csICckMS4qPycpICsgJyQnXG4pO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTmF0aXZlYCB3aXRob3V0IGJhZCBzaGltIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG5hdGl2ZSBmdW5jdGlvbixcbiAqICBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc05hdGl2ZSh2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0XzEodmFsdWUpIHx8IF9pc01hc2tlZCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHBhdHRlcm4gPSBpc0Z1bmN0aW9uXzEodmFsdWUpID8gcmVJc05hdGl2ZSA6IHJlSXNIb3N0Q3RvcjtcbiAgcmV0dXJuIHBhdHRlcm4udGVzdChfdG9Tb3VyY2UodmFsdWUpKTtcbn1cblxudmFyIF9iYXNlSXNOYXRpdmUgPSBiYXNlSXNOYXRpdmU7XG5cbi8qKlxuICogR2V0cyB0aGUgdmFsdWUgYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGdldFZhbHVlJDEob2JqZWN0LCBrZXkpIHtcbiAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XG59XG5cbnZhciBfZ2V0VmFsdWUgPSBnZXRWYWx1ZSQxO1xuXG4vKipcbiAqIEdldHMgdGhlIG5hdGl2ZSBmdW5jdGlvbiBhdCBga2V5YCBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBtZXRob2QgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGZ1bmN0aW9uIGlmIGl0J3MgbmF0aXZlLCBlbHNlIGB1bmRlZmluZWRgLlxuICovXG5mdW5jdGlvbiBnZXROYXRpdmUob2JqZWN0LCBrZXkpIHtcbiAgdmFyIHZhbHVlID0gX2dldFZhbHVlKG9iamVjdCwga2V5KTtcbiAgcmV0dXJuIF9iYXNlSXNOYXRpdmUodmFsdWUpID8gdmFsdWUgOiB1bmRlZmluZWQ7XG59XG5cbnZhciBfZ2V0TmF0aXZlID0gZ2V0TmF0aXZlO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgbmF0aXZlQ3JlYXRlID0gX2dldE5hdGl2ZShPYmplY3QsICdjcmVhdGUnKTtcblxudmFyIF9uYXRpdmVDcmVhdGUgPSBuYXRpdmVDcmVhdGU7XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgaGFzaC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKi9cbmZ1bmN0aW9uIGhhc2hDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IF9uYXRpdmVDcmVhdGUgPyBfbmF0aXZlQ3JlYXRlKG51bGwpIDoge307XG4gIHRoaXMuc2l6ZSA9IDA7XG59XG5cbnZhciBfaGFzaENsZWFyID0gaGFzaENsZWFyO1xuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBoYXNoLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge09iamVjdH0gaGFzaCBUaGUgaGFzaCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzaERlbGV0ZShrZXkpIHtcbiAgdmFyIHJlc3VsdCA9IHRoaXMuaGFzKGtleSkgJiYgZGVsZXRlIHRoaXMuX19kYXRhX19ba2V5XTtcbiAgdGhpcy5zaXplIC09IHJlc3VsdCA/IDEgOiAwO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG52YXIgX2hhc2hEZWxldGUgPSBoYXNoRGVsZXRlO1xuXG4vKiogVXNlZCB0byBzdGFuZC1pbiBmb3IgYHVuZGVmaW5lZGAgaGFzaCB2YWx1ZXMuICovXG52YXIgSEFTSF9VTkRFRklORUQkMSA9ICdfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvJDIgPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSQyID0gb2JqZWN0UHJvdG8kMi5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBHZXRzIHRoZSBoYXNoIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGhhc2hHZXQoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgaWYgKF9uYXRpdmVDcmVhdGUpIHtcbiAgICB2YXIgcmVzdWx0ID0gZGF0YVtrZXldO1xuICAgIHJldHVybiByZXN1bHQgPT09IEhBU0hfVU5ERUZJTkVEJDEgPyB1bmRlZmluZWQgOiByZXN1bHQ7XG4gIH1cbiAgcmV0dXJuIGhhc093blByb3BlcnR5JDIuY2FsbChkYXRhLCBrZXkpID8gZGF0YVtrZXldIDogdW5kZWZpbmVkO1xufVxuXG52YXIgX2hhc2hHZXQgPSBoYXNoR2V0O1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8kMSA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5JDEgPSBvYmplY3RQcm90byQxLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIGhhc2ggdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc2hIYXMoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgcmV0dXJuIF9uYXRpdmVDcmVhdGUgPyAoZGF0YVtrZXldICE9PSB1bmRlZmluZWQpIDogaGFzT3duUHJvcGVydHkkMS5jYWxsKGRhdGEsIGtleSk7XG59XG5cbnZhciBfaGFzaEhhcyA9IGhhc2hIYXM7XG5cbi8qKiBVc2VkIHRvIHN0YW5kLWluIGZvciBgdW5kZWZpbmVkYCBoYXNoIHZhbHVlcy4gKi9cbnZhciBIQVNIX1VOREVGSU5FRCA9ICdfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fJztcblxuLyoqXG4gKiBTZXRzIHRoZSBoYXNoIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgaGFzaCBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gaGFzaFNldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgdGhpcy5zaXplICs9IHRoaXMuaGFzKGtleSkgPyAwIDogMTtcbiAgZGF0YVtrZXldID0gKF9uYXRpdmVDcmVhdGUgJiYgdmFsdWUgPT09IHVuZGVmaW5lZCkgPyBIQVNIX1VOREVGSU5FRCA6IHZhbHVlO1xuICByZXR1cm4gdGhpcztcbn1cblxudmFyIF9oYXNoU2V0ID0gaGFzaFNldDtcblxuLyoqXG4gKiBDcmVhdGVzIGEgaGFzaCBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIEhhc2goZW50cmllcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgSGFzaGAuXG5IYXNoLnByb3RvdHlwZS5jbGVhciA9IF9oYXNoQ2xlYXI7XG5IYXNoLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBfaGFzaERlbGV0ZTtcbkhhc2gucHJvdG90eXBlLmdldCA9IF9oYXNoR2V0O1xuSGFzaC5wcm90b3R5cGUuaGFzID0gX2hhc2hIYXM7XG5IYXNoLnByb3RvdHlwZS5zZXQgPSBfaGFzaFNldDtcblxudmFyIF9IYXNoID0gSGFzaDtcblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBsaXN0IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IFtdO1xuICB0aGlzLnNpemUgPSAwO1xufVxuXG52YXIgX2xpc3RDYWNoZUNsZWFyID0gbGlzdENhY2hlQ2xlYXI7XG5cbi8qKlxuICogUGVyZm9ybXMgYVxuICogW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAqIGNvbXBhcmlzb24gYmV0d2VlbiB0d28gdmFsdWVzIHRvIGRldGVybWluZSBpZiB0aGV5IGFyZSBlcXVpdmFsZW50LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSB9O1xuICogdmFyIG90aGVyID0geyAnYSc6IDEgfTtcbiAqXG4gKiBfLmVxKG9iamVjdCwgb2JqZWN0KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmVxKG9iamVjdCwgb3RoZXIpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmVxKCdhJywgJ2EnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmVxKCdhJywgT2JqZWN0KCdhJykpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmVxKE5hTiwgTmFOKTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gZXEodmFsdWUsIG90aGVyKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gb3RoZXIgfHwgKHZhbHVlICE9PSB2YWx1ZSAmJiBvdGhlciAhPT0gb3RoZXIpO1xufVxuXG52YXIgZXFfMSA9IGVxO1xuXG4vKipcbiAqIEdldHMgdGhlIGluZGV4IGF0IHdoaWNoIHRoZSBga2V5YCBpcyBmb3VuZCBpbiBgYXJyYXlgIG9mIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0geyp9IGtleSBUaGUga2V5IHRvIHNlYXJjaCBmb3IuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICovXG5mdW5jdGlvbiBhc3NvY0luZGV4T2YoYXJyYXksIGtleSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICBpZiAoZXFfMShhcnJheVtsZW5ndGhdWzBdLCBrZXkpKSB7XG4gICAgICByZXR1cm4gbGVuZ3RoO1xuICAgIH1cbiAgfVxuICByZXR1cm4gLTE7XG59XG5cbnZhciBfYXNzb2NJbmRleE9mID0gYXNzb2NJbmRleE9mO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgYXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3BsaWNlID0gYXJyYXlQcm90by5zcGxpY2U7XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIGxpc3QgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZURlbGV0ZShrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBfYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgaWYgKGluZGV4IDwgMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgbGFzdEluZGV4ID0gZGF0YS5sZW5ndGggLSAxO1xuICBpZiAoaW5kZXggPT0gbGFzdEluZGV4KSB7XG4gICAgZGF0YS5wb3AoKTtcbiAgfSBlbHNlIHtcbiAgICBzcGxpY2UuY2FsbChkYXRhLCBpbmRleCwgMSk7XG4gIH1cbiAgLS10aGlzLnNpemU7XG4gIHJldHVybiB0cnVlO1xufVxuXG52YXIgX2xpc3RDYWNoZURlbGV0ZSA9IGxpc3RDYWNoZURlbGV0ZTtcblxuLyoqXG4gKiBHZXRzIHRoZSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlR2V0KGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IF9hc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICByZXR1cm4gaW5kZXggPCAwID8gdW5kZWZpbmVkIDogZGF0YVtpbmRleF1bMV07XG59XG5cbnZhciBfbGlzdENhY2hlR2V0ID0gbGlzdENhY2hlR2V0O1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIGxpc3QgY2FjaGUgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlSGFzKGtleSkge1xuICByZXR1cm4gX2Fzc29jSW5kZXhPZih0aGlzLl9fZGF0YV9fLCBrZXkpID4gLTE7XG59XG5cbnZhciBfbGlzdENhY2hlSGFzID0gbGlzdENhY2hlSGFzO1xuXG4vKipcbiAqIFNldHMgdGhlIGxpc3QgY2FjaGUgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGxpc3QgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZVNldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gX2Fzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIGlmIChpbmRleCA8IDApIHtcbiAgICArK3RoaXMuc2l6ZTtcbiAgICBkYXRhLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgfSBlbHNlIHtcbiAgICBkYXRhW2luZGV4XVsxXSA9IHZhbHVlO1xuICB9XG4gIHJldHVybiB0aGlzO1xufVxuXG52YXIgX2xpc3RDYWNoZVNldCA9IGxpc3RDYWNoZVNldDtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGxpc3QgY2FjaGUgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBMaXN0Q2FjaGUoZW50cmllcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgTGlzdENhY2hlYC5cbkxpc3RDYWNoZS5wcm90b3R5cGUuY2xlYXIgPSBfbGlzdENhY2hlQ2xlYXI7XG5MaXN0Q2FjaGUucHJvdG90eXBlWydkZWxldGUnXSA9IF9saXN0Q2FjaGVEZWxldGU7XG5MaXN0Q2FjaGUucHJvdG90eXBlLmdldCA9IF9saXN0Q2FjaGVHZXQ7XG5MaXN0Q2FjaGUucHJvdG90eXBlLmhhcyA9IF9saXN0Q2FjaGVIYXM7XG5MaXN0Q2FjaGUucHJvdG90eXBlLnNldCA9IF9saXN0Q2FjaGVTZXQ7XG5cbnZhciBfTGlzdENhY2hlID0gTGlzdENhY2hlO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgTWFwJDEgPSBfZ2V0TmF0aXZlKF9yb290LCAnTWFwJyk7XG5cbnZhciBfTWFwID0gTWFwJDE7XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgbWFwLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlQ2xlYXIoKSB7XG4gIHRoaXMuc2l6ZSA9IDA7XG4gIHRoaXMuX19kYXRhX18gPSB7XG4gICAgJ2hhc2gnOiBuZXcgX0hhc2gsXG4gICAgJ21hcCc6IG5ldyAoX01hcCB8fCBfTGlzdENhY2hlKSxcbiAgICAnc3RyaW5nJzogbmV3IF9IYXNoXG4gIH07XG59XG5cbnZhciBfbWFwQ2FjaGVDbGVhciA9IG1hcENhY2hlQ2xlYXI7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUgZm9yIHVzZSBhcyB1bmlxdWUgb2JqZWN0IGtleS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0tleWFibGUodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiAodHlwZSA9PSAnc3RyaW5nJyB8fCB0eXBlID09ICdudW1iZXInIHx8IHR5cGUgPT0gJ3N5bWJvbCcgfHwgdHlwZSA9PSAnYm9vbGVhbicpXG4gICAgPyAodmFsdWUgIT09ICdfX3Byb3RvX18nKVxuICAgIDogKHZhbHVlID09PSBudWxsKTtcbn1cblxudmFyIF9pc0tleWFibGUgPSBpc0tleWFibGU7XG5cbi8qKlxuICogR2V0cyB0aGUgZGF0YSBmb3IgYG1hcGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBtYXAgVGhlIG1hcCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIHJlZmVyZW5jZSBrZXkuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWFwIGRhdGEuXG4gKi9cbmZ1bmN0aW9uIGdldE1hcERhdGEobWFwLCBrZXkpIHtcbiAgdmFyIGRhdGEgPSBtYXAuX19kYXRhX187XG4gIHJldHVybiBfaXNLZXlhYmxlKGtleSlcbiAgICA/IGRhdGFbdHlwZW9mIGtleSA9PSAnc3RyaW5nJyA/ICdzdHJpbmcnIDogJ2hhc2gnXVxuICAgIDogZGF0YS5tYXA7XG59XG5cbnZhciBfZ2V0TWFwRGF0YSA9IGdldE1hcERhdGE7XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIG1hcC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZURlbGV0ZShrZXkpIHtcbiAgdmFyIHJlc3VsdCA9IF9nZXRNYXBEYXRhKHRoaXMsIGtleSlbJ2RlbGV0ZSddKGtleSk7XG4gIHRoaXMuc2l6ZSAtPSByZXN1bHQgPyAxIDogMDtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxudmFyIF9tYXBDYWNoZURlbGV0ZSA9IG1hcENhY2hlRGVsZXRlO1xuXG4vKipcbiAqIEdldHMgdGhlIG1hcCB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVHZXQoa2V5KSB7XG4gIHJldHVybiBfZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLmdldChrZXkpO1xufVxuXG52YXIgX21hcENhY2hlR2V0ID0gbWFwQ2FjaGVHZXQ7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgbWFwIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVIYXMoa2V5KSB7XG4gIHJldHVybiBfZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLmhhcyhrZXkpO1xufVxuXG52YXIgX21hcENhY2hlSGFzID0gbWFwQ2FjaGVIYXM7XG5cbi8qKlxuICogU2V0cyB0aGUgbWFwIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG1hcCBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IF9nZXRNYXBEYXRhKHRoaXMsIGtleSksXG4gICAgICBzaXplID0gZGF0YS5zaXplO1xuXG4gIGRhdGEuc2V0KGtleSwgdmFsdWUpO1xuICB0aGlzLnNpemUgKz0gZGF0YS5zaXplID09IHNpemUgPyAwIDogMTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbnZhciBfbWFwQ2FjaGVTZXQgPSBtYXBDYWNoZVNldDtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbWFwIGNhY2hlIG9iamVjdCB0byBzdG9yZSBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIE1hcENhY2hlKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYE1hcENhY2hlYC5cbk1hcENhY2hlLnByb3RvdHlwZS5jbGVhciA9IF9tYXBDYWNoZUNsZWFyO1xuTWFwQ2FjaGUucHJvdG90eXBlWydkZWxldGUnXSA9IF9tYXBDYWNoZURlbGV0ZTtcbk1hcENhY2hlLnByb3RvdHlwZS5nZXQgPSBfbWFwQ2FjaGVHZXQ7XG5NYXBDYWNoZS5wcm90b3R5cGUuaGFzID0gX21hcENhY2hlSGFzO1xuTWFwQ2FjaGUucHJvdG90eXBlLnNldCA9IF9tYXBDYWNoZVNldDtcblxudmFyIF9NYXBDYWNoZSA9IE1hcENhY2hlO1xuXG4vKiogRXJyb3IgbWVzc2FnZSBjb25zdGFudHMuICovXG52YXIgRlVOQ19FUlJPUl9URVhUID0gJ0V4cGVjdGVkIGEgZnVuY3Rpb24nO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IG1lbW9pemVzIHRoZSByZXN1bHQgb2YgYGZ1bmNgLiBJZiBgcmVzb2x2ZXJgIGlzXG4gKiBwcm92aWRlZCwgaXQgZGV0ZXJtaW5lcyB0aGUgY2FjaGUga2V5IGZvciBzdG9yaW5nIHRoZSByZXN1bHQgYmFzZWQgb24gdGhlXG4gKiBhcmd1bWVudHMgcHJvdmlkZWQgdG8gdGhlIG1lbW9pemVkIGZ1bmN0aW9uLiBCeSBkZWZhdWx0LCB0aGUgZmlyc3QgYXJndW1lbnRcbiAqIHByb3ZpZGVkIHRvIHRoZSBtZW1vaXplZCBmdW5jdGlvbiBpcyB1c2VkIGFzIHRoZSBtYXAgY2FjaGUga2V5LiBUaGUgYGZ1bmNgXG4gKiBpcyBpbnZva2VkIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIHRoZSBtZW1vaXplZCBmdW5jdGlvbi5cbiAqXG4gKiAqKk5vdGU6KiogVGhlIGNhY2hlIGlzIGV4cG9zZWQgYXMgdGhlIGBjYWNoZWAgcHJvcGVydHkgb24gdGhlIG1lbW9pemVkXG4gKiBmdW5jdGlvbi4gSXRzIGNyZWF0aW9uIG1heSBiZSBjdXN0b21pemVkIGJ5IHJlcGxhY2luZyB0aGUgYF8ubWVtb2l6ZS5DYWNoZWBcbiAqIGNvbnN0cnVjdG9yIHdpdGggb25lIHdob3NlIGluc3RhbmNlcyBpbXBsZW1lbnQgdGhlXG4gKiBbYE1hcGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXByb3BlcnRpZXMtb2YtdGhlLW1hcC1wcm90b3R5cGUtb2JqZWN0KVxuICogbWV0aG9kIGludGVyZmFjZSBvZiBgY2xlYXJgLCBgZGVsZXRlYCwgYGdldGAsIGBoYXNgLCBhbmQgYHNldGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBoYXZlIGl0cyBvdXRwdXQgbWVtb2l6ZWQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmVzb2x2ZXJdIFRoZSBmdW5jdGlvbiB0byByZXNvbHZlIHRoZSBjYWNoZSBrZXkuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBtZW1vaXplZCBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6IDIgfTtcbiAqIHZhciBvdGhlciA9IHsgJ2MnOiAzLCAnZCc6IDQgfTtcbiAqXG4gKiB2YXIgdmFsdWVzID0gXy5tZW1vaXplKF8udmFsdWVzKTtcbiAqIHZhbHVlcyhvYmplY3QpO1xuICogLy8gPT4gWzEsIDJdXG4gKlxuICogdmFsdWVzKG90aGVyKTtcbiAqIC8vID0+IFszLCA0XVxuICpcbiAqIG9iamVjdC5hID0gMjtcbiAqIHZhbHVlcyhvYmplY3QpO1xuICogLy8gPT4gWzEsIDJdXG4gKlxuICogLy8gTW9kaWZ5IHRoZSByZXN1bHQgY2FjaGUuXG4gKiB2YWx1ZXMuY2FjaGUuc2V0KG9iamVjdCwgWydhJywgJ2InXSk7XG4gKiB2YWx1ZXMob2JqZWN0KTtcbiAqIC8vID0+IFsnYScsICdiJ11cbiAqXG4gKiAvLyBSZXBsYWNlIGBfLm1lbW9pemUuQ2FjaGVgLlxuICogXy5tZW1vaXplLkNhY2hlID0gV2Vha01hcDtcbiAqL1xuZnVuY3Rpb24gbWVtb2l6ZShmdW5jLCByZXNvbHZlcikge1xuICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJyB8fCAocmVzb2x2ZXIgIT0gbnVsbCAmJiB0eXBlb2YgcmVzb2x2ZXIgIT0gJ2Z1bmN0aW9uJykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gIH1cbiAgdmFyIG1lbW9pemVkID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgIGtleSA9IHJlc29sdmVyID8gcmVzb2x2ZXIuYXBwbHkodGhpcywgYXJncykgOiBhcmdzWzBdLFxuICAgICAgICBjYWNoZSA9IG1lbW9pemVkLmNhY2hlO1xuXG4gICAgaWYgKGNhY2hlLmhhcyhrZXkpKSB7XG4gICAgICByZXR1cm4gY2FjaGUuZ2V0KGtleSk7XG4gICAgfVxuICAgIHZhciByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIG1lbW9pemVkLmNhY2hlID0gY2FjaGUuc2V0KGtleSwgcmVzdWx0KSB8fCBjYWNoZTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuICBtZW1vaXplZC5jYWNoZSA9IG5ldyAobWVtb2l6ZS5DYWNoZSB8fCBfTWFwQ2FjaGUpO1xuICByZXR1cm4gbWVtb2l6ZWQ7XG59XG5cbi8vIEV4cG9zZSBgTWFwQ2FjaGVgLlxubWVtb2l6ZS5DYWNoZSA9IF9NYXBDYWNoZTtcblxudmFyIG1lbW9pemVfMSA9IG1lbW9pemU7XG5cbi8qKiBVc2VkIGFzIHRoZSBtYXhpbXVtIG1lbW9pemUgY2FjaGUgc2l6ZS4gKi9cbnZhciBNQVhfTUVNT0laRV9TSVpFID0gNTAwO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5tZW1vaXplYCB3aGljaCBjbGVhcnMgdGhlIG1lbW9pemVkIGZ1bmN0aW9uJ3NcbiAqIGNhY2hlIHdoZW4gaXQgZXhjZWVkcyBgTUFYX01FTU9JWkVfU0laRWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGhhdmUgaXRzIG91dHB1dCBtZW1vaXplZC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IG1lbW9pemVkIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBtZW1vaXplQ2FwcGVkKGZ1bmMpIHtcbiAgdmFyIHJlc3VsdCA9IG1lbW9pemVfMShmdW5jLCBmdW5jdGlvbihrZXkpIHtcbiAgICBpZiAoY2FjaGUuc2l6ZSA9PT0gTUFYX01FTU9JWkVfU0laRSkge1xuICAgICAgY2FjaGUuY2xlYXIoKTtcbiAgICB9XG4gICAgcmV0dXJuIGtleTtcbiAgfSk7XG5cbiAgdmFyIGNhY2hlID0gcmVzdWx0LmNhY2hlO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG52YXIgX21lbW9pemVDYXBwZWQgPSBtZW1vaXplQ2FwcGVkO1xuXG4vKiogVXNlZCB0byBtYXRjaCBwcm9wZXJ0eSBuYW1lcyB3aXRoaW4gcHJvcGVydHkgcGF0aHMuICovXG52YXIgcmVQcm9wTmFtZSA9IC9bXi5bXFxdXSt8XFxbKD86KC0/XFxkKyg/OlxcLlxcZCspPyl8KFtcIiddKSgoPzooPyFcXDIpW15cXFxcXXxcXFxcLikqPylcXDIpXFxdfCg/PSg/OlxcLnxcXFtcXF0pKD86XFwufFxcW1xcXXwkKSkvZztcblxuLyoqIFVzZWQgdG8gbWF0Y2ggYmFja3NsYXNoZXMgaW4gcHJvcGVydHkgcGF0aHMuICovXG52YXIgcmVFc2NhcGVDaGFyID0gL1xcXFwoXFxcXCk/L2c7XG5cbi8qKlxuICogQ29udmVydHMgYHN0cmluZ2AgdG8gYSBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAqL1xudmFyIHN0cmluZ1RvUGF0aCA9IF9tZW1vaXplQ2FwcGVkKGZ1bmN0aW9uKHN0cmluZykge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIGlmIChzdHJpbmcuY2hhckNvZGVBdCgwKSA9PT0gNDYgLyogLiAqLykge1xuICAgIHJlc3VsdC5wdXNoKCcnKTtcbiAgfVxuICBzdHJpbmcucmVwbGFjZShyZVByb3BOYW1lLCBmdW5jdGlvbihtYXRjaCwgbnVtYmVyLCBxdW90ZSwgc3ViU3RyaW5nKSB7XG4gICAgcmVzdWx0LnB1c2gocXVvdGUgPyBzdWJTdHJpbmcucmVwbGFjZShyZUVzY2FwZUNoYXIsICckMScpIDogKG51bWJlciB8fCBtYXRjaCkpO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn0pO1xuXG52YXIgX3N0cmluZ1RvUGF0aCA9IHN0cmluZ1RvUGF0aDtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ubWFwYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWVcbiAqIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBtYXBwZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGFycmF5TWFwKGFycmF5LCBpdGVyYXRlZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHJlc3VsdFtpbmRleF0gPSBpdGVyYXRlZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxudmFyIF9hcnJheU1hcCA9IGFycmF5TWFwO1xuXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBJTkZJTklUWSQxID0gMSAvIDA7XG5cbi8qKiBVc2VkIHRvIGNvbnZlcnQgc3ltYm9scyB0byBwcmltaXRpdmVzIGFuZCBzdHJpbmdzLiAqL1xudmFyIHN5bWJvbFByb3RvID0gX1N5bWJvbCA/IF9TeW1ib2wucHJvdG90eXBlIDogdW5kZWZpbmVkLFxuICAgIHN5bWJvbFRvU3RyaW5nID0gc3ltYm9sUHJvdG8gPyBzeW1ib2xQcm90by50b1N0cmluZyA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50b1N0cmluZ2Agd2hpY2ggZG9lc24ndCBjb252ZXJ0IG51bGxpc2hcbiAqIHZhbHVlcyB0byBlbXB0eSBzdHJpbmdzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm9jZXNzLlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBiYXNlVG9TdHJpbmcodmFsdWUpIHtcbiAgLy8gRXhpdCBlYXJseSBmb3Igc3RyaW5ncyB0byBhdm9pZCBhIHBlcmZvcm1hbmNlIGhpdCBpbiBzb21lIGVudmlyb25tZW50cy5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAoaXNBcnJheV8xKHZhbHVlKSkge1xuICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbnZlcnQgdmFsdWVzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgcmV0dXJuIF9hcnJheU1hcCh2YWx1ZSwgYmFzZVRvU3RyaW5nKSArICcnO1xuICB9XG4gIGlmIChpc1N5bWJvbF8xKHZhbHVlKSkge1xuICAgIHJldHVybiBzeW1ib2xUb1N0cmluZyA/IHN5bWJvbFRvU3RyaW5nLmNhbGwodmFsdWUpIDogJyc7XG4gIH1cbiAgdmFyIHJlc3VsdCA9ICh2YWx1ZSArICcnKTtcbiAgcmV0dXJuIChyZXN1bHQgPT0gJzAnICYmICgxIC8gdmFsdWUpID09IC1JTkZJTklUWSQxKSA/ICctMCcgOiByZXN1bHQ7XG59XG5cbnZhciBfYmFzZVRvU3RyaW5nID0gYmFzZVRvU3RyaW5nO1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcuIEFuIGVtcHR5IHN0cmluZyBpcyByZXR1cm5lZCBmb3IgYG51bGxgXG4gKiBhbmQgYHVuZGVmaW5lZGAgdmFsdWVzLiBUaGUgc2lnbiBvZiBgLTBgIGlzIHByZXNlcnZlZC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBzdHJpbmcuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udG9TdHJpbmcobnVsbCk7XG4gKiAvLyA9PiAnJ1xuICpcbiAqIF8udG9TdHJpbmcoLTApO1xuICogLy8gPT4gJy0wJ1xuICpcbiAqIF8udG9TdHJpbmcoWzEsIDIsIDNdKTtcbiAqIC8vID0+ICcxLDIsMydcbiAqL1xuZnVuY3Rpb24gdG9TdHJpbmckMSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT0gbnVsbCA/ICcnIDogX2Jhc2VUb1N0cmluZyh2YWx1ZSk7XG59XG5cbnZhciB0b1N0cmluZ18xID0gdG9TdHJpbmckMTtcblxuLyoqXG4gKiBDYXN0cyBgdmFsdWVgIHRvIGEgcGF0aCBhcnJheSBpZiBpdCdzIG5vdCBvbmUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeSBrZXlzIG9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBjYXN0IHByb3BlcnR5IHBhdGggYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGNhc3RQYXRoKHZhbHVlLCBvYmplY3QpIHtcbiAgaWYgKGlzQXJyYXlfMSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIF9pc0tleSh2YWx1ZSwgb2JqZWN0KSA/IFt2YWx1ZV0gOiBfc3RyaW5nVG9QYXRoKHRvU3RyaW5nXzEodmFsdWUpKTtcbn1cblxudmFyIF9jYXN0UGF0aCA9IGNhc3RQYXRoO1xuXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBJTkZJTklUWSA9IDEgLyAwO1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcga2V5IGlmIGl0J3Mgbm90IGEgc3RyaW5nIG9yIHN5bWJvbC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cbiAqIEByZXR1cm5zIHtzdHJpbmd8c3ltYm9sfSBSZXR1cm5zIHRoZSBrZXkuXG4gKi9cbmZ1bmN0aW9uIHRvS2V5KHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycgfHwgaXNTeW1ib2xfMSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgdmFyIHJlc3VsdCA9ICh2YWx1ZSArICcnKTtcbiAgcmV0dXJuIChyZXN1bHQgPT0gJzAnICYmICgxIC8gdmFsdWUpID09IC1JTkZJTklUWSkgPyAnLTAnIDogcmVzdWx0O1xufVxuXG52YXIgX3RvS2V5ID0gdG9LZXk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZ2V0YCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZmF1bHQgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc29sdmVkIHZhbHVlLlxuICovXG5mdW5jdGlvbiBiYXNlR2V0KG9iamVjdCwgcGF0aCkge1xuICBwYXRoID0gX2Nhc3RQYXRoKHBhdGgsIG9iamVjdCk7XG5cbiAgdmFyIGluZGV4ID0gMCxcbiAgICAgIGxlbmd0aCA9IHBhdGgubGVuZ3RoO1xuXG4gIHdoaWxlIChvYmplY3QgIT0gbnVsbCAmJiBpbmRleCA8IGxlbmd0aCkge1xuICAgIG9iamVjdCA9IG9iamVjdFtfdG9LZXkocGF0aFtpbmRleCsrXSldO1xuICB9XG4gIHJldHVybiAoaW5kZXggJiYgaW5kZXggPT0gbGVuZ3RoKSA/IG9iamVjdCA6IHVuZGVmaW5lZDtcbn1cblxudmFyIF9iYXNlR2V0ID0gYmFzZUdldDtcblxuLyoqXG4gKiBHZXRzIHRoZSB2YWx1ZSBhdCBgcGF0aGAgb2YgYG9iamVjdGAuIElmIHRoZSByZXNvbHZlZCB2YWx1ZSBpc1xuICogYHVuZGVmaW5lZGAsIHRoZSBgZGVmYXVsdFZhbHVlYCBpcyByZXR1cm5lZCBpbiBpdHMgcGxhY2UuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjcuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEBwYXJhbSB7Kn0gW2RlZmF1bHRWYWx1ZV0gVGhlIHZhbHVlIHJldHVybmVkIGZvciBgdW5kZWZpbmVkYCByZXNvbHZlZCB2YWx1ZXMuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzb2x2ZWQgdmFsdWUuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogW3sgJ2InOiB7ICdjJzogMyB9IH1dIH07XG4gKlxuICogXy5nZXQob2JqZWN0LCAnYVswXS5iLmMnKTtcbiAqIC8vID0+IDNcbiAqXG4gKiBfLmdldChvYmplY3QsIFsnYScsICcwJywgJ2InLCAnYyddKTtcbiAqIC8vID0+IDNcbiAqXG4gKiBfLmdldChvYmplY3QsICdhLmIuYycsICdkZWZhdWx0Jyk7XG4gKiAvLyA9PiAnZGVmYXVsdCdcbiAqL1xuZnVuY3Rpb24gZ2V0KG9iamVjdCwgcGF0aCwgZGVmYXVsdFZhbHVlKSB7XG4gIHZhciByZXN1bHQgPSBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IF9iYXNlR2V0KG9iamVjdCwgcGF0aCk7XG4gIHJldHVybiByZXN1bHQgPT09IHVuZGVmaW5lZCA/IGRlZmF1bHRWYWx1ZSA6IHJlc3VsdDtcbn1cblxudmFyIGdldF8xID0gZ2V0O1xuXG52YXIgZGVmaW5lUHJvcGVydHkgPSAoZnVuY3Rpb24oKSB7XG4gIHRyeSB7XG4gICAgdmFyIGZ1bmMgPSBfZ2V0TmF0aXZlKE9iamVjdCwgJ2RlZmluZVByb3BlcnR5Jyk7XG4gICAgZnVuYyh7fSwgJycsIHt9KTtcbiAgICByZXR1cm4gZnVuYztcbiAgfSBjYXRjaCAoZSkge31cbn0oKSk7XG5cbnZhciBfZGVmaW5lUHJvcGVydHkgPSBkZWZpbmVQcm9wZXJ0eTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgYXNzaWduVmFsdWVgIGFuZCBgYXNzaWduTWVyZ2VWYWx1ZWAgd2l0aG91dFxuICogdmFsdWUgY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBhc3NpZ24uXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBhc3NpZ24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgaWYgKGtleSA9PSAnX19wcm90b19fJyAmJiBfZGVmaW5lUHJvcGVydHkpIHtcbiAgICBfZGVmaW5lUHJvcGVydHkob2JqZWN0LCBrZXksIHtcbiAgICAgICdjb25maWd1cmFibGUnOiB0cnVlLFxuICAgICAgJ2VudW1lcmFibGUnOiB0cnVlLFxuICAgICAgJ3ZhbHVlJzogdmFsdWUsXG4gICAgICAnd3JpdGFibGUnOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgfVxufVxuXG52YXIgX2Jhc2VBc3NpZ25WYWx1ZSA9IGJhc2VBc3NpZ25WYWx1ZTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBBc3NpZ25zIGB2YWx1ZWAgdG8gYGtleWAgb2YgYG9iamVjdGAgaWYgdGhlIGV4aXN0aW5nIHZhbHVlIGlzIG5vdCBlcXVpdmFsZW50XG4gKiB1c2luZyBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICogZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBhc3NpZ24uXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBhc3NpZ24uXG4gKi9cbmZ1bmN0aW9uIGFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICB2YXIgb2JqVmFsdWUgPSBvYmplY3Rba2V5XTtcbiAgaWYgKCEoaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkgJiYgZXFfMShvYmpWYWx1ZSwgdmFsdWUpKSB8fFxuICAgICAgKHZhbHVlID09PSB1bmRlZmluZWQgJiYgIShrZXkgaW4gb2JqZWN0KSkpIHtcbiAgICBfYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSk7XG4gIH1cbn1cblxudmFyIF9hc3NpZ25WYWx1ZSA9IGFzc2lnblZhbHVlO1xuXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IHVuc2lnbmVkIGludGVnZXIgdmFsdWVzLiAqL1xudmFyIHJlSXNVaW50ID0gL14oPzowfFsxLTldXFxkKikkLztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgaW5kZXguXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGg9TUFYX1NBRkVfSU5URUdFUl0gVGhlIHVwcGVyIGJvdW5kcyBvZiBhIHZhbGlkIGluZGV4LlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBpbmRleCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0luZGV4KHZhbHVlLCBsZW5ndGgpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIGxlbmd0aCA9IGxlbmd0aCA9PSBudWxsID8gTUFYX1NBRkVfSU5URUdFUiA6IGxlbmd0aDtcblxuICByZXR1cm4gISFsZW5ndGggJiZcbiAgICAodHlwZSA9PSAnbnVtYmVyJyB8fFxuICAgICAgKHR5cGUgIT0gJ3N5bWJvbCcgJiYgcmVJc1VpbnQudGVzdCh2YWx1ZSkpKSAmJlxuICAgICAgICAodmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8IGxlbmd0aCk7XG59XG5cbnZhciBfaXNJbmRleCA9IGlzSW5kZXg7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc2V0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBwYXRoIGNyZWF0aW9uLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gYmFzZVNldChvYmplY3QsIHBhdGgsIHZhbHVlLCBjdXN0b21pemVyKSB7XG4gIGlmICghaXNPYmplY3RfMShvYmplY3QpKSB7XG4gICAgcmV0dXJuIG9iamVjdDtcbiAgfVxuICBwYXRoID0gX2Nhc3RQYXRoKHBhdGgsIG9iamVjdCk7XG5cbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBwYXRoLmxlbmd0aCxcbiAgICAgIGxhc3RJbmRleCA9IGxlbmd0aCAtIDEsXG4gICAgICBuZXN0ZWQgPSBvYmplY3Q7XG5cbiAgd2hpbGUgKG5lc3RlZCAhPSBudWxsICYmICsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIga2V5ID0gX3RvS2V5KHBhdGhbaW5kZXhdKSxcbiAgICAgICAgbmV3VmFsdWUgPSB2YWx1ZTtcblxuICAgIGlmIChrZXkgPT09ICdfX3Byb3RvX18nIHx8IGtleSA9PT0gJ2NvbnN0cnVjdG9yJyB8fCBrZXkgPT09ICdwcm90b3R5cGUnKSB7XG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH1cblxuICAgIGlmIChpbmRleCAhPSBsYXN0SW5kZXgpIHtcbiAgICAgIHZhciBvYmpWYWx1ZSA9IG5lc3RlZFtrZXldO1xuICAgICAgbmV3VmFsdWUgPSBjdXN0b21pemVyID8gY3VzdG9taXplcihvYmpWYWx1ZSwga2V5LCBuZXN0ZWQpIDogdW5kZWZpbmVkO1xuICAgICAgaWYgKG5ld1ZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbmV3VmFsdWUgPSBpc09iamVjdF8xKG9ialZhbHVlKVxuICAgICAgICAgID8gb2JqVmFsdWVcbiAgICAgICAgICA6IChfaXNJbmRleChwYXRoW2luZGV4ICsgMV0pID8gW10gOiB7fSk7XG4gICAgICB9XG4gICAgfVxuICAgIF9hc3NpZ25WYWx1ZShuZXN0ZWQsIGtleSwgbmV3VmFsdWUpO1xuICAgIG5lc3RlZCA9IG5lc3RlZFtrZXldO1xuICB9XG4gIHJldHVybiBvYmplY3Q7XG59XG5cbnZhciBfYmFzZVNldCA9IGJhc2VTZXQ7XG5cbi8qKlxuICogU2V0cyB0aGUgdmFsdWUgYXQgYHBhdGhgIG9mIGBvYmplY3RgLiBJZiBhIHBvcnRpb24gb2YgYHBhdGhgIGRvZXNuJ3QgZXhpc3QsXG4gKiBpdCdzIGNyZWF0ZWQuIEFycmF5cyBhcmUgY3JlYXRlZCBmb3IgbWlzc2luZyBpbmRleCBwcm9wZXJ0aWVzIHdoaWxlIG9iamVjdHNcbiAqIGFyZSBjcmVhdGVkIGZvciBhbGwgb3RoZXIgbWlzc2luZyBwcm9wZXJ0aWVzLiBVc2UgYF8uc2V0V2l0aGAgdG8gY3VzdG9taXplXG4gKiBgcGF0aGAgY3JlYXRpb24uXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjcuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IFt7ICdiJzogeyAnYyc6IDMgfSB9XSB9O1xuICpcbiAqIF8uc2V0KG9iamVjdCwgJ2FbMF0uYi5jJywgNCk7XG4gKiBjb25zb2xlLmxvZyhvYmplY3QuYVswXS5iLmMpO1xuICogLy8gPT4gNFxuICpcbiAqIF8uc2V0KG9iamVjdCwgWyd4JywgJzAnLCAneScsICd6J10sIDUpO1xuICogY29uc29sZS5sb2cob2JqZWN0LnhbMF0ueS56KTtcbiAqIC8vID0+IDVcbiAqL1xuZnVuY3Rpb24gc2V0KG9iamVjdCwgcGF0aCwgdmFsdWUpIHtcbiAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gb2JqZWN0IDogX2Jhc2VTZXQob2JqZWN0LCBwYXRoLCB2YWx1ZSk7XG59XG5cbnZhciBzZXRfMSA9IHNldDtcblxuLyoqXG4gKiBDb3BpZXMgdGhlIHZhbHVlcyBvZiBgc291cmNlYCB0byBgYXJyYXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBzb3VyY2UgVGhlIGFycmF5IHRvIGNvcHkgdmFsdWVzIGZyb20uXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXk9W11dIFRoZSBhcnJheSB0byBjb3B5IHZhbHVlcyB0by5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICovXG5mdW5jdGlvbiBjb3B5QXJyYXkoc291cmNlLCBhcnJheSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHNvdXJjZS5sZW5ndGg7XG5cbiAgYXJyYXkgfHwgKGFycmF5ID0gQXJyYXkobGVuZ3RoKSk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgYXJyYXlbaW5kZXhdID0gc291cmNlW2luZGV4XTtcbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbnZhciBfY29weUFycmF5ID0gY29weUFycmF5O1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50b1BhdGgoJ2EuYi5jJyk7XG4gKiAvLyA9PiBbJ2EnLCAnYicsICdjJ11cbiAqXG4gKiBfLnRvUGF0aCgnYVswXS5iLmMnKTtcbiAqIC8vID0+IFsnYScsICcwJywgJ2InLCAnYyddXG4gKi9cbmZ1bmN0aW9uIHRvUGF0aCh2YWx1ZSkge1xuICBpZiAoaXNBcnJheV8xKHZhbHVlKSkge1xuICAgIHJldHVybiBfYXJyYXlNYXAodmFsdWUsIF90b0tleSk7XG4gIH1cbiAgcmV0dXJuIGlzU3ltYm9sXzEodmFsdWUpID8gW3ZhbHVlXSA6IF9jb3B5QXJyYXkoX3N0cmluZ1RvUGF0aCh0b1N0cmluZ18xKHZhbHVlKSkpO1xufVxuXG52YXIgdG9QYXRoXzEgPSB0b1BhdGg7XG5cbnZhciBkZWZpbmUkMiA9IHtcbiAgLy8gYWNjZXNzIGRhdGEgZmllbGRcbiAgZGF0YTogZnVuY3Rpb24gZGF0YShwYXJhbXMpIHtcbiAgICB2YXIgZGVmYXVsdHMgPSB7XG4gICAgICBmaWVsZDogJ2RhdGEnLFxuICAgICAgYmluZGluZ0V2ZW50OiAnZGF0YScsXG4gICAgICBhbGxvd0JpbmRpbmc6IGZhbHNlLFxuICAgICAgYWxsb3dTZXR0aW5nOiBmYWxzZSxcbiAgICAgIGFsbG93R2V0dGluZzogZmFsc2UsXG4gICAgICBzZXR0aW5nRXZlbnQ6ICdkYXRhJyxcbiAgICAgIHNldHRpbmdUcmlnZ2Vyc0V2ZW50OiBmYWxzZSxcbiAgICAgIHRyaWdnZXJGbk5hbWU6ICd0cmlnZ2VyJyxcbiAgICAgIGltbXV0YWJsZUtleXM6IHt9LFxuICAgICAgLy8ga2V5ID0+IHRydWUgaWYgaW1tdXRhYmxlXG4gICAgICB1cGRhdGVTdHlsZTogZmFsc2UsXG4gICAgICBiZWZvcmVHZXQ6IGZ1bmN0aW9uIGJlZm9yZUdldChzZWxmKSB7fSxcbiAgICAgIGJlZm9yZVNldDogZnVuY3Rpb24gYmVmb3JlU2V0KHNlbGYsIG9iaikge30sXG4gICAgICBvblNldDogZnVuY3Rpb24gb25TZXQoc2VsZikge30sXG4gICAgICBjYW5TZXQ6IGZ1bmN0aW9uIGNhblNldChzZWxmKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH07XG4gICAgcGFyYW1zID0gZXh0ZW5kKHt9LCBkZWZhdWx0cywgcGFyYW1zKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gZGF0YUltcGwobmFtZSwgdmFsdWUpIHtcbiAgICAgIHZhciBwID0gcGFyYW1zO1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIHNlbGZJc0FycmF5TGlrZSA9IHNlbGYubGVuZ3RoICE9PSB1bmRlZmluZWQ7XG4gICAgICB2YXIgYWxsID0gc2VsZklzQXJyYXlMaWtlID8gc2VsZiA6IFtzZWxmXTsgLy8gcHV0IGluIGFycmF5IGlmIG5vdCBhcnJheS1saWtlXG4gICAgICB2YXIgc2luZ2xlID0gc2VsZklzQXJyYXlMaWtlID8gc2VsZlswXSA6IHNlbGY7XG5cbiAgICAgIC8vIC5kYXRhKCdmb28nLCAuLi4pXG4gICAgICBpZiAoc3RyaW5nKG5hbWUpKSB7XG4gICAgICAgIC8vIHNldCBvciBnZXQgcHJvcGVydHlcbiAgICAgICAgdmFyIGlzUGF0aExpa2UgPSBuYW1lLmluZGV4T2YoJy4nKSAhPT0gLTE7IC8vIHRoZXJlIG1pZ2h0IGJlIGEgbm9ybWFsIGZpZWxkIHdpdGggYSBkb3QgXG4gICAgICAgIHZhciBwYXRoID0gaXNQYXRoTGlrZSAmJiB0b1BhdGhfMShuYW1lKTtcblxuICAgICAgICAvLyAuZGF0YSgnZm9vJylcbiAgICAgICAgaWYgKHAuYWxsb3dHZXR0aW5nICYmIHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAvLyBnZXRcblxuICAgICAgICAgIHZhciByZXQ7XG4gICAgICAgICAgaWYgKHNpbmdsZSkge1xuICAgICAgICAgICAgcC5iZWZvcmVHZXQoc2luZ2xlKTtcblxuICAgICAgICAgICAgLy8gY2hlY2sgaWYgaXQncyBwYXRoIGFuZCBhIGZpZWxkIHdpdGggdGhlIHNhbWUgbmFtZSBkb2Vzbid0IGV4aXN0XG4gICAgICAgICAgICBpZiAocGF0aCAmJiBzaW5nbGUuX3ByaXZhdGVbcC5maWVsZF1bbmFtZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICByZXQgPSBnZXRfMShzaW5nbGUuX3ByaXZhdGVbcC5maWVsZF0sIHBhdGgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0ID0gc2luZ2xlLl9wcml2YXRlW3AuZmllbGRdW25hbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmV0O1xuXG4gICAgICAgICAgLy8gLmRhdGEoJ2ZvbycsICdiYXInKVxuICAgICAgICB9IGVsc2UgaWYgKHAuYWxsb3dTZXR0aW5nICYmIHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAvLyBzZXRcbiAgICAgICAgICB2YXIgdmFsaWQgPSAhcC5pbW11dGFibGVLZXlzW25hbWVdO1xuICAgICAgICAgIGlmICh2YWxpZCkge1xuICAgICAgICAgICAgdmFyIGNoYW5nZSA9IF9kZWZpbmVQcm9wZXJ0eSQxKHt9LCBuYW1lLCB2YWx1ZSk7XG4gICAgICAgICAgICBwLmJlZm9yZVNldChzZWxmLCBjaGFuZ2UpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBhbGwubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgIHZhciBlbGUgPSBhbGxbaV07XG4gICAgICAgICAgICAgIGlmIChwLmNhblNldChlbGUpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBhdGggJiYgc2luZ2xlLl9wcml2YXRlW3AuZmllbGRdW25hbWVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgIHNldF8xKGVsZS5fcHJpdmF0ZVtwLmZpZWxkXSwgcGF0aCwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBlbGUuX3ByaXZhdGVbcC5maWVsZF1bbmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gdXBkYXRlIG1hcHBlcnMgaWYgYXNrZWRcbiAgICAgICAgICAgIGlmIChwLnVwZGF0ZVN0eWxlKSB7XG4gICAgICAgICAgICAgIHNlbGYudXBkYXRlU3R5bGUoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gY2FsbCBvblNldCBjYWxsYmFja1xuICAgICAgICAgICAgcC5vblNldChzZWxmKTtcbiAgICAgICAgICAgIGlmIChwLnNldHRpbmdUcmlnZ2Vyc0V2ZW50KSB7XG4gICAgICAgICAgICAgIHNlbGZbcC50cmlnZ2VyRm5OYW1lXShwLnNldHRpbmdFdmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gLmRhdGEoeyAnZm9vJzogJ2JhcicgfSlcbiAgICAgIH0gZWxzZSBpZiAocC5hbGxvd1NldHRpbmcgJiYgcGxhaW5PYmplY3QobmFtZSkpIHtcbiAgICAgICAgLy8gZXh0ZW5kXG4gICAgICAgIHZhciBvYmogPSBuYW1lO1xuICAgICAgICB2YXIgaywgdjtcbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICAgICAgICBwLmJlZm9yZVNldChzZWxmLCBvYmopO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwga2V5cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICBrID0ga2V5c1tfaV07XG4gICAgICAgICAgdiA9IG9ialtrXTtcbiAgICAgICAgICB2YXIgX3ZhbGlkID0gIXAuaW1tdXRhYmxlS2V5c1trXTtcbiAgICAgICAgICBpZiAoX3ZhbGlkKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGFsbC5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICB2YXIgX2VsZSA9IGFsbFtqXTtcbiAgICAgICAgICAgICAgaWYgKHAuY2FuU2V0KF9lbGUpKSB7XG4gICAgICAgICAgICAgICAgX2VsZS5fcHJpdmF0ZVtwLmZpZWxkXVtrXSA9IHY7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyB1cGRhdGUgbWFwcGVycyBpZiBhc2tlZFxuICAgICAgICBpZiAocC51cGRhdGVTdHlsZSkge1xuICAgICAgICAgIHNlbGYudXBkYXRlU3R5bGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNhbGwgb25TZXQgY2FsbGJhY2tcbiAgICAgICAgcC5vblNldChzZWxmKTtcbiAgICAgICAgaWYgKHAuc2V0dGluZ1RyaWdnZXJzRXZlbnQpIHtcbiAgICAgICAgICBzZWxmW3AudHJpZ2dlckZuTmFtZV0ocC5zZXR0aW5nRXZlbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gLmRhdGEoZnVuY3Rpb24oKXsgLi4uIH0pXG4gICAgICB9IGVsc2UgaWYgKHAuYWxsb3dCaW5kaW5nICYmIGZuJDYobmFtZSkpIHtcbiAgICAgICAgLy8gYmluZCB0byBldmVudFxuICAgICAgICB2YXIgZm4gPSBuYW1lO1xuICAgICAgICBzZWxmLm9uKHAuYmluZGluZ0V2ZW50LCBmbik7XG5cbiAgICAgICAgLy8gLmRhdGEoKVxuICAgICAgfSBlbHNlIGlmIChwLmFsbG93R2V0dGluZyAmJiBuYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gZ2V0IHdob2xlIG9iamVjdFxuICAgICAgICB2YXIgX3JldDtcbiAgICAgICAgaWYgKHNpbmdsZSkge1xuICAgICAgICAgIHAuYmVmb3JlR2V0KHNpbmdsZSk7XG4gICAgICAgICAgX3JldCA9IHNpbmdsZS5fcHJpdmF0ZVtwLmZpZWxkXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3JldDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzZWxmOyAvLyBtYWludGFpbiBjaGFpbmFiaWxpdHlcbiAgICB9OyAvLyBmdW5jdGlvblxuICB9LFxuXG4gIC8vIGRhdGFcblxuICAvLyByZW1vdmUgZGF0YSBmaWVsZFxuICByZW1vdmVEYXRhOiBmdW5jdGlvbiByZW1vdmVEYXRhKHBhcmFtcykge1xuICAgIHZhciBkZWZhdWx0cyA9IHtcbiAgICAgIGZpZWxkOiAnZGF0YScsXG4gICAgICBldmVudDogJ2RhdGEnLFxuICAgICAgdHJpZ2dlckZuTmFtZTogJ3RyaWdnZXInLFxuICAgICAgdHJpZ2dlckV2ZW50OiBmYWxzZSxcbiAgICAgIGltbXV0YWJsZUtleXM6IHt9IC8vIGtleSA9PiB0cnVlIGlmIGltbXV0YWJsZVxuICAgIH07XG5cbiAgICBwYXJhbXMgPSBleHRlbmQoe30sIGRlZmF1bHRzLCBwYXJhbXMpO1xuICAgIHJldHVybiBmdW5jdGlvbiByZW1vdmVEYXRhSW1wbChuYW1lcykge1xuICAgICAgdmFyIHAgPSBwYXJhbXM7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgc2VsZklzQXJyYXlMaWtlID0gc2VsZi5sZW5ndGggIT09IHVuZGVmaW5lZDtcbiAgICAgIHZhciBhbGwgPSBzZWxmSXNBcnJheUxpa2UgPyBzZWxmIDogW3NlbGZdOyAvLyBwdXQgaW4gYXJyYXkgaWYgbm90IGFycmF5LWxpa2VcblxuICAgICAgLy8gLnJlbW92ZURhdGEoJ2ZvbyBiYXInKVxuICAgICAgaWYgKHN0cmluZyhuYW1lcykpIHtcbiAgICAgICAgLy8gdGhlbiBnZXQgdGhlIGxpc3Qgb2Yga2V5cywgYW5kIGRlbGV0ZSB0aGVtXG4gICAgICAgIHZhciBrZXlzID0gbmFtZXMuc3BsaXQoL1xccysvKTtcbiAgICAgICAgdmFyIGwgPSBrZXlzLmxlbmd0aDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAvLyBkZWxldGUgZWFjaCBub24tZW1wdHkga2V5XG4gICAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgaWYgKGVtcHR5U3RyaW5nKGtleSkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgdmFsaWQgPSAhcC5pbW11dGFibGVLZXlzW2tleV07IC8vIG5vdCB2YWxpZCBpZiBpbW11dGFibGVcbiAgICAgICAgICBpZiAodmFsaWQpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGlfYSA9IDAsIGxfYSA9IGFsbC5sZW5ndGg7IGlfYSA8IGxfYTsgaV9hKyspIHtcbiAgICAgICAgICAgICAgYWxsW2lfYV0uX3ByaXZhdGVbcC5maWVsZF1ba2V5XSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHAudHJpZ2dlckV2ZW50KSB7XG4gICAgICAgICAgc2VsZltwLnRyaWdnZXJGbk5hbWVdKHAuZXZlbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gLnJlbW92ZURhdGEoKVxuICAgICAgfSBlbHNlIGlmIChuYW1lcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIHRoZW4gZGVsZXRlIGFsbCBrZXlzXG5cbiAgICAgICAgZm9yICh2YXIgX2lfYSA9IDAsIF9sX2EgPSBhbGwubGVuZ3RoOyBfaV9hIDwgX2xfYTsgX2lfYSsrKSB7XG4gICAgICAgICAgdmFyIF9wcml2YXRlRmllbGRzID0gYWxsW19pX2FdLl9wcml2YXRlW3AuZmllbGRdO1xuICAgICAgICAgIHZhciBfa2V5cyA9IE9iamVjdC5rZXlzKF9wcml2YXRlRmllbGRzKTtcbiAgICAgICAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBfa2V5cy5sZW5ndGg7IF9pMisrKSB7XG4gICAgICAgICAgICB2YXIgX2tleSA9IF9rZXlzW19pMl07XG4gICAgICAgICAgICB2YXIgdmFsaWRLZXlUb0RlbGV0ZSA9ICFwLmltbXV0YWJsZUtleXNbX2tleV07XG4gICAgICAgICAgICBpZiAodmFsaWRLZXlUb0RlbGV0ZSkge1xuICAgICAgICAgICAgICBfcHJpdmF0ZUZpZWxkc1tfa2V5XSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHAudHJpZ2dlckV2ZW50KSB7XG4gICAgICAgICAgc2VsZltwLnRyaWdnZXJGbk5hbWVdKHAuZXZlbnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gc2VsZjsgLy8gbWFpbnRhaW4gY2hhaW5pbmdcbiAgICB9OyAvLyBmdW5jdGlvblxuICB9IC8vIHJlbW92ZURhdGFcbn07IC8vIGRlZmluZVxuXG52YXIgZGVmaW5lJDEgPSB7XG4gIGV2ZW50QWxpYXNlc09uOiBmdW5jdGlvbiBldmVudEFsaWFzZXNPbihwcm90bykge1xuICAgIHZhciBwID0gcHJvdG87XG4gICAgcC5hZGRMaXN0ZW5lciA9IHAubGlzdGVuID0gcC5iaW5kID0gcC5vbjtcbiAgICBwLnVubGlzdGVuID0gcC51bmJpbmQgPSBwLm9mZiA9IHAucmVtb3ZlTGlzdGVuZXI7XG4gICAgcC50cmlnZ2VyID0gcC5lbWl0O1xuXG4gICAgLy8gdGhpcyBpcyBqdXN0IGEgd3JhcHBlciBhbGlhcyBvZiAub24oKVxuICAgIHAucG9uID0gcC5wcm9taXNlT24gPSBmdW5jdGlvbiAoZXZlbnRzLCBzZWxlY3Rvcikge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlJDEoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICB2YXIgY2FsbGJhY2sgPSBmdW5jdGlvbiBjYWxsYmFjayhlKSB7XG4gICAgICAgICAgc2VsZi5vZmYuYXBwbHkoc2VsZiwgb2ZmQXJncyk7XG4gICAgICAgICAgcmVzb2x2ZShlKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIG9uQXJncyA9IGFyZ3MuY29uY2F0KFtjYWxsYmFja10pO1xuICAgICAgICB2YXIgb2ZmQXJncyA9IG9uQXJncy5jb25jYXQoW10pO1xuICAgICAgICBzZWxmLm9uLmFwcGx5KHNlbGYsIG9uQXJncyk7XG4gICAgICB9KTtcbiAgICB9O1xuICB9XG59OyAvLyBkZWZpbmVcblxuLy8gdXNlIHRoaXMgbW9kdWxlIHRvIGNoZXJyeSBwaWNrIGZ1bmN0aW9ucyBpbnRvIHlvdXIgcHJvdG90eXBlXG52YXIgZGVmaW5lID0ge307XG5bZGVmaW5lJDMsIGRlZmluZSQyLCBkZWZpbmUkMV0uZm9yRWFjaChmdW5jdGlvbiAobSkge1xuICBleHRlbmQoZGVmaW5lLCBtKTtcbn0pO1xuXG52YXIgZWxlc2ZuJGkgPSB7XG4gIGFuaW1hdGU6IGRlZmluZS5hbmltYXRlKCksXG4gIGFuaW1hdGlvbjogZGVmaW5lLmFuaW1hdGlvbigpLFxuICBhbmltYXRlZDogZGVmaW5lLmFuaW1hdGVkKCksXG4gIGNsZWFyUXVldWU6IGRlZmluZS5jbGVhclF1ZXVlKCksXG4gIGRlbGF5OiBkZWZpbmUuZGVsYXkoKSxcbiAgZGVsYXlBbmltYXRpb246IGRlZmluZS5kZWxheUFuaW1hdGlvbigpLFxuICBzdG9wOiBkZWZpbmUuc3RvcCgpXG59O1xuXG52YXIgZWxlc2ZuJGggPSB7XG4gIGNsYXNzZXM6IGZ1bmN0aW9uIGNsYXNzZXMoX2NsYXNzZXMpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgaWYgKF9jbGFzc2VzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhciByZXQgPSBbXTtcbiAgICAgIHNlbGZbMF0uX3ByaXZhdGUuY2xhc3Nlcy5mb3JFYWNoKGZ1bmN0aW9uIChjbHMpIHtcbiAgICAgICAgcmV0dXJuIHJldC5wdXNoKGNscyk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXQ7XG4gICAgfSBlbHNlIGlmICghYXJyYXkoX2NsYXNzZXMpKSB7XG4gICAgICAvLyBleHRyYWN0IGNsYXNzZXMgZnJvbSBzdHJpbmdcbiAgICAgIF9jbGFzc2VzID0gKF9jbGFzc2VzIHx8ICcnKS5tYXRjaCgvXFxTKy9nKSB8fCBbXTtcbiAgICB9XG4gICAgdmFyIGNoYW5nZWQgPSBbXTtcbiAgICB2YXIgY2xhc3Nlc1NldCA9IG5ldyBTZXQkMShfY2xhc3Nlcyk7XG5cbiAgICAvLyBjaGVjayBhbmQgdXBkYXRlIGVhY2ggZWxlXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBzZWxmLmxlbmd0aDsgaisrKSB7XG4gICAgICB2YXIgZWxlID0gc2VsZltqXTtcbiAgICAgIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgICAgIHZhciBlbGVDbGFzc2VzID0gX3AuY2xhc3NlcztcbiAgICAgIHZhciBjaGFuZ2VkRWxlID0gZmFsc2U7XG5cbiAgICAgIC8vIGNoZWNrIGlmIGVsZSBoYXMgYWxsIG9mIHRoZSBwYXNzZWQgY2xhc3Nlc1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBfY2xhc3Nlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2xzID0gX2NsYXNzZXNbaV07XG4gICAgICAgIHZhciBlbGVIYXNDbGFzcyA9IGVsZUNsYXNzZXMuaGFzKGNscyk7XG4gICAgICAgIGlmICghZWxlSGFzQ2xhc3MpIHtcbiAgICAgICAgICBjaGFuZ2VkRWxlID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBjaGVjayBpZiBlbGUgaGFzIGNsYXNzZXMgb3V0c2lkZSBvZiB0aG9zZSBwYXNzZWRcbiAgICAgIGlmICghY2hhbmdlZEVsZSkge1xuICAgICAgICBjaGFuZ2VkRWxlID0gZWxlQ2xhc3Nlcy5zaXplICE9PSBfY2xhc3Nlcy5sZW5ndGg7XG4gICAgICB9XG4gICAgICBpZiAoY2hhbmdlZEVsZSkge1xuICAgICAgICBfcC5jbGFzc2VzID0gY2xhc3Nlc1NldDtcbiAgICAgICAgY2hhbmdlZC5wdXNoKGVsZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gdHJpZ2dlciB1cGRhdGUgc3R5bGUgb24gdGhvc2UgZWxlcyB0aGF0IGhhZCBjbGFzcyBjaGFuZ2VzXG4gICAgaWYgKGNoYW5nZWQubGVuZ3RoID4gMCkge1xuICAgICAgdGhpcy5zcGF3bihjaGFuZ2VkKS51cGRhdGVTdHlsZSgpLmVtaXQoJ2NsYXNzJyk7XG4gICAgfVxuICAgIHJldHVybiBzZWxmO1xuICB9LFxuICBhZGRDbGFzczogZnVuY3Rpb24gYWRkQ2xhc3MoY2xhc3Nlcykge1xuICAgIHJldHVybiB0aGlzLnRvZ2dsZUNsYXNzKGNsYXNzZXMsIHRydWUpO1xuICB9LFxuICBoYXNDbGFzczogZnVuY3Rpb24gaGFzQ2xhc3MoY2xhc3NOYW1lKSB7XG4gICAgdmFyIGVsZSA9IHRoaXNbMF07XG4gICAgcmV0dXJuIGVsZSAhPSBudWxsICYmIGVsZS5fcHJpdmF0ZS5jbGFzc2VzLmhhcyhjbGFzc05hbWUpO1xuICB9LFxuICB0b2dnbGVDbGFzczogZnVuY3Rpb24gdG9nZ2xlQ2xhc3MoY2xhc3NlcywgdG9nZ2xlKSB7XG4gICAgaWYgKCFhcnJheShjbGFzc2VzKSkge1xuICAgICAgLy8gZXh0cmFjdCBjbGFzc2VzIGZyb20gc3RyaW5nXG4gICAgICBjbGFzc2VzID0gY2xhc3Nlcy5tYXRjaCgvXFxTKy9nKSB8fCBbXTtcbiAgICB9XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciB0b2dnbGVVbmRlZmQgPSB0b2dnbGUgPT09IHVuZGVmaW5lZDtcbiAgICB2YXIgY2hhbmdlZCA9IFtdOyAvLyBlbGVzIHdobyBoYWQgY2xhc3NlcyBjaGFuZ2VkXG5cbiAgICBmb3IgKHZhciBpID0gMCwgaWwgPSBzZWxmLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcbiAgICAgIHZhciBlbGUgPSBzZWxmW2ldO1xuICAgICAgdmFyIGVsZUNsYXNzZXMgPSBlbGUuX3ByaXZhdGUuY2xhc3NlcztcbiAgICAgIHZhciBjaGFuZ2VkRWxlID0gZmFsc2U7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGNsYXNzZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgdmFyIGNscyA9IGNsYXNzZXNbal07XG4gICAgICAgIHZhciBoYXNDbGFzcyA9IGVsZUNsYXNzZXMuaGFzKGNscyk7XG4gICAgICAgIHZhciBjaGFuZ2VkTm93ID0gZmFsc2U7XG4gICAgICAgIGlmICh0b2dnbGUgfHwgdG9nZ2xlVW5kZWZkICYmICFoYXNDbGFzcykge1xuICAgICAgICAgIGVsZUNsYXNzZXMuYWRkKGNscyk7XG4gICAgICAgICAgY2hhbmdlZE5vdyA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAoIXRvZ2dsZSB8fCB0b2dnbGVVbmRlZmQgJiYgaGFzQ2xhc3MpIHtcbiAgICAgICAgICBlbGVDbGFzc2VzW1wiZGVsZXRlXCJdKGNscyk7XG4gICAgICAgICAgY2hhbmdlZE5vdyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjaGFuZ2VkRWxlICYmIGNoYW5nZWROb3cpIHtcbiAgICAgICAgICBjaGFuZ2VkLnB1c2goZWxlKTtcbiAgICAgICAgICBjaGFuZ2VkRWxlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBmb3IgaiBjbGFzc2VzXG4gICAgfSAvLyBmb3IgaSBlbGVzXG5cbiAgICAvLyB0cmlnZ2VyIHVwZGF0ZSBzdHlsZSBvbiB0aG9zZSBlbGVzIHRoYXQgaGFkIGNsYXNzIGNoYW5nZXNcbiAgICBpZiAoY2hhbmdlZC5sZW5ndGggPiAwKSB7XG4gICAgICB0aGlzLnNwYXduKGNoYW5nZWQpLnVwZGF0ZVN0eWxlKCkuZW1pdCgnY2xhc3MnKTtcbiAgICB9XG4gICAgcmV0dXJuIHNlbGY7XG4gIH0sXG4gIHJlbW92ZUNsYXNzOiBmdW5jdGlvbiByZW1vdmVDbGFzcyhjbGFzc2VzKSB7XG4gICAgcmV0dXJuIHRoaXMudG9nZ2xlQ2xhc3MoY2xhc3NlcywgZmFsc2UpO1xuICB9LFxuICBmbGFzaENsYXNzOiBmdW5jdGlvbiBmbGFzaENsYXNzKGNsYXNzZXMsIGR1cmF0aW9uKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIGlmIChkdXJhdGlvbiA9PSBudWxsKSB7XG4gICAgICBkdXJhdGlvbiA9IDI1MDtcbiAgICB9IGVsc2UgaWYgKGR1cmF0aW9uID09PSAwKSB7XG4gICAgICByZXR1cm4gc2VsZjsgLy8gbm90aGluZyB0byBkbyByZWFsbHlcbiAgICB9XG5cbiAgICBzZWxmLmFkZENsYXNzKGNsYXNzZXMpO1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgc2VsZi5yZW1vdmVDbGFzcyhjbGFzc2VzKTtcbiAgICB9LCBkdXJhdGlvbik7XG4gICAgcmV0dXJuIHNlbGY7XG4gIH1cbn07XG5lbGVzZm4kaC5jbGFzc05hbWUgPSBlbGVzZm4kaC5jbGFzc05hbWVzID0gZWxlc2ZuJGguY2xhc3NlcztcblxuLy8gdG9rZW5zIGluIHRoZSBxdWVyeSBsYW5ndWFnZVxudmFyIHRva2VucyA9IHtcbiAgbWV0YUNoYXI6ICdbXFxcXCFcXFxcXCJcXFxcI1xcXFwkXFxcXCVcXFxcJlxcXFxcXCdcXFxcKFxcXFwpXFxcXCpcXFxcK1xcXFwsXFxcXC5cXFxcL1xcXFw6XFxcXDtcXFxcPFxcXFw9XFxcXD5cXFxcP1xcXFxAXFxcXFtcXFxcXVxcXFxeXFxcXGBcXFxce1xcXFx8XFxcXH1cXFxcfl0nLFxuICAvLyBjaGFycyB3ZSBuZWVkIHRvIGVzY2FwZSBpbiBsZXQgbmFtZXMsIGV0Y1xuICBjb21wYXJhdG9yT3A6ICc9fFxcXFwhPXw+fD49fDx8PD18XFxcXCQ9fFxcXFxePXxcXFxcKj0nLFxuICAvLyBiaW5hcnkgY29tcGFyaXNvbiBvcCAodXNlZCBpbiBkYXRhIHNlbGVjdG9ycylcbiAgYm9vbE9wOiAnXFxcXD98XFxcXCF8XFxcXF4nLFxuICAvLyBib29sZWFuICh1bmFyeSkgb3BlcmF0b3JzICh1c2VkIGluIGRhdGEgc2VsZWN0b3JzKVxuICBzdHJpbmc6ICdcIig/OlxcXFxcXFxcXCJ8W15cIl0pKlwiJyArICd8JyArIFwiJyg/OlxcXFxcXFxcJ3xbXiddKSonXCIsXG4gIC8vIHN0cmluZyBsaXRlcmFscyAodXNlZCBpbiBkYXRhIHNlbGVjdG9ycykgLS0gZG91YmxlcXVvdGVzIHwgc2luZ2xlcXVvdGVzXG4gIG51bWJlcjogbnVtYmVyLFxuICAvLyBudW1iZXIgbGl0ZXJhbCAodXNlZCBpbiBkYXRhIHNlbGVjdG9ycykgLS0tIGUuZy4gMC4xMjM0LCAxMjM0LCAxMmUxMjNcbiAgbWV0YTogJ2RlZ3JlZXxpbmRlZ3JlZXxvdXRkZWdyZWUnLFxuICAvLyBhbGxvd2VkIG1ldGFkYXRhIGZpZWxkcyAoaS5lLiBhbGxvd2VkIGZ1bmN0aW9ucyB0byB1c2UgZnJvbSBDb2xsZWN0aW9uKVxuICBzZXBhcmF0b3I6ICdcXFxccyosXFxcXHMqJyxcbiAgLy8gcXVlcmllcyBhcmUgc2VwYXJhdGVkIGJ5IGNvbW1hcywgZS5nLiBlZGdlW2ZvbyA9ICdiYXInXSwgbm9kZS5zb21lQ2xhc3NcbiAgZGVzY2VuZGFudDogJ1xcXFxzKycsXG4gIGNoaWxkOiAnXFxcXHMrPlxcXFxzKycsXG4gIHN1YmplY3Q6ICdcXFxcJCcsXG4gIGdyb3VwOiAnbm9kZXxlZGdlfFxcXFwqJyxcbiAgZGlyZWN0ZWRFZGdlOiAnXFxcXHMrLT5cXFxccysnLFxuICB1bmRpcmVjdGVkRWRnZTogJ1xcXFxzKzwtPlxcXFxzKydcbn07XG50b2tlbnMudmFyaWFibGUgPSAnKD86W1xcXFx3LS5dfCg/OlxcXFxcXFxcJyArIHRva2Vucy5tZXRhQ2hhciArICcpKSsnOyAvLyBhIHZhcmlhYmxlIG5hbWUgY2FuIGhhdmUgbGV0dGVycywgbnVtYmVycywgZGFzaGVzLCBhbmQgcGVyaW9kc1xudG9rZW5zLmNsYXNzTmFtZSA9ICcoPzpbXFxcXHctXXwoPzpcXFxcXFxcXCcgKyB0b2tlbnMubWV0YUNoYXIgKyAnKSkrJzsgLy8gYSBjbGFzcyBuYW1lIGhhcyB0aGUgc2FtZSBydWxlcyBhcyBhIHZhcmlhYmxlIGV4Y2VwdCBpdCBjYW4ndCBoYXZlIGEgJy4nIGluIHRoZSBuYW1lXG50b2tlbnMudmFsdWUgPSB0b2tlbnMuc3RyaW5nICsgJ3wnICsgdG9rZW5zLm51bWJlcjsgLy8gYSB2YWx1ZSBsaXRlcmFsLCBlaXRoZXIgYSBzdHJpbmcgb3IgbnVtYmVyXG50b2tlbnMuaWQgPSB0b2tlbnMudmFyaWFibGU7IC8vIGFuIGVsZW1lbnQgaWQgKGZvbGxvd3MgdmFyaWFibGUgY29udmVudGlvbnMpXG5cbihmdW5jdGlvbiAoKSB7XG4gIHZhciBvcHMsIG9wLCBpO1xuXG4gIC8vIGFkZCBAIHZhcmlhbnRzIHRvIGNvbXBhcmF0b3JPcFxuICBvcHMgPSB0b2tlbnMuY29tcGFyYXRvck9wLnNwbGl0KCd8Jyk7XG4gIGZvciAoaSA9IDA7IGkgPCBvcHMubGVuZ3RoOyBpKyspIHtcbiAgICBvcCA9IG9wc1tpXTtcbiAgICB0b2tlbnMuY29tcGFyYXRvck9wICs9ICd8QCcgKyBvcDtcbiAgfVxuXG4gIC8vIGFkZCAhIHZhcmlhbnRzIHRvIGNvbXBhcmF0b3JPcFxuICBvcHMgPSB0b2tlbnMuY29tcGFyYXRvck9wLnNwbGl0KCd8Jyk7XG4gIGZvciAoaSA9IDA7IGkgPCBvcHMubGVuZ3RoOyBpKyspIHtcbiAgICBvcCA9IG9wc1tpXTtcbiAgICBpZiAob3AuaW5kZXhPZignIScpID49IDApIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH0gLy8gc2tpcCBvcHMgdGhhdCBleHBsaWNpdGx5IGNvbnRhaW4gIVxuICAgIGlmIChvcCA9PT0gJz0nKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9IC8vIHNraXAgPSBiL2MgIT0gaXMgZXhwbGljaXRseSBkZWZpbmVkXG5cbiAgICB0b2tlbnMuY29tcGFyYXRvck9wICs9ICd8XFxcXCEnICsgb3A7XG4gIH1cbn0pKCk7XG5cbi8qKlxuICogTWFrZSBhIG5ldyBxdWVyeSBvYmplY3RcbiAqXG4gKiBAcHJvcCB0eXBlIHtUeXBlfSBUaGUgdHlwZSBlbnVtIChpbnQpIG9mIHRoZSBxdWVyeVxuICogQHByb3AgY2hlY2tzIExpc3Qgb2YgY2hlY2tzIHRvIG1ha2UgYWdhaW5zdCBhbiBlbGUgdG8gdGVzdCBmb3IgYSBtYXRjaFxuICovXG52YXIgbmV3UXVlcnkgPSBmdW5jdGlvbiBuZXdRdWVyeSgpIHtcbiAgcmV0dXJuIHtcbiAgICBjaGVja3M6IFtdXG4gIH07XG59O1xuXG4vKipcbiAqIEEgY2hlY2sgdHlwZSBlbnVtLWxpa2Ugb2JqZWN0LiAgVXNlcyBpbnRlZ2VyIHZhbHVlcyBmb3IgZmFzdCBtYXRjaCgpIGxvb2t1cC5cbiAqIFRoZSBvcmRlcmluZyBkb2VzIG5vdCBtYXR0ZXIgYXMgbG9uZyBhcyB0aGUgaW50cyBhcmUgdW5pcXVlLlxuICovXG52YXIgVHlwZSA9IHtcbiAgLyoqIEUuZy4gbm9kZSAqL1xuICBHUk9VUDogMCxcbiAgLyoqIEEgY29sbGVjdGlvbiBvZiBlbGVtZW50cyAqL1xuICBDT0xMRUNUSU9OOiAxLFxuICAvKiogQSBmaWx0ZXIoZWxlKSBmdW5jdGlvbiAqL1xuICBGSUxURVI6IDIsXG4gIC8qKiBFLmcuIFtmb28gPiAxXSAqL1xuICBEQVRBX0NPTVBBUkU6IDMsXG4gIC8qKiBFLmcuIFtmb29dICovXG4gIERBVEFfRVhJU1Q6IDQsXG4gIC8qKiBFLmcuIFs/Zm9vXSAqL1xuICBEQVRBX0JPT0w6IDUsXG4gIC8qKiBFLmcuIFtbZGVncmVlID4gMl1dICovXG4gIE1FVEFfQ09NUEFSRTogNixcbiAgLyoqIEUuZy4gOnNlbGVjdGVkICovXG4gIFNUQVRFOiA3LFxuICAvKiogRS5nLiAjZm9vICovXG4gIElEOiA4LFxuICAvKiogRS5nLiAuZm9vICovXG4gIENMQVNTOiA5LFxuICAvKiogRS5nLiAjZm9vIDwtPiAjYmFyICovXG4gIFVORElSRUNURURfRURHRTogMTAsXG4gIC8qKiBFLmcuICNmb28gLT4gI2JhciAqL1xuICBESVJFQ1RFRF9FREdFOiAxMSxcbiAgLyoqIEUuZy4gJCNmb28gLT4gI2JhciAqL1xuICBOT0RFX1NPVVJDRTogMTIsXG4gIC8qKiBFLmcuICNmb28gLT4gJCNiYXIgKi9cbiAgTk9ERV9UQVJHRVQ6IDEzLFxuICAvKiogRS5nLiAkI2ZvbyA8LT4gI2JhciAqL1xuICBOT0RFX05FSUdIQk9SOiAxNCxcbiAgLyoqIEUuZy4gI2ZvbyA+ICNiYXIgKi9cbiAgQ0hJTEQ6IDE1LFxuICAvKiogRS5nLiAjZm9vICNiYXIgKi9cbiAgREVTQ0VOREFOVDogMTYsXG4gIC8qKiBFLmcuICQjZm9vID4gI2JhciAqL1xuICBQQVJFTlQ6IDE3LFxuICAvKiogRS5nLiAkI2ZvbyAjYmFyICovXG4gIEFOQ0VTVE9SOiAxOCxcbiAgLyoqIEUuZy4gI2ZvbyA+ICRiYXIgPiAjYmF6ICovXG4gIENPTVBPVU5EX1NQTElUOiAxOSxcbiAgLyoqIEFsd2F5cyBtYXRjaGVzLCB1c2VmdWwgcGxhY2Vob2xkZXIgZm9yIHN1YmplY3QgaW4gYENPTVBPVU5EX1NQTElUYCAqL1xuICBUUlVFOiAyMFxufTtcblxudmFyIHN0YXRlU2VsZWN0b3JzID0gW3tcbiAgc2VsZWN0b3I6ICc6c2VsZWN0ZWQnLFxuICBtYXRjaGVzOiBmdW5jdGlvbiBtYXRjaGVzKGVsZSkge1xuICAgIHJldHVybiBlbGUuc2VsZWN0ZWQoKTtcbiAgfVxufSwge1xuICBzZWxlY3RvcjogJzp1bnNlbGVjdGVkJyxcbiAgbWF0Y2hlczogZnVuY3Rpb24gbWF0Y2hlcyhlbGUpIHtcbiAgICByZXR1cm4gIWVsZS5zZWxlY3RlZCgpO1xuICB9XG59LCB7XG4gIHNlbGVjdG9yOiAnOnNlbGVjdGFibGUnLFxuICBtYXRjaGVzOiBmdW5jdGlvbiBtYXRjaGVzKGVsZSkge1xuICAgIHJldHVybiBlbGUuc2VsZWN0YWJsZSgpO1xuICB9XG59LCB7XG4gIHNlbGVjdG9yOiAnOnVuc2VsZWN0YWJsZScsXG4gIG1hdGNoZXM6IGZ1bmN0aW9uIG1hdGNoZXMoZWxlKSB7XG4gICAgcmV0dXJuICFlbGUuc2VsZWN0YWJsZSgpO1xuICB9XG59LCB7XG4gIHNlbGVjdG9yOiAnOmxvY2tlZCcsXG4gIG1hdGNoZXM6IGZ1bmN0aW9uIG1hdGNoZXMoZWxlKSB7XG4gICAgcmV0dXJuIGVsZS5sb2NrZWQoKTtcbiAgfVxufSwge1xuICBzZWxlY3RvcjogJzp1bmxvY2tlZCcsXG4gIG1hdGNoZXM6IGZ1bmN0aW9uIG1hdGNoZXMoZWxlKSB7XG4gICAgcmV0dXJuICFlbGUubG9ja2VkKCk7XG4gIH1cbn0sIHtcbiAgc2VsZWN0b3I6ICc6dmlzaWJsZScsXG4gIG1hdGNoZXM6IGZ1bmN0aW9uIG1hdGNoZXMoZWxlKSB7XG4gICAgcmV0dXJuIGVsZS52aXNpYmxlKCk7XG4gIH1cbn0sIHtcbiAgc2VsZWN0b3I6ICc6aGlkZGVuJyxcbiAgbWF0Y2hlczogZnVuY3Rpb24gbWF0Y2hlcyhlbGUpIHtcbiAgICByZXR1cm4gIWVsZS52aXNpYmxlKCk7XG4gIH1cbn0sIHtcbiAgc2VsZWN0b3I6ICc6dHJhbnNwYXJlbnQnLFxuICBtYXRjaGVzOiBmdW5jdGlvbiBtYXRjaGVzKGVsZSkge1xuICAgIHJldHVybiBlbGUudHJhbnNwYXJlbnQoKTtcbiAgfVxufSwge1xuICBzZWxlY3RvcjogJzpncmFiYmVkJyxcbiAgbWF0Y2hlczogZnVuY3Rpb24gbWF0Y2hlcyhlbGUpIHtcbiAgICByZXR1cm4gZWxlLmdyYWJiZWQoKTtcbiAgfVxufSwge1xuICBzZWxlY3RvcjogJzpmcmVlJyxcbiAgbWF0Y2hlczogZnVuY3Rpb24gbWF0Y2hlcyhlbGUpIHtcbiAgICByZXR1cm4gIWVsZS5ncmFiYmVkKCk7XG4gIH1cbn0sIHtcbiAgc2VsZWN0b3I6ICc6cmVtb3ZlZCcsXG4gIG1hdGNoZXM6IGZ1bmN0aW9uIG1hdGNoZXMoZWxlKSB7XG4gICAgcmV0dXJuIGVsZS5yZW1vdmVkKCk7XG4gIH1cbn0sIHtcbiAgc2VsZWN0b3I6ICc6aW5zaWRlJyxcbiAgbWF0Y2hlczogZnVuY3Rpb24gbWF0Y2hlcyhlbGUpIHtcbiAgICByZXR1cm4gIWVsZS5yZW1vdmVkKCk7XG4gIH1cbn0sIHtcbiAgc2VsZWN0b3I6ICc6Z3JhYmJhYmxlJyxcbiAgbWF0Y2hlczogZnVuY3Rpb24gbWF0Y2hlcyhlbGUpIHtcbiAgICByZXR1cm4gZWxlLmdyYWJiYWJsZSgpO1xuICB9XG59LCB7XG4gIHNlbGVjdG9yOiAnOnVuZ3JhYmJhYmxlJyxcbiAgbWF0Y2hlczogZnVuY3Rpb24gbWF0Y2hlcyhlbGUpIHtcbiAgICByZXR1cm4gIWVsZS5ncmFiYmFibGUoKTtcbiAgfVxufSwge1xuICBzZWxlY3RvcjogJzphbmltYXRlZCcsXG4gIG1hdGNoZXM6IGZ1bmN0aW9uIG1hdGNoZXMoZWxlKSB7XG4gICAgcmV0dXJuIGVsZS5hbmltYXRlZCgpO1xuICB9XG59LCB7XG4gIHNlbGVjdG9yOiAnOnVuYW5pbWF0ZWQnLFxuICBtYXRjaGVzOiBmdW5jdGlvbiBtYXRjaGVzKGVsZSkge1xuICAgIHJldHVybiAhZWxlLmFuaW1hdGVkKCk7XG4gIH1cbn0sIHtcbiAgc2VsZWN0b3I6ICc6cGFyZW50JyxcbiAgbWF0Y2hlczogZnVuY3Rpb24gbWF0Y2hlcyhlbGUpIHtcbiAgICByZXR1cm4gZWxlLmlzUGFyZW50KCk7XG4gIH1cbn0sIHtcbiAgc2VsZWN0b3I6ICc6Y2hpbGRsZXNzJyxcbiAgbWF0Y2hlczogZnVuY3Rpb24gbWF0Y2hlcyhlbGUpIHtcbiAgICByZXR1cm4gZWxlLmlzQ2hpbGRsZXNzKCk7XG4gIH1cbn0sIHtcbiAgc2VsZWN0b3I6ICc6Y2hpbGQnLFxuICBtYXRjaGVzOiBmdW5jdGlvbiBtYXRjaGVzKGVsZSkge1xuICAgIHJldHVybiBlbGUuaXNDaGlsZCgpO1xuICB9XG59LCB7XG4gIHNlbGVjdG9yOiAnOm9ycGhhbicsXG4gIG1hdGNoZXM6IGZ1bmN0aW9uIG1hdGNoZXMoZWxlKSB7XG4gICAgcmV0dXJuIGVsZS5pc09ycGhhbigpO1xuICB9XG59LCB7XG4gIHNlbGVjdG9yOiAnOm5vbm9ycGhhbicsXG4gIG1hdGNoZXM6IGZ1bmN0aW9uIG1hdGNoZXMoZWxlKSB7XG4gICAgcmV0dXJuIGVsZS5pc0NoaWxkKCk7XG4gIH1cbn0sIHtcbiAgc2VsZWN0b3I6ICc6Y29tcG91bmQnLFxuICBtYXRjaGVzOiBmdW5jdGlvbiBtYXRjaGVzKGVsZSkge1xuICAgIGlmIChlbGUuaXNOb2RlKCkpIHtcbiAgICAgIHJldHVybiBlbGUuaXNQYXJlbnQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGVsZS5zb3VyY2UoKS5pc1BhcmVudCgpIHx8IGVsZS50YXJnZXQoKS5pc1BhcmVudCgpO1xuICAgIH1cbiAgfVxufSwge1xuICBzZWxlY3RvcjogJzpsb29wJyxcbiAgbWF0Y2hlczogZnVuY3Rpb24gbWF0Y2hlcyhlbGUpIHtcbiAgICByZXR1cm4gZWxlLmlzTG9vcCgpO1xuICB9XG59LCB7XG4gIHNlbGVjdG9yOiAnOnNpbXBsZScsXG4gIG1hdGNoZXM6IGZ1bmN0aW9uIG1hdGNoZXMoZWxlKSB7XG4gICAgcmV0dXJuIGVsZS5pc1NpbXBsZSgpO1xuICB9XG59LCB7XG4gIHNlbGVjdG9yOiAnOmFjdGl2ZScsXG4gIG1hdGNoZXM6IGZ1bmN0aW9uIG1hdGNoZXMoZWxlKSB7XG4gICAgcmV0dXJuIGVsZS5hY3RpdmUoKTtcbiAgfVxufSwge1xuICBzZWxlY3RvcjogJzppbmFjdGl2ZScsXG4gIG1hdGNoZXM6IGZ1bmN0aW9uIG1hdGNoZXMoZWxlKSB7XG4gICAgcmV0dXJuICFlbGUuYWN0aXZlKCk7XG4gIH1cbn0sIHtcbiAgc2VsZWN0b3I6ICc6YmFja2dyb3VuZGluZycsXG4gIG1hdGNoZXM6IGZ1bmN0aW9uIG1hdGNoZXMoZWxlKSB7XG4gICAgcmV0dXJuIGVsZS5iYWNrZ3JvdW5kaW5nKCk7XG4gIH1cbn0sIHtcbiAgc2VsZWN0b3I6ICc6bm9uYmFja2dyb3VuZGluZycsXG4gIG1hdGNoZXM6IGZ1bmN0aW9uIG1hdGNoZXMoZWxlKSB7XG4gICAgcmV0dXJuICFlbGUuYmFja2dyb3VuZGluZygpO1xuICB9XG59XS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gIC8vIG4uYi4gc2VsZWN0b3JzIHRoYXQgYXJlIHN0YXJ0aW5nIHN1YnN0cmluZ3Mgb2Ygb3RoZXJzIG11c3QgaGF2ZSB0aGUgbG9uZ2VyIG9uZXMgZmlyc3RcbiAgcmV0dXJuIGRlc2NlbmRpbmcoYS5zZWxlY3RvciwgYi5zZWxlY3Rvcik7XG59KTtcbnZhciBsb29rdXAgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxUb0ZuID0ge307XG4gIHZhciBzO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0YXRlU2VsZWN0b3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgcyA9IHN0YXRlU2VsZWN0b3JzW2ldO1xuICAgIHNlbFRvRm5bcy5zZWxlY3Rvcl0gPSBzLm1hdGNoZXM7XG4gIH1cbiAgcmV0dXJuIHNlbFRvRm47XG59KCk7XG52YXIgc3RhdGVTZWxlY3Rvck1hdGNoZXMgPSBmdW5jdGlvbiBzdGF0ZVNlbGVjdG9yTWF0Y2hlcyhzZWwsIGVsZSkge1xuICByZXR1cm4gbG9va3VwW3NlbF0oZWxlKTtcbn07XG52YXIgc3RhdGVTZWxlY3RvclJlZ2V4ID0gJygnICsgc3RhdGVTZWxlY3RvcnMubWFwKGZ1bmN0aW9uIChzKSB7XG4gIHJldHVybiBzLnNlbGVjdG9yO1xufSkuam9pbignfCcpICsgJyknO1xuXG4vLyB3aGVuIGEgdG9rZW4gbGlrZSBhIHZhcmlhYmxlIGhhcyBlc2NhcGVkIG1ldGEgY2hhcmFjdGVycywgd2UgbmVlZCB0byBjbGVhbiB0aGUgYmFja3NsYXNoZXMgb3V0XG4vLyBzbyB0aGF0IHZhbHVlcyBnZXQgY29tcGFyZWQgcHJvcGVybHkgaW4gU2VsZWN0b3IuZmlsdGVyKClcbnZhciBjbGVhbk1ldGFDaGFycyA9IGZ1bmN0aW9uIGNsZWFuTWV0YUNoYXJzKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UobmV3IFJlZ0V4cCgnXFxcXFxcXFwoJyArIHRva2Vucy5tZXRhQ2hhciArICcpJywgJ2cnKSwgZnVuY3Rpb24gKG1hdGNoLCAkMSkge1xuICAgIHJldHVybiAkMTtcbiAgfSk7XG59O1xudmFyIHJlcGxhY2VMYXN0UXVlcnkgPSBmdW5jdGlvbiByZXBsYWNlTGFzdFF1ZXJ5KHNlbGVjdG9yLCBleGFtaW5pbmdRdWVyeSwgcmVwbGFjZW1lbnRRdWVyeSkge1xuICBzZWxlY3RvcltzZWxlY3Rvci5sZW5ndGggLSAxXSA9IHJlcGxhY2VtZW50UXVlcnk7XG59O1xuXG4vLyBOT1RFOiBhZGQgbmV3IGV4cHJlc3Npb24gc3ludGF4IGhlcmUgdG8gaGF2ZSBpdCByZWNvZ25pc2VkIGJ5IHRoZSBwYXJzZXI7XG4vLyAtIGEgcXVlcnkgY29udGFpbnMgYWxsIGFkamFjZW50IChpLmUuIG5vIHNlcGFyYXRvciBpbiBiZXR3ZWVuKSBleHByZXNzaW9ucztcbi8vIC0gdGhlIGN1cnJlbnQgcXVlcnkgaXMgc3RvcmVkIGluIHNlbGVjdG9yW2ldXG4vLyAtIHlvdSBuZWVkIHRvIGNoZWNrIHRoZSBxdWVyeSBvYmplY3RzIGluIG1hdGNoKCkgZm9yIGl0IGFjdHVhbGx5IGZpbHRlciBwcm9wZXJseSwgYnV0IHRoYXQncyBwcmV0dHkgc3RyYWlnaHQgZm9yd2FyZFxudmFyIGV4cHJzID0gW3tcbiAgbmFtZTogJ2dyb3VwJyxcbiAgLy8ganVzdCB1c2VkIGZvciBpZGVudGlmeWluZyB3aGVuIGRlYnVnZ2luZ1xuICBxdWVyeTogdHJ1ZSxcbiAgcmVnZXg6ICcoJyArIHRva2Vucy5ncm91cCArICcpJyxcbiAgcG9wdWxhdGU6IGZ1bmN0aW9uIHBvcHVsYXRlKHNlbGVjdG9yLCBxdWVyeSwgX3JlZikge1xuICAgIHZhciBfcmVmMiA9IF9zbGljZWRUb0FycmF5KF9yZWYsIDEpLFxuICAgICAgZ3JvdXAgPSBfcmVmMlswXTtcbiAgICBxdWVyeS5jaGVja3MucHVzaCh7XG4gICAgICB0eXBlOiBUeXBlLkdST1VQLFxuICAgICAgdmFsdWU6IGdyb3VwID09PSAnKicgPyBncm91cCA6IGdyb3VwICsgJ3MnXG4gICAgfSk7XG4gIH1cbn0sIHtcbiAgbmFtZTogJ3N0YXRlJyxcbiAgcXVlcnk6IHRydWUsXG4gIHJlZ2V4OiBzdGF0ZVNlbGVjdG9yUmVnZXgsXG4gIHBvcHVsYXRlOiBmdW5jdGlvbiBwb3B1bGF0ZShzZWxlY3RvciwgcXVlcnksIF9yZWYzKSB7XG4gICAgdmFyIF9yZWY0ID0gX3NsaWNlZFRvQXJyYXkoX3JlZjMsIDEpLFxuICAgICAgc3RhdGUgPSBfcmVmNFswXTtcbiAgICBxdWVyeS5jaGVja3MucHVzaCh7XG4gICAgICB0eXBlOiBUeXBlLlNUQVRFLFxuICAgICAgdmFsdWU6IHN0YXRlXG4gICAgfSk7XG4gIH1cbn0sIHtcbiAgbmFtZTogJ2lkJyxcbiAgcXVlcnk6IHRydWUsXG4gIHJlZ2V4OiAnXFxcXCMoJyArIHRva2Vucy5pZCArICcpJyxcbiAgcG9wdWxhdGU6IGZ1bmN0aW9uIHBvcHVsYXRlKHNlbGVjdG9yLCBxdWVyeSwgX3JlZjUpIHtcbiAgICB2YXIgX3JlZjYgPSBfc2xpY2VkVG9BcnJheShfcmVmNSwgMSksXG4gICAgICBpZCA9IF9yZWY2WzBdO1xuICAgIHF1ZXJ5LmNoZWNrcy5wdXNoKHtcbiAgICAgIHR5cGU6IFR5cGUuSUQsXG4gICAgICB2YWx1ZTogY2xlYW5NZXRhQ2hhcnMoaWQpXG4gICAgfSk7XG4gIH1cbn0sIHtcbiAgbmFtZTogJ2NsYXNzTmFtZScsXG4gIHF1ZXJ5OiB0cnVlLFxuICByZWdleDogJ1xcXFwuKCcgKyB0b2tlbnMuY2xhc3NOYW1lICsgJyknLFxuICBwb3B1bGF0ZTogZnVuY3Rpb24gcG9wdWxhdGUoc2VsZWN0b3IsIHF1ZXJ5LCBfcmVmNykge1xuICAgIHZhciBfcmVmOCA9IF9zbGljZWRUb0FycmF5KF9yZWY3LCAxKSxcbiAgICAgIGNsYXNzTmFtZSA9IF9yZWY4WzBdO1xuICAgIHF1ZXJ5LmNoZWNrcy5wdXNoKHtcbiAgICAgIHR5cGU6IFR5cGUuQ0xBU1MsXG4gICAgICB2YWx1ZTogY2xlYW5NZXRhQ2hhcnMoY2xhc3NOYW1lKVxuICAgIH0pO1xuICB9XG59LCB7XG4gIG5hbWU6ICdkYXRhRXhpc3RzJyxcbiAgcXVlcnk6IHRydWUsXG4gIHJlZ2V4OiAnXFxcXFtcXFxccyooJyArIHRva2Vucy52YXJpYWJsZSArICcpXFxcXHMqXFxcXF0nLFxuICBwb3B1bGF0ZTogZnVuY3Rpb24gcG9wdWxhdGUoc2VsZWN0b3IsIHF1ZXJ5LCBfcmVmOSkge1xuICAgIHZhciBfcmVmMTAgPSBfc2xpY2VkVG9BcnJheShfcmVmOSwgMSksXG4gICAgICB2YXJpYWJsZSA9IF9yZWYxMFswXTtcbiAgICBxdWVyeS5jaGVja3MucHVzaCh7XG4gICAgICB0eXBlOiBUeXBlLkRBVEFfRVhJU1QsXG4gICAgICBmaWVsZDogY2xlYW5NZXRhQ2hhcnModmFyaWFibGUpXG4gICAgfSk7XG4gIH1cbn0sIHtcbiAgbmFtZTogJ2RhdGFDb21wYXJlJyxcbiAgcXVlcnk6IHRydWUsXG4gIHJlZ2V4OiAnXFxcXFtcXFxccyooJyArIHRva2Vucy52YXJpYWJsZSArICcpXFxcXHMqKCcgKyB0b2tlbnMuY29tcGFyYXRvck9wICsgJylcXFxccyooJyArIHRva2Vucy52YWx1ZSArICcpXFxcXHMqXFxcXF0nLFxuICBwb3B1bGF0ZTogZnVuY3Rpb24gcG9wdWxhdGUoc2VsZWN0b3IsIHF1ZXJ5LCBfcmVmMTEpIHtcbiAgICB2YXIgX3JlZjEyID0gX3NsaWNlZFRvQXJyYXkoX3JlZjExLCAzKSxcbiAgICAgIHZhcmlhYmxlID0gX3JlZjEyWzBdLFxuICAgICAgY29tcGFyYXRvck9wID0gX3JlZjEyWzFdLFxuICAgICAgdmFsdWUgPSBfcmVmMTJbMl07XG4gICAgdmFyIHZhbHVlSXNTdHJpbmcgPSBuZXcgUmVnRXhwKCdeJyArIHRva2Vucy5zdHJpbmcgKyAnJCcpLmV4ZWModmFsdWUpICE9IG51bGw7XG4gICAgaWYgKHZhbHVlSXNTdHJpbmcpIHtcbiAgICAgIHZhbHVlID0gdmFsdWUuc3Vic3RyaW5nKDEsIHZhbHVlLmxlbmd0aCAtIDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSA9IHBhcnNlRmxvYXQodmFsdWUpO1xuICAgIH1cbiAgICBxdWVyeS5jaGVja3MucHVzaCh7XG4gICAgICB0eXBlOiBUeXBlLkRBVEFfQ09NUEFSRSxcbiAgICAgIGZpZWxkOiBjbGVhbk1ldGFDaGFycyh2YXJpYWJsZSksXG4gICAgICBvcGVyYXRvcjogY29tcGFyYXRvck9wLFxuICAgICAgdmFsdWU6IHZhbHVlXG4gICAgfSk7XG4gIH1cbn0sIHtcbiAgbmFtZTogJ2RhdGFCb29sJyxcbiAgcXVlcnk6IHRydWUsXG4gIHJlZ2V4OiAnXFxcXFtcXFxccyooJyArIHRva2Vucy5ib29sT3AgKyAnKVxcXFxzKignICsgdG9rZW5zLnZhcmlhYmxlICsgJylcXFxccypcXFxcXScsXG4gIHBvcHVsYXRlOiBmdW5jdGlvbiBwb3B1bGF0ZShzZWxlY3RvciwgcXVlcnksIF9yZWYxMykge1xuICAgIHZhciBfcmVmMTQgPSBfc2xpY2VkVG9BcnJheShfcmVmMTMsIDIpLFxuICAgICAgYm9vbE9wID0gX3JlZjE0WzBdLFxuICAgICAgdmFyaWFibGUgPSBfcmVmMTRbMV07XG4gICAgcXVlcnkuY2hlY2tzLnB1c2goe1xuICAgICAgdHlwZTogVHlwZS5EQVRBX0JPT0wsXG4gICAgICBmaWVsZDogY2xlYW5NZXRhQ2hhcnModmFyaWFibGUpLFxuICAgICAgb3BlcmF0b3I6IGJvb2xPcFxuICAgIH0pO1xuICB9XG59LCB7XG4gIG5hbWU6ICdtZXRhQ29tcGFyZScsXG4gIHF1ZXJ5OiB0cnVlLFxuICByZWdleDogJ1xcXFxbXFxcXFtcXFxccyooJyArIHRva2Vucy5tZXRhICsgJylcXFxccyooJyArIHRva2Vucy5jb21wYXJhdG9yT3AgKyAnKVxcXFxzKignICsgdG9rZW5zLm51bWJlciArICcpXFxcXHMqXFxcXF1cXFxcXScsXG4gIHBvcHVsYXRlOiBmdW5jdGlvbiBwb3B1bGF0ZShzZWxlY3RvciwgcXVlcnksIF9yZWYxNSkge1xuICAgIHZhciBfcmVmMTYgPSBfc2xpY2VkVG9BcnJheShfcmVmMTUsIDMpLFxuICAgICAgbWV0YSA9IF9yZWYxNlswXSxcbiAgICAgIGNvbXBhcmF0b3JPcCA9IF9yZWYxNlsxXSxcbiAgICAgIG51bWJlciA9IF9yZWYxNlsyXTtcbiAgICBxdWVyeS5jaGVja3MucHVzaCh7XG4gICAgICB0eXBlOiBUeXBlLk1FVEFfQ09NUEFSRSxcbiAgICAgIGZpZWxkOiBjbGVhbk1ldGFDaGFycyhtZXRhKSxcbiAgICAgIG9wZXJhdG9yOiBjb21wYXJhdG9yT3AsXG4gICAgICB2YWx1ZTogcGFyc2VGbG9hdChudW1iZXIpXG4gICAgfSk7XG4gIH1cbn0sIHtcbiAgbmFtZTogJ25leHRRdWVyeScsXG4gIHNlcGFyYXRvcjogdHJ1ZSxcbiAgcmVnZXg6IHRva2Vucy5zZXBhcmF0b3IsXG4gIHBvcHVsYXRlOiBmdW5jdGlvbiBwb3B1bGF0ZShzZWxlY3RvciwgcXVlcnkpIHtcbiAgICB2YXIgY3VycmVudFN1YmplY3QgPSBzZWxlY3Rvci5jdXJyZW50U3ViamVjdDtcbiAgICB2YXIgZWRnZUNvdW50ID0gc2VsZWN0b3IuZWRnZUNvdW50O1xuICAgIHZhciBjb21wb3VuZENvdW50ID0gc2VsZWN0b3IuY29tcG91bmRDb3VudDtcbiAgICB2YXIgbGFzdFEgPSBzZWxlY3RvcltzZWxlY3Rvci5sZW5ndGggLSAxXTtcbiAgICBpZiAoY3VycmVudFN1YmplY3QgIT0gbnVsbCkge1xuICAgICAgbGFzdFEuc3ViamVjdCA9IGN1cnJlbnRTdWJqZWN0O1xuICAgICAgc2VsZWN0b3IuY3VycmVudFN1YmplY3QgPSBudWxsO1xuICAgIH1cbiAgICBsYXN0US5lZGdlQ291bnQgPSBlZGdlQ291bnQ7XG4gICAgbGFzdFEuY29tcG91bmRDb3VudCA9IGNvbXBvdW5kQ291bnQ7XG4gICAgc2VsZWN0b3IuZWRnZUNvdW50ID0gMDtcbiAgICBzZWxlY3Rvci5jb21wb3VuZENvdW50ID0gMDtcblxuICAgIC8vIGdvIG9uIHRvIG5leHQgcXVlcnlcbiAgICB2YXIgbmV4dFF1ZXJ5ID0gc2VsZWN0b3Jbc2VsZWN0b3IubGVuZ3RoKytdID0gbmV3UXVlcnkoKTtcbiAgICByZXR1cm4gbmV4dFF1ZXJ5OyAvLyB0aGlzIGlzIHRoZSBuZXcgcXVlcnkgdG8gYmUgZmlsbGVkIGJ5IHRoZSBmb2xsb3dpbmcgZXhwcnNcbiAgfVxufSwge1xuICBuYW1lOiAnZGlyZWN0ZWRFZGdlJyxcbiAgc2VwYXJhdG9yOiB0cnVlLFxuICByZWdleDogdG9rZW5zLmRpcmVjdGVkRWRnZSxcbiAgcG9wdWxhdGU6IGZ1bmN0aW9uIHBvcHVsYXRlKHNlbGVjdG9yLCBxdWVyeSkge1xuICAgIGlmIChzZWxlY3Rvci5jdXJyZW50U3ViamVjdCA9PSBudWxsKSB7XG4gICAgICAvLyB1bmRpcmVjdGVkIGVkZ2VcbiAgICAgIHZhciBlZGdlUXVlcnkgPSBuZXdRdWVyeSgpO1xuICAgICAgdmFyIHNvdXJjZSA9IHF1ZXJ5O1xuICAgICAgdmFyIHRhcmdldCA9IG5ld1F1ZXJ5KCk7XG4gICAgICBlZGdlUXVlcnkuY2hlY2tzLnB1c2goe1xuICAgICAgICB0eXBlOiBUeXBlLkRJUkVDVEVEX0VER0UsXG4gICAgICAgIHNvdXJjZTogc291cmNlLFxuICAgICAgICB0YXJnZXQ6IHRhcmdldFxuICAgICAgfSk7XG5cbiAgICAgIC8vIHRoZSBxdWVyeSBpbiB0aGUgc2VsZWN0b3Igc2hvdWxkIGJlIHRoZSBlZGdlIHJhdGhlciB0aGFuIHRoZSBzb3VyY2VcbiAgICAgIHJlcGxhY2VMYXN0UXVlcnkoc2VsZWN0b3IsIHF1ZXJ5LCBlZGdlUXVlcnkpO1xuICAgICAgc2VsZWN0b3IuZWRnZUNvdW50Kys7XG5cbiAgICAgIC8vIHdlJ3JlIG5vdyBwb3B1bGF0aW5nIHRoZSB0YXJnZXQgcXVlcnkgd2l0aCBleHByZXNzaW9ucyB0aGF0IGZvbGxvd1xuICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gc291cmNlL3RhcmdldFxuICAgICAgdmFyIHNyY1RndFEgPSBuZXdRdWVyeSgpO1xuICAgICAgdmFyIF9zb3VyY2UgPSBxdWVyeTtcbiAgICAgIHZhciBfdGFyZ2V0ID0gbmV3UXVlcnkoKTtcbiAgICAgIHNyY1RndFEuY2hlY2tzLnB1c2goe1xuICAgICAgICB0eXBlOiBUeXBlLk5PREVfU09VUkNFLFxuICAgICAgICBzb3VyY2U6IF9zb3VyY2UsXG4gICAgICAgIHRhcmdldDogX3RhcmdldFxuICAgICAgfSk7XG5cbiAgICAgIC8vIHRoZSBxdWVyeSBpbiB0aGUgc2VsZWN0b3Igc2hvdWxkIGJlIHRoZSBuZWlnaGJvdXJob29kIHJhdGhlciB0aGFuIHRoZSBub2RlXG4gICAgICByZXBsYWNlTGFzdFF1ZXJ5KHNlbGVjdG9yLCBxdWVyeSwgc3JjVGd0USk7XG4gICAgICBzZWxlY3Rvci5lZGdlQ291bnQrKztcbiAgICAgIHJldHVybiBfdGFyZ2V0OyAvLyBub3cgcG9wdWxhdGluZyB0aGUgdGFyZ2V0IHdpdGggdGhlIGZvbGxvd2luZyBleHByZXNzaW9uc1xuICAgIH1cbiAgfVxufSwge1xuICBuYW1lOiAndW5kaXJlY3RlZEVkZ2UnLFxuICBzZXBhcmF0b3I6IHRydWUsXG4gIHJlZ2V4OiB0b2tlbnMudW5kaXJlY3RlZEVkZ2UsXG4gIHBvcHVsYXRlOiBmdW5jdGlvbiBwb3B1bGF0ZShzZWxlY3RvciwgcXVlcnkpIHtcbiAgICBpZiAoc2VsZWN0b3IuY3VycmVudFN1YmplY3QgPT0gbnVsbCkge1xuICAgICAgLy8gdW5kaXJlY3RlZCBlZGdlXG4gICAgICB2YXIgZWRnZVF1ZXJ5ID0gbmV3UXVlcnkoKTtcbiAgICAgIHZhciBzb3VyY2UgPSBxdWVyeTtcbiAgICAgIHZhciB0YXJnZXQgPSBuZXdRdWVyeSgpO1xuICAgICAgZWRnZVF1ZXJ5LmNoZWNrcy5wdXNoKHtcbiAgICAgICAgdHlwZTogVHlwZS5VTkRJUkVDVEVEX0VER0UsXG4gICAgICAgIG5vZGVzOiBbc291cmNlLCB0YXJnZXRdXG4gICAgICB9KTtcblxuICAgICAgLy8gdGhlIHF1ZXJ5IGluIHRoZSBzZWxlY3RvciBzaG91bGQgYmUgdGhlIGVkZ2UgcmF0aGVyIHRoYW4gdGhlIHNvdXJjZVxuICAgICAgcmVwbGFjZUxhc3RRdWVyeShzZWxlY3RvciwgcXVlcnksIGVkZ2VRdWVyeSk7XG4gICAgICBzZWxlY3Rvci5lZGdlQ291bnQrKztcblxuICAgICAgLy8gd2UncmUgbm93IHBvcHVsYXRpbmcgdGhlIHRhcmdldCBxdWVyeSB3aXRoIGV4cHJlc3Npb25zIHRoYXQgZm9sbG93XG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBuZWlnaGJvdXJob29kXG4gICAgICB2YXIgbmhvb2RRID0gbmV3UXVlcnkoKTtcbiAgICAgIHZhciBub2RlID0gcXVlcnk7XG4gICAgICB2YXIgbmVpZ2hib3IgPSBuZXdRdWVyeSgpO1xuICAgICAgbmhvb2RRLmNoZWNrcy5wdXNoKHtcbiAgICAgICAgdHlwZTogVHlwZS5OT0RFX05FSUdIQk9SLFxuICAgICAgICBub2RlOiBub2RlLFxuICAgICAgICBuZWlnaGJvcjogbmVpZ2hib3JcbiAgICAgIH0pO1xuXG4gICAgICAvLyB0aGUgcXVlcnkgaW4gdGhlIHNlbGVjdG9yIHNob3VsZCBiZSB0aGUgbmVpZ2hib3VyaG9vZCByYXRoZXIgdGhhbiB0aGUgbm9kZVxuICAgICAgcmVwbGFjZUxhc3RRdWVyeShzZWxlY3RvciwgcXVlcnksIG5ob29kUSk7XG4gICAgICByZXR1cm4gbmVpZ2hib3I7IC8vIG5vdyBwb3B1bGF0aW5nIHRoZSBuZWlnaGJvciB3aXRoIGZvbGxvd2luZyBleHByZXNzaW9uc1xuICAgIH1cbiAgfVxufSwge1xuICBuYW1lOiAnY2hpbGQnLFxuICBzZXBhcmF0b3I6IHRydWUsXG4gIHJlZ2V4OiB0b2tlbnMuY2hpbGQsXG4gIHBvcHVsYXRlOiBmdW5jdGlvbiBwb3B1bGF0ZShzZWxlY3RvciwgcXVlcnkpIHtcbiAgICBpZiAoc2VsZWN0b3IuY3VycmVudFN1YmplY3QgPT0gbnVsbCkge1xuICAgICAgLy8gZGVmYXVsdDogY2hpbGQgcXVlcnlcbiAgICAgIHZhciBwYXJlbnRDaGlsZFF1ZXJ5ID0gbmV3UXVlcnkoKTtcbiAgICAgIHZhciBjaGlsZCA9IG5ld1F1ZXJ5KCk7XG4gICAgICB2YXIgcGFyZW50ID0gc2VsZWN0b3Jbc2VsZWN0b3IubGVuZ3RoIC0gMV07XG4gICAgICBwYXJlbnRDaGlsZFF1ZXJ5LmNoZWNrcy5wdXNoKHtcbiAgICAgICAgdHlwZTogVHlwZS5DSElMRCxcbiAgICAgICAgcGFyZW50OiBwYXJlbnQsXG4gICAgICAgIGNoaWxkOiBjaGlsZFxuICAgICAgfSk7XG5cbiAgICAgIC8vIHRoZSBxdWVyeSBpbiB0aGUgc2VsZWN0b3Igc2hvdWxkIGJlIHRoZSAnPicgaXRzZWxmXG4gICAgICByZXBsYWNlTGFzdFF1ZXJ5KHNlbGVjdG9yLCBxdWVyeSwgcGFyZW50Q2hpbGRRdWVyeSk7XG4gICAgICBzZWxlY3Rvci5jb21wb3VuZENvdW50Kys7XG5cbiAgICAgIC8vIHdlJ3JlIG5vdyBwb3B1bGF0aW5nIHRoZSBjaGlsZCBxdWVyeSB3aXRoIGV4cHJlc3Npb25zIHRoYXQgZm9sbG93XG4gICAgICByZXR1cm4gY2hpbGQ7XG4gICAgfSBlbHNlIGlmIChzZWxlY3Rvci5jdXJyZW50U3ViamVjdCA9PT0gcXVlcnkpIHtcbiAgICAgIC8vIGNvbXBvdW5kIHNwbGl0IHF1ZXJ5XG4gICAgICB2YXIgY29tcG91bmQgPSBuZXdRdWVyeSgpO1xuICAgICAgdmFyIGxlZnQgPSBzZWxlY3RvcltzZWxlY3Rvci5sZW5ndGggLSAxXTtcbiAgICAgIHZhciByaWdodCA9IG5ld1F1ZXJ5KCk7XG4gICAgICB2YXIgc3ViamVjdCA9IG5ld1F1ZXJ5KCk7XG4gICAgICB2YXIgX2NoaWxkID0gbmV3UXVlcnkoKTtcbiAgICAgIHZhciBfcGFyZW50ID0gbmV3UXVlcnkoKTtcblxuICAgICAgLy8gc2V0IHVwIHRoZSByb290IGNvbXBvdW5kIHFcbiAgICAgIGNvbXBvdW5kLmNoZWNrcy5wdXNoKHtcbiAgICAgICAgdHlwZTogVHlwZS5DT01QT1VORF9TUExJVCxcbiAgICAgICAgbGVmdDogbGVmdCxcbiAgICAgICAgcmlnaHQ6IHJpZ2h0LFxuICAgICAgICBzdWJqZWN0OiBzdWJqZWN0XG4gICAgICB9KTtcblxuICAgICAgLy8gcG9wdWxhdGUgdGhlIHN1YmplY3QgYW5kIHJlcGxhY2UgdGhlIHEgYXQgdGhlIG9sZCBzcG90ICh3aXRoaW4gbGVmdCkgd2l0aCBUUlVFXG4gICAgICBzdWJqZWN0LmNoZWNrcyA9IHF1ZXJ5LmNoZWNrczsgLy8gdGFrZSB0aGUgY2hlY2tzIGZyb20gdGhlIGxlZnRcbiAgICAgIHF1ZXJ5LmNoZWNrcyA9IFt7XG4gICAgICAgIHR5cGU6IFR5cGUuVFJVRVxuICAgICAgfV07IC8vIGNoZWNrcyB1bmRlciBsZWZ0IHJlZnMgdGhlIHN1YmplY3QgaW1wbGljaXRseVxuXG4gICAgICAvLyBzZXQgdXAgdGhlIHJpZ2h0IHFcbiAgICAgIF9wYXJlbnQuY2hlY2tzLnB1c2goe1xuICAgICAgICB0eXBlOiBUeXBlLlRSVUVcbiAgICAgIH0pOyAvLyBwYXJlbnQgaW1wbGljaXRseSByZWZzIHRoZSBzdWJqZWN0XG4gICAgICByaWdodC5jaGVja3MucHVzaCh7XG4gICAgICAgIHR5cGU6IFR5cGUuUEFSRU5ULFxuICAgICAgICAvLyB0eXBlIGlzIHN3YXBwZWQgb24gcmlnaHQgc2lkZSBxdWVyaWVzXG4gICAgICAgIHBhcmVudDogX3BhcmVudCxcbiAgICAgICAgY2hpbGQ6IF9jaGlsZCAvLyBlbXB0eSBmb3Igbm93XG4gICAgICB9KTtcblxuICAgICAgcmVwbGFjZUxhc3RRdWVyeShzZWxlY3RvciwgbGVmdCwgY29tcG91bmQpO1xuXG4gICAgICAvLyB1cGRhdGUgdGhlIHJlZiBzaW5jZSB3ZSBtb3ZlZCB0aGluZ3MgYXJvdW5kIGZvciBgcXVlcnlgXG4gICAgICBzZWxlY3Rvci5jdXJyZW50U3ViamVjdCA9IHN1YmplY3Q7XG4gICAgICBzZWxlY3Rvci5jb21wb3VuZENvdW50Kys7XG4gICAgICByZXR1cm4gX2NoaWxkOyAvLyBub3cgcG9wdWxhdGluZyB0aGUgcmlnaHQgc2lkZSdzIGNoaWxkXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHBhcmVudCBxdWVyeVxuICAgICAgLy8gaW5mbyBmb3IgcGFyZW50IHF1ZXJ5XG4gICAgICB2YXIgX3BhcmVudDIgPSBuZXdRdWVyeSgpO1xuICAgICAgdmFyIF9jaGlsZDIgPSBuZXdRdWVyeSgpO1xuICAgICAgdmFyIHBjUUNoZWNrcyA9IFt7XG4gICAgICAgIHR5cGU6IFR5cGUuUEFSRU5ULFxuICAgICAgICBwYXJlbnQ6IF9wYXJlbnQyLFxuICAgICAgICBjaGlsZDogX2NoaWxkMlxuICAgICAgfV07XG5cbiAgICAgIC8vIHRoZSBwYXJlbnQtY2hpbGQgcXVlcnkgdGFrZXMgdGhlIHBsYWNlIG9mIHRoZSBxdWVyeSBwcmV2aW91c2x5IGJlaW5nIHBvcHVsYXRlZFxuICAgICAgX3BhcmVudDIuY2hlY2tzID0gcXVlcnkuY2hlY2tzOyAvLyB0aGUgcHJldmlvdXMgcXVlcnkgY29udGFpbnMgdGhlIGNoZWNrcyBmb3IgdGhlIHBhcmVudFxuICAgICAgcXVlcnkuY2hlY2tzID0gcGNRQ2hlY2tzOyAvLyBwYyBxdWVyeSB0YWtlcyBvdmVyXG5cbiAgICAgIHNlbGVjdG9yLmNvbXBvdW5kQ291bnQrKztcbiAgICAgIHJldHVybiBfY2hpbGQyOyAvLyB3ZSdyZSBub3cgcG9wdWxhdGluZyB0aGUgY2hpbGRcbiAgICB9XG4gIH1cbn0sIHtcbiAgbmFtZTogJ2Rlc2NlbmRhbnQnLFxuICBzZXBhcmF0b3I6IHRydWUsXG4gIHJlZ2V4OiB0b2tlbnMuZGVzY2VuZGFudCxcbiAgcG9wdWxhdGU6IGZ1bmN0aW9uIHBvcHVsYXRlKHNlbGVjdG9yLCBxdWVyeSkge1xuICAgIGlmIChzZWxlY3Rvci5jdXJyZW50U3ViamVjdCA9PSBudWxsKSB7XG4gICAgICAvLyBkZWZhdWx0OiBkZXNjZW5kYW50IHF1ZXJ5XG4gICAgICB2YXIgYW5jQ2hRdWVyeSA9IG5ld1F1ZXJ5KCk7XG4gICAgICB2YXIgZGVzY2VuZGFudCA9IG5ld1F1ZXJ5KCk7XG4gICAgICB2YXIgYW5jZXN0b3IgPSBzZWxlY3RvcltzZWxlY3Rvci5sZW5ndGggLSAxXTtcbiAgICAgIGFuY0NoUXVlcnkuY2hlY2tzLnB1c2goe1xuICAgICAgICB0eXBlOiBUeXBlLkRFU0NFTkRBTlQsXG4gICAgICAgIGFuY2VzdG9yOiBhbmNlc3RvcixcbiAgICAgICAgZGVzY2VuZGFudDogZGVzY2VuZGFudFxuICAgICAgfSk7XG5cbiAgICAgIC8vIHRoZSBxdWVyeSBpbiB0aGUgc2VsZWN0b3Igc2hvdWxkIGJlIHRoZSAnPicgaXRzZWxmXG4gICAgICByZXBsYWNlTGFzdFF1ZXJ5KHNlbGVjdG9yLCBxdWVyeSwgYW5jQ2hRdWVyeSk7XG4gICAgICBzZWxlY3Rvci5jb21wb3VuZENvdW50Kys7XG5cbiAgICAgIC8vIHdlJ3JlIG5vdyBwb3B1bGF0aW5nIHRoZSBkZXNjZW5kYW50IHF1ZXJ5IHdpdGggZXhwcmVzc2lvbnMgdGhhdCBmb2xsb3dcbiAgICAgIHJldHVybiBkZXNjZW5kYW50O1xuICAgIH0gZWxzZSBpZiAoc2VsZWN0b3IuY3VycmVudFN1YmplY3QgPT09IHF1ZXJ5KSB7XG4gICAgICAvLyBjb21wb3VuZCBzcGxpdCBxdWVyeVxuICAgICAgdmFyIGNvbXBvdW5kID0gbmV3UXVlcnkoKTtcbiAgICAgIHZhciBsZWZ0ID0gc2VsZWN0b3Jbc2VsZWN0b3IubGVuZ3RoIC0gMV07XG4gICAgICB2YXIgcmlnaHQgPSBuZXdRdWVyeSgpO1xuICAgICAgdmFyIHN1YmplY3QgPSBuZXdRdWVyeSgpO1xuICAgICAgdmFyIF9kZXNjZW5kYW50ID0gbmV3UXVlcnkoKTtcbiAgICAgIHZhciBfYW5jZXN0b3IgPSBuZXdRdWVyeSgpO1xuXG4gICAgICAvLyBzZXQgdXAgdGhlIHJvb3QgY29tcG91bmQgcVxuICAgICAgY29tcG91bmQuY2hlY2tzLnB1c2goe1xuICAgICAgICB0eXBlOiBUeXBlLkNPTVBPVU5EX1NQTElULFxuICAgICAgICBsZWZ0OiBsZWZ0LFxuICAgICAgICByaWdodDogcmlnaHQsXG4gICAgICAgIHN1YmplY3Q6IHN1YmplY3RcbiAgICAgIH0pO1xuXG4gICAgICAvLyBwb3B1bGF0ZSB0aGUgc3ViamVjdCBhbmQgcmVwbGFjZSB0aGUgcSBhdCB0aGUgb2xkIHNwb3QgKHdpdGhpbiBsZWZ0KSB3aXRoIFRSVUVcbiAgICAgIHN1YmplY3QuY2hlY2tzID0gcXVlcnkuY2hlY2tzOyAvLyB0YWtlIHRoZSBjaGVja3MgZnJvbSB0aGUgbGVmdFxuICAgICAgcXVlcnkuY2hlY2tzID0gW3tcbiAgICAgICAgdHlwZTogVHlwZS5UUlVFXG4gICAgICB9XTsgLy8gY2hlY2tzIHVuZGVyIGxlZnQgcmVmcyB0aGUgc3ViamVjdCBpbXBsaWNpdGx5XG5cbiAgICAgIC8vIHNldCB1cCB0aGUgcmlnaHQgcVxuICAgICAgX2FuY2VzdG9yLmNoZWNrcy5wdXNoKHtcbiAgICAgICAgdHlwZTogVHlwZS5UUlVFXG4gICAgICB9KTsgLy8gYW5jZXN0b3IgaW1wbGljaXRseSByZWZzIHRoZSBzdWJqZWN0XG4gICAgICByaWdodC5jaGVja3MucHVzaCh7XG4gICAgICAgIHR5cGU6IFR5cGUuQU5DRVNUT1IsXG4gICAgICAgIC8vIHR5cGUgaXMgc3dhcHBlZCBvbiByaWdodCBzaWRlIHF1ZXJpZXNcbiAgICAgICAgYW5jZXN0b3I6IF9hbmNlc3RvcixcbiAgICAgICAgZGVzY2VuZGFudDogX2Rlc2NlbmRhbnQgLy8gZW1wdHkgZm9yIG5vd1xuICAgICAgfSk7XG5cbiAgICAgIHJlcGxhY2VMYXN0UXVlcnkoc2VsZWN0b3IsIGxlZnQsIGNvbXBvdW5kKTtcblxuICAgICAgLy8gdXBkYXRlIHRoZSByZWYgc2luY2Ugd2UgbW92ZWQgdGhpbmdzIGFyb3VuZCBmb3IgYHF1ZXJ5YFxuICAgICAgc2VsZWN0b3IuY3VycmVudFN1YmplY3QgPSBzdWJqZWN0O1xuICAgICAgc2VsZWN0b3IuY29tcG91bmRDb3VudCsrO1xuICAgICAgcmV0dXJuIF9kZXNjZW5kYW50OyAvLyBub3cgcG9wdWxhdGluZyB0aGUgcmlnaHQgc2lkZSdzIGRlc2NlbmRhbnRcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gYW5jZXN0b3IgcXVlcnlcbiAgICAgIC8vIGluZm8gZm9yIHBhcmVudCBxdWVyeVxuICAgICAgdmFyIF9hbmNlc3RvcjIgPSBuZXdRdWVyeSgpO1xuICAgICAgdmFyIF9kZXNjZW5kYW50MiA9IG5ld1F1ZXJ5KCk7XG4gICAgICB2YXIgYWRRQ2hlY2tzID0gW3tcbiAgICAgICAgdHlwZTogVHlwZS5BTkNFU1RPUixcbiAgICAgICAgYW5jZXN0b3I6IF9hbmNlc3RvcjIsXG4gICAgICAgIGRlc2NlbmRhbnQ6IF9kZXNjZW5kYW50MlxuICAgICAgfV07XG5cbiAgICAgIC8vIHRoZSBwYXJlbnQtY2hpbGQgcXVlcnkgdGFrZXMgdGhlIHBsYWNlIG9mIHRoZSBxdWVyeSBwcmV2aW91c2x5IGJlaW5nIHBvcHVsYXRlZFxuICAgICAgX2FuY2VzdG9yMi5jaGVja3MgPSBxdWVyeS5jaGVja3M7IC8vIHRoZSBwcmV2aW91cyBxdWVyeSBjb250YWlucyB0aGUgY2hlY2tzIGZvciB0aGUgcGFyZW50XG4gICAgICBxdWVyeS5jaGVja3MgPSBhZFFDaGVja3M7IC8vIHBjIHF1ZXJ5IHRha2VzIG92ZXJcblxuICAgICAgc2VsZWN0b3IuY29tcG91bmRDb3VudCsrO1xuICAgICAgcmV0dXJuIF9kZXNjZW5kYW50MjsgLy8gd2UncmUgbm93IHBvcHVsYXRpbmcgdGhlIGNoaWxkXG4gICAgfVxuICB9XG59LCB7XG4gIG5hbWU6ICdzdWJqZWN0JyxcbiAgbW9kaWZpZXI6IHRydWUsXG4gIHJlZ2V4OiB0b2tlbnMuc3ViamVjdCxcbiAgcG9wdWxhdGU6IGZ1bmN0aW9uIHBvcHVsYXRlKHNlbGVjdG9yLCBxdWVyeSkge1xuICAgIGlmIChzZWxlY3Rvci5jdXJyZW50U3ViamVjdCAhPSBudWxsICYmIHNlbGVjdG9yLmN1cnJlbnRTdWJqZWN0ICE9PSBxdWVyeSkge1xuICAgICAgd2FybignUmVkZWZpbml0aW9uIG9mIHN1YmplY3QgaW4gc2VsZWN0b3IgYCcgKyBzZWxlY3Rvci50b1N0cmluZygpICsgJ2AnKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgc2VsZWN0b3IuY3VycmVudFN1YmplY3QgPSBxdWVyeTtcbiAgICB2YXIgdG9wUSA9IHNlbGVjdG9yW3NlbGVjdG9yLmxlbmd0aCAtIDFdO1xuICAgIHZhciB0b3BDaGsgPSB0b3BRLmNoZWNrc1swXTtcbiAgICB2YXIgdG9wVHlwZSA9IHRvcENoayA9PSBudWxsID8gbnVsbCA6IHRvcENoay50eXBlO1xuICAgIGlmICh0b3BUeXBlID09PSBUeXBlLkRJUkVDVEVEX0VER0UpIHtcbiAgICAgIC8vIGRpcmVjdGVkIGVkZ2Ugd2l0aCBzdWJqZWN0IG9uIHRoZSB0YXJnZXRcblxuICAgICAgLy8gY2hhbmdlIHRvIHRhcmdldCBub2RlIGNoZWNrXG4gICAgICB0b3BDaGsudHlwZSA9IFR5cGUuTk9ERV9UQVJHRVQ7XG4gICAgfSBlbHNlIGlmICh0b3BUeXBlID09PSBUeXBlLlVORElSRUNURURfRURHRSkge1xuICAgICAgLy8gdW5kaXJlY3RlZCBlZGdlIHdpdGggc3ViamVjdCBvbiB0aGUgc2Vjb25kIG5vZGVcblxuICAgICAgLy8gY2hhbmdlIHRvIG5laWdoYm9yIGNoZWNrXG4gICAgICB0b3BDaGsudHlwZSA9IFR5cGUuTk9ERV9ORUlHSEJPUjtcbiAgICAgIHRvcENoay5ub2RlID0gdG9wQ2hrLm5vZGVzWzFdOyAvLyBzZWNvbmQgbm9kZSBpcyBzdWJqZWN0XG4gICAgICB0b3BDaGsubmVpZ2hib3IgPSB0b3BDaGsubm9kZXNbMF07XG5cbiAgICAgIC8vIGNsZWFuIHVwIHVudXNlZCBmaWVsZHMgZm9yIG5ldyB0eXBlXG4gICAgICB0b3BDaGsubm9kZXMgPSBudWxsO1xuICAgIH1cbiAgfVxufV07XG5leHBycy5mb3JFYWNoKGZ1bmN0aW9uIChlKSB7XG4gIHJldHVybiBlLnJlZ2V4T2JqID0gbmV3IFJlZ0V4cCgnXicgKyBlLnJlZ2V4KTtcbn0pO1xuXG4vKipcbiAqIE9mIGFsbCB0aGUgZXhwcmVzc2lvbnMsIGZpbmQgdGhlIGZpcnN0IG1hdGNoIGluIHRoZSByZW1haW5pbmcgdGV4dC5cbiAqIEBwYXJhbSB7c3RyaW5nfSByZW1haW5pbmcgVGhlIHJlbWFpbmluZyB0ZXh0IHRvIHBhcnNlXG4gKiBAcmV0dXJucyBUaGUgbWF0Y2hlZCBleHByZXNzaW9uIGFuZCB0aGUgbmV3bHkgcmVtYWluaW5nIHRleHQgYHsgZXhwciwgbWF0Y2gsIG5hbWUsIHJlbWFpbmluZyB9YFxuICovXG52YXIgY29uc3VtZUV4cHIgPSBmdW5jdGlvbiBjb25zdW1lRXhwcihyZW1haW5pbmcpIHtcbiAgdmFyIGV4cHI7XG4gIHZhciBtYXRjaDtcbiAgdmFyIG5hbWU7XG4gIGZvciAodmFyIGogPSAwOyBqIDwgZXhwcnMubGVuZ3RoOyBqKyspIHtcbiAgICB2YXIgZSA9IGV4cHJzW2pdO1xuICAgIHZhciBuID0gZS5uYW1lO1xuICAgIHZhciBtID0gcmVtYWluaW5nLm1hdGNoKGUucmVnZXhPYmopO1xuICAgIGlmIChtICE9IG51bGwpIHtcbiAgICAgIG1hdGNoID0gbTtcbiAgICAgIGV4cHIgPSBlO1xuICAgICAgbmFtZSA9IG47XG4gICAgICB2YXIgY29uc3VtZWQgPSBtWzBdO1xuICAgICAgcmVtYWluaW5nID0gcmVtYWluaW5nLnN1YnN0cmluZyhjb25zdW1lZC5sZW5ndGgpO1xuICAgICAgYnJlYWs7IC8vIHdlJ3ZlIGNvbnN1bWVkIG9uZSBleHByLCBzbyB3ZSBjYW4gcmV0dXJuIG5vd1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgZXhwcjogZXhwcixcbiAgICBtYXRjaDogbWF0Y2gsXG4gICAgbmFtZTogbmFtZSxcbiAgICByZW1haW5pbmc6IHJlbWFpbmluZ1xuICB9O1xufTtcblxuLyoqXG4gKiBDb25zdW1lIGFsbCB0aGUgbGVhZGluZyB3aGl0ZXNwYWNlXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVtYWluaW5nIFRoZSB0ZXh0IHRvIGNvbnN1bWVcbiAqIEByZXR1cm5zIFRoZSB0ZXh0IHdpdGggdGhlIGxlYWRpbmcgd2hpdGVzcGFjZSByZW1vdmVkXG4gKi9cbnZhciBjb25zdW1lV2hpdGVzcGFjZSA9IGZ1bmN0aW9uIGNvbnN1bWVXaGl0ZXNwYWNlKHJlbWFpbmluZykge1xuICB2YXIgbWF0Y2ggPSByZW1haW5pbmcubWF0Y2goL15cXHMrLyk7XG4gIGlmIChtYXRjaCkge1xuICAgIHZhciBjb25zdW1lZCA9IG1hdGNoWzBdO1xuICAgIHJlbWFpbmluZyA9IHJlbWFpbmluZy5zdWJzdHJpbmcoY29uc3VtZWQubGVuZ3RoKTtcbiAgfVxuICByZXR1cm4gcmVtYWluaW5nO1xufTtcblxuLyoqXG4gKiBQYXJzZSB0aGUgc3RyaW5nIGFuZCBzdG9yZSB0aGUgcGFyc2VkIHJlcHJlc2VudGF0aW9uIGluIHRoZSBTZWxlY3Rvci5cbiAqIEBwYXJhbSB7c3RyaW5nfSBzZWxlY3RvciBUaGUgc2VsZWN0b3Igc3RyaW5nXG4gKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHNlbGVjdG9yIHdhcyBzdWNjZXNzZnVsbHkgcGFyc2VkLCBgZmFsc2VgIG90aGVyd2lzZVxuICovXG52YXIgcGFyc2UgPSBmdW5jdGlvbiBwYXJzZShzZWxlY3Rvcikge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciByZW1haW5pbmcgPSBzZWxmLmlucHV0VGV4dCA9IHNlbGVjdG9yO1xuICB2YXIgY3VycmVudFF1ZXJ5ID0gc2VsZlswXSA9IG5ld1F1ZXJ5KCk7XG4gIHNlbGYubGVuZ3RoID0gMTtcbiAgcmVtYWluaW5nID0gY29uc3VtZVdoaXRlc3BhY2UocmVtYWluaW5nKTsgLy8gZ2V0IHJpZCBvZiBsZWFkaW5nIHdoaXRlc3BhY2VcblxuICBmb3IgKDs7KSB7XG4gICAgdmFyIGV4cHJJbmZvID0gY29uc3VtZUV4cHIocmVtYWluaW5nKTtcbiAgICBpZiAoZXhwckluZm8uZXhwciA9PSBudWxsKSB7XG4gICAgICB3YXJuKCdUaGUgc2VsZWN0b3IgYCcgKyBzZWxlY3RvciArICdgaXMgaW52YWxpZCcpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYXJncyA9IGV4cHJJbmZvLm1hdGNoLnNsaWNlKDEpO1xuXG4gICAgICAvLyBsZXQgdGhlIHRva2VuIHBvcHVsYXRlIHRoZSBzZWxlY3RvciBvYmplY3QgaW4gY3VycmVudFF1ZXJ5XG4gICAgICB2YXIgcmV0ID0gZXhwckluZm8uZXhwci5wb3B1bGF0ZShzZWxmLCBjdXJyZW50UXVlcnksIGFyZ3MpO1xuICAgICAgaWYgKHJldCA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBleGl0IGlmIHBvcHVsYXRpb24gZmFpbGVkXG4gICAgICB9IGVsc2UgaWYgKHJldCAhPSBudWxsKSB7XG4gICAgICAgIGN1cnJlbnRRdWVyeSA9IHJldDsgLy8gY2hhbmdlIHRoZSBjdXJyZW50IHF1ZXJ5IHRvIGJlIGZpbGxlZCBpZiB0aGUgZXhwciBzcGVjaWZpZXNcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZW1haW5pbmcgPSBleHBySW5mby5yZW1haW5pbmc7XG5cbiAgICAvLyB3ZSdyZSBkb25lIHdoZW4gdGhlcmUncyBub3RoaW5nIGxlZnQgdG8gcGFyc2VcbiAgICBpZiAocmVtYWluaW5nLm1hdGNoKC9eXFxzKiQvKSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHZhciBsYXN0USA9IHNlbGZbc2VsZi5sZW5ndGggLSAxXTtcbiAgaWYgKHNlbGYuY3VycmVudFN1YmplY3QgIT0gbnVsbCkge1xuICAgIGxhc3RRLnN1YmplY3QgPSBzZWxmLmN1cnJlbnRTdWJqZWN0O1xuICB9XG4gIGxhc3RRLmVkZ2VDb3VudCA9IHNlbGYuZWRnZUNvdW50O1xuICBsYXN0US5jb21wb3VuZENvdW50ID0gc2VsZi5jb21wb3VuZENvdW50O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbGYubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcSA9IHNlbGZbaV07XG5cbiAgICAvLyBpbiBmdXR1cmUsIHRoaXMgY291bGQgcG90ZW50aWFsbHkgYmUgYWxsb3dlZCBpZiB0aGVyZSB3ZXJlIG9wZXJhdG9yIHByZWNlZGVuY2UgYW5kIGRldGVjdGlvbiBvZiBpbnZhbGlkIGNvbWJpbmF0aW9uc1xuICAgIGlmIChxLmNvbXBvdW5kQ291bnQgPiAwICYmIHEuZWRnZUNvdW50ID4gMCkge1xuICAgICAgd2FybignVGhlIHNlbGVjdG9yIGAnICsgc2VsZWN0b3IgKyAnYCBpcyBpbnZhbGlkIGJlY2F1c2UgaXQgdXNlcyBib3RoIGEgY29tcG91bmQgc2VsZWN0b3IgYW5kIGFuIGVkZ2Ugc2VsZWN0b3InKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHEuZWRnZUNvdW50ID4gMSkge1xuICAgICAgd2FybignVGhlIHNlbGVjdG9yIGAnICsgc2VsZWN0b3IgKyAnYCBpcyBpbnZhbGlkIGJlY2F1c2UgaXQgdXNlcyBtdWx0aXBsZSBlZGdlIHNlbGVjdG9ycycpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSBpZiAocS5lZGdlQ291bnQgPT09IDEpIHtcbiAgICAgIHdhcm4oJ1RoZSBzZWxlY3RvciBgJyArIHNlbGVjdG9yICsgJ2AgaXMgZGVwcmVjYXRlZC4gIEVkZ2Ugc2VsZWN0b3JzIGRvIG5vdCB0YWtlIGVmZmVjdCBvbiBjaGFuZ2VzIHRvIHNvdXJjZSBhbmQgdGFyZ2V0IG5vZGVzIGFmdGVyIGFuIGVkZ2UgaXMgYWRkZWQsIGZvciBwZXJmb3JtYW5jZSByZWFzb25zLiAgVXNlIGEgY2xhc3Mgb3IgZGF0YSBzZWxlY3RvciBvbiBlZGdlcyBpbnN0ZWFkLCB1cGRhdGluZyB0aGUgY2xhc3Mgb3IgZGF0YSBvZiBhbiBlZGdlIHdoZW4geW91ciBhcHAgZGV0ZWN0cyBhIGNoYW5nZSBpbiBzb3VyY2Ugb3IgdGFyZ2V0IG5vZGVzLicpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTsgLy8gc3VjY2Vzc1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIHNlbGVjdG9yIHJlcHJlc2VudGVkIGFzIGEgc3RyaW5nLiAgVGhpcyB2YWx1ZSB1c2VzIGRlZmF1bHQgZm9ybWF0dGluZyxcbiAqIHNvIHRoaW5ncyBsaWtlIHNwYWNpbmcgbWF5IGRpZmZlciBmcm9tIHRoZSBpbnB1dCB0ZXh0IHBhc3NlZCB0byB0aGUgY29uc3RydWN0b3IuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgc2VsZWN0b3Igc3RyaW5nXG4gKi9cbnZhciB0b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICBpZiAodGhpcy50b1N0cmluZ0NhY2hlICE9IG51bGwpIHtcbiAgICByZXR1cm4gdGhpcy50b1N0cmluZ0NhY2hlO1xuICB9XG4gIHZhciBjbGVhbiA9IGZ1bmN0aW9uIGNsZWFuKG9iaikge1xuICAgIGlmIChvYmogPT0gbnVsbCkge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gb2JqO1xuICAgIH1cbiAgfTtcbiAgdmFyIGNsZWFuVmFsID0gZnVuY3Rpb24gY2xlYW5WYWwodmFsKSB7XG4gICAgaWYgKHN0cmluZyh2YWwpKSB7XG4gICAgICByZXR1cm4gJ1wiJyArIHZhbCArICdcIic7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBjbGVhbih2YWwpO1xuICAgIH1cbiAgfTtcbiAgdmFyIHNwYWNlID0gZnVuY3Rpb24gc3BhY2UodmFsKSB7XG4gICAgcmV0dXJuICcgJyArIHZhbCArICcgJztcbiAgfTtcbiAgdmFyIGNoZWNrVG9TdHJpbmcgPSBmdW5jdGlvbiBjaGVja1RvU3RyaW5nKGNoZWNrLCBzdWJqZWN0KSB7XG4gICAgdmFyIHR5cGUgPSBjaGVjay50eXBlLFxuICAgICAgdmFsdWUgPSBjaGVjay52YWx1ZTtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgVHlwZS5HUk9VUDpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBncm91cCA9IGNsZWFuKHZhbHVlKTtcbiAgICAgICAgICByZXR1cm4gZ3JvdXAuc3Vic3RyaW5nKDAsIGdyb3VwLmxlbmd0aCAtIDEpO1xuICAgICAgICB9XG4gICAgICBjYXNlIFR5cGUuREFUQV9DT01QQVJFOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGZpZWxkID0gY2hlY2suZmllbGQsXG4gICAgICAgICAgICBvcGVyYXRvciA9IGNoZWNrLm9wZXJhdG9yO1xuICAgICAgICAgIHJldHVybiAnWycgKyBmaWVsZCArIHNwYWNlKGNsZWFuKG9wZXJhdG9yKSkgKyBjbGVhblZhbCh2YWx1ZSkgKyAnXSc7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgVHlwZS5EQVRBX0JPT0w6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgX29wZXJhdG9yID0gY2hlY2sub3BlcmF0b3IsXG4gICAgICAgICAgICBfZmllbGQgPSBjaGVjay5maWVsZDtcbiAgICAgICAgICByZXR1cm4gJ1snICsgY2xlYW4oX29wZXJhdG9yKSArIF9maWVsZCArICddJztcbiAgICAgICAgfVxuICAgICAgY2FzZSBUeXBlLkRBVEFfRVhJU1Q6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgX2ZpZWxkMiA9IGNoZWNrLmZpZWxkO1xuICAgICAgICAgIHJldHVybiAnWycgKyBfZmllbGQyICsgJ10nO1xuICAgICAgICB9XG4gICAgICBjYXNlIFR5cGUuTUVUQV9DT01QQVJFOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIF9vcGVyYXRvcjIgPSBjaGVjay5vcGVyYXRvcixcbiAgICAgICAgICAgIF9maWVsZDMgPSBjaGVjay5maWVsZDtcbiAgICAgICAgICByZXR1cm4gJ1tbJyArIF9maWVsZDMgKyBzcGFjZShjbGVhbihfb3BlcmF0b3IyKSkgKyBjbGVhblZhbCh2YWx1ZSkgKyAnXV0nO1xuICAgICAgICB9XG4gICAgICBjYXNlIFR5cGUuU1RBVEU6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgVHlwZS5JRDpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiAnIycgKyB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgY2FzZSBUeXBlLkNMQVNTOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuICcuJyArIHZhbHVlO1xuICAgICAgICB9XG4gICAgICBjYXNlIFR5cGUuUEFSRU5UOlxuICAgICAgY2FzZSBUeXBlLkNISUxEOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIHF1ZXJ5VG9TdHJpbmcoY2hlY2sucGFyZW50LCBzdWJqZWN0KSArIHNwYWNlKCc+JykgKyBxdWVyeVRvU3RyaW5nKGNoZWNrLmNoaWxkLCBzdWJqZWN0KTtcbiAgICAgICAgfVxuICAgICAgY2FzZSBUeXBlLkFOQ0VTVE9SOlxuICAgICAgY2FzZSBUeXBlLkRFU0NFTkRBTlQ6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gcXVlcnlUb1N0cmluZyhjaGVjay5hbmNlc3Rvciwgc3ViamVjdCkgKyAnICcgKyBxdWVyeVRvU3RyaW5nKGNoZWNrLmRlc2NlbmRhbnQsIHN1YmplY3QpO1xuICAgICAgICB9XG4gICAgICBjYXNlIFR5cGUuQ09NUE9VTkRfU1BMSVQ6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbGhzID0gcXVlcnlUb1N0cmluZyhjaGVjay5sZWZ0LCBzdWJqZWN0KTtcbiAgICAgICAgICB2YXIgc3ViID0gcXVlcnlUb1N0cmluZyhjaGVjay5zdWJqZWN0LCBzdWJqZWN0KTtcbiAgICAgICAgICB2YXIgcmhzID0gcXVlcnlUb1N0cmluZyhjaGVjay5yaWdodCwgc3ViamVjdCk7XG4gICAgICAgICAgcmV0dXJuIGxocyArIChsaHMubGVuZ3RoID4gMCA/ICcgJyA6ICcnKSArIHN1YiArIHJocztcbiAgICAgICAgfVxuICAgICAgY2FzZSBUeXBlLlRSVUU6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cbiAgICB9XG4gIH07XG4gIHZhciBxdWVyeVRvU3RyaW5nID0gZnVuY3Rpb24gcXVlcnlUb1N0cmluZyhxdWVyeSwgc3ViamVjdCkge1xuICAgIHJldHVybiBxdWVyeS5jaGVja3MucmVkdWNlKGZ1bmN0aW9uIChzdHIsIGNoaywgaSkge1xuICAgICAgcmV0dXJuIHN0ciArIChzdWJqZWN0ID09PSBxdWVyeSAmJiBpID09PSAwID8gJyQnIDogJycpICsgY2hlY2tUb1N0cmluZyhjaGssIHN1YmplY3QpO1xuICAgIH0sICcnKTtcbiAgfTtcbiAgdmFyIHN0ciA9ICcnO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcXVlcnkgPSB0aGlzW2ldO1xuICAgIHN0ciArPSBxdWVyeVRvU3RyaW5nKHF1ZXJ5LCBxdWVyeS5zdWJqZWN0KTtcbiAgICBpZiAodGhpcy5sZW5ndGggPiAxICYmIGkgPCB0aGlzLmxlbmd0aCAtIDEpIHtcbiAgICAgIHN0ciArPSAnLCAnO1xuICAgIH1cbiAgfVxuICB0aGlzLnRvU3RyaW5nQ2FjaGUgPSBzdHI7XG4gIHJldHVybiBzdHI7XG59O1xudmFyIHBhcnNlJDEgPSB7XG4gIHBhcnNlOiBwYXJzZSxcbiAgdG9TdHJpbmc6IHRvU3RyaW5nXG59O1xuXG52YXIgdmFsQ21wID0gZnVuY3Rpb24gdmFsQ21wKGZpZWxkVmFsLCBvcGVyYXRvciwgdmFsdWUpIHtcbiAgdmFyIG1hdGNoZXM7XG4gIHZhciBpc0ZpZWxkU3RyID0gc3RyaW5nKGZpZWxkVmFsKTtcbiAgdmFyIGlzRmllbGROdW0gPSBudW1iZXIkMShmaWVsZFZhbCk7XG4gIHZhciBpc1ZhbFN0ciA9IHN0cmluZyh2YWx1ZSk7XG4gIHZhciBmaWVsZFN0ciwgdmFsU3RyO1xuICB2YXIgY2FzZUluc2Vuc2l0aXZlID0gZmFsc2U7XG4gIHZhciBub3RFeHByID0gZmFsc2U7XG4gIHZhciBpc0luZXFDbXAgPSBmYWxzZTtcbiAgaWYgKG9wZXJhdG9yLmluZGV4T2YoJyEnKSA+PSAwKSB7XG4gICAgb3BlcmF0b3IgPSBvcGVyYXRvci5yZXBsYWNlKCchJywgJycpO1xuICAgIG5vdEV4cHIgPSB0cnVlO1xuICB9XG4gIGlmIChvcGVyYXRvci5pbmRleE9mKCdAJykgPj0gMCkge1xuICAgIG9wZXJhdG9yID0gb3BlcmF0b3IucmVwbGFjZSgnQCcsICcnKTtcbiAgICBjYXNlSW5zZW5zaXRpdmUgPSB0cnVlO1xuICB9XG4gIGlmIChpc0ZpZWxkU3RyIHx8IGlzVmFsU3RyIHx8IGNhc2VJbnNlbnNpdGl2ZSkge1xuICAgIGZpZWxkU3RyID0gIWlzRmllbGRTdHIgJiYgIWlzRmllbGROdW0gPyAnJyA6ICcnICsgZmllbGRWYWw7XG4gICAgdmFsU3RyID0gJycgKyB2YWx1ZTtcbiAgfVxuXG4gIC8vIGlmIHdlJ3JlIGRvaW5nIGEgY2FzZSBpbnNlbnNpdGl2ZSBjb21wYXJpc29uLCB0aGVuIHdlJ3JlIHVzaW5nIGEgU1RSSU5HIGNvbXBhcmlzb25cbiAgLy8gZXZlbiBpZiB3ZSdyZSBjb21wYXJpbmcgbnVtYmVyc1xuICBpZiAoY2FzZUluc2Vuc2l0aXZlKSB7XG4gICAgZmllbGRWYWwgPSBmaWVsZFN0ciA9IGZpZWxkU3RyLnRvTG93ZXJDYXNlKCk7XG4gICAgdmFsdWUgPSB2YWxTdHIgPSB2YWxTdHIudG9Mb3dlckNhc2UoKTtcbiAgfVxuICBzd2l0Y2ggKG9wZXJhdG9yKSB7XG4gICAgY2FzZSAnKj0nOlxuICAgICAgbWF0Y2hlcyA9IGZpZWxkU3RyLmluZGV4T2YodmFsU3RyKSA+PSAwO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnJD0nOlxuICAgICAgbWF0Y2hlcyA9IGZpZWxkU3RyLmluZGV4T2YodmFsU3RyLCBmaWVsZFN0ci5sZW5ndGggLSB2YWxTdHIubGVuZ3RoKSA+PSAwO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnXj0nOlxuICAgICAgbWF0Y2hlcyA9IGZpZWxkU3RyLmluZGV4T2YodmFsU3RyKSA9PT0gMDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJz0nOlxuICAgICAgbWF0Y2hlcyA9IGZpZWxkVmFsID09PSB2YWx1ZTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJz4nOlxuICAgICAgaXNJbmVxQ21wID0gdHJ1ZTtcbiAgICAgIG1hdGNoZXMgPSBmaWVsZFZhbCA+IHZhbHVlO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnPj0nOlxuICAgICAgaXNJbmVxQ21wID0gdHJ1ZTtcbiAgICAgIG1hdGNoZXMgPSBmaWVsZFZhbCA+PSB2YWx1ZTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJzwnOlxuICAgICAgaXNJbmVxQ21wID0gdHJ1ZTtcbiAgICAgIG1hdGNoZXMgPSBmaWVsZFZhbCA8IHZhbHVlO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnPD0nOlxuICAgICAgaXNJbmVxQ21wID0gdHJ1ZTtcbiAgICAgIG1hdGNoZXMgPSBmaWVsZFZhbCA8PSB2YWx1ZTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBtYXRjaGVzID0gZmFsc2U7XG4gICAgICBicmVhaztcbiAgfVxuXG4gIC8vIGFwcGx5IHRoZSBub3Qgb3AsIGJ1dCBudWxsIHZhbHMgZm9yIGluZXF1YWxpdGllcyBzaG91bGQgYWx3YXlzIHN0YXkgbm9uLW1hdGNoaW5nXG4gIGlmIChub3RFeHByICYmIChmaWVsZFZhbCAhPSBudWxsIHx8ICFpc0luZXFDbXApKSB7XG4gICAgbWF0Y2hlcyA9ICFtYXRjaGVzO1xuICB9XG4gIHJldHVybiBtYXRjaGVzO1xufTtcbnZhciBib29sQ21wID0gZnVuY3Rpb24gYm9vbENtcChmaWVsZFZhbCwgb3BlcmF0b3IpIHtcbiAgc3dpdGNoIChvcGVyYXRvcikge1xuICAgIGNhc2UgJz8nOlxuICAgICAgcmV0dXJuIGZpZWxkVmFsID8gdHJ1ZSA6IGZhbHNlO1xuICAgIGNhc2UgJyEnOlxuICAgICAgcmV0dXJuIGZpZWxkVmFsID8gZmFsc2UgOiB0cnVlO1xuICAgIGNhc2UgJ14nOlxuICAgICAgcmV0dXJuIGZpZWxkVmFsID09PSB1bmRlZmluZWQ7XG4gIH1cbn07XG52YXIgZXhpc3RDbXAgPSBmdW5jdGlvbiBleGlzdENtcChmaWVsZFZhbCkge1xuICByZXR1cm4gZmllbGRWYWwgIT09IHVuZGVmaW5lZDtcbn07XG52YXIgZGF0YSQxID0gZnVuY3Rpb24gZGF0YShlbGUsIGZpZWxkKSB7XG4gIHJldHVybiBlbGUuZGF0YShmaWVsZCk7XG59O1xudmFyIG1ldGEgPSBmdW5jdGlvbiBtZXRhKGVsZSwgZmllbGQpIHtcbiAgcmV0dXJuIGVsZVtmaWVsZF0oKTtcbn07XG5cbi8qKiBBIGxvb2t1cCBvZiBgbWF0Y2goY2hlY2ssIGVsZSlgIGZ1bmN0aW9ucyBieSBgVHlwZWAgaW50ICovXG52YXIgbWF0Y2ggPSBbXTtcblxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgdGhlIHF1ZXJ5IG1hdGNoZXMgZm9yIHRoZSBlbGVtZW50XG4gKiBAcGFyYW0gcXVlcnkgVGhlIGB7IHR5cGUsIHZhbHVlLCAuLi4gfWAgcXVlcnkgb2JqZWN0XG4gKiBAcGFyYW0gZWxlIFRoZSBlbGVtZW50IHRvIGNvbXBhcmUgYWdhaW5zdFxuKi9cbnZhciBtYXRjaGVzJDEgPSBmdW5jdGlvbiBtYXRjaGVzKHF1ZXJ5LCBlbGUpIHtcbiAgcmV0dXJuIHF1ZXJ5LmNoZWNrcy5ldmVyeShmdW5jdGlvbiAoY2hrKSB7XG4gICAgcmV0dXJuIG1hdGNoW2Noay50eXBlXShjaGssIGVsZSk7XG4gIH0pO1xufTtcbm1hdGNoW1R5cGUuR1JPVVBdID0gZnVuY3Rpb24gKGNoZWNrLCBlbGUpIHtcbiAgdmFyIGdyb3VwID0gY2hlY2sudmFsdWU7XG4gIHJldHVybiBncm91cCA9PT0gJyonIHx8IGdyb3VwID09PSBlbGUuZ3JvdXAoKTtcbn07XG5tYXRjaFtUeXBlLlNUQVRFXSA9IGZ1bmN0aW9uIChjaGVjaywgZWxlKSB7XG4gIHZhciBzdGF0ZVNlbGVjdG9yID0gY2hlY2sudmFsdWU7XG4gIHJldHVybiBzdGF0ZVNlbGVjdG9yTWF0Y2hlcyhzdGF0ZVNlbGVjdG9yLCBlbGUpO1xufTtcbm1hdGNoW1R5cGUuSURdID0gZnVuY3Rpb24gKGNoZWNrLCBlbGUpIHtcbiAgdmFyIGlkID0gY2hlY2sudmFsdWU7XG4gIHJldHVybiBlbGUuaWQoKSA9PT0gaWQ7XG59O1xubWF0Y2hbVHlwZS5DTEFTU10gPSBmdW5jdGlvbiAoY2hlY2ssIGVsZSkge1xuICB2YXIgY2xzID0gY2hlY2sudmFsdWU7XG4gIHJldHVybiBlbGUuaGFzQ2xhc3MoY2xzKTtcbn07XG5tYXRjaFtUeXBlLk1FVEFfQ09NUEFSRV0gPSBmdW5jdGlvbiAoY2hlY2ssIGVsZSkge1xuICB2YXIgZmllbGQgPSBjaGVjay5maWVsZCxcbiAgICBvcGVyYXRvciA9IGNoZWNrLm9wZXJhdG9yLFxuICAgIHZhbHVlID0gY2hlY2sudmFsdWU7XG4gIHJldHVybiB2YWxDbXAobWV0YShlbGUsIGZpZWxkKSwgb3BlcmF0b3IsIHZhbHVlKTtcbn07XG5tYXRjaFtUeXBlLkRBVEFfQ09NUEFSRV0gPSBmdW5jdGlvbiAoY2hlY2ssIGVsZSkge1xuICB2YXIgZmllbGQgPSBjaGVjay5maWVsZCxcbiAgICBvcGVyYXRvciA9IGNoZWNrLm9wZXJhdG9yLFxuICAgIHZhbHVlID0gY2hlY2sudmFsdWU7XG4gIHJldHVybiB2YWxDbXAoZGF0YSQxKGVsZSwgZmllbGQpLCBvcGVyYXRvciwgdmFsdWUpO1xufTtcbm1hdGNoW1R5cGUuREFUQV9CT09MXSA9IGZ1bmN0aW9uIChjaGVjaywgZWxlKSB7XG4gIHZhciBmaWVsZCA9IGNoZWNrLmZpZWxkLFxuICAgIG9wZXJhdG9yID0gY2hlY2sub3BlcmF0b3I7XG4gIHJldHVybiBib29sQ21wKGRhdGEkMShlbGUsIGZpZWxkKSwgb3BlcmF0b3IpO1xufTtcbm1hdGNoW1R5cGUuREFUQV9FWElTVF0gPSBmdW5jdGlvbiAoY2hlY2ssIGVsZSkge1xuICB2YXIgZmllbGQgPSBjaGVjay5maWVsZDtcbiAgICBjaGVjay5vcGVyYXRvcjtcbiAgcmV0dXJuIGV4aXN0Q21wKGRhdGEkMShlbGUsIGZpZWxkKSk7XG59O1xubWF0Y2hbVHlwZS5VTkRJUkVDVEVEX0VER0VdID0gZnVuY3Rpb24gKGNoZWNrLCBlbGUpIHtcbiAgdmFyIHFBID0gY2hlY2subm9kZXNbMF07XG4gIHZhciBxQiA9IGNoZWNrLm5vZGVzWzFdO1xuICB2YXIgc3JjID0gZWxlLnNvdXJjZSgpO1xuICB2YXIgdGd0ID0gZWxlLnRhcmdldCgpO1xuICByZXR1cm4gbWF0Y2hlcyQxKHFBLCBzcmMpICYmIG1hdGNoZXMkMShxQiwgdGd0KSB8fCBtYXRjaGVzJDEocUIsIHNyYykgJiYgbWF0Y2hlcyQxKHFBLCB0Z3QpO1xufTtcbm1hdGNoW1R5cGUuTk9ERV9ORUlHSEJPUl0gPSBmdW5jdGlvbiAoY2hlY2ssIGVsZSkge1xuICByZXR1cm4gbWF0Y2hlcyQxKGNoZWNrLm5vZGUsIGVsZSkgJiYgZWxlLm5laWdoYm9yaG9vZCgpLnNvbWUoZnVuY3Rpb24gKG4pIHtcbiAgICByZXR1cm4gbi5pc05vZGUoKSAmJiBtYXRjaGVzJDEoY2hlY2submVpZ2hib3IsIG4pO1xuICB9KTtcbn07XG5tYXRjaFtUeXBlLkRJUkVDVEVEX0VER0VdID0gZnVuY3Rpb24gKGNoZWNrLCBlbGUpIHtcbiAgcmV0dXJuIG1hdGNoZXMkMShjaGVjay5zb3VyY2UsIGVsZS5zb3VyY2UoKSkgJiYgbWF0Y2hlcyQxKGNoZWNrLnRhcmdldCwgZWxlLnRhcmdldCgpKTtcbn07XG5tYXRjaFtUeXBlLk5PREVfU09VUkNFXSA9IGZ1bmN0aW9uIChjaGVjaywgZWxlKSB7XG4gIHJldHVybiBtYXRjaGVzJDEoY2hlY2suc291cmNlLCBlbGUpICYmIGVsZS5vdXRnb2VycygpLnNvbWUoZnVuY3Rpb24gKG4pIHtcbiAgICByZXR1cm4gbi5pc05vZGUoKSAmJiBtYXRjaGVzJDEoY2hlY2sudGFyZ2V0LCBuKTtcbiAgfSk7XG59O1xubWF0Y2hbVHlwZS5OT0RFX1RBUkdFVF0gPSBmdW5jdGlvbiAoY2hlY2ssIGVsZSkge1xuICByZXR1cm4gbWF0Y2hlcyQxKGNoZWNrLnRhcmdldCwgZWxlKSAmJiBlbGUuaW5jb21lcnMoKS5zb21lKGZ1bmN0aW9uIChuKSB7XG4gICAgcmV0dXJuIG4uaXNOb2RlKCkgJiYgbWF0Y2hlcyQxKGNoZWNrLnNvdXJjZSwgbik7XG4gIH0pO1xufTtcbm1hdGNoW1R5cGUuQ0hJTERdID0gZnVuY3Rpb24gKGNoZWNrLCBlbGUpIHtcbiAgcmV0dXJuIG1hdGNoZXMkMShjaGVjay5jaGlsZCwgZWxlKSAmJiBtYXRjaGVzJDEoY2hlY2sucGFyZW50LCBlbGUucGFyZW50KCkpO1xufTtcbm1hdGNoW1R5cGUuUEFSRU5UXSA9IGZ1bmN0aW9uIChjaGVjaywgZWxlKSB7XG4gIHJldHVybiBtYXRjaGVzJDEoY2hlY2sucGFyZW50LCBlbGUpICYmIGVsZS5jaGlsZHJlbigpLnNvbWUoZnVuY3Rpb24gKGMpIHtcbiAgICByZXR1cm4gbWF0Y2hlcyQxKGNoZWNrLmNoaWxkLCBjKTtcbiAgfSk7XG59O1xubWF0Y2hbVHlwZS5ERVNDRU5EQU5UXSA9IGZ1bmN0aW9uIChjaGVjaywgZWxlKSB7XG4gIHJldHVybiBtYXRjaGVzJDEoY2hlY2suZGVzY2VuZGFudCwgZWxlKSAmJiBlbGUuYW5jZXN0b3JzKCkuc29tZShmdW5jdGlvbiAoYSkge1xuICAgIHJldHVybiBtYXRjaGVzJDEoY2hlY2suYW5jZXN0b3IsIGEpO1xuICB9KTtcbn07XG5tYXRjaFtUeXBlLkFOQ0VTVE9SXSA9IGZ1bmN0aW9uIChjaGVjaywgZWxlKSB7XG4gIHJldHVybiBtYXRjaGVzJDEoY2hlY2suYW5jZXN0b3IsIGVsZSkgJiYgZWxlLmRlc2NlbmRhbnRzKCkuc29tZShmdW5jdGlvbiAoZCkge1xuICAgIHJldHVybiBtYXRjaGVzJDEoY2hlY2suZGVzY2VuZGFudCwgZCk7XG4gIH0pO1xufTtcbm1hdGNoW1R5cGUuQ09NUE9VTkRfU1BMSVRdID0gZnVuY3Rpb24gKGNoZWNrLCBlbGUpIHtcbiAgcmV0dXJuIG1hdGNoZXMkMShjaGVjay5zdWJqZWN0LCBlbGUpICYmIG1hdGNoZXMkMShjaGVjay5sZWZ0LCBlbGUpICYmIG1hdGNoZXMkMShjaGVjay5yaWdodCwgZWxlKTtcbn07XG5tYXRjaFtUeXBlLlRSVUVdID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdHJ1ZTtcbn07XG5tYXRjaFtUeXBlLkNPTExFQ1RJT05dID0gZnVuY3Rpb24gKGNoZWNrLCBlbGUpIHtcbiAgdmFyIGNvbGxlY3Rpb24gPSBjaGVjay52YWx1ZTtcbiAgcmV0dXJuIGNvbGxlY3Rpb24uaGFzKGVsZSk7XG59O1xubWF0Y2hbVHlwZS5GSUxURVJdID0gZnVuY3Rpb24gKGNoZWNrLCBlbGUpIHtcbiAgdmFyIGZpbHRlciA9IGNoZWNrLnZhbHVlO1xuICByZXR1cm4gZmlsdGVyKGVsZSk7XG59O1xuXG4vLyBmaWx0ZXIgYW4gZXhpc3RpbmcgY29sbGVjdGlvblxudmFyIGZpbHRlciA9IGZ1bmN0aW9uIGZpbHRlcihjb2xsZWN0aW9uKSB7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICAvLyBmb3IgMSBpZCAjZm9vIHF1ZXJpZXMsIGp1c3QgZ2V0IHRoZSBlbGVtZW50XG4gIGlmIChzZWxmLmxlbmd0aCA9PT0gMSAmJiBzZWxmWzBdLmNoZWNrcy5sZW5ndGggPT09IDEgJiYgc2VsZlswXS5jaGVja3NbMF0udHlwZSA9PT0gVHlwZS5JRCkge1xuICAgIHJldHVybiBjb2xsZWN0aW9uLmdldEVsZW1lbnRCeUlkKHNlbGZbMF0uY2hlY2tzWzBdLnZhbHVlKS5jb2xsZWN0aW9uKCk7XG4gIH1cbiAgdmFyIHNlbGVjdG9yRnVuY3Rpb24gPSBmdW5jdGlvbiBzZWxlY3RvckZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IHNlbGYubGVuZ3RoOyBqKyspIHtcbiAgICAgIHZhciBxdWVyeSA9IHNlbGZbal07XG4gICAgICBpZiAobWF0Y2hlcyQxKHF1ZXJ5LCBlbGVtZW50KSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuICBpZiAoc2VsZi50ZXh0KCkgPT0gbnVsbCkge1xuICAgIHNlbGVjdG9yRnVuY3Rpb24gPSBmdW5jdGlvbiBzZWxlY3RvckZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gY29sbGVjdGlvbi5maWx0ZXIoc2VsZWN0b3JGdW5jdGlvbik7XG59OyAvLyBmaWx0ZXJcblxuLy8gZG9lcyBzZWxlY3RvciBtYXRjaCBhIHNpbmdsZSBlbGVtZW50P1xudmFyIG1hdGNoZXMgPSBmdW5jdGlvbiBtYXRjaGVzKGVsZSkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIGZvciAodmFyIGogPSAwOyBqIDwgc2VsZi5sZW5ndGg7IGorKykge1xuICAgIHZhciBxdWVyeSA9IHNlbGZbal07XG4gICAgaWYgKG1hdGNoZXMkMShxdWVyeSwgZWxlKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn07IC8vIG1hdGNoZXNcblxudmFyIG1hdGNoaW5nID0ge1xuICBtYXRjaGVzOiBtYXRjaGVzLFxuICBmaWx0ZXI6IGZpbHRlclxufTtcblxudmFyIFNlbGVjdG9yID0gZnVuY3Rpb24gU2VsZWN0b3Ioc2VsZWN0b3IpIHtcbiAgdGhpcy5pbnB1dFRleHQgPSBzZWxlY3RvcjtcbiAgdGhpcy5jdXJyZW50U3ViamVjdCA9IG51bGw7XG4gIHRoaXMuY29tcG91bmRDb3VudCA9IDA7XG4gIHRoaXMuZWRnZUNvdW50ID0gMDtcbiAgdGhpcy5sZW5ndGggPSAwO1xuICBpZiAoc2VsZWN0b3IgPT0gbnVsbCB8fCBzdHJpbmcoc2VsZWN0b3IpICYmIHNlbGVjdG9yLm1hdGNoKC9eXFxzKiQvKSkgOyBlbHNlIGlmIChlbGVtZW50T3JDb2xsZWN0aW9uKHNlbGVjdG9yKSkge1xuICAgIHRoaXMuYWRkUXVlcnkoe1xuICAgICAgY2hlY2tzOiBbe1xuICAgICAgICB0eXBlOiBUeXBlLkNPTExFQ1RJT04sXG4gICAgICAgIHZhbHVlOiBzZWxlY3Rvci5jb2xsZWN0aW9uKClcbiAgICAgIH1dXG4gICAgfSk7XG4gIH0gZWxzZSBpZiAoZm4kNihzZWxlY3RvcikpIHtcbiAgICB0aGlzLmFkZFF1ZXJ5KHtcbiAgICAgIGNoZWNrczogW3tcbiAgICAgICAgdHlwZTogVHlwZS5GSUxURVIsXG4gICAgICAgIHZhbHVlOiBzZWxlY3RvclxuICAgICAgfV1cbiAgICB9KTtcbiAgfSBlbHNlIGlmIChzdHJpbmcoc2VsZWN0b3IpKSB7XG4gICAgaWYgKCF0aGlzLnBhcnNlKHNlbGVjdG9yKSkge1xuICAgICAgdGhpcy5pbnZhbGlkID0gdHJ1ZTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZXJyb3IoJ0Egc2VsZWN0b3IgbXVzdCBiZSBjcmVhdGVkIGZyb20gYSBzdHJpbmc7IGZvdW5kICcpO1xuICB9XG59O1xudmFyIHNlbGZuID0gU2VsZWN0b3IucHJvdG90eXBlO1xuW3BhcnNlJDEsIG1hdGNoaW5nXS5mb3JFYWNoKGZ1bmN0aW9uIChwKSB7XG4gIHJldHVybiBleHRlbmQoc2VsZm4sIHApO1xufSk7XG5zZWxmbi50ZXh0ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5pbnB1dFRleHQ7XG59O1xuc2VsZm4uc2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMubGVuZ3RoO1xufTtcbnNlbGZuLmVxID0gZnVuY3Rpb24gKGkpIHtcbiAgcmV0dXJuIHRoaXNbaV07XG59O1xuc2VsZm4uc2FtZVRleHQgPSBmdW5jdGlvbiAob3RoZXJTZWwpIHtcbiAgcmV0dXJuICF0aGlzLmludmFsaWQgJiYgIW90aGVyU2VsLmludmFsaWQgJiYgdGhpcy50ZXh0KCkgPT09IG90aGVyU2VsLnRleHQoKTtcbn07XG5zZWxmbi5hZGRRdWVyeSA9IGZ1bmN0aW9uIChxKSB7XG4gIHRoaXNbdGhpcy5sZW5ndGgrK10gPSBxO1xufTtcbnNlbGZuLnNlbGVjdG9yID0gc2VsZm4udG9TdHJpbmc7XG5cbnZhciBlbGVzZm4kZyA9IHtcbiAgYWxsQXJlOiBmdW5jdGlvbiBhbGxBcmUoc2VsZWN0b3IpIHtcbiAgICB2YXIgc2VsT2JqID0gbmV3IFNlbGVjdG9yKHNlbGVjdG9yKTtcbiAgICByZXR1cm4gdGhpcy5ldmVyeShmdW5jdGlvbiAoZWxlKSB7XG4gICAgICByZXR1cm4gc2VsT2JqLm1hdGNoZXMoZWxlKTtcbiAgICB9KTtcbiAgfSxcbiAgaXM6IGZ1bmN0aW9uIGlzKHNlbGVjdG9yKSB7XG4gICAgdmFyIHNlbE9iaiA9IG5ldyBTZWxlY3RvcihzZWxlY3Rvcik7XG4gICAgcmV0dXJuIHRoaXMuc29tZShmdW5jdGlvbiAoZWxlKSB7XG4gICAgICByZXR1cm4gc2VsT2JqLm1hdGNoZXMoZWxlKTtcbiAgICB9KTtcbiAgfSxcbiAgc29tZTogZnVuY3Rpb24gc29tZShmbiwgdGhpc0FyZykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHJldCA9ICF0aGlzQXJnID8gZm4odGhpc1tpXSwgaSwgdGhpcykgOiBmbi5hcHBseSh0aGlzQXJnLCBbdGhpc1tpXSwgaSwgdGhpc10pO1xuICAgICAgaWYgKHJldCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LFxuICBldmVyeTogZnVuY3Rpb24gZXZlcnkoZm4sIHRoaXNBcmcpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciByZXQgPSAhdGhpc0FyZyA/IGZuKHRoaXNbaV0sIGksIHRoaXMpIDogZm4uYXBwbHkodGhpc0FyZywgW3RoaXNbaV0sIGksIHRoaXNdKTtcbiAgICAgIGlmICghcmV0KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sXG4gIHNhbWU6IGZ1bmN0aW9uIHNhbWUoY29sbGVjdGlvbikge1xuICAgIC8vIGNoZWFwIGNvbGxlY3Rpb24gcmVmIGNoZWNrXG4gICAgaWYgKHRoaXMgPT09IGNvbGxlY3Rpb24pIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjb2xsZWN0aW9uID0gdGhpcy5jeSgpLmNvbGxlY3Rpb24oY29sbGVjdGlvbik7XG4gICAgdmFyIHRoaXNMZW5ndGggPSB0aGlzLmxlbmd0aDtcbiAgICB2YXIgY29sbGVjdGlvbkxlbmd0aCA9IGNvbGxlY3Rpb24ubGVuZ3RoO1xuXG4gICAgLy8gY2hlYXAgbGVuZ3RoIGNoZWNrXG4gICAgaWYgKHRoaXNMZW5ndGggIT09IGNvbGxlY3Rpb25MZW5ndGgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBjaGVhcCBlbGVtZW50IHJlZiBjaGVja1xuICAgIGlmICh0aGlzTGVuZ3RoID09PSAxKSB7XG4gICAgICByZXR1cm4gdGhpc1swXSA9PT0gY29sbGVjdGlvblswXTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZXZlcnkoZnVuY3Rpb24gKGVsZSkge1xuICAgICAgcmV0dXJuIGNvbGxlY3Rpb24uaGFzRWxlbWVudFdpdGhJZChlbGUuaWQoKSk7XG4gICAgfSk7XG4gIH0sXG4gIGFueVNhbWU6IGZ1bmN0aW9uIGFueVNhbWUoY29sbGVjdGlvbikge1xuICAgIGNvbGxlY3Rpb24gPSB0aGlzLmN5KCkuY29sbGVjdGlvbihjb2xsZWN0aW9uKTtcbiAgICByZXR1cm4gdGhpcy5zb21lKGZ1bmN0aW9uIChlbGUpIHtcbiAgICAgIHJldHVybiBjb2xsZWN0aW9uLmhhc0VsZW1lbnRXaXRoSWQoZWxlLmlkKCkpO1xuICAgIH0pO1xuICB9LFxuICBhbGxBcmVOZWlnaGJvcnM6IGZ1bmN0aW9uIGFsbEFyZU5laWdoYm9ycyhjb2xsZWN0aW9uKSB7XG4gICAgY29sbGVjdGlvbiA9IHRoaXMuY3koKS5jb2xsZWN0aW9uKGNvbGxlY3Rpb24pO1xuICAgIHZhciBuaG9vZCA9IHRoaXMubmVpZ2hib3Job29kKCk7XG4gICAgcmV0dXJuIGNvbGxlY3Rpb24uZXZlcnkoZnVuY3Rpb24gKGVsZSkge1xuICAgICAgcmV0dXJuIG5ob29kLmhhc0VsZW1lbnRXaXRoSWQoZWxlLmlkKCkpO1xuICAgIH0pO1xuICB9LFxuICBjb250YWluczogZnVuY3Rpb24gY29udGFpbnMoY29sbGVjdGlvbikge1xuICAgIGNvbGxlY3Rpb24gPSB0aGlzLmN5KCkuY29sbGVjdGlvbihjb2xsZWN0aW9uKTtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgcmV0dXJuIGNvbGxlY3Rpb24uZXZlcnkoZnVuY3Rpb24gKGVsZSkge1xuICAgICAgcmV0dXJuIHNlbGYuaGFzRWxlbWVudFdpdGhJZChlbGUuaWQoKSk7XG4gICAgfSk7XG4gIH1cbn07XG5lbGVzZm4kZy5hbGxBcmVOZWlnaGJvdXJzID0gZWxlc2ZuJGcuYWxsQXJlTmVpZ2hib3JzO1xuZWxlc2ZuJGcuaGFzID0gZWxlc2ZuJGcuY29udGFpbnM7XG5lbGVzZm4kZy5lcXVhbCA9IGVsZXNmbiRnLmVxdWFscyA9IGVsZXNmbiRnLnNhbWU7XG5cbnZhciBjYWNoZSA9IGZ1bmN0aW9uIGNhY2hlKGZuLCBuYW1lKSB7XG4gIHJldHVybiBmdW5jdGlvbiB0cmF2ZXJzYWxDYWNoZShhcmcxLCBhcmcyLCBhcmczLCBhcmc0KSB7XG4gICAgdmFyIHNlbGVjdG9yT3JFbGVzID0gYXJnMTtcbiAgICB2YXIgZWxlcyA9IHRoaXM7XG4gICAgdmFyIGtleTtcbiAgICBpZiAoc2VsZWN0b3JPckVsZXMgPT0gbnVsbCkge1xuICAgICAga2V5ID0gJyc7XG4gICAgfSBlbHNlIGlmIChlbGVtZW50T3JDb2xsZWN0aW9uKHNlbGVjdG9yT3JFbGVzKSAmJiBzZWxlY3Rvck9yRWxlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgIGtleSA9IHNlbGVjdG9yT3JFbGVzLmlkKCk7XG4gICAgfVxuICAgIGlmIChlbGVzLmxlbmd0aCA9PT0gMSAmJiBrZXkpIHtcbiAgICAgIHZhciBfcCA9IGVsZXNbMF0uX3ByaXZhdGU7XG4gICAgICB2YXIgdGNoID0gX3AudHJhdmVyc2FsQ2FjaGUgPSBfcC50cmF2ZXJzYWxDYWNoZSB8fCB7fTtcbiAgICAgIHZhciBjaCA9IHRjaFtuYW1lXSA9IHRjaFtuYW1lXSB8fCBbXTtcbiAgICAgIHZhciBoYXNoID0gaGFzaFN0cmluZyhrZXkpO1xuICAgICAgdmFyIGNhY2hlSGl0ID0gY2hbaGFzaF07XG4gICAgICBpZiAoY2FjaGVIaXQpIHtcbiAgICAgICAgcmV0dXJuIGNhY2hlSGl0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGNoW2hhc2hdID0gZm4uY2FsbChlbGVzLCBhcmcxLCBhcmcyLCBhcmczLCBhcmc0KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZuLmNhbGwoZWxlcywgYXJnMSwgYXJnMiwgYXJnMywgYXJnNCk7XG4gICAgfVxuICB9O1xufTtcblxudmFyIGVsZXNmbiRmID0ge1xuICBwYXJlbnQ6IGZ1bmN0aW9uIHBhcmVudChzZWxlY3Rvcikge1xuICAgIHZhciBwYXJlbnRzID0gW107XG5cbiAgICAvLyBvcHRpbWlzYXRpb24gZm9yIHNpbmdsZSBlbGUgY2FsbFxuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdmFyIHBhcmVudCA9IHRoaXNbMF0uX3ByaXZhdGUucGFyZW50O1xuICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICByZXR1cm4gcGFyZW50O1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBlbGUgPSB0aGlzW2ldO1xuICAgICAgdmFyIF9wYXJlbnQgPSBlbGUuX3ByaXZhdGUucGFyZW50O1xuICAgICAgaWYgKF9wYXJlbnQpIHtcbiAgICAgICAgcGFyZW50cy5wdXNoKF9wYXJlbnQpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5zcGF3bihwYXJlbnRzLCB0cnVlKS5maWx0ZXIoc2VsZWN0b3IpO1xuICB9LFxuICBwYXJlbnRzOiBmdW5jdGlvbiBwYXJlbnRzKHNlbGVjdG9yKSB7XG4gICAgdmFyIHBhcmVudHMgPSBbXTtcbiAgICB2YXIgZWxlcyA9IHRoaXMucGFyZW50KCk7XG4gICAgd2hpbGUgKGVsZXMubm9uZW1wdHkoKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlbGUgPSBlbGVzW2ldO1xuICAgICAgICBwYXJlbnRzLnB1c2goZWxlKTtcbiAgICAgIH1cbiAgICAgIGVsZXMgPSBlbGVzLnBhcmVudCgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5zcGF3bihwYXJlbnRzLCB0cnVlKS5maWx0ZXIoc2VsZWN0b3IpO1xuICB9LFxuICBjb21tb25BbmNlc3RvcnM6IGZ1bmN0aW9uIGNvbW1vbkFuY2VzdG9ycyhzZWxlY3Rvcikge1xuICAgIHZhciBhbmNlc3RvcnM7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZWxlID0gdGhpc1tpXTtcbiAgICAgIHZhciBwYXJlbnRzID0gZWxlLnBhcmVudHMoKTtcbiAgICAgIGFuY2VzdG9ycyA9IGFuY2VzdG9ycyB8fCBwYXJlbnRzO1xuICAgICAgYW5jZXN0b3JzID0gYW5jZXN0b3JzLmludGVyc2VjdChwYXJlbnRzKTsgLy8gY3VycmVudCBsaXN0IG11c3QgYmUgY29tbW9uIHdpdGggY3VycmVudCBlbGUgcGFyZW50cyBzZXRcbiAgICB9XG5cbiAgICByZXR1cm4gYW5jZXN0b3JzLmZpbHRlcihzZWxlY3Rvcik7XG4gIH0sXG4gIG9ycGhhbnM6IGZ1bmN0aW9uIG9ycGhhbnMoc2VsZWN0b3IpIHtcbiAgICByZXR1cm4gdGhpcy5zdGRGaWx0ZXIoZnVuY3Rpb24gKGVsZSkge1xuICAgICAgcmV0dXJuIGVsZS5pc09ycGhhbigpO1xuICAgIH0pLmZpbHRlcihzZWxlY3Rvcik7XG4gIH0sXG4gIG5vbm9ycGhhbnM6IGZ1bmN0aW9uIG5vbm9ycGhhbnMoc2VsZWN0b3IpIHtcbiAgICByZXR1cm4gdGhpcy5zdGRGaWx0ZXIoZnVuY3Rpb24gKGVsZSkge1xuICAgICAgcmV0dXJuIGVsZS5pc0NoaWxkKCk7XG4gICAgfSkuZmlsdGVyKHNlbGVjdG9yKTtcbiAgfSxcbiAgY2hpbGRyZW46IGNhY2hlKGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuICAgIHZhciBjaGlsZHJlbiA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGVsZSA9IHRoaXNbaV07XG4gICAgICB2YXIgZWxlQ2hpbGRyZW4gPSBlbGUuX3ByaXZhdGUuY2hpbGRyZW47XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGVsZUNoaWxkcmVuLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGNoaWxkcmVuLnB1c2goZWxlQ2hpbGRyZW5bal0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5zcGF3bihjaGlsZHJlbiwgdHJ1ZSkuZmlsdGVyKHNlbGVjdG9yKTtcbiAgfSwgJ2NoaWxkcmVuJyksXG4gIHNpYmxpbmdzOiBmdW5jdGlvbiBzaWJsaW5ncyhzZWxlY3Rvcikge1xuICAgIHJldHVybiB0aGlzLnBhcmVudCgpLmNoaWxkcmVuKCkubm90KHRoaXMpLmZpbHRlcihzZWxlY3Rvcik7XG4gIH0sXG4gIGlzUGFyZW50OiBmdW5jdGlvbiBpc1BhcmVudCgpIHtcbiAgICB2YXIgZWxlID0gdGhpc1swXTtcbiAgICBpZiAoZWxlKSB7XG4gICAgICByZXR1cm4gZWxlLmlzTm9kZSgpICYmIGVsZS5fcHJpdmF0ZS5jaGlsZHJlbi5sZW5ndGggIT09IDA7XG4gICAgfVxuICB9LFxuICBpc0NoaWxkbGVzczogZnVuY3Rpb24gaXNDaGlsZGxlc3MoKSB7XG4gICAgdmFyIGVsZSA9IHRoaXNbMF07XG4gICAgaWYgKGVsZSkge1xuICAgICAgcmV0dXJuIGVsZS5pc05vZGUoKSAmJiBlbGUuX3ByaXZhdGUuY2hpbGRyZW4ubGVuZ3RoID09PSAwO1xuICAgIH1cbiAgfSxcbiAgaXNDaGlsZDogZnVuY3Rpb24gaXNDaGlsZCgpIHtcbiAgICB2YXIgZWxlID0gdGhpc1swXTtcbiAgICBpZiAoZWxlKSB7XG4gICAgICByZXR1cm4gZWxlLmlzTm9kZSgpICYmIGVsZS5fcHJpdmF0ZS5wYXJlbnQgIT0gbnVsbDtcbiAgICB9XG4gIH0sXG4gIGlzT3JwaGFuOiBmdW5jdGlvbiBpc09ycGhhbigpIHtcbiAgICB2YXIgZWxlID0gdGhpc1swXTtcbiAgICBpZiAoZWxlKSB7XG4gICAgICByZXR1cm4gZWxlLmlzTm9kZSgpICYmIGVsZS5fcHJpdmF0ZS5wYXJlbnQgPT0gbnVsbDtcbiAgICB9XG4gIH0sXG4gIGRlc2NlbmRhbnRzOiBmdW5jdGlvbiBkZXNjZW5kYW50cyhzZWxlY3Rvcikge1xuICAgIHZhciBlbGVtZW50cyA9IFtdO1xuICAgIGZ1bmN0aW9uIGFkZChlbGVzKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGVsZSA9IGVsZXNbaV07XG4gICAgICAgIGVsZW1lbnRzLnB1c2goZWxlKTtcbiAgICAgICAgaWYgKGVsZS5jaGlsZHJlbigpLm5vbmVtcHR5KCkpIHtcbiAgICAgICAgICBhZGQoZWxlLmNoaWxkcmVuKCkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGFkZCh0aGlzLmNoaWxkcmVuKCkpO1xuICAgIHJldHVybiB0aGlzLnNwYXduKGVsZW1lbnRzLCB0cnVlKS5maWx0ZXIoc2VsZWN0b3IpO1xuICB9XG59O1xuZnVuY3Rpb24gZm9yRWFjaENvbXBvdW5kKGVsZXMsIGZuLCBpbmNsdWRlU2VsZiwgcmVjdXJzaXZlU3RlcCkge1xuICB2YXIgcSA9IFtdO1xuICB2YXIgZGlkID0gbmV3IFNldCQxKCk7XG4gIHZhciBjeSA9IGVsZXMuY3koKTtcbiAgdmFyIGhhc0NvbXBvdW5kcyA9IGN5Lmhhc0NvbXBvdW5kTm9kZXMoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGVsZSA9IGVsZXNbaV07XG4gICAgaWYgKGluY2x1ZGVTZWxmKSB7XG4gICAgICBxLnB1c2goZWxlKTtcbiAgICB9IGVsc2UgaWYgKGhhc0NvbXBvdW5kcykge1xuICAgICAgcmVjdXJzaXZlU3RlcChxLCBkaWQsIGVsZSk7XG4gICAgfVxuICB9XG4gIHdoaWxlIChxLmxlbmd0aCA+IDApIHtcbiAgICB2YXIgX2VsZSA9IHEuc2hpZnQoKTtcbiAgICBmbihfZWxlKTtcbiAgICBkaWQuYWRkKF9lbGUuaWQoKSk7XG4gICAgaWYgKGhhc0NvbXBvdW5kcykge1xuICAgICAgcmVjdXJzaXZlU3RlcChxLCBkaWQsIF9lbGUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZWxlcztcbn1cbmZ1bmN0aW9uIGFkZENoaWxkcmVuKHEsIGRpZCwgZWxlKSB7XG4gIGlmIChlbGUuaXNQYXJlbnQoKSkge1xuICAgIHZhciBjaGlsZHJlbiA9IGVsZS5fcHJpdmF0ZS5jaGlsZHJlbjtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgIGlmICghZGlkLmhhcyhjaGlsZC5pZCgpKSkge1xuICAgICAgICBxLnB1c2goY2hpbGQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vLyB2ZXJ5IGVmZmljaWVudCB2ZXJzaW9uIG9mIGVsZXMuYWRkKCBlbGVzLmRlc2NlbmRhbnRzKCkgKS5mb3JFYWNoKClcbi8vIGZvciBpbnRlcm5hbCB1c2VcbmVsZXNmbiRmLmZvckVhY2hEb3duID0gZnVuY3Rpb24gKGZuKSB7XG4gIHZhciBpbmNsdWRlU2VsZiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdHJ1ZTtcbiAgcmV0dXJuIGZvckVhY2hDb21wb3VuZCh0aGlzLCBmbiwgaW5jbHVkZVNlbGYsIGFkZENoaWxkcmVuKTtcbn07XG5mdW5jdGlvbiBhZGRQYXJlbnQocSwgZGlkLCBlbGUpIHtcbiAgaWYgKGVsZS5pc0NoaWxkKCkpIHtcbiAgICB2YXIgcGFyZW50ID0gZWxlLl9wcml2YXRlLnBhcmVudDtcbiAgICBpZiAoIWRpZC5oYXMocGFyZW50LmlkKCkpKSB7XG4gICAgICBxLnB1c2gocGFyZW50KTtcbiAgICB9XG4gIH1cbn1cbmVsZXNmbiRmLmZvckVhY2hVcCA9IGZ1bmN0aW9uIChmbikge1xuICB2YXIgaW5jbHVkZVNlbGYgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRydWU7XG4gIHJldHVybiBmb3JFYWNoQ29tcG91bmQodGhpcywgZm4sIGluY2x1ZGVTZWxmLCBhZGRQYXJlbnQpO1xufTtcbmZ1bmN0aW9uIGFkZFBhcmVudEFuZENoaWxkcmVuKHEsIGRpZCwgZWxlKSB7XG4gIGFkZFBhcmVudChxLCBkaWQsIGVsZSk7XG4gIGFkZENoaWxkcmVuKHEsIGRpZCwgZWxlKTtcbn1cbmVsZXNmbiRmLmZvckVhY2hVcEFuZERvd24gPSBmdW5jdGlvbiAoZm4pIHtcbiAgdmFyIGluY2x1ZGVTZWxmID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0cnVlO1xuICByZXR1cm4gZm9yRWFjaENvbXBvdW5kKHRoaXMsIGZuLCBpbmNsdWRlU2VsZiwgYWRkUGFyZW50QW5kQ2hpbGRyZW4pO1xufTtcblxuLy8gYWxpYXNlc1xuZWxlc2ZuJGYuYW5jZXN0b3JzID0gZWxlc2ZuJGYucGFyZW50cztcblxudmFyIGZuJDUsIGVsZXNmbiRlO1xuZm4kNSA9IGVsZXNmbiRlID0ge1xuICBkYXRhOiBkZWZpbmUuZGF0YSh7XG4gICAgZmllbGQ6ICdkYXRhJyxcbiAgICBiaW5kaW5nRXZlbnQ6ICdkYXRhJyxcbiAgICBhbGxvd0JpbmRpbmc6IHRydWUsXG4gICAgYWxsb3dTZXR0aW5nOiB0cnVlLFxuICAgIHNldHRpbmdFdmVudDogJ2RhdGEnLFxuICAgIHNldHRpbmdUcmlnZ2Vyc0V2ZW50OiB0cnVlLFxuICAgIHRyaWdnZXJGbk5hbWU6ICd0cmlnZ2VyJyxcbiAgICBhbGxvd0dldHRpbmc6IHRydWUsXG4gICAgaW1tdXRhYmxlS2V5czoge1xuICAgICAgJ2lkJzogdHJ1ZSxcbiAgICAgICdzb3VyY2UnOiB0cnVlLFxuICAgICAgJ3RhcmdldCc6IHRydWUsXG4gICAgICAncGFyZW50JzogdHJ1ZVxuICAgIH0sXG4gICAgdXBkYXRlU3R5bGU6IHRydWVcbiAgfSksXG4gIHJlbW92ZURhdGE6IGRlZmluZS5yZW1vdmVEYXRhKHtcbiAgICBmaWVsZDogJ2RhdGEnLFxuICAgIGV2ZW50OiAnZGF0YScsXG4gICAgdHJpZ2dlckZuTmFtZTogJ3RyaWdnZXInLFxuICAgIHRyaWdnZXJFdmVudDogdHJ1ZSxcbiAgICBpbW11dGFibGVLZXlzOiB7XG4gICAgICAnaWQnOiB0cnVlLFxuICAgICAgJ3NvdXJjZSc6IHRydWUsXG4gICAgICAndGFyZ2V0JzogdHJ1ZSxcbiAgICAgICdwYXJlbnQnOiB0cnVlXG4gICAgfSxcbiAgICB1cGRhdGVTdHlsZTogdHJ1ZVxuICB9KSxcbiAgc2NyYXRjaDogZGVmaW5lLmRhdGEoe1xuICAgIGZpZWxkOiAnc2NyYXRjaCcsXG4gICAgYmluZGluZ0V2ZW50OiAnc2NyYXRjaCcsXG4gICAgYWxsb3dCaW5kaW5nOiB0cnVlLFxuICAgIGFsbG93U2V0dGluZzogdHJ1ZSxcbiAgICBzZXR0aW5nRXZlbnQ6ICdzY3JhdGNoJyxcbiAgICBzZXR0aW5nVHJpZ2dlcnNFdmVudDogdHJ1ZSxcbiAgICB0cmlnZ2VyRm5OYW1lOiAndHJpZ2dlcicsXG4gICAgYWxsb3dHZXR0aW5nOiB0cnVlLFxuICAgIHVwZGF0ZVN0eWxlOiB0cnVlXG4gIH0pLFxuICByZW1vdmVTY3JhdGNoOiBkZWZpbmUucmVtb3ZlRGF0YSh7XG4gICAgZmllbGQ6ICdzY3JhdGNoJyxcbiAgICBldmVudDogJ3NjcmF0Y2gnLFxuICAgIHRyaWdnZXJGbk5hbWU6ICd0cmlnZ2VyJyxcbiAgICB0cmlnZ2VyRXZlbnQ6IHRydWUsXG4gICAgdXBkYXRlU3R5bGU6IHRydWVcbiAgfSksXG4gIHJzY3JhdGNoOiBkZWZpbmUuZGF0YSh7XG4gICAgZmllbGQ6ICdyc2NyYXRjaCcsXG4gICAgYWxsb3dCaW5kaW5nOiBmYWxzZSxcbiAgICBhbGxvd1NldHRpbmc6IHRydWUsXG4gICAgc2V0dGluZ1RyaWdnZXJzRXZlbnQ6IGZhbHNlLFxuICAgIGFsbG93R2V0dGluZzogdHJ1ZVxuICB9KSxcbiAgcmVtb3ZlUnNjcmF0Y2g6IGRlZmluZS5yZW1vdmVEYXRhKHtcbiAgICBmaWVsZDogJ3JzY3JhdGNoJyxcbiAgICB0cmlnZ2VyRXZlbnQ6IGZhbHNlXG4gIH0pLFxuICBpZDogZnVuY3Rpb24gaWQoKSB7XG4gICAgdmFyIGVsZSA9IHRoaXNbMF07XG4gICAgaWYgKGVsZSkge1xuICAgICAgcmV0dXJuIGVsZS5fcHJpdmF0ZS5kYXRhLmlkO1xuICAgIH1cbiAgfVxufTtcblxuLy8gYWxpYXNlc1xuZm4kNS5hdHRyID0gZm4kNS5kYXRhO1xuZm4kNS5yZW1vdmVBdHRyID0gZm4kNS5yZW1vdmVEYXRhO1xudmFyIGRhdGEgPSBlbGVzZm4kZTtcblxudmFyIGVsZXNmbiRkID0ge307XG5mdW5jdGlvbiBkZWZpbmVEZWdyZWVGdW5jdGlvbihjYWxsYmFjaykge1xuICByZXR1cm4gZnVuY3Rpb24gKGluY2x1ZGVMb29wcykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBpZiAoaW5jbHVkZUxvb3BzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGluY2x1ZGVMb29wcyA9IHRydWU7XG4gICAgfVxuICAgIGlmIChzZWxmLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoc2VsZi5pc05vZGUoKSAmJiAhc2VsZi5yZW1vdmVkKCkpIHtcbiAgICAgIHZhciBkZWdyZWUgPSAwO1xuICAgICAgdmFyIG5vZGUgPSBzZWxmWzBdO1xuICAgICAgdmFyIGNvbm5lY3RlZEVkZ2VzID0gbm9kZS5fcHJpdmF0ZS5lZGdlcztcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29ubmVjdGVkRWRnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGVkZ2UgPSBjb25uZWN0ZWRFZGdlc1tpXTtcbiAgICAgICAgaWYgKCFpbmNsdWRlTG9vcHMgJiYgZWRnZS5pc0xvb3AoKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGRlZ3JlZSArPSBjYWxsYmFjayhub2RlLCBlZGdlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkZWdyZWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH07XG59XG5leHRlbmQoZWxlc2ZuJGQsIHtcbiAgZGVncmVlOiBkZWZpbmVEZWdyZWVGdW5jdGlvbihmdW5jdGlvbiAobm9kZSwgZWRnZSkge1xuICAgIGlmIChlZGdlLnNvdXJjZSgpLnNhbWUoZWRnZS50YXJnZXQoKSkpIHtcbiAgICAgIHJldHVybiAyO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG4gIH0pLFxuICBpbmRlZ3JlZTogZGVmaW5lRGVncmVlRnVuY3Rpb24oZnVuY3Rpb24gKG5vZGUsIGVkZ2UpIHtcbiAgICBpZiAoZWRnZS50YXJnZXQoKS5zYW1lKG5vZGUpKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICB9KSxcbiAgb3V0ZGVncmVlOiBkZWZpbmVEZWdyZWVGdW5jdGlvbihmdW5jdGlvbiAobm9kZSwgZWRnZSkge1xuICAgIGlmIChlZGdlLnNvdXJjZSgpLnNhbWUobm9kZSkpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gIH0pXG59KTtcbmZ1bmN0aW9uIGRlZmluZURlZ3JlZUJvdW5kc0Z1bmN0aW9uKGRlZ3JlZUZuLCBjYWxsYmFjaykge1xuICByZXR1cm4gZnVuY3Rpb24gKGluY2x1ZGVMb29wcykge1xuICAgIHZhciByZXQ7XG4gICAgdmFyIG5vZGVzID0gdGhpcy5ub2RlcygpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBlbGUgPSBub2Rlc1tpXTtcbiAgICAgIHZhciBkZWdyZWUgPSBlbGVbZGVncmVlRm5dKGluY2x1ZGVMb29wcyk7XG4gICAgICBpZiAoZGVncmVlICE9PSB1bmRlZmluZWQgJiYgKHJldCA9PT0gdW5kZWZpbmVkIHx8IGNhbGxiYWNrKGRlZ3JlZSwgcmV0KSkpIHtcbiAgICAgICAgcmV0ID0gZGVncmVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9O1xufVxuZXh0ZW5kKGVsZXNmbiRkLCB7XG4gIG1pbkRlZ3JlZTogZGVmaW5lRGVncmVlQm91bmRzRnVuY3Rpb24oJ2RlZ3JlZScsIGZ1bmN0aW9uIChkZWdyZWUsIG1pbikge1xuICAgIHJldHVybiBkZWdyZWUgPCBtaW47XG4gIH0pLFxuICBtYXhEZWdyZWU6IGRlZmluZURlZ3JlZUJvdW5kc0Z1bmN0aW9uKCdkZWdyZWUnLCBmdW5jdGlvbiAoZGVncmVlLCBtYXgpIHtcbiAgICByZXR1cm4gZGVncmVlID4gbWF4O1xuICB9KSxcbiAgbWluSW5kZWdyZWU6IGRlZmluZURlZ3JlZUJvdW5kc0Z1bmN0aW9uKCdpbmRlZ3JlZScsIGZ1bmN0aW9uIChkZWdyZWUsIG1pbikge1xuICAgIHJldHVybiBkZWdyZWUgPCBtaW47XG4gIH0pLFxuICBtYXhJbmRlZ3JlZTogZGVmaW5lRGVncmVlQm91bmRzRnVuY3Rpb24oJ2luZGVncmVlJywgZnVuY3Rpb24gKGRlZ3JlZSwgbWF4KSB7XG4gICAgcmV0dXJuIGRlZ3JlZSA+IG1heDtcbiAgfSksXG4gIG1pbk91dGRlZ3JlZTogZGVmaW5lRGVncmVlQm91bmRzRnVuY3Rpb24oJ291dGRlZ3JlZScsIGZ1bmN0aW9uIChkZWdyZWUsIG1pbikge1xuICAgIHJldHVybiBkZWdyZWUgPCBtaW47XG4gIH0pLFxuICBtYXhPdXRkZWdyZWU6IGRlZmluZURlZ3JlZUJvdW5kc0Z1bmN0aW9uKCdvdXRkZWdyZWUnLCBmdW5jdGlvbiAoZGVncmVlLCBtYXgpIHtcbiAgICByZXR1cm4gZGVncmVlID4gbWF4O1xuICB9KVxufSk7XG5leHRlbmQoZWxlc2ZuJGQsIHtcbiAgdG90YWxEZWdyZWU6IGZ1bmN0aW9uIHRvdGFsRGVncmVlKGluY2x1ZGVMb29wcykge1xuICAgIHZhciB0b3RhbCA9IDA7XG4gICAgdmFyIG5vZGVzID0gdGhpcy5ub2RlcygpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRvdGFsICs9IG5vZGVzW2ldLmRlZ3JlZShpbmNsdWRlTG9vcHMpO1xuICAgIH1cbiAgICByZXR1cm4gdG90YWw7XG4gIH1cbn0pO1xuXG52YXIgZm4kNCwgZWxlc2ZuJGM7XG52YXIgYmVmb3JlUG9zaXRpb25TZXQgPSBmdW5jdGlvbiBiZWZvcmVQb3NpdGlvblNldChlbGVzLCBuZXdQb3MsIHNpbGVudCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZWxlID0gZWxlc1tpXTtcbiAgICBpZiAoIWVsZS5sb2NrZWQoKSkge1xuICAgICAgdmFyIG9sZFBvcyA9IGVsZS5fcHJpdmF0ZS5wb3NpdGlvbjtcbiAgICAgIHZhciBkZWx0YSA9IHtcbiAgICAgICAgeDogbmV3UG9zLnggIT0gbnVsbCA/IG5ld1Bvcy54IC0gb2xkUG9zLnggOiAwLFxuICAgICAgICB5OiBuZXdQb3MueSAhPSBudWxsID8gbmV3UG9zLnkgLSBvbGRQb3MueSA6IDBcbiAgICAgIH07XG4gICAgICBpZiAoZWxlLmlzUGFyZW50KCkgJiYgIShkZWx0YS54ID09PSAwICYmIGRlbHRhLnkgPT09IDApKSB7XG4gICAgICAgIGVsZS5jaGlsZHJlbigpLnNoaWZ0KGRlbHRhLCBzaWxlbnQpO1xuICAgICAgfVxuICAgICAgZWxlLmRpcnR5Qm91bmRpbmdCb3hDYWNoZSgpO1xuICAgIH1cbiAgfVxufTtcbnZhciBwb3NpdGlvbkRlZiA9IHtcbiAgZmllbGQ6ICdwb3NpdGlvbicsXG4gIGJpbmRpbmdFdmVudDogJ3Bvc2l0aW9uJyxcbiAgYWxsb3dCaW5kaW5nOiB0cnVlLFxuICBhbGxvd1NldHRpbmc6IHRydWUsXG4gIHNldHRpbmdFdmVudDogJ3Bvc2l0aW9uJyxcbiAgc2V0dGluZ1RyaWdnZXJzRXZlbnQ6IHRydWUsXG4gIHRyaWdnZXJGbk5hbWU6ICdlbWl0QW5kTm90aWZ5JyxcbiAgYWxsb3dHZXR0aW5nOiB0cnVlLFxuICB2YWxpZEtleXM6IFsneCcsICd5J10sXG4gIGJlZm9yZUdldDogZnVuY3Rpb24gYmVmb3JlR2V0KGVsZSkge1xuICAgIGVsZS51cGRhdGVDb21wb3VuZEJvdW5kcygpO1xuICB9LFxuICBiZWZvcmVTZXQ6IGZ1bmN0aW9uIGJlZm9yZVNldChlbGVzLCBuZXdQb3MpIHtcbiAgICBiZWZvcmVQb3NpdGlvblNldChlbGVzLCBuZXdQb3MsIGZhbHNlKTtcbiAgfSxcbiAgb25TZXQ6IGZ1bmN0aW9uIG9uU2V0KGVsZXMpIHtcbiAgICBlbGVzLmRpcnR5Q29tcG91bmRCb3VuZHNDYWNoZSgpO1xuICB9LFxuICBjYW5TZXQ6IGZ1bmN0aW9uIGNhblNldChlbGUpIHtcbiAgICByZXR1cm4gIWVsZS5sb2NrZWQoKTtcbiAgfVxufTtcbmZuJDQgPSBlbGVzZm4kYyA9IHtcbiAgcG9zaXRpb246IGRlZmluZS5kYXRhKHBvc2l0aW9uRGVmKSxcbiAgLy8gcG9zaXRpb24gYnV0IG5vIG5vdGlmaWNhdGlvbiB0byByZW5kZXJlclxuICBzaWxlbnRQb3NpdGlvbjogZGVmaW5lLmRhdGEoZXh0ZW5kKHt9LCBwb3NpdGlvbkRlZiwge1xuICAgIGFsbG93QmluZGluZzogZmFsc2UsXG4gICAgYWxsb3dTZXR0aW5nOiB0cnVlLFxuICAgIHNldHRpbmdUcmlnZ2Vyc0V2ZW50OiBmYWxzZSxcbiAgICBhbGxvd0dldHRpbmc6IGZhbHNlLFxuICAgIGJlZm9yZVNldDogZnVuY3Rpb24gYmVmb3JlU2V0KGVsZXMsIG5ld1Bvcykge1xuICAgICAgYmVmb3JlUG9zaXRpb25TZXQoZWxlcywgbmV3UG9zLCB0cnVlKTtcbiAgICB9LFxuICAgIG9uU2V0OiBmdW5jdGlvbiBvblNldChlbGVzKSB7XG4gICAgICBlbGVzLmRpcnR5Q29tcG91bmRCb3VuZHNDYWNoZSgpO1xuICAgIH1cbiAgfSkpLFxuICBwb3NpdGlvbnM6IGZ1bmN0aW9uIHBvc2l0aW9ucyhwb3MsIHNpbGVudCkge1xuICAgIGlmIChwbGFpbk9iamVjdChwb3MpKSB7XG4gICAgICBpZiAoc2lsZW50KSB7XG4gICAgICAgIHRoaXMuc2lsZW50UG9zaXRpb24ocG9zKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucG9zaXRpb24ocG9zKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGZuJDYocG9zKSkge1xuICAgICAgdmFyIF9mbiA9IHBvcztcbiAgICAgIHZhciBjeSA9IHRoaXMuY3koKTtcbiAgICAgIGN5LnN0YXJ0QmF0Y2goKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZWxlID0gdGhpc1tpXTtcbiAgICAgICAgdmFyIF9wb3MgPSB2b2lkIDA7XG4gICAgICAgIGlmIChfcG9zID0gX2ZuKGVsZSwgaSkpIHtcbiAgICAgICAgICBpZiAoc2lsZW50KSB7XG4gICAgICAgICAgICBlbGUuc2lsZW50UG9zaXRpb24oX3Bvcyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVsZS5wb3NpdGlvbihfcG9zKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGN5LmVuZEJhdGNoKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9LFxuXG4gIHNpbGVudFBvc2l0aW9uczogZnVuY3Rpb24gc2lsZW50UG9zaXRpb25zKHBvcykge1xuICAgIHJldHVybiB0aGlzLnBvc2l0aW9ucyhwb3MsIHRydWUpO1xuICB9LFxuICBzaGlmdDogZnVuY3Rpb24gc2hpZnQoZGltLCB2YWwsIHNpbGVudCkge1xuICAgIHZhciBkZWx0YTtcbiAgICBpZiAocGxhaW5PYmplY3QoZGltKSkge1xuICAgICAgZGVsdGEgPSB7XG4gICAgICAgIHg6IG51bWJlciQxKGRpbS54KSA/IGRpbS54IDogMCxcbiAgICAgICAgeTogbnVtYmVyJDEoZGltLnkpID8gZGltLnkgOiAwXG4gICAgICB9O1xuICAgICAgc2lsZW50ID0gdmFsO1xuICAgIH0gZWxzZSBpZiAoc3RyaW5nKGRpbSkgJiYgbnVtYmVyJDEodmFsKSkge1xuICAgICAgZGVsdGEgPSB7XG4gICAgICAgIHg6IDAsXG4gICAgICAgIHk6IDBcbiAgICAgIH07XG4gICAgICBkZWx0YVtkaW1dID0gdmFsO1xuICAgIH1cbiAgICBpZiAoZGVsdGEgIT0gbnVsbCkge1xuICAgICAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuICAgICAgY3kuc3RhcnRCYXRjaCgpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlbGUgPSB0aGlzW2ldO1xuXG4gICAgICAgIC8vIGV4Y2x1ZGUgYW55IG5vZGUgdGhhdCBpcyBhIGRlc2NlbmRhbnQgb2YgdGhlIGNhbGxpbmcgY29sbGVjdGlvblxuICAgICAgICBpZiAoY3kuaGFzQ29tcG91bmROb2RlcygpICYmIGVsZS5pc0NoaWxkKCkgJiYgZWxlLmFuY2VzdG9ycygpLmFueVNhbWUodGhpcykpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcG9zID0gZWxlLnBvc2l0aW9uKCk7XG4gICAgICAgIHZhciBuZXdQb3MgPSB7XG4gICAgICAgICAgeDogcG9zLnggKyBkZWx0YS54LFxuICAgICAgICAgIHk6IHBvcy55ICsgZGVsdGEueVxuICAgICAgICB9O1xuICAgICAgICBpZiAoc2lsZW50KSB7XG4gICAgICAgICAgZWxlLnNpbGVudFBvc2l0aW9uKG5ld1Bvcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZWxlLnBvc2l0aW9uKG5ld1Bvcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGN5LmVuZEJhdGNoKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBzaWxlbnRTaGlmdDogZnVuY3Rpb24gc2lsZW50U2hpZnQoZGltLCB2YWwpIHtcbiAgICBpZiAocGxhaW5PYmplY3QoZGltKSkge1xuICAgICAgdGhpcy5zaGlmdChkaW0sIHRydWUpO1xuICAgIH0gZWxzZSBpZiAoc3RyaW5nKGRpbSkgJiYgbnVtYmVyJDEodmFsKSkge1xuICAgICAgdGhpcy5zaGlmdChkaW0sIHZhbCwgdHJ1ZSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICAvLyBnZXQvc2V0IHRoZSByZW5kZXJlZCAoaS5lLiBvbiBzY3JlZW4pIHBvc2l0b24gb2YgdGhlIGVsZW1lbnRcbiAgcmVuZGVyZWRQb3NpdGlvbjogZnVuY3Rpb24gcmVuZGVyZWRQb3NpdGlvbihkaW0sIHZhbCkge1xuICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuICAgIHZhciBjeSA9IHRoaXMuY3koKTtcbiAgICB2YXIgem9vbSA9IGN5Lnpvb20oKTtcbiAgICB2YXIgcGFuID0gY3kucGFuKCk7XG4gICAgdmFyIHJwb3MgPSBwbGFpbk9iamVjdChkaW0pID8gZGltIDogdW5kZWZpbmVkO1xuICAgIHZhciBzZXR0aW5nID0gcnBvcyAhPT0gdW5kZWZpbmVkIHx8IHZhbCAhPT0gdW5kZWZpbmVkICYmIHN0cmluZyhkaW0pO1xuICAgIGlmIChlbGUgJiYgZWxlLmlzTm9kZSgpKSB7XG4gICAgICAvLyBtdXN0IGhhdmUgYW4gZWxlbWVudCBhbmQgbXVzdCBiZSBhIG5vZGUgdG8gcmV0dXJuIHBvc2l0aW9uXG4gICAgICBpZiAoc2V0dGluZykge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgX2VsZSA9IHRoaXNbaV07XG4gICAgICAgICAgaWYgKHZhbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBzZXQgb25lIGRpbWVuc2lvblxuICAgICAgICAgICAgX2VsZS5wb3NpdGlvbihkaW0sICh2YWwgLSBwYW5bZGltXSkgLyB6b29tKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHJwb3MgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gc2V0IHdob2xlIHBvc2l0aW9uXG4gICAgICAgICAgICBfZWxlLnBvc2l0aW9uKHJlbmRlcmVkVG9Nb2RlbFBvc2l0aW9uKHJwb3MsIHpvb20sIHBhbikpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZ2V0dGluZ1xuICAgICAgICB2YXIgcG9zID0gZWxlLnBvc2l0aW9uKCk7XG4gICAgICAgIHJwb3MgPSBtb2RlbFRvUmVuZGVyZWRQb3NpdGlvbihwb3MsIHpvb20sIHBhbik7XG4gICAgICAgIGlmIChkaW0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIC8vIHRoZW4gcmV0dXJuIHRoZSB3aG9sZSByZW5kZXJlZCBwb3NpdGlvblxuICAgICAgICAgIHJldHVybiBycG9zO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHRoZW4gcmV0dXJuIHRoZSBzcGVjaWZpZWQgZGltZW5zaW9uXG4gICAgICAgICAgcmV0dXJuIHJwb3NbZGltXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIXNldHRpbmcpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7IC8vIGZvciBlbXB0eSBjb2xsZWN0aW9uIGNhc2VcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfSxcblxuICAvLyBnZXQvc2V0IHRoZSBwb3NpdGlvbiByZWxhdGl2ZSB0byB0aGUgcGFyZW50XG4gIHJlbGF0aXZlUG9zaXRpb246IGZ1bmN0aW9uIHJlbGF0aXZlUG9zaXRpb24oZGltLCB2YWwpIHtcbiAgICB2YXIgZWxlID0gdGhpc1swXTtcbiAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG4gICAgdmFyIHBwb3MgPSBwbGFpbk9iamVjdChkaW0pID8gZGltIDogdW5kZWZpbmVkO1xuICAgIHZhciBzZXR0aW5nID0gcHBvcyAhPT0gdW5kZWZpbmVkIHx8IHZhbCAhPT0gdW5kZWZpbmVkICYmIHN0cmluZyhkaW0pO1xuICAgIHZhciBoYXNDb21wb3VuZE5vZGVzID0gY3kuaGFzQ29tcG91bmROb2RlcygpO1xuICAgIGlmIChlbGUgJiYgZWxlLmlzTm9kZSgpKSB7XG4gICAgICAvLyBtdXN0IGhhdmUgYW4gZWxlbWVudCBhbmQgbXVzdCBiZSBhIG5vZGUgdG8gcmV0dXJuIHBvc2l0aW9uXG4gICAgICBpZiAoc2V0dGluZykge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgX2VsZTIgPSB0aGlzW2ldO1xuICAgICAgICAgIHZhciBwYXJlbnQgPSBoYXNDb21wb3VuZE5vZGVzID8gX2VsZTIucGFyZW50KCkgOiBudWxsO1xuICAgICAgICAgIHZhciBoYXNQYXJlbnQgPSBwYXJlbnQgJiYgcGFyZW50Lmxlbmd0aCA+IDA7XG4gICAgICAgICAgdmFyIHJlbGF0aXZlVG9QYXJlbnQgPSBoYXNQYXJlbnQ7XG4gICAgICAgICAgaWYgKGhhc1BhcmVudCkge1xuICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50WzBdO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgb3JpZ2luID0gcmVsYXRpdmVUb1BhcmVudCA/IHBhcmVudC5wb3NpdGlvbigpIDoge1xuICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgIHk6IDBcbiAgICAgICAgICB9O1xuICAgICAgICAgIGlmICh2YWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gc2V0IG9uZSBkaW1lbnNpb25cbiAgICAgICAgICAgIF9lbGUyLnBvc2l0aW9uKGRpbSwgdmFsICsgb3JpZ2luW2RpbV0pO1xuICAgICAgICAgIH0gZWxzZSBpZiAocHBvcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBzZXQgd2hvbGUgcG9zaXRpb25cbiAgICAgICAgICAgIF9lbGUyLnBvc2l0aW9uKHtcbiAgICAgICAgICAgICAgeDogcHBvcy54ICsgb3JpZ2luLngsXG4gICAgICAgICAgICAgIHk6IHBwb3MueSArIG9yaWdpbi55XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGdldHRpbmdcbiAgICAgICAgdmFyIHBvcyA9IGVsZS5wb3NpdGlvbigpO1xuICAgICAgICB2YXIgX3BhcmVudCA9IGhhc0NvbXBvdW5kTm9kZXMgPyBlbGUucGFyZW50KCkgOiBudWxsO1xuICAgICAgICB2YXIgX2hhc1BhcmVudCA9IF9wYXJlbnQgJiYgX3BhcmVudC5sZW5ndGggPiAwO1xuICAgICAgICB2YXIgX3JlbGF0aXZlVG9QYXJlbnQgPSBfaGFzUGFyZW50O1xuICAgICAgICBpZiAoX2hhc1BhcmVudCkge1xuICAgICAgICAgIF9wYXJlbnQgPSBfcGFyZW50WzBdO1xuICAgICAgICB9XG4gICAgICAgIHZhciBfb3JpZ2luID0gX3JlbGF0aXZlVG9QYXJlbnQgPyBfcGFyZW50LnBvc2l0aW9uKCkgOiB7XG4gICAgICAgICAgeDogMCxcbiAgICAgICAgICB5OiAwXG4gICAgICAgIH07XG4gICAgICAgIHBwb3MgPSB7XG4gICAgICAgICAgeDogcG9zLnggLSBfb3JpZ2luLngsXG4gICAgICAgICAgeTogcG9zLnkgLSBfb3JpZ2luLnlcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGRpbSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgLy8gdGhlbiByZXR1cm4gdGhlIHdob2xlIHJlbmRlcmVkIHBvc2l0aW9uXG4gICAgICAgICAgcmV0dXJuIHBwb3M7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gdGhlbiByZXR1cm4gdGhlIHNwZWNpZmllZCBkaW1lbnNpb25cbiAgICAgICAgICByZXR1cm4gcHBvc1tkaW1dO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghc2V0dGluZykge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDsgLy8gZm9yIGVtcHR5IGNvbGxlY3Rpb24gY2FzZVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9XG59O1xuXG4vLyBhbGlhc2VzXG5mbiQ0Lm1vZGVsUG9zaXRpb24gPSBmbiQ0LnBvaW50ID0gZm4kNC5wb3NpdGlvbjtcbmZuJDQubW9kZWxQb3NpdGlvbnMgPSBmbiQ0LnBvaW50cyA9IGZuJDQucG9zaXRpb25zO1xuZm4kNC5yZW5kZXJlZFBvaW50ID0gZm4kNC5yZW5kZXJlZFBvc2l0aW9uO1xuZm4kNC5yZWxhdGl2ZVBvaW50ID0gZm4kNC5yZWxhdGl2ZVBvc2l0aW9uO1xudmFyIHBvc2l0aW9uID0gZWxlc2ZuJGM7XG5cbnZhciBmbiQzLCBlbGVzZm4kYjtcbmZuJDMgPSBlbGVzZm4kYiA9IHt9O1xuZWxlc2ZuJGIucmVuZGVyZWRCb3VuZGluZ0JveCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIHZhciBiYiA9IHRoaXMuYm91bmRpbmdCb3gob3B0aW9ucyk7XG4gIHZhciBjeSA9IHRoaXMuY3koKTtcbiAgdmFyIHpvb20gPSBjeS56b29tKCk7XG4gIHZhciBwYW4gPSBjeS5wYW4oKTtcbiAgdmFyIHgxID0gYmIueDEgKiB6b29tICsgcGFuLng7XG4gIHZhciB4MiA9IGJiLngyICogem9vbSArIHBhbi54O1xuICB2YXIgeTEgPSBiYi55MSAqIHpvb20gKyBwYW4ueTtcbiAgdmFyIHkyID0gYmIueTIgKiB6b29tICsgcGFuLnk7XG4gIHJldHVybiB7XG4gICAgeDE6IHgxLFxuICAgIHgyOiB4MixcbiAgICB5MTogeTEsXG4gICAgeTI6IHkyLFxuICAgIHc6IHgyIC0geDEsXG4gICAgaDogeTIgLSB5MVxuICB9O1xufTtcbmVsZXNmbiRiLmRpcnR5Q29tcG91bmRCb3VuZHNDYWNoZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNpbGVudCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogZmFsc2U7XG4gIHZhciBjeSA9IHRoaXMuY3koKTtcbiAgaWYgKCFjeS5zdHlsZUVuYWJsZWQoKSB8fCAhY3kuaGFzQ29tcG91bmROb2RlcygpKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgdGhpcy5mb3JFYWNoVXAoZnVuY3Rpb24gKGVsZSkge1xuICAgIGlmIChlbGUuaXNQYXJlbnQoKSkge1xuICAgICAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuICAgICAgX3AuY29tcG91bmRCb3VuZHNDbGVhbiA9IGZhbHNlO1xuICAgICAgX3AuYmJDYWNoZSA9IG51bGw7XG4gICAgICBpZiAoIXNpbGVudCkge1xuICAgICAgICBlbGUuZW1pdEFuZE5vdGlmeSgnYm91bmRzJyk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuZWxlc2ZuJGIudXBkYXRlQ29tcG91bmRCb3VuZHMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBmb3JjZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogZmFsc2U7XG4gIHZhciBjeSA9IHRoaXMuY3koKTtcblxuICAvLyBub3QgcG9zc2libGUgdG8gZG8gb24gbm9uLWNvbXBvdW5kIGdyYXBocyBvciB3aXRoIHRoZSBzdHlsZSBkaXNhYmxlZFxuICBpZiAoIWN5LnN0eWxlRW5hYmxlZCgpIHx8ICFjeS5oYXNDb21wb3VuZE5vZGVzKCkpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIHNhdmUgY3ljbGVzIHdoZW4gYmF0Y2hpbmcgLS0gYnV0IGJvdW5kcyB3aWxsIGJlIHN0YWxlIChvciBub3QgZXhpc3QgeWV0KVxuICBpZiAoIWZvcmNlICYmIGN5LmJhdGNoaW5nKCkpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBmdW5jdGlvbiB1cGRhdGUocGFyZW50KSB7XG4gICAgaWYgKCFwYXJlbnQuaXNQYXJlbnQoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgX3AgPSBwYXJlbnQuX3ByaXZhdGU7XG4gICAgdmFyIGNoaWxkcmVuID0gcGFyZW50LmNoaWxkcmVuKCk7XG4gICAgdmFyIGluY2x1ZGVMYWJlbHMgPSBwYXJlbnQucHN0eWxlKCdjb21wb3VuZC1zaXppbmctd3J0LWxhYmVscycpLnZhbHVlID09PSAnaW5jbHVkZSc7XG4gICAgdmFyIG1pbiA9IHtcbiAgICAgIHdpZHRoOiB7XG4gICAgICAgIHZhbDogcGFyZW50LnBzdHlsZSgnbWluLXdpZHRoJykucGZWYWx1ZSxcbiAgICAgICAgbGVmdDogcGFyZW50LnBzdHlsZSgnbWluLXdpZHRoLWJpYXMtbGVmdCcpLFxuICAgICAgICByaWdodDogcGFyZW50LnBzdHlsZSgnbWluLXdpZHRoLWJpYXMtcmlnaHQnKVxuICAgICAgfSxcbiAgICAgIGhlaWdodDoge1xuICAgICAgICB2YWw6IHBhcmVudC5wc3R5bGUoJ21pbi1oZWlnaHQnKS5wZlZhbHVlLFxuICAgICAgICB0b3A6IHBhcmVudC5wc3R5bGUoJ21pbi1oZWlnaHQtYmlhcy10b3AnKSxcbiAgICAgICAgYm90dG9tOiBwYXJlbnQucHN0eWxlKCdtaW4taGVpZ2h0LWJpYXMtYm90dG9tJylcbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciBiYiA9IGNoaWxkcmVuLmJvdW5kaW5nQm94KHtcbiAgICAgIGluY2x1ZGVMYWJlbHM6IGluY2x1ZGVMYWJlbHMsXG4gICAgICBpbmNsdWRlT3ZlcmxheXM6IGZhbHNlLFxuICAgICAgLy8gdXBkYXRpbmcgdGhlIGNvbXBvdW5kIGJvdW5kcyBoYXBwZW5zIG91dHNpZGUgb2YgdGhlIHJlZ3VsYXJcbiAgICAgIC8vIGNhY2hlIGN5Y2xlIChpLmUuIGJlZm9yZSBmaXJlZCBldmVudHMpXG4gICAgICB1c2VDYWNoZTogZmFsc2VcbiAgICB9KTtcbiAgICB2YXIgcG9zID0gX3AucG9zaXRpb247XG5cbiAgICAvLyBpZiBjaGlsZHJlbiB0YWtlIHVwIHplcm8gYXJlYSB0aGVuIGtlZXAgcG9zaXRpb24gYW5kIGZhbGwgYmFjayBvbiBzdHlsZXNoZWV0IHcvaFxuICAgIGlmIChiYi53ID09PSAwIHx8IGJiLmggPT09IDApIHtcbiAgICAgIGJiID0ge1xuICAgICAgICB3OiBwYXJlbnQucHN0eWxlKCd3aWR0aCcpLnBmVmFsdWUsXG4gICAgICAgIGg6IHBhcmVudC5wc3R5bGUoJ2hlaWdodCcpLnBmVmFsdWVcbiAgICAgIH07XG4gICAgICBiYi54MSA9IHBvcy54IC0gYmIudyAvIDI7XG4gICAgICBiYi54MiA9IHBvcy54ICsgYmIudyAvIDI7XG4gICAgICBiYi55MSA9IHBvcy55IC0gYmIuaCAvIDI7XG4gICAgICBiYi55MiA9IHBvcy55ICsgYmIuaCAvIDI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbXB1dGVCaWFzVmFsdWVzKHByb3BEaWZmLCBwcm9wQmlhcywgcHJvcEJpYXNDb21wbGVtZW50KSB7XG4gICAgICB2YXIgYmlhc0RpZmYgPSAwO1xuICAgICAgdmFyIGJpYXNDb21wbGVtZW50RGlmZiA9IDA7XG4gICAgICB2YXIgYmlhc1RvdGFsID0gcHJvcEJpYXMgKyBwcm9wQmlhc0NvbXBsZW1lbnQ7XG4gICAgICBpZiAocHJvcERpZmYgPiAwICYmIGJpYXNUb3RhbCA+IDApIHtcbiAgICAgICAgYmlhc0RpZmYgPSBwcm9wQmlhcyAvIGJpYXNUb3RhbCAqIHByb3BEaWZmO1xuICAgICAgICBiaWFzQ29tcGxlbWVudERpZmYgPSBwcm9wQmlhc0NvbXBsZW1lbnQgLyBiaWFzVG90YWwgKiBwcm9wRGlmZjtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGJpYXNEaWZmOiBiaWFzRGlmZixcbiAgICAgICAgYmlhc0NvbXBsZW1lbnREaWZmOiBiaWFzQ29tcGxlbWVudERpZmZcbiAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbXB1dGVQYWRkaW5nVmFsdWVzKHdpZHRoLCBoZWlnaHQsIHBhZGRpbmdPYmplY3QsIHJlbGF0aXZlVG8pIHtcbiAgICAgIC8vIEFzc3VtaW5nIHBlcmNlbnRhZ2UgaXMgbnVtYmVyIGZyb20gMCB0byAxXG4gICAgICBpZiAocGFkZGluZ09iamVjdC51bml0cyA9PT0gJyUnKSB7XG4gICAgICAgIHN3aXRjaCAocmVsYXRpdmVUbykge1xuICAgICAgICAgIGNhc2UgJ3dpZHRoJzpcbiAgICAgICAgICAgIHJldHVybiB3aWR0aCA+IDAgPyBwYWRkaW5nT2JqZWN0LnBmVmFsdWUgKiB3aWR0aCA6IDA7XG4gICAgICAgICAgY2FzZSAnaGVpZ2h0JzpcbiAgICAgICAgICAgIHJldHVybiBoZWlnaHQgPiAwID8gcGFkZGluZ09iamVjdC5wZlZhbHVlICogaGVpZ2h0IDogMDtcbiAgICAgICAgICBjYXNlICdhdmVyYWdlJzpcbiAgICAgICAgICAgIHJldHVybiB3aWR0aCA+IDAgJiYgaGVpZ2h0ID4gMCA/IHBhZGRpbmdPYmplY3QucGZWYWx1ZSAqICh3aWR0aCArIGhlaWdodCkgLyAyIDogMDtcbiAgICAgICAgICBjYXNlICdtaW4nOlxuICAgICAgICAgICAgcmV0dXJuIHdpZHRoID4gMCAmJiBoZWlnaHQgPiAwID8gd2lkdGggPiBoZWlnaHQgPyBwYWRkaW5nT2JqZWN0LnBmVmFsdWUgKiBoZWlnaHQgOiBwYWRkaW5nT2JqZWN0LnBmVmFsdWUgKiB3aWR0aCA6IDA7XG4gICAgICAgICAgY2FzZSAnbWF4JzpcbiAgICAgICAgICAgIHJldHVybiB3aWR0aCA+IDAgJiYgaGVpZ2h0ID4gMCA/IHdpZHRoID4gaGVpZ2h0ID8gcGFkZGluZ09iamVjdC5wZlZhbHVlICogd2lkdGggOiBwYWRkaW5nT2JqZWN0LnBmVmFsdWUgKiBoZWlnaHQgOiAwO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChwYWRkaW5nT2JqZWN0LnVuaXRzID09PSAncHgnKSB7XG4gICAgICAgIHJldHVybiBwYWRkaW5nT2JqZWN0LnBmVmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIGxlZnRWYWwgPSBtaW4ud2lkdGgubGVmdC52YWx1ZTtcbiAgICBpZiAobWluLndpZHRoLmxlZnQudW5pdHMgPT09ICdweCcgJiYgbWluLndpZHRoLnZhbCA+IDApIHtcbiAgICAgIGxlZnRWYWwgPSBsZWZ0VmFsICogMTAwIC8gbWluLndpZHRoLnZhbDtcbiAgICB9XG4gICAgdmFyIHJpZ2h0VmFsID0gbWluLndpZHRoLnJpZ2h0LnZhbHVlO1xuICAgIGlmIChtaW4ud2lkdGgucmlnaHQudW5pdHMgPT09ICdweCcgJiYgbWluLndpZHRoLnZhbCA+IDApIHtcbiAgICAgIHJpZ2h0VmFsID0gcmlnaHRWYWwgKiAxMDAgLyBtaW4ud2lkdGgudmFsO1xuICAgIH1cbiAgICB2YXIgdG9wVmFsID0gbWluLmhlaWdodC50b3AudmFsdWU7XG4gICAgaWYgKG1pbi5oZWlnaHQudG9wLnVuaXRzID09PSAncHgnICYmIG1pbi5oZWlnaHQudmFsID4gMCkge1xuICAgICAgdG9wVmFsID0gdG9wVmFsICogMTAwIC8gbWluLmhlaWdodC52YWw7XG4gICAgfVxuICAgIHZhciBib3R0b21WYWwgPSBtaW4uaGVpZ2h0LmJvdHRvbS52YWx1ZTtcbiAgICBpZiAobWluLmhlaWdodC5ib3R0b20udW5pdHMgPT09ICdweCcgJiYgbWluLmhlaWdodC52YWwgPiAwKSB7XG4gICAgICBib3R0b21WYWwgPSBib3R0b21WYWwgKiAxMDAgLyBtaW4uaGVpZ2h0LnZhbDtcbiAgICB9XG4gICAgdmFyIHdpZHRoQmlhc0RpZmZzID0gY29tcHV0ZUJpYXNWYWx1ZXMobWluLndpZHRoLnZhbCAtIGJiLncsIGxlZnRWYWwsIHJpZ2h0VmFsKTtcbiAgICB2YXIgZGlmZkxlZnQgPSB3aWR0aEJpYXNEaWZmcy5iaWFzRGlmZjtcbiAgICB2YXIgZGlmZlJpZ2h0ID0gd2lkdGhCaWFzRGlmZnMuYmlhc0NvbXBsZW1lbnREaWZmO1xuICAgIHZhciBoZWlnaHRCaWFzRGlmZnMgPSBjb21wdXRlQmlhc1ZhbHVlcyhtaW4uaGVpZ2h0LnZhbCAtIGJiLmgsIHRvcFZhbCwgYm90dG9tVmFsKTtcbiAgICB2YXIgZGlmZlRvcCA9IGhlaWdodEJpYXNEaWZmcy5iaWFzRGlmZjtcbiAgICB2YXIgZGlmZkJvdHRvbSA9IGhlaWdodEJpYXNEaWZmcy5iaWFzQ29tcGxlbWVudERpZmY7XG4gICAgX3AuYXV0b1BhZGRpbmcgPSBjb21wdXRlUGFkZGluZ1ZhbHVlcyhiYi53LCBiYi5oLCBwYXJlbnQucHN0eWxlKCdwYWRkaW5nJyksIHBhcmVudC5wc3R5bGUoJ3BhZGRpbmctcmVsYXRpdmUtdG8nKS52YWx1ZSk7XG4gICAgX3AuYXV0b1dpZHRoID0gTWF0aC5tYXgoYmIudywgbWluLndpZHRoLnZhbCk7XG4gICAgcG9zLnggPSAoLWRpZmZMZWZ0ICsgYmIueDEgKyBiYi54MiArIGRpZmZSaWdodCkgLyAyO1xuICAgIF9wLmF1dG9IZWlnaHQgPSBNYXRoLm1heChiYi5oLCBtaW4uaGVpZ2h0LnZhbCk7XG4gICAgcG9zLnkgPSAoLWRpZmZUb3AgKyBiYi55MSArIGJiLnkyICsgZGlmZkJvdHRvbSkgLyAyO1xuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBlbGUgPSB0aGlzW2ldO1xuICAgIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgICBpZiAoIV9wLmNvbXBvdW5kQm91bmRzQ2xlYW4gfHwgZm9yY2UpIHtcbiAgICAgIHVwZGF0ZShlbGUpO1xuICAgICAgaWYgKCFjeS5iYXRjaGluZygpKSB7XG4gICAgICAgIF9wLmNvbXBvdW5kQm91bmRzQ2xlYW4gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG52YXIgbm9uaW5mID0gZnVuY3Rpb24gbm9uaW5mKHgpIHtcbiAgaWYgKHggPT09IEluZmluaXR5IHx8IHggPT09IC1JbmZpbml0eSkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIHJldHVybiB4O1xufTtcbnZhciB1cGRhdGVCb3VuZHMgPSBmdW5jdGlvbiB1cGRhdGVCb3VuZHMoYiwgeDEsIHkxLCB4MiwgeTIpIHtcbiAgLy8gZG9uJ3QgdXBkYXRlIHdpdGggemVybyBhcmVhIGJveGVzXG4gIGlmICh4MiAtIHgxID09PSAwIHx8IHkyIC0geTEgPT09IDApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBkb24ndCB1cGRhdGUgd2l0aCBudWxsIGRpbVxuICBpZiAoeDEgPT0gbnVsbCB8fCB5MSA9PSBudWxsIHx8IHgyID09IG51bGwgfHwgeTIgPT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuICBiLngxID0geDEgPCBiLngxID8geDEgOiBiLngxO1xuICBiLngyID0geDIgPiBiLngyID8geDIgOiBiLngyO1xuICBiLnkxID0geTEgPCBiLnkxID8geTEgOiBiLnkxO1xuICBiLnkyID0geTIgPiBiLnkyID8geTIgOiBiLnkyO1xuICBiLncgPSBiLngyIC0gYi54MTtcbiAgYi5oID0gYi55MiAtIGIueTE7XG59O1xudmFyIHVwZGF0ZUJvdW5kc0Zyb21Cb3ggPSBmdW5jdGlvbiB1cGRhdGVCb3VuZHNGcm9tQm94KGIsIGIyKSB7XG4gIGlmIChiMiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGI7XG4gIH1cbiAgcmV0dXJuIHVwZGF0ZUJvdW5kcyhiLCBiMi54MSwgYjIueTEsIGIyLngyLCBiMi55Mik7XG59O1xudmFyIHByZWZpeGVkUHJvcGVydHkgPSBmdW5jdGlvbiBwcmVmaXhlZFByb3BlcnR5KG9iaiwgZmllbGQsIHByZWZpeCkge1xuICByZXR1cm4gZ2V0UHJlZml4ZWRQcm9wZXJ0eShvYmosIGZpZWxkLCBwcmVmaXgpO1xufTtcbnZhciB1cGRhdGVCb3VuZHNGcm9tQXJyb3cgPSBmdW5jdGlvbiB1cGRhdGVCb3VuZHNGcm9tQXJyb3coYm91bmRzLCBlbGUsIHByZWZpeCkge1xuICBpZiAoZWxlLmN5KCkuaGVhZGxlc3MoKSkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gIHZhciByc3R5bGUgPSBfcC5yc3R5bGU7XG4gIHZhciBoYWxmQXJXID0gcnN0eWxlLmFycm93V2lkdGggLyAyO1xuICB2YXIgYXJyb3dUeXBlID0gZWxlLnBzdHlsZShwcmVmaXggKyAnLWFycm93LXNoYXBlJykudmFsdWU7XG4gIHZhciB4O1xuICB2YXIgeTtcbiAgaWYgKGFycm93VHlwZSAhPT0gJ25vbmUnKSB7XG4gICAgaWYgKHByZWZpeCA9PT0gJ3NvdXJjZScpIHtcbiAgICAgIHggPSByc3R5bGUuc3JjWDtcbiAgICAgIHkgPSByc3R5bGUuc3JjWTtcbiAgICB9IGVsc2UgaWYgKHByZWZpeCA9PT0gJ3RhcmdldCcpIHtcbiAgICAgIHggPSByc3R5bGUudGd0WDtcbiAgICAgIHkgPSByc3R5bGUudGd0WTtcbiAgICB9IGVsc2Uge1xuICAgICAgeCA9IHJzdHlsZS5taWRYO1xuICAgICAgeSA9IHJzdHlsZS5taWRZO1xuICAgIH1cblxuICAgIC8vIGFsd2F5cyBzdG9yZSB0aGUgaW5kaXZpZHVhbCBhcnJvdyBib3VuZHNcbiAgICB2YXIgYmJzID0gX3AuYXJyb3dCb3VuZHMgPSBfcC5hcnJvd0JvdW5kcyB8fCB7fTtcbiAgICB2YXIgYmIgPSBiYnNbcHJlZml4XSA9IGJic1twcmVmaXhdIHx8IHt9O1xuICAgIGJiLngxID0geCAtIGhhbGZBclc7XG4gICAgYmIueTEgPSB5IC0gaGFsZkFyVztcbiAgICBiYi54MiA9IHggKyBoYWxmQXJXO1xuICAgIGJiLnkyID0geSArIGhhbGZBclc7XG4gICAgYmIudyA9IGJiLngyIC0gYmIueDE7XG4gICAgYmIuaCA9IGJiLnkyIC0gYmIueTE7XG4gICAgZXhwYW5kQm91bmRpbmdCb3goYmIsIDEpO1xuICAgIHVwZGF0ZUJvdW5kcyhib3VuZHMsIGJiLngxLCBiYi55MSwgYmIueDIsIGJiLnkyKTtcbiAgfVxufTtcbnZhciB1cGRhdGVCb3VuZHNGcm9tTGFiZWwgPSBmdW5jdGlvbiB1cGRhdGVCb3VuZHNGcm9tTGFiZWwoYm91bmRzLCBlbGUsIHByZWZpeCkge1xuICBpZiAoZWxlLmN5KCkuaGVhZGxlc3MoKSkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgcHJlZml4RGFzaDtcbiAgaWYgKHByZWZpeCkge1xuICAgIHByZWZpeERhc2ggPSBwcmVmaXggKyAnLSc7XG4gIH0gZWxzZSB7XG4gICAgcHJlZml4RGFzaCA9ICcnO1xuICB9XG4gIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgdmFyIHJzdHlsZSA9IF9wLnJzdHlsZTtcbiAgdmFyIGxhYmVsID0gZWxlLnBzdHlsZShwcmVmaXhEYXNoICsgJ2xhYmVsJykuc3RyVmFsdWU7XG4gIGlmIChsYWJlbCkge1xuICAgIHZhciBoYWxpZ24gPSBlbGUucHN0eWxlKCd0ZXh0LWhhbGlnbicpO1xuICAgIHZhciB2YWxpZ24gPSBlbGUucHN0eWxlKCd0ZXh0LXZhbGlnbicpO1xuICAgIHZhciBsYWJlbFdpZHRoID0gcHJlZml4ZWRQcm9wZXJ0eShyc3R5bGUsICdsYWJlbFdpZHRoJywgcHJlZml4KTtcbiAgICB2YXIgbGFiZWxIZWlnaHQgPSBwcmVmaXhlZFByb3BlcnR5KHJzdHlsZSwgJ2xhYmVsSGVpZ2h0JywgcHJlZml4KTtcbiAgICB2YXIgbGFiZWxYID0gcHJlZml4ZWRQcm9wZXJ0eShyc3R5bGUsICdsYWJlbFgnLCBwcmVmaXgpO1xuICAgIHZhciBsYWJlbFkgPSBwcmVmaXhlZFByb3BlcnR5KHJzdHlsZSwgJ2xhYmVsWScsIHByZWZpeCk7XG4gICAgdmFyIG1hcmdpblggPSBlbGUucHN0eWxlKHByZWZpeERhc2ggKyAndGV4dC1tYXJnaW4teCcpLnBmVmFsdWU7XG4gICAgdmFyIG1hcmdpblkgPSBlbGUucHN0eWxlKHByZWZpeERhc2ggKyAndGV4dC1tYXJnaW4teScpLnBmVmFsdWU7XG4gICAgdmFyIGlzRWRnZSA9IGVsZS5pc0VkZ2UoKTtcbiAgICB2YXIgcm90YXRpb24gPSBlbGUucHN0eWxlKHByZWZpeERhc2ggKyAndGV4dC1yb3RhdGlvbicpO1xuICAgIHZhciBvdXRsaW5lV2lkdGggPSBlbGUucHN0eWxlKCd0ZXh0LW91dGxpbmUtd2lkdGgnKS5wZlZhbHVlO1xuICAgIHZhciBib3JkZXJXaWR0aCA9IGVsZS5wc3R5bGUoJ3RleHQtYm9yZGVyLXdpZHRoJykucGZWYWx1ZTtcbiAgICB2YXIgaGFsZkJvcmRlcldpZHRoID0gYm9yZGVyV2lkdGggLyAyO1xuICAgIHZhciBwYWRkaW5nID0gZWxlLnBzdHlsZSgndGV4dC1iYWNrZ3JvdW5kLXBhZGRpbmcnKS5wZlZhbHVlO1xuICAgIHZhciBtYXJnaW5PZkVycm9yID0gMjsgLy8gZXhwYW5kIHRvIHdvcmsgYXJvdW5kIGJyb3dzZXIgZGltZW5zaW9uIGluYWNjdXJhY2llc1xuXG4gICAgdmFyIGxoID0gbGFiZWxIZWlnaHQ7XG4gICAgdmFyIGx3ID0gbGFiZWxXaWR0aDtcbiAgICB2YXIgbHdfMiA9IGx3IC8gMjtcbiAgICB2YXIgbGhfMiA9IGxoIC8gMjtcbiAgICB2YXIgbHgxLCBseDIsIGx5MSwgbHkyO1xuICAgIGlmIChpc0VkZ2UpIHtcbiAgICAgIGx4MSA9IGxhYmVsWCAtIGx3XzI7XG4gICAgICBseDIgPSBsYWJlbFggKyBsd18yO1xuICAgICAgbHkxID0gbGFiZWxZIC0gbGhfMjtcbiAgICAgIGx5MiA9IGxhYmVsWSArIGxoXzI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN3aXRjaCAoaGFsaWduLnZhbHVlKSB7XG4gICAgICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgICAgIGx4MSA9IGxhYmVsWCAtIGx3O1xuICAgICAgICAgIGx4MiA9IGxhYmVsWDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnY2VudGVyJzpcbiAgICAgICAgICBseDEgPSBsYWJlbFggLSBsd18yO1xuICAgICAgICAgIGx4MiA9IGxhYmVsWCArIGx3XzI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgICBseDEgPSBsYWJlbFg7XG4gICAgICAgICAgbHgyID0gbGFiZWxYICsgbHc7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKHZhbGlnbi52YWx1ZSkge1xuICAgICAgICBjYXNlICd0b3AnOlxuICAgICAgICAgIGx5MSA9IGxhYmVsWSAtIGxoO1xuICAgICAgICAgIGx5MiA9IGxhYmVsWTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnY2VudGVyJzpcbiAgICAgICAgICBseTEgPSBsYWJlbFkgLSBsaF8yO1xuICAgICAgICAgIGx5MiA9IGxhYmVsWSArIGxoXzI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICAgICAgbHkxID0gbGFiZWxZO1xuICAgICAgICAgIGx5MiA9IGxhYmVsWSArIGxoO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHNoaWZ0IGJ5IG1hcmdpbiBhbmQgZXhwYW5kIGJ5IG91dGxpbmUgYW5kIGJvcmRlclxuICAgIHZhciBsZWZ0UGFkID0gbWFyZ2luWCAtIE1hdGgubWF4KG91dGxpbmVXaWR0aCwgaGFsZkJvcmRlcldpZHRoKSAtIHBhZGRpbmcgLSBtYXJnaW5PZkVycm9yO1xuICAgIHZhciByaWdodFBhZCA9IG1hcmdpblggKyBNYXRoLm1heChvdXRsaW5lV2lkdGgsIGhhbGZCb3JkZXJXaWR0aCkgKyBwYWRkaW5nICsgbWFyZ2luT2ZFcnJvcjtcbiAgICB2YXIgdG9wUGFkID0gbWFyZ2luWSAtIE1hdGgubWF4KG91dGxpbmVXaWR0aCwgaGFsZkJvcmRlcldpZHRoKSAtIHBhZGRpbmcgLSBtYXJnaW5PZkVycm9yO1xuICAgIHZhciBib3RQYWQgPSBtYXJnaW5ZICsgTWF0aC5tYXgob3V0bGluZVdpZHRoLCBoYWxmQm9yZGVyV2lkdGgpICsgcGFkZGluZyArIG1hcmdpbk9mRXJyb3I7XG4gICAgbHgxICs9IGxlZnRQYWQ7XG4gICAgbHgyICs9IHJpZ2h0UGFkO1xuICAgIGx5MSArPSB0b3BQYWQ7XG4gICAgbHkyICs9IGJvdFBhZDtcblxuICAgIC8vIGFsd2F5cyBzdG9yZSB0aGUgdW5yb3RhdGVkIGxhYmVsIGJvdW5kcyBzZXBhcmF0ZWx5XG4gICAgdmFyIGJiUHJlZml4ID0gcHJlZml4IHx8ICdtYWluJztcbiAgICB2YXIgYmJzID0gX3AubGFiZWxCb3VuZHM7XG4gICAgdmFyIGJiID0gYmJzW2JiUHJlZml4XSA9IGJic1tiYlByZWZpeF0gfHwge307XG4gICAgYmIueDEgPSBseDE7XG4gICAgYmIueTEgPSBseTE7XG4gICAgYmIueDIgPSBseDI7XG4gICAgYmIueTIgPSBseTI7XG4gICAgYmIudyA9IGx4MiAtIGx4MTtcbiAgICBiYi5oID0gbHkyIC0gbHkxO1xuICAgIGJiLmxlZnRQYWQgPSBsZWZ0UGFkO1xuICAgIGJiLnJpZ2h0UGFkID0gcmlnaHRQYWQ7XG4gICAgYmIudG9wUGFkID0gdG9wUGFkO1xuICAgIGJiLmJvdFBhZCA9IGJvdFBhZDtcbiAgICB2YXIgaXNBdXRvcm90YXRlID0gaXNFZGdlICYmIHJvdGF0aW9uLnN0clZhbHVlID09PSAnYXV0b3JvdGF0ZSc7XG4gICAgdmFyIGlzUGZWYWx1ZSA9IHJvdGF0aW9uLnBmVmFsdWUgIT0gbnVsbCAmJiByb3RhdGlvbi5wZlZhbHVlICE9PSAwO1xuICAgIGlmIChpc0F1dG9yb3RhdGUgfHwgaXNQZlZhbHVlKSB7XG4gICAgICB2YXIgdGhldGEgPSBpc0F1dG9yb3RhdGUgPyBwcmVmaXhlZFByb3BlcnR5KF9wLnJzdHlsZSwgJ2xhYmVsQW5nbGUnLCBwcmVmaXgpIDogcm90YXRpb24ucGZWYWx1ZTtcbiAgICAgIHZhciBjb3MgPSBNYXRoLmNvcyh0aGV0YSk7XG4gICAgICB2YXIgc2luID0gTWF0aC5zaW4odGhldGEpO1xuXG4gICAgICAvLyByb3RhdGlvbiBwb2ludCAoZGVmYXVsdCB2YWx1ZSBmb3IgY2VudGVyLWNlbnRlcilcbiAgICAgIHZhciB4byA9IChseDEgKyBseDIpIC8gMjtcbiAgICAgIHZhciB5byA9IChseTEgKyBseTIpIC8gMjtcbiAgICAgIGlmICghaXNFZGdlKSB7XG4gICAgICAgIHN3aXRjaCAoaGFsaWduLnZhbHVlKSB7XG4gICAgICAgICAgY2FzZSAnbGVmdCc6XG4gICAgICAgICAgICB4byA9IGx4MjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgICAgIHhvID0gbHgxO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoICh2YWxpZ24udmFsdWUpIHtcbiAgICAgICAgICBjYXNlICd0b3AnOlxuICAgICAgICAgICAgeW8gPSBseTI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdib3R0b20nOlxuICAgICAgICAgICAgeW8gPSBseTE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIHJvdGF0ZSA9IGZ1bmN0aW9uIHJvdGF0ZSh4LCB5KSB7XG4gICAgICAgIHggPSB4IC0geG87XG4gICAgICAgIHkgPSB5IC0geW87XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgeDogeCAqIGNvcyAtIHkgKiBzaW4gKyB4byxcbiAgICAgICAgICB5OiB4ICogc2luICsgeSAqIGNvcyArIHlvXG4gICAgICAgIH07XG4gICAgICB9O1xuICAgICAgdmFyIHB4MXkxID0gcm90YXRlKGx4MSwgbHkxKTtcbiAgICAgIHZhciBweDF5MiA9IHJvdGF0ZShseDEsIGx5Mik7XG4gICAgICB2YXIgcHgyeTEgPSByb3RhdGUobHgyLCBseTEpO1xuICAgICAgdmFyIHB4MnkyID0gcm90YXRlKGx4MiwgbHkyKTtcbiAgICAgIGx4MSA9IE1hdGgubWluKHB4MXkxLngsIHB4MXkyLngsIHB4MnkxLngsIHB4MnkyLngpO1xuICAgICAgbHgyID0gTWF0aC5tYXgocHgxeTEueCwgcHgxeTIueCwgcHgyeTEueCwgcHgyeTIueCk7XG4gICAgICBseTEgPSBNYXRoLm1pbihweDF5MS55LCBweDF5Mi55LCBweDJ5MS55LCBweDJ5Mi55KTtcbiAgICAgIGx5MiA9IE1hdGgubWF4KHB4MXkxLnksIHB4MXkyLnksIHB4MnkxLnksIHB4MnkyLnkpO1xuICAgIH1cbiAgICB2YXIgYmJQcmVmaXhSb3QgPSBiYlByZWZpeCArICdSb3QnO1xuICAgIHZhciBiYlJvdCA9IGJic1tiYlByZWZpeFJvdF0gPSBiYnNbYmJQcmVmaXhSb3RdIHx8IHt9O1xuICAgIGJiUm90LngxID0gbHgxO1xuICAgIGJiUm90LnkxID0gbHkxO1xuICAgIGJiUm90LngyID0gbHgyO1xuICAgIGJiUm90LnkyID0gbHkyO1xuICAgIGJiUm90LncgPSBseDIgLSBseDE7XG4gICAgYmJSb3QuaCA9IGx5MiAtIGx5MTtcbiAgICB1cGRhdGVCb3VuZHMoYm91bmRzLCBseDEsIGx5MSwgbHgyLCBseTIpO1xuICAgIHVwZGF0ZUJvdW5kcyhfcC5sYWJlbEJvdW5kcy5hbGwsIGx4MSwgbHkxLCBseDIsIGx5Mik7XG4gIH1cbiAgcmV0dXJuIGJvdW5kcztcbn07XG52YXIgdXBkYXRlQm91bmRzRnJvbU91dGxpbmUgPSBmdW5jdGlvbiB1cGRhdGVCb3VuZHNGcm9tT3V0bGluZShib3VuZHMsIGVsZSkge1xuICBpZiAoZWxlLmN5KCkuaGVhZGxlc3MoKSkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgb3V0bGluZU9wYWNpdHkgPSBlbGUucHN0eWxlKCdvdXRsaW5lLW9wYWNpdHknKS52YWx1ZTtcbiAgdmFyIG91dGxpbmVXaWR0aCA9IGVsZS5wc3R5bGUoJ291dGxpbmUtd2lkdGgnKS52YWx1ZTtcbiAgaWYgKG91dGxpbmVPcGFjaXR5ID4gMCAmJiBvdXRsaW5lV2lkdGggPiAwKSB7XG4gICAgdmFyIG91dGxpbmVPZmZzZXQgPSBlbGUucHN0eWxlKCdvdXRsaW5lLW9mZnNldCcpLnZhbHVlO1xuICAgIHZhciBub2RlU2hhcGUgPSBlbGUucHN0eWxlKCdzaGFwZScpLnZhbHVlO1xuICAgIHZhciBvdXRsaW5lU2l6ZSA9IG91dGxpbmVXaWR0aCArIG91dGxpbmVPZmZzZXQ7XG4gICAgdmFyIHNjYWxlWCA9IChib3VuZHMudyArIG91dGxpbmVTaXplICogMikgLyBib3VuZHMudztcbiAgICB2YXIgc2NhbGVZID0gKGJvdW5kcy5oICsgb3V0bGluZVNpemUgKiAyKSAvIGJvdW5kcy5oO1xuICAgIHZhciB4T2Zmc2V0ID0gMDtcbiAgICB2YXIgeU9mZnNldCA9IDA7XG4gICAgaWYgKFtcImRpYW1vbmRcIiwgXCJwZW50YWdvblwiLCBcInJvdW5kLXRyaWFuZ2xlXCJdLmluY2x1ZGVzKG5vZGVTaGFwZSkpIHtcbiAgICAgIHNjYWxlWCA9IChib3VuZHMudyArIG91dGxpbmVTaXplICogMi40KSAvIGJvdW5kcy53O1xuICAgICAgeU9mZnNldCA9IC1vdXRsaW5lU2l6ZSAvIDMuNjtcbiAgICB9IGVsc2UgaWYgKFtcImNvbmNhdmUtaGV4YWdvblwiLCBcInJob21ib2lkXCIsIFwicmlnaHQtcmhvbWJvaWRcIl0uaW5jbHVkZXMobm9kZVNoYXBlKSkge1xuICAgICAgc2NhbGVYID0gKGJvdW5kcy53ICsgb3V0bGluZVNpemUgKiAyLjQpIC8gYm91bmRzLnc7XG4gICAgfSBlbHNlIGlmIChub2RlU2hhcGUgPT09IFwic3RhclwiKSB7XG4gICAgICBzY2FsZVggPSAoYm91bmRzLncgKyBvdXRsaW5lU2l6ZSAqIDIuOCkgLyBib3VuZHMudztcbiAgICAgIHNjYWxlWSA9IChib3VuZHMuaCArIG91dGxpbmVTaXplICogMi42KSAvIGJvdW5kcy5oO1xuICAgICAgeU9mZnNldCA9IC1vdXRsaW5lU2l6ZSAvIDMuODtcbiAgICB9IGVsc2UgaWYgKG5vZGVTaGFwZSA9PT0gXCJ0cmlhbmdsZVwiKSB7XG4gICAgICBzY2FsZVggPSAoYm91bmRzLncgKyBvdXRsaW5lU2l6ZSAqIDIuOCkgLyBib3VuZHMudztcbiAgICAgIHNjYWxlWSA9IChib3VuZHMuaCArIG91dGxpbmVTaXplICogMi40KSAvIGJvdW5kcy5oO1xuICAgICAgeU9mZnNldCA9IC1vdXRsaW5lU2l6ZSAvIDEuNDtcbiAgICB9IGVsc2UgaWYgKG5vZGVTaGFwZSA9PT0gXCJ2ZWVcIikge1xuICAgICAgc2NhbGVYID0gKGJvdW5kcy53ICsgb3V0bGluZVNpemUgKiA0LjQpIC8gYm91bmRzLnc7XG4gICAgICBzY2FsZVkgPSAoYm91bmRzLmggKyBvdXRsaW5lU2l6ZSAqIDMuOCkgLyBib3VuZHMuaDtcbiAgICAgIHlPZmZzZXQgPSAtb3V0bGluZVNpemUgKiAuNTtcbiAgICB9XG4gICAgdmFyIGhEZWx0YSA9IGJvdW5kcy5oICogc2NhbGVZIC0gYm91bmRzLmg7XG4gICAgdmFyIHdEZWx0YSA9IGJvdW5kcy53ICogc2NhbGVYIC0gYm91bmRzLnc7XG4gICAgZXhwYW5kQm91bmRpbmdCb3hTaWRlcyhib3VuZHMsIFtNYXRoLmNlaWwoaERlbHRhIC8gMiksIE1hdGguY2VpbCh3RGVsdGEgLyAyKV0pO1xuICAgIGlmICh4T2Zmc2V0ICE9IDAgfHwgeU9mZnNldCAhPT0gMCkge1xuICAgICAgdmFyIG9Cb3VuZHMgPSBzaGlmdEJvdW5kaW5nQm94KGJvdW5kcywgeE9mZnNldCwgeU9mZnNldCk7XG4gICAgICB1cGRhdGVCb3VuZGluZ0JveChib3VuZHMsIG9Cb3VuZHMpO1xuICAgIH1cbiAgfVxufTtcblxuLy8gZ2V0IHRoZSBib3VuZGluZyBib3ggb2YgdGhlIGVsZW1lbnRzIChpbiByYXcgbW9kZWwgcG9zaXRpb24pXG52YXIgYm91bmRpbmdCb3hJbXBsID0gZnVuY3Rpb24gYm91bmRpbmdCb3hJbXBsKGVsZSwgb3B0aW9ucykge1xuICB2YXIgY3kgPSBlbGUuX3ByaXZhdGUuY3k7XG4gIHZhciBzdHlsZUVuYWJsZWQgPSBjeS5zdHlsZUVuYWJsZWQoKTtcbiAgdmFyIGhlYWRsZXNzID0gY3kuaGVhZGxlc3MoKTtcbiAgdmFyIGJvdW5kcyA9IG1ha2VCb3VuZGluZ0JveCgpO1xuICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gIHZhciBpc05vZGUgPSBlbGUuaXNOb2RlKCk7XG4gIHZhciBpc0VkZ2UgPSBlbGUuaXNFZGdlKCk7XG4gIHZhciBleDEsIGV4MiwgZXkxLCBleTI7IC8vIGV4dHJlbWEgb2YgYm9keSAvIGxpbmVzXG4gIHZhciB4LCB5OyAvLyBub2RlIHBvc1xuICB2YXIgcnN0eWxlID0gX3AucnN0eWxlO1xuICB2YXIgbWFudWFsRXhwYW5zaW9uID0gaXNOb2RlICYmIHN0eWxlRW5hYmxlZCA/IGVsZS5wc3R5bGUoJ2JvdW5kcy1leHBhbnNpb24nKS5wZlZhbHVlIDogWzBdO1xuXG4gIC8vIG11c3QgdXNlIGBkaXNwbGF5YCBwcm9wIG9ubHksIGFzIHJlYWRpbmcgYGNvbXBvdW5kLndpZHRoKClgIGNhdXNlcyByZWN1cnNpb25cbiAgLy8gKG90aGVyIGZhY3RvcnMgbGlrZSB3aWR0aCB2YWx1ZXMgd2lsbCBiZSBjb25zaWRlcmVkIGxhdGVyIGluIHRoaXMgZnVuY3Rpb24gYW55d2F5KVxuICB2YXIgaXNEaXNwbGF5ZWQgPSBmdW5jdGlvbiBpc0Rpc3BsYXllZChlbGUpIHtcbiAgICByZXR1cm4gZWxlLnBzdHlsZSgnZGlzcGxheScpLnZhbHVlICE9PSAnbm9uZSc7XG4gIH07XG4gIHZhciBkaXNwbGF5ZWQgPSAhc3R5bGVFbmFibGVkIHx8IGlzRGlzcGxheWVkKGVsZSlcblxuICAvLyBtdXN0IHRha2UgaW50byBhY2NvdW50IGNvbm5lY3RlZCBub2RlcyBiL2Mgb2YgaW1wbGljaXQgZWRnZSBoaWRpbmcgb24gZGlzcGxheTpub25lIG5vZGVcbiAgJiYgKCFpc0VkZ2UgfHwgaXNEaXNwbGF5ZWQoZWxlLnNvdXJjZSgpKSAmJiBpc0Rpc3BsYXllZChlbGUudGFyZ2V0KCkpKTtcbiAgaWYgKGRpc3BsYXllZCkge1xuICAgIC8vIGRpc3BsYXllZCBzdWZmaWNlcywgc2luY2Ugd2Ugd2lsbCBmaW5kIHplcm8gYXJlYSBlbGVzIGFueXdheVxuICAgIHZhciBvdmVybGF5T3BhY2l0eSA9IDA7XG4gICAgdmFyIG92ZXJsYXlQYWRkaW5nID0gMDtcbiAgICBpZiAoc3R5bGVFbmFibGVkICYmIG9wdGlvbnMuaW5jbHVkZU92ZXJsYXlzKSB7XG4gICAgICBvdmVybGF5T3BhY2l0eSA9IGVsZS5wc3R5bGUoJ292ZXJsYXktb3BhY2l0eScpLnZhbHVlO1xuICAgICAgaWYgKG92ZXJsYXlPcGFjaXR5ICE9PSAwKSB7XG4gICAgICAgIG92ZXJsYXlQYWRkaW5nID0gZWxlLnBzdHlsZSgnb3ZlcmxheS1wYWRkaW5nJykudmFsdWU7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciB1bmRlcmxheU9wYWNpdHkgPSAwO1xuICAgIHZhciB1bmRlcmxheVBhZGRpbmcgPSAwO1xuICAgIGlmIChzdHlsZUVuYWJsZWQgJiYgb3B0aW9ucy5pbmNsdWRlVW5kZXJsYXlzKSB7XG4gICAgICB1bmRlcmxheU9wYWNpdHkgPSBlbGUucHN0eWxlKCd1bmRlcmxheS1vcGFjaXR5JykudmFsdWU7XG4gICAgICBpZiAodW5kZXJsYXlPcGFjaXR5ICE9PSAwKSB7XG4gICAgICAgIHVuZGVybGF5UGFkZGluZyA9IGVsZS5wc3R5bGUoJ3VuZGVybGF5LXBhZGRpbmcnKS52YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIHBhZGRpbmcgPSBNYXRoLm1heChvdmVybGF5UGFkZGluZywgdW5kZXJsYXlQYWRkaW5nKTtcbiAgICB2YXIgdyA9IDA7XG4gICAgdmFyIHdIYWxmID0gMDtcbiAgICBpZiAoc3R5bGVFbmFibGVkKSB7XG4gICAgICB3ID0gZWxlLnBzdHlsZSgnd2lkdGgnKS5wZlZhbHVlO1xuICAgICAgd0hhbGYgPSB3IC8gMjtcbiAgICB9XG4gICAgaWYgKGlzTm9kZSAmJiBvcHRpb25zLmluY2x1ZGVOb2Rlcykge1xuICAgICAgdmFyIHBvcyA9IGVsZS5wb3NpdGlvbigpO1xuICAgICAgeCA9IHBvcy54O1xuICAgICAgeSA9IHBvcy55O1xuICAgICAgdmFyIF93ID0gZWxlLm91dGVyV2lkdGgoKTtcbiAgICAgIHZhciBoYWxmVyA9IF93IC8gMjtcbiAgICAgIHZhciBoID0gZWxlLm91dGVySGVpZ2h0KCk7XG4gICAgICB2YXIgaGFsZkggPSBoIC8gMjtcblxuICAgICAgLy8gaGFuZGxlIG5vZGUgZGltZW5zaW9uc1xuICAgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4gICAgICBleDEgPSB4IC0gaGFsZlc7XG4gICAgICBleDIgPSB4ICsgaGFsZlc7XG4gICAgICBleTEgPSB5IC0gaGFsZkg7XG4gICAgICBleTIgPSB5ICsgaGFsZkg7XG4gICAgICB1cGRhdGVCb3VuZHMoYm91bmRzLCBleDEsIGV5MSwgZXgyLCBleTIpO1xuICAgICAgaWYgKHN0eWxlRW5hYmxlZCAmJiBvcHRpb25zLmluY2x1ZGVPdXRsaW5lcykge1xuICAgICAgICB1cGRhdGVCb3VuZHNGcm9tT3V0bGluZShib3VuZHMsIGVsZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc0VkZ2UgJiYgb3B0aW9ucy5pbmNsdWRlRWRnZXMpIHtcbiAgICAgIGlmIChzdHlsZUVuYWJsZWQgJiYgIWhlYWRsZXNzKSB7XG4gICAgICAgIHZhciBjdXJ2ZVN0eWxlID0gZWxlLnBzdHlsZSgnY3VydmUtc3R5bGUnKS5zdHJWYWx1ZTtcblxuICAgICAgICAvLyBoYW5kbGUgZWRnZSBkaW1lbnNpb25zIChyb3VnaCBib3ggZXN0aW1hdGUpXG4gICAgICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuICAgICAgICBleDEgPSBNYXRoLm1pbihyc3R5bGUuc3JjWCwgcnN0eWxlLm1pZFgsIHJzdHlsZS50Z3RYKTtcbiAgICAgICAgZXgyID0gTWF0aC5tYXgocnN0eWxlLnNyY1gsIHJzdHlsZS5taWRYLCByc3R5bGUudGd0WCk7XG4gICAgICAgIGV5MSA9IE1hdGgubWluKHJzdHlsZS5zcmNZLCByc3R5bGUubWlkWSwgcnN0eWxlLnRndFkpO1xuICAgICAgICBleTIgPSBNYXRoLm1heChyc3R5bGUuc3JjWSwgcnN0eWxlLm1pZFksIHJzdHlsZS50Z3RZKTtcblxuICAgICAgICAvLyB0YWtlIGludG8gYWNjb3VudCBlZGdlIHdpZHRoXG4gICAgICAgIGV4MSAtPSB3SGFsZjtcbiAgICAgICAgZXgyICs9IHdIYWxmO1xuICAgICAgICBleTEgLT0gd0hhbGY7XG4gICAgICAgIGV5MiArPSB3SGFsZjtcbiAgICAgICAgdXBkYXRlQm91bmRzKGJvdW5kcywgZXgxLCBleTEsIGV4MiwgZXkyKTtcblxuICAgICAgICAvLyBwcmVjaXNlIGVkZ2VzXG4gICAgICAgIC8vLy8vLy8vLy8vLy8vLy9cblxuICAgICAgICBpZiAoY3VydmVTdHlsZSA9PT0gJ2hheXN0YWNrJykge1xuICAgICAgICAgIHZhciBocHRzID0gcnN0eWxlLmhheXN0YWNrUHRzO1xuICAgICAgICAgIGlmIChocHRzICYmIGhwdHMubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICBleDEgPSBocHRzWzBdLng7XG4gICAgICAgICAgICBleTEgPSBocHRzWzBdLnk7XG4gICAgICAgICAgICBleDIgPSBocHRzWzFdLng7XG4gICAgICAgICAgICBleTIgPSBocHRzWzFdLnk7XG4gICAgICAgICAgICBpZiAoZXgxID4gZXgyKSB7XG4gICAgICAgICAgICAgIHZhciB0ZW1wID0gZXgxO1xuICAgICAgICAgICAgICBleDEgPSBleDI7XG4gICAgICAgICAgICAgIGV4MiA9IHRlbXA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZXkxID4gZXkyKSB7XG4gICAgICAgICAgICAgIHZhciBfdGVtcCA9IGV5MTtcbiAgICAgICAgICAgICAgZXkxID0gZXkyO1xuICAgICAgICAgICAgICBleTIgPSBfdGVtcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHVwZGF0ZUJvdW5kcyhib3VuZHMsIGV4MSAtIHdIYWxmLCBleTEgLSB3SGFsZiwgZXgyICsgd0hhbGYsIGV5MiArIHdIYWxmKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoY3VydmVTdHlsZSA9PT0gJ2JlemllcicgfHwgY3VydmVTdHlsZSA9PT0gJ3VuYnVuZGxlZC1iZXppZXInIHx8IGN1cnZlU3R5bGUuZW5kc1dpdGgoJ3NlZ21lbnRzJykgfHwgY3VydmVTdHlsZS5lbmRzV2l0aCgndGF4aScpKSB7XG4gICAgICAgICAgdmFyIHB0cztcbiAgICAgICAgICBzd2l0Y2ggKGN1cnZlU3R5bGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2Jlemllcic6XG4gICAgICAgICAgICBjYXNlICd1bmJ1bmRsZWQtYmV6aWVyJzpcbiAgICAgICAgICAgICAgcHRzID0gcnN0eWxlLmJlemllclB0cztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdzZWdtZW50cyc6XG4gICAgICAgICAgICBjYXNlICd0YXhpJzpcbiAgICAgICAgICAgIGNhc2UgJ3JvdW5kLXNlZ21lbnRzJzpcbiAgICAgICAgICAgIGNhc2UgJ3JvdW5kLXRheGknOlxuICAgICAgICAgICAgICBwdHMgPSByc3R5bGUubGluZVB0cztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwdHMgIT0gbnVsbCkge1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBwdHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgdmFyIHB0ID0gcHRzW2pdO1xuICAgICAgICAgICAgICBleDEgPSBwdC54IC0gd0hhbGY7XG4gICAgICAgICAgICAgIGV4MiA9IHB0LnggKyB3SGFsZjtcbiAgICAgICAgICAgICAgZXkxID0gcHQueSAtIHdIYWxmO1xuICAgICAgICAgICAgICBleTIgPSBwdC55ICsgd0hhbGY7XG4gICAgICAgICAgICAgIHVwZGF0ZUJvdW5kcyhib3VuZHMsIGV4MSwgZXkxLCBleDIsIGV5Mik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIGJlemllci1saWtlIG9yIHNlZ21lbnQtbGlrZSBlZGdlXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBoZWFkbGVzcyBvciBzdHlsZSBkaXNhYmxlZFxuXG4gICAgICAgIC8vIGZhbGxiYWNrIG9uIHNvdXJjZSBhbmQgdGFyZ2V0IHBvc2l0aW9uc1xuICAgICAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuICAgICAgICB2YXIgbjEgPSBlbGUuc291cmNlKCk7XG4gICAgICAgIHZhciBuMXBvcyA9IG4xLnBvc2l0aW9uKCk7XG4gICAgICAgIHZhciBuMiA9IGVsZS50YXJnZXQoKTtcbiAgICAgICAgdmFyIG4ycG9zID0gbjIucG9zaXRpb24oKTtcbiAgICAgICAgZXgxID0gbjFwb3MueDtcbiAgICAgICAgZXgyID0gbjJwb3MueDtcbiAgICAgICAgZXkxID0gbjFwb3MueTtcbiAgICAgICAgZXkyID0gbjJwb3MueTtcbiAgICAgICAgaWYgKGV4MSA+IGV4Mikge1xuICAgICAgICAgIHZhciBfdGVtcDIgPSBleDE7XG4gICAgICAgICAgZXgxID0gZXgyO1xuICAgICAgICAgIGV4MiA9IF90ZW1wMjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXkxID4gZXkyKSB7XG4gICAgICAgICAgdmFyIF90ZW1wMyA9IGV5MTtcbiAgICAgICAgICBleTEgPSBleTI7XG4gICAgICAgICAgZXkyID0gX3RlbXAzO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdGFrZSBpbnRvIGFjY291bnQgZWRnZSB3aWR0aFxuICAgICAgICBleDEgLT0gd0hhbGY7XG4gICAgICAgIGV4MiArPSB3SGFsZjtcbiAgICAgICAgZXkxIC09IHdIYWxmO1xuICAgICAgICBleTIgKz0gd0hhbGY7XG4gICAgICAgIHVwZGF0ZUJvdW5kcyhib3VuZHMsIGV4MSwgZXkxLCBleDIsIGV5Mik7XG4gICAgICB9IC8vIGhlYWRsZXNzIG9yIHN0eWxlIGRpc2FibGVkXG4gICAgfSAvLyBlZGdlc1xuXG4gICAgLy8gaGFuZGxlIGVkZ2UgYXJyb3cgc2l6ZVxuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuICAgIGlmIChzdHlsZUVuYWJsZWQgJiYgb3B0aW9ucy5pbmNsdWRlRWRnZXMgJiYgaXNFZGdlKSB7XG4gICAgICB1cGRhdGVCb3VuZHNGcm9tQXJyb3coYm91bmRzLCBlbGUsICdtaWQtc291cmNlJyk7XG4gICAgICB1cGRhdGVCb3VuZHNGcm9tQXJyb3coYm91bmRzLCBlbGUsICdtaWQtdGFyZ2V0Jyk7XG4gICAgICB1cGRhdGVCb3VuZHNGcm9tQXJyb3coYm91bmRzLCBlbGUsICdzb3VyY2UnKTtcbiAgICAgIHVwZGF0ZUJvdW5kc0Zyb21BcnJvdyhib3VuZHMsIGVsZSwgJ3RhcmdldCcpO1xuICAgIH1cblxuICAgIC8vIGdob3N0XG4gICAgLy8vLy8vLy9cblxuICAgIGlmIChzdHlsZUVuYWJsZWQpIHtcbiAgICAgIHZhciBnaG9zdCA9IGVsZS5wc3R5bGUoJ2dob3N0JykudmFsdWUgPT09ICd5ZXMnO1xuICAgICAgaWYgKGdob3N0KSB7XG4gICAgICAgIHZhciBneCA9IGVsZS5wc3R5bGUoJ2dob3N0LW9mZnNldC14JykucGZWYWx1ZTtcbiAgICAgICAgdmFyIGd5ID0gZWxlLnBzdHlsZSgnZ2hvc3Qtb2Zmc2V0LXknKS5wZlZhbHVlO1xuICAgICAgICB1cGRhdGVCb3VuZHMoYm91bmRzLCBib3VuZHMueDEgKyBneCwgYm91bmRzLnkxICsgZ3ksIGJvdW5kcy54MiArIGd4LCBib3VuZHMueTIgKyBneSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gYWx3YXlzIHN0b3JlIHRoZSBib2R5IGJvdW5kcyBzZXBhcmF0ZWx5IGZyb20gdGhlIGxhYmVsc1xuICAgIHZhciBiYkJvZHkgPSBfcC5ib2R5Qm91bmRzID0gX3AuYm9keUJvdW5kcyB8fCB7fTtcbiAgICBhc3NpZ25Cb3VuZGluZ0JveChiYkJvZHksIGJvdW5kcyk7XG4gICAgZXhwYW5kQm91bmRpbmdCb3hTaWRlcyhiYkJvZHksIG1hbnVhbEV4cGFuc2lvbik7XG4gICAgZXhwYW5kQm91bmRpbmdCb3goYmJCb2R5LCAxKTsgLy8gZXhwYW5kIHRvIHdvcmsgYXJvdW5kIGJyb3dzZXIgZGltZW5zaW9uIGluYWNjdXJhY2llc1xuXG4gICAgLy8gb3ZlcmxheVxuICAgIC8vLy8vLy8vLy9cblxuICAgIGlmIChzdHlsZUVuYWJsZWQpIHtcbiAgICAgIGV4MSA9IGJvdW5kcy54MTtcbiAgICAgIGV4MiA9IGJvdW5kcy54MjtcbiAgICAgIGV5MSA9IGJvdW5kcy55MTtcbiAgICAgIGV5MiA9IGJvdW5kcy55MjtcbiAgICAgIHVwZGF0ZUJvdW5kcyhib3VuZHMsIGV4MSAtIHBhZGRpbmcsIGV5MSAtIHBhZGRpbmcsIGV4MiArIHBhZGRpbmcsIGV5MiArIHBhZGRpbmcpO1xuICAgIH1cblxuICAgIC8vIGFsd2F5cyBzdG9yZSB0aGUgYm9keSBib3VuZHMgc2VwYXJhdGVseSBmcm9tIHRoZSBsYWJlbHNcbiAgICB2YXIgYmJPdmVybGF5ID0gX3Aub3ZlcmxheUJvdW5kcyA9IF9wLm92ZXJsYXlCb3VuZHMgfHwge307XG4gICAgYXNzaWduQm91bmRpbmdCb3goYmJPdmVybGF5LCBib3VuZHMpO1xuICAgIGV4cGFuZEJvdW5kaW5nQm94U2lkZXMoYmJPdmVybGF5LCBtYW51YWxFeHBhbnNpb24pO1xuICAgIGV4cGFuZEJvdW5kaW5nQm94KGJiT3ZlcmxheSwgMSk7IC8vIGV4cGFuZCB0byB3b3JrIGFyb3VuZCBicm93c2VyIGRpbWVuc2lvbiBpbmFjY3VyYWNpZXNcblxuICAgIC8vIGhhbmRsZSBsYWJlbCBkaW1lbnNpb25zXG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuICAgIHZhciBiYkxhYmVscyA9IF9wLmxhYmVsQm91bmRzID0gX3AubGFiZWxCb3VuZHMgfHwge307XG4gICAgaWYgKGJiTGFiZWxzLmFsbCAhPSBudWxsKSB7XG4gICAgICBjbGVhckJvdW5kaW5nQm94KGJiTGFiZWxzLmFsbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJiTGFiZWxzLmFsbCA9IG1ha2VCb3VuZGluZ0JveCgpO1xuICAgIH1cbiAgICBpZiAoc3R5bGVFbmFibGVkICYmIG9wdGlvbnMuaW5jbHVkZUxhYmVscykge1xuICAgICAgaWYgKG9wdGlvbnMuaW5jbHVkZU1haW5MYWJlbHMpIHtcbiAgICAgICAgdXBkYXRlQm91bmRzRnJvbUxhYmVsKGJvdW5kcywgZWxlLCBudWxsKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0VkZ2UpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuaW5jbHVkZVNvdXJjZUxhYmVscykge1xuICAgICAgICAgIHVwZGF0ZUJvdW5kc0Zyb21MYWJlbChib3VuZHMsIGVsZSwgJ3NvdXJjZScpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmluY2x1ZGVUYXJnZXRMYWJlbHMpIHtcbiAgICAgICAgICB1cGRhdGVCb3VuZHNGcm9tTGFiZWwoYm91bmRzLCBlbGUsICd0YXJnZXQnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gLy8gc3R5bGUgZW5hYmxlZCBmb3IgbGFiZWxzXG4gIH0gLy8gaWYgZGlzcGxheWVkXG5cbiAgYm91bmRzLngxID0gbm9uaW5mKGJvdW5kcy54MSk7XG4gIGJvdW5kcy55MSA9IG5vbmluZihib3VuZHMueTEpO1xuICBib3VuZHMueDIgPSBub25pbmYoYm91bmRzLngyKTtcbiAgYm91bmRzLnkyID0gbm9uaW5mKGJvdW5kcy55Mik7XG4gIGJvdW5kcy53ID0gbm9uaW5mKGJvdW5kcy54MiAtIGJvdW5kcy54MSk7XG4gIGJvdW5kcy5oID0gbm9uaW5mKGJvdW5kcy55MiAtIGJvdW5kcy55MSk7XG4gIGlmIChib3VuZHMudyA+IDAgJiYgYm91bmRzLmggPiAwICYmIGRpc3BsYXllZCkge1xuICAgIGV4cGFuZEJvdW5kaW5nQm94U2lkZXMoYm91bmRzLCBtYW51YWxFeHBhbnNpb24pO1xuXG4gICAgLy8gZXhwYW5kIGJvdW5kcyBieSAxIGJlY2F1c2UgYW50aWFsaWFzaW5nIGNhbiBpbmNyZWFzZSB0aGUgdmlzdWFsL2VmZmVjdGl2ZSBzaXplIGJ5IDEgb24gYWxsIHNpZGVzXG4gICAgZXhwYW5kQm91bmRpbmdCb3goYm91bmRzLCAxKTtcbiAgfVxuICByZXR1cm4gYm91bmRzO1xufTtcbnZhciBnZXRLZXkgPSBmdW5jdGlvbiBnZXRLZXkob3B0cykge1xuICB2YXIgaSA9IDA7XG4gIHZhciB0ZiA9IGZ1bmN0aW9uIHRmKHZhbCkge1xuICAgIHJldHVybiAodmFsID8gMSA6IDApIDw8IGkrKztcbiAgfTtcbiAgdmFyIGtleSA9IDA7XG4gIGtleSArPSB0ZihvcHRzLmluY3VkZU5vZGVzKTtcbiAga2V5ICs9IHRmKG9wdHMuaW5jbHVkZUVkZ2VzKTtcbiAga2V5ICs9IHRmKG9wdHMuaW5jbHVkZUxhYmVscyk7XG4gIGtleSArPSB0ZihvcHRzLmluY2x1ZGVNYWluTGFiZWxzKTtcbiAga2V5ICs9IHRmKG9wdHMuaW5jbHVkZVNvdXJjZUxhYmVscyk7XG4gIGtleSArPSB0ZihvcHRzLmluY2x1ZGVUYXJnZXRMYWJlbHMpO1xuICBrZXkgKz0gdGYob3B0cy5pbmNsdWRlT3ZlcmxheXMpO1xuICBrZXkgKz0gdGYob3B0cy5pbmNsdWRlT3V0bGluZXMpO1xuICByZXR1cm4ga2V5O1xufTtcbnZhciBnZXRCb3VuZGluZ0JveFBvc0tleSA9IGZ1bmN0aW9uIGdldEJvdW5kaW5nQm94UG9zS2V5KGVsZSkge1xuICBpZiAoZWxlLmlzRWRnZSgpKSB7XG4gICAgdmFyIHAxID0gZWxlLnNvdXJjZSgpLnBvc2l0aW9uKCk7XG4gICAgdmFyIHAyID0gZWxlLnRhcmdldCgpLnBvc2l0aW9uKCk7XG4gICAgdmFyIHIgPSBmdW5jdGlvbiByKHgpIHtcbiAgICAgIHJldHVybiBNYXRoLnJvdW5kKHgpO1xuICAgIH07XG4gICAgcmV0dXJuIGhhc2hJbnRzQXJyYXkoW3IocDEueCksIHIocDEueSksIHIocDIueCksIHIocDIueSldKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gMDtcbiAgfVxufTtcbnZhciBjYWNoZWRCb3VuZGluZ0JveEltcGwgPSBmdW5jdGlvbiBjYWNoZWRCb3VuZGluZ0JveEltcGwoZWxlLCBvcHRzKSB7XG4gIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgdmFyIGJiO1xuICB2YXIgaXNFZGdlID0gZWxlLmlzRWRnZSgpO1xuICB2YXIga2V5ID0gb3B0cyA9PSBudWxsID8gZGVmQmJPcHRzS2V5IDogZ2V0S2V5KG9wdHMpO1xuICB2YXIgdXNpbmdEZWZPcHRzID0ga2V5ID09PSBkZWZCYk9wdHNLZXk7XG4gIHZhciBjdXJyUG9zS2V5ID0gZ2V0Qm91bmRpbmdCb3hQb3NLZXkoZWxlKTtcbiAgdmFyIGlzUG9zS2V5U2FtZSA9IF9wLmJiQ2FjaGVQb3NLZXkgPT09IGN1cnJQb3NLZXk7XG4gIHZhciB1c2VDYWNoZSA9IG9wdHMudXNlQ2FjaGUgJiYgaXNQb3NLZXlTYW1lO1xuICB2YXIgaXNEaXJ0eSA9IGZ1bmN0aW9uIGlzRGlydHkoZWxlKSB7XG4gICAgcmV0dXJuIGVsZS5fcHJpdmF0ZS5iYkNhY2hlID09IG51bGwgfHwgZWxlLl9wcml2YXRlLnN0eWxlRGlydHk7XG4gIH07XG4gIHZhciBuZWVkUmVjYWxjID0gIXVzZUNhY2hlIHx8IGlzRGlydHkoZWxlKSB8fCBpc0VkZ2UgJiYgKGlzRGlydHkoZWxlLnNvdXJjZSgpKSB8fCBpc0RpcnR5KGVsZS50YXJnZXQoKSkpO1xuICBpZiAobmVlZFJlY2FsYykge1xuICAgIGlmICghaXNQb3NLZXlTYW1lKSB7XG4gICAgICBlbGUucmVjYWxjdWxhdGVSZW5kZXJlZFN0eWxlKHVzZUNhY2hlKTtcbiAgICB9XG4gICAgYmIgPSBib3VuZGluZ0JveEltcGwoZWxlLCBkZWZCYk9wdHMpO1xuICAgIF9wLmJiQ2FjaGUgPSBiYjtcbiAgICBfcC5iYkNhY2hlUG9zS2V5ID0gY3VyclBvc0tleTtcbiAgfSBlbHNlIHtcbiAgICBiYiA9IF9wLmJiQ2FjaGU7XG4gIH1cblxuICAvLyBub3QgdXNpbmcgZGVmIG9wdHMgPT4gbmVlZCB0byBidWlsZCB1cCBiYiBmcm9tIGNvbWJpbmF0aW9uIG9mIHN1YiBiYnNcbiAgaWYgKCF1c2luZ0RlZk9wdHMpIHtcbiAgICB2YXIgaXNOb2RlID0gZWxlLmlzTm9kZSgpO1xuICAgIGJiID0gbWFrZUJvdW5kaW5nQm94KCk7XG4gICAgaWYgKG9wdHMuaW5jbHVkZU5vZGVzICYmIGlzTm9kZSB8fCBvcHRzLmluY2x1ZGVFZGdlcyAmJiAhaXNOb2RlKSB7XG4gICAgICBpZiAob3B0cy5pbmNsdWRlT3ZlcmxheXMpIHtcbiAgICAgICAgdXBkYXRlQm91bmRzRnJvbUJveChiYiwgX3Aub3ZlcmxheUJvdW5kcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB1cGRhdGVCb3VuZHNGcm9tQm94KGJiLCBfcC5ib2R5Qm91bmRzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9wdHMuaW5jbHVkZUxhYmVscykge1xuICAgICAgaWYgKG9wdHMuaW5jbHVkZU1haW5MYWJlbHMgJiYgKCFpc0VkZ2UgfHwgb3B0cy5pbmNsdWRlU291cmNlTGFiZWxzICYmIG9wdHMuaW5jbHVkZVRhcmdldExhYmVscykpIHtcbiAgICAgICAgdXBkYXRlQm91bmRzRnJvbUJveChiYiwgX3AubGFiZWxCb3VuZHMuYWxsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChvcHRzLmluY2x1ZGVNYWluTGFiZWxzKSB7XG4gICAgICAgICAgdXBkYXRlQm91bmRzRnJvbUJveChiYiwgX3AubGFiZWxCb3VuZHMubWFpblJvdCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdHMuaW5jbHVkZVNvdXJjZUxhYmVscykge1xuICAgICAgICAgIHVwZGF0ZUJvdW5kc0Zyb21Cb3goYmIsIF9wLmxhYmVsQm91bmRzLnNvdXJjZVJvdCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdHMuaW5jbHVkZVRhcmdldExhYmVscykge1xuICAgICAgICAgIHVwZGF0ZUJvdW5kc0Zyb21Cb3goYmIsIF9wLmxhYmVsQm91bmRzLnRhcmdldFJvdCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgYmIudyA9IGJiLngyIC0gYmIueDE7XG4gICAgYmIuaCA9IGJiLnkyIC0gYmIueTE7XG4gIH1cbiAgcmV0dXJuIGJiO1xufTtcbnZhciBkZWZCYk9wdHMgPSB7XG4gIGluY2x1ZGVOb2RlczogdHJ1ZSxcbiAgaW5jbHVkZUVkZ2VzOiB0cnVlLFxuICBpbmNsdWRlTGFiZWxzOiB0cnVlLFxuICBpbmNsdWRlTWFpbkxhYmVsczogdHJ1ZSxcbiAgaW5jbHVkZVNvdXJjZUxhYmVsczogdHJ1ZSxcbiAgaW5jbHVkZVRhcmdldExhYmVsczogdHJ1ZSxcbiAgaW5jbHVkZU92ZXJsYXlzOiB0cnVlLFxuICBpbmNsdWRlVW5kZXJsYXlzOiB0cnVlLFxuICBpbmNsdWRlT3V0bGluZXM6IHRydWUsXG4gIHVzZUNhY2hlOiB0cnVlXG59O1xudmFyIGRlZkJiT3B0c0tleSA9IGdldEtleShkZWZCYk9wdHMpO1xudmFyIGZpbGxlZEJiT3B0cyA9IGRlZmF1bHRzJGcoZGVmQmJPcHRzKTtcbmVsZXNmbiRiLmJvdW5kaW5nQm94ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgdmFyIGJvdW5kcztcblxuICAvLyB0aGUgbWFpbiB1c2VjYXNlIGlzIGVsZS5ib3VuZGluZ0JveCgpIGZvciBhIHNpbmdsZSBlbGVtZW50IHdpdGggbm8vZGVmIG9wdGlvbnNcbiAgLy8gc3BlY2lmaWVkIHMudC4gdGhlIGNhY2hlIGlzIHVzZWQsIHNvIGNoZWNrIGZvciB0aGlzIGNhc2UgdG8gbWFrZSBpdCBmYXN0ZXIgYnlcbiAgLy8gYXZvaWRpbmcgdGhlIG92ZXJoZWFkIG9mIHRoZSByZXN0IG9mIHRoZSBmdW5jdGlvblxuICBpZiAodGhpcy5sZW5ndGggPT09IDEgJiYgdGhpc1swXS5fcHJpdmF0ZS5iYkNhY2hlICE9IG51bGwgJiYgIXRoaXNbMF0uX3ByaXZhdGUuc3R5bGVEaXJ0eSAmJiAob3B0aW9ucyA9PT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMudXNlQ2FjaGUgPT09IHVuZGVmaW5lZCB8fCBvcHRpb25zLnVzZUNhY2hlID09PSB0cnVlKSkge1xuICAgIGlmIChvcHRpb25zID09PSB1bmRlZmluZWQpIHtcbiAgICAgIG9wdGlvbnMgPSBkZWZCYk9wdHM7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9wdGlvbnMgPSBmaWxsZWRCYk9wdHMob3B0aW9ucyk7XG4gICAgfVxuICAgIGJvdW5kcyA9IGNhY2hlZEJvdW5kaW5nQm94SW1wbCh0aGlzWzBdLCBvcHRpb25zKTtcbiAgfSBlbHNlIHtcbiAgICBib3VuZHMgPSBtYWtlQm91bmRpbmdCb3goKTtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCBkZWZCYk9wdHM7XG4gICAgdmFyIG9wdHMgPSBmaWxsZWRCYk9wdHMob3B0aW9ucyk7XG4gICAgdmFyIGVsZXMgPSB0aGlzO1xuICAgIHZhciBjeSA9IGVsZXMuY3koKTtcbiAgICB2YXIgc3R5bGVFbmFibGVkID0gY3kuc3R5bGVFbmFibGVkKCk7XG4gICAgaWYgKHN0eWxlRW5hYmxlZCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlbGUgPSBlbGVzW2ldO1xuICAgICAgICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gICAgICAgIHZhciBjdXJyUG9zS2V5ID0gZ2V0Qm91bmRpbmdCb3hQb3NLZXkoZWxlKTtcbiAgICAgICAgdmFyIGlzUG9zS2V5U2FtZSA9IF9wLmJiQ2FjaGVQb3NLZXkgPT09IGN1cnJQb3NLZXk7XG4gICAgICAgIHZhciB1c2VDYWNoZSA9IG9wdHMudXNlQ2FjaGUgJiYgaXNQb3NLZXlTYW1lICYmICFfcC5zdHlsZURpcnR5O1xuICAgICAgICBlbGUucmVjYWxjdWxhdGVSZW5kZXJlZFN0eWxlKHVzZUNhY2hlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy51cGRhdGVDb21wb3VuZEJvdW5kcyghb3B0aW9ucy51c2VDYWNoZSk7XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGVsZXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICB2YXIgX2VsZSA9IGVsZXNbX2ldO1xuICAgICAgdXBkYXRlQm91bmRzRnJvbUJveChib3VuZHMsIGNhY2hlZEJvdW5kaW5nQm94SW1wbChfZWxlLCBvcHRzKSk7XG4gICAgfVxuICB9XG4gIGJvdW5kcy54MSA9IG5vbmluZihib3VuZHMueDEpO1xuICBib3VuZHMueTEgPSBub25pbmYoYm91bmRzLnkxKTtcbiAgYm91bmRzLngyID0gbm9uaW5mKGJvdW5kcy54Mik7XG4gIGJvdW5kcy55MiA9IG5vbmluZihib3VuZHMueTIpO1xuICBib3VuZHMudyA9IG5vbmluZihib3VuZHMueDIgLSBib3VuZHMueDEpO1xuICBib3VuZHMuaCA9IG5vbmluZihib3VuZHMueTIgLSBib3VuZHMueTEpO1xuICByZXR1cm4gYm91bmRzO1xufTtcbmVsZXNmbiRiLmRpcnR5Qm91bmRpbmdCb3hDYWNoZSA9IGZ1bmN0aW9uICgpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIF9wID0gdGhpc1tpXS5fcHJpdmF0ZTtcbiAgICBfcC5iYkNhY2hlID0gbnVsbDtcbiAgICBfcC5iYkNhY2hlUG9zS2V5ID0gbnVsbDtcbiAgICBfcC5ib2R5Qm91bmRzID0gbnVsbDtcbiAgICBfcC5vdmVybGF5Qm91bmRzID0gbnVsbDtcbiAgICBfcC5sYWJlbEJvdW5kcy5hbGwgPSBudWxsO1xuICAgIF9wLmxhYmVsQm91bmRzLnNvdXJjZSA9IG51bGw7XG4gICAgX3AubGFiZWxCb3VuZHMudGFyZ2V0ID0gbnVsbDtcbiAgICBfcC5sYWJlbEJvdW5kcy5tYWluID0gbnVsbDtcbiAgICBfcC5sYWJlbEJvdW5kcy5zb3VyY2VSb3QgPSBudWxsO1xuICAgIF9wLmxhYmVsQm91bmRzLnRhcmdldFJvdCA9IG51bGw7XG4gICAgX3AubGFiZWxCb3VuZHMubWFpblJvdCA9IG51bGw7XG4gICAgX3AuYXJyb3dCb3VuZHMuc291cmNlID0gbnVsbDtcbiAgICBfcC5hcnJvd0JvdW5kcy50YXJnZXQgPSBudWxsO1xuICAgIF9wLmFycm93Qm91bmRzWydtaWQtc291cmNlJ10gPSBudWxsO1xuICAgIF9wLmFycm93Qm91bmRzWydtaWQtdGFyZ2V0J10gPSBudWxsO1xuICB9XG4gIHRoaXMuZW1pdEFuZE5vdGlmeSgnYm91bmRzJyk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gcHJpdmF0ZSBoZWxwZXIgdG8gZ2V0IGJvdW5kaW5nIGJveCBmb3IgY3VzdG9tIG5vZGUgcG9zaXRpb25zXG4vLyAtIGdvb2QgZm9yIHBlcmYgaW4gY2VydGFpbiBjYXNlcyBidXQgY3VycmVudGx5IHJlcXVpcmVzIGRpcnR5aW5nIHRoZSByZW5kZXJlZCBzdHlsZVxuLy8gLSB3b3VsZCBiZSBiZXR0ZXIgdG8gbm90IG1vZGlmeSB0aGUgbm9kZXMgYnV0IHRoZSBub2RlcyBhcmUgcmVhZCBkaXJlY3RseSBldmVyeXdoZXJlIGluIHRoZSByZW5kZXJlci4uLlxuLy8gLSB0cnkgdG8gdXNlIGZvciBvbmx5IHRoaW5ncyBsaWtlIGRpc2NyZXRlIGxheW91dHMgd2hlcmUgdGhlIG5vZGUgcG9zaXRpb24gd291bGQgY2hhbmdlIGFueXdheVxuZWxlc2ZuJGIuYm91bmRpbmdCb3hBdCA9IGZ1bmN0aW9uIChmbikge1xuICB2YXIgbm9kZXMgPSB0aGlzLm5vZGVzKCk7XG4gIHZhciBjeSA9IHRoaXMuY3koKTtcbiAgdmFyIGhhc0NvbXBvdW5kTm9kZXMgPSBjeS5oYXNDb21wb3VuZE5vZGVzKCk7XG4gIHZhciBwYXJlbnRzID0gY3kuY29sbGVjdGlvbigpO1xuICBpZiAoaGFzQ29tcG91bmROb2Rlcykge1xuICAgIHBhcmVudHMgPSBub2Rlcy5maWx0ZXIoZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgIHJldHVybiBub2RlLmlzUGFyZW50KCk7XG4gICAgfSk7XG4gICAgbm9kZXMgPSBub2Rlcy5ub3QocGFyZW50cyk7XG4gIH1cbiAgaWYgKHBsYWluT2JqZWN0KGZuKSkge1xuICAgIHZhciBvYmogPSBmbjtcbiAgICBmbiA9IGZ1bmN0aW9uIGZuKCkge1xuICAgICAgcmV0dXJuIG9iajtcbiAgICB9O1xuICB9XG4gIHZhciBzdG9yZU9sZFBvcyA9IGZ1bmN0aW9uIHN0b3JlT2xkUG9zKG5vZGUsIGkpIHtcbiAgICByZXR1cm4gbm9kZS5fcHJpdmF0ZS5iYkF0T2xkUG9zID0gZm4obm9kZSwgaSk7XG4gIH07XG4gIHZhciBnZXRPbGRQb3MgPSBmdW5jdGlvbiBnZXRPbGRQb3Mobm9kZSkge1xuICAgIHJldHVybiBub2RlLl9wcml2YXRlLmJiQXRPbGRQb3M7XG4gIH07XG4gIGN5LnN0YXJ0QmF0Y2goKTtcbiAgbm9kZXMuZm9yRWFjaChzdG9yZU9sZFBvcykuc2lsZW50UG9zaXRpb25zKGZuKTtcbiAgaWYgKGhhc0NvbXBvdW5kTm9kZXMpIHtcbiAgICBwYXJlbnRzLmRpcnR5Q29tcG91bmRCb3VuZHNDYWNoZSgpO1xuICAgIHBhcmVudHMuZGlydHlCb3VuZGluZ0JveENhY2hlKCk7XG4gICAgcGFyZW50cy51cGRhdGVDb21wb3VuZEJvdW5kcyh0cnVlKTsgLy8gZm9yY2UgdXBkYXRlIGIvYyB3ZSdyZSBpbnNpZGUgYSBiYXRjaCBjeWNsZVxuICB9XG5cbiAgdmFyIGJiID0gY29weUJvdW5kaW5nQm94KHRoaXMuYm91bmRpbmdCb3goe1xuICAgIHVzZUNhY2hlOiBmYWxzZVxuICB9KSk7XG4gIG5vZGVzLnNpbGVudFBvc2l0aW9ucyhnZXRPbGRQb3MpO1xuICBpZiAoaGFzQ29tcG91bmROb2Rlcykge1xuICAgIHBhcmVudHMuZGlydHlDb21wb3VuZEJvdW5kc0NhY2hlKCk7XG4gICAgcGFyZW50cy5kaXJ0eUJvdW5kaW5nQm94Q2FjaGUoKTtcbiAgICBwYXJlbnRzLnVwZGF0ZUNvbXBvdW5kQm91bmRzKHRydWUpOyAvLyBmb3JjZSB1cGRhdGUgYi9jIHdlJ3JlIGluc2lkZSBhIGJhdGNoIGN5Y2xlXG4gIH1cblxuICBjeS5lbmRCYXRjaCgpO1xuICByZXR1cm4gYmI7XG59O1xuZm4kMy5ib3VuZGluZ2JveCA9IGZuJDMuYmIgPSBmbiQzLmJvdW5kaW5nQm94O1xuZm4kMy5yZW5kZXJlZEJvdW5kaW5nYm94ID0gZm4kMy5yZW5kZXJlZEJvdW5kaW5nQm94O1xudmFyIGJvdW5kcyA9IGVsZXNmbiRiO1xuXG52YXIgZm4kMiwgZWxlc2ZuJGE7XG5mbiQyID0gZWxlc2ZuJGEgPSB7fTtcbnZhciBkZWZpbmVEaW1GbnMgPSBmdW5jdGlvbiBkZWZpbmVEaW1GbnMob3B0cykge1xuICBvcHRzLnVwcGVyY2FzZU5hbWUgPSBjYXBpdGFsaXplKG9wdHMubmFtZSk7XG4gIG9wdHMuYXV0b05hbWUgPSAnYXV0bycgKyBvcHRzLnVwcGVyY2FzZU5hbWU7XG4gIG9wdHMubGFiZWxOYW1lID0gJ2xhYmVsJyArIG9wdHMudXBwZXJjYXNlTmFtZTtcbiAgb3B0cy5vdXRlck5hbWUgPSAnb3V0ZXInICsgb3B0cy51cHBlcmNhc2VOYW1lO1xuICBvcHRzLnVwcGVyY2FzZU91dGVyTmFtZSA9IGNhcGl0YWxpemUob3B0cy5vdXRlck5hbWUpO1xuICBmbiQyW29wdHMubmFtZV0gPSBmdW5jdGlvbiBkaW1JbXBsKCkge1xuICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuICAgIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgICB2YXIgY3kgPSBfcC5jeTtcbiAgICB2YXIgc3R5bGVFbmFibGVkID0gY3kuX3ByaXZhdGUuc3R5bGVFbmFibGVkO1xuICAgIGlmIChlbGUpIHtcbiAgICAgIGlmIChzdHlsZUVuYWJsZWQpIHtcbiAgICAgICAgaWYgKGVsZS5pc1BhcmVudCgpKSB7XG4gICAgICAgICAgZWxlLnVwZGF0ZUNvbXBvdW5kQm91bmRzKCk7XG4gICAgICAgICAgcmV0dXJuIF9wW29wdHMuYXV0b05hbWVdIHx8IDA7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGQgPSBlbGUucHN0eWxlKG9wdHMubmFtZSk7XG4gICAgICAgIHN3aXRjaCAoZC5zdHJWYWx1ZSkge1xuICAgICAgICAgIGNhc2UgJ2xhYmVsJzpcbiAgICAgICAgICAgIGVsZS5yZWNhbGN1bGF0ZVJlbmRlcmVkU3R5bGUoKTtcbiAgICAgICAgICAgIHJldHVybiBfcC5yc3R5bGVbb3B0cy5sYWJlbE5hbWVdIHx8IDA7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBkLnBmVmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgZm4kMlsnb3V0ZXInICsgb3B0cy51cHBlcmNhc2VOYW1lXSA9IGZ1bmN0aW9uIG91dGVyRGltSW1wbCgpIHtcbiAgICB2YXIgZWxlID0gdGhpc1swXTtcbiAgICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gICAgdmFyIGN5ID0gX3AuY3k7XG4gICAgdmFyIHN0eWxlRW5hYmxlZCA9IGN5Ll9wcml2YXRlLnN0eWxlRW5hYmxlZDtcbiAgICBpZiAoZWxlKSB7XG4gICAgICBpZiAoc3R5bGVFbmFibGVkKSB7XG4gICAgICAgIHZhciBkaW0gPSBlbGVbb3B0cy5uYW1lXSgpO1xuICAgICAgICB2YXIgYm9yZGVyID0gZWxlLnBzdHlsZSgnYm9yZGVyLXdpZHRoJykucGZWYWx1ZTsgLy8gbi5iLiAxLzIgZWFjaCBzaWRlXG4gICAgICAgIHZhciBwYWRkaW5nID0gMiAqIGVsZS5wYWRkaW5nKCk7XG4gICAgICAgIHJldHVybiBkaW0gKyBib3JkZXIgKyBwYWRkaW5nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBmbiQyWydyZW5kZXJlZCcgKyBvcHRzLnVwcGVyY2FzZU5hbWVdID0gZnVuY3Rpb24gcmVuZGVyZWREaW1JbXBsKCkge1xuICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuICAgIGlmIChlbGUpIHtcbiAgICAgIHZhciBkID0gZWxlW29wdHMubmFtZV0oKTtcbiAgICAgIHJldHVybiBkICogdGhpcy5jeSgpLnpvb20oKTtcbiAgICB9XG4gIH07XG4gIGZuJDJbJ3JlbmRlcmVkJyArIG9wdHMudXBwZXJjYXNlT3V0ZXJOYW1lXSA9IGZ1bmN0aW9uIHJlbmRlcmVkT3V0ZXJEaW1JbXBsKCkge1xuICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuICAgIGlmIChlbGUpIHtcbiAgICAgIHZhciBvZCA9IGVsZVtvcHRzLm91dGVyTmFtZV0oKTtcbiAgICAgIHJldHVybiBvZCAqIHRoaXMuY3koKS56b29tKCk7XG4gICAgfVxuICB9O1xufTtcbmRlZmluZURpbUZucyh7XG4gIG5hbWU6ICd3aWR0aCdcbn0pO1xuZGVmaW5lRGltRm5zKHtcbiAgbmFtZTogJ2hlaWdodCdcbn0pO1xuZWxlc2ZuJGEucGFkZGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGVsZSA9IHRoaXNbMF07XG4gIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgaWYgKGVsZS5pc1BhcmVudCgpKSB7XG4gICAgZWxlLnVwZGF0ZUNvbXBvdW5kQm91bmRzKCk7XG4gICAgaWYgKF9wLmF1dG9QYWRkaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBfcC5hdXRvUGFkZGluZztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGVsZS5wc3R5bGUoJ3BhZGRpbmcnKS5wZlZhbHVlO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZWxlLnBzdHlsZSgncGFkZGluZycpLnBmVmFsdWU7XG4gIH1cbn07XG5lbGVzZm4kYS5wYWRkZWRIZWlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBlbGUgPSB0aGlzWzBdO1xuICByZXR1cm4gZWxlLmhlaWdodCgpICsgMiAqIGVsZS5wYWRkaW5nKCk7XG59O1xuZWxlc2ZuJGEucGFkZGVkV2lkdGggPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBlbGUgPSB0aGlzWzBdO1xuICByZXR1cm4gZWxlLndpZHRoKCkgKyAyICogZWxlLnBhZGRpbmcoKTtcbn07XG52YXIgd2lkdGhIZWlnaHQgPSBlbGVzZm4kYTtcblxudmFyIGlmRWRnZSA9IGZ1bmN0aW9uIGlmRWRnZShlbGUsIGdldFZhbHVlKSB7XG4gIGlmIChlbGUuaXNFZGdlKCkpIHtcbiAgICByZXR1cm4gZ2V0VmFsdWUoZWxlKTtcbiAgfVxufTtcbnZhciBpZkVkZ2VSZW5kZXJlZFBvc2l0aW9uID0gZnVuY3Rpb24gaWZFZGdlUmVuZGVyZWRQb3NpdGlvbihlbGUsIGdldFBvaW50KSB7XG4gIGlmIChlbGUuaXNFZGdlKCkpIHtcbiAgICB2YXIgY3kgPSBlbGUuY3koKTtcbiAgICByZXR1cm4gbW9kZWxUb1JlbmRlcmVkUG9zaXRpb24oZ2V0UG9pbnQoZWxlKSwgY3kuem9vbSgpLCBjeS5wYW4oKSk7XG4gIH1cbn07XG52YXIgaWZFZGdlUmVuZGVyZWRQb3NpdGlvbnMgPSBmdW5jdGlvbiBpZkVkZ2VSZW5kZXJlZFBvc2l0aW9ucyhlbGUsIGdldFBvaW50cykge1xuICBpZiAoZWxlLmlzRWRnZSgpKSB7XG4gICAgdmFyIGN5ID0gZWxlLmN5KCk7XG4gICAgdmFyIHBhbiA9IGN5LnBhbigpO1xuICAgIHZhciB6b29tID0gY3kuem9vbSgpO1xuICAgIHJldHVybiBnZXRQb2ludHMoZWxlKS5tYXAoZnVuY3Rpb24gKHApIHtcbiAgICAgIHJldHVybiBtb2RlbFRvUmVuZGVyZWRQb3NpdGlvbihwLCB6b29tLCBwYW4pO1xuICAgIH0pO1xuICB9XG59O1xudmFyIGNvbnRyb2xQb2ludHMgPSBmdW5jdGlvbiBjb250cm9sUG9pbnRzKGVsZSkge1xuICByZXR1cm4gZWxlLnJlbmRlcmVyKCkuZ2V0Q29udHJvbFBvaW50cyhlbGUpO1xufTtcbnZhciBzZWdtZW50UG9pbnRzID0gZnVuY3Rpb24gc2VnbWVudFBvaW50cyhlbGUpIHtcbiAgcmV0dXJuIGVsZS5yZW5kZXJlcigpLmdldFNlZ21lbnRQb2ludHMoZWxlKTtcbn07XG52YXIgc291cmNlRW5kcG9pbnQgPSBmdW5jdGlvbiBzb3VyY2VFbmRwb2ludChlbGUpIHtcbiAgcmV0dXJuIGVsZS5yZW5kZXJlcigpLmdldFNvdXJjZUVuZHBvaW50KGVsZSk7XG59O1xudmFyIHRhcmdldEVuZHBvaW50ID0gZnVuY3Rpb24gdGFyZ2V0RW5kcG9pbnQoZWxlKSB7XG4gIHJldHVybiBlbGUucmVuZGVyZXIoKS5nZXRUYXJnZXRFbmRwb2ludChlbGUpO1xufTtcbnZhciBtaWRwb2ludCA9IGZ1bmN0aW9uIG1pZHBvaW50KGVsZSkge1xuICByZXR1cm4gZWxlLnJlbmRlcmVyKCkuZ2V0RWRnZU1pZHBvaW50KGVsZSk7XG59O1xudmFyIHB0cyA9IHtcbiAgY29udHJvbFBvaW50czoge1xuICAgIGdldDogY29udHJvbFBvaW50cyxcbiAgICBtdWx0OiB0cnVlXG4gIH0sXG4gIHNlZ21lbnRQb2ludHM6IHtcbiAgICBnZXQ6IHNlZ21lbnRQb2ludHMsXG4gICAgbXVsdDogdHJ1ZVxuICB9LFxuICBzb3VyY2VFbmRwb2ludDoge1xuICAgIGdldDogc291cmNlRW5kcG9pbnRcbiAgfSxcbiAgdGFyZ2V0RW5kcG9pbnQ6IHtcbiAgICBnZXQ6IHRhcmdldEVuZHBvaW50XG4gIH0sXG4gIG1pZHBvaW50OiB7XG4gICAgZ2V0OiBtaWRwb2ludFxuICB9XG59O1xudmFyIHJlbmRlcmVkTmFtZSA9IGZ1bmN0aW9uIHJlbmRlcmVkTmFtZShuYW1lKSB7XG4gIHJldHVybiAncmVuZGVyZWQnICsgbmFtZVswXS50b1VwcGVyQ2FzZSgpICsgbmFtZS5zdWJzdHIoMSk7XG59O1xudmFyIGVkZ2VQb2ludHMgPSBPYmplY3Qua2V5cyhwdHMpLnJlZHVjZShmdW5jdGlvbiAob2JqLCBuYW1lKSB7XG4gIHZhciBzcGVjID0gcHRzW25hbWVdO1xuICB2YXIgck5hbWUgPSByZW5kZXJlZE5hbWUobmFtZSk7XG4gIG9ialtuYW1lXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gaWZFZGdlKHRoaXMsIHNwZWMuZ2V0KTtcbiAgfTtcbiAgaWYgKHNwZWMubXVsdCkge1xuICAgIG9ialtyTmFtZV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gaWZFZGdlUmVuZGVyZWRQb3NpdGlvbnModGhpcywgc3BlYy5nZXQpO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgb2JqW3JOYW1lXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBpZkVkZ2VSZW5kZXJlZFBvc2l0aW9uKHRoaXMsIHNwZWMuZ2V0KTtcbiAgICB9O1xuICB9XG4gIHJldHVybiBvYmo7XG59LCB7fSk7XG5cbnZhciBkaW1lbnNpb25zID0gZXh0ZW5kKHt9LCBwb3NpdGlvbiwgYm91bmRzLCB3aWR0aEhlaWdodCwgZWRnZVBvaW50cyk7XG5cbi8qIVxuRXZlbnQgb2JqZWN0IGJhc2VkIG9uIGpRdWVyeSBldmVudHMsIE1JVCBsaWNlbnNlXG5cbmh0dHBzOi8vanF1ZXJ5Lm9yZy9saWNlbnNlL1xuaHR0cHM6Ly90bGRybGVnYWwuY29tL2xpY2Vuc2UvbWl0LWxpY2Vuc2Vcbmh0dHBzOi8vZ2l0aHViLmNvbS9qcXVlcnkvanF1ZXJ5L2Jsb2IvbWFzdGVyL3NyYy9ldmVudC5qc1xuKi9cblxudmFyIEV2ZW50ID0gZnVuY3Rpb24gRXZlbnQoc3JjLCBwcm9wcykge1xuICB0aGlzLnJlY3ljbGUoc3JjLCBwcm9wcyk7XG59O1xuZnVuY3Rpb24gcmV0dXJuRmFsc2UoKSB7XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIHJldHVyblRydWUoKSB7XG4gIHJldHVybiB0cnVlO1xufVxuXG4vLyBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDAzL1dELURPTS1MZXZlbC0zLUV2ZW50cy0yMDAzMDMzMS9lY21hLXNjcmlwdC1iaW5kaW5nLmh0bWxcbkV2ZW50LnByb3RvdHlwZSA9IHtcbiAgaW5zdGFuY2VTdHJpbmc6IGZ1bmN0aW9uIGluc3RhbmNlU3RyaW5nKCkge1xuICAgIHJldHVybiAnZXZlbnQnO1xuICB9LFxuICByZWN5Y2xlOiBmdW5jdGlvbiByZWN5Y2xlKHNyYywgcHJvcHMpIHtcbiAgICB0aGlzLmlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkID0gdGhpcy5pc1Byb3BhZ2F0aW9uU3RvcHBlZCA9IHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gcmV0dXJuRmFsc2U7XG4gICAgaWYgKHNyYyAhPSBudWxsICYmIHNyYy5wcmV2ZW50RGVmYXVsdCkge1xuICAgICAgLy8gQnJvd3NlciBFdmVudCBvYmplY3RcbiAgICAgIHRoaXMudHlwZSA9IHNyYy50eXBlO1xuXG4gICAgICAvLyBFdmVudHMgYnViYmxpbmcgdXAgdGhlIGRvY3VtZW50IG1heSBoYXZlIGJlZW4gbWFya2VkIGFzIHByZXZlbnRlZFxuICAgICAgLy8gYnkgYSBoYW5kbGVyIGxvd2VyIGRvd24gdGhlIHRyZWU7IHJlZmxlY3QgdGhlIGNvcnJlY3QgdmFsdWUuXG4gICAgICB0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IHNyYy5kZWZhdWx0UHJldmVudGVkID8gcmV0dXJuVHJ1ZSA6IHJldHVybkZhbHNlO1xuICAgIH0gZWxzZSBpZiAoc3JjICE9IG51bGwgJiYgc3JjLnR5cGUpIHtcbiAgICAgIC8vIFBsYWluIG9iamVjdCBjb250YWluaW5nIGFsbCBldmVudCBkZXRhaWxzXG4gICAgICBwcm9wcyA9IHNyYztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRXZlbnQgc3RyaW5nXG4gICAgICB0aGlzLnR5cGUgPSBzcmM7XG4gICAgfVxuXG4gICAgLy8gUHV0IGV4cGxpY2l0bHkgcHJvdmlkZWQgcHJvcGVydGllcyBvbnRvIHRoZSBldmVudCBvYmplY3RcbiAgICBpZiAocHJvcHMgIT0gbnVsbCkge1xuICAgICAgLy8gbW9yZSBlZmZpY2llbnQgdG8gbWFudWFsbHkgY29weSBmaWVsZHMgd2UgdXNlXG4gICAgICB0aGlzLm9yaWdpbmFsRXZlbnQgPSBwcm9wcy5vcmlnaW5hbEV2ZW50O1xuICAgICAgdGhpcy50eXBlID0gcHJvcHMudHlwZSAhPSBudWxsID8gcHJvcHMudHlwZSA6IHRoaXMudHlwZTtcbiAgICAgIHRoaXMuY3kgPSBwcm9wcy5jeTtcbiAgICAgIHRoaXMudGFyZ2V0ID0gcHJvcHMudGFyZ2V0O1xuICAgICAgdGhpcy5wb3NpdGlvbiA9IHByb3BzLnBvc2l0aW9uO1xuICAgICAgdGhpcy5yZW5kZXJlZFBvc2l0aW9uID0gcHJvcHMucmVuZGVyZWRQb3NpdGlvbjtcbiAgICAgIHRoaXMubmFtZXNwYWNlID0gcHJvcHMubmFtZXNwYWNlO1xuICAgICAgdGhpcy5sYXlvdXQgPSBwcm9wcy5sYXlvdXQ7XG4gICAgfVxuICAgIGlmICh0aGlzLmN5ICE9IG51bGwgJiYgdGhpcy5wb3NpdGlvbiAhPSBudWxsICYmIHRoaXMucmVuZGVyZWRQb3NpdGlvbiA9PSBudWxsKSB7XG4gICAgICAvLyBjcmVhdGUgYSByZW5kZXJlZCBwb3NpdGlvbiBiYXNlZCBvbiB0aGUgcGFzc2VkIHBvc2l0aW9uXG4gICAgICB2YXIgcG9zID0gdGhpcy5wb3NpdGlvbjtcbiAgICAgIHZhciB6b29tID0gdGhpcy5jeS56b29tKCk7XG4gICAgICB2YXIgcGFuID0gdGhpcy5jeS5wYW4oKTtcbiAgICAgIHRoaXMucmVuZGVyZWRQb3NpdGlvbiA9IHtcbiAgICAgICAgeDogcG9zLnggKiB6b29tICsgcGFuLngsXG4gICAgICAgIHk6IHBvcy55ICogem9vbSArIHBhbi55XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIENyZWF0ZSBhIHRpbWVzdGFtcCBpZiBpbmNvbWluZyBldmVudCBkb2Vzbid0IGhhdmUgb25lXG4gICAgdGhpcy50aW1lU3RhbXAgPSBzcmMgJiYgc3JjLnRpbWVTdGFtcCB8fCBEYXRlLm5vdygpO1xuICB9LFxuICBwcmV2ZW50RGVmYXVsdDogZnVuY3Rpb24gcHJldmVudERlZmF1bHQoKSB7XG4gICAgdGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSByZXR1cm5UcnVlO1xuICAgIHZhciBlID0gdGhpcy5vcmlnaW5hbEV2ZW50O1xuICAgIGlmICghZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGlmIHByZXZlbnREZWZhdWx0IGV4aXN0cyBydW4gaXQgb24gdGhlIG9yaWdpbmFsIGV2ZW50XG4gICAgaWYgKGUucHJldmVudERlZmF1bHQpIHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gIH0sXG4gIHN0b3BQcm9wYWdhdGlvbjogZnVuY3Rpb24gc3RvcFByb3BhZ2F0aW9uKCkge1xuICAgIHRoaXMuaXNQcm9wYWdhdGlvblN0b3BwZWQgPSByZXR1cm5UcnVlO1xuICAgIHZhciBlID0gdGhpcy5vcmlnaW5hbEV2ZW50O1xuICAgIGlmICghZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGlmIHN0b3BQcm9wYWdhdGlvbiBleGlzdHMgcnVuIGl0IG9uIHRoZSBvcmlnaW5hbCBldmVudFxuICAgIGlmIChlLnN0b3BQcm9wYWdhdGlvbikge1xuICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9XG4gIH0sXG4gIHN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbjogZnVuY3Rpb24gc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCkge1xuICAgIHRoaXMuaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQgPSByZXR1cm5UcnVlO1xuICAgIHRoaXMuc3RvcFByb3BhZ2F0aW9uKCk7XG4gIH0sXG4gIGlzRGVmYXVsdFByZXZlbnRlZDogcmV0dXJuRmFsc2UsXG4gIGlzUHJvcGFnYXRpb25TdG9wcGVkOiByZXR1cm5GYWxzZSxcbiAgaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQ6IHJldHVybkZhbHNlXG59O1xuXG52YXIgZXZlbnRSZWdleCA9IC9eKFteLl0rKShcXC4oPzpbXi5dKykpPyQvOyAvLyByZWdleCBmb3IgbWF0Y2hpbmcgZXZlbnQgc3RyaW5ncyAoZS5nLiBcImNsaWNrLm5hbWVzcGFjZVwiKVxudmFyIHVuaXZlcnNhbE5hbWVzcGFjZSA9ICcuKic7IC8vIG1hdGNoZXMgYXMgaWYgbm8gbmFtZXNwYWNlIHNwZWNpZmllZCBhbmQgcHJldmVudHMgdXNlcnMgZnJvbSB1bmJpbmRpbmcgYWNjaWRlbnRhbGx5XG5cbnZhciBkZWZhdWx0cyQ4ID0ge1xuICBxdWFsaWZpZXJDb21wYXJlOiBmdW5jdGlvbiBxdWFsaWZpZXJDb21wYXJlKHExLCBxMikge1xuICAgIHJldHVybiBxMSA9PT0gcTI7XG4gIH0sXG4gIGV2ZW50TWF0Y2hlczogZnVuY3Rpb24gZXZlbnRNYXRjaGVzKCAvKmNvbnRleHQsIGxpc3RlbmVyLCBldmVudE9iaiovXG4gICkge1xuICAgIHJldHVybiB0cnVlO1xuICB9LFxuICBhZGRFdmVudEZpZWxkczogZnVuY3Rpb24gYWRkRXZlbnRGaWVsZHMoIC8qY29udGV4dCwgZXZ0Ki9cbiAgKSB7fSxcbiAgY2FsbGJhY2tDb250ZXh0OiBmdW5jdGlvbiBjYWxsYmFja0NvbnRleHQoY29udGV4dCAvKiwgbGlzdGVuZXIsIGV2ZW50T2JqKi8pIHtcbiAgICByZXR1cm4gY29udGV4dDtcbiAgfSxcbiAgYmVmb3JlRW1pdDogZnVuY3Rpb24gYmVmb3JlRW1pdCggLyogY29udGV4dCwgbGlzdGVuZXIsIGV2ZW50T2JqICovXG4gICkge30sXG4gIGFmdGVyRW1pdDogZnVuY3Rpb24gYWZ0ZXJFbWl0KCAvKiBjb250ZXh0LCBsaXN0ZW5lciwgZXZlbnRPYmogKi9cbiAgKSB7fSxcbiAgYnViYmxlOiBmdW5jdGlvbiBidWJibGUoIC8qY29udGV4dCovXG4gICkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcbiAgcGFyZW50OiBmdW5jdGlvbiBwYXJlbnQoIC8qY29udGV4dCovXG4gICkge1xuICAgIHJldHVybiBudWxsO1xuICB9LFxuICBjb250ZXh0OiBudWxsXG59O1xudmFyIGRlZmF1bHRzS2V5cyA9IE9iamVjdC5rZXlzKGRlZmF1bHRzJDgpO1xudmFyIGVtcHR5T3B0cyA9IHt9O1xuZnVuY3Rpb24gRW1pdHRlcigpIHtcbiAgdmFyIG9wdHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IGVtcHR5T3B0cztcbiAgdmFyIGNvbnRleHQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZDtcbiAgLy8gbWljcm8tb3B0aW1pc2F0aW9uIHZzIE9iamVjdC5hc3NpZ24oKSAtLSByZWR1Y2VzIEVsZW1lbnQgaW5zdGFudGlhdGlvbiB0aW1lXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZGVmYXVsdHNLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGtleSA9IGRlZmF1bHRzS2V5c1tpXTtcbiAgICB0aGlzW2tleV0gPSBvcHRzW2tleV0gfHwgZGVmYXVsdHMkOFtrZXldO1xuICB9XG4gIHRoaXMuY29udGV4dCA9IGNvbnRleHQgfHwgdGhpcy5jb250ZXh0O1xuICB0aGlzLmxpc3RlbmVycyA9IFtdO1xuICB0aGlzLmVtaXR0aW5nID0gMDtcbn1cbnZhciBwID0gRW1pdHRlci5wcm90b3R5cGU7XG52YXIgZm9yRWFjaEV2ZW50ID0gZnVuY3Rpb24gZm9yRWFjaEV2ZW50KHNlbGYsIGhhbmRsZXIsIGV2ZW50cywgcXVhbGlmaWVyLCBjYWxsYmFjaywgY29uZiwgY29uZk92ZXJyaWRlcykge1xuICBpZiAoZm4kNihxdWFsaWZpZXIpKSB7XG4gICAgY2FsbGJhY2sgPSBxdWFsaWZpZXI7XG4gICAgcXVhbGlmaWVyID0gbnVsbDtcbiAgfVxuICBpZiAoY29uZk92ZXJyaWRlcykge1xuICAgIGlmIChjb25mID09IG51bGwpIHtcbiAgICAgIGNvbmYgPSBjb25mT3ZlcnJpZGVzO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25mID0gZXh0ZW5kKHt9LCBjb25mLCBjb25mT3ZlcnJpZGVzKTtcbiAgICB9XG4gIH1cbiAgdmFyIGV2ZW50TGlzdCA9IGFycmF5KGV2ZW50cykgPyBldmVudHMgOiBldmVudHMuc3BsaXQoL1xccysvKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBldmVudExpc3QubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZXZ0ID0gZXZlbnRMaXN0W2ldO1xuICAgIGlmIChlbXB0eVN0cmluZyhldnQpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgdmFyIG1hdGNoID0gZXZ0Lm1hdGNoKGV2ZW50UmVnZXgpOyAvLyB0eXBlWy5uYW1lc3BhY2VdXG5cbiAgICBpZiAobWF0Y2gpIHtcbiAgICAgIHZhciB0eXBlID0gbWF0Y2hbMV07XG4gICAgICB2YXIgbmFtZXNwYWNlID0gbWF0Y2hbMl0gPyBtYXRjaFsyXSA6IG51bGw7XG4gICAgICB2YXIgcmV0ID0gaGFuZGxlcihzZWxmLCBldnQsIHR5cGUsIG5hbWVzcGFjZSwgcXVhbGlmaWVyLCBjYWxsYmFjaywgY29uZik7XG4gICAgICBpZiAocmV0ID09PSBmYWxzZSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH0gLy8gYWxsb3cgZXhpdGluZyBlYXJseVxuICAgIH1cbiAgfVxufTtcblxudmFyIG1ha2VFdmVudE9iaiA9IGZ1bmN0aW9uIG1ha2VFdmVudE9iaihzZWxmLCBvYmopIHtcbiAgc2VsZi5hZGRFdmVudEZpZWxkcyhzZWxmLmNvbnRleHQsIG9iaik7XG4gIHJldHVybiBuZXcgRXZlbnQob2JqLnR5cGUsIG9iaik7XG59O1xudmFyIGZvckVhY2hFdmVudE9iaiA9IGZ1bmN0aW9uIGZvckVhY2hFdmVudE9iaihzZWxmLCBoYW5kbGVyLCBldmVudHMpIHtcbiAgaWYgKGV2ZW50KGV2ZW50cykpIHtcbiAgICBoYW5kbGVyKHNlbGYsIGV2ZW50cyk7XG4gICAgcmV0dXJuO1xuICB9IGVsc2UgaWYgKHBsYWluT2JqZWN0KGV2ZW50cykpIHtcbiAgICBoYW5kbGVyKHNlbGYsIG1ha2VFdmVudE9iaihzZWxmLCBldmVudHMpKTtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIGV2ZW50TGlzdCA9IGFycmF5KGV2ZW50cykgPyBldmVudHMgOiBldmVudHMuc3BsaXQoL1xccysvKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBldmVudExpc3QubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZXZ0ID0gZXZlbnRMaXN0W2ldO1xuICAgIGlmIChlbXB0eVN0cmluZyhldnQpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgdmFyIG1hdGNoID0gZXZ0Lm1hdGNoKGV2ZW50UmVnZXgpOyAvLyB0eXBlWy5uYW1lc3BhY2VdXG5cbiAgICBpZiAobWF0Y2gpIHtcbiAgICAgIHZhciB0eXBlID0gbWF0Y2hbMV07XG4gICAgICB2YXIgbmFtZXNwYWNlID0gbWF0Y2hbMl0gPyBtYXRjaFsyXSA6IG51bGw7XG4gICAgICB2YXIgZXZlbnRPYmogPSBtYWtlRXZlbnRPYmooc2VsZiwge1xuICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICBuYW1lc3BhY2U6IG5hbWVzcGFjZSxcbiAgICAgICAgdGFyZ2V0OiBzZWxmLmNvbnRleHRcbiAgICAgIH0pO1xuICAgICAgaGFuZGxlcihzZWxmLCBldmVudE9iaik7XG4gICAgfVxuICB9XG59O1xucC5vbiA9IHAuYWRkTGlzdGVuZXIgPSBmdW5jdGlvbiAoZXZlbnRzLCBxdWFsaWZpZXIsIGNhbGxiYWNrLCBjb25mLCBjb25mT3ZlcnJpZGVzKSB7XG4gIGZvckVhY2hFdmVudCh0aGlzLCBmdW5jdGlvbiAoc2VsZiwgZXZlbnQsIHR5cGUsIG5hbWVzcGFjZSwgcXVhbGlmaWVyLCBjYWxsYmFjaywgY29uZikge1xuICAgIGlmIChmbiQ2KGNhbGxiYWNrKSkge1xuICAgICAgc2VsZi5saXN0ZW5lcnMucHVzaCh7XG4gICAgICAgIGV2ZW50OiBldmVudCxcbiAgICAgICAgLy8gZnVsbCBldmVudCBzdHJpbmdcbiAgICAgICAgY2FsbGJhY2s6IGNhbGxiYWNrLFxuICAgICAgICAvLyBjYWxsYmFjayB0byBydW5cbiAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgLy8gdGhlIGV2ZW50IHR5cGUgKGUuZy4gJ2NsaWNrJylcbiAgICAgICAgbmFtZXNwYWNlOiBuYW1lc3BhY2UsXG4gICAgICAgIC8vIHRoZSBldmVudCBuYW1lc3BhY2UgKGUuZy4gXCIuZm9vXCIpXG4gICAgICAgIHF1YWxpZmllcjogcXVhbGlmaWVyLFxuICAgICAgICAvLyBhIHJlc3RyaWN0aW9uIG9uIHdoZXRoZXIgdG8gbWF0Y2ggdGhpcyBlbWl0dGVyXG4gICAgICAgIGNvbmY6IGNvbmYgLy8gYWRkaXRpb25hbCBjb25maWd1cmF0aW9uXG4gICAgICB9KTtcbiAgICB9XG4gIH0sIGV2ZW50cywgcXVhbGlmaWVyLCBjYWxsYmFjaywgY29uZiwgY29uZk92ZXJyaWRlcyk7XG4gIHJldHVybiB0aGlzO1xufTtcbnAub25lID0gZnVuY3Rpb24gKGV2ZW50cywgcXVhbGlmaWVyLCBjYWxsYmFjaywgY29uZikge1xuICByZXR1cm4gdGhpcy5vbihldmVudHMsIHF1YWxpZmllciwgY2FsbGJhY2ssIGNvbmYsIHtcbiAgICBvbmU6IHRydWVcbiAgfSk7XG59O1xucC5yZW1vdmVMaXN0ZW5lciA9IHAub2ZmID0gZnVuY3Rpb24gKGV2ZW50cywgcXVhbGlmaWVyLCBjYWxsYmFjaywgY29uZikge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuICBpZiAodGhpcy5lbWl0dGluZyAhPT0gMCkge1xuICAgIHRoaXMubGlzdGVuZXJzID0gY29weUFycmF5JDEodGhpcy5saXN0ZW5lcnMpO1xuICB9XG4gIHZhciBsaXN0ZW5lcnMgPSB0aGlzLmxpc3RlbmVycztcbiAgdmFyIF9sb29wID0gZnVuY3Rpb24gX2xvb3AoaSkge1xuICAgIHZhciBsaXN0ZW5lciA9IGxpc3RlbmVyc1tpXTtcbiAgICBmb3JFYWNoRXZlbnQoX3RoaXMsIGZ1bmN0aW9uIChzZWxmLCBldmVudCwgdHlwZSwgbmFtZXNwYWNlLCBxdWFsaWZpZXIsIGNhbGxiYWNrIC8qLCBjb25mKi8pIHtcbiAgICAgIGlmICgobGlzdGVuZXIudHlwZSA9PT0gdHlwZSB8fCBldmVudHMgPT09ICcqJykgJiYgKCFuYW1lc3BhY2UgJiYgbGlzdGVuZXIubmFtZXNwYWNlICE9PSAnLionIHx8IGxpc3RlbmVyLm5hbWVzcGFjZSA9PT0gbmFtZXNwYWNlKSAmJiAoIXF1YWxpZmllciB8fCBzZWxmLnF1YWxpZmllckNvbXBhcmUobGlzdGVuZXIucXVhbGlmaWVyLCBxdWFsaWZpZXIpKSAmJiAoIWNhbGxiYWNrIHx8IGxpc3RlbmVyLmNhbGxiYWNrID09PSBjYWxsYmFjaykpIHtcbiAgICAgICAgbGlzdGVuZXJzLnNwbGljZShpLCAxKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0sIGV2ZW50cywgcXVhbGlmaWVyLCBjYWxsYmFjaywgY29uZik7XG4gIH07XG4gIGZvciAodmFyIGkgPSBsaXN0ZW5lcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBfbG9vcChpKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5wLnJlbW92ZUFsbExpc3RlbmVycyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMucmVtb3ZlTGlzdGVuZXIoJyonKTtcbn07XG5wLmVtaXQgPSBwLnRyaWdnZXIgPSBmdW5jdGlvbiAoZXZlbnRzLCBleHRyYVBhcmFtcywgbWFudWFsQ2FsbGJhY2spIHtcbiAgdmFyIGxpc3RlbmVycyA9IHRoaXMubGlzdGVuZXJzO1xuICB2YXIgbnVtTGlzdGVuZXJzQmVmb3JlRW1pdCA9IGxpc3RlbmVycy5sZW5ndGg7XG4gIHRoaXMuZW1pdHRpbmcrKztcbiAgaWYgKCFhcnJheShleHRyYVBhcmFtcykpIHtcbiAgICBleHRyYVBhcmFtcyA9IFtleHRyYVBhcmFtc107XG4gIH1cbiAgZm9yRWFjaEV2ZW50T2JqKHRoaXMsIGZ1bmN0aW9uIChzZWxmLCBldmVudE9iaikge1xuICAgIGlmIChtYW51YWxDYWxsYmFjayAhPSBudWxsKSB7XG4gICAgICBsaXN0ZW5lcnMgPSBbe1xuICAgICAgICBldmVudDogZXZlbnRPYmouZXZlbnQsXG4gICAgICAgIHR5cGU6IGV2ZW50T2JqLnR5cGUsXG4gICAgICAgIG5hbWVzcGFjZTogZXZlbnRPYmoubmFtZXNwYWNlLFxuICAgICAgICBjYWxsYmFjazogbWFudWFsQ2FsbGJhY2tcbiAgICAgIH1dO1xuICAgICAgbnVtTGlzdGVuZXJzQmVmb3JlRW1pdCA9IGxpc3RlbmVycy5sZW5ndGg7XG4gICAgfVxuICAgIHZhciBfbG9vcDIgPSBmdW5jdGlvbiBfbG9vcDIoaSkge1xuICAgICAgdmFyIGxpc3RlbmVyID0gbGlzdGVuZXJzW2ldO1xuICAgICAgaWYgKGxpc3RlbmVyLnR5cGUgPT09IGV2ZW50T2JqLnR5cGUgJiYgKCFsaXN0ZW5lci5uYW1lc3BhY2UgfHwgbGlzdGVuZXIubmFtZXNwYWNlID09PSBldmVudE9iai5uYW1lc3BhY2UgfHwgbGlzdGVuZXIubmFtZXNwYWNlID09PSB1bml2ZXJzYWxOYW1lc3BhY2UpICYmIHNlbGYuZXZlbnRNYXRjaGVzKHNlbGYuY29udGV4dCwgbGlzdGVuZXIsIGV2ZW50T2JqKSkge1xuICAgICAgICB2YXIgYXJncyA9IFtldmVudE9ial07XG4gICAgICAgIGlmIChleHRyYVBhcmFtcyAhPSBudWxsKSB7XG4gICAgICAgICAgcHVzaChhcmdzLCBleHRyYVBhcmFtcyk7XG4gICAgICAgIH1cbiAgICAgICAgc2VsZi5iZWZvcmVFbWl0KHNlbGYuY29udGV4dCwgbGlzdGVuZXIsIGV2ZW50T2JqKTtcbiAgICAgICAgaWYgKGxpc3RlbmVyLmNvbmYgJiYgbGlzdGVuZXIuY29uZi5vbmUpIHtcbiAgICAgICAgICBzZWxmLmxpc3RlbmVycyA9IHNlbGYubGlzdGVuZXJzLmZpbHRlcihmdW5jdGlvbiAobCkge1xuICAgICAgICAgICAgcmV0dXJuIGwgIT09IGxpc3RlbmVyO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjb250ZXh0ID0gc2VsZi5jYWxsYmFja0NvbnRleHQoc2VsZi5jb250ZXh0LCBsaXN0ZW5lciwgZXZlbnRPYmopO1xuICAgICAgICB2YXIgcmV0ID0gbGlzdGVuZXIuY2FsbGJhY2suYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICAgIHNlbGYuYWZ0ZXJFbWl0KHNlbGYuY29udGV4dCwgbGlzdGVuZXIsIGV2ZW50T2JqKTtcbiAgICAgICAgaWYgKHJldCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICBldmVudE9iai5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICBldmVudE9iai5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgICB9IC8vIGlmIGxpc3RlbmVyIG1hdGNoZXNcbiAgICB9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtTGlzdGVuZXJzQmVmb3JlRW1pdDsgaSsrKSB7XG4gICAgICBfbG9vcDIoaSk7XG4gICAgfSAvLyBmb3IgbGlzdGVuZXJcblxuICAgIGlmIChzZWxmLmJ1YmJsZShzZWxmLmNvbnRleHQpICYmICFldmVudE9iai5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpKSB7XG4gICAgICBzZWxmLnBhcmVudChzZWxmLmNvbnRleHQpLmVtaXQoZXZlbnRPYmosIGV4dHJhUGFyYW1zKTtcbiAgICB9XG4gIH0sIGV2ZW50cyk7XG4gIHRoaXMuZW1pdHRpbmctLTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG52YXIgZW1pdHRlck9wdGlvbnMkMSA9IHtcbiAgcXVhbGlmaWVyQ29tcGFyZTogZnVuY3Rpb24gcXVhbGlmaWVyQ29tcGFyZShzZWxlY3RvcjEsIHNlbGVjdG9yMikge1xuICAgIGlmIChzZWxlY3RvcjEgPT0gbnVsbCB8fCBzZWxlY3RvcjIgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHNlbGVjdG9yMSA9PSBudWxsICYmIHNlbGVjdG9yMiA9PSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gc2VsZWN0b3IxLnNhbWVUZXh0KHNlbGVjdG9yMik7XG4gICAgfVxuICB9LFxuICBldmVudE1hdGNoZXM6IGZ1bmN0aW9uIGV2ZW50TWF0Y2hlcyhlbGUsIGxpc3RlbmVyLCBldmVudE9iaikge1xuICAgIHZhciBzZWxlY3RvciA9IGxpc3RlbmVyLnF1YWxpZmllcjtcbiAgICBpZiAoc2VsZWN0b3IgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGVsZSAhPT0gZXZlbnRPYmoudGFyZ2V0ICYmIGVsZW1lbnQoZXZlbnRPYmoudGFyZ2V0KSAmJiBzZWxlY3Rvci5tYXRjaGVzKGV2ZW50T2JqLnRhcmdldCk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9LFxuICBhZGRFdmVudEZpZWxkczogZnVuY3Rpb24gYWRkRXZlbnRGaWVsZHMoZWxlLCBldnQpIHtcbiAgICBldnQuY3kgPSBlbGUuY3koKTtcbiAgICBldnQudGFyZ2V0ID0gZWxlO1xuICB9LFxuICBjYWxsYmFja0NvbnRleHQ6IGZ1bmN0aW9uIGNhbGxiYWNrQ29udGV4dChlbGUsIGxpc3RlbmVyLCBldmVudE9iaikge1xuICAgIHJldHVybiBsaXN0ZW5lci5xdWFsaWZpZXIgIT0gbnVsbCA/IGV2ZW50T2JqLnRhcmdldCA6IGVsZTtcbiAgfSxcbiAgYmVmb3JlRW1pdDogZnVuY3Rpb24gYmVmb3JlRW1pdChjb250ZXh0LCBsaXN0ZW5lciAvKiwgZXZlbnRPYmoqLykge1xuICAgIGlmIChsaXN0ZW5lci5jb25mICYmIGxpc3RlbmVyLmNvbmYub25jZSkge1xuICAgICAgbGlzdGVuZXIuY29uZi5vbmNlQ29sbGVjdGlvbi5yZW1vdmVMaXN0ZW5lcihsaXN0ZW5lci5ldmVudCwgbGlzdGVuZXIucXVhbGlmaWVyLCBsaXN0ZW5lci5jYWxsYmFjayk7XG4gICAgfVxuICB9LFxuICBidWJibGU6IGZ1bmN0aW9uIGJ1YmJsZSgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSxcbiAgcGFyZW50OiBmdW5jdGlvbiBwYXJlbnQoZWxlKSB7XG4gICAgcmV0dXJuIGVsZS5pc0NoaWxkKCkgPyBlbGUucGFyZW50KCkgOiBlbGUuY3koKTtcbiAgfVxufTtcbnZhciBhcmdTZWxlY3RvciQxID0gZnVuY3Rpb24gYXJnU2VsZWN0b3IoYXJnKSB7XG4gIGlmIChzdHJpbmcoYXJnKSkge1xuICAgIHJldHVybiBuZXcgU2VsZWN0b3IoYXJnKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYXJnO1xuICB9XG59O1xudmFyIGVsZXNmbiQ5ID0ge1xuICBjcmVhdGVFbWl0dGVyOiBmdW5jdGlvbiBjcmVhdGVFbWl0dGVyKCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGVsZSA9IHRoaXNbaV07XG4gICAgICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gICAgICBpZiAoIV9wLmVtaXR0ZXIpIHtcbiAgICAgICAgX3AuZW1pdHRlciA9IG5ldyBFbWl0dGVyKGVtaXR0ZXJPcHRpb25zJDEsIGVsZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBlbWl0dGVyOiBmdW5jdGlvbiBlbWl0dGVyKCkge1xuICAgIHJldHVybiB0aGlzLl9wcml2YXRlLmVtaXR0ZXI7XG4gIH0sXG4gIG9uOiBmdW5jdGlvbiBvbihldmVudHMsIHNlbGVjdG9yLCBjYWxsYmFjaykge1xuICAgIHZhciBhcmdTZWwgPSBhcmdTZWxlY3RvciQxKHNlbGVjdG9yKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBlbGUgPSB0aGlzW2ldO1xuICAgICAgZWxlLmVtaXR0ZXIoKS5vbihldmVudHMsIGFyZ1NlbCwgY2FsbGJhY2spO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgcmVtb3ZlTGlzdGVuZXI6IGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKGV2ZW50cywgc2VsZWN0b3IsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGFyZ1NlbCA9IGFyZ1NlbGVjdG9yJDEoc2VsZWN0b3IpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGVsZSA9IHRoaXNbaV07XG4gICAgICBlbGUuZW1pdHRlcigpLnJlbW92ZUxpc3RlbmVyKGV2ZW50cywgYXJnU2VsLCBjYWxsYmFjayk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICByZW1vdmVBbGxMaXN0ZW5lcnM6IGZ1bmN0aW9uIHJlbW92ZUFsbExpc3RlbmVycygpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBlbGUgPSB0aGlzW2ldO1xuICAgICAgZWxlLmVtaXR0ZXIoKS5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIG9uZTogZnVuY3Rpb24gb25lKGV2ZW50cywgc2VsZWN0b3IsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGFyZ1NlbCA9IGFyZ1NlbGVjdG9yJDEoc2VsZWN0b3IpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGVsZSA9IHRoaXNbaV07XG4gICAgICBlbGUuZW1pdHRlcigpLm9uZShldmVudHMsIGFyZ1NlbCwgY2FsbGJhY2spO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgb25jZTogZnVuY3Rpb24gb25jZShldmVudHMsIHNlbGVjdG9yLCBjYWxsYmFjaykge1xuICAgIHZhciBhcmdTZWwgPSBhcmdTZWxlY3RvciQxKHNlbGVjdG9yKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBlbGUgPSB0aGlzW2ldO1xuICAgICAgZWxlLmVtaXR0ZXIoKS5vbihldmVudHMsIGFyZ1NlbCwgY2FsbGJhY2ssIHtcbiAgICAgICAgb25jZTogdHJ1ZSxcbiAgICAgICAgb25jZUNvbGxlY3Rpb246IHRoaXNcbiAgICAgIH0pO1xuICAgIH1cbiAgfSxcbiAgZW1pdDogZnVuY3Rpb24gZW1pdChldmVudHMsIGV4dHJhUGFyYW1zKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZWxlID0gdGhpc1tpXTtcbiAgICAgIGVsZS5lbWl0dGVyKCkuZW1pdChldmVudHMsIGV4dHJhUGFyYW1zKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIGVtaXRBbmROb3RpZnk6IGZ1bmN0aW9uIGVtaXRBbmROb3RpZnkoZXZlbnQsIGV4dHJhUGFyYW1zKSB7XG4gICAgLy8gZm9yIGludGVybmFsIHVzZSBvbmx5XG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBlbXB0eSBjb2xsZWN0aW9ucyBkb24ndCBuZWVkIHRvIG5vdGlmeSBhbnl0aGluZ1xuXG4gICAgLy8gbm90aWZ5IHJlbmRlcmVyXG4gICAgdGhpcy5jeSgpLm5vdGlmeShldmVudCwgdGhpcyk7XG4gICAgdGhpcy5lbWl0KGV2ZW50LCBleHRyYVBhcmFtcyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn07XG5kZWZpbmUuZXZlbnRBbGlhc2VzT24oZWxlc2ZuJDkpO1xuXG52YXIgZWxlc2ZuJDggPSB7XG4gIG5vZGVzOiBmdW5jdGlvbiBub2RlcyhzZWxlY3Rvcikge1xuICAgIHJldHVybiB0aGlzLmZpbHRlcihmdW5jdGlvbiAoZWxlKSB7XG4gICAgICByZXR1cm4gZWxlLmlzTm9kZSgpO1xuICAgIH0pLmZpbHRlcihzZWxlY3Rvcik7XG4gIH0sXG4gIGVkZ2VzOiBmdW5jdGlvbiBlZGdlcyhzZWxlY3Rvcikge1xuICAgIHJldHVybiB0aGlzLmZpbHRlcihmdW5jdGlvbiAoZWxlKSB7XG4gICAgICByZXR1cm4gZWxlLmlzRWRnZSgpO1xuICAgIH0pLmZpbHRlcihzZWxlY3Rvcik7XG4gIH0sXG4gIC8vIGludGVybmFsIGhlbHBlciB0byBnZXQgbm9kZXMgYW5kIGVkZ2VzIGFzIHNlcGFyYXRlIGNvbGxlY3Rpb25zIHdpdGggc2luZ2xlIGl0ZXJhdGlvbiBvdmVyIGVsZW1lbnRzXG4gIGJ5R3JvdXA6IGZ1bmN0aW9uIGJ5R3JvdXAoKSB7XG4gICAgdmFyIG5vZGVzID0gdGhpcy5zcGF3bigpO1xuICAgIHZhciBlZGdlcyA9IHRoaXMuc3Bhd24oKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBlbGUgPSB0aGlzW2ldO1xuICAgICAgaWYgKGVsZS5pc05vZGUoKSkge1xuICAgICAgICBub2Rlcy5wdXNoKGVsZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlZGdlcy5wdXNoKGVsZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBub2Rlczogbm9kZXMsXG4gICAgICBlZGdlczogZWRnZXNcbiAgICB9O1xuICB9LFxuICBmaWx0ZXI6IGZ1bmN0aW9uIGZpbHRlcihfZmlsdGVyLCB0aGlzQXJnKSB7XG4gICAgaWYgKF9maWx0ZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gY2hlY2sgdGhpcyBmaXJzdCBiL2MgaXQncyB0aGUgbW9zdCBjb21tb24vcGVyZm9ybWFudCBjYXNlXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9IGVsc2UgaWYgKHN0cmluZyhfZmlsdGVyKSB8fCBlbGVtZW50T3JDb2xsZWN0aW9uKF9maWx0ZXIpKSB7XG4gICAgICByZXR1cm4gbmV3IFNlbGVjdG9yKF9maWx0ZXIpLmZpbHRlcih0aGlzKTtcbiAgICB9IGVsc2UgaWYgKGZuJDYoX2ZpbHRlcikpIHtcbiAgICAgIHZhciBmaWx0ZXJFbGVzID0gdGhpcy5zcGF3bigpO1xuICAgICAgdmFyIGVsZXMgPSB0aGlzO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlbGUgPSBlbGVzW2ldO1xuICAgICAgICB2YXIgaW5jbHVkZSA9IHRoaXNBcmcgPyBfZmlsdGVyLmFwcGx5KHRoaXNBcmcsIFtlbGUsIGksIGVsZXNdKSA6IF9maWx0ZXIoZWxlLCBpLCBlbGVzKTtcbiAgICAgICAgaWYgKGluY2x1ZGUpIHtcbiAgICAgICAgICBmaWx0ZXJFbGVzLnB1c2goZWxlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZpbHRlckVsZXM7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnNwYXduKCk7IC8vIGlmIG5vdCBoYW5kbGVkIGJ5IGFib3ZlLCBnaXZlICdlbSBhbiBlbXB0eSBjb2xsZWN0aW9uXG4gIH0sXG5cbiAgbm90OiBmdW5jdGlvbiBub3QodG9SZW1vdmUpIHtcbiAgICBpZiAoIXRvUmVtb3ZlKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHN0cmluZyh0b1JlbW92ZSkpIHtcbiAgICAgICAgdG9SZW1vdmUgPSB0aGlzLmZpbHRlcih0b1JlbW92ZSk7XG4gICAgICB9XG4gICAgICB2YXIgZWxlbWVudHMgPSB0aGlzLnNwYXduKCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzW2ldO1xuICAgICAgICB2YXIgcmVtb3ZlID0gdG9SZW1vdmUuaGFzKGVsZW1lbnQpO1xuICAgICAgICBpZiAoIXJlbW92ZSkge1xuICAgICAgICAgIGVsZW1lbnRzLnB1c2goZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBlbGVtZW50cztcbiAgICB9XG4gIH0sXG4gIGFic29sdXRlQ29tcGxlbWVudDogZnVuY3Rpb24gYWJzb2x1dGVDb21wbGVtZW50KCkge1xuICAgIHZhciBjeSA9IHRoaXMuY3koKTtcbiAgICByZXR1cm4gY3kubXV0YWJsZUVsZW1lbnRzKCkubm90KHRoaXMpO1xuICB9LFxuICBpbnRlcnNlY3Q6IGZ1bmN0aW9uIGludGVyc2VjdChvdGhlcikge1xuICAgIC8vIGlmIGEgc2VsZWN0b3IgaXMgc3BlY2lmaWVkLCB0aGVuIGZpbHRlciBieSBpdCBpbnN0ZWFkXG4gICAgaWYgKHN0cmluZyhvdGhlcikpIHtcbiAgICAgIHZhciBzZWxlY3RvciA9IG90aGVyO1xuICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyKHNlbGVjdG9yKTtcbiAgICB9XG4gICAgdmFyIGVsZW1lbnRzID0gdGhpcy5zcGF3bigpO1xuICAgIHZhciBjb2wxID0gdGhpcztcbiAgICB2YXIgY29sMiA9IG90aGVyO1xuICAgIHZhciBjb2wxU21hbGxlciA9IHRoaXMubGVuZ3RoIDwgb3RoZXIubGVuZ3RoO1xuICAgIHZhciBjb2xTID0gY29sMVNtYWxsZXIgPyBjb2wxIDogY29sMjtcbiAgICB2YXIgY29sTCA9IGNvbDFTbWFsbGVyID8gY29sMiA6IGNvbDE7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb2xTLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZWxlID0gY29sU1tpXTtcbiAgICAgIGlmIChjb2xMLmhhcyhlbGUpKSB7XG4gICAgICAgIGVsZW1lbnRzLnB1c2goZWxlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGVsZW1lbnRzO1xuICB9LFxuICB4b3I6IGZ1bmN0aW9uIHhvcihvdGhlcikge1xuICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3k7XG4gICAgaWYgKHN0cmluZyhvdGhlcikpIHtcbiAgICAgIG90aGVyID0gY3kuJChvdGhlcik7XG4gICAgfVxuICAgIHZhciBlbGVtZW50cyA9IHRoaXMuc3Bhd24oKTtcbiAgICB2YXIgY29sMSA9IHRoaXM7XG4gICAgdmFyIGNvbDIgPSBvdGhlcjtcbiAgICB2YXIgYWRkID0gZnVuY3Rpb24gYWRkKGNvbCwgb3RoZXIpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29sLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlbGUgPSBjb2xbaV07XG4gICAgICAgIHZhciBpZCA9IGVsZS5fcHJpdmF0ZS5kYXRhLmlkO1xuICAgICAgICB2YXIgaW5PdGhlciA9IG90aGVyLmhhc0VsZW1lbnRXaXRoSWQoaWQpO1xuICAgICAgICBpZiAoIWluT3RoZXIpIHtcbiAgICAgICAgICBlbGVtZW50cy5wdXNoKGVsZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIGFkZChjb2wxLCBjb2wyKTtcbiAgICBhZGQoY29sMiwgY29sMSk7XG4gICAgcmV0dXJuIGVsZW1lbnRzO1xuICB9LFxuICBkaWZmOiBmdW5jdGlvbiBkaWZmKG90aGVyKSB7XG4gICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeTtcbiAgICBpZiAoc3RyaW5nKG90aGVyKSkge1xuICAgICAgb3RoZXIgPSBjeS4kKG90aGVyKTtcbiAgICB9XG4gICAgdmFyIGxlZnQgPSB0aGlzLnNwYXduKCk7XG4gICAgdmFyIHJpZ2h0ID0gdGhpcy5zcGF3bigpO1xuICAgIHZhciBib3RoID0gdGhpcy5zcGF3bigpO1xuICAgIHZhciBjb2wxID0gdGhpcztcbiAgICB2YXIgY29sMiA9IG90aGVyO1xuICAgIHZhciBhZGQgPSBmdW5jdGlvbiBhZGQoY29sLCBvdGhlciwgcmV0RWxlcykge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb2wubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGVsZSA9IGNvbFtpXTtcbiAgICAgICAgdmFyIGlkID0gZWxlLl9wcml2YXRlLmRhdGEuaWQ7XG4gICAgICAgIHZhciBpbk90aGVyID0gb3RoZXIuaGFzRWxlbWVudFdpdGhJZChpZCk7XG4gICAgICAgIGlmIChpbk90aGVyKSB7XG4gICAgICAgICAgYm90aC5tZXJnZShlbGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldEVsZXMucHVzaChlbGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBhZGQoY29sMSwgY29sMiwgbGVmdCk7XG4gICAgYWRkKGNvbDIsIGNvbDEsIHJpZ2h0KTtcbiAgICByZXR1cm4ge1xuICAgICAgbGVmdDogbGVmdCxcbiAgICAgIHJpZ2h0OiByaWdodCxcbiAgICAgIGJvdGg6IGJvdGhcbiAgICB9O1xuICB9LFxuICBhZGQ6IGZ1bmN0aW9uIGFkZCh0b0FkZCkge1xuICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3k7XG4gICAgaWYgKCF0b0FkZCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGlmIChzdHJpbmcodG9BZGQpKSB7XG4gICAgICB2YXIgc2VsZWN0b3IgPSB0b0FkZDtcbiAgICAgIHRvQWRkID0gY3kubXV0YWJsZUVsZW1lbnRzKCkuZmlsdGVyKHNlbGVjdG9yKTtcbiAgICB9XG4gICAgdmFyIGVsZW1lbnRzID0gdGhpcy5zcGF3blNlbGYoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRvQWRkLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZWxlID0gdG9BZGRbaV07XG4gICAgICB2YXIgYWRkID0gIXRoaXMuaGFzKGVsZSk7XG4gICAgICBpZiAoYWRkKSB7XG4gICAgICAgIGVsZW1lbnRzLnB1c2goZWxlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGVsZW1lbnRzO1xuICB9LFxuICAvLyBpbiBwbGFjZSBtZXJnZSBvbiBjYWxsaW5nIGNvbGxlY3Rpb25cbiAgbWVyZ2U6IGZ1bmN0aW9uIG1lcmdlKHRvQWRkKSB7XG4gICAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZTtcbiAgICB2YXIgY3kgPSBfcC5jeTtcbiAgICBpZiAoIXRvQWRkKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgaWYgKHRvQWRkICYmIHN0cmluZyh0b0FkZCkpIHtcbiAgICAgIHZhciBzZWxlY3RvciA9IHRvQWRkO1xuICAgICAgdG9BZGQgPSBjeS5tdXRhYmxlRWxlbWVudHMoKS5maWx0ZXIoc2VsZWN0b3IpO1xuICAgIH1cbiAgICB2YXIgbWFwID0gX3AubWFwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdG9BZGQubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB0b0FkZEVsZSA9IHRvQWRkW2ldO1xuICAgICAgdmFyIGlkID0gdG9BZGRFbGUuX3ByaXZhdGUuZGF0YS5pZDtcbiAgICAgIHZhciBhZGQgPSAhbWFwLmhhcyhpZCk7XG4gICAgICBpZiAoYWRkKSB7XG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMubGVuZ3RoKys7XG4gICAgICAgIHRoaXNbaW5kZXhdID0gdG9BZGRFbGU7XG4gICAgICAgIG1hcC5zZXQoaWQsIHtcbiAgICAgICAgICBlbGU6IHRvQWRkRWxlLFxuICAgICAgICAgIGluZGV4OiBpbmRleFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH0sXG5cbiAgdW5tZXJnZUF0OiBmdW5jdGlvbiB1bm1lcmdlQXQoaSkge1xuICAgIHZhciBlbGUgPSB0aGlzW2ldO1xuICAgIHZhciBpZCA9IGVsZS5pZCgpO1xuICAgIHZhciBfcCA9IHRoaXMuX3ByaXZhdGU7XG4gICAgdmFyIG1hcCA9IF9wLm1hcDtcblxuICAgIC8vIHJlbW92ZSBlbGVcbiAgICB0aGlzW2ldID0gdW5kZWZpbmVkO1xuICAgIG1hcFtcImRlbGV0ZVwiXShpZCk7XG4gICAgdmFyIHVubWVyZ2VkTGFzdEVsZSA9IGkgPT09IHRoaXMubGVuZ3RoIC0gMTtcblxuICAgIC8vIHJlcGxhY2UgZW1wdHkgc3BvdCB3aXRoIGxhc3QgZWxlIGluIGNvbGxlY3Rpb25cbiAgICBpZiAodGhpcy5sZW5ndGggPiAxICYmICF1bm1lcmdlZExhc3RFbGUpIHtcbiAgICAgIHZhciBsYXN0RWxlSSA9IHRoaXMubGVuZ3RoIC0gMTtcbiAgICAgIHZhciBsYXN0RWxlID0gdGhpc1tsYXN0RWxlSV07XG4gICAgICB2YXIgbGFzdEVsZUlkID0gbGFzdEVsZS5fcHJpdmF0ZS5kYXRhLmlkO1xuICAgICAgdGhpc1tsYXN0RWxlSV0gPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzW2ldID0gbGFzdEVsZTtcbiAgICAgIG1hcC5zZXQobGFzdEVsZUlkLCB7XG4gICAgICAgIGVsZTogbGFzdEVsZSxcbiAgICAgICAgaW5kZXg6IGlcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIHRoZSBjb2xsZWN0aW9uIGlzIG5vdyAxIGVsZSBzbWFsbGVyXG4gICAgdGhpcy5sZW5ndGgtLTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgLy8gcmVtb3ZlIHNpbmdsZSBlbGUgaW4gcGxhY2UgaW4gY2FsbGluZyBjb2xsZWN0aW9uXG4gIHVubWVyZ2VPbmU6IGZ1bmN0aW9uIHVubWVyZ2VPbmUoZWxlKSB7XG4gICAgZWxlID0gZWxlWzBdO1xuICAgIHZhciBfcCA9IHRoaXMuX3ByaXZhdGU7XG4gICAgdmFyIGlkID0gZWxlLl9wcml2YXRlLmRhdGEuaWQ7XG4gICAgdmFyIG1hcCA9IF9wLm1hcDtcbiAgICB2YXIgZW50cnkgPSBtYXAuZ2V0KGlkKTtcbiAgICBpZiAoIWVudHJ5KSB7XG4gICAgICByZXR1cm4gdGhpczsgLy8gbm8gbmVlZCB0byByZW1vdmVcbiAgICB9XG5cbiAgICB2YXIgaSA9IGVudHJ5LmluZGV4O1xuICAgIHRoaXMudW5tZXJnZUF0KGkpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICAvLyByZW1vdmUgZWxlcyBpbiBwbGFjZSBvbiBjYWxsaW5nIGNvbGxlY3Rpb25cbiAgdW5tZXJnZTogZnVuY3Rpb24gdW5tZXJnZSh0b1JlbW92ZSkge1xuICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3k7XG4gICAgaWYgKCF0b1JlbW92ZSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGlmICh0b1JlbW92ZSAmJiBzdHJpbmcodG9SZW1vdmUpKSB7XG4gICAgICB2YXIgc2VsZWN0b3IgPSB0b1JlbW92ZTtcbiAgICAgIHRvUmVtb3ZlID0gY3kubXV0YWJsZUVsZW1lbnRzKCkuZmlsdGVyKHNlbGVjdG9yKTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b1JlbW92ZS5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy51bm1lcmdlT25lKHRvUmVtb3ZlW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH0sXG5cbiAgdW5tZXJnZUJ5OiBmdW5jdGlvbiB1bm1lcmdlQnkodG9SbUZuKSB7XG4gICAgZm9yICh2YXIgaSA9IHRoaXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciBlbGUgPSB0aGlzW2ldO1xuICAgICAgaWYgKHRvUm1GbihlbGUpKSB7XG4gICAgICAgIHRoaXMudW5tZXJnZUF0KGkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgbWFwOiBmdW5jdGlvbiBtYXAobWFwRm4sIHRoaXNBcmcpIHtcbiAgICB2YXIgYXJyID0gW107XG4gICAgdmFyIGVsZXMgPSB0aGlzO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGVsZSA9IGVsZXNbaV07XG4gICAgICB2YXIgcmV0ID0gdGhpc0FyZyA/IG1hcEZuLmFwcGx5KHRoaXNBcmcsIFtlbGUsIGksIGVsZXNdKSA6IG1hcEZuKGVsZSwgaSwgZWxlcyk7XG4gICAgICBhcnIucHVzaChyZXQpO1xuICAgIH1cbiAgICByZXR1cm4gYXJyO1xuICB9LFxuICByZWR1Y2U6IGZ1bmN0aW9uIHJlZHVjZShmbiwgaW5pdGlhbFZhbHVlKSB7XG4gICAgdmFyIHZhbCA9IGluaXRpYWxWYWx1ZTtcbiAgICB2YXIgZWxlcyA9IHRoaXM7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YWwgPSBmbih2YWwsIGVsZXNbaV0sIGksIGVsZXMpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsO1xuICB9LFxuICBtYXg6IGZ1bmN0aW9uIG1heCh2YWxGbiwgdGhpc0FyZykge1xuICAgIHZhciBtYXggPSAtSW5maW5pdHk7XG4gICAgdmFyIG1heEVsZTtcbiAgICB2YXIgZWxlcyA9IHRoaXM7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZWxlID0gZWxlc1tpXTtcbiAgICAgIHZhciB2YWwgPSB0aGlzQXJnID8gdmFsRm4uYXBwbHkodGhpc0FyZywgW2VsZSwgaSwgZWxlc10pIDogdmFsRm4oZWxlLCBpLCBlbGVzKTtcbiAgICAgIGlmICh2YWwgPiBtYXgpIHtcbiAgICAgICAgbWF4ID0gdmFsO1xuICAgICAgICBtYXhFbGUgPSBlbGU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB2YWx1ZTogbWF4LFxuICAgICAgZWxlOiBtYXhFbGVcbiAgICB9O1xuICB9LFxuICBtaW46IGZ1bmN0aW9uIG1pbih2YWxGbiwgdGhpc0FyZykge1xuICAgIHZhciBtaW4gPSBJbmZpbml0eTtcbiAgICB2YXIgbWluRWxlO1xuICAgIHZhciBlbGVzID0gdGhpcztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBlbGUgPSBlbGVzW2ldO1xuICAgICAgdmFyIHZhbCA9IHRoaXNBcmcgPyB2YWxGbi5hcHBseSh0aGlzQXJnLCBbZWxlLCBpLCBlbGVzXSkgOiB2YWxGbihlbGUsIGksIGVsZXMpO1xuICAgICAgaWYgKHZhbCA8IG1pbikge1xuICAgICAgICBtaW4gPSB2YWw7XG4gICAgICAgIG1pbkVsZSA9IGVsZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHZhbHVlOiBtaW4sXG4gICAgICBlbGU6IG1pbkVsZVxuICAgIH07XG4gIH1cbn07XG5cbi8vIGFsaWFzZXNcbnZhciBmbiQxID0gZWxlc2ZuJDg7XG5mbiQxWyd1J10gPSBmbiQxWyd8J10gPSBmbiQxWycrJ10gPSBmbiQxLnVuaW9uID0gZm4kMS5vciA9IGZuJDEuYWRkO1xuZm4kMVsnXFxcXCddID0gZm4kMVsnISddID0gZm4kMVsnLSddID0gZm4kMS5kaWZmZXJlbmNlID0gZm4kMS5yZWxhdGl2ZUNvbXBsZW1lbnQgPSBmbiQxLnN1YnRyYWN0ID0gZm4kMS5ub3Q7XG5mbiQxWyduJ10gPSBmbiQxWycmJ10gPSBmbiQxWycuJ10gPSBmbiQxLmFuZCA9IGZuJDEuaW50ZXJzZWN0aW9uID0gZm4kMS5pbnRlcnNlY3Q7XG5mbiQxWydeJ10gPSBmbiQxWycoKyknXSA9IGZuJDFbJygtKSddID0gZm4kMS5zeW1tZXRyaWNEaWZmZXJlbmNlID0gZm4kMS5zeW1kaWZmID0gZm4kMS54b3I7XG5mbiQxLmZuRmlsdGVyID0gZm4kMS5maWx0ZXJGbiA9IGZuJDEuc3RkRmlsdGVyID0gZm4kMS5maWx0ZXI7XG5mbiQxLmNvbXBsZW1lbnQgPSBmbiQxLmFic2NvbXAgPSBmbiQxLmFic29sdXRlQ29tcGxlbWVudDtcblxudmFyIGVsZXNmbiQ3ID0ge1xuICBpc05vZGU6IGZ1bmN0aW9uIGlzTm9kZSgpIHtcbiAgICByZXR1cm4gdGhpcy5ncm91cCgpID09PSAnbm9kZXMnO1xuICB9LFxuICBpc0VkZ2U6IGZ1bmN0aW9uIGlzRWRnZSgpIHtcbiAgICByZXR1cm4gdGhpcy5ncm91cCgpID09PSAnZWRnZXMnO1xuICB9LFxuICBpc0xvb3A6IGZ1bmN0aW9uIGlzTG9vcCgpIHtcbiAgICByZXR1cm4gdGhpcy5pc0VkZ2UoKSAmJiB0aGlzLnNvdXJjZSgpWzBdID09PSB0aGlzLnRhcmdldCgpWzBdO1xuICB9LFxuICBpc1NpbXBsZTogZnVuY3Rpb24gaXNTaW1wbGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNFZGdlKCkgJiYgdGhpcy5zb3VyY2UoKVswXSAhPT0gdGhpcy50YXJnZXQoKVswXTtcbiAgfSxcbiAgZ3JvdXA6IGZ1bmN0aW9uIGdyb3VwKCkge1xuICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuICAgIGlmIChlbGUpIHtcbiAgICAgIHJldHVybiBlbGUuX3ByaXZhdGUuZ3JvdXA7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqICBFbGVtZW50cyBhcmUgZHJhd24gaW4gYSBzcGVjaWZpYyBvcmRlciBiYXNlZCBvbiBjb21wb3VuZCBkZXB0aCAobG93IHRvIGhpZ2gpLCB0aGUgZWxlbWVudCB0eXBlIChub2RlcyBhYm92ZSBlZGdlcyksXG4gKiAgYW5kIHotaW5kZXggKGxvdyB0byBoaWdoKS4gIFRoZXNlIHN0eWxlcyBhZmZlY3QgaG93IHRoaXMgYXBwbGllczpcbiAqXG4gKiAgei1jb21wb3VuZC1kZXB0aDogTWF5IGJlIGBib3R0b20gfCBvcnBoYW4gfCBhdXRvIHwgdG9wYC4gIFRoZSBmaXJzdCBkcmF3biBpcyBgYm90dG9tYCwgdGhlbiBgb3JwaGFuYCB3aGljaCBpcyB0aGVcbiAqICAgICAgc2FtZSBkZXB0aCBhcyB0aGUgcm9vdCBvZiB0aGUgY29tcG91bmQgZ3JhcGgsIGZvbGxvd2VkIGJ5IHRoZSBkZWZhdWx0IHZhbHVlIGBhdXRvYCB3aGljaCBkcmF3cyBpbiBvcmRlciBmcm9tXG4gKiAgICAgIHJvb3QgdG8gbGVhdmVzIG9mIHRoZSBjb21wb3VuZCBncmFwaC4gIFRoZSBsYXN0IGRyYXduIGlzIGB0b3BgLlxuICogIHotaW5kZXgtY29tcGFyZTogTWF5IGJlIGBhdXRvIHwgbWFudWFsYC4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIGBhdXRvYCB3aGljaCBhbHdheXMgZHJhd3MgZWRnZXMgdW5kZXIgbm9kZXMuXG4gKiAgICAgIGBtYW51YWxgIGlnbm9yZXMgdGhpcyBjb252ZW50aW9uIGFuZCBkcmF3cyBiYXNlZCBvbiB0aGUgYHotaW5kZXhgIHZhbHVlIHNldHRpbmcuXG4gKiAgei1pbmRleDogQW4gaW50ZWdlciB2YWx1ZSB0aGF0IGFmZmVjdHMgdGhlIHJlbGF0aXZlIGRyYXcgb3JkZXIgb2YgZWxlbWVudHMuICBJbiBnZW5lcmFsLCBhbiBlbGVtZW50IHdpdGggYSBoaWdoZXJcbiAqICAgICAgYHotaW5kZXhgIHdpbGwgYmUgZHJhd24gb24gdG9wIG9mIGFuIGVsZW1lbnQgd2l0aCBhIGxvd2VyIGB6LWluZGV4YC5cbiAqL1xudmFyIHpJbmRleFNvcnQgPSBmdW5jdGlvbiB6SW5kZXhTb3J0KGEsIGIpIHtcbiAgdmFyIGN5ID0gYS5jeSgpO1xuICB2YXIgaGFzQ29tcG91bmROb2RlcyA9IGN5Lmhhc0NvbXBvdW5kTm9kZXMoKTtcbiAgZnVuY3Rpb24gZ2V0RGVwdGgoZWxlKSB7XG4gICAgdmFyIHN0eWxlID0gZWxlLnBzdHlsZSgnei1jb21wb3VuZC1kZXB0aCcpO1xuICAgIGlmIChzdHlsZS52YWx1ZSA9PT0gJ2F1dG8nKSB7XG4gICAgICByZXR1cm4gaGFzQ29tcG91bmROb2RlcyA/IGVsZS56RGVwdGgoKSA6IDA7XG4gICAgfSBlbHNlIGlmIChzdHlsZS52YWx1ZSA9PT0gJ2JvdHRvbScpIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9IGVsc2UgaWYgKHN0eWxlLnZhbHVlID09PSAndG9wJykge1xuICAgICAgcmV0dXJuIE1BWF9JTlQkMTtcbiAgICB9XG4gICAgLy8gJ29ycGhhbidcbiAgICByZXR1cm4gMDtcbiAgfVxuICB2YXIgZGVwdGhEaWZmID0gZ2V0RGVwdGgoYSkgLSBnZXREZXB0aChiKTtcbiAgaWYgKGRlcHRoRGlmZiAhPT0gMCkge1xuICAgIHJldHVybiBkZXB0aERpZmY7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0RWxlRGVwdGgoZWxlKSB7XG4gICAgdmFyIHN0eWxlID0gZWxlLnBzdHlsZSgnei1pbmRleC1jb21wYXJlJyk7XG4gICAgaWYgKHN0eWxlLnZhbHVlID09PSAnYXV0bycpIHtcbiAgICAgIHJldHVybiBlbGUuaXNOb2RlKCkgPyAxIDogMDtcbiAgICB9XG4gICAgLy8gJ21hbnVhbCdcbiAgICByZXR1cm4gMDtcbiAgfVxuICB2YXIgZWxlRGlmZiA9IGdldEVsZURlcHRoKGEpIC0gZ2V0RWxlRGVwdGgoYik7XG4gIGlmIChlbGVEaWZmICE9PSAwKSB7XG4gICAgcmV0dXJuIGVsZURpZmY7XG4gIH1cbiAgdmFyIHpEaWZmID0gYS5wc3R5bGUoJ3otaW5kZXgnKS52YWx1ZSAtIGIucHN0eWxlKCd6LWluZGV4JykudmFsdWU7XG4gIGlmICh6RGlmZiAhPT0gMCkge1xuICAgIHJldHVybiB6RGlmZjtcbiAgfVxuICAvLyBjb21wYXJlIGluZGljZXMgaW4gdGhlIGNvcmUgKG9yZGVyIGFkZGVkIHRvIGdyYXBoIHcvIGxhc3Qgb24gdG9wKVxuICByZXR1cm4gYS5wb29sSW5kZXgoKSAtIGIucG9vbEluZGV4KCk7XG59O1xuXG52YXIgZWxlc2ZuJDYgPSB7XG4gIGZvckVhY2g6IGZ1bmN0aW9uIGZvckVhY2goZm4sIHRoaXNBcmcpIHtcbiAgICBpZiAoZm4kNihmbikpIHtcbiAgICAgIHZhciBOID0gdGhpcy5sZW5ndGg7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IE47IGkrKykge1xuICAgICAgICB2YXIgZWxlID0gdGhpc1tpXTtcbiAgICAgICAgdmFyIHJldCA9IHRoaXNBcmcgPyBmbi5hcHBseSh0aGlzQXJnLCBbZWxlLCBpLCB0aGlzXSkgOiBmbihlbGUsIGksIHRoaXMpO1xuICAgICAgICBpZiAocmV0ID09PSBmYWxzZSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9IC8vIGV4aXQgZWFjaCBlYXJseSBvbiByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgdG9BcnJheTogZnVuY3Rpb24gdG9BcnJheSgpIHtcbiAgICB2YXIgYXJyYXkgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFycmF5LnB1c2godGhpc1tpXSk7XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbiAgfSxcbiAgc2xpY2U6IGZ1bmN0aW9uIHNsaWNlKHN0YXJ0LCBlbmQpIHtcbiAgICB2YXIgYXJyYXkgPSBbXTtcbiAgICB2YXIgdGhpc1NpemUgPSB0aGlzLmxlbmd0aDtcbiAgICBpZiAoZW5kID09IG51bGwpIHtcbiAgICAgIGVuZCA9IHRoaXNTaXplO1xuICAgIH1cbiAgICBpZiAoc3RhcnQgPT0gbnVsbCkge1xuICAgICAgc3RhcnQgPSAwO1xuICAgIH1cbiAgICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgICBzdGFydCA9IHRoaXNTaXplICsgc3RhcnQ7XG4gICAgfVxuICAgIGlmIChlbmQgPCAwKSB7XG4gICAgICBlbmQgPSB0aGlzU2l6ZSArIGVuZDtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpID49IDAgJiYgaSA8IGVuZCAmJiBpIDwgdGhpc1NpemU7IGkrKykge1xuICAgICAgYXJyYXkucHVzaCh0aGlzW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuc3Bhd24oYXJyYXkpO1xuICB9LFxuICBzaXplOiBmdW5jdGlvbiBzaXplKCkge1xuICAgIHJldHVybiB0aGlzLmxlbmd0aDtcbiAgfSxcbiAgZXE6IGZ1bmN0aW9uIGVxKGkpIHtcbiAgICByZXR1cm4gdGhpc1tpXSB8fCB0aGlzLnNwYXduKCk7XG4gIH0sXG4gIGZpcnN0OiBmdW5jdGlvbiBmaXJzdCgpIHtcbiAgICByZXR1cm4gdGhpc1swXSB8fCB0aGlzLnNwYXduKCk7XG4gIH0sXG4gIGxhc3Q6IGZ1bmN0aW9uIGxhc3QoKSB7XG4gICAgcmV0dXJuIHRoaXNbdGhpcy5sZW5ndGggLSAxXSB8fCB0aGlzLnNwYXduKCk7XG4gIH0sXG4gIGVtcHR5OiBmdW5jdGlvbiBlbXB0eSgpIHtcbiAgICByZXR1cm4gdGhpcy5sZW5ndGggPT09IDA7XG4gIH0sXG4gIG5vbmVtcHR5OiBmdW5jdGlvbiBub25lbXB0eSgpIHtcbiAgICByZXR1cm4gIXRoaXMuZW1wdHkoKTtcbiAgfSxcbiAgc29ydDogZnVuY3Rpb24gc29ydChzb3J0Rm4pIHtcbiAgICBpZiAoIWZuJDYoc29ydEZuKSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHZhciBzb3J0ZWQgPSB0aGlzLnRvQXJyYXkoKS5zb3J0KHNvcnRGbik7XG4gICAgcmV0dXJuIHRoaXMuc3Bhd24oc29ydGVkKTtcbiAgfSxcbiAgc29ydEJ5WkluZGV4OiBmdW5jdGlvbiBzb3J0QnlaSW5kZXgoKSB7XG4gICAgcmV0dXJuIHRoaXMuc29ydCh6SW5kZXhTb3J0KTtcbiAgfSxcbiAgekRlcHRoOiBmdW5jdGlvbiB6RGVwdGgoKSB7XG4gICAgdmFyIGVsZSA9IHRoaXNbMF07XG4gICAgaWYgKCFlbGUpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLy8gbGV0IGN5ID0gZWxlLmN5KCk7XG4gICAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuICAgIHZhciBncm91cCA9IF9wLmdyb3VwO1xuICAgIGlmIChncm91cCA9PT0gJ25vZGVzJykge1xuICAgICAgdmFyIGRlcHRoID0gX3AuZGF0YS5wYXJlbnQgPyBlbGUucGFyZW50cygpLnNpemUoKSA6IDA7XG4gICAgICBpZiAoIWVsZS5pc1BhcmVudCgpKSB7XG4gICAgICAgIHJldHVybiBNQVhfSU5UJDEgLSAxOyAvLyBjaGlsZGxlc3Mgbm9kZXMgYWx3YXlzIG9uIHRvcFxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGVwdGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBzcmMgPSBfcC5zb3VyY2U7XG4gICAgICB2YXIgdGd0ID0gX3AudGFyZ2V0O1xuICAgICAgdmFyIHNyY0RlcHRoID0gc3JjLnpEZXB0aCgpO1xuICAgICAgdmFyIHRndERlcHRoID0gdGd0LnpEZXB0aCgpO1xuICAgICAgcmV0dXJuIE1hdGgubWF4KHNyY0RlcHRoLCB0Z3REZXB0aCwgMCk7IC8vIGRlcHRoIG9mIGRlZXBlc3QgcGFyZW50XG4gICAgfVxuICB9XG59O1xuXG5lbGVzZm4kNi5lYWNoID0gZWxlc2ZuJDYuZm9yRWFjaDtcbnZhciBkZWZpbmVTeW1ib2xJdGVyYXRvciA9IGZ1bmN0aW9uIGRlZmluZVN5bWJvbEl0ZXJhdG9yKCkge1xuICB2YXIgdHlwZW9mVW5kZWYgPSBcInVuZGVmaW5lZFwiIDtcbiAgdmFyIGlzSXRlcmF0b3JTdXBwb3J0ZWQgPSAodHlwZW9mIFN5bWJvbCA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mKFN5bWJvbCkpICE9IHR5cGVvZlVuZGVmICYmIF90eXBlb2YoU3ltYm9sLml0ZXJhdG9yKSAhPSB0eXBlb2ZVbmRlZjsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuXG4gIGlmIChpc0l0ZXJhdG9yU3VwcG9ydGVkKSB7XG4gICAgZWxlc2ZuJDZbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG4gICAgICB2YXIgZW50cnkgPSB7XG4gICAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICAgIGRvbmU6IGZhbHNlXG4gICAgICB9O1xuICAgICAgdmFyIGkgPSAwO1xuICAgICAgdmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoO1xuICAgICAgcmV0dXJuIF9kZWZpbmVQcm9wZXJ0eSQxKHtcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgICBpZiAoaSA8IGxlbmd0aCkge1xuICAgICAgICAgICAgZW50cnkudmFsdWUgPSBfdGhpc1tpKytdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlbnRyeS52YWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGVudHJ5LmRvbmUgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZW50cnk7XG4gICAgICAgIH1cbiAgICAgIH0sIFN5bWJvbC5pdGVyYXRvciwgZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSk7XG4gICAgfTtcbiAgfVxufTtcbmRlZmluZVN5bWJvbEl0ZXJhdG9yKCk7XG5cbnZhciBnZXRMYXlvdXREaW1lbnNpb25PcHRpb25zID0gZGVmYXVsdHMkZyh7XG4gIG5vZGVEaW1lbnNpb25zSW5jbHVkZUxhYmVsczogZmFsc2Vcbn0pO1xudmFyIGVsZXNmbiQ1ID0ge1xuICAvLyBDYWxjdWxhdGVzIGFuZCByZXR1cm5zIG5vZGUgZGltZW5zaW9ucyB7IHgsIHkgfSBiYXNlZCBvbiBvcHRpb25zIGdpdmVuXG4gIGxheW91dERpbWVuc2lvbnM6IGZ1bmN0aW9uIGxheW91dERpbWVuc2lvbnMob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBnZXRMYXlvdXREaW1lbnNpb25PcHRpb25zKG9wdGlvbnMpO1xuICAgIHZhciBkaW1zO1xuICAgIGlmICghdGhpcy50YWtlc1VwU3BhY2UoKSkge1xuICAgICAgZGltcyA9IHtcbiAgICAgICAgdzogMCxcbiAgICAgICAgaDogMFxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMubm9kZURpbWVuc2lvbnNJbmNsdWRlTGFiZWxzKSB7XG4gICAgICB2YXIgYmJEaW0gPSB0aGlzLmJvdW5kaW5nQm94KCk7XG4gICAgICBkaW1zID0ge1xuICAgICAgICB3OiBiYkRpbS53LFxuICAgICAgICBoOiBiYkRpbS5oXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBkaW1zID0ge1xuICAgICAgICB3OiB0aGlzLm91dGVyV2lkdGgoKSxcbiAgICAgICAgaDogdGhpcy5vdXRlckhlaWdodCgpXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIHNhbml0aXNlIHRoZSBkaW1lbnNpb25zIGZvciBleHRlcm5hbCBsYXlvdXRzIChhdm9pZCBkaXZpc2lvbiBieSB6ZXJvKVxuICAgIGlmIChkaW1zLncgPT09IDAgfHwgZGltcy5oID09PSAwKSB7XG4gICAgICBkaW1zLncgPSBkaW1zLmggPSAxO1xuICAgIH1cbiAgICByZXR1cm4gZGltcztcbiAgfSxcbiAgLy8gdXNpbmcgc3RhbmRhcmQgbGF5b3V0IG9wdGlvbnMsIGFwcGx5IHBvc2l0aW9uIGZ1bmN0aW9uICh3LyBvciB3L28gYW5pbWF0aW9uKVxuICBsYXlvdXRQb3NpdGlvbnM6IGZ1bmN0aW9uIGxheW91dFBvc2l0aW9ucyhsYXlvdXQsIG9wdGlvbnMsIGZuKSB7XG4gICAgdmFyIG5vZGVzID0gdGhpcy5ub2RlcygpLmZpbHRlcihmdW5jdGlvbiAobikge1xuICAgICAgcmV0dXJuICFuLmlzUGFyZW50KCk7XG4gICAgfSk7XG4gICAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuICAgIHZhciBsYXlvdXRFbGVzID0gb3B0aW9ucy5lbGVzOyAvLyBub2RlcyAmIGVkZ2VzXG4gICAgdmFyIGdldE1lbW9pemVLZXkgPSBmdW5jdGlvbiBnZXRNZW1vaXplS2V5KG5vZGUpIHtcbiAgICAgIHJldHVybiBub2RlLmlkKCk7XG4gICAgfTtcbiAgICB2YXIgZm5NZW0gPSBtZW1vaXplJDEoZm4sIGdldE1lbW9pemVLZXkpOyAvLyBtZW1vaXplZCB2ZXJzaW9uIG9mIHBvc2l0aW9uIGZ1bmN0aW9uXG5cbiAgICBsYXlvdXQuZW1pdCh7XG4gICAgICB0eXBlOiAnbGF5b3V0c3RhcnQnLFxuICAgICAgbGF5b3V0OiBsYXlvdXRcbiAgICB9KTtcbiAgICBsYXlvdXQuYW5pbWF0aW9ucyA9IFtdO1xuICAgIHZhciBjYWxjdWxhdGVTcGFjaW5nID0gZnVuY3Rpb24gY2FsY3VsYXRlU3BhY2luZyhzcGFjaW5nLCBub2Rlc0JiLCBwb3MpIHtcbiAgICAgIHZhciBjZW50ZXIgPSB7XG4gICAgICAgIHg6IG5vZGVzQmIueDEgKyBub2Rlc0JiLncgLyAyLFxuICAgICAgICB5OiBub2Rlc0JiLnkxICsgbm9kZXNCYi5oIC8gMlxuICAgICAgfTtcbiAgICAgIHZhciBzcGFjaW5nVmVjdG9yID0ge1xuICAgICAgICAvLyBzY2FsZSBmcm9tIGNlbnRlciBvZiBib3VuZGluZyBib3ggKG5vdCBuZWNlc3NhcmlseSAwLDApXG4gICAgICAgIHg6IChwb3MueCAtIGNlbnRlci54KSAqIHNwYWNpbmcsXG4gICAgICAgIHk6IChwb3MueSAtIGNlbnRlci55KSAqIHNwYWNpbmdcbiAgICAgIH07XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiBjZW50ZXIueCArIHNwYWNpbmdWZWN0b3IueCxcbiAgICAgICAgeTogY2VudGVyLnkgKyBzcGFjaW5nVmVjdG9yLnlcbiAgICAgIH07XG4gICAgfTtcbiAgICB2YXIgdXNlU3BhY2luZ0ZhY3RvciA9IG9wdGlvbnMuc3BhY2luZ0ZhY3RvciAmJiBvcHRpb25zLnNwYWNpbmdGYWN0b3IgIT09IDE7XG4gICAgdmFyIHNwYWNpbmdCYiA9IGZ1bmN0aW9uIHNwYWNpbmdCYigpIHtcbiAgICAgIGlmICghdXNlU3BhY2luZ0ZhY3Rvcikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHZhciBiYiA9IG1ha2VCb3VuZGluZ0JveCgpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICB2YXIgcG9zID0gZm5NZW0obm9kZSwgaSk7XG4gICAgICAgIGV4cGFuZEJvdW5kaW5nQm94QnlQb2ludChiYiwgcG9zLngsIHBvcy55KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYjtcbiAgICB9O1xuICAgIHZhciBiYiA9IHNwYWNpbmdCYigpO1xuICAgIHZhciBnZXRGaW5hbFBvcyA9IG1lbW9pemUkMShmdW5jdGlvbiAobm9kZSwgaSkge1xuICAgICAgdmFyIG5ld1BvcyA9IGZuTWVtKG5vZGUsIGkpO1xuICAgICAgaWYgKHVzZVNwYWNpbmdGYWN0b3IpIHtcbiAgICAgICAgdmFyIHNwYWNpbmcgPSBNYXRoLmFicyhvcHRpb25zLnNwYWNpbmdGYWN0b3IpO1xuICAgICAgICBuZXdQb3MgPSBjYWxjdWxhdGVTcGFjaW5nKHNwYWNpbmcsIGJiLCBuZXdQb3MpO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMudHJhbnNmb3JtICE9IG51bGwpIHtcbiAgICAgICAgbmV3UG9zID0gb3B0aW9ucy50cmFuc2Zvcm0obm9kZSwgbmV3UG9zKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXdQb3M7XG4gICAgfSwgZ2V0TWVtb2l6ZUtleSk7XG4gICAgaWYgKG9wdGlvbnMuYW5pbWF0ZSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICB2YXIgbmV3UG9zID0gZ2V0RmluYWxQb3Mobm9kZSwgaSk7XG4gICAgICAgIHZhciBhbmltYXRlTm9kZSA9IG9wdGlvbnMuYW5pbWF0ZUZpbHRlciA9PSBudWxsIHx8IG9wdGlvbnMuYW5pbWF0ZUZpbHRlcihub2RlLCBpKTtcbiAgICAgICAgaWYgKGFuaW1hdGVOb2RlKSB7XG4gICAgICAgICAgdmFyIGFuaSA9IG5vZGUuYW5pbWF0aW9uKHtcbiAgICAgICAgICAgIHBvc2l0aW9uOiBuZXdQb3MsXG4gICAgICAgICAgICBkdXJhdGlvbjogb3B0aW9ucy5hbmltYXRpb25EdXJhdGlvbixcbiAgICAgICAgICAgIGVhc2luZzogb3B0aW9ucy5hbmltYXRpb25FYXNpbmdcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBsYXlvdXQuYW5pbWF0aW9ucy5wdXNoKGFuaSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbm9kZS5wb3NpdGlvbihuZXdQb3MpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy5maXQpIHtcbiAgICAgICAgdmFyIGZpdEFuaSA9IGN5LmFuaW1hdGlvbih7XG4gICAgICAgICAgZml0OiB7XG4gICAgICAgICAgICBib3VuZGluZ0JveDogbGF5b3V0RWxlcy5ib3VuZGluZ0JveEF0KGdldEZpbmFsUG9zKSxcbiAgICAgICAgICAgIHBhZGRpbmc6IG9wdGlvbnMucGFkZGluZ1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IG9wdGlvbnMuYW5pbWF0aW9uRHVyYXRpb24sXG4gICAgICAgICAgZWFzaW5nOiBvcHRpb25zLmFuaW1hdGlvbkVhc2luZ1xuICAgICAgICB9KTtcbiAgICAgICAgbGF5b3V0LmFuaW1hdGlvbnMucHVzaChmaXRBbmkpO1xuICAgICAgfSBlbHNlIGlmIChvcHRpb25zLnpvb20gIT09IHVuZGVmaW5lZCAmJiBvcHRpb25zLnBhbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciB6b29tUGFuQW5pID0gY3kuYW5pbWF0aW9uKHtcbiAgICAgICAgICB6b29tOiBvcHRpb25zLnpvb20sXG4gICAgICAgICAgcGFuOiBvcHRpb25zLnBhbixcbiAgICAgICAgICBkdXJhdGlvbjogb3B0aW9ucy5hbmltYXRpb25EdXJhdGlvbixcbiAgICAgICAgICBlYXNpbmc6IG9wdGlvbnMuYW5pbWF0aW9uRWFzaW5nXG4gICAgICAgIH0pO1xuICAgICAgICBsYXlvdXQuYW5pbWF0aW9ucy5wdXNoKHpvb21QYW5BbmkpO1xuICAgICAgfVxuICAgICAgbGF5b3V0LmFuaW1hdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAoYW5pKSB7XG4gICAgICAgIHJldHVybiBhbmkucGxheSgpO1xuICAgICAgfSk7XG4gICAgICBsYXlvdXQub25lKCdsYXlvdXRyZWFkeScsIG9wdGlvbnMucmVhZHkpO1xuICAgICAgbGF5b3V0LmVtaXQoe1xuICAgICAgICB0eXBlOiAnbGF5b3V0cmVhZHknLFxuICAgICAgICBsYXlvdXQ6IGxheW91dFxuICAgICAgfSk7XG4gICAgICBQcm9taXNlJDEuYWxsKGxheW91dC5hbmltYXRpb25zLm1hcChmdW5jdGlvbiAoYW5pKSB7XG4gICAgICAgIHJldHVybiBhbmkucHJvbWlzZSgpO1xuICAgICAgfSkpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICBsYXlvdXQub25lKCdsYXlvdXRzdG9wJywgb3B0aW9ucy5zdG9wKTtcbiAgICAgICAgbGF5b3V0LmVtaXQoe1xuICAgICAgICAgIHR5cGU6ICdsYXlvdXRzdG9wJyxcbiAgICAgICAgICBsYXlvdXQ6IGxheW91dFxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBub2Rlcy5wb3NpdGlvbnMoZ2V0RmluYWxQb3MpO1xuICAgICAgaWYgKG9wdGlvbnMuZml0KSB7XG4gICAgICAgIGN5LmZpdChvcHRpb25zLmVsZXMsIG9wdGlvbnMucGFkZGluZyk7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy56b29tICE9IG51bGwpIHtcbiAgICAgICAgY3kuem9vbShvcHRpb25zLnpvb20pO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMucGFuKSB7XG4gICAgICAgIGN5LnBhbihvcHRpb25zLnBhbik7XG4gICAgICB9XG4gICAgICBsYXlvdXQub25lKCdsYXlvdXRyZWFkeScsIG9wdGlvbnMucmVhZHkpO1xuICAgICAgbGF5b3V0LmVtaXQoe1xuICAgICAgICB0eXBlOiAnbGF5b3V0cmVhZHknLFxuICAgICAgICBsYXlvdXQ6IGxheW91dFxuICAgICAgfSk7XG4gICAgICBsYXlvdXQub25lKCdsYXlvdXRzdG9wJywgb3B0aW9ucy5zdG9wKTtcbiAgICAgIGxheW91dC5lbWl0KHtcbiAgICAgICAgdHlwZTogJ2xheW91dHN0b3AnLFxuICAgICAgICBsYXlvdXQ6IGxheW91dFxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9LFxuXG4gIGxheW91dDogZnVuY3Rpb24gbGF5b3V0KG9wdGlvbnMpIHtcbiAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG4gICAgcmV0dXJuIGN5Lm1ha2VMYXlvdXQoZXh0ZW5kKHt9LCBvcHRpb25zLCB7XG4gICAgICBlbGVzOiB0aGlzXG4gICAgfSkpO1xuICB9XG59O1xuXG4vLyBhbGlhc2VzOlxuZWxlc2ZuJDUuY3JlYXRlTGF5b3V0ID0gZWxlc2ZuJDUubWFrZUxheW91dCA9IGVsZXNmbiQ1LmxheW91dDtcblxuZnVuY3Rpb24gc3R5bGVDYWNoZShrZXksIGZuLCBlbGUpIHtcbiAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuICB2YXIgY2FjaGUgPSBfcC5zdHlsZUNhY2hlID0gX3Auc3R5bGVDYWNoZSB8fCBbXTtcbiAgdmFyIHZhbDtcbiAgaWYgKCh2YWwgPSBjYWNoZVtrZXldKSAhPSBudWxsKSB7XG4gICAgcmV0dXJuIHZhbDtcbiAgfSBlbHNlIHtcbiAgICB2YWwgPSBjYWNoZVtrZXldID0gZm4oZWxlKTtcbiAgICByZXR1cm4gdmFsO1xuICB9XG59XG5mdW5jdGlvbiBjYWNoZVN0eWxlRnVuY3Rpb24oa2V5LCBmbikge1xuICBrZXkgPSBoYXNoU3RyaW5nKGtleSk7XG4gIHJldHVybiBmdW5jdGlvbiBjYWNoZWRTdHlsZUZ1bmN0aW9uKGVsZSkge1xuICAgIHJldHVybiBzdHlsZUNhY2hlKGtleSwgZm4sIGVsZSk7XG4gIH07XG59XG5mdW5jdGlvbiBjYWNoZVByb3RvdHlwZVN0eWxlRnVuY3Rpb24oa2V5LCBmbikge1xuICBrZXkgPSBoYXNoU3RyaW5nKGtleSk7XG4gIHZhciBzZWxmRm4gPSBmdW5jdGlvbiBzZWxmRm4oZWxlKSB7XG4gICAgcmV0dXJuIGZuLmNhbGwoZWxlKTtcbiAgfTtcbiAgcmV0dXJuIGZ1bmN0aW9uIGNhY2hlZFByb3RvdHlwZVN0eWxlRnVuY3Rpb24oKSB7XG4gICAgdmFyIGVsZSA9IHRoaXNbMF07XG4gICAgaWYgKGVsZSkge1xuICAgICAgcmV0dXJuIHN0eWxlQ2FjaGUoa2V5LCBzZWxmRm4sIGVsZSk7XG4gICAgfVxuICB9O1xufVxudmFyIGVsZXNmbiQ0ID0ge1xuICByZWNhbGN1bGF0ZVJlbmRlcmVkU3R5bGU6IGZ1bmN0aW9uIHJlY2FsY3VsYXRlUmVuZGVyZWRTdHlsZSh1c2VDYWNoZSkge1xuICAgIHZhciBjeSA9IHRoaXMuY3koKTtcbiAgICB2YXIgcmVuZGVyZXIgPSBjeS5yZW5kZXJlcigpO1xuICAgIHZhciBzdHlsZUVuYWJsZWQgPSBjeS5zdHlsZUVuYWJsZWQoKTtcbiAgICBpZiAocmVuZGVyZXIgJiYgc3R5bGVFbmFibGVkKSB7XG4gICAgICByZW5kZXJlci5yZWNhbGN1bGF0ZVJlbmRlcmVkU3R5bGUodGhpcywgdXNlQ2FjaGUpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgZGlydHlTdHlsZUNhY2hlOiBmdW5jdGlvbiBkaXJ0eVN0eWxlQ2FjaGUoKSB7XG4gICAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuICAgIHZhciBkaXJ0eSA9IGZ1bmN0aW9uIGRpcnR5KGVsZSkge1xuICAgICAgcmV0dXJuIGVsZS5fcHJpdmF0ZS5zdHlsZUNhY2hlID0gbnVsbDtcbiAgICB9O1xuICAgIGlmIChjeS5oYXNDb21wb3VuZE5vZGVzKCkpIHtcbiAgICAgIHZhciBlbGVzO1xuICAgICAgZWxlcyA9IHRoaXMuc3Bhd25TZWxmKCkubWVyZ2UodGhpcy5kZXNjZW5kYW50cygpKS5tZXJnZSh0aGlzLnBhcmVudHMoKSk7XG4gICAgICBlbGVzLm1lcmdlKGVsZXMuY29ubmVjdGVkRWRnZXMoKSk7XG4gICAgICBlbGVzLmZvckVhY2goZGlydHkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmZvckVhY2goZnVuY3Rpb24gKGVsZSkge1xuICAgICAgICBkaXJ0eShlbGUpO1xuICAgICAgICBlbGUuY29ubmVjdGVkRWRnZXMoKS5mb3JFYWNoKGRpcnR5KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgLy8gZnVsbHkgdXBkYXRlcyAocmVjYWxjdWxhdGVzKSB0aGUgc3R5bGUgZm9yIHRoZSBlbGVtZW50c1xuICB1cGRhdGVTdHlsZTogZnVuY3Rpb24gdXBkYXRlU3R5bGUobm90aWZ5UmVuZGVyZXIpIHtcbiAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5O1xuICAgIGlmICghY3kuc3R5bGVFbmFibGVkKCkpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBpZiAoY3kuYmF0Y2hpbmcoKSkge1xuICAgICAgdmFyIGJFbGVzID0gY3kuX3ByaXZhdGUuYmF0Y2hTdHlsZUVsZXM7XG4gICAgICBiRWxlcy5tZXJnZSh0aGlzKTtcbiAgICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZyBhbmQgZXhpdCBlYXJseSB3aGVuIGJhdGNoaW5nXG4gICAgfVxuXG4gICAgdmFyIGhhc0NvbXBvdW5kcyA9IGN5Lmhhc0NvbXBvdW5kTm9kZXMoKTtcbiAgICB2YXIgdXBkYXRlZEVsZXMgPSB0aGlzO1xuICAgIG5vdGlmeVJlbmRlcmVyID0gbm90aWZ5UmVuZGVyZXIgfHwgbm90aWZ5UmVuZGVyZXIgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBmYWxzZTtcbiAgICBpZiAoaGFzQ29tcG91bmRzKSB7XG4gICAgICAvLyB0aGVuIGFkZCBldmVyeXRoaW5nIHVwIGFuZCBkb3duIGZvciBjb21wb3VuZCBzZWxlY3RvciBjaGVja3NcbiAgICAgIHVwZGF0ZWRFbGVzID0gdGhpcy5zcGF3blNlbGYoKS5tZXJnZSh0aGlzLmRlc2NlbmRhbnRzKCkpLm1lcmdlKHRoaXMucGFyZW50cygpKTtcbiAgICB9XG5cbiAgICAvLyBsZXQgY2hhbmdlZEVsZXMgPSBzdHlsZS5hcHBseSggdXBkYXRlZEVsZXMgKTtcbiAgICB2YXIgY2hhbmdlZEVsZXMgPSB1cGRhdGVkRWxlcztcbiAgICBpZiAobm90aWZ5UmVuZGVyZXIpIHtcbiAgICAgIGNoYW5nZWRFbGVzLmVtaXRBbmROb3RpZnkoJ3N0eWxlJyk7IC8vIGxldCByZW5kZXJlciBrbm93IHdlIGNoYW5nZWQgc3R5bGVcbiAgICB9IGVsc2Uge1xuICAgICAgY2hhbmdlZEVsZXMuZW1pdCgnc3R5bGUnKTsgLy8ganVzdCBmaXJlIHRoZSBldmVudFxuICAgIH1cblxuICAgIHVwZGF0ZWRFbGVzLmZvckVhY2goZnVuY3Rpb24gKGVsZSkge1xuICAgICAgcmV0dXJuIGVsZS5fcHJpdmF0ZS5zdHlsZURpcnR5ID0gdHJ1ZTtcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfSxcblxuICAvLyBwcml2YXRlOiBjbGVhcnMgZGlydHkgZmxhZyBhbmQgcmVjYWxjdWxhdGVzIHN0eWxlXG4gIGNsZWFuU3R5bGU6IGZ1bmN0aW9uIGNsZWFuU3R5bGUoKSB7XG4gICAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuICAgIGlmICghY3kuc3R5bGVFbmFibGVkKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZWxlID0gdGhpc1tpXTtcbiAgICAgIGlmIChlbGUuX3ByaXZhdGUuc3R5bGVEaXJ0eSkge1xuICAgICAgICAvLyBuLmIuIHRoaXMgZmxhZyBzaG91bGQgYmUgc2V0IGJlZm9yZSBhcHBseSgpIHRvIGF2b2lkIHBvdGVudGlhbCBpbmZpbml0ZSByZWN1cnNpb25cbiAgICAgICAgZWxlLl9wcml2YXRlLnN0eWxlRGlydHkgPSBmYWxzZTtcbiAgICAgICAgY3kuc3R5bGUoKS5hcHBseShlbGUpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgLy8gZ2V0IHRoZSBpbnRlcm5hbCBwYXJzZWQgc3R5bGUgb2JqZWN0IGZvciB0aGUgc3BlY2lmaWVkIHByb3BlcnR5XG4gIHBhcnNlZFN0eWxlOiBmdW5jdGlvbiBwYXJzZWRTdHlsZShwcm9wZXJ0eSkge1xuICAgIHZhciBpbmNsdWRlTm9uRGVmYXVsdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdHJ1ZTtcbiAgICB2YXIgZWxlID0gdGhpc1swXTtcbiAgICB2YXIgY3kgPSBlbGUuY3koKTtcbiAgICBpZiAoIWN5LnN0eWxlRW5hYmxlZCgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChlbGUpIHtcbiAgICAgIHRoaXMuY2xlYW5TdHlsZSgpO1xuICAgICAgdmFyIG92ZXJyaWRkZW5TdHlsZSA9IGVsZS5fcHJpdmF0ZS5zdHlsZVtwcm9wZXJ0eV07XG4gICAgICBpZiAob3ZlcnJpZGRlblN0eWxlICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG92ZXJyaWRkZW5TdHlsZTtcbiAgICAgIH0gZWxzZSBpZiAoaW5jbHVkZU5vbkRlZmF1bHQpIHtcbiAgICAgICAgcmV0dXJuIGN5LnN0eWxlKCkuZ2V0RGVmYXVsdFByb3BlcnR5KHByb3BlcnR5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgbnVtZXJpY1N0eWxlOiBmdW5jdGlvbiBudW1lcmljU3R5bGUocHJvcGVydHkpIHtcbiAgICB2YXIgZWxlID0gdGhpc1swXTtcbiAgICBpZiAoIWVsZS5jeSgpLnN0eWxlRW5hYmxlZCgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChlbGUpIHtcbiAgICAgIHZhciBwc3R5bGUgPSBlbGUucHN0eWxlKHByb3BlcnR5KTtcbiAgICAgIHJldHVybiBwc3R5bGUucGZWYWx1ZSAhPT0gdW5kZWZpbmVkID8gcHN0eWxlLnBmVmFsdWUgOiBwc3R5bGUudmFsdWU7XG4gICAgfVxuICB9LFxuICBudW1lcmljU3R5bGVVbml0czogZnVuY3Rpb24gbnVtZXJpY1N0eWxlVW5pdHMocHJvcGVydHkpIHtcbiAgICB2YXIgZWxlID0gdGhpc1swXTtcbiAgICBpZiAoIWVsZS5jeSgpLnN0eWxlRW5hYmxlZCgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChlbGUpIHtcbiAgICAgIHJldHVybiBlbGUucHN0eWxlKHByb3BlcnR5KS51bml0cztcbiAgICB9XG4gIH0sXG4gIC8vIGdldCB0aGUgc3BlY2lmaWVkIGNzcyBwcm9wZXJ0eSBhcyBhIHJlbmRlcmVkIHZhbHVlIChpLmUuIG9uLXNjcmVlbiB2YWx1ZSlcbiAgLy8gb3IgZ2V0IHRoZSB3aG9sZSByZW5kZXJlZCBzdHlsZSBpZiBubyBwcm9wZXJ0eSBzcGVjaWZpZWQgKE5CIGRvZXNuJ3QgYWxsb3cgc2V0dGluZylcbiAgcmVuZGVyZWRTdHlsZTogZnVuY3Rpb24gcmVuZGVyZWRTdHlsZShwcm9wZXJ0eSkge1xuICAgIHZhciBjeSA9IHRoaXMuY3koKTtcbiAgICBpZiAoIWN5LnN0eWxlRW5hYmxlZCgpKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdmFyIGVsZSA9IHRoaXNbMF07XG4gICAgaWYgKGVsZSkge1xuICAgICAgcmV0dXJuIGN5LnN0eWxlKCkuZ2V0UmVuZGVyZWRTdHlsZShlbGUsIHByb3BlcnR5KTtcbiAgICB9XG4gIH0sXG4gIC8vIHJlYWQgdGhlIGNhbGN1bGF0ZWQgY3NzIHN0eWxlIG9mIHRoZSBlbGVtZW50IG9yIG92ZXJyaWRlIHRoZSBzdHlsZSAodmlhIGEgYnlwYXNzKVxuICBzdHlsZTogZnVuY3Rpb24gc3R5bGUobmFtZSwgdmFsdWUpIHtcbiAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG4gICAgaWYgKCFjeS5zdHlsZUVuYWJsZWQoKSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHZhciB1cGRhdGVUcmFuc2l0aW9ucyA9IGZhbHNlO1xuICAgIHZhciBzdHlsZSA9IGN5LnN0eWxlKCk7XG4gICAgaWYgKHBsYWluT2JqZWN0KG5hbWUpKSB7XG4gICAgICAvLyB0aGVuIGV4dGVuZCB0aGUgYnlwYXNzXG4gICAgICB2YXIgcHJvcHMgPSBuYW1lO1xuICAgICAgc3R5bGUuYXBwbHlCeXBhc3ModGhpcywgcHJvcHMsIHVwZGF0ZVRyYW5zaXRpb25zKTtcbiAgICAgIHRoaXMuZW1pdEFuZE5vdGlmeSgnc3R5bGUnKTsgLy8gbGV0IHRoZSByZW5kZXJlciBrbm93IHdlJ3ZlIHVwZGF0ZWQgc3R5bGVcbiAgICB9IGVsc2UgaWYgKHN0cmluZyhuYW1lKSkge1xuICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gdGhlbiBnZXQgdGhlIHByb3BlcnR5IGZyb20gdGhlIHN0eWxlXG4gICAgICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuICAgICAgICBpZiAoZWxlKSB7XG4gICAgICAgICAgcmV0dXJuIHN0eWxlLmdldFN0eWxlUHJvcGVydHlWYWx1ZShlbGUsIG5hbWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGVtcHR5IGNvbGxlY3Rpb24gPT4gY2FuJ3QgZ2V0IGFueSB2YWx1ZVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gdGhlbiBzZXQgdGhlIGJ5cGFzcyB3aXRoIHRoZSBwcm9wZXJ0eSB2YWx1ZVxuICAgICAgICBzdHlsZS5hcHBseUJ5cGFzcyh0aGlzLCBuYW1lLCB2YWx1ZSwgdXBkYXRlVHJhbnNpdGlvbnMpO1xuICAgICAgICB0aGlzLmVtaXRBbmROb3RpZnkoJ3N0eWxlJyk7IC8vIGxldCB0aGUgcmVuZGVyZXIga25vdyB3ZSd2ZSB1cGRhdGVkIHN0eWxlXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChuYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhciBfZWxlID0gdGhpc1swXTtcbiAgICAgIGlmIChfZWxlKSB7XG4gICAgICAgIHJldHVybiBzdHlsZS5nZXRSYXdTdHlsZShfZWxlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGVtcHR5IGNvbGxlY3Rpb24gPT4gY2FuJ3QgZ2V0IGFueSB2YWx1ZVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9LFxuXG4gIHJlbW92ZVN0eWxlOiBmdW5jdGlvbiByZW1vdmVTdHlsZShuYW1lcykge1xuICAgIHZhciBjeSA9IHRoaXMuY3koKTtcbiAgICBpZiAoIWN5LnN0eWxlRW5hYmxlZCgpKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdmFyIHVwZGF0ZVRyYW5zaXRpb25zID0gZmFsc2U7XG4gICAgdmFyIHN0eWxlID0gY3kuc3R5bGUoKTtcbiAgICB2YXIgZWxlcyA9IHRoaXM7XG4gICAgaWYgKG5hbWVzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZWxlID0gZWxlc1tpXTtcbiAgICAgICAgc3R5bGUucmVtb3ZlQWxsQnlwYXNzZXMoZWxlLCB1cGRhdGVUcmFuc2l0aW9ucyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG5hbWVzID0gbmFtZXMuc3BsaXQoL1xccysvKTtcbiAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBlbGVzLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgX2VsZTIgPSBlbGVzW19pXTtcbiAgICAgICAgc3R5bGUucmVtb3ZlQnlwYXNzZXMoX2VsZTIsIG5hbWVzLCB1cGRhdGVUcmFuc2l0aW9ucyk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuZW1pdEFuZE5vdGlmeSgnc3R5bGUnKTsgLy8gbGV0IHRoZSByZW5kZXJlciBrbm93IHdlJ3ZlIHVwZGF0ZWQgc3R5bGVcblxuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9LFxuXG4gIHNob3c6IGZ1bmN0aW9uIHNob3coKSB7XG4gICAgdGhpcy5jc3MoJ2Rpc3BsYXknLCAnZWxlbWVudCcpO1xuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9LFxuXG4gIGhpZGU6IGZ1bmN0aW9uIGhpZGUoKSB7XG4gICAgdGhpcy5jc3MoJ2Rpc3BsYXknLCAnbm9uZScpO1xuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9LFxuXG4gIGVmZmVjdGl2ZU9wYWNpdHk6IGZ1bmN0aW9uIGVmZmVjdGl2ZU9wYWNpdHkoKSB7XG4gICAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuICAgIGlmICghY3kuc3R5bGVFbmFibGVkKCkpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICB2YXIgaGFzQ29tcG91bmROb2RlcyA9IGN5Lmhhc0NvbXBvdW5kTm9kZXMoKTtcbiAgICB2YXIgZWxlID0gdGhpc1swXTtcbiAgICBpZiAoZWxlKSB7XG4gICAgICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gICAgICB2YXIgcGFyZW50T3BhY2l0eSA9IGVsZS5wc3R5bGUoJ29wYWNpdHknKS52YWx1ZTtcbiAgICAgIGlmICghaGFzQ29tcG91bmROb2Rlcykge1xuICAgICAgICByZXR1cm4gcGFyZW50T3BhY2l0eTtcbiAgICAgIH1cbiAgICAgIHZhciBwYXJlbnRzID0gIV9wLmRhdGEucGFyZW50ID8gbnVsbCA6IGVsZS5wYXJlbnRzKCk7XG4gICAgICBpZiAocGFyZW50cykge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcmVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgcGFyZW50ID0gcGFyZW50c1tpXTtcbiAgICAgICAgICB2YXIgb3BhY2l0eSA9IHBhcmVudC5wc3R5bGUoJ29wYWNpdHknKS52YWx1ZTtcbiAgICAgICAgICBwYXJlbnRPcGFjaXR5ID0gb3BhY2l0eSAqIHBhcmVudE9wYWNpdHk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXJlbnRPcGFjaXR5O1xuICAgIH1cbiAgfSxcbiAgdHJhbnNwYXJlbnQ6IGZ1bmN0aW9uIHRyYW5zcGFyZW50KCkge1xuICAgIHZhciBjeSA9IHRoaXMuY3koKTtcbiAgICBpZiAoIWN5LnN0eWxlRW5hYmxlZCgpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuICAgIHZhciBoYXNDb21wb3VuZE5vZGVzID0gZWxlLmN5KCkuaGFzQ29tcG91bmROb2RlcygpO1xuICAgIGlmIChlbGUpIHtcbiAgICAgIGlmICghaGFzQ29tcG91bmROb2Rlcykge1xuICAgICAgICByZXR1cm4gZWxlLnBzdHlsZSgnb3BhY2l0eScpLnZhbHVlID09PSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGVsZS5lZmZlY3RpdmVPcGFjaXR5KCkgPT09IDA7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBiYWNrZ3JvdW5kaW5nOiBmdW5jdGlvbiBiYWNrZ3JvdW5kaW5nKCkge1xuICAgIHZhciBjeSA9IHRoaXMuY3koKTtcbiAgICBpZiAoIWN5LnN0eWxlRW5hYmxlZCgpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuICAgIHJldHVybiBlbGUuX3ByaXZhdGUuYmFja2dyb3VuZGluZyA/IHRydWUgOiBmYWxzZTtcbiAgfVxufTtcbmZ1bmN0aW9uIGNoZWNrQ29tcG91bmQoZWxlLCBwYXJlbnRPaykge1xuICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gIHZhciBwYXJlbnRzID0gX3AuZGF0YS5wYXJlbnQgPyBlbGUucGFyZW50cygpIDogbnVsbDtcbiAgaWYgKHBhcmVudHMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcmVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBwYXJlbnQgPSBwYXJlbnRzW2ldO1xuICAgICAgaWYgKCFwYXJlbnRPayhwYXJlbnQpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBkZWZpbmVEZXJpdmVkU3RhdGVGdW5jdGlvbihzcGVjcykge1xuICB2YXIgb2sgPSBzcGVjcy5vaztcbiAgdmFyIGVkZ2VPa1ZpYU5vZGUgPSBzcGVjcy5lZGdlT2tWaWFOb2RlIHx8IHNwZWNzLm9rO1xuICB2YXIgcGFyZW50T2sgPSBzcGVjcy5wYXJlbnRPayB8fCBzcGVjcy5vaztcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG4gICAgaWYgKCFjeS5zdHlsZUVuYWJsZWQoKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuICAgIHZhciBoYXNDb21wb3VuZE5vZGVzID0gY3kuaGFzQ29tcG91bmROb2RlcygpO1xuICAgIGlmIChlbGUpIHtcbiAgICAgIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgICAgIGlmICghb2soZWxlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoZWxlLmlzTm9kZSgpKSB7XG4gICAgICAgIHJldHVybiAhaGFzQ29tcG91bmROb2RlcyB8fCBjaGVja0NvbXBvdW5kKGVsZSwgcGFyZW50T2spO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHNyYyA9IF9wLnNvdXJjZTtcbiAgICAgICAgdmFyIHRndCA9IF9wLnRhcmdldDtcbiAgICAgICAgcmV0dXJuIGVkZ2VPa1ZpYU5vZGUoc3JjKSAmJiAoIWhhc0NvbXBvdW5kTm9kZXMgfHwgY2hlY2tDb21wb3VuZChzcmMsIGVkZ2VPa1ZpYU5vZGUpKSAmJiAoc3JjID09PSB0Z3QgfHwgZWRnZU9rVmlhTm9kZSh0Z3QpICYmICghaGFzQ29tcG91bmROb2RlcyB8fCBjaGVja0NvbXBvdW5kKHRndCwgZWRnZU9rVmlhTm9kZSkpKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG52YXIgZWxlVGFrZXNVcFNwYWNlID0gY2FjaGVTdHlsZUZ1bmN0aW9uKCdlbGVUYWtlc1VwU3BhY2UnLCBmdW5jdGlvbiAoZWxlKSB7XG4gIHJldHVybiBlbGUucHN0eWxlKCdkaXNwbGF5JykudmFsdWUgPT09ICdlbGVtZW50JyAmJiBlbGUud2lkdGgoKSAhPT0gMCAmJiAoZWxlLmlzTm9kZSgpID8gZWxlLmhlaWdodCgpICE9PSAwIDogdHJ1ZSk7XG59KTtcbmVsZXNmbiQ0LnRha2VzVXBTcGFjZSA9IGNhY2hlUHJvdG90eXBlU3R5bGVGdW5jdGlvbigndGFrZXNVcFNwYWNlJywgZGVmaW5lRGVyaXZlZFN0YXRlRnVuY3Rpb24oe1xuICBvazogZWxlVGFrZXNVcFNwYWNlXG59KSk7XG52YXIgZWxlSW50ZXJhY3RpdmUgPSBjYWNoZVN0eWxlRnVuY3Rpb24oJ2VsZUludGVyYWN0aXZlJywgZnVuY3Rpb24gKGVsZSkge1xuICByZXR1cm4gZWxlLnBzdHlsZSgnZXZlbnRzJykudmFsdWUgPT09ICd5ZXMnICYmIGVsZS5wc3R5bGUoJ3Zpc2liaWxpdHknKS52YWx1ZSA9PT0gJ3Zpc2libGUnICYmIGVsZVRha2VzVXBTcGFjZShlbGUpO1xufSk7XG52YXIgcGFyZW50SW50ZXJhY3RpdmUgPSBjYWNoZVN0eWxlRnVuY3Rpb24oJ3BhcmVudEludGVyYWN0aXZlJywgZnVuY3Rpb24gKHBhcmVudCkge1xuICByZXR1cm4gcGFyZW50LnBzdHlsZSgndmlzaWJpbGl0eScpLnZhbHVlID09PSAndmlzaWJsZScgJiYgZWxlVGFrZXNVcFNwYWNlKHBhcmVudCk7XG59KTtcbmVsZXNmbiQ0LmludGVyYWN0aXZlID0gY2FjaGVQcm90b3R5cGVTdHlsZUZ1bmN0aW9uKCdpbnRlcmFjdGl2ZScsIGRlZmluZURlcml2ZWRTdGF0ZUZ1bmN0aW9uKHtcbiAgb2s6IGVsZUludGVyYWN0aXZlLFxuICBwYXJlbnRPazogcGFyZW50SW50ZXJhY3RpdmUsXG4gIGVkZ2VPa1ZpYU5vZGU6IGVsZVRha2VzVXBTcGFjZVxufSkpO1xuZWxlc2ZuJDQubm9uaW50ZXJhY3RpdmUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBlbGUgPSB0aGlzWzBdO1xuICBpZiAoZWxlKSB7XG4gICAgcmV0dXJuICFlbGUuaW50ZXJhY3RpdmUoKTtcbiAgfVxufTtcbnZhciBlbGVWaXNpYmxlID0gY2FjaGVTdHlsZUZ1bmN0aW9uKCdlbGVWaXNpYmxlJywgZnVuY3Rpb24gKGVsZSkge1xuICByZXR1cm4gZWxlLnBzdHlsZSgndmlzaWJpbGl0eScpLnZhbHVlID09PSAndmlzaWJsZScgJiYgZWxlLnBzdHlsZSgnb3BhY2l0eScpLnBmVmFsdWUgIT09IDAgJiYgZWxlVGFrZXNVcFNwYWNlKGVsZSk7XG59KTtcbnZhciBlZGdlVmlzaWJsZVZpYU5vZGUgPSBlbGVUYWtlc1VwU3BhY2U7XG5lbGVzZm4kNC52aXNpYmxlID0gY2FjaGVQcm90b3R5cGVTdHlsZUZ1bmN0aW9uKCd2aXNpYmxlJywgZGVmaW5lRGVyaXZlZFN0YXRlRnVuY3Rpb24oe1xuICBvazogZWxlVmlzaWJsZSxcbiAgZWRnZU9rVmlhTm9kZTogZWRnZVZpc2libGVWaWFOb2RlXG59KSk7XG5lbGVzZm4kNC5oaWRkZW4gPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBlbGUgPSB0aGlzWzBdO1xuICBpZiAoZWxlKSB7XG4gICAgcmV0dXJuICFlbGUudmlzaWJsZSgpO1xuICB9XG59O1xuZWxlc2ZuJDQuaXNCdW5kbGVkQmV6aWVyID0gY2FjaGVQcm90b3R5cGVTdHlsZUZ1bmN0aW9uKCdpc0J1bmRsZWRCZXppZXInLCBmdW5jdGlvbiAoKSB7XG4gIGlmICghdGhpcy5jeSgpLnN0eWxlRW5hYmxlZCgpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiAhdGhpcy5yZW1vdmVkKCkgJiYgdGhpcy5wc3R5bGUoJ2N1cnZlLXN0eWxlJykudmFsdWUgPT09ICdiZXppZXInICYmIHRoaXMudGFrZXNVcFNwYWNlKCk7XG59KTtcbmVsZXNmbiQ0LmJ5cGFzcyA9IGVsZXNmbiQ0LmNzcyA9IGVsZXNmbiQ0LnN0eWxlO1xuZWxlc2ZuJDQucmVuZGVyZWRDc3MgPSBlbGVzZm4kNC5yZW5kZXJlZFN0eWxlO1xuZWxlc2ZuJDQucmVtb3ZlQnlwYXNzID0gZWxlc2ZuJDQucmVtb3ZlQ3NzID0gZWxlc2ZuJDQucmVtb3ZlU3R5bGU7XG5lbGVzZm4kNC5wc3R5bGUgPSBlbGVzZm4kNC5wYXJzZWRTdHlsZTtcblxudmFyIGVsZXNmbiQzID0ge307XG5mdW5jdGlvbiBkZWZpbmVTd2l0Y2hGdW5jdGlvbihwYXJhbXMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICB2YXIgY2hhbmdlZEVsZXMgPSBbXTtcblxuICAgIC8vIGUuZy4gY3kubm9kZXMoKS5zZWxlY3QoIGRhdGEsIGhhbmRsZXIgKVxuICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMikge1xuICAgICAgdmFyIGRhdGEgPSBhcmdzWzBdO1xuICAgICAgdmFyIGhhbmRsZXIgPSBhcmdzWzFdO1xuICAgICAgdGhpcy5vbihwYXJhbXMuZXZlbnQsIGRhdGEsIGhhbmRsZXIpO1xuICAgIH1cblxuICAgIC8vIGUuZy4gY3kubm9kZXMoKS5zZWxlY3QoIGhhbmRsZXIgKVxuICAgIGVsc2UgaWYgKGFyZ3MubGVuZ3RoID09PSAxICYmIGZuJDYoYXJnc1swXSkpIHtcbiAgICAgIHZhciBfaGFuZGxlciA9IGFyZ3NbMF07XG4gICAgICB0aGlzLm9uKHBhcmFtcy5ldmVudCwgX2hhbmRsZXIpO1xuICAgIH1cblxuICAgIC8vIGUuZy4gY3kubm9kZXMoKS5zZWxlY3QoKVxuICAgIC8vIGUuZy4gKHByaXZhdGUpIGN5Lm5vZGVzKCkuc2VsZWN0KFsndGFwc2VsZWN0J10pXG4gICAgZWxzZSBpZiAoYXJncy5sZW5ndGggPT09IDAgfHwgYXJncy5sZW5ndGggPT09IDEgJiYgYXJyYXkoYXJnc1swXSkpIHtcbiAgICAgIHZhciBhZGRsRXZlbnRzID0gYXJncy5sZW5ndGggPT09IDEgPyBhcmdzWzBdIDogbnVsbDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZWxlID0gdGhpc1tpXTtcbiAgICAgICAgdmFyIGFibGUgPSAhcGFyYW1zLmFibGVGaWVsZCB8fCBlbGUuX3ByaXZhdGVbcGFyYW1zLmFibGVGaWVsZF07XG4gICAgICAgIHZhciBjaGFuZ2VkID0gZWxlLl9wcml2YXRlW3BhcmFtcy5maWVsZF0gIT0gcGFyYW1zLnZhbHVlO1xuICAgICAgICBpZiAocGFyYW1zLm92ZXJyaWRlQWJsZSkge1xuICAgICAgICAgIHZhciBvdmVycmlkZUFibGUgPSBwYXJhbXMub3ZlcnJpZGVBYmxlKGVsZSk7XG4gICAgICAgICAgaWYgKG92ZXJyaWRlQWJsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBhYmxlID0gb3ZlcnJpZGVBYmxlO1xuICAgICAgICAgICAgaWYgKCFvdmVycmlkZUFibGUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9IC8vIHRvIHNhdmUgY3ljbGVzIGFzc3VtZSBub3QgYWJsZSBmb3IgYWxsIG9uIG92ZXJyaWRlXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGFibGUpIHtcbiAgICAgICAgICBlbGUuX3ByaXZhdGVbcGFyYW1zLmZpZWxkXSA9IHBhcmFtcy52YWx1ZTtcbiAgICAgICAgICBpZiAoY2hhbmdlZCkge1xuICAgICAgICAgICAgY2hhbmdlZEVsZXMucHVzaChlbGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIGNoYW5nZWRDb2xsID0gdGhpcy5zcGF3bihjaGFuZ2VkRWxlcyk7XG4gICAgICBjaGFuZ2VkQ29sbC51cGRhdGVTdHlsZSgpOyAvLyBjaGFuZ2Ugb2Ygc3RhdGUgPT4gcG9zc2libGUgY2hhbmdlIG9mIHN0eWxlXG4gICAgICBjaGFuZ2VkQ29sbC5lbWl0KHBhcmFtcy5ldmVudCk7XG4gICAgICBpZiAoYWRkbEV2ZW50cykge1xuICAgICAgICBjaGFuZ2VkQ29sbC5lbWl0KGFkZGxFdmVudHMpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbn1cbmZ1bmN0aW9uIGRlZmluZVN3aXRjaFNldChwYXJhbXMpIHtcbiAgZWxlc2ZuJDNbcGFyYW1zLmZpZWxkXSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZWxlID0gdGhpc1swXTtcbiAgICBpZiAoZWxlKSB7XG4gICAgICBpZiAocGFyYW1zLm92ZXJyaWRlRmllbGQpIHtcbiAgICAgICAgdmFyIHZhbCA9IHBhcmFtcy5vdmVycmlkZUZpZWxkKGVsZSk7XG4gICAgICAgIGlmICh2YWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBlbGUuX3ByaXZhdGVbcGFyYW1zLmZpZWxkXTtcbiAgICB9XG4gIH07XG4gIGVsZXNmbiQzW3BhcmFtcy5vbl0gPSBkZWZpbmVTd2l0Y2hGdW5jdGlvbih7XG4gICAgZXZlbnQ6IHBhcmFtcy5vbixcbiAgICBmaWVsZDogcGFyYW1zLmZpZWxkLFxuICAgIGFibGVGaWVsZDogcGFyYW1zLmFibGVGaWVsZCxcbiAgICBvdmVycmlkZUFibGU6IHBhcmFtcy5vdmVycmlkZUFibGUsXG4gICAgdmFsdWU6IHRydWVcbiAgfSk7XG4gIGVsZXNmbiQzW3BhcmFtcy5vZmZdID0gZGVmaW5lU3dpdGNoRnVuY3Rpb24oe1xuICAgIGV2ZW50OiBwYXJhbXMub2ZmLFxuICAgIGZpZWxkOiBwYXJhbXMuZmllbGQsXG4gICAgYWJsZUZpZWxkOiBwYXJhbXMuYWJsZUZpZWxkLFxuICAgIG92ZXJyaWRlQWJsZTogcGFyYW1zLm92ZXJyaWRlQWJsZSxcbiAgICB2YWx1ZTogZmFsc2VcbiAgfSk7XG59XG5kZWZpbmVTd2l0Y2hTZXQoe1xuICBmaWVsZDogJ2xvY2tlZCcsXG4gIG92ZXJyaWRlRmllbGQ6IGZ1bmN0aW9uIG92ZXJyaWRlRmllbGQoZWxlKSB7XG4gICAgcmV0dXJuIGVsZS5jeSgpLmF1dG9sb2NrKCkgPyB0cnVlIDogdW5kZWZpbmVkO1xuICB9LFxuICBvbjogJ2xvY2snLFxuICBvZmY6ICd1bmxvY2snXG59KTtcbmRlZmluZVN3aXRjaFNldCh7XG4gIGZpZWxkOiAnZ3JhYmJhYmxlJyxcbiAgb3ZlcnJpZGVGaWVsZDogZnVuY3Rpb24gb3ZlcnJpZGVGaWVsZChlbGUpIHtcbiAgICByZXR1cm4gZWxlLmN5KCkuYXV0b3VuZ3JhYmlmeSgpIHx8IGVsZS5wYW5uYWJsZSgpID8gZmFsc2UgOiB1bmRlZmluZWQ7XG4gIH0sXG4gIG9uOiAnZ3JhYmlmeScsXG4gIG9mZjogJ3VuZ3JhYmlmeSdcbn0pO1xuZGVmaW5lU3dpdGNoU2V0KHtcbiAgZmllbGQ6ICdzZWxlY3RlZCcsXG4gIGFibGVGaWVsZDogJ3NlbGVjdGFibGUnLFxuICBvdmVycmlkZUFibGU6IGZ1bmN0aW9uIG92ZXJyaWRlQWJsZShlbGUpIHtcbiAgICByZXR1cm4gZWxlLmN5KCkuYXV0b3Vuc2VsZWN0aWZ5KCkgPyBmYWxzZSA6IHVuZGVmaW5lZDtcbiAgfSxcbiAgb246ICdzZWxlY3QnLFxuICBvZmY6ICd1bnNlbGVjdCdcbn0pO1xuZGVmaW5lU3dpdGNoU2V0KHtcbiAgZmllbGQ6ICdzZWxlY3RhYmxlJyxcbiAgb3ZlcnJpZGVGaWVsZDogZnVuY3Rpb24gb3ZlcnJpZGVGaWVsZChlbGUpIHtcbiAgICByZXR1cm4gZWxlLmN5KCkuYXV0b3Vuc2VsZWN0aWZ5KCkgPyBmYWxzZSA6IHVuZGVmaW5lZDtcbiAgfSxcbiAgb246ICdzZWxlY3RpZnknLFxuICBvZmY6ICd1bnNlbGVjdGlmeSdcbn0pO1xuZWxlc2ZuJDMuZGVzZWxlY3QgPSBlbGVzZm4kMy51bnNlbGVjdDtcbmVsZXNmbiQzLmdyYWJiZWQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBlbGUgPSB0aGlzWzBdO1xuICBpZiAoZWxlKSB7XG4gICAgcmV0dXJuIGVsZS5fcHJpdmF0ZS5ncmFiYmVkO1xuICB9XG59O1xuZGVmaW5lU3dpdGNoU2V0KHtcbiAgZmllbGQ6ICdhY3RpdmUnLFxuICBvbjogJ2FjdGl2YXRlJyxcbiAgb2ZmOiAndW5hY3RpdmF0ZSdcbn0pO1xuZGVmaW5lU3dpdGNoU2V0KHtcbiAgZmllbGQ6ICdwYW5uYWJsZScsXG4gIG9uOiAncGFuaWZ5JyxcbiAgb2ZmOiAndW5wYW5pZnknXG59KTtcbmVsZXNmbiQzLmluYWN0aXZlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgZWxlID0gdGhpc1swXTtcbiAgaWYgKGVsZSkge1xuICAgIHJldHVybiAhZWxlLl9wcml2YXRlLmFjdGl2ZTtcbiAgfVxufTtcblxudmFyIGVsZXNmbiQyID0ge307XG5cbi8vIERBRyBmdW5jdGlvbnNcbi8vLy8vLy8vLy8vLy8vLy9cblxudmFyIGRlZmluZURhZ0V4dHJlbWl0eSA9IGZ1bmN0aW9uIGRlZmluZURhZ0V4dHJlbWl0eShwYXJhbXMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGRhZ0V4dHJlbWl0eUltcGwoc2VsZWN0b3IpIHtcbiAgICB2YXIgZWxlcyA9IHRoaXM7XG4gICAgdmFyIHJldCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGVsZSA9IGVsZXNbaV07XG4gICAgICBpZiAoIWVsZS5pc05vZGUoKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHZhciBkaXNxdWFsaWZpZWQgPSBmYWxzZTtcbiAgICAgIHZhciBlZGdlcyA9IGVsZS5jb25uZWN0ZWRFZGdlcygpO1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBlZGdlcy5sZW5ndGg7IGorKykge1xuICAgICAgICB2YXIgZWRnZSA9IGVkZ2VzW2pdO1xuICAgICAgICB2YXIgc3JjID0gZWRnZS5zb3VyY2UoKTtcbiAgICAgICAgdmFyIHRndCA9IGVkZ2UudGFyZ2V0KCk7XG4gICAgICAgIGlmIChwYXJhbXMubm9JbmNvbWluZ0VkZ2VzICYmIHRndCA9PT0gZWxlICYmIHNyYyAhPT0gZWxlIHx8IHBhcmFtcy5ub091dGdvaW5nRWRnZXMgJiYgc3JjID09PSBlbGUgJiYgdGd0ICE9PSBlbGUpIHtcbiAgICAgICAgICBkaXNxdWFsaWZpZWQgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIWRpc3F1YWxpZmllZCkge1xuICAgICAgICByZXQucHVzaChlbGUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5zcGF3bihyZXQsIHRydWUpLmZpbHRlcihzZWxlY3Rvcik7XG4gIH07XG59O1xudmFyIGRlZmluZURhZ09uZUhvcCA9IGZ1bmN0aW9uIGRlZmluZURhZ09uZUhvcChwYXJhbXMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuICAgIHZhciBlbGVzID0gdGhpcztcbiAgICB2YXIgb0VsZXMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBlbGUgPSBlbGVzW2ldO1xuICAgICAgaWYgKCFlbGUuaXNOb2RlKCkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB2YXIgZWRnZXMgPSBlbGUuY29ubmVjdGVkRWRnZXMoKTtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZWRnZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgdmFyIGVkZ2UgPSBlZGdlc1tqXTtcbiAgICAgICAgdmFyIHNyYyA9IGVkZ2Uuc291cmNlKCk7XG4gICAgICAgIHZhciB0Z3QgPSBlZGdlLnRhcmdldCgpO1xuICAgICAgICBpZiAocGFyYW1zLm91dGdvaW5nICYmIHNyYyA9PT0gZWxlKSB7XG4gICAgICAgICAgb0VsZXMucHVzaChlZGdlKTtcbiAgICAgICAgICBvRWxlcy5wdXNoKHRndCk7XG4gICAgICAgIH0gZWxzZSBpZiAocGFyYW1zLmluY29taW5nICYmIHRndCA9PT0gZWxlKSB7XG4gICAgICAgICAgb0VsZXMucHVzaChlZGdlKTtcbiAgICAgICAgICBvRWxlcy5wdXNoKHNyYyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuc3Bhd24ob0VsZXMsIHRydWUpLmZpbHRlcihzZWxlY3Rvcik7XG4gIH07XG59O1xudmFyIGRlZmluZURhZ0FsbEhvcHMgPSBmdW5jdGlvbiBkZWZpbmVEYWdBbGxIb3BzKHBhcmFtcykge1xuICByZXR1cm4gZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG4gICAgdmFyIGVsZXMgPSB0aGlzO1xuICAgIHZhciBzRWxlcyA9IFtdO1xuICAgIHZhciBzRWxlc0lkcyA9IHt9O1xuICAgIGZvciAoOzspIHtcbiAgICAgIHZhciBuZXh0ID0gcGFyYW1zLm91dGdvaW5nID8gZWxlcy5vdXRnb2VycygpIDogZWxlcy5pbmNvbWVycygpO1xuICAgICAgaWYgKG5leHQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSAvLyBkb25lIGlmIG5vbmUgbGVmdFxuXG4gICAgICB2YXIgbmV3TmV4dCA9IGZhbHNlO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuZXh0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBuID0gbmV4dFtpXTtcbiAgICAgICAgdmFyIG5pZCA9IG4uaWQoKTtcbiAgICAgICAgaWYgKCFzRWxlc0lkc1tuaWRdKSB7XG4gICAgICAgICAgc0VsZXNJZHNbbmlkXSA9IHRydWU7XG4gICAgICAgICAgc0VsZXMucHVzaChuKTtcbiAgICAgICAgICBuZXdOZXh0ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFuZXdOZXh0KSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSAvLyBkb25lIGlmIHRvdWNoZWQgYWxsIG91dGdvZXJzIGFscmVhZHlcblxuICAgICAgZWxlcyA9IG5leHQ7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnNwYXduKHNFbGVzLCB0cnVlKS5maWx0ZXIoc2VsZWN0b3IpO1xuICB9O1xufTtcbmVsZXNmbiQyLmNsZWFyVHJhdmVyc2FsQ2FjaGUgPSBmdW5jdGlvbiAoKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgIHRoaXNbaV0uX3ByaXZhdGUudHJhdmVyc2FsQ2FjaGUgPSBudWxsO1xuICB9XG59O1xuZXh0ZW5kKGVsZXNmbiQyLCB7XG4gIC8vIGdldCB0aGUgcm9vdCBub2RlcyBpbiB0aGUgREFHXG4gIHJvb3RzOiBkZWZpbmVEYWdFeHRyZW1pdHkoe1xuICAgIG5vSW5jb21pbmdFZGdlczogdHJ1ZVxuICB9KSxcbiAgLy8gZ2V0IHRoZSBsZWFmIG5vZGVzIGluIHRoZSBEQUdcbiAgbGVhdmVzOiBkZWZpbmVEYWdFeHRyZW1pdHkoe1xuICAgIG5vT3V0Z29pbmdFZGdlczogdHJ1ZVxuICB9KSxcbiAgLy8gbm9ybWFsbHkgY2FsbGVkIGNoaWxkcmVuIGluIGdyYXBoIHRoZW9yeVxuICAvLyB0aGVzZSBub2RlcyA9ZWRnZXM9PiBvdXRnb2luZyBub2Rlc1xuICBvdXRnb2VyczogY2FjaGUoZGVmaW5lRGFnT25lSG9wKHtcbiAgICBvdXRnb2luZzogdHJ1ZVxuICB9KSwgJ291dGdvZXJzJyksXG4gIC8vIGFrYSBEQUcgZGVzY2VuZGFudHNcbiAgc3VjY2Vzc29yczogZGVmaW5lRGFnQWxsSG9wcyh7XG4gICAgb3V0Z29pbmc6IHRydWVcbiAgfSksXG4gIC8vIG5vcm1hbGx5IGNhbGxlZCBwYXJlbnRzIGluIGdyYXBoIHRoZW9yeVxuICAvLyB0aGVzZSBub2RlcyA8PWVkZ2VzPSBpbmNvbWluZyBub2Rlc1xuICBpbmNvbWVyczogY2FjaGUoZGVmaW5lRGFnT25lSG9wKHtcbiAgICBpbmNvbWluZzogdHJ1ZVxuICB9KSwgJ2luY29tZXJzJyksXG4gIC8vIGFrYSBEQUcgYW5jZXN0b3JzXG4gIHByZWRlY2Vzc29yczogZGVmaW5lRGFnQWxsSG9wcyh7XG4gICAgaW5jb21pbmc6IHRydWVcbiAgfSlcbn0pO1xuXG4vLyBOZWlnaGJvdXJob29kIGZ1bmN0aW9uc1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuZXh0ZW5kKGVsZXNmbiQyLCB7XG4gIG5laWdoYm9yaG9vZDogY2FjaGUoZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG4gICAgdmFyIGVsZW1lbnRzID0gW107XG4gICAgdmFyIG5vZGVzID0gdGhpcy5ub2RlcygpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIC8vIGZvciBhbGwgbm9kZXNcbiAgICAgIHZhciBub2RlID0gbm9kZXNbaV07XG4gICAgICB2YXIgY29ubmVjdGVkRWRnZXMgPSBub2RlLmNvbm5lY3RlZEVkZ2VzKCk7XG5cbiAgICAgIC8vIGZvciBlYWNoIGNvbm5lY3RlZCBlZGdlLCBhZGQgdGhlIGVkZ2UgYW5kIHRoZSBvdGhlciBub2RlXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGNvbm5lY3RlZEVkZ2VzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHZhciBlZGdlID0gY29ubmVjdGVkRWRnZXNbal07XG4gICAgICAgIHZhciBzcmMgPSBlZGdlLnNvdXJjZSgpO1xuICAgICAgICB2YXIgdGd0ID0gZWRnZS50YXJnZXQoKTtcbiAgICAgICAgdmFyIG90aGVyTm9kZSA9IG5vZGUgPT09IHNyYyA/IHRndCA6IHNyYztcblxuICAgICAgICAvLyBuZWVkIGNoZWNrIGluIGNhc2Ugb2YgbG9vcFxuICAgICAgICBpZiAob3RoZXJOb2RlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBlbGVtZW50cy5wdXNoKG90aGVyTm9kZVswXSk7IC8vIGFkZCBub2RlIDEgaG9wIGF3YXlcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFkZCBjb25uZWN0ZWQgZWRnZVxuICAgICAgICBlbGVtZW50cy5wdXNoKGVkZ2VbMF0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5zcGF3bihlbGVtZW50cywgdHJ1ZSkuZmlsdGVyKHNlbGVjdG9yKTtcbiAgfSwgJ25laWdoYm9yaG9vZCcpLFxuICBjbG9zZWROZWlnaGJvcmhvb2Q6IGZ1bmN0aW9uIGNsb3NlZE5laWdoYm9yaG9vZChzZWxlY3Rvcikge1xuICAgIHJldHVybiB0aGlzLm5laWdoYm9yaG9vZCgpLmFkZCh0aGlzKS5maWx0ZXIoc2VsZWN0b3IpO1xuICB9LFxuICBvcGVuTmVpZ2hib3Job29kOiBmdW5jdGlvbiBvcGVuTmVpZ2hib3Job29kKHNlbGVjdG9yKSB7XG4gICAgcmV0dXJuIHRoaXMubmVpZ2hib3Job29kKHNlbGVjdG9yKTtcbiAgfVxufSk7XG5cbi8vIGFsaWFzZXNcbmVsZXNmbiQyLm5laWdoYm91cmhvb2QgPSBlbGVzZm4kMi5uZWlnaGJvcmhvb2Q7XG5lbGVzZm4kMi5jbG9zZWROZWlnaGJvdXJob29kID0gZWxlc2ZuJDIuY2xvc2VkTmVpZ2hib3Job29kO1xuZWxlc2ZuJDIub3Blbk5laWdoYm91cmhvb2QgPSBlbGVzZm4kMi5vcGVuTmVpZ2hib3Job29kO1xuXG4vLyBFZGdlIGZ1bmN0aW9uc1xuLy8vLy8vLy8vLy8vLy8vLy9cblxuZXh0ZW5kKGVsZXNmbiQyLCB7XG4gIHNvdXJjZTogY2FjaGUoZnVuY3Rpb24gc291cmNlSW1wbChzZWxlY3Rvcikge1xuICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuICAgIHZhciBzcmM7XG4gICAgaWYgKGVsZSkge1xuICAgICAgc3JjID0gZWxlLl9wcml2YXRlLnNvdXJjZSB8fCBlbGUuY3koKS5jb2xsZWN0aW9uKCk7XG4gICAgfVxuICAgIHJldHVybiBzcmMgJiYgc2VsZWN0b3IgPyBzcmMuZmlsdGVyKHNlbGVjdG9yKSA6IHNyYztcbiAgfSwgJ3NvdXJjZScpLFxuICB0YXJnZXQ6IGNhY2hlKGZ1bmN0aW9uIHRhcmdldEltcGwoc2VsZWN0b3IpIHtcbiAgICB2YXIgZWxlID0gdGhpc1swXTtcbiAgICB2YXIgdGd0O1xuICAgIGlmIChlbGUpIHtcbiAgICAgIHRndCA9IGVsZS5fcHJpdmF0ZS50YXJnZXQgfHwgZWxlLmN5KCkuY29sbGVjdGlvbigpO1xuICAgIH1cbiAgICByZXR1cm4gdGd0ICYmIHNlbGVjdG9yID8gdGd0LmZpbHRlcihzZWxlY3RvcikgOiB0Z3Q7XG4gIH0sICd0YXJnZXQnKSxcbiAgc291cmNlczogZGVmaW5lU291cmNlRnVuY3Rpb24oe1xuICAgIGF0dHI6ICdzb3VyY2UnXG4gIH0pLFxuICB0YXJnZXRzOiBkZWZpbmVTb3VyY2VGdW5jdGlvbih7XG4gICAgYXR0cjogJ3RhcmdldCdcbiAgfSlcbn0pO1xuZnVuY3Rpb24gZGVmaW5lU291cmNlRnVuY3Rpb24ocGFyYW1zKSB7XG4gIHJldHVybiBmdW5jdGlvbiBzb3VyY2VJbXBsKHNlbGVjdG9yKSB7XG4gICAgdmFyIHNvdXJjZXMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBlbGUgPSB0aGlzW2ldO1xuICAgICAgdmFyIHNyYyA9IGVsZS5fcHJpdmF0ZVtwYXJhbXMuYXR0cl07XG4gICAgICBpZiAoc3JjKSB7XG4gICAgICAgIHNvdXJjZXMucHVzaChzcmMpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5zcGF3bihzb3VyY2VzLCB0cnVlKS5maWx0ZXIoc2VsZWN0b3IpO1xuICB9O1xufVxuZXh0ZW5kKGVsZXNmbiQyLCB7XG4gIGVkZ2VzV2l0aDogY2FjaGUoZGVmaW5lRWRnZXNXaXRoRnVuY3Rpb24oKSwgJ2VkZ2VzV2l0aCcpLFxuICBlZGdlc1RvOiBjYWNoZShkZWZpbmVFZGdlc1dpdGhGdW5jdGlvbih7XG4gICAgdGhpc0lzU3JjOiB0cnVlXG4gIH0pLCAnZWRnZXNUbycpXG59KTtcbmZ1bmN0aW9uIGRlZmluZUVkZ2VzV2l0aEZ1bmN0aW9uKHBhcmFtcykge1xuICByZXR1cm4gZnVuY3Rpb24gZWRnZXNXaXRoSW1wbChvdGhlck5vZGVzKSB7XG4gICAgdmFyIGVsZW1lbnRzID0gW107XG4gICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeTtcbiAgICB2YXIgcCA9IHBhcmFtcyB8fCB7fTtcblxuICAgIC8vIGdldCBlbGVtZW50cyBpZiBhIHNlbGVjdG9yIGlzIHNwZWNpZmllZFxuICAgIGlmIChzdHJpbmcob3RoZXJOb2RlcykpIHtcbiAgICAgIG90aGVyTm9kZXMgPSBjeS4kKG90aGVyTm9kZXMpO1xuICAgIH1cbiAgICBmb3IgKHZhciBoID0gMDsgaCA8IG90aGVyTm9kZXMubGVuZ3RoOyBoKyspIHtcbiAgICAgIHZhciBlZGdlcyA9IG90aGVyTm9kZXNbaF0uX3ByaXZhdGUuZWRnZXM7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVkZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlZGdlID0gZWRnZXNbaV07XG4gICAgICAgIHZhciBlZGdlRGF0YSA9IGVkZ2UuX3ByaXZhdGUuZGF0YTtcbiAgICAgICAgdmFyIHRoaXNUb090aGVyID0gdGhpcy5oYXNFbGVtZW50V2l0aElkKGVkZ2VEYXRhLnNvdXJjZSkgJiYgb3RoZXJOb2Rlcy5oYXNFbGVtZW50V2l0aElkKGVkZ2VEYXRhLnRhcmdldCk7XG4gICAgICAgIHZhciBvdGhlclRvVGhpcyA9IG90aGVyTm9kZXMuaGFzRWxlbWVudFdpdGhJZChlZGdlRGF0YS5zb3VyY2UpICYmIHRoaXMuaGFzRWxlbWVudFdpdGhJZChlZGdlRGF0YS50YXJnZXQpO1xuICAgICAgICB2YXIgZWRnZUNvbm5lY3RzVGhpc0FuZE90aGVyID0gdGhpc1RvT3RoZXIgfHwgb3RoZXJUb1RoaXM7XG4gICAgICAgIGlmICghZWRnZUNvbm5lY3RzVGhpc0FuZE90aGVyKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHAudGhpc0lzU3JjIHx8IHAudGhpc0lzVGd0KSB7XG4gICAgICAgICAgaWYgKHAudGhpc0lzU3JjICYmICF0aGlzVG9PdGhlcikge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwLnRoaXNJc1RndCAmJiAhb3RoZXJUb1RoaXMpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbGVtZW50cy5wdXNoKGVkZ2UpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5zcGF3bihlbGVtZW50cywgdHJ1ZSk7XG4gIH07XG59XG5leHRlbmQoZWxlc2ZuJDIsIHtcbiAgY29ubmVjdGVkRWRnZXM6IGNhY2hlKGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuICAgIHZhciByZXRFbGVzID0gW107XG4gICAgdmFyIGVsZXMgPSB0aGlzO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIG5vZGUgPSBlbGVzW2ldO1xuICAgICAgaWYgKCFub2RlLmlzTm9kZSgpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdmFyIGVkZ2VzID0gbm9kZS5fcHJpdmF0ZS5lZGdlcztcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZWRnZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgdmFyIGVkZ2UgPSBlZGdlc1tqXTtcbiAgICAgICAgcmV0RWxlcy5wdXNoKGVkZ2UpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5zcGF3bihyZXRFbGVzLCB0cnVlKS5maWx0ZXIoc2VsZWN0b3IpO1xuICB9LCAnY29ubmVjdGVkRWRnZXMnKSxcbiAgY29ubmVjdGVkTm9kZXM6IGNhY2hlKGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuICAgIHZhciByZXRFbGVzID0gW107XG4gICAgdmFyIGVsZXMgPSB0aGlzO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGVkZ2UgPSBlbGVzW2ldO1xuICAgICAgaWYgKCFlZGdlLmlzRWRnZSgpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgcmV0RWxlcy5wdXNoKGVkZ2Uuc291cmNlKClbMF0pO1xuICAgICAgcmV0RWxlcy5wdXNoKGVkZ2UudGFyZ2V0KClbMF0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5zcGF3bihyZXRFbGVzLCB0cnVlKS5maWx0ZXIoc2VsZWN0b3IpO1xuICB9LCAnY29ubmVjdGVkTm9kZXMnKSxcbiAgcGFyYWxsZWxFZGdlczogY2FjaGUoZGVmaW5lUGFyYWxsZWxFZGdlc0Z1bmN0aW9uKCksICdwYXJhbGxlbEVkZ2VzJyksXG4gIGNvZGlyZWN0ZWRFZGdlczogY2FjaGUoZGVmaW5lUGFyYWxsZWxFZGdlc0Z1bmN0aW9uKHtcbiAgICBjb2RpcmVjdGVkOiB0cnVlXG4gIH0pLCAnY29kaXJlY3RlZEVkZ2VzJylcbn0pO1xuZnVuY3Rpb24gZGVmaW5lUGFyYWxsZWxFZGdlc0Z1bmN0aW9uKHBhcmFtcykge1xuICB2YXIgZGVmYXVsdHMgPSB7XG4gICAgY29kaXJlY3RlZDogZmFsc2VcbiAgfTtcbiAgcGFyYW1zID0gZXh0ZW5kKHt9LCBkZWZhdWx0cywgcGFyYW1zKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIHBhcmFsbGVsRWRnZXNJbXBsKHNlbGVjdG9yKSB7XG4gICAgLy8gbWljcm8tb3B0aW1pc2VkIGZvciByZW5kZXJlclxuICAgIHZhciBlbGVtZW50cyA9IFtdO1xuICAgIHZhciBlZGdlcyA9IHRoaXMuZWRnZXMoKTtcbiAgICB2YXIgcCA9IHBhcmFtcztcblxuICAgIC8vIGxvb2sgYXQgYWxsIHRoZSBlZGdlcyBpbiB0aGUgY29sbGVjdGlvblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWRnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBlZGdlMSA9IGVkZ2VzW2ldO1xuICAgICAgdmFyIGVkZ2UxX3AgPSBlZGdlMS5fcHJpdmF0ZTtcbiAgICAgIHZhciBzcmMxID0gZWRnZTFfcC5zb3VyY2U7XG4gICAgICB2YXIgc3JjaWQxID0gc3JjMS5fcHJpdmF0ZS5kYXRhLmlkO1xuICAgICAgdmFyIHRndGlkMSA9IGVkZ2UxX3AuZGF0YS50YXJnZXQ7XG4gICAgICB2YXIgc3JjRWRnZXMxID0gc3JjMS5fcHJpdmF0ZS5lZGdlcztcblxuICAgICAgLy8gbG9vayBhdCBlZGdlcyBjb25uZWN0ZWQgdG8gdGhlIHNyYyBub2RlIG9mIHRoaXMgZWRnZVxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBzcmNFZGdlczEubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgdmFyIGVkZ2UyID0gc3JjRWRnZXMxW2pdO1xuICAgICAgICB2YXIgZWRnZTJkYXRhID0gZWRnZTIuX3ByaXZhdGUuZGF0YTtcbiAgICAgICAgdmFyIHRndGlkMiA9IGVkZ2UyZGF0YS50YXJnZXQ7XG4gICAgICAgIHZhciBzcmNpZDIgPSBlZGdlMmRhdGEuc291cmNlO1xuICAgICAgICB2YXIgY29kaXJlY3RlZCA9IHRndGlkMiA9PT0gdGd0aWQxICYmIHNyY2lkMiA9PT0gc3JjaWQxO1xuICAgICAgICB2YXIgb3BwZGlyZWN0ZWQgPSBzcmNpZDEgPT09IHRndGlkMiAmJiB0Z3RpZDEgPT09IHNyY2lkMjtcbiAgICAgICAgaWYgKHAuY29kaXJlY3RlZCAmJiBjb2RpcmVjdGVkIHx8ICFwLmNvZGlyZWN0ZWQgJiYgKGNvZGlyZWN0ZWQgfHwgb3BwZGlyZWN0ZWQpKSB7XG4gICAgICAgICAgZWxlbWVudHMucHVzaChlZGdlMik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuc3Bhd24oZWxlbWVudHMsIHRydWUpLmZpbHRlcihzZWxlY3Rvcik7XG4gIH07XG59XG5cbi8vIE1pc2MgZnVuY3Rpb25zXG4vLy8vLy8vLy8vLy8vLy8vL1xuXG5leHRlbmQoZWxlc2ZuJDIsIHtcbiAgY29tcG9uZW50czogZnVuY3Rpb24gY29tcG9uZW50cyhyb290KSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBjeSA9IHNlbGYuY3koKTtcbiAgICB2YXIgdmlzaXRlZCA9IGN5LmNvbGxlY3Rpb24oKTtcbiAgICB2YXIgdW52aXNpdGVkID0gcm9vdCA9PSBudWxsID8gc2VsZi5ub2RlcygpIDogcm9vdC5ub2RlcygpO1xuICAgIHZhciBjb21wb25lbnRzID0gW107XG4gICAgaWYgKHJvb3QgIT0gbnVsbCAmJiB1bnZpc2l0ZWQuZW1wdHkoKSkge1xuICAgICAgLy8gcm9vdCBtYXkgY29udGFpbiBvbmx5IGVkZ2VzXG4gICAgICB1bnZpc2l0ZWQgPSByb290LnNvdXJjZXMoKTsgLy8gZG9lc24ndCBtYXR0ZXIgd2hpY2ggbm9kZSB0byB1c2UgKHVuZGlyZWN0ZWQpLCBzbyBqdXN0IHVzZSB0aGUgc291cmNlIHNpZGVzXG4gICAgfVxuXG4gICAgdmFyIHZpc2l0SW5Db21wb25lbnQgPSBmdW5jdGlvbiB2aXNpdEluQ29tcG9uZW50KG5vZGUsIGNvbXBvbmVudCkge1xuICAgICAgdmlzaXRlZC5tZXJnZShub2RlKTtcbiAgICAgIHVudmlzaXRlZC51bm1lcmdlKG5vZGUpO1xuICAgICAgY29tcG9uZW50Lm1lcmdlKG5vZGUpO1xuICAgIH07XG4gICAgaWYgKHVudmlzaXRlZC5lbXB0eSgpKSB7XG4gICAgICByZXR1cm4gc2VsZi5zcGF3bigpO1xuICAgIH1cbiAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcCgpIHtcbiAgICAgIC8vIGVhY2ggaXRlcmF0aW9uIHlpZWxkcyBhIGNvbXBvbmVudFxuICAgICAgdmFyIGNtcHQgPSBjeS5jb2xsZWN0aW9uKCk7XG4gICAgICBjb21wb25lbnRzLnB1c2goY21wdCk7XG4gICAgICB2YXIgcm9vdCA9IHVudmlzaXRlZFswXTtcbiAgICAgIHZpc2l0SW5Db21wb25lbnQocm9vdCwgY21wdCk7XG4gICAgICBzZWxmLmJmcyh7XG4gICAgICAgIGRpcmVjdGVkOiBmYWxzZSxcbiAgICAgICAgcm9vdHM6IHJvb3QsXG4gICAgICAgIHZpc2l0OiBmdW5jdGlvbiB2aXNpdCh2KSB7XG4gICAgICAgICAgcmV0dXJuIHZpc2l0SW5Db21wb25lbnQodiwgY21wdCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgY21wdC5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIG5vZGUuY29ubmVjdGVkRWRnZXMoKS5mb3JFYWNoKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgLy8gY29ubmVjdGVkRWRnZXMoKSB1c3VhbGx5IGNhY2hlZFxuICAgICAgICAgIGlmIChzZWxmLmhhcyhlKSAmJiBjbXB0LmhhcyhlLnNvdXJjZSgpKSAmJiBjbXB0LmhhcyhlLnRhcmdldCgpKSkge1xuICAgICAgICAgICAgLy8gaGFzKCkgaXMgY2hlYXBcbiAgICAgICAgICAgIGNtcHQubWVyZ2UoZSk7IC8vIGZvckVhY2goKSBvbmx5IGNvbnNpZGVycyBub2RlcyAtLSBzZXRzIE4gYXQgY2FsbCB0aW1lXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgZG8ge1xuICAgICAgX2xvb3AoKTtcbiAgICB9IHdoaWxlICh1bnZpc2l0ZWQubGVuZ3RoID4gMCk7XG4gICAgcmV0dXJuIGNvbXBvbmVudHM7XG4gIH0sXG4gIGNvbXBvbmVudDogZnVuY3Rpb24gY29tcG9uZW50KCkge1xuICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuICAgIHJldHVybiBlbGUuY3koKS5tdXRhYmxlRWxlbWVudHMoKS5jb21wb25lbnRzKGVsZSlbMF07XG4gIH1cbn0pO1xuZWxlc2ZuJDIuY29tcG9uZW50c09mID0gZWxlc2ZuJDIuY29tcG9uZW50cztcblxuLy8gcmVwcmVzZW50cyBhIHNldCBvZiBub2RlcywgZWRnZXMsIG9yIGJvdGggdG9nZXRoZXJcbnZhciBDb2xsZWN0aW9uID0gZnVuY3Rpb24gQ29sbGVjdGlvbihjeSwgZWxlbWVudHMpIHtcbiAgdmFyIHVuaXF1ZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogZmFsc2U7XG4gIHZhciByZW1vdmVkID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiBmYWxzZTtcbiAgaWYgKGN5ID09PSB1bmRlZmluZWQpIHtcbiAgICBlcnJvcignQSBjb2xsZWN0aW9uIG11c3QgaGF2ZSBhIHJlZmVyZW5jZSB0byB0aGUgY29yZScpO1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbWFwID0gbmV3IE1hcCQyKCk7XG4gIHZhciBjcmVhdGVkRWxlbWVudHMgPSBmYWxzZTtcbiAgaWYgKCFlbGVtZW50cykge1xuICAgIGVsZW1lbnRzID0gW107XG4gIH0gZWxzZSBpZiAoZWxlbWVudHMubGVuZ3RoID4gMCAmJiBwbGFpbk9iamVjdChlbGVtZW50c1swXSkgJiYgIWVsZW1lbnQoZWxlbWVudHNbMF0pKSB7XG4gICAgY3JlYXRlZEVsZW1lbnRzID0gdHJ1ZTtcblxuICAgIC8vIG1ha2UgZWxlbWVudHMgZnJvbSBqc29uIGFuZCByZXN0b3JlIGFsbCBhdCBvbmNlIGxhdGVyXG4gICAgdmFyIGVsZXMgPSBbXTtcbiAgICB2YXIgZWxlc0lkcyA9IG5ldyBTZXQkMSgpO1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gZWxlbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIganNvbiA9IGVsZW1lbnRzW2ldO1xuICAgICAgaWYgKGpzb24uZGF0YSA9PSBudWxsKSB7XG4gICAgICAgIGpzb24uZGF0YSA9IHt9O1xuICAgICAgfVxuICAgICAgdmFyIF9kYXRhID0ganNvbi5kYXRhO1xuXG4gICAgICAvLyBtYWtlIHN1cmUgbmV3bHkgY3JlYXRlZCBlbGVtZW50cyBoYXZlIHZhbGlkIGlkc1xuICAgICAgaWYgKF9kYXRhLmlkID09IG51bGwpIHtcbiAgICAgICAgX2RhdGEuaWQgPSB1dWlkKCk7XG4gICAgICB9IGVsc2UgaWYgKGN5Lmhhc0VsZW1lbnRXaXRoSWQoX2RhdGEuaWQpIHx8IGVsZXNJZHMuaGFzKF9kYXRhLmlkKSkge1xuICAgICAgICBjb250aW51ZTsgLy8gY2FuJ3QgY3JlYXRlIGVsZW1lbnQgaWYgcHJpb3IgaWQgYWxyZWFkeSBleGlzdHNcbiAgICAgIH1cblxuICAgICAgdmFyIGVsZSA9IG5ldyBFbGVtZW50KGN5LCBqc29uLCBmYWxzZSk7XG4gICAgICBlbGVzLnB1c2goZWxlKTtcbiAgICAgIGVsZXNJZHMuYWRkKF9kYXRhLmlkKTtcbiAgICB9XG4gICAgZWxlbWVudHMgPSBlbGVzO1xuICB9XG4gIHRoaXMubGVuZ3RoID0gMDtcbiAgZm9yICh2YXIgX2kgPSAwLCBfbCA9IGVsZW1lbnRzLmxlbmd0aDsgX2kgPCBfbDsgX2krKykge1xuICAgIHZhciBlbGVtZW50JDEgPSBlbGVtZW50c1tfaV1bMF07IC8vIFswXSBpbiBjYXNlIGVsZW1lbnRzIGlzIGFuIGFycmF5IG9mIGNvbGxlY3Rpb25zLCByYXRoZXIgdGhhbiBhcnJheSBvZiBlbGVtZW50c1xuICAgIGlmIChlbGVtZW50JDEgPT0gbnVsbCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHZhciBpZCA9IGVsZW1lbnQkMS5fcHJpdmF0ZS5kYXRhLmlkO1xuICAgIGlmICghdW5pcXVlIHx8ICFtYXAuaGFzKGlkKSkge1xuICAgICAgaWYgKHVuaXF1ZSkge1xuICAgICAgICBtYXAuc2V0KGlkLCB7XG4gICAgICAgICAgaW5kZXg6IHRoaXMubGVuZ3RoLFxuICAgICAgICAgIGVsZTogZWxlbWVudCQxXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgdGhpc1t0aGlzLmxlbmd0aF0gPSBlbGVtZW50JDE7XG4gICAgICB0aGlzLmxlbmd0aCsrO1xuICAgIH1cbiAgfVxuICB0aGlzLl9wcml2YXRlID0ge1xuICAgIGVsZXM6IHRoaXMsXG4gICAgY3k6IGN5LFxuICAgIGdldCBtYXAoKSB7XG4gICAgICBpZiAodGhpcy5sYXp5TWFwID09IG51bGwpIHtcbiAgICAgICAgdGhpcy5yZWJ1aWxkTWFwKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5sYXp5TWFwO1xuICAgIH0sXG4gICAgc2V0IG1hcChtKSB7XG4gICAgICB0aGlzLmxhenlNYXAgPSBtO1xuICAgIH0sXG4gICAgcmVidWlsZE1hcDogZnVuY3Rpb24gcmVidWlsZE1hcCgpIHtcbiAgICAgIHZhciBtID0gdGhpcy5sYXp5TWFwID0gbmV3IE1hcCQyKCk7XG4gICAgICB2YXIgZWxlcyA9IHRoaXMuZWxlcztcbiAgICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IGVsZXMubGVuZ3RoOyBfaTIrKykge1xuICAgICAgICB2YXIgX2VsZSA9IGVsZXNbX2kyXTtcbiAgICAgICAgbS5zZXQoX2VsZS5pZCgpLCB7XG4gICAgICAgICAgaW5kZXg6IF9pMixcbiAgICAgICAgICBlbGU6IF9lbGVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBpZiAodW5pcXVlKSB7XG4gICAgdGhpcy5fcHJpdmF0ZS5tYXAgPSBtYXA7XG4gIH1cblxuICAvLyByZXN0b3JlIHRoZSBlbGVtZW50cyBpZiB3ZSBjcmVhdGVkIHRoZW0gZnJvbSBqc29uXG4gIGlmIChjcmVhdGVkRWxlbWVudHMgJiYgIXJlbW92ZWQpIHtcbiAgICB0aGlzLnJlc3RvcmUoKTtcbiAgfVxufTtcblxuLy8gRnVuY3Rpb25zXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbi8vIGtlZXAgdGhlIHByb3RvdHlwZXMgaW4gc3luYyAoYW4gZWxlbWVudCBoYXMgdGhlIHNhbWUgZnVuY3Rpb25zIGFzIGEgY29sbGVjdGlvbilcbi8vIGFuZCB1c2UgZWxlZm4gYW5kIGVsZXNmbiBhcyBzaG9ydGhhbmRzIHRvIHRoZSBwcm90b3R5cGVzXG52YXIgZWxlc2ZuJDEgPSBFbGVtZW50LnByb3RvdHlwZSA9IENvbGxlY3Rpb24ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShBcnJheS5wcm90b3R5cGUpO1xuZWxlc2ZuJDEuaW5zdGFuY2VTdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAnY29sbGVjdGlvbic7XG59O1xuZWxlc2ZuJDEuc3Bhd24gPSBmdW5jdGlvbiAoZWxlcywgdW5pcXVlKSB7XG4gIHJldHVybiBuZXcgQ29sbGVjdGlvbih0aGlzLmN5KCksIGVsZXMsIHVuaXF1ZSk7XG59O1xuZWxlc2ZuJDEuc3Bhd25TZWxmID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5zcGF3bih0aGlzKTtcbn07XG5lbGVzZm4kMS5jeSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuX3ByaXZhdGUuY3k7XG59O1xuZWxlc2ZuJDEucmVuZGVyZXIgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLl9wcml2YXRlLmN5LnJlbmRlcmVyKCk7XG59O1xuZWxlc2ZuJDEuZWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXNbMF07XG59O1xuZWxlc2ZuJDEuY29sbGVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKGNvbGxlY3Rpb24odGhpcykpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfSBlbHNlIHtcbiAgICAvLyBhbiBlbGVtZW50XG4gICAgcmV0dXJuIG5ldyBDb2xsZWN0aW9uKHRoaXMuX3ByaXZhdGUuY3ksIFt0aGlzXSk7XG4gIH1cbn07XG5lbGVzZm4kMS51bmlxdWUgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBuZXcgQ29sbGVjdGlvbih0aGlzLl9wcml2YXRlLmN5LCB0aGlzLCB0cnVlKTtcbn07XG5lbGVzZm4kMS5oYXNFbGVtZW50V2l0aElkID0gZnVuY3Rpb24gKGlkKSB7XG4gIGlkID0gJycgKyBpZDsgLy8gaWQgbXVzdCBiZSBzdHJpbmdcblxuICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5tYXAuaGFzKGlkKTtcbn07XG5lbGVzZm4kMS5nZXRFbGVtZW50QnlJZCA9IGZ1bmN0aW9uIChpZCkge1xuICBpZCA9ICcnICsgaWQ7IC8vIGlkIG11c3QgYmUgc3RyaW5nXG5cbiAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeTtcbiAgdmFyIGVudHJ5ID0gdGhpcy5fcHJpdmF0ZS5tYXAuZ2V0KGlkKTtcbiAgcmV0dXJuIGVudHJ5ID8gZW50cnkuZWxlIDogbmV3IENvbGxlY3Rpb24oY3kpOyAvLyBnZXQgZWxlIG9yIGVtcHR5IGNvbGxlY3Rpb25cbn07XG5cbmVsZXNmbiQxLiRpZCA9IGVsZXNmbiQxLmdldEVsZW1lbnRCeUlkO1xuZWxlc2ZuJDEucG9vbEluZGV4ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5O1xuICB2YXIgZWxlcyA9IGN5Ll9wcml2YXRlLmVsZW1lbnRzO1xuICB2YXIgaWQgPSB0aGlzWzBdLl9wcml2YXRlLmRhdGEuaWQ7XG4gIHJldHVybiBlbGVzLl9wcml2YXRlLm1hcC5nZXQoaWQpLmluZGV4O1xufTtcbmVsZXNmbiQxLmluZGV4T2YgPSBmdW5jdGlvbiAoZWxlKSB7XG4gIHZhciBpZCA9IGVsZVswXS5fcHJpdmF0ZS5kYXRhLmlkO1xuICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5tYXAuZ2V0KGlkKS5pbmRleDtcbn07XG5lbGVzZm4kMS5pbmRleE9mSWQgPSBmdW5jdGlvbiAoaWQpIHtcbiAgaWQgPSAnJyArIGlkOyAvLyBpZCBtdXN0IGJlIHN0cmluZ1xuXG4gIHJldHVybiB0aGlzLl9wcml2YXRlLm1hcC5nZXQoaWQpLmluZGV4O1xufTtcbmVsZXNmbiQxLmpzb24gPSBmdW5jdGlvbiAob2JqKSB7XG4gIHZhciBlbGUgPSB0aGlzLmVsZW1lbnQoKTtcbiAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuICBpZiAoZWxlID09IG51bGwgJiYgb2JqKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0gLy8gY2FuJ3Qgc2V0IHRvIG5vIGVsZXNcblxuICBpZiAoZWxlID09IG51bGwpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9IC8vIGNhbid0IGdldCBmcm9tIG5vIGVsZXNcblxuICB2YXIgcCA9IGVsZS5fcHJpdmF0ZTtcbiAgaWYgKHBsYWluT2JqZWN0KG9iaikpIHtcbiAgICAvLyBzZXRcblxuICAgIGN5LnN0YXJ0QmF0Y2goKTtcbiAgICBpZiAob2JqLmRhdGEpIHtcbiAgICAgIGVsZS5kYXRhKG9iai5kYXRhKTtcbiAgICAgIHZhciBfZGF0YTIgPSBwLmRhdGE7XG4gICAgICBpZiAoZWxlLmlzRWRnZSgpKSB7XG4gICAgICAgIC8vIHNvdXJjZSBhbmQgdGFyZ2V0IGFyZSBpbW11dGFibGUgdmlhIGRhdGEoKVxuICAgICAgICB2YXIgbW92ZSA9IGZhbHNlO1xuICAgICAgICB2YXIgc3BlYyA9IHt9O1xuICAgICAgICB2YXIgc3JjID0gb2JqLmRhdGEuc291cmNlO1xuICAgICAgICB2YXIgdGd0ID0gb2JqLmRhdGEudGFyZ2V0O1xuICAgICAgICBpZiAoc3JjICE9IG51bGwgJiYgc3JjICE9IF9kYXRhMi5zb3VyY2UpIHtcbiAgICAgICAgICBzcGVjLnNvdXJjZSA9ICcnICsgc3JjOyAvLyBpZCBtdXN0IGJlIHN0cmluZ1xuICAgICAgICAgIG1vdmUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0Z3QgIT0gbnVsbCAmJiB0Z3QgIT0gX2RhdGEyLnRhcmdldCkge1xuICAgICAgICAgIHNwZWMudGFyZ2V0ID0gJycgKyB0Z3Q7IC8vIGlkIG11c3QgYmUgc3RyaW5nXG4gICAgICAgICAgbW92ZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1vdmUpIHtcbiAgICAgICAgICBlbGUgPSBlbGUubW92ZShzcGVjKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gcGFyZW50IGlzIGltbXV0YWJsZSB2aWEgZGF0YSgpXG4gICAgICAgIHZhciBuZXdQYXJlbnRWYWxTcGVjZCA9ICgncGFyZW50JyBpbiBvYmouZGF0YSk7XG4gICAgICAgIHZhciBwYXJlbnQgPSBvYmouZGF0YS5wYXJlbnQ7XG4gICAgICAgIGlmIChuZXdQYXJlbnRWYWxTcGVjZCAmJiAocGFyZW50ICE9IG51bGwgfHwgX2RhdGEyLnBhcmVudCAhPSBudWxsKSAmJiBwYXJlbnQgIT0gX2RhdGEyLnBhcmVudCkge1xuICAgICAgICAgIGlmIChwYXJlbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gY2FuJ3Qgc2V0IHVuZGVmaW5lZCBpbXBlcmF0aXZlbHksIHNvIHVzZSBudWxsXG4gICAgICAgICAgICBwYXJlbnQgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocGFyZW50ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHBhcmVudCA9ICcnICsgcGFyZW50OyAvLyBpZCBtdXN0IGJlIHN0cmluZ1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGVsZSA9IGVsZS5tb3ZlKHtcbiAgICAgICAgICAgIHBhcmVudDogcGFyZW50XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9iai5wb3NpdGlvbikge1xuICAgICAgZWxlLnBvc2l0aW9uKG9iai5wb3NpdGlvbik7XG4gICAgfVxuXG4gICAgLy8gaWdub3JlIGdyb3VwIC0tIGltbXV0YWJsZVxuXG4gICAgdmFyIGNoZWNrU3dpdGNoID0gZnVuY3Rpb24gY2hlY2tTd2l0Y2goaywgdHJ1ZUZuTmFtZSwgZmFsc2VGbk5hbWUpIHtcbiAgICAgIHZhciBvYmpfayA9IG9ialtrXTtcbiAgICAgIGlmIChvYmpfayAhPSBudWxsICYmIG9ial9rICE9PSBwW2tdKSB7XG4gICAgICAgIGlmIChvYmpfaykge1xuICAgICAgICAgIGVsZVt0cnVlRm5OYW1lXSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVsZVtmYWxzZUZuTmFtZV0oKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgY2hlY2tTd2l0Y2goJ3JlbW92ZWQnLCAncmVtb3ZlJywgJ3Jlc3RvcmUnKTtcbiAgICBjaGVja1N3aXRjaCgnc2VsZWN0ZWQnLCAnc2VsZWN0JywgJ3Vuc2VsZWN0Jyk7XG4gICAgY2hlY2tTd2l0Y2goJ3NlbGVjdGFibGUnLCAnc2VsZWN0aWZ5JywgJ3Vuc2VsZWN0aWZ5Jyk7XG4gICAgY2hlY2tTd2l0Y2goJ2xvY2tlZCcsICdsb2NrJywgJ3VubG9jaycpO1xuICAgIGNoZWNrU3dpdGNoKCdncmFiYmFibGUnLCAnZ3JhYmlmeScsICd1bmdyYWJpZnknKTtcbiAgICBjaGVja1N3aXRjaCgncGFubmFibGUnLCAncGFuaWZ5JywgJ3VucGFuaWZ5Jyk7XG4gICAgaWYgKG9iai5jbGFzc2VzICE9IG51bGwpIHtcbiAgICAgIGVsZS5jbGFzc2VzKG9iai5jbGFzc2VzKTtcbiAgICB9XG4gICAgY3kuZW5kQmF0Y2goKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSBlbHNlIGlmIChvYmogPT09IHVuZGVmaW5lZCkge1xuICAgIC8vIGdldFxuXG4gICAgdmFyIGpzb24gPSB7XG4gICAgICBkYXRhOiBjb3B5KHAuZGF0YSksXG4gICAgICBwb3NpdGlvbjogY29weShwLnBvc2l0aW9uKSxcbiAgICAgIGdyb3VwOiBwLmdyb3VwLFxuICAgICAgcmVtb3ZlZDogcC5yZW1vdmVkLFxuICAgICAgc2VsZWN0ZWQ6IHAuc2VsZWN0ZWQsXG4gICAgICBzZWxlY3RhYmxlOiBwLnNlbGVjdGFibGUsXG4gICAgICBsb2NrZWQ6IHAubG9ja2VkLFxuICAgICAgZ3JhYmJhYmxlOiBwLmdyYWJiYWJsZSxcbiAgICAgIHBhbm5hYmxlOiBwLnBhbm5hYmxlLFxuICAgICAgY2xhc3NlczogbnVsbFxuICAgIH07XG4gICAganNvbi5jbGFzc2VzID0gJyc7XG4gICAgdmFyIGkgPSAwO1xuICAgIHAuY2xhc3Nlcy5mb3JFYWNoKGZ1bmN0aW9uIChjbHMpIHtcbiAgICAgIHJldHVybiBqc29uLmNsYXNzZXMgKz0gaSsrID09PSAwID8gY2xzIDogJyAnICsgY2xzO1xuICAgIH0pO1xuICAgIHJldHVybiBqc29uO1xuICB9XG59O1xuZWxlc2ZuJDEuanNvbnMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBqc29ucyA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZWxlID0gdGhpc1tpXTtcbiAgICB2YXIganNvbiA9IGVsZS5qc29uKCk7XG4gICAganNvbnMucHVzaChqc29uKTtcbiAgfVxuICByZXR1cm4ganNvbnM7XG59O1xuZWxlc2ZuJDEuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBjeSA9IHRoaXMuY3koKTtcbiAgdmFyIGVsZXNBcnIgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGVsZSA9IHRoaXNbaV07XG4gICAgdmFyIGpzb24gPSBlbGUuanNvbigpO1xuICAgIHZhciBjbG9uZSA9IG5ldyBFbGVtZW50KGN5LCBqc29uLCBmYWxzZSk7IC8vIE5CIG5vIHJlc3RvcmVcblxuICAgIGVsZXNBcnIucHVzaChjbG9uZSk7XG4gIH1cbiAgcmV0dXJuIG5ldyBDb2xsZWN0aW9uKGN5LCBlbGVzQXJyKTtcbn07XG5lbGVzZm4kMS5jb3B5ID0gZWxlc2ZuJDEuY2xvbmU7XG5lbGVzZm4kMS5yZXN0b3JlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbm90aWZ5UmVuZGVyZXIgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHRydWU7XG4gIHZhciBhZGRUb1Bvb2wgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRydWU7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIGN5ID0gc2VsZi5jeSgpO1xuICB2YXIgY3lfcCA9IGN5Ll9wcml2YXRlO1xuXG4gIC8vIGNyZWF0ZSBhcnJheXMgb2Ygbm9kZXMgYW5kIGVkZ2VzLCBzaW5jZSB3ZSBuZWVkIHRvXG4gIC8vIHJlc3RvcmUgdGhlIG5vZGVzIGZpcnN0XG4gIHZhciBub2RlcyA9IFtdO1xuICB2YXIgZWRnZXMgPSBbXTtcbiAgdmFyIGVsZW1lbnRzO1xuICBmb3IgKHZhciBfaTMgPSAwLCBsID0gc2VsZi5sZW5ndGg7IF9pMyA8IGw7IF9pMysrKSB7XG4gICAgdmFyIGVsZSA9IHNlbGZbX2kzXTtcbiAgICBpZiAoYWRkVG9Qb29sICYmICFlbGUucmVtb3ZlZCgpKSB7XG4gICAgICAvLyBkb24ndCBuZWVkIHRvIGhhbmRsZSB0aGlzIGVsZVxuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8ga2VlcCBub2RlcyBmaXJzdCBpbiB0aGUgYXJyYXkgYW5kIGVkZ2VzIGFmdGVyXG4gICAgaWYgKGVsZS5pc05vZGUoKSkge1xuICAgICAgLy8gcHV0IHRvIGZyb250IG9mIGFycmF5IGlmIG5vZGVcbiAgICAgIG5vZGVzLnB1c2goZWxlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gcHV0IHRvIGVuZCBvZiBhcnJheSBpZiBlZGdlXG4gICAgICBlZGdlcy5wdXNoKGVsZSk7XG4gICAgfVxuICB9XG4gIGVsZW1lbnRzID0gbm9kZXMuY29uY2F0KGVkZ2VzKTtcbiAgdmFyIGk7XG4gIHZhciByZW1vdmVGcm9tRWxlbWVudHMgPSBmdW5jdGlvbiByZW1vdmVGcm9tRWxlbWVudHMoKSB7XG4gICAgZWxlbWVudHMuc3BsaWNlKGksIDEpO1xuICAgIGktLTtcbiAgfTtcblxuICAvLyBub3csIHJlc3RvcmUgZWFjaCBlbGVtZW50XG4gIGZvciAoaSA9IDA7IGkgPCBlbGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBfZWxlMiA9IGVsZW1lbnRzW2ldO1xuICAgIHZhciBfcHJpdmF0ZSA9IF9lbGUyLl9wcml2YXRlO1xuICAgIHZhciBfZGF0YTMgPSBfcHJpdmF0ZS5kYXRhO1xuXG4gICAgLy8gdGhlIHRyYXZlcnNhbCBjYWNoZSBzaG91bGQgc3RhcnQgZnJlc2ggd2hlbiBlbGUgaXMgYWRkZWRcbiAgICBfZWxlMi5jbGVhclRyYXZlcnNhbENhY2hlKCk7XG5cbiAgICAvLyBzZXQgaWQgYW5kIHZhbGlkYXRlXG4gICAgaWYgKCFhZGRUb1Bvb2wgJiYgIV9wcml2YXRlLnJlbW92ZWQpIDsgZWxzZSBpZiAoX2RhdGEzLmlkID09PSB1bmRlZmluZWQpIHtcbiAgICAgIF9kYXRhMy5pZCA9IHV1aWQoKTtcbiAgICB9IGVsc2UgaWYgKG51bWJlciQxKF9kYXRhMy5pZCkpIHtcbiAgICAgIF9kYXRhMy5pZCA9ICcnICsgX2RhdGEzLmlkOyAvLyBub3cgaXQncyBhIHN0cmluZ1xuICAgIH0gZWxzZSBpZiAoZW1wdHlTdHJpbmcoX2RhdGEzLmlkKSB8fCAhc3RyaW5nKF9kYXRhMy5pZCkpIHtcbiAgICAgIGVycm9yKCdDYW4gbm90IGNyZWF0ZSBlbGVtZW50IHdpdGggaW52YWxpZCBzdHJpbmcgSUQgYCcgKyBfZGF0YTMuaWQgKyAnYCcpO1xuXG4gICAgICAvLyBjYW4ndCBjcmVhdGUgZWxlbWVudCBpZiBpdCBoYXMgZW1wdHkgc3RyaW5nIGFzIGlkIG9yIG5vbi1zdHJpbmcgaWRcbiAgICAgIHJlbW92ZUZyb21FbGVtZW50cygpO1xuICAgICAgY29udGludWU7XG4gICAgfSBlbHNlIGlmIChjeS5oYXNFbGVtZW50V2l0aElkKF9kYXRhMy5pZCkpIHtcbiAgICAgIGVycm9yKCdDYW4gbm90IGNyZWF0ZSBzZWNvbmQgZWxlbWVudCB3aXRoIElEIGAnICsgX2RhdGEzLmlkICsgJ2AnKTtcblxuICAgICAgLy8gY2FuJ3QgY3JlYXRlIGVsZW1lbnQgaWYgb25lIGFscmVhZHkgaGFzIHRoYXQgaWRcbiAgICAgIHJlbW92ZUZyb21FbGVtZW50cygpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHZhciBpZCA9IF9kYXRhMy5pZDsgLy8gaWQgaXMgZmluYWxpc2VkLCBub3cgbGV0J3Mga2VlcCBhIHJlZlxuXG4gICAgaWYgKF9lbGUyLmlzTm9kZSgpKSB7XG4gICAgICAvLyBleHRyYSBjaGVja3MgZm9yIG5vZGVzXG4gICAgICB2YXIgcG9zID0gX3ByaXZhdGUucG9zaXRpb247XG5cbiAgICAgIC8vIG1ha2Ugc3VyZSB0aGUgbm9kZXMgaGF2ZSBhIGRlZmluZWQgcG9zaXRpb25cblxuICAgICAgaWYgKHBvcy54ID09IG51bGwpIHtcbiAgICAgICAgcG9zLnggPSAwO1xuICAgICAgfVxuICAgICAgaWYgKHBvcy55ID09IG51bGwpIHtcbiAgICAgICAgcG9zLnkgPSAwO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoX2VsZTIuaXNFZGdlKCkpIHtcbiAgICAgIC8vIGV4dHJhIGNoZWNrcyBmb3IgZWRnZXNcblxuICAgICAgdmFyIGVkZ2UgPSBfZWxlMjtcbiAgICAgIHZhciBmaWVsZHMgPSBbJ3NvdXJjZScsICd0YXJnZXQnXTtcbiAgICAgIHZhciBmaWVsZHNMZW5ndGggPSBmaWVsZHMubGVuZ3RoO1xuICAgICAgdmFyIGJhZFNvdXJjZU9yVGFyZ2V0ID0gZmFsc2U7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGZpZWxkc0xlbmd0aDsgaisrKSB7XG4gICAgICAgIHZhciBmaWVsZCA9IGZpZWxkc1tqXTtcbiAgICAgICAgdmFyIHZhbCA9IF9kYXRhM1tmaWVsZF07XG4gICAgICAgIGlmIChudW1iZXIkMSh2YWwpKSB7XG4gICAgICAgICAgdmFsID0gX2RhdGEzW2ZpZWxkXSA9ICcnICsgX2RhdGEzW2ZpZWxkXTsgLy8gbm93IHN0cmluZ1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbCA9PSBudWxsIHx8IHZhbCA9PT0gJycpIHtcbiAgICAgICAgICAvLyBjYW4ndCBjcmVhdGUgaWYgc291cmNlIG9yIHRhcmdldCBpcyBub3QgZGVmaW5lZCBwcm9wZXJseVxuICAgICAgICAgIGVycm9yKCdDYW4gbm90IGNyZWF0ZSBlZGdlIGAnICsgaWQgKyAnYCB3aXRoIHVuc3BlY2lmaWVkICcgKyBmaWVsZCk7XG4gICAgICAgICAgYmFkU291cmNlT3JUYXJnZXQgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKCFjeS5oYXNFbGVtZW50V2l0aElkKHZhbCkpIHtcbiAgICAgICAgICAvLyBjYW4ndCBjcmVhdGUgZWRnZSBpZiBvbmUgb2YgaXRzIG5vZGVzIGRvZXNuJ3QgZXhpc3RcbiAgICAgICAgICBlcnJvcignQ2FuIG5vdCBjcmVhdGUgZWRnZSBgJyArIGlkICsgJ2Agd2l0aCBub25leGlzdGFudCAnICsgZmllbGQgKyAnIGAnICsgdmFsICsgJ2AnKTtcbiAgICAgICAgICBiYWRTb3VyY2VPclRhcmdldCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChiYWRTb3VyY2VPclRhcmdldCkge1xuICAgICAgICByZW1vdmVGcm9tRWxlbWVudHMoKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IC8vIGNhbid0IGNyZWF0ZSB0aGlzXG5cbiAgICAgIHZhciBzcmMgPSBjeS5nZXRFbGVtZW50QnlJZChfZGF0YTMuc291cmNlKTtcbiAgICAgIHZhciB0Z3QgPSBjeS5nZXRFbGVtZW50QnlJZChfZGF0YTMudGFyZ2V0KTtcblxuICAgICAgLy8gb25seSBvbmUgZWRnZSBpbiBub2RlIGlmIGxvb3BcbiAgICAgIGlmIChzcmMuc2FtZSh0Z3QpKSB7XG4gICAgICAgIHNyYy5fcHJpdmF0ZS5lZGdlcy5wdXNoKGVkZ2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3JjLl9wcml2YXRlLmVkZ2VzLnB1c2goZWRnZSk7XG4gICAgICAgIHRndC5fcHJpdmF0ZS5lZGdlcy5wdXNoKGVkZ2UpO1xuICAgICAgfVxuICAgICAgZWRnZS5fcHJpdmF0ZS5zb3VyY2UgPSBzcmM7XG4gICAgICBlZGdlLl9wcml2YXRlLnRhcmdldCA9IHRndDtcbiAgICB9IC8vIGlmIGlzIGVkZ2VcblxuICAgIC8vIGNyZWF0ZSBtb2NrIGlkcyAvIGluZGV4ZXMgbWFwcyBmb3IgZWxlbWVudCBzbyBpdCBjYW4gYmUgdXNlZCBsaWtlIGNvbGxlY3Rpb25zXG4gICAgX3ByaXZhdGUubWFwID0gbmV3IE1hcCQyKCk7XG4gICAgX3ByaXZhdGUubWFwLnNldChpZCwge1xuICAgICAgZWxlOiBfZWxlMixcbiAgICAgIGluZGV4OiAwXG4gICAgfSk7XG4gICAgX3ByaXZhdGUucmVtb3ZlZCA9IGZhbHNlO1xuICAgIGlmIChhZGRUb1Bvb2wpIHtcbiAgICAgIGN5LmFkZFRvUG9vbChfZWxlMik7XG4gICAgfVxuICB9IC8vIGZvciBlYWNoIGVsZW1lbnRcblxuICAvLyBkbyBjb21wb3VuZCBub2RlIHNhbml0eSBjaGVja3NcbiAgZm9yICh2YXIgX2k0ID0gMDsgX2k0IDwgbm9kZXMubGVuZ3RoOyBfaTQrKykge1xuICAgIC8vIGVhY2ggbm9kZVxuICAgIHZhciBub2RlID0gbm9kZXNbX2k0XTtcbiAgICB2YXIgX2RhdGE0ID0gbm9kZS5fcHJpdmF0ZS5kYXRhO1xuICAgIGlmIChudW1iZXIkMShfZGF0YTQucGFyZW50KSkge1xuICAgICAgLy8gdGhlbiBhdXRvbWFrZSBzdHJpbmdcbiAgICAgIF9kYXRhNC5wYXJlbnQgPSAnJyArIF9kYXRhNC5wYXJlbnQ7XG4gICAgfVxuICAgIHZhciBwYXJlbnRJZCA9IF9kYXRhNC5wYXJlbnQ7XG4gICAgdmFyIHNwZWNpZmllZFBhcmVudCA9IHBhcmVudElkICE9IG51bGw7XG4gICAgaWYgKHNwZWNpZmllZFBhcmVudCB8fCBub2RlLl9wcml2YXRlLnBhcmVudCkge1xuICAgICAgdmFyIHBhcmVudCA9IG5vZGUuX3ByaXZhdGUucGFyZW50ID8gY3kuY29sbGVjdGlvbigpLm1lcmdlKG5vZGUuX3ByaXZhdGUucGFyZW50KSA6IGN5LmdldEVsZW1lbnRCeUlkKHBhcmVudElkKTtcbiAgICAgIGlmIChwYXJlbnQuZW1wdHkoKSkge1xuICAgICAgICAvLyBub24tZXhpc3RhbnQgcGFyZW50OyBqdXN0IHJlbW92ZSBpdFxuICAgICAgICBfZGF0YTQucGFyZW50ID0gdW5kZWZpbmVkO1xuICAgICAgfSBlbHNlIGlmIChwYXJlbnRbMF0ucmVtb3ZlZCgpKSB7XG4gICAgICAgIHdhcm4oJ05vZGUgYWRkZWQgd2l0aCBtaXNzaW5nIHBhcmVudCwgcmVmZXJlbmNlIHRvIHBhcmVudCByZW1vdmVkJyk7XG4gICAgICAgIF9kYXRhNC5wYXJlbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgIG5vZGUuX3ByaXZhdGUucGFyZW50ID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBzZWxmQXNQYXJlbnQgPSBmYWxzZTtcbiAgICAgICAgdmFyIGFuY2VzdG9yID0gcGFyZW50O1xuICAgICAgICB3aGlsZSAoIWFuY2VzdG9yLmVtcHR5KCkpIHtcbiAgICAgICAgICBpZiAobm9kZS5zYW1lKGFuY2VzdG9yKSkge1xuICAgICAgICAgICAgLy8gbWFyayBzZWxmIGFzIHBhcmVudCBhbmQgcmVtb3ZlIGZyb20gZGF0YVxuICAgICAgICAgICAgc2VsZkFzUGFyZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgIF9kYXRhNC5wYXJlbnQgPSB1bmRlZmluZWQ7IC8vIHJlbW92ZSBwYXJlbnQgcmVmZXJlbmNlXG5cbiAgICAgICAgICAgIC8vIGV4aXQgb3Igd2UgbG9vcCBmb3JldmVyXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgYW5jZXN0b3IgPSBhbmNlc3Rvci5wYXJlbnQoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXNlbGZBc1BhcmVudCkge1xuICAgICAgICAgIC8vIGNvbm5lY3Qgd2l0aCBjaGlsZHJlblxuICAgICAgICAgIHBhcmVudFswXS5fcHJpdmF0ZS5jaGlsZHJlbi5wdXNoKG5vZGUpO1xuICAgICAgICAgIG5vZGUuX3ByaXZhdGUucGFyZW50ID0gcGFyZW50WzBdO1xuXG4gICAgICAgICAgLy8gbGV0IHRoZSBjb3JlIGtub3cgd2UgaGF2ZSBhIGNvbXBvdW5kIGdyYXBoXG4gICAgICAgICAgY3lfcC5oYXNDb21wb3VuZE5vZGVzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBlbHNlXG4gICAgfSAvLyBpZiBzcGVjaWZpZWQgcGFyZW50XG4gIH0gLy8gZm9yIGVhY2ggbm9kZVxuXG4gIGlmIChlbGVtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgdmFyIHJlc3RvcmVkID0gZWxlbWVudHMubGVuZ3RoID09PSBzZWxmLmxlbmd0aCA/IHNlbGYgOiBuZXcgQ29sbGVjdGlvbihjeSwgZWxlbWVudHMpO1xuICAgIGZvciAodmFyIF9pNSA9IDA7IF9pNSA8IHJlc3RvcmVkLmxlbmd0aDsgX2k1KyspIHtcbiAgICAgIHZhciBfZWxlMyA9IHJlc3RvcmVkW19pNV07XG4gICAgICBpZiAoX2VsZTMuaXNOb2RlKCkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIGFkZGluZyBhbiBlZGdlIGludmFsaWRhdGVzIHRoZSB0cmF2ZXJzYWwgY2FjaGVzIGZvciB0aGUgcGFyYWxsZWwgZWRnZXNcbiAgICAgIF9lbGUzLnBhcmFsbGVsRWRnZXMoKS5jbGVhclRyYXZlcnNhbENhY2hlKCk7XG5cbiAgICAgIC8vIGFkZGluZyBhbiBlZGdlIGludmFsaWRhdGVzIHRoZSB0cmF2ZXJzYWwgY2FjaGUgZm9yIHRoZSBjb25uZWN0ZWQgbm9kZXNcbiAgICAgIF9lbGUzLnNvdXJjZSgpLmNsZWFyVHJhdmVyc2FsQ2FjaGUoKTtcbiAgICAgIF9lbGUzLnRhcmdldCgpLmNsZWFyVHJhdmVyc2FsQ2FjaGUoKTtcbiAgICB9XG4gICAgdmFyIHRvVXBkYXRlU3R5bGU7XG4gICAgaWYgKGN5X3AuaGFzQ29tcG91bmROb2Rlcykge1xuICAgICAgdG9VcGRhdGVTdHlsZSA9IGN5LmNvbGxlY3Rpb24oKS5tZXJnZShyZXN0b3JlZCkubWVyZ2UocmVzdG9yZWQuY29ubmVjdGVkTm9kZXMoKSkubWVyZ2UocmVzdG9yZWQucGFyZW50KCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0b1VwZGF0ZVN0eWxlID0gcmVzdG9yZWQ7XG4gICAgfVxuICAgIHRvVXBkYXRlU3R5bGUuZGlydHlDb21wb3VuZEJvdW5kc0NhY2hlKCkuZGlydHlCb3VuZGluZ0JveENhY2hlKCkudXBkYXRlU3R5bGUobm90aWZ5UmVuZGVyZXIpO1xuICAgIGlmIChub3RpZnlSZW5kZXJlcikge1xuICAgICAgcmVzdG9yZWQuZW1pdEFuZE5vdGlmeSgnYWRkJyk7XG4gICAgfSBlbHNlIGlmIChhZGRUb1Bvb2wpIHtcbiAgICAgIHJlc3RvcmVkLmVtaXQoJ2FkZCcpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc2VsZjsgLy8gY2hhaW5hYmlsaXR5XG59O1xuXG5lbGVzZm4kMS5yZW1vdmVkID0gZnVuY3Rpb24gKCkge1xuICB2YXIgZWxlID0gdGhpc1swXTtcbiAgcmV0dXJuIGVsZSAmJiBlbGUuX3ByaXZhdGUucmVtb3ZlZDtcbn07XG5lbGVzZm4kMS5pbnNpZGUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBlbGUgPSB0aGlzWzBdO1xuICByZXR1cm4gZWxlICYmICFlbGUuX3ByaXZhdGUucmVtb3ZlZDtcbn07XG5lbGVzZm4kMS5yZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBub3RpZnlSZW5kZXJlciA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogdHJ1ZTtcbiAgdmFyIHJlbW92ZUZyb21Qb29sID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0cnVlO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBlbGVzVG9SZW1vdmUgPSBbXTtcbiAgdmFyIGVsZXNUb1JlbW92ZUlkcyA9IHt9O1xuICB2YXIgY3kgPSBzZWxmLl9wcml2YXRlLmN5O1xuXG4gIC8vIGFkZCBjb25uZWN0ZWQgZWRnZXNcbiAgZnVuY3Rpb24gYWRkQ29ubmVjdGVkRWRnZXMobm9kZSkge1xuICAgIHZhciBlZGdlcyA9IG5vZGUuX3ByaXZhdGUuZWRnZXM7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlZGdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgYWRkKGVkZ2VzW2ldKTtcbiAgICB9XG4gIH1cblxuICAvLyBhZGQgZGVzY2VuZGFudCBub2Rlc1xuICBmdW5jdGlvbiBhZGRDaGlsZHJlbihub2RlKSB7XG4gICAgdmFyIGNoaWxkcmVuID0gbm9kZS5fcHJpdmF0ZS5jaGlsZHJlbjtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhZGQoY2hpbGRyZW5baV0pO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBhZGQoZWxlKSB7XG4gICAgdmFyIGFscmVhZHlBZGRlZCA9IGVsZXNUb1JlbW92ZUlkc1tlbGUuaWQoKV07XG4gICAgaWYgKHJlbW92ZUZyb21Qb29sICYmIGVsZS5yZW1vdmVkKCkgfHwgYWxyZWFkeUFkZGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsZXNUb1JlbW92ZUlkc1tlbGUuaWQoKV0gPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoZWxlLmlzTm9kZSgpKSB7XG4gICAgICBlbGVzVG9SZW1vdmUucHVzaChlbGUpOyAvLyBub2RlcyBhcmUgcmVtb3ZlZCBsYXN0XG5cbiAgICAgIGFkZENvbm5lY3RlZEVkZ2VzKGVsZSk7XG4gICAgICBhZGRDaGlsZHJlbihlbGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbGVzVG9SZW1vdmUudW5zaGlmdChlbGUpOyAvLyBlZGdlcyBhcmUgcmVtb3ZlZCBmaXJzdFxuICAgIH1cbiAgfVxuXG4gIC8vIG1ha2UgdGhlIGxpc3Qgb2YgZWxlbWVudHMgdG8gcmVtb3ZlXG4gIC8vIChtYXkgYmUgcmVtb3ZpbmcgbW9yZSB0aGFuIHNwZWNpZmllZCBkdWUgdG8gY29ubmVjdGVkIGVkZ2VzIGV0YylcblxuICBmb3IgKHZhciBpID0gMCwgbCA9IHNlbGYubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgdmFyIGVsZSA9IHNlbGZbaV07XG4gICAgYWRkKGVsZSk7XG4gIH1cbiAgZnVuY3Rpb24gcmVtb3ZlRWRnZVJlZihub2RlLCBlZGdlKSB7XG4gICAgdmFyIGNvbm5lY3RlZEVkZ2VzID0gbm9kZS5fcHJpdmF0ZS5lZGdlcztcbiAgICByZW1vdmVGcm9tQXJyYXkoY29ubmVjdGVkRWRnZXMsIGVkZ2UpO1xuXG4gICAgLy8gcmVtb3ZpbmcgYW4gZWRnZXMgaW52YWxpZGF0ZXMgdGhlIHRyYXZlcnNhbCBjYWNoZSBmb3IgaXRzIG5vZGVzXG4gICAgbm9kZS5jbGVhclRyYXZlcnNhbENhY2hlKCk7XG4gIH1cbiAgZnVuY3Rpb24gcmVtb3ZlUGFyYWxsZWxSZWYocGxsRWRnZSkge1xuICAgIC8vIHJlbW92aW5nIGFuIGVkZ2UgaW52YWxpZGF0ZXMgdGhlIHRyYXZlcnNhbCBjYWNoZXMgZm9yIHRoZSBwYXJhbGxlbCBlZGdlc1xuICAgIHBsbEVkZ2UuY2xlYXJUcmF2ZXJzYWxDYWNoZSgpO1xuICB9XG4gIHZhciBhbHRlcmVkUGFyZW50cyA9IFtdO1xuICBhbHRlcmVkUGFyZW50cy5pZHMgPSB7fTtcbiAgZnVuY3Rpb24gcmVtb3ZlQ2hpbGRSZWYocGFyZW50LCBlbGUpIHtcbiAgICBlbGUgPSBlbGVbMF07XG4gICAgcGFyZW50ID0gcGFyZW50WzBdO1xuICAgIHZhciBjaGlsZHJlbiA9IHBhcmVudC5fcHJpdmF0ZS5jaGlsZHJlbjtcbiAgICB2YXIgcGlkID0gcGFyZW50LmlkKCk7XG4gICAgcmVtb3ZlRnJvbUFycmF5KGNoaWxkcmVuLCBlbGUpOyAvLyByZW1vdmUgcGFyZW50ID0+IGNoaWxkIHJlZlxuXG4gICAgZWxlLl9wcml2YXRlLnBhcmVudCA9IG51bGw7IC8vIHJlbW92ZSBjaGlsZCA9PiBwYXJlbnQgcmVmXG5cbiAgICBpZiAoIWFsdGVyZWRQYXJlbnRzLmlkc1twaWRdKSB7XG4gICAgICBhbHRlcmVkUGFyZW50cy5pZHNbcGlkXSA9IHRydWU7XG4gICAgICBhbHRlcmVkUGFyZW50cy5wdXNoKHBhcmVudCk7XG4gICAgfVxuICB9XG4gIHNlbGYuZGlydHlDb21wb3VuZEJvdW5kc0NhY2hlKCk7XG4gIGlmIChyZW1vdmVGcm9tUG9vbCkge1xuICAgIGN5LnJlbW92ZUZyb21Qb29sKGVsZXNUb1JlbW92ZSk7IC8vIHJlbW92ZSBmcm9tIGNvcmUgcG9vbFxuICB9XG5cbiAgZm9yICh2YXIgX2k2ID0gMDsgX2k2IDwgZWxlc1RvUmVtb3ZlLmxlbmd0aDsgX2k2KyspIHtcbiAgICB2YXIgX2VsZTQgPSBlbGVzVG9SZW1vdmVbX2k2XTtcbiAgICBpZiAoX2VsZTQuaXNFZGdlKCkpIHtcbiAgICAgIC8vIHJlbW92ZSByZWZlcmVuY2VzIHRvIHRoaXMgZWRnZSBpbiBpdHMgY29ubmVjdGVkIG5vZGVzXG4gICAgICB2YXIgc3JjID0gX2VsZTQuc291cmNlKClbMF07XG4gICAgICB2YXIgdGd0ID0gX2VsZTQudGFyZ2V0KClbMF07XG4gICAgICByZW1vdmVFZGdlUmVmKHNyYywgX2VsZTQpO1xuICAgICAgcmVtb3ZlRWRnZVJlZih0Z3QsIF9lbGU0KTtcbiAgICAgIHZhciBwbGxFZGdlcyA9IF9lbGU0LnBhcmFsbGVsRWRnZXMoKTtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcGxsRWRnZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgdmFyIHBsbEVkZ2UgPSBwbGxFZGdlc1tqXTtcbiAgICAgICAgcmVtb3ZlUGFyYWxsZWxSZWYocGxsRWRnZSk7XG4gICAgICAgIGlmIChwbGxFZGdlLmlzQnVuZGxlZEJlemllcigpKSB7XG4gICAgICAgICAgcGxsRWRnZS5kaXJ0eUJvdW5kaW5nQm94Q2FjaGUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyByZW1vdmUgcmVmZXJlbmNlIHRvIHBhcmVudFxuICAgICAgdmFyIHBhcmVudCA9IF9lbGU0LnBhcmVudCgpO1xuICAgICAgaWYgKHBhcmVudC5sZW5ndGggIT09IDApIHtcbiAgICAgICAgcmVtb3ZlQ2hpbGRSZWYocGFyZW50LCBfZWxlNCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChyZW1vdmVGcm9tUG9vbCkge1xuICAgICAgLy8gbWFyayBhcyByZW1vdmVkXG4gICAgICBfZWxlNC5fcHJpdmF0ZS5yZW1vdmVkID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICAvLyBjaGVjayB0byBzZWUgaWYgd2UgaGF2ZSBhIGNvbXBvdW5kIGdyYXBoIG9yIG5vdFxuICB2YXIgZWxlc1N0aWxsSW5zaWRlID0gY3kuX3ByaXZhdGUuZWxlbWVudHM7XG4gIGN5Ll9wcml2YXRlLmhhc0NvbXBvdW5kTm9kZXMgPSBmYWxzZTtcbiAgZm9yICh2YXIgX2k3ID0gMDsgX2k3IDwgZWxlc1N0aWxsSW5zaWRlLmxlbmd0aDsgX2k3KyspIHtcbiAgICB2YXIgX2VsZTUgPSBlbGVzU3RpbGxJbnNpZGVbX2k3XTtcbiAgICBpZiAoX2VsZTUuaXNQYXJlbnQoKSkge1xuICAgICAgY3kuX3ByaXZhdGUuaGFzQ29tcG91bmROb2RlcyA9IHRydWU7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgdmFyIHJlbW92ZWRFbGVtZW50cyA9IG5ldyBDb2xsZWN0aW9uKHRoaXMuY3koKSwgZWxlc1RvUmVtb3ZlKTtcbiAgaWYgKHJlbW92ZWRFbGVtZW50cy5zaXplKCkgPiAwKSB7XG4gICAgLy8gbXVzdCBtYW51YWxseSBub3RpZnkgc2luY2UgdHJpZ2dlciB3b24ndCBkbyB0aGlzIGF1dG9tYXRpY2FsbHkgb25jZSByZW1vdmVkXG5cbiAgICBpZiAobm90aWZ5UmVuZGVyZXIpIHtcbiAgICAgIHJlbW92ZWRFbGVtZW50cy5lbWl0QW5kTm90aWZ5KCdyZW1vdmUnKTtcbiAgICB9IGVsc2UgaWYgKHJlbW92ZUZyb21Qb29sKSB7XG4gICAgICByZW1vdmVkRWxlbWVudHMuZW1pdCgncmVtb3ZlJyk7XG4gICAgfVxuICB9XG5cbiAgLy8gdGhlIHBhcmVudHMgd2hvIHdlcmUgbW9kaWZpZWQgYnkgdGhlIHJlbW92YWwgbmVlZCB0aGVpciBzdHlsZSB1cGRhdGVkXG4gIGZvciAodmFyIF9pOCA9IDA7IF9pOCA8IGFsdGVyZWRQYXJlbnRzLmxlbmd0aDsgX2k4KyspIHtcbiAgICB2YXIgX2VsZTYgPSBhbHRlcmVkUGFyZW50c1tfaThdO1xuICAgIGlmICghcmVtb3ZlRnJvbVBvb2wgfHwgIV9lbGU2LnJlbW92ZWQoKSkge1xuICAgICAgX2VsZTYudXBkYXRlU3R5bGUoKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlbW92ZWRFbGVtZW50cztcbn07XG5lbGVzZm4kMS5tb3ZlID0gZnVuY3Rpb24gKHN0cnVjdCkge1xuICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5O1xuICB2YXIgZWxlcyA9IHRoaXM7XG5cbiAgLy8ganVzdCBjbGVhbiB1cCByZWZzLCBjYWNoZXMsIGV0Yy4gaW4gdGhlIHNhbWUgd2F5IGFzIHdoZW4gcmVtb3ZpbmcgYW5kIHRoZW4gcmVzdG9yaW5nXG4gIC8vIChvdXIgY2FsbHMgdG8gcmVtb3ZlL3Jlc3RvcmUgZG8gbm90IHJlbW92ZSBmcm9tIHRoZSBncmFwaCBvciBtYWtlIGV2ZW50cylcbiAgdmFyIG5vdGlmeVJlbmRlcmVyID0gZmFsc2U7XG4gIHZhciBtb2RpZnlQb29sID0gZmFsc2U7XG4gIHZhciB0b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKGlkKSB7XG4gICAgcmV0dXJuIGlkID09IG51bGwgPyBpZCA6ICcnICsgaWQ7XG4gIH07IC8vIGlkIG11c3QgYmUgc3RyaW5nXG5cbiAgaWYgKHN0cnVjdC5zb3VyY2UgIT09IHVuZGVmaW5lZCB8fCBzdHJ1Y3QudGFyZ2V0ICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgc3JjSWQgPSB0b1N0cmluZyhzdHJ1Y3Quc291cmNlKTtcbiAgICB2YXIgdGd0SWQgPSB0b1N0cmluZyhzdHJ1Y3QudGFyZ2V0KTtcbiAgICB2YXIgc3JjRXhpc3RzID0gc3JjSWQgIT0gbnVsbCAmJiBjeS5oYXNFbGVtZW50V2l0aElkKHNyY0lkKTtcbiAgICB2YXIgdGd0RXhpc3RzID0gdGd0SWQgIT0gbnVsbCAmJiBjeS5oYXNFbGVtZW50V2l0aElkKHRndElkKTtcbiAgICBpZiAoc3JjRXhpc3RzIHx8IHRndEV4aXN0cykge1xuICAgICAgY3kuYmF0Y2goZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBhdm9pZCBkdXBsaWNhdGUgc3R5bGUgdXBkYXRlc1xuICAgICAgICBlbGVzLnJlbW92ZShub3RpZnlSZW5kZXJlciwgbW9kaWZ5UG9vbCk7IC8vIGNsZWFuIHVwIHJlZnMgZXRjLlxuICAgICAgICBlbGVzLmVtaXRBbmROb3RpZnkoJ21vdmVvdXQnKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGVsZSA9IGVsZXNbaV07XG4gICAgICAgICAgdmFyIF9kYXRhNSA9IGVsZS5fcHJpdmF0ZS5kYXRhO1xuICAgICAgICAgIGlmIChlbGUuaXNFZGdlKCkpIHtcbiAgICAgICAgICAgIGlmIChzcmNFeGlzdHMpIHtcbiAgICAgICAgICAgICAgX2RhdGE1LnNvdXJjZSA9IHNyY0lkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRndEV4aXN0cykge1xuICAgICAgICAgICAgICBfZGF0YTUudGFyZ2V0ID0gdGd0SWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsZXMucmVzdG9yZShub3RpZnlSZW5kZXJlciwgbW9kaWZ5UG9vbCk7IC8vIG1ha2UgbmV3IHJlZnMsIHN0eWxlLCBldGMuXG4gICAgICB9KTtcblxuICAgICAgZWxlcy5lbWl0QW5kTm90aWZ5KCdtb3ZlJyk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHN0cnVjdC5wYXJlbnQgIT09IHVuZGVmaW5lZCkge1xuICAgIC8vIG1vdmUgbm9kZSB0byBuZXcgcGFyZW50XG4gICAgdmFyIHBhcmVudElkID0gdG9TdHJpbmcoc3RydWN0LnBhcmVudCk7XG4gICAgdmFyIHBhcmVudEV4aXN0cyA9IHBhcmVudElkID09PSBudWxsIHx8IGN5Lmhhc0VsZW1lbnRXaXRoSWQocGFyZW50SWQpO1xuICAgIGlmIChwYXJlbnRFeGlzdHMpIHtcbiAgICAgIHZhciBwaWRUb0Fzc2lnbiA9IHBhcmVudElkID09PSBudWxsID8gdW5kZWZpbmVkIDogcGFyZW50SWQ7XG4gICAgICBjeS5iYXRjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIGF2b2lkIGR1cGxpY2F0ZSBzdHlsZSB1cGRhdGVzXG4gICAgICAgIHZhciB1cGRhdGVkID0gZWxlcy5yZW1vdmUobm90aWZ5UmVuZGVyZXIsIG1vZGlmeVBvb2wpOyAvLyBjbGVhbiB1cCByZWZzIGV0Yy5cbiAgICAgICAgdXBkYXRlZC5lbWl0QW5kTm90aWZ5KCdtb3Zlb3V0Jyk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBlbGUgPSBlbGVzW2ldO1xuICAgICAgICAgIHZhciBfZGF0YTYgPSBlbGUuX3ByaXZhdGUuZGF0YTtcbiAgICAgICAgICBpZiAoZWxlLmlzTm9kZSgpKSB7XG4gICAgICAgICAgICBfZGF0YTYucGFyZW50ID0gcGlkVG9Bc3NpZ247XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHVwZGF0ZWQucmVzdG9yZShub3RpZnlSZW5kZXJlciwgbW9kaWZ5UG9vbCk7IC8vIG1ha2UgbmV3IHJlZnMsIHN0eWxlLCBldGMuXG4gICAgICB9KTtcblxuICAgICAgZWxlcy5lbWl0QW5kTm90aWZ5KCdtb3ZlJyk7XG4gICAgfVxuICB9XG4gIHJldHVybiB0aGlzO1xufTtcbltlbGVzZm4kaiwgZWxlc2ZuJGksIGVsZXNmbiRoLCBlbGVzZm4kZywgZWxlc2ZuJGYsIGRhdGEsIGVsZXNmbiRkLCBkaW1lbnNpb25zLCBlbGVzZm4kOSwgZWxlc2ZuJDgsIGVsZXNmbiQ3LCBlbGVzZm4kNiwgZWxlc2ZuJDUsIGVsZXNmbiQ0LCBlbGVzZm4kMywgZWxlc2ZuJDJdLmZvckVhY2goZnVuY3Rpb24gKHByb3BzKSB7XG4gIGV4dGVuZChlbGVzZm4kMSwgcHJvcHMpO1xufSk7XG5cbnZhciBjb3JlZm4kOSA9IHtcbiAgYWRkOiBmdW5jdGlvbiBhZGQob3B0cykge1xuICAgIHZhciBlbGVtZW50cztcbiAgICB2YXIgY3kgPSB0aGlzO1xuXG4gICAgLy8gYWRkIHRoZSBlbGVtZW50c1xuICAgIGlmIChlbGVtZW50T3JDb2xsZWN0aW9uKG9wdHMpKSB7XG4gICAgICB2YXIgZWxlcyA9IG9wdHM7XG4gICAgICBpZiAoZWxlcy5fcHJpdmF0ZS5jeSA9PT0gY3kpIHtcbiAgICAgICAgLy8gc2FtZSBpbnN0YW5jZSA9PiBqdXN0IHJlc3RvcmVcbiAgICAgICAgZWxlbWVudHMgPSBlbGVzLnJlc3RvcmUoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIG90aGVyd2lzZSwgY29weSBmcm9tIGpzb25cbiAgICAgICAgdmFyIGpzb25zID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBlbGUgPSBlbGVzW2ldO1xuICAgICAgICAgIGpzb25zLnB1c2goZWxlLmpzb24oKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxlbWVudHMgPSBuZXcgQ29sbGVjdGlvbihjeSwganNvbnMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHNwZWNpZnkgYW4gYXJyYXkgb2Ygb3B0aW9uc1xuICAgIGVsc2UgaWYgKGFycmF5KG9wdHMpKSB7XG4gICAgICB2YXIgX2pzb25zID0gb3B0cztcbiAgICAgIGVsZW1lbnRzID0gbmV3IENvbGxlY3Rpb24oY3ksIF9qc29ucyk7XG4gICAgfVxuXG4gICAgLy8gc3BlY2lmeSB2aWEgb3B0cy5ub2RlcyBhbmQgb3B0cy5lZGdlc1xuICAgIGVsc2UgaWYgKHBsYWluT2JqZWN0KG9wdHMpICYmIChhcnJheShvcHRzLm5vZGVzKSB8fCBhcnJheShvcHRzLmVkZ2VzKSkpIHtcbiAgICAgIHZhciBlbGVzQnlHcm91cCA9IG9wdHM7XG4gICAgICB2YXIgX2pzb25zMiA9IFtdO1xuICAgICAgdmFyIGdycyA9IFsnbm9kZXMnLCAnZWRnZXMnXTtcbiAgICAgIGZvciAodmFyIF9pID0gMCwgaWwgPSBncnMubGVuZ3RoOyBfaSA8IGlsOyBfaSsrKSB7XG4gICAgICAgIHZhciBncm91cCA9IGdyc1tfaV07XG4gICAgICAgIHZhciBlbGVzQXJyYXkgPSBlbGVzQnlHcm91cFtncm91cF07XG4gICAgICAgIGlmIChhcnJheShlbGVzQXJyYXkpKSB7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDAsIGpsID0gZWxlc0FycmF5Lmxlbmd0aDsgaiA8IGpsOyBqKyspIHtcbiAgICAgICAgICAgIHZhciBqc29uID0gZXh0ZW5kKHtcbiAgICAgICAgICAgICAgZ3JvdXA6IGdyb3VwXG4gICAgICAgICAgICB9LCBlbGVzQXJyYXlbal0pO1xuICAgICAgICAgICAgX2pzb25zMi5wdXNoKGpzb24pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxlbWVudHMgPSBuZXcgQ29sbGVjdGlvbihjeSwgX2pzb25zMik7XG4gICAgfVxuXG4gICAgLy8gc3BlY2lmeSBvcHRpb25zIGZvciBvbmUgZWxlbWVudFxuICAgIGVsc2Uge1xuICAgICAgdmFyIF9qc29uID0gb3B0cztcbiAgICAgIGVsZW1lbnRzID0gbmV3IEVsZW1lbnQoY3ksIF9qc29uKS5jb2xsZWN0aW9uKCk7XG4gICAgfVxuICAgIHJldHVybiBlbGVtZW50cztcbiAgfSxcbiAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoY29sbGVjdGlvbikge1xuICAgIGlmIChlbGVtZW50T3JDb2xsZWN0aW9uKGNvbGxlY3Rpb24pKSA7IGVsc2UgaWYgKHN0cmluZyhjb2xsZWN0aW9uKSkge1xuICAgICAgdmFyIHNlbGVjdG9yID0gY29sbGVjdGlvbjtcbiAgICAgIGNvbGxlY3Rpb24gPSB0aGlzLiQoc2VsZWN0b3IpO1xuICAgIH1cbiAgICByZXR1cm4gY29sbGVjdGlvbi5yZW1vdmUoKTtcbiAgfVxufTtcblxuLyogZ2xvYmFsIEZsb2F0MzJBcnJheSAqL1xuXG4vKiEgQmV6aWVyIGN1cnZlIGZ1bmN0aW9uIGdlbmVyYXRvci4gQ29weXJpZ2h0IEdhZXRhbiBSZW5hdWRlYXUuIE1JVCBMaWNlbnNlOiBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL01JVF9MaWNlbnNlICovXG5mdW5jdGlvbiBnZW5lcmF0ZUN1YmljQmV6aWVyKG1YMSwgbVkxLCBtWDIsIG1ZMikge1xuICB2YXIgTkVXVE9OX0lURVJBVElPTlMgPSA0LFxuICAgIE5FV1RPTl9NSU5fU0xPUEUgPSAwLjAwMSxcbiAgICBTVUJESVZJU0lPTl9QUkVDSVNJT04gPSAwLjAwMDAwMDEsXG4gICAgU1VCRElWSVNJT05fTUFYX0lURVJBVElPTlMgPSAxMCxcbiAgICBrU3BsaW5lVGFibGVTaXplID0gMTEsXG4gICAga1NhbXBsZVN0ZXBTaXplID0gMS4wIC8gKGtTcGxpbmVUYWJsZVNpemUgLSAxLjApLFxuICAgIGZsb2F0MzJBcnJheVN1cHBvcnRlZCA9IHR5cGVvZiBGbG9hdDMyQXJyYXkgIT09ICd1bmRlZmluZWQnO1xuXG4gIC8qIE11c3QgY29udGFpbiBmb3VyIGFyZ3VtZW50cy4gKi9cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggIT09IDQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKiBBcmd1bWVudHMgbXVzdCBiZSBudW1iZXJzLiAqL1xuICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7ICsraSkge1xuICAgIGlmICh0eXBlb2YgYXJndW1lbnRzW2ldICE9PSBcIm51bWJlclwiIHx8IGlzTmFOKGFyZ3VtZW50c1tpXSkgfHwgIWlzRmluaXRlKGFyZ3VtZW50c1tpXSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICAvKiBYIHZhbHVlcyBtdXN0IGJlIGluIHRoZSBbMCwgMV0gcmFuZ2UuICovXG4gIG1YMSA9IE1hdGgubWluKG1YMSwgMSk7XG4gIG1YMiA9IE1hdGgubWluKG1YMiwgMSk7XG4gIG1YMSA9IE1hdGgubWF4KG1YMSwgMCk7XG4gIG1YMiA9IE1hdGgubWF4KG1YMiwgMCk7XG4gIHZhciBtU2FtcGxlVmFsdWVzID0gZmxvYXQzMkFycmF5U3VwcG9ydGVkID8gbmV3IEZsb2F0MzJBcnJheShrU3BsaW5lVGFibGVTaXplKSA6IG5ldyBBcnJheShrU3BsaW5lVGFibGVTaXplKTtcbiAgZnVuY3Rpb24gQShhQTEsIGFBMikge1xuICAgIHJldHVybiAxLjAgLSAzLjAgKiBhQTIgKyAzLjAgKiBhQTE7XG4gIH1cbiAgZnVuY3Rpb24gQihhQTEsIGFBMikge1xuICAgIHJldHVybiAzLjAgKiBhQTIgLSA2LjAgKiBhQTE7XG4gIH1cbiAgZnVuY3Rpb24gQyhhQTEpIHtcbiAgICByZXR1cm4gMy4wICogYUExO1xuICB9XG4gIGZ1bmN0aW9uIGNhbGNCZXppZXIoYVQsIGFBMSwgYUEyKSB7XG4gICAgcmV0dXJuICgoQShhQTEsIGFBMikgKiBhVCArIEIoYUExLCBhQTIpKSAqIGFUICsgQyhhQTEpKSAqIGFUO1xuICB9XG4gIGZ1bmN0aW9uIGdldFNsb3BlKGFULCBhQTEsIGFBMikge1xuICAgIHJldHVybiAzLjAgKiBBKGFBMSwgYUEyKSAqIGFUICogYVQgKyAyLjAgKiBCKGFBMSwgYUEyKSAqIGFUICsgQyhhQTEpO1xuICB9XG4gIGZ1bmN0aW9uIG5ld3RvblJhcGhzb25JdGVyYXRlKGFYLCBhR3Vlc3NUKSB7XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IE5FV1RPTl9JVEVSQVRJT05TOyArK19pKSB7XG4gICAgICB2YXIgY3VycmVudFNsb3BlID0gZ2V0U2xvcGUoYUd1ZXNzVCwgbVgxLCBtWDIpO1xuICAgICAgaWYgKGN1cnJlbnRTbG9wZSA9PT0gMC4wKSB7XG4gICAgICAgIHJldHVybiBhR3Vlc3NUO1xuICAgICAgfVxuICAgICAgdmFyIGN1cnJlbnRYID0gY2FsY0JlemllcihhR3Vlc3NULCBtWDEsIG1YMikgLSBhWDtcbiAgICAgIGFHdWVzc1QgLT0gY3VycmVudFggLyBjdXJyZW50U2xvcGU7XG4gICAgfVxuICAgIHJldHVybiBhR3Vlc3NUO1xuICB9XG4gIGZ1bmN0aW9uIGNhbGNTYW1wbGVWYWx1ZXMoKSB7XG4gICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwga1NwbGluZVRhYmxlU2l6ZTsgKytfaTIpIHtcbiAgICAgIG1TYW1wbGVWYWx1ZXNbX2kyXSA9IGNhbGNCZXppZXIoX2kyICoga1NhbXBsZVN0ZXBTaXplLCBtWDEsIG1YMik7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGJpbmFyeVN1YmRpdmlkZShhWCwgYUEsIGFCKSB7XG4gICAgdmFyIGN1cnJlbnRYLFxuICAgICAgY3VycmVudFQsXG4gICAgICBpID0gMDtcbiAgICBkbyB7XG4gICAgICBjdXJyZW50VCA9IGFBICsgKGFCIC0gYUEpIC8gMi4wO1xuICAgICAgY3VycmVudFggPSBjYWxjQmV6aWVyKGN1cnJlbnRULCBtWDEsIG1YMikgLSBhWDtcbiAgICAgIGlmIChjdXJyZW50WCA+IDAuMCkge1xuICAgICAgICBhQiA9IGN1cnJlbnRUO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYUEgPSBjdXJyZW50VDtcbiAgICAgIH1cbiAgICB9IHdoaWxlIChNYXRoLmFicyhjdXJyZW50WCkgPiBTVUJESVZJU0lPTl9QUkVDSVNJT04gJiYgKytpIDwgU1VCRElWSVNJT05fTUFYX0lURVJBVElPTlMpO1xuICAgIHJldHVybiBjdXJyZW50VDtcbiAgfVxuICBmdW5jdGlvbiBnZXRURm9yWChhWCkge1xuICAgIHZhciBpbnRlcnZhbFN0YXJ0ID0gMC4wLFxuICAgICAgY3VycmVudFNhbXBsZSA9IDEsXG4gICAgICBsYXN0U2FtcGxlID0ga1NwbGluZVRhYmxlU2l6ZSAtIDE7XG4gICAgZm9yICg7IGN1cnJlbnRTYW1wbGUgIT09IGxhc3RTYW1wbGUgJiYgbVNhbXBsZVZhbHVlc1tjdXJyZW50U2FtcGxlXSA8PSBhWDsgKytjdXJyZW50U2FtcGxlKSB7XG4gICAgICBpbnRlcnZhbFN0YXJ0ICs9IGtTYW1wbGVTdGVwU2l6ZTtcbiAgICB9XG4gICAgLS1jdXJyZW50U2FtcGxlO1xuICAgIHZhciBkaXN0ID0gKGFYIC0gbVNhbXBsZVZhbHVlc1tjdXJyZW50U2FtcGxlXSkgLyAobVNhbXBsZVZhbHVlc1tjdXJyZW50U2FtcGxlICsgMV0gLSBtU2FtcGxlVmFsdWVzW2N1cnJlbnRTYW1wbGVdKSxcbiAgICAgIGd1ZXNzRm9yVCA9IGludGVydmFsU3RhcnQgKyBkaXN0ICoga1NhbXBsZVN0ZXBTaXplLFxuICAgICAgaW5pdGlhbFNsb3BlID0gZ2V0U2xvcGUoZ3Vlc3NGb3JULCBtWDEsIG1YMik7XG4gICAgaWYgKGluaXRpYWxTbG9wZSA+PSBORVdUT05fTUlOX1NMT1BFKSB7XG4gICAgICByZXR1cm4gbmV3dG9uUmFwaHNvbkl0ZXJhdGUoYVgsIGd1ZXNzRm9yVCk7XG4gICAgfSBlbHNlIGlmIChpbml0aWFsU2xvcGUgPT09IDAuMCkge1xuICAgICAgcmV0dXJuIGd1ZXNzRm9yVDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGJpbmFyeVN1YmRpdmlkZShhWCwgaW50ZXJ2YWxTdGFydCwgaW50ZXJ2YWxTdGFydCArIGtTYW1wbGVTdGVwU2l6ZSk7XG4gICAgfVxuICB9XG4gIHZhciBfcHJlY29tcHV0ZWQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gcHJlY29tcHV0ZSgpIHtcbiAgICBfcHJlY29tcHV0ZWQgPSB0cnVlO1xuICAgIGlmIChtWDEgIT09IG1ZMSB8fCBtWDIgIT09IG1ZMikge1xuICAgICAgY2FsY1NhbXBsZVZhbHVlcygpO1xuICAgIH1cbiAgfVxuICB2YXIgZiA9IGZ1bmN0aW9uIGYoYVgpIHtcbiAgICBpZiAoIV9wcmVjb21wdXRlZCkge1xuICAgICAgcHJlY29tcHV0ZSgpO1xuICAgIH1cbiAgICBpZiAobVgxID09PSBtWTEgJiYgbVgyID09PSBtWTIpIHtcbiAgICAgIHJldHVybiBhWDtcbiAgICB9XG4gICAgaWYgKGFYID09PSAwKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgaWYgKGFYID09PSAxKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgcmV0dXJuIGNhbGNCZXppZXIoZ2V0VEZvclgoYVgpLCBtWTEsIG1ZMik7XG4gIH07XG4gIGYuZ2V0Q29udHJvbFBvaW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gW3tcbiAgICAgIHg6IG1YMSxcbiAgICAgIHk6IG1ZMVxuICAgIH0sIHtcbiAgICAgIHg6IG1YMixcbiAgICAgIHk6IG1ZMlxuICAgIH1dO1xuICB9O1xuICB2YXIgc3RyID0gXCJnZW5lcmF0ZUJlemllcihcIiArIFttWDEsIG1ZMSwgbVgyLCBtWTJdICsgXCIpXCI7XG4gIGYudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHN0cjtcbiAgfTtcbiAgcmV0dXJuIGY7XG59XG5cbi8qISBSdW5nZS1LdXR0YSBzcHJpbmcgcGh5c2ljcyBmdW5jdGlvbiBnZW5lcmF0b3IuIEFkYXB0ZWQgZnJvbSBGcmFtZXIuanMsIGNvcHlyaWdodCBLb2VuIEJvay4gTUlUIExpY2Vuc2U6IGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTUlUX0xpY2Vuc2UgKi9cbi8qIEdpdmVuIGEgdGVuc2lvbiwgZnJpY3Rpb24sIGFuZCBkdXJhdGlvbiwgYSBzaW11bGF0aW9uIGF0IDYwRlBTIHdpbGwgZmlyc3QgcnVuIHdpdGhvdXQgYSBkZWZpbmVkIGR1cmF0aW9uIGluIG9yZGVyIHRvIGNhbGN1bGF0ZSB0aGUgZnVsbCBwYXRoLiBBIHNlY29uZCBwYXNzXG4gICB0aGVuIGFkanVzdHMgdGhlIHRpbWUgZGVsdGEgLS0gdXNpbmcgdGhlIHJlbGF0aW9uIGJldHdlZW4gYWN0dWFsIHRpbWUgYW5kIGR1cmF0aW9uIC0tIHRvIGNhbGN1bGF0ZSB0aGUgcGF0aCBmb3IgdGhlIGR1cmF0aW9uLWNvbnN0cmFpbmVkIGFuaW1hdGlvbi4gKi9cbnZhciBnZW5lcmF0ZVNwcmluZ1JLNCA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gc3ByaW5nQWNjZWxlcmF0aW9uRm9yU3RhdGUoc3RhdGUpIHtcbiAgICByZXR1cm4gLXN0YXRlLnRlbnNpb24gKiBzdGF0ZS54IC0gc3RhdGUuZnJpY3Rpb24gKiBzdGF0ZS52O1xuICB9XG4gIGZ1bmN0aW9uIHNwcmluZ0V2YWx1YXRlU3RhdGVXaXRoRGVyaXZhdGl2ZShpbml0aWFsU3RhdGUsIGR0LCBkZXJpdmF0aXZlKSB7XG4gICAgdmFyIHN0YXRlID0ge1xuICAgICAgeDogaW5pdGlhbFN0YXRlLnggKyBkZXJpdmF0aXZlLmR4ICogZHQsXG4gICAgICB2OiBpbml0aWFsU3RhdGUudiArIGRlcml2YXRpdmUuZHYgKiBkdCxcbiAgICAgIHRlbnNpb246IGluaXRpYWxTdGF0ZS50ZW5zaW9uLFxuICAgICAgZnJpY3Rpb246IGluaXRpYWxTdGF0ZS5mcmljdGlvblxuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgIGR4OiBzdGF0ZS52LFxuICAgICAgZHY6IHNwcmluZ0FjY2VsZXJhdGlvbkZvclN0YXRlKHN0YXRlKVxuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gc3ByaW5nSW50ZWdyYXRlU3RhdGUoc3RhdGUsIGR0KSB7XG4gICAgdmFyIGEgPSB7XG4gICAgICAgIGR4OiBzdGF0ZS52LFxuICAgICAgICBkdjogc3ByaW5nQWNjZWxlcmF0aW9uRm9yU3RhdGUoc3RhdGUpXG4gICAgICB9LFxuICAgICAgYiA9IHNwcmluZ0V2YWx1YXRlU3RhdGVXaXRoRGVyaXZhdGl2ZShzdGF0ZSwgZHQgKiAwLjUsIGEpLFxuICAgICAgYyA9IHNwcmluZ0V2YWx1YXRlU3RhdGVXaXRoRGVyaXZhdGl2ZShzdGF0ZSwgZHQgKiAwLjUsIGIpLFxuICAgICAgZCA9IHNwcmluZ0V2YWx1YXRlU3RhdGVXaXRoRGVyaXZhdGl2ZShzdGF0ZSwgZHQsIGMpLFxuICAgICAgZHhkdCA9IDEuMCAvIDYuMCAqIChhLmR4ICsgMi4wICogKGIuZHggKyBjLmR4KSArIGQuZHgpLFxuICAgICAgZHZkdCA9IDEuMCAvIDYuMCAqIChhLmR2ICsgMi4wICogKGIuZHYgKyBjLmR2KSArIGQuZHYpO1xuICAgIHN0YXRlLnggPSBzdGF0ZS54ICsgZHhkdCAqIGR0O1xuICAgIHN0YXRlLnYgPSBzdGF0ZS52ICsgZHZkdCAqIGR0O1xuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24gc3ByaW5nUks0RmFjdG9yeSh0ZW5zaW9uLCBmcmljdGlvbiwgZHVyYXRpb24pIHtcbiAgICB2YXIgaW5pdFN0YXRlID0ge1xuICAgICAgICB4OiAtMSxcbiAgICAgICAgdjogMCxcbiAgICAgICAgdGVuc2lvbjogbnVsbCxcbiAgICAgICAgZnJpY3Rpb246IG51bGxcbiAgICAgIH0sXG4gICAgICBwYXRoID0gWzBdLFxuICAgICAgdGltZV9sYXBzZWQgPSAwLFxuICAgICAgdG9sZXJhbmNlID0gMSAvIDEwMDAwLFxuICAgICAgRFQgPSAxNiAvIDEwMDAsXG4gICAgICBoYXZlX2R1cmF0aW9uLFxuICAgICAgZHQsXG4gICAgICBsYXN0X3N0YXRlO1xuICAgIHRlbnNpb24gPSBwYXJzZUZsb2F0KHRlbnNpb24pIHx8IDUwMDtcbiAgICBmcmljdGlvbiA9IHBhcnNlRmxvYXQoZnJpY3Rpb24pIHx8IDIwO1xuICAgIGR1cmF0aW9uID0gZHVyYXRpb24gfHwgbnVsbDtcbiAgICBpbml0U3RhdGUudGVuc2lvbiA9IHRlbnNpb247XG4gICAgaW5pdFN0YXRlLmZyaWN0aW9uID0gZnJpY3Rpb247XG4gICAgaGF2ZV9kdXJhdGlvbiA9IGR1cmF0aW9uICE9PSBudWxsO1xuXG4gICAgLyogQ2FsY3VsYXRlIHRoZSBhY3R1YWwgdGltZSBpdCB0YWtlcyBmb3IgdGhpcyBhbmltYXRpb24gdG8gY29tcGxldGUgd2l0aCB0aGUgcHJvdmlkZWQgY29uZGl0aW9ucy4gKi9cbiAgICBpZiAoaGF2ZV9kdXJhdGlvbikge1xuICAgICAgLyogUnVuIHRoZSBzaW11bGF0aW9uIHdpdGhvdXQgYSBkdXJhdGlvbi4gKi9cbiAgICAgIHRpbWVfbGFwc2VkID0gc3ByaW5nUks0RmFjdG9yeSh0ZW5zaW9uLCBmcmljdGlvbik7XG4gICAgICAvKiBDb21wdXRlIHRoZSBhZGp1c3RlZCB0aW1lIGRlbHRhLiAqL1xuICAgICAgZHQgPSB0aW1lX2xhcHNlZCAvIGR1cmF0aW9uICogRFQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGR0ID0gRFQ7XG4gICAgfVxuICAgIGZvciAoOzspIHtcbiAgICAgIC8qIE5leHQvc3RlcCBmdW5jdGlvbiAuKi9cbiAgICAgIGxhc3Rfc3RhdGUgPSBzcHJpbmdJbnRlZ3JhdGVTdGF0ZShsYXN0X3N0YXRlIHx8IGluaXRTdGF0ZSwgZHQpO1xuICAgICAgLyogU3RvcmUgdGhlIHBvc2l0aW9uLiAqL1xuICAgICAgcGF0aC5wdXNoKDEgKyBsYXN0X3N0YXRlLngpO1xuICAgICAgdGltZV9sYXBzZWQgKz0gMTY7XG4gICAgICAvKiBJZiB0aGUgY2hhbmdlIHRocmVzaG9sZCBpcyByZWFjaGVkLCBicmVhay4gKi9cbiAgICAgIGlmICghKE1hdGguYWJzKGxhc3Rfc3RhdGUueCkgPiB0b2xlcmFuY2UgJiYgTWF0aC5hYnMobGFzdF9zdGF0ZS52KSA+IHRvbGVyYW5jZSkpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyogSWYgZHVyYXRpb24gaXMgbm90IGRlZmluZWQsIHJldHVybiB0aGUgYWN0dWFsIHRpbWUgcmVxdWlyZWQgZm9yIGNvbXBsZXRpbmcgdGhpcyBhbmltYXRpb24uIE90aGVyd2lzZSwgcmV0dXJuIGEgY2xvc3VyZSB0aGF0IGhvbGRzIHRoZVxuICAgICAgIGNvbXB1dGVkIHBhdGggYW5kIHJldHVybnMgYSBzbmFwc2hvdCBvZiB0aGUgcG9zaXRpb24gYWNjb3JkaW5nIHRvIGEgZ2l2ZW4gcGVyY2VudENvbXBsZXRlLiAqL1xuICAgIHJldHVybiAhaGF2ZV9kdXJhdGlvbiA/IHRpbWVfbGFwc2VkIDogZnVuY3Rpb24gKHBlcmNlbnRDb21wbGV0ZSkge1xuICAgICAgcmV0dXJuIHBhdGhbcGVyY2VudENvbXBsZXRlICogKHBhdGgubGVuZ3RoIC0gMSkgfCAwXTtcbiAgICB9O1xuICB9O1xufSgpO1xuXG52YXIgY3ViaWNCZXppZXIgPSBmdW5jdGlvbiBjdWJpY0Jlemllcih0MSwgcDEsIHQyLCBwMikge1xuICB2YXIgYmV6aWVyID0gZ2VuZXJhdGVDdWJpY0Jlemllcih0MSwgcDEsIHQyLCBwMik7XG4gIHJldHVybiBmdW5jdGlvbiAoc3RhcnQsIGVuZCwgcGVyY2VudCkge1xuICAgIHJldHVybiBzdGFydCArIChlbmQgLSBzdGFydCkgKiBiZXppZXIocGVyY2VudCk7XG4gIH07XG59O1xudmFyIGVhc2luZ3MgPSB7XG4gICdsaW5lYXInOiBmdW5jdGlvbiBsaW5lYXIoc3RhcnQsIGVuZCwgcGVyY2VudCkge1xuICAgIHJldHVybiBzdGFydCArIChlbmQgLSBzdGFydCkgKiBwZXJjZW50O1xuICB9LFxuICAvLyBkZWZhdWx0IGVhc2luZ3NcbiAgJ2Vhc2UnOiBjdWJpY0JlemllcigwLjI1LCAwLjEsIDAuMjUsIDEpLFxuICAnZWFzZS1pbic6IGN1YmljQmV6aWVyKDAuNDIsIDAsIDEsIDEpLFxuICAnZWFzZS1vdXQnOiBjdWJpY0JlemllcigwLCAwLCAwLjU4LCAxKSxcbiAgJ2Vhc2UtaW4tb3V0JzogY3ViaWNCZXppZXIoMC40MiwgMCwgMC41OCwgMSksXG4gIC8vIHNpbmVcbiAgJ2Vhc2UtaW4tc2luZSc6IGN1YmljQmV6aWVyKDAuNDcsIDAsIDAuNzQ1LCAwLjcxNSksXG4gICdlYXNlLW91dC1zaW5lJzogY3ViaWNCZXppZXIoMC4zOSwgMC41NzUsIDAuNTY1LCAxKSxcbiAgJ2Vhc2UtaW4tb3V0LXNpbmUnOiBjdWJpY0JlemllcigwLjQ0NSwgMC4wNSwgMC41NSwgMC45NSksXG4gIC8vIHF1YWRcbiAgJ2Vhc2UtaW4tcXVhZCc6IGN1YmljQmV6aWVyKDAuNTUsIDAuMDg1LCAwLjY4LCAwLjUzKSxcbiAgJ2Vhc2Utb3V0LXF1YWQnOiBjdWJpY0JlemllcigwLjI1LCAwLjQ2LCAwLjQ1LCAwLjk0KSxcbiAgJ2Vhc2UtaW4tb3V0LXF1YWQnOiBjdWJpY0JlemllcigwLjQ1NSwgMC4wMywgMC41MTUsIDAuOTU1KSxcbiAgLy8gY3ViaWNcbiAgJ2Vhc2UtaW4tY3ViaWMnOiBjdWJpY0JlemllcigwLjU1LCAwLjA1NSwgMC42NzUsIDAuMTkpLFxuICAnZWFzZS1vdXQtY3ViaWMnOiBjdWJpY0JlemllcigwLjIxNSwgMC42MSwgMC4zNTUsIDEpLFxuICAnZWFzZS1pbi1vdXQtY3ViaWMnOiBjdWJpY0JlemllcigwLjY0NSwgMC4wNDUsIDAuMzU1LCAxKSxcbiAgLy8gcXVhcnRcbiAgJ2Vhc2UtaW4tcXVhcnQnOiBjdWJpY0JlemllcigwLjg5NSwgMC4wMywgMC42ODUsIDAuMjIpLFxuICAnZWFzZS1vdXQtcXVhcnQnOiBjdWJpY0JlemllcigwLjE2NSwgMC44NCwgMC40NCwgMSksXG4gICdlYXNlLWluLW91dC1xdWFydCc6IGN1YmljQmV6aWVyKDAuNzcsIDAsIDAuMTc1LCAxKSxcbiAgLy8gcXVpbnRcbiAgJ2Vhc2UtaW4tcXVpbnQnOiBjdWJpY0JlemllcigwLjc1NSwgMC4wNSwgMC44NTUsIDAuMDYpLFxuICAnZWFzZS1vdXQtcXVpbnQnOiBjdWJpY0JlemllcigwLjIzLCAxLCAwLjMyLCAxKSxcbiAgJ2Vhc2UtaW4tb3V0LXF1aW50JzogY3ViaWNCZXppZXIoMC44NiwgMCwgMC4wNywgMSksXG4gIC8vIGV4cG9cbiAgJ2Vhc2UtaW4tZXhwbyc6IGN1YmljQmV6aWVyKDAuOTUsIDAuMDUsIDAuNzk1LCAwLjAzNSksXG4gICdlYXNlLW91dC1leHBvJzogY3ViaWNCZXppZXIoMC4xOSwgMSwgMC4yMiwgMSksXG4gICdlYXNlLWluLW91dC1leHBvJzogY3ViaWNCZXppZXIoMSwgMCwgMCwgMSksXG4gIC8vIGNpcmNcbiAgJ2Vhc2UtaW4tY2lyYyc6IGN1YmljQmV6aWVyKDAuNiwgMC4wNCwgMC45OCwgMC4zMzUpLFxuICAnZWFzZS1vdXQtY2lyYyc6IGN1YmljQmV6aWVyKDAuMDc1LCAwLjgyLCAwLjE2NSwgMSksXG4gICdlYXNlLWluLW91dC1jaXJjJzogY3ViaWNCZXppZXIoMC43ODUsIDAuMTM1LCAwLjE1LCAwLjg2KSxcbiAgLy8gdXNlciBwYXJhbSBlYXNpbmdzLi4uXG5cbiAgJ3NwcmluZyc6IGZ1bmN0aW9uIHNwcmluZyh0ZW5zaW9uLCBmcmljdGlvbiwgZHVyYXRpb24pIHtcbiAgICBpZiAoZHVyYXRpb24gPT09IDApIHtcbiAgICAgIC8vIGNhbid0IGdldCBhIHNwcmluZyB3LyBkdXJhdGlvbiAwXG4gICAgICByZXR1cm4gZWFzaW5ncy5saW5lYXI7IC8vIGR1cmF0aW9uIDAgPT4ganVtcCB0byBlbmQgc28gaW1wbCBkb2Vzbid0IG1hdHRlclxuICAgIH1cblxuICAgIHZhciBzcHJpbmcgPSBnZW5lcmF0ZVNwcmluZ1JLNCh0ZW5zaW9uLCBmcmljdGlvbiwgZHVyYXRpb24pO1xuICAgIHJldHVybiBmdW5jdGlvbiAoc3RhcnQsIGVuZCwgcGVyY2VudCkge1xuICAgICAgcmV0dXJuIHN0YXJ0ICsgKGVuZCAtIHN0YXJ0KSAqIHNwcmluZyhwZXJjZW50KTtcbiAgICB9O1xuICB9LFxuICAnY3ViaWMtYmV6aWVyJzogY3ViaWNCZXppZXJcbn07XG5cbmZ1bmN0aW9uIGdldEVhc2VkVmFsdWUodHlwZSwgc3RhcnQsIGVuZCwgcGVyY2VudCwgZWFzaW5nRm4pIHtcbiAgaWYgKHBlcmNlbnQgPT09IDEpIHtcbiAgICByZXR1cm4gZW5kO1xuICB9XG4gIGlmIChzdGFydCA9PT0gZW5kKSB7XG4gICAgcmV0dXJuIGVuZDtcbiAgfVxuICB2YXIgdmFsID0gZWFzaW5nRm4oc3RhcnQsIGVuZCwgcGVyY2VudCk7XG4gIGlmICh0eXBlID09IG51bGwpIHtcbiAgICByZXR1cm4gdmFsO1xuICB9XG4gIGlmICh0eXBlLnJvdW5kVmFsdWUgfHwgdHlwZS5jb2xvcikge1xuICAgIHZhbCA9IE1hdGgucm91bmQodmFsKTtcbiAgfVxuICBpZiAodHlwZS5taW4gIT09IHVuZGVmaW5lZCkge1xuICAgIHZhbCA9IE1hdGgubWF4KHZhbCwgdHlwZS5taW4pO1xuICB9XG4gIGlmICh0eXBlLm1heCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFsID0gTWF0aC5taW4odmFsLCB0eXBlLm1heCk7XG4gIH1cbiAgcmV0dXJuIHZhbDtcbn1cbmZ1bmN0aW9uIGdldFZhbHVlKHByb3AsIHNwZWMpIHtcbiAgaWYgKHByb3AucGZWYWx1ZSAhPSBudWxsIHx8IHByb3AudmFsdWUgIT0gbnVsbCkge1xuICAgIGlmIChwcm9wLnBmVmFsdWUgIT0gbnVsbCAmJiAoc3BlYyA9PSBudWxsIHx8IHNwZWMudHlwZS51bml0cyAhPT0gJyUnKSkge1xuICAgICAgcmV0dXJuIHByb3AucGZWYWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHByb3AudmFsdWU7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBwcm9wO1xuICB9XG59XG5mdW5jdGlvbiBlYXNlKHN0YXJ0UHJvcCwgZW5kUHJvcCwgcGVyY2VudCwgZWFzaW5nRm4sIHByb3BTcGVjKSB7XG4gIHZhciB0eXBlID0gcHJvcFNwZWMgIT0gbnVsbCA/IHByb3BTcGVjLnR5cGUgOiBudWxsO1xuICBpZiAocGVyY2VudCA8IDApIHtcbiAgICBwZXJjZW50ID0gMDtcbiAgfSBlbHNlIGlmIChwZXJjZW50ID4gMSkge1xuICAgIHBlcmNlbnQgPSAxO1xuICB9XG4gIHZhciBzdGFydCA9IGdldFZhbHVlKHN0YXJ0UHJvcCwgcHJvcFNwZWMpO1xuICB2YXIgZW5kID0gZ2V0VmFsdWUoZW5kUHJvcCwgcHJvcFNwZWMpO1xuICBpZiAobnVtYmVyJDEoc3RhcnQpICYmIG51bWJlciQxKGVuZCkpIHtcbiAgICByZXR1cm4gZ2V0RWFzZWRWYWx1ZSh0eXBlLCBzdGFydCwgZW5kLCBwZXJjZW50LCBlYXNpbmdGbik7XG4gIH0gZWxzZSBpZiAoYXJyYXkoc3RhcnQpICYmIGFycmF5KGVuZCkpIHtcbiAgICB2YXIgZWFzZWRBcnIgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVuZC5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNpID0gc3RhcnRbaV07XG4gICAgICB2YXIgZWkgPSBlbmRbaV07XG4gICAgICBpZiAoc2kgIT0gbnVsbCAmJiBlaSAhPSBudWxsKSB7XG4gICAgICAgIHZhciB2YWwgPSBnZXRFYXNlZFZhbHVlKHR5cGUsIHNpLCBlaSwgcGVyY2VudCwgZWFzaW5nRm4pO1xuICAgICAgICBlYXNlZEFyci5wdXNoKHZhbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlYXNlZEFyci5wdXNoKGVpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGVhc2VkQXJyO1xuICB9XG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIHN0ZXAkMShzZWxmLCBhbmksIG5vdywgaXNDb3JlKSB7XG4gIHZhciBpc0VsZXMgPSAhaXNDb3JlO1xuICB2YXIgX3AgPSBzZWxmLl9wcml2YXRlO1xuICB2YXIgYW5pX3AgPSBhbmkuX3ByaXZhdGU7XG4gIHZhciBwRWFzaW5nID0gYW5pX3AuZWFzaW5nO1xuICB2YXIgc3RhcnRUaW1lID0gYW5pX3Auc3RhcnRUaW1lO1xuICB2YXIgY3kgPSBpc0NvcmUgPyBzZWxmIDogc2VsZi5jeSgpO1xuICB2YXIgc3R5bGUgPSBjeS5zdHlsZSgpO1xuICBpZiAoIWFuaV9wLmVhc2luZ0ltcGwpIHtcbiAgICBpZiAocEVhc2luZyA9PSBudWxsKSB7XG4gICAgICAvLyB1c2UgZGVmYXVsdFxuICAgICAgYW5pX3AuZWFzaW5nSW1wbCA9IGVhc2luZ3NbJ2xpbmVhciddO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB0aGVuIGRlZmluZSB3LyBuYW1lXG4gICAgICB2YXIgZWFzaW5nVmFscztcbiAgICAgIGlmIChzdHJpbmcocEVhc2luZykpIHtcbiAgICAgICAgdmFyIGVhc2luZ1Byb3AgPSBzdHlsZS5wYXJzZSgndHJhbnNpdGlvbi10aW1pbmctZnVuY3Rpb24nLCBwRWFzaW5nKTtcbiAgICAgICAgZWFzaW5nVmFscyA9IGVhc2luZ1Byb3AudmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyB0aGVuIGFzc3VtZSBwcmVwYXJzZWQgYXJyYXlcbiAgICAgICAgZWFzaW5nVmFscyA9IHBFYXNpbmc7XG4gICAgICB9XG4gICAgICB2YXIgbmFtZSwgYXJncztcbiAgICAgIGlmIChzdHJpbmcoZWFzaW5nVmFscykpIHtcbiAgICAgICAgbmFtZSA9IGVhc2luZ1ZhbHM7XG4gICAgICAgIGFyZ3MgPSBbXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5hbWUgPSBlYXNpbmdWYWxzWzFdO1xuICAgICAgICBhcmdzID0gZWFzaW5nVmFscy5zbGljZSgyKS5tYXAoZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgICByZXR1cm4gK247XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKGFyZ3MubGVuZ3RoID4gMCkge1xuICAgICAgICAvLyBjcmVhdGUgd2l0aCBhcmdzXG4gICAgICAgIGlmIChuYW1lID09PSAnc3ByaW5nJykge1xuICAgICAgICAgIGFyZ3MucHVzaChhbmlfcC5kdXJhdGlvbik7IC8vIG5lZWQgZHVyYXRpb24gdG8gZ2VuZXJhdGUgc3ByaW5nXG4gICAgICAgIH1cblxuICAgICAgICBhbmlfcC5lYXNpbmdJbXBsID0gZWFzaW5nc1tuYW1lXS5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHN0YXRpYyBpbXBsIGJ5IG5hbWVcbiAgICAgICAgYW5pX3AuZWFzaW5nSW1wbCA9IGVhc2luZ3NbbmFtZV07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHZhciBlYXNpbmcgPSBhbmlfcC5lYXNpbmdJbXBsO1xuICB2YXIgcGVyY2VudDtcbiAgaWYgKGFuaV9wLmR1cmF0aW9uID09PSAwKSB7XG4gICAgcGVyY2VudCA9IDE7XG4gIH0gZWxzZSB7XG4gICAgcGVyY2VudCA9IChub3cgLSBzdGFydFRpbWUpIC8gYW5pX3AuZHVyYXRpb247XG4gIH1cbiAgaWYgKGFuaV9wLmFwcGx5aW5nKSB7XG4gICAgcGVyY2VudCA9IGFuaV9wLnByb2dyZXNzO1xuICB9XG4gIGlmIChwZXJjZW50IDwgMCkge1xuICAgIHBlcmNlbnQgPSAwO1xuICB9IGVsc2UgaWYgKHBlcmNlbnQgPiAxKSB7XG4gICAgcGVyY2VudCA9IDE7XG4gIH1cbiAgaWYgKGFuaV9wLmRlbGF5ID09IG51bGwpIHtcbiAgICAvLyB0aGVuIHVwZGF0ZVxuXG4gICAgdmFyIHN0YXJ0UG9zID0gYW5pX3Auc3RhcnRQb3NpdGlvbjtcbiAgICB2YXIgZW5kUG9zID0gYW5pX3AucG9zaXRpb247XG4gICAgaWYgKGVuZFBvcyAmJiBpc0VsZXMgJiYgIXNlbGYubG9ja2VkKCkpIHtcbiAgICAgIHZhciBuZXdQb3MgPSB7fTtcbiAgICAgIGlmICh2YWxpZChzdGFydFBvcy54LCBlbmRQb3MueCkpIHtcbiAgICAgICAgbmV3UG9zLnggPSBlYXNlKHN0YXJ0UG9zLngsIGVuZFBvcy54LCBwZXJjZW50LCBlYXNpbmcpO1xuICAgICAgfVxuICAgICAgaWYgKHZhbGlkKHN0YXJ0UG9zLnksIGVuZFBvcy55KSkge1xuICAgICAgICBuZXdQb3MueSA9IGVhc2Uoc3RhcnRQb3MueSwgZW5kUG9zLnksIHBlcmNlbnQsIGVhc2luZyk7XG4gICAgICB9XG4gICAgICBzZWxmLnBvc2l0aW9uKG5ld1Bvcyk7XG4gICAgfVxuICAgIHZhciBzdGFydFBhbiA9IGFuaV9wLnN0YXJ0UGFuO1xuICAgIHZhciBlbmRQYW4gPSBhbmlfcC5wYW47XG4gICAgdmFyIHBhbiA9IF9wLnBhbjtcbiAgICB2YXIgYW5pbWF0aW5nUGFuID0gZW5kUGFuICE9IG51bGwgJiYgaXNDb3JlO1xuICAgIGlmIChhbmltYXRpbmdQYW4pIHtcbiAgICAgIGlmICh2YWxpZChzdGFydFBhbi54LCBlbmRQYW4ueCkpIHtcbiAgICAgICAgcGFuLnggPSBlYXNlKHN0YXJ0UGFuLngsIGVuZFBhbi54LCBwZXJjZW50LCBlYXNpbmcpO1xuICAgICAgfVxuICAgICAgaWYgKHZhbGlkKHN0YXJ0UGFuLnksIGVuZFBhbi55KSkge1xuICAgICAgICBwYW4ueSA9IGVhc2Uoc3RhcnRQYW4ueSwgZW5kUGFuLnksIHBlcmNlbnQsIGVhc2luZyk7XG4gICAgICB9XG4gICAgICBzZWxmLmVtaXQoJ3BhbicpO1xuICAgIH1cbiAgICB2YXIgc3RhcnRab29tID0gYW5pX3Auc3RhcnRab29tO1xuICAgIHZhciBlbmRab29tID0gYW5pX3Auem9vbTtcbiAgICB2YXIgYW5pbWF0aW5nWm9vbSA9IGVuZFpvb20gIT0gbnVsbCAmJiBpc0NvcmU7XG4gICAgaWYgKGFuaW1hdGluZ1pvb20pIHtcbiAgICAgIGlmICh2YWxpZChzdGFydFpvb20sIGVuZFpvb20pKSB7XG4gICAgICAgIF9wLnpvb20gPSBib3VuZChfcC5taW5ab29tLCBlYXNlKHN0YXJ0Wm9vbSwgZW5kWm9vbSwgcGVyY2VudCwgZWFzaW5nKSwgX3AubWF4Wm9vbSk7XG4gICAgICB9XG4gICAgICBzZWxmLmVtaXQoJ3pvb20nKTtcbiAgICB9XG4gICAgaWYgKGFuaW1hdGluZ1BhbiB8fCBhbmltYXRpbmdab29tKSB7XG4gICAgICBzZWxmLmVtaXQoJ3ZpZXdwb3J0Jyk7XG4gICAgfVxuICAgIHZhciBwcm9wcyA9IGFuaV9wLnN0eWxlO1xuICAgIGlmIChwcm9wcyAmJiBwcm9wcy5sZW5ndGggPiAwICYmIGlzRWxlcykge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcHJvcCA9IHByb3BzW2ldO1xuICAgICAgICB2YXIgX25hbWUgPSBwcm9wLm5hbWU7XG4gICAgICAgIHZhciBlbmQgPSBwcm9wO1xuICAgICAgICB2YXIgc3RhcnQgPSBhbmlfcC5zdGFydFN0eWxlW19uYW1lXTtcbiAgICAgICAgdmFyIHByb3BTcGVjID0gc3R5bGUucHJvcGVydGllc1tzdGFydC5uYW1lXTtcbiAgICAgICAgdmFyIGVhc2VkVmFsID0gZWFzZShzdGFydCwgZW5kLCBwZXJjZW50LCBlYXNpbmcsIHByb3BTcGVjKTtcbiAgICAgICAgc3R5bGUub3ZlcnJpZGVCeXBhc3Moc2VsZiwgX25hbWUsIGVhc2VkVmFsKTtcbiAgICAgIH0gLy8gZm9yIHByb3BzXG5cbiAgICAgIHNlbGYuZW1pdCgnc3R5bGUnKTtcbiAgICB9IC8vIGlmXG4gIH1cblxuICBhbmlfcC5wcm9ncmVzcyA9IHBlcmNlbnQ7XG4gIHJldHVybiBwZXJjZW50O1xufVxuZnVuY3Rpb24gdmFsaWQoc3RhcnQsIGVuZCkge1xuICBpZiAoc3RhcnQgPT0gbnVsbCB8fCBlbmQgPT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAobnVtYmVyJDEoc3RhcnQpICYmIG51bWJlciQxKGVuZCkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIGlmIChzdGFydCAmJiBlbmQpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIHN0YXJ0QW5pbWF0aW9uKHNlbGYsIGFuaSwgbm93LCBpc0NvcmUpIHtcbiAgdmFyIGFuaV9wID0gYW5pLl9wcml2YXRlO1xuICBhbmlfcC5zdGFydGVkID0gdHJ1ZTtcbiAgYW5pX3Auc3RhcnRUaW1lID0gbm93IC0gYW5pX3AucHJvZ3Jlc3MgKiBhbmlfcC5kdXJhdGlvbjtcbn1cblxuZnVuY3Rpb24gc3RlcEFsbChub3csIGN5KSB7XG4gIHZhciBlbGVzID0gY3kuX3ByaXZhdGUuYW5pRWxlcztcbiAgdmFyIGRvbmVFbGVzID0gW107XG4gIGZ1bmN0aW9uIHN0ZXBPbmUoZWxlLCBpc0NvcmUpIHtcbiAgICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gICAgdmFyIGN1cnJlbnQgPSBfcC5hbmltYXRpb24uY3VycmVudDtcbiAgICB2YXIgcXVldWUgPSBfcC5hbmltYXRpb24ucXVldWU7XG4gICAgdmFyIHJhbkFuaXMgPSBmYWxzZTtcblxuICAgIC8vIGlmIG5vdGhpbmcgY3VycmVudGx5IGFuaW1hdGluZywgZ2V0IHNvbWV0aGluZyBmcm9tIHRoZSBxdWV1ZVxuICAgIGlmIChjdXJyZW50Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgdmFyIG5leHQgPSBxdWV1ZS5zaGlmdCgpO1xuICAgICAgaWYgKG5leHQpIHtcbiAgICAgICAgY3VycmVudC5wdXNoKG5leHQpO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgY2FsbGJhY2tzID0gZnVuY3Rpb24gY2FsbGJhY2tzKF9jYWxsYmFja3MpIHtcbiAgICAgIGZvciAodmFyIGogPSBfY2FsbGJhY2tzLmxlbmd0aCAtIDE7IGogPj0gMDsgai0tKSB7XG4gICAgICAgIHZhciBjYiA9IF9jYWxsYmFja3Nbal07XG4gICAgICAgIGNiKCk7XG4gICAgICB9XG4gICAgICBfY2FsbGJhY2tzLnNwbGljZSgwLCBfY2FsbGJhY2tzLmxlbmd0aCk7XG4gICAgfTtcblxuICAgIC8vIHN0ZXAgYW5kIHJlbW92ZSBpZiBkb25lXG4gICAgZm9yICh2YXIgaSA9IGN1cnJlbnQubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciBhbmkgPSBjdXJyZW50W2ldO1xuICAgICAgdmFyIGFuaV9wID0gYW5pLl9wcml2YXRlO1xuICAgICAgaWYgKGFuaV9wLnN0b3BwZWQpIHtcbiAgICAgICAgY3VycmVudC5zcGxpY2UoaSwgMSk7XG4gICAgICAgIGFuaV9wLmhvb2tlZCA9IGZhbHNlO1xuICAgICAgICBhbmlfcC5wbGF5aW5nID0gZmFsc2U7XG4gICAgICAgIGFuaV9wLnN0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgY2FsbGJhY2tzKGFuaV9wLmZyYW1lcyk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKCFhbmlfcC5wbGF5aW5nICYmICFhbmlfcC5hcHBseWluZykge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gYW4gYXBwbHkoKSB3aGlsZSBwbGF5aW5nIHNob3VsZG4ndCBkbyBhbnl0aGluZ1xuICAgICAgaWYgKGFuaV9wLnBsYXlpbmcgJiYgYW5pX3AuYXBwbHlpbmcpIHtcbiAgICAgICAgYW5pX3AuYXBwbHlpbmcgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmICghYW5pX3Auc3RhcnRlZCkge1xuICAgICAgICBzdGFydEFuaW1hdGlvbihlbGUsIGFuaSwgbm93KTtcbiAgICAgIH1cbiAgICAgIHN0ZXAkMShlbGUsIGFuaSwgbm93LCBpc0NvcmUpO1xuICAgICAgaWYgKGFuaV9wLmFwcGx5aW5nKSB7XG4gICAgICAgIGFuaV9wLmFwcGx5aW5nID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBjYWxsYmFja3MoYW5pX3AuZnJhbWVzKTtcbiAgICAgIGlmIChhbmlfcC5zdGVwICE9IG51bGwpIHtcbiAgICAgICAgYW5pX3Auc3RlcChub3cpO1xuICAgICAgfVxuICAgICAgaWYgKGFuaS5jb21wbGV0ZWQoKSkge1xuICAgICAgICBjdXJyZW50LnNwbGljZShpLCAxKTtcbiAgICAgICAgYW5pX3AuaG9va2VkID0gZmFsc2U7XG4gICAgICAgIGFuaV9wLnBsYXlpbmcgPSBmYWxzZTtcbiAgICAgICAgYW5pX3Auc3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICBjYWxsYmFja3MoYW5pX3AuY29tcGxldGVzKTtcbiAgICAgIH1cbiAgICAgIHJhbkFuaXMgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoIWlzQ29yZSAmJiBjdXJyZW50Lmxlbmd0aCA9PT0gMCAmJiBxdWV1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgIGRvbmVFbGVzLnB1c2goZWxlKTtcbiAgICB9XG4gICAgcmV0dXJuIHJhbkFuaXM7XG4gIH0gLy8gc3RlcEVsZW1lbnRcblxuICAvLyBoYW5kbGUgYWxsIGVsZXNcbiAgdmFyIHJhbkVsZUFuaSA9IGZhbHNlO1xuICBmb3IgKHZhciBlID0gMDsgZSA8IGVsZXMubGVuZ3RoOyBlKyspIHtcbiAgICB2YXIgZWxlID0gZWxlc1tlXTtcbiAgICB2YXIgaGFuZGxlZFRoaXNFbGUgPSBzdGVwT25lKGVsZSk7XG4gICAgcmFuRWxlQW5pID0gcmFuRWxlQW5pIHx8IGhhbmRsZWRUaGlzRWxlO1xuICB9IC8vIGVhY2ggZWxlbWVudFxuXG4gIHZhciByYW5Db3JlQW5pID0gc3RlcE9uZShjeSwgdHJ1ZSk7XG5cbiAgLy8gbm90aWZ5IHJlbmRlcmVyXG4gIGlmIChyYW5FbGVBbmkgfHwgcmFuQ29yZUFuaSkge1xuICAgIGlmIChlbGVzLmxlbmd0aCA+IDApIHtcbiAgICAgIGN5Lm5vdGlmeSgnZHJhdycsIGVsZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjeS5ub3RpZnkoJ2RyYXcnKTtcbiAgICB9XG4gIH1cblxuICAvLyByZW1vdmUgZWxlbWVudHMgZnJvbSBsaXN0IG9mIGN1cnJlbnRseSBhbmltYXRpbmcgaWYgaXRzIHF1ZXVlcyBhcmUgZW1wdHlcbiAgZWxlcy51bm1lcmdlKGRvbmVFbGVzKTtcbiAgY3kuZW1pdCgnc3RlcCcpO1xufSAvLyBzdGVwQWxsXG5cbnZhciBjb3JlZm4kOCA9IHtcbiAgLy8gcHVsbCBpbiBhbmltYXRpb24gZnVuY3Rpb25zXG4gIGFuaW1hdGU6IGRlZmluZS5hbmltYXRlKCksXG4gIGFuaW1hdGlvbjogZGVmaW5lLmFuaW1hdGlvbigpLFxuICBhbmltYXRlZDogZGVmaW5lLmFuaW1hdGVkKCksXG4gIGNsZWFyUXVldWU6IGRlZmluZS5jbGVhclF1ZXVlKCksXG4gIGRlbGF5OiBkZWZpbmUuZGVsYXkoKSxcbiAgZGVsYXlBbmltYXRpb246IGRlZmluZS5kZWxheUFuaW1hdGlvbigpLFxuICBzdG9wOiBkZWZpbmUuc3RvcCgpLFxuICBhZGRUb0FuaW1hdGlvblBvb2w6IGZ1bmN0aW9uIGFkZFRvQW5pbWF0aW9uUG9vbChlbGVzKSB7XG4gICAgdmFyIGN5ID0gdGhpcztcbiAgICBpZiAoIWN5LnN0eWxlRW5hYmxlZCgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBzYXZlIGN5Y2xlcyB3aGVuIG5vIHN0eWxlIHVzZWRcblxuICAgIGN5Ll9wcml2YXRlLmFuaUVsZXMubWVyZ2UoZWxlcyk7XG4gIH0sXG4gIHN0b3BBbmltYXRpb25Mb29wOiBmdW5jdGlvbiBzdG9wQW5pbWF0aW9uTG9vcCgpIHtcbiAgICB0aGlzLl9wcml2YXRlLmFuaW1hdGlvbnNSdW5uaW5nID0gZmFsc2U7XG4gIH0sXG4gIHN0YXJ0QW5pbWF0aW9uTG9vcDogZnVuY3Rpb24gc3RhcnRBbmltYXRpb25Mb29wKCkge1xuICAgIHZhciBjeSA9IHRoaXM7XG4gICAgY3kuX3ByaXZhdGUuYW5pbWF0aW9uc1J1bm5pbmcgPSB0cnVlO1xuICAgIGlmICghY3kuc3R5bGVFbmFibGVkKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIHNhdmUgY3ljbGVzIHdoZW4gbm8gc3R5bGUgdXNlZFxuXG4gICAgLy8gTkIgdGhlIGFuaW1hdGlvbiBsb29wIHdpbGwgZXhlYyBpbiBoZWFkbGVzcyBlbnZpcm9ubWVudHMgaWYgc3R5bGUgZW5hYmxlZFxuICAgIC8vIGFuZCBleHBsaWNpdCBjeS5kZXN0cm95KCkgaXMgbmVjZXNzYXJ5IHRvIHN0b3AgdGhlIGxvb3BcblxuICAgIGZ1bmN0aW9uIGhlYWRsZXNzU3RlcCgpIHtcbiAgICAgIGlmICghY3kuX3ByaXZhdGUuYW5pbWF0aW9uc1J1bm5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uIGFuaW1hdGlvblN0ZXAobm93KSB7XG4gICAgICAgIHN0ZXBBbGwobm93LCBjeSk7XG4gICAgICAgIGhlYWRsZXNzU3RlcCgpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHZhciByZW5kZXJlciA9IGN5LnJlbmRlcmVyKCk7XG4gICAgaWYgKHJlbmRlcmVyICYmIHJlbmRlcmVyLmJlZm9yZVJlbmRlcikge1xuICAgICAgLy8gbGV0IHRoZSByZW5kZXJlciBzY2hlZHVsZSBhbmltYXRpb25zXG4gICAgICByZW5kZXJlci5iZWZvcmVSZW5kZXIoZnVuY3Rpb24gcmVuZGVyZXJBbmltYXRpb25TdGVwKHdpbGxEcmF3LCBub3cpIHtcbiAgICAgICAgc3RlcEFsbChub3csIGN5KTtcbiAgICAgIH0sIHJlbmRlcmVyLmJlZm9yZVJlbmRlclByaW9yaXRpZXMuYW5pbWF0aW9ucyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIG1hbmFnZSB0aGUgYW5pbWF0aW9uIGxvb3Agb3Vyc2VsdmVzXG4gICAgICBoZWFkbGVzc1N0ZXAoKTsgLy8gZmlyc3QgY2FsbFxuICAgIH1cbiAgfVxufTtcblxudmFyIGVtaXR0ZXJPcHRpb25zID0ge1xuICBxdWFsaWZpZXJDb21wYXJlOiBmdW5jdGlvbiBxdWFsaWZpZXJDb21wYXJlKHNlbGVjdG9yMSwgc2VsZWN0b3IyKSB7XG4gICAgaWYgKHNlbGVjdG9yMSA9PSBudWxsIHx8IHNlbGVjdG9yMiA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gc2VsZWN0b3IxID09IG51bGwgJiYgc2VsZWN0b3IyID09IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBzZWxlY3RvcjEuc2FtZVRleHQoc2VsZWN0b3IyKTtcbiAgICB9XG4gIH0sXG4gIGV2ZW50TWF0Y2hlczogZnVuY3Rpb24gZXZlbnRNYXRjaGVzKGN5LCBsaXN0ZW5lciwgZXZlbnRPYmopIHtcbiAgICB2YXIgc2VsZWN0b3IgPSBsaXN0ZW5lci5xdWFsaWZpZXI7XG4gICAgaWYgKHNlbGVjdG9yICE9IG51bGwpIHtcbiAgICAgIHJldHVybiBjeSAhPT0gZXZlbnRPYmoudGFyZ2V0ICYmIGVsZW1lbnQoZXZlbnRPYmoudGFyZ2V0KSAmJiBzZWxlY3Rvci5tYXRjaGVzKGV2ZW50T2JqLnRhcmdldCk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9LFxuICBhZGRFdmVudEZpZWxkczogZnVuY3Rpb24gYWRkRXZlbnRGaWVsZHMoY3ksIGV2dCkge1xuICAgIGV2dC5jeSA9IGN5O1xuICAgIGV2dC50YXJnZXQgPSBjeTtcbiAgfSxcbiAgY2FsbGJhY2tDb250ZXh0OiBmdW5jdGlvbiBjYWxsYmFja0NvbnRleHQoY3ksIGxpc3RlbmVyLCBldmVudE9iaikge1xuICAgIHJldHVybiBsaXN0ZW5lci5xdWFsaWZpZXIgIT0gbnVsbCA/IGV2ZW50T2JqLnRhcmdldCA6IGN5O1xuICB9XG59O1xudmFyIGFyZ1NlbGVjdG9yID0gZnVuY3Rpb24gYXJnU2VsZWN0b3IoYXJnKSB7XG4gIGlmIChzdHJpbmcoYXJnKSkge1xuICAgIHJldHVybiBuZXcgU2VsZWN0b3IoYXJnKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYXJnO1xuICB9XG59O1xudmFyIGVsZXNmbiA9IHtcbiAgY3JlYXRlRW1pdHRlcjogZnVuY3Rpb24gY3JlYXRlRW1pdHRlcigpIHtcbiAgICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlO1xuICAgIGlmICghX3AuZW1pdHRlcikge1xuICAgICAgX3AuZW1pdHRlciA9IG5ldyBFbWl0dGVyKGVtaXR0ZXJPcHRpb25zLCB0aGlzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIGVtaXR0ZXI6IGZ1bmN0aW9uIGVtaXR0ZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUuZW1pdHRlcjtcbiAgfSxcbiAgb246IGZ1bmN0aW9uIG9uKGV2ZW50cywgc2VsZWN0b3IsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5lbWl0dGVyKCkub24oZXZlbnRzLCBhcmdTZWxlY3RvcihzZWxlY3RvciksIGNhbGxiYWNrKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgcmVtb3ZlTGlzdGVuZXI6IGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKGV2ZW50cywgc2VsZWN0b3IsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5lbWl0dGVyKCkucmVtb3ZlTGlzdGVuZXIoZXZlbnRzLCBhcmdTZWxlY3RvcihzZWxlY3RvciksIGNhbGxiYWNrKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgcmVtb3ZlQWxsTGlzdGVuZXJzOiBmdW5jdGlvbiByZW1vdmVBbGxMaXN0ZW5lcnMoKSB7XG4gICAgdGhpcy5lbWl0dGVyKCkucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIG9uZTogZnVuY3Rpb24gb25lKGV2ZW50cywgc2VsZWN0b3IsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5lbWl0dGVyKCkub25lKGV2ZW50cywgYXJnU2VsZWN0b3Ioc2VsZWN0b3IpLCBjYWxsYmFjayk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIG9uY2U6IGZ1bmN0aW9uIG9uY2UoZXZlbnRzLCBzZWxlY3RvciwgY2FsbGJhY2spIHtcbiAgICB0aGlzLmVtaXR0ZXIoKS5vbmUoZXZlbnRzLCBhcmdTZWxlY3RvcihzZWxlY3RvciksIGNhbGxiYWNrKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgZW1pdDogZnVuY3Rpb24gZW1pdChldmVudHMsIGV4dHJhUGFyYW1zKSB7XG4gICAgdGhpcy5lbWl0dGVyKCkuZW1pdChldmVudHMsIGV4dHJhUGFyYW1zKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgZW1pdEFuZE5vdGlmeTogZnVuY3Rpb24gZW1pdEFuZE5vdGlmeShldmVudCwgZWxlcykge1xuICAgIHRoaXMuZW1pdChldmVudCk7XG4gICAgdGhpcy5ub3RpZnkoZXZlbnQsIGVsZXMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG59O1xuZGVmaW5lLmV2ZW50QWxpYXNlc09uKGVsZXNmbik7XG5cbnZhciBjb3JlZm4kNyA9IHtcbiAgcG5nOiBmdW5jdGlvbiBwbmcob3B0aW9ucykge1xuICAgIHZhciByZW5kZXJlciA9IHRoaXMuX3ByaXZhdGUucmVuZGVyZXI7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgcmV0dXJuIHJlbmRlcmVyLnBuZyhvcHRpb25zKTtcbiAgfSxcbiAganBnOiBmdW5jdGlvbiBqcGcob3B0aW9ucykge1xuICAgIHZhciByZW5kZXJlciA9IHRoaXMuX3ByaXZhdGUucmVuZGVyZXI7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgb3B0aW9ucy5iZyA9IG9wdGlvbnMuYmcgfHwgJyNmZmYnO1xuICAgIHJldHVybiByZW5kZXJlci5qcGcob3B0aW9ucyk7XG4gIH1cbn07XG5jb3JlZm4kNy5qcGVnID0gY29yZWZuJDcuanBnO1xuXG52YXIgY29yZWZuJDYgPSB7XG4gIGxheW91dDogZnVuY3Rpb24gbGF5b3V0KG9wdGlvbnMpIHtcbiAgICB2YXIgY3kgPSB0aGlzO1xuICAgIGlmIChvcHRpb25zID09IG51bGwpIHtcbiAgICAgIGVycm9yKCdMYXlvdXQgb3B0aW9ucyBtdXN0IGJlIHNwZWNpZmllZCB0byBtYWtlIGEgbGF5b3V0Jyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChvcHRpb25zLm5hbWUgPT0gbnVsbCkge1xuICAgICAgZXJyb3IoJ0EgYG5hbWVgIG11c3QgYmUgc3BlY2lmaWVkIHRvIG1ha2UgYSBsYXlvdXQnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIG5hbWUgPSBvcHRpb25zLm5hbWU7XG4gICAgdmFyIExheW91dCA9IGN5LmV4dGVuc2lvbignbGF5b3V0JywgbmFtZSk7XG4gICAgaWYgKExheW91dCA9PSBudWxsKSB7XG4gICAgICBlcnJvcignTm8gc3VjaCBsYXlvdXQgYCcgKyBuYW1lICsgJ2AgZm91bmQuICBEaWQgeW91IGZvcmdldCB0byBpbXBvcnQgaXQgYW5kIGBjeXRvc2NhcGUudXNlKClgIGl0PycpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgZWxlcztcbiAgICBpZiAoc3RyaW5nKG9wdGlvbnMuZWxlcykpIHtcbiAgICAgIGVsZXMgPSBjeS4kKG9wdGlvbnMuZWxlcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsZXMgPSBvcHRpb25zLmVsZXMgIT0gbnVsbCA/IG9wdGlvbnMuZWxlcyA6IGN5LiQoKTtcbiAgICB9XG4gICAgdmFyIGxheW91dCA9IG5ldyBMYXlvdXQoZXh0ZW5kKHt9LCBvcHRpb25zLCB7XG4gICAgICBjeTogY3ksXG4gICAgICBlbGVzOiBlbGVzXG4gICAgfSkpO1xuICAgIHJldHVybiBsYXlvdXQ7XG4gIH1cbn07XG5jb3JlZm4kNi5jcmVhdGVMYXlvdXQgPSBjb3JlZm4kNi5tYWtlTGF5b3V0ID0gY29yZWZuJDYubGF5b3V0O1xuXG52YXIgY29yZWZuJDUgPSB7XG4gIG5vdGlmeTogZnVuY3Rpb24gbm90aWZ5KGV2ZW50TmFtZSwgZXZlbnRFbGVzKSB7XG4gICAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZTtcbiAgICBpZiAodGhpcy5iYXRjaGluZygpKSB7XG4gICAgICBfcC5iYXRjaE5vdGlmaWNhdGlvbnMgPSBfcC5iYXRjaE5vdGlmaWNhdGlvbnMgfHwge307XG4gICAgICB2YXIgZWxlcyA9IF9wLmJhdGNoTm90aWZpY2F0aW9uc1tldmVudE5hbWVdID0gX3AuYmF0Y2hOb3RpZmljYXRpb25zW2V2ZW50TmFtZV0gfHwgdGhpcy5jb2xsZWN0aW9uKCk7XG4gICAgICBpZiAoZXZlbnRFbGVzICE9IG51bGwpIHtcbiAgICAgICAgZWxlcy5tZXJnZShldmVudEVsZXMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuOyAvLyBub3RpZmljYXRpb25zIGFyZSBkaXNhYmxlZCBkdXJpbmcgYmF0Y2hpbmdcbiAgICB9XG5cbiAgICBpZiAoIV9wLm5vdGlmaWNhdGlvbnNFbmFibGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBleGl0IG9uIGRpc2FibGVkXG5cbiAgICB2YXIgcmVuZGVyZXIgPSB0aGlzLnJlbmRlcmVyKCk7XG5cbiAgICAvLyBleGl0IGlmIGRlc3Ryb3koKSBjYWxsZWQgb24gY29yZSBvciByZW5kZXJlciBpbiBiZXR3ZWVuIGZyYW1lcyAjMTQ5OSAjMTUyOFxuICAgIGlmICh0aGlzLmRlc3Ryb3llZCgpIHx8ICFyZW5kZXJlcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZW5kZXJlci5ub3RpZnkoZXZlbnROYW1lLCBldmVudEVsZXMpO1xuICB9LFxuICBub3RpZmljYXRpb25zOiBmdW5jdGlvbiBub3RpZmljYXRpb25zKGJvb2wpIHtcbiAgICB2YXIgcCA9IHRoaXMuX3ByaXZhdGU7XG4gICAgaWYgKGJvb2wgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHAubm90aWZpY2F0aW9uc0VuYWJsZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHAubm90aWZpY2F0aW9uc0VuYWJsZWQgPSBib29sID8gdHJ1ZSA6IGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgbm9Ob3RpZmljYXRpb25zOiBmdW5jdGlvbiBub05vdGlmaWNhdGlvbnMoY2FsbGJhY2spIHtcbiAgICB0aGlzLm5vdGlmaWNhdGlvbnMoZmFsc2UpO1xuICAgIGNhbGxiYWNrKCk7XG4gICAgdGhpcy5ub3RpZmljYXRpb25zKHRydWUpO1xuICB9LFxuICBiYXRjaGluZzogZnVuY3Rpb24gYmF0Y2hpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUuYmF0Y2hDb3VudCA+IDA7XG4gIH0sXG4gIHN0YXJ0QmF0Y2g6IGZ1bmN0aW9uIHN0YXJ0QmF0Y2goKSB7XG4gICAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZTtcbiAgICBpZiAoX3AuYmF0Y2hDb3VudCA9PSBudWxsKSB7XG4gICAgICBfcC5iYXRjaENvdW50ID0gMDtcbiAgICB9XG4gICAgaWYgKF9wLmJhdGNoQ291bnQgPT09IDApIHtcbiAgICAgIF9wLmJhdGNoU3R5bGVFbGVzID0gdGhpcy5jb2xsZWN0aW9uKCk7XG4gICAgICBfcC5iYXRjaE5vdGlmaWNhdGlvbnMgPSB7fTtcbiAgICB9XG4gICAgX3AuYmF0Y2hDb3VudCsrO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBlbmRCYXRjaDogZnVuY3Rpb24gZW5kQmF0Y2goKSB7XG4gICAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZTtcbiAgICBpZiAoX3AuYmF0Y2hDb3VudCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIF9wLmJhdGNoQ291bnQtLTtcbiAgICBpZiAoX3AuYmF0Y2hDb3VudCA9PT0gMCkge1xuICAgICAgLy8gdXBkYXRlIHN0eWxlIGZvciBkaXJ0eSBlbGVzXG4gICAgICBfcC5iYXRjaFN0eWxlRWxlcy51cGRhdGVTdHlsZSgpO1xuICAgICAgdmFyIHJlbmRlcmVyID0gdGhpcy5yZW5kZXJlcigpO1xuXG4gICAgICAvLyBub3RpZnkgdGhlIHJlbmRlcmVyIG9mIHF1ZXVlZCBlbGVzIGFuZCBldmVudCB0eXBlc1xuICAgICAgT2JqZWN0LmtleXMoX3AuYmF0Y2hOb3RpZmljYXRpb25zKS5mb3JFYWNoKGZ1bmN0aW9uIChldmVudE5hbWUpIHtcbiAgICAgICAgdmFyIGVsZXMgPSBfcC5iYXRjaE5vdGlmaWNhdGlvbnNbZXZlbnROYW1lXTtcbiAgICAgICAgaWYgKGVsZXMuZW1wdHkoKSkge1xuICAgICAgICAgIHJlbmRlcmVyLm5vdGlmeShldmVudE5hbWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlbmRlcmVyLm5vdGlmeShldmVudE5hbWUsIGVsZXMpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIGJhdGNoOiBmdW5jdGlvbiBiYXRjaChjYWxsYmFjaykge1xuICAgIHRoaXMuc3RhcnRCYXRjaCgpO1xuICAgIGNhbGxiYWNrKCk7XG4gICAgdGhpcy5lbmRCYXRjaCgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICAvLyBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbiAgYmF0Y2hEYXRhOiBmdW5jdGlvbiBiYXRjaERhdGEobWFwKSB7XG4gICAgdmFyIGN5ID0gdGhpcztcbiAgICByZXR1cm4gdGhpcy5iYXRjaChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgaWRzID0gT2JqZWN0LmtleXMobWFwKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBpZCA9IGlkc1tpXTtcbiAgICAgICAgdmFyIGRhdGEgPSBtYXBbaWRdO1xuICAgICAgICB2YXIgZWxlID0gY3kuZ2V0RWxlbWVudEJ5SWQoaWQpO1xuICAgICAgICBlbGUuZGF0YShkYXRhKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufTtcblxudmFyIHJlbmRlcmVyRGVmYXVsdHMgPSBkZWZhdWx0cyRnKHtcbiAgaGlkZUVkZ2VzT25WaWV3cG9ydDogZmFsc2UsXG4gIHRleHR1cmVPblZpZXdwb3J0OiBmYWxzZSxcbiAgbW90aW9uQmx1cjogZmFsc2UsXG4gIG1vdGlvbkJsdXJPcGFjaXR5OiAwLjA1LFxuICBwaXhlbFJhdGlvOiB1bmRlZmluZWQsXG4gIGRlc2t0b3BUYXBUaHJlc2hvbGQ6IDQsXG4gIHRvdWNoVGFwVGhyZXNob2xkOiA4LFxuICB3aGVlbFNlbnNpdGl2aXR5OiAxLFxuICBkZWJ1ZzogZmFsc2UsXG4gIHNob3dGcHM6IGZhbHNlXG59KTtcbnZhciBjb3JlZm4kNCA9IHtcbiAgcmVuZGVyVG86IGZ1bmN0aW9uIHJlbmRlclRvKGNvbnRleHQsIHpvb20sIHBhbiwgcHhSYXRpbykge1xuICAgIHZhciByID0gdGhpcy5fcHJpdmF0ZS5yZW5kZXJlcjtcbiAgICByLnJlbmRlclRvKGNvbnRleHQsIHpvb20sIHBhbiwgcHhSYXRpbyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIHJlbmRlcmVyOiBmdW5jdGlvbiByZW5kZXJlcigpIHtcbiAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5yZW5kZXJlcjtcbiAgfSxcbiAgZm9yY2VSZW5kZXI6IGZ1bmN0aW9uIGZvcmNlUmVuZGVyKCkge1xuICAgIHRoaXMubm90aWZ5KCdkcmF3Jyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIHJlc2l6ZTogZnVuY3Rpb24gcmVzaXplKCkge1xuICAgIHRoaXMuaW52YWxpZGF0ZVNpemUoKTtcbiAgICB0aGlzLmVtaXRBbmROb3RpZnkoJ3Jlc2l6ZScpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBpbml0UmVuZGVyZXI6IGZ1bmN0aW9uIGluaXRSZW5kZXJlcihvcHRpb25zKSB7XG4gICAgdmFyIGN5ID0gdGhpcztcbiAgICB2YXIgUmVuZGVyZXJQcm90byA9IGN5LmV4dGVuc2lvbigncmVuZGVyZXInLCBvcHRpb25zLm5hbWUpO1xuICAgIGlmIChSZW5kZXJlclByb3RvID09IG51bGwpIHtcbiAgICAgIGVycm9yKFwiQ2FuIG5vdCBpbml0aWFsaXNlOiBObyBzdWNoIHJlbmRlcmVyIGBcIi5jb25jYXQob3B0aW9ucy5uYW1lLCBcImAgZm91bmQuIERpZCB5b3UgZm9yZ2V0IHRvIGltcG9ydCBpdCBhbmQgYGN5dG9zY2FwZS51c2UoKWAgaXQ/XCIpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMud2hlZWxTZW5zaXRpdml0eSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB3YXJuKFwiWW91IGhhdmUgc2V0IGEgY3VzdG9tIHdoZWVsIHNlbnNpdGl2aXR5LiAgVGhpcyB3aWxsIG1ha2UgeW91ciBhcHAgem9vbSB1bm5hdHVyYWxseSB3aGVuIHVzaW5nIG1haW5zdHJlYW0gbWljZS4gIFlvdSBzaG91bGQgY2hhbmdlIHRoaXMgdmFsdWUgZnJvbSB0aGUgZGVmYXVsdCBvbmx5IGlmIHlvdSBjYW4gZ3VhcmFudGVlIHRoYXQgYWxsIHlvdXIgdXNlcnMgd2lsbCB1c2UgdGhlIHNhbWUgaGFyZHdhcmUgYW5kIE9TIGNvbmZpZ3VyYXRpb24gYXMgeW91ciBjdXJyZW50IG1hY2hpbmUuXCIpO1xuICAgIH1cbiAgICB2YXIgck9wdHMgPSByZW5kZXJlckRlZmF1bHRzKG9wdGlvbnMpO1xuICAgIHJPcHRzLmN5ID0gY3k7XG4gICAgY3kuX3ByaXZhdGUucmVuZGVyZXIgPSBuZXcgUmVuZGVyZXJQcm90byhyT3B0cyk7XG4gICAgdGhpcy5ub3RpZnkoJ2luaXQnKTtcbiAgfSxcbiAgZGVzdHJveVJlbmRlcmVyOiBmdW5jdGlvbiBkZXN0cm95UmVuZGVyZXIoKSB7XG4gICAgdmFyIGN5ID0gdGhpcztcbiAgICBjeS5ub3RpZnkoJ2Rlc3Ryb3knKTsgLy8gZGVzdHJveSB0aGUgcmVuZGVyZXJcblxuICAgIHZhciBkb21FbGUgPSBjeS5jb250YWluZXIoKTtcbiAgICBpZiAoZG9tRWxlKSB7XG4gICAgICBkb21FbGUuX2N5cmVnID0gbnVsbDtcbiAgICAgIHdoaWxlIChkb21FbGUuY2hpbGROb2Rlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGRvbUVsZS5yZW1vdmVDaGlsZChkb21FbGUuY2hpbGROb2Rlc1swXSk7XG4gICAgICB9XG4gICAgfVxuICAgIGN5Ll9wcml2YXRlLnJlbmRlcmVyID0gbnVsbDsgLy8gdG8gYmUgZXh0cmEgc2FmZSwgcmVtb3ZlIHRoZSByZWZcbiAgICBjeS5tdXRhYmxlRWxlbWVudHMoKS5mb3JFYWNoKGZ1bmN0aW9uIChlbGUpIHtcbiAgICAgIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgICAgIF9wLnJzY3JhdGNoID0ge307XG4gICAgICBfcC5yc3R5bGUgPSB7fTtcbiAgICAgIF9wLmFuaW1hdGlvbi5jdXJyZW50ID0gW107XG4gICAgICBfcC5hbmltYXRpb24ucXVldWUgPSBbXTtcbiAgICB9KTtcbiAgfSxcbiAgb25SZW5kZXI6IGZ1bmN0aW9uIG9uUmVuZGVyKGZuKSB7XG4gICAgcmV0dXJuIHRoaXMub24oJ3JlbmRlcicsIGZuKTtcbiAgfSxcbiAgb2ZmUmVuZGVyOiBmdW5jdGlvbiBvZmZSZW5kZXIoZm4pIHtcbiAgICByZXR1cm4gdGhpcy5vZmYoJ3JlbmRlcicsIGZuKTtcbiAgfVxufTtcbmNvcmVmbiQ0LmludmFsaWRhdGVEaW1lbnNpb25zID0gY29yZWZuJDQucmVzaXplO1xuXG52YXIgY29yZWZuJDMgPSB7XG4gIC8vIGdldCBhIGNvbGxlY3Rpb25cbiAgLy8gLSBlbXB0eSBjb2xsZWN0aW9uIG9uIG5vIGFyZ3NcbiAgLy8gLSBjb2xsZWN0aW9uIG9mIGVsZW1lbnRzIGluIHRoZSBncmFwaCBvbiBzZWxlY3RvciBhcmdcbiAgLy8gLSBndWFyYW50ZWUgYSByZXR1cm5lZCBjb2xsZWN0aW9uIHdoZW4gZWxlbWVudHMgb3IgY29sbGVjdGlvbiBzcGVjaWZpZWRcbiAgY29sbGVjdGlvbjogZnVuY3Rpb24gY29sbGVjdGlvbihlbGVzLCBvcHRzKSB7XG4gICAgaWYgKHN0cmluZyhlbGVzKSkge1xuICAgICAgcmV0dXJuIHRoaXMuJChlbGVzKTtcbiAgICB9IGVsc2UgaWYgKGVsZW1lbnRPckNvbGxlY3Rpb24oZWxlcykpIHtcbiAgICAgIHJldHVybiBlbGVzLmNvbGxlY3Rpb24oKTtcbiAgICB9IGVsc2UgaWYgKGFycmF5KGVsZXMpKSB7XG4gICAgICBpZiAoIW9wdHMpIHtcbiAgICAgICAgb3B0cyA9IHt9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBDb2xsZWN0aW9uKHRoaXMsIGVsZXMsIG9wdHMudW5pcXVlLCBvcHRzLnJlbW92ZWQpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IENvbGxlY3Rpb24odGhpcyk7XG4gIH0sXG4gIG5vZGVzOiBmdW5jdGlvbiBub2RlcyhzZWxlY3Rvcikge1xuICAgIHZhciBub2RlcyA9IHRoaXMuJChmdW5jdGlvbiAoZWxlKSB7XG4gICAgICByZXR1cm4gZWxlLmlzTm9kZSgpO1xuICAgIH0pO1xuICAgIGlmIChzZWxlY3Rvcikge1xuICAgICAgcmV0dXJuIG5vZGVzLmZpbHRlcihzZWxlY3Rvcik7XG4gICAgfVxuICAgIHJldHVybiBub2RlcztcbiAgfSxcbiAgZWRnZXM6IGZ1bmN0aW9uIGVkZ2VzKHNlbGVjdG9yKSB7XG4gICAgdmFyIGVkZ2VzID0gdGhpcy4kKGZ1bmN0aW9uIChlbGUpIHtcbiAgICAgIHJldHVybiBlbGUuaXNFZGdlKCk7XG4gICAgfSk7XG4gICAgaWYgKHNlbGVjdG9yKSB7XG4gICAgICByZXR1cm4gZWRnZXMuZmlsdGVyKHNlbGVjdG9yKTtcbiAgICB9XG4gICAgcmV0dXJuIGVkZ2VzO1xuICB9LFxuICAvLyBzZWFyY2ggdGhlIGdyYXBoIGxpa2UgalF1ZXJ5XG4gICQ6IGZ1bmN0aW9uICQoc2VsZWN0b3IpIHtcbiAgICB2YXIgZWxlcyA9IHRoaXMuX3ByaXZhdGUuZWxlbWVudHM7XG4gICAgaWYgKHNlbGVjdG9yKSB7XG4gICAgICByZXR1cm4gZWxlcy5maWx0ZXIoc2VsZWN0b3IpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZWxlcy5zcGF3blNlbGYoKTtcbiAgICB9XG4gIH0sXG4gIG11dGFibGVFbGVtZW50czogZnVuY3Rpb24gbXV0YWJsZUVsZW1lbnRzKCkge1xuICAgIHJldHVybiB0aGlzLl9wcml2YXRlLmVsZW1lbnRzO1xuICB9XG59O1xuXG4vLyBhbGlhc2VzXG5jb3JlZm4kMy5lbGVtZW50cyA9IGNvcmVmbiQzLmZpbHRlciA9IGNvcmVmbiQzLiQ7XG5cbnZhciBzdHlmbiQ4ID0ge307XG5cbi8vIGtleXMgZm9yIHN0eWxlIGJsb2NrcywgZS5nLiB0dGZmdHRcbnZhciBUUlVFID0gJ3QnO1xudmFyIEZBTFNFID0gJ2YnO1xuXG4vLyAocG90ZW50aWFsbHkgZXhwZW5zaXZlIGNhbGN1bGF0aW9uKVxuLy8gYXBwbHkgdGhlIHN0eWxlIHRvIHRoZSBlbGVtZW50IGJhc2VkIG9uXG4vLyAtIGl0cyBieXBhc3Ncbi8vIC0gd2hhdCBzZWxlY3RvcnMgbWF0Y2ggaXRcbnN0eWZuJDguYXBwbHkgPSBmdW5jdGlvbiAoZWxlcykge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBfcCA9IHNlbGYuX3ByaXZhdGU7XG4gIHZhciBjeSA9IF9wLmN5O1xuICB2YXIgdXBkYXRlZEVsZXMgPSBjeS5jb2xsZWN0aW9uKCk7XG4gIGZvciAodmFyIGllID0gMDsgaWUgPCBlbGVzLmxlbmd0aDsgaWUrKykge1xuICAgIHZhciBlbGUgPSBlbGVzW2llXTtcbiAgICB2YXIgY3h0TWV0YSA9IHNlbGYuZ2V0Q29udGV4dE1ldGEoZWxlKTtcbiAgICBpZiAoY3h0TWV0YS5lbXB0eSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHZhciBjeHRTdHlsZSA9IHNlbGYuZ2V0Q29udGV4dFN0eWxlKGN4dE1ldGEpO1xuICAgIHZhciBhcHAgPSBzZWxmLmFwcGx5Q29udGV4dFN0eWxlKGN4dE1ldGEsIGN4dFN0eWxlLCBlbGUpO1xuICAgIGlmIChlbGUuX3ByaXZhdGUuYXBwbGllZEluaXRTdHlsZSkge1xuICAgICAgc2VsZi51cGRhdGVUcmFuc2l0aW9ucyhlbGUsIGFwcC5kaWZmUHJvcHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbGUuX3ByaXZhdGUuYXBwbGllZEluaXRTdHlsZSA9IHRydWU7XG4gICAgfVxuICAgIHZhciBoaW50c0RpZmYgPSBzZWxmLnVwZGF0ZVN0eWxlSGludHMoZWxlKTtcbiAgICBpZiAoaGludHNEaWZmKSB7XG4gICAgICB1cGRhdGVkRWxlcy5wdXNoKGVsZSk7XG4gICAgfVxuICB9IC8vIGZvciBlbGVtZW50c1xuXG4gIHJldHVybiB1cGRhdGVkRWxlcztcbn07XG5zdHlmbiQ4LmdldFByb3BlcnRpZXNEaWZmID0gZnVuY3Rpb24gKG9sZEN4dEtleSwgbmV3Q3h0S2V5KSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIGNhY2hlID0gc2VsZi5fcHJpdmF0ZS5wcm9wRGlmZnMgPSBzZWxmLl9wcml2YXRlLnByb3BEaWZmcyB8fCB7fTtcbiAgdmFyIGR1YWxDeHRLZXkgPSBvbGRDeHRLZXkgKyAnLScgKyBuZXdDeHRLZXk7XG4gIHZhciBjYWNoZWRWYWwgPSBjYWNoZVtkdWFsQ3h0S2V5XTtcbiAgaWYgKGNhY2hlZFZhbCkge1xuICAgIHJldHVybiBjYWNoZWRWYWw7XG4gIH1cbiAgdmFyIGRpZmZQcm9wcyA9IFtdO1xuICB2YXIgYWRkZWRQcm9wID0ge307XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc2VsZi5sZW5ndGg7IGkrKykge1xuICAgIHZhciBjeHQgPSBzZWxmW2ldO1xuICAgIHZhciBvbGRIYXNDeHQgPSBvbGRDeHRLZXlbaV0gPT09IFRSVUU7XG4gICAgdmFyIG5ld0hhc0N4dCA9IG5ld0N4dEtleVtpXSA9PT0gVFJVRTtcbiAgICB2YXIgY3h0SGFzRGlmZmVkID0gb2xkSGFzQ3h0ICE9PSBuZXdIYXNDeHQ7XG4gICAgdmFyIGN4dEhhc01hcHBlZFByb3BzID0gY3h0Lm1hcHBlZFByb3BlcnRpZXMubGVuZ3RoID4gMDtcbiAgICBpZiAoY3h0SGFzRGlmZmVkIHx8IG5ld0hhc0N4dCAmJiBjeHRIYXNNYXBwZWRQcm9wcykge1xuICAgICAgdmFyIHByb3BzID0gdm9pZCAwO1xuICAgICAgaWYgKGN4dEhhc0RpZmZlZCAmJiBjeHRIYXNNYXBwZWRQcm9wcykge1xuICAgICAgICBwcm9wcyA9IGN4dC5wcm9wZXJ0aWVzOyAvLyBzdWZmaWNlcyBiL2MgbWFwcGVkUHJvcGVydGllcyBpcyBhIHN1YnNldCBvZiBwcm9wZXJ0aWVzXG4gICAgICB9IGVsc2UgaWYgKGN4dEhhc0RpZmZlZCkge1xuICAgICAgICBwcm9wcyA9IGN4dC5wcm9wZXJ0aWVzOyAvLyBuZWVkIHRvIGNoZWNrIHRoZW0gYWxsXG4gICAgICB9IGVsc2UgaWYgKGN4dEhhc01hcHBlZFByb3BzKSB7XG4gICAgICAgIHByb3BzID0gY3h0Lm1hcHBlZFByb3BlcnRpZXM7IC8vIG9ubHkgbmVlZCB0byBjaGVjayBtYXBwZWRcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBwcm9wcy5sZW5ndGg7IGorKykge1xuICAgICAgICB2YXIgcHJvcCA9IHByb3BzW2pdO1xuICAgICAgICB2YXIgbmFtZSA9IHByb3AubmFtZTtcblxuICAgICAgICAvLyBpZiBhIGxhdGVyIGNvbnRleHQgb3ZlcnJpZGVzIHRoaXMgcHJvcGVydHksIHRoZW4gdGhlIGZhY3QgdGhhdCB0aGlzIGNvbnRleHQgaGFzIHN3aXRjaGVkL2RpZmZlZCBkb2Vzbid0IG1hdHRlclxuICAgICAgICAvLyAoc2VtaSBleHBlbnNpdmUgY2hlY2sgc2luY2UgaXQgbWFrZXMgdGhpcyBmdW5jdGlvbiBPKG5eMikgb24gY29udGV4dCBsZW5ndGgsIGJ1dCB3b3J0aCBpdCBzaW5jZSBvdmVyYWxsIHJlc3VsdFxuICAgICAgICAvLyBpcyBjYWNoZWQpXG4gICAgICAgIHZhciBsYXRlckN4dE92ZXJyaWRlcyA9IGZhbHNlO1xuICAgICAgICBmb3IgKHZhciBrID0gaSArIDE7IGsgPCBzZWxmLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgdmFyIGxhdGVyQ3h0ID0gc2VsZltrXTtcbiAgICAgICAgICB2YXIgaGFzTGF0ZXJDeHQgPSBuZXdDeHRLZXlba10gPT09IFRSVUU7XG4gICAgICAgICAgaWYgKCFoYXNMYXRlckN4dCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfSAvLyBjYW4ndCBvdmVycmlkZSB1bmxlc3MgdGhlIGNvbnRleHQgaXMgYWN0aXZlXG5cbiAgICAgICAgICBsYXRlckN4dE92ZXJyaWRlcyA9IGxhdGVyQ3h0LnByb3BlcnRpZXNbcHJvcC5uYW1lXSAhPSBudWxsO1xuICAgICAgICAgIGlmIChsYXRlckN4dE92ZXJyaWRlcykge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfSAvLyBleGl0IGVhcmx5IGFzIGxvbmcgYXMgb25lIGxhdGVyIGNvbnRleHQgb3ZlcnJpZGVzXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWFkZGVkUHJvcFtuYW1lXSAmJiAhbGF0ZXJDeHRPdmVycmlkZXMpIHtcbiAgICAgICAgICBhZGRlZFByb3BbbmFtZV0gPSB0cnVlO1xuICAgICAgICAgIGRpZmZQcm9wcy5wdXNoKG5hbWUpO1xuICAgICAgICB9XG4gICAgICB9IC8vIGZvciBwcm9wc1xuICAgIH0gLy8gaWZcbiAgfSAvLyBmb3IgY29udGV4dHNcblxuICBjYWNoZVtkdWFsQ3h0S2V5XSA9IGRpZmZQcm9wcztcbiAgcmV0dXJuIGRpZmZQcm9wcztcbn07XG5zdHlmbiQ4LmdldENvbnRleHRNZXRhID0gZnVuY3Rpb24gKGVsZSkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBjeHRLZXkgPSAnJztcbiAgdmFyIGRpZmZQcm9wcztcbiAgdmFyIHByZXZLZXkgPSBlbGUuX3ByaXZhdGUuc3R5bGVDeHRLZXkgfHwgJyc7XG5cbiAgLy8gZ2V0IHRoZSBjeHQga2V5XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc2VsZi5sZW5ndGg7IGkrKykge1xuICAgIHZhciBjb250ZXh0ID0gc2VsZltpXTtcbiAgICB2YXIgY29udGV4dFNlbGVjdG9yTWF0Y2hlcyA9IGNvbnRleHQuc2VsZWN0b3IgJiYgY29udGV4dC5zZWxlY3Rvci5tYXRjaGVzKGVsZSk7IC8vIE5COiBjb250ZXh0LnNlbGVjdG9yIG1heSBiZSBudWxsIGZvciAnY29yZSdcblxuICAgIGlmIChjb250ZXh0U2VsZWN0b3JNYXRjaGVzKSB7XG4gICAgICBjeHRLZXkgKz0gVFJVRTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3h0S2V5ICs9IEZBTFNFO1xuICAgIH1cbiAgfSAvLyBmb3IgY29udGV4dFxuXG4gIGRpZmZQcm9wcyA9IHNlbGYuZ2V0UHJvcGVydGllc0RpZmYocHJldktleSwgY3h0S2V5KTtcbiAgZWxlLl9wcml2YXRlLnN0eWxlQ3h0S2V5ID0gY3h0S2V5O1xuICByZXR1cm4ge1xuICAgIGtleTogY3h0S2V5LFxuICAgIGRpZmZQcm9wTmFtZXM6IGRpZmZQcm9wcyxcbiAgICBlbXB0eTogZGlmZlByb3BzLmxlbmd0aCA9PT0gMFxuICB9O1xufTtcblxuLy8gZ2V0cyBhIGNvbXB1dGVkIGVsZSBzdHlsZSBvYmplY3QgYmFzZWQgb24gbWF0Y2hlZCBjb250ZXh0c1xuc3R5Zm4kOC5nZXRDb250ZXh0U3R5bGUgPSBmdW5jdGlvbiAoY3h0TWV0YSkge1xuICB2YXIgY3h0S2V5ID0gY3h0TWV0YS5rZXk7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIGN4dFN0eWxlcyA9IHRoaXMuX3ByaXZhdGUuY29udGV4dFN0eWxlcyA9IHRoaXMuX3ByaXZhdGUuY29udGV4dFN0eWxlcyB8fCB7fTtcblxuICAvLyBpZiBhbHJlYWR5IGNvbXB1dGVkIHN0eWxlLCByZXR1cm5lZCBjYWNoZWQgY29weVxuICBpZiAoY3h0U3R5bGVzW2N4dEtleV0pIHtcbiAgICByZXR1cm4gY3h0U3R5bGVzW2N4dEtleV07XG4gIH1cbiAgdmFyIHN0eWxlID0ge1xuICAgIF9wcml2YXRlOiB7XG4gICAgICBrZXk6IGN4dEtleVxuICAgIH1cbiAgfTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWxmLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGN4dCA9IHNlbGZbaV07XG4gICAgdmFyIGhhc0N4dCA9IGN4dEtleVtpXSA9PT0gVFJVRTtcbiAgICBpZiAoIWhhc0N4dCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgY3h0LnByb3BlcnRpZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgIHZhciBwcm9wID0gY3h0LnByb3BlcnRpZXNbal07XG4gICAgICBzdHlsZVtwcm9wLm5hbWVdID0gcHJvcDtcbiAgICB9XG4gIH1cbiAgY3h0U3R5bGVzW2N4dEtleV0gPSBzdHlsZTtcbiAgcmV0dXJuIHN0eWxlO1xufTtcbnN0eWZuJDguYXBwbHlDb250ZXh0U3R5bGUgPSBmdW5jdGlvbiAoY3h0TWV0YSwgY3h0U3R5bGUsIGVsZSkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBkaWZmUHJvcHMgPSBjeHRNZXRhLmRpZmZQcm9wTmFtZXM7XG4gIHZhciByZXREaWZmUHJvcHMgPSB7fTtcbiAgdmFyIHR5cGVzID0gc2VsZi50eXBlcztcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaWZmUHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZGlmZlByb3BOYW1lID0gZGlmZlByb3BzW2ldO1xuICAgIHZhciBjeHRQcm9wID0gY3h0U3R5bGVbZGlmZlByb3BOYW1lXTtcbiAgICB2YXIgZWxlUHJvcCA9IGVsZS5wc3R5bGUoZGlmZlByb3BOYW1lKTtcbiAgICBpZiAoIWN4dFByb3ApIHtcbiAgICAgIC8vIG5vIGNvbnRleHQgcHJvcCBtZWFucyBkZWxldGVcbiAgICAgIGlmICghZWxlUHJvcCkge1xuICAgICAgICBjb250aW51ZTsgLy8gbm8gZXhpc3RpbmcgcHJvcCBtZWFucyBub3RoaW5nIG5lZWRzIHRvIGJlIHJlbW92ZWRcbiAgICAgICAgLy8gbmIgYWZmZWN0cyBpbml0aWFsIGFwcGxpY2F0aW9uIG9uIG1hcHBlZCB2YWx1ZXMgbGlrZSBjb250cm9sLXBvaW50LWRpc3RhbmNlc1xuICAgICAgfSBlbHNlIGlmIChlbGVQcm9wLmJ5cGFzcykge1xuICAgICAgICBjeHRQcm9wID0ge1xuICAgICAgICAgIG5hbWU6IGRpZmZQcm9wTmFtZSxcbiAgICAgICAgICBkZWxldGVCeXBhc3NlZDogdHJ1ZVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3h0UHJvcCA9IHtcbiAgICAgICAgICBuYW1lOiBkaWZmUHJvcE5hbWUsXG4gICAgICAgICAgXCJkZWxldGVcIjogdHJ1ZVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHNhdmUgY3ljbGVzIHdoZW4gdGhlIGNvbnRleHQgcHJvcCBkb2Vzbid0IG5lZWQgdG8gYmUgYXBwbGllZFxuICAgIGlmIChlbGVQcm9wID09PSBjeHRQcm9wKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBzYXZlIGN5Y2xlcyB3aGVuIGEgbWFwcGVkIGNvbnRleHQgcHJvcCBkb2Vzbid0IG5lZWQgdG8gYmUgYXBwbGllZFxuICAgIGlmIChjeHRQcm9wLm1hcHBlZCA9PT0gdHlwZXMuZm4gLy8gY29udGV4dCBwcm9wIGlzIGZ1bmN0aW9uIG1hcHBlclxuICAgICYmIGVsZVByb3AgIT0gbnVsbCAvLyBzb21lIHByb3BzIGNhbiBiZSBudWxsIGV2ZW4gYnkgZGVmYXVsdCAoZS5nLiBhIHByb3AgdGhhdCBvdmVycmlkZXMgYW5vdGhlciBvbmUpXG4gICAgJiYgZWxlUHJvcC5tYXBwaW5nICE9IG51bGwgLy8gZWxlIHByb3AgaXMgYSBjb25jcmV0ZSB2YWx1ZSBmcm9tIGZyb20gYSBtYXBwZXJcbiAgICAmJiBlbGVQcm9wLm1hcHBpbmcudmFsdWUgPT09IGN4dFByb3AudmFsdWUgLy8gdGhlIGN1cnJlbnQgcHJvcCBvbiB0aGUgZWxlIGlzIGEgZmxhdCBwcm9wIHZhbHVlIGZvciB0aGUgZnVuY3Rpb24gbWFwcGVyXG4gICAgKSB7XG4gICAgICAvLyBOQiBkb24ndCB3cml0ZSB0byBjeHRQcm9wLCBhcyBpdCdzIHNoYXJlZCBhbW9uZyBlbGVzIChzdG9yZWQgaW4gc3R5bGVzaGVldClcbiAgICAgIHZhciBtYXBwaW5nID0gZWxlUHJvcC5tYXBwaW5nOyAvLyBjYW4gd3JpdGUgdG8gbWFwcGluZywgYXMgaXQncyBhIHBlci1lbGUgY29weVxuICAgICAgdmFyIGZuVmFsdWUgPSBtYXBwaW5nLmZuVmFsdWUgPSBjeHRQcm9wLnZhbHVlKGVsZSk7IC8vIHRlbXBvcmFyaWx5IGNhY2hlIHRoZSB2YWx1ZSBpbiBjYXNlIG9mIGEgbWlzc1xuXG4gICAgICBpZiAoZm5WYWx1ZSA9PT0gbWFwcGluZy5wcmV2Rm5WYWx1ZSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIHJldERpZmZQcm9wID0gcmV0RGlmZlByb3BzW2RpZmZQcm9wTmFtZV0gPSB7XG4gICAgICBwcmV2OiBlbGVQcm9wXG4gICAgfTtcbiAgICBzZWxmLmFwcGx5UGFyc2VkUHJvcGVydHkoZWxlLCBjeHRQcm9wKTtcbiAgICByZXREaWZmUHJvcC5uZXh0ID0gZWxlLnBzdHlsZShkaWZmUHJvcE5hbWUpO1xuICAgIGlmIChyZXREaWZmUHJvcC5uZXh0ICYmIHJldERpZmZQcm9wLm5leHQuYnlwYXNzKSB7XG4gICAgICByZXREaWZmUHJvcC5uZXh0ID0gcmV0RGlmZlByb3AubmV4dC5ieXBhc3NlZDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBkaWZmUHJvcHM6IHJldERpZmZQcm9wc1xuICB9O1xufTtcbnN0eWZuJDgudXBkYXRlU3R5bGVIaW50cyA9IGZ1bmN0aW9uIChlbGUpIHtcbiAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBwcm9wTmFtZXMgPSBzZWxmLnByb3BlcnR5R3JvdXBOYW1lcztcbiAgdmFyIHByb3BHcktleXMgPSBzZWxmLnByb3BlcnR5R3JvdXBLZXlzO1xuICB2YXIgcHJvcEhhc2ggPSBmdW5jdGlvbiBwcm9wSGFzaChlbGUsIHByb3BOYW1lcywgc2VlZEtleSkge1xuICAgIHJldHVybiBzZWxmLmdldFByb3BlcnRpZXNIYXNoKGVsZSwgcHJvcE5hbWVzLCBzZWVkS2V5KTtcbiAgfTtcbiAgdmFyIG9sZFN0eWxlS2V5ID0gX3Auc3R5bGVLZXk7XG4gIGlmIChlbGUucmVtb3ZlZCgpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBpc05vZGUgPSBfcC5ncm91cCA9PT0gJ25vZGVzJztcblxuICAvLyBnZXQgdGhlIHN0eWxlIGtleSBoYXNoZXMgcGVyIHByb3AgZ3JvdXBcbiAgLy8gYnV0IGxhemlseSAtLSBvbmx5IHVzZSBub24tZGVmYXVsdCBwcm9wIHZhbHVlcyB0byByZWR1Y2UgdGhlIG51bWJlciBvZiBoYXNoZXNcbiAgLy9cblxuICB2YXIgb3ZlcnJpZGRlblN0eWxlcyA9IGVsZS5fcHJpdmF0ZS5zdHlsZTtcbiAgcHJvcE5hbWVzID0gT2JqZWN0LmtleXMob3ZlcnJpZGRlblN0eWxlcyk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcEdyS2V5cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBncktleSA9IHByb3BHcktleXNbaV07XG4gICAgX3Auc3R5bGVLZXlzW2dyS2V5XSA9IFtERUZBVUxUX0hBU0hfU0VFRCwgREVGQVVMVF9IQVNIX1NFRURfQUxUXTtcbiAgfVxuICB2YXIgdXBkYXRlR3JLZXkxID0gZnVuY3Rpb24gdXBkYXRlR3JLZXkxKHZhbCwgZ3JLZXkpIHtcbiAgICByZXR1cm4gX3Auc3R5bGVLZXlzW2dyS2V5XVswXSA9IGhhc2hJbnQodmFsLCBfcC5zdHlsZUtleXNbZ3JLZXldWzBdKTtcbiAgfTtcbiAgdmFyIHVwZGF0ZUdyS2V5MiA9IGZ1bmN0aW9uIHVwZGF0ZUdyS2V5Mih2YWwsIGdyS2V5KSB7XG4gICAgcmV0dXJuIF9wLnN0eWxlS2V5c1tncktleV1bMV0gPSBoYXNoSW50QWx0KHZhbCwgX3Auc3R5bGVLZXlzW2dyS2V5XVsxXSk7XG4gIH07XG4gIHZhciB1cGRhdGVHcktleSA9IGZ1bmN0aW9uIHVwZGF0ZUdyS2V5KHZhbCwgZ3JLZXkpIHtcbiAgICB1cGRhdGVHcktleTEodmFsLCBncktleSk7XG4gICAgdXBkYXRlR3JLZXkyKHZhbCwgZ3JLZXkpO1xuICB9O1xuICB2YXIgdXBkYXRlR3JLZXlXU3RyID0gZnVuY3Rpb24gdXBkYXRlR3JLZXlXU3RyKHN0clZhbCwgZ3JLZXkpIHtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IHN0clZhbC5sZW5ndGg7IGorKykge1xuICAgICAgdmFyIGNoID0gc3RyVmFsLmNoYXJDb2RlQXQoaik7XG4gICAgICB1cGRhdGVHcktleTEoY2gsIGdyS2V5KTtcbiAgICAgIHVwZGF0ZUdyS2V5MihjaCwgZ3JLZXkpO1xuICAgIH1cbiAgfTtcblxuICAvLyAtIGhhc2hpbmcgd29ya3Mgb24gMzIgYml0IGludHMgYi9jIHdlIHVzZSBiaXR3aXNlIG9wc1xuICAvLyAtIHNtYWxsIG51bWJlcnMgZ2V0IGN1dCBvZmYgKGUuZy4gMC4xMjMgaXMgc2VlbiBhcyAwIGJ5IHRoZSBoYXNoaW5nIGZ1bmN0aW9uKVxuICAvLyAtIHJhaXNlIHVwIHNtYWxsIG51bWJlcnMgc28gbW9yZSBzaWduaWZpY2FudCBkaWdpdHMgYXJlIHNlZW4gYnkgaGFzaGluZ1xuICAvLyAtIG1ha2Ugc21hbGwgbnVtYmVycyBsYXJnZXIgdGhhbiBhIG5vcm1hbCB2YWx1ZSB0byBhdm9pZCBjb2xsaXNpb25zXG4gIC8vIC0gd29ya3MgaW4gcHJhY3RpY2UgYW5kIGl0J3MgcmVsYXRpdmVseSBjaGVhcFxuICB2YXIgTiA9IDIwMDAwMDAwMDA7XG4gIHZhciBjbGVhbk51bSA9IGZ1bmN0aW9uIGNsZWFuTnVtKHZhbCkge1xuICAgIHJldHVybiAtMTI4IDwgdmFsICYmIHZhbCA8IDEyOCAmJiBNYXRoLmZsb29yKHZhbCkgIT09IHZhbCA/IE4gLSAodmFsICogMTAyNCB8IDApIDogdmFsO1xuICB9O1xuICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgcHJvcE5hbWVzLmxlbmd0aDsgX2krKykge1xuICAgIHZhciBuYW1lID0gcHJvcE5hbWVzW19pXTtcbiAgICB2YXIgcGFyc2VkUHJvcCA9IG92ZXJyaWRkZW5TdHlsZXNbbmFtZV07XG4gICAgaWYgKHBhcnNlZFByb3AgPT0gbnVsbCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHZhciBwcm9wSW5mbyA9IHRoaXMucHJvcGVydGllc1tuYW1lXTtcbiAgICB2YXIgdHlwZSA9IHByb3BJbmZvLnR5cGU7XG4gICAgdmFyIF9ncktleSA9IHByb3BJbmZvLmdyb3VwS2V5O1xuICAgIHZhciBub3JtYWxpemVkTnVtYmVyVmFsID0gdm9pZCAwO1xuICAgIGlmIChwcm9wSW5mby5oYXNoT3ZlcnJpZGUgIT0gbnVsbCkge1xuICAgICAgbm9ybWFsaXplZE51bWJlclZhbCA9IHByb3BJbmZvLmhhc2hPdmVycmlkZShlbGUsIHBhcnNlZFByb3ApO1xuICAgIH0gZWxzZSBpZiAocGFyc2VkUHJvcC5wZlZhbHVlICE9IG51bGwpIHtcbiAgICAgIG5vcm1hbGl6ZWROdW1iZXJWYWwgPSBwYXJzZWRQcm9wLnBmVmFsdWU7XG4gICAgfVxuXG4gICAgLy8gbWlnaHQgbm90IGJlIGEgbnVtYmVyIGlmIGl0IGFsbG93cyBlbnVtc1xuICAgIHZhciBudW1iZXJWYWwgPSBwcm9wSW5mby5lbnVtcyA9PSBudWxsID8gcGFyc2VkUHJvcC52YWx1ZSA6IG51bGw7XG4gICAgdmFyIGhhdmVOb3JtTnVtID0gbm9ybWFsaXplZE51bWJlclZhbCAhPSBudWxsO1xuICAgIHZhciBoYXZlVW5pdGVkTnVtID0gbnVtYmVyVmFsICE9IG51bGw7XG4gICAgdmFyIGhhdmVOdW0gPSBoYXZlTm9ybU51bSB8fCBoYXZlVW5pdGVkTnVtO1xuICAgIHZhciB1bml0cyA9IHBhcnNlZFByb3AudW5pdHM7XG5cbiAgICAvLyBudW1iZXJzIGFyZSBjaGVhcGVyIHRvIGhhc2ggdGhhbiBzdHJpbmdzXG4gICAgLy8gMSBoYXNoIG9wIHZzIG4gaGFzaCBvcHMgKGZvciBsZW5ndGggbiBzdHJpbmcpXG4gICAgaWYgKHR5cGUubnVtYmVyICYmIGhhdmVOdW0gJiYgIXR5cGUubXVsdGlwbGUpIHtcbiAgICAgIHZhciB2ID0gaGF2ZU5vcm1OdW0gPyBub3JtYWxpemVkTnVtYmVyVmFsIDogbnVtYmVyVmFsO1xuICAgICAgdXBkYXRlR3JLZXkoY2xlYW5OdW0odiksIF9ncktleSk7XG4gICAgICBpZiAoIWhhdmVOb3JtTnVtICYmIHVuaXRzICE9IG51bGwpIHtcbiAgICAgICAgdXBkYXRlR3JLZXlXU3RyKHVuaXRzLCBfZ3JLZXkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB1cGRhdGVHcktleVdTdHIocGFyc2VkUHJvcC5zdHJWYWx1ZSwgX2dyS2V5KTtcbiAgICB9XG4gIH1cblxuICAvLyBvdmVyYWxsIHN0eWxlIGtleVxuICAvL1xuXG4gIHZhciBoYXNoID0gW0RFRkFVTFRfSEFTSF9TRUVELCBERUZBVUxUX0hBU0hfU0VFRF9BTFRdO1xuICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBwcm9wR3JLZXlzLmxlbmd0aDsgX2kyKyspIHtcbiAgICB2YXIgX2dyS2V5MiA9IHByb3BHcktleXNbX2kyXTtcbiAgICB2YXIgZ3JIYXNoID0gX3Auc3R5bGVLZXlzW19ncktleTJdO1xuICAgIGhhc2hbMF0gPSBoYXNoSW50KGdySGFzaFswXSwgaGFzaFswXSk7XG4gICAgaGFzaFsxXSA9IGhhc2hJbnRBbHQoZ3JIYXNoWzFdLCBoYXNoWzFdKTtcbiAgfVxuICBfcC5zdHlsZUtleSA9IGNvbWJpbmVIYXNoZXMoaGFzaFswXSwgaGFzaFsxXSk7XG5cbiAgLy8gbGFiZWwgZGltc1xuICAvL1xuXG4gIHZhciBzayA9IF9wLnN0eWxlS2V5cztcbiAgX3AubGFiZWxEaW1zS2V5ID0gY29tYmluZUhhc2hlc0FycmF5KHNrLmxhYmVsRGltZW5zaW9ucyk7XG4gIHZhciBsYWJlbEtleXMgPSBwcm9wSGFzaChlbGUsIFsnbGFiZWwnXSwgc2subGFiZWxEaW1lbnNpb25zKTtcbiAgX3AubGFiZWxLZXkgPSBjb21iaW5lSGFzaGVzQXJyYXkobGFiZWxLZXlzKTtcbiAgX3AubGFiZWxTdHlsZUtleSA9IGNvbWJpbmVIYXNoZXNBcnJheShoYXNoQXJyYXlzKHNrLmNvbW1vbkxhYmVsLCBsYWJlbEtleXMpKTtcbiAgaWYgKCFpc05vZGUpIHtcbiAgICB2YXIgc291cmNlTGFiZWxLZXlzID0gcHJvcEhhc2goZWxlLCBbJ3NvdXJjZS1sYWJlbCddLCBzay5sYWJlbERpbWVuc2lvbnMpO1xuICAgIF9wLnNvdXJjZUxhYmVsS2V5ID0gY29tYmluZUhhc2hlc0FycmF5KHNvdXJjZUxhYmVsS2V5cyk7XG4gICAgX3Auc291cmNlTGFiZWxTdHlsZUtleSA9IGNvbWJpbmVIYXNoZXNBcnJheShoYXNoQXJyYXlzKHNrLmNvbW1vbkxhYmVsLCBzb3VyY2VMYWJlbEtleXMpKTtcbiAgICB2YXIgdGFyZ2V0TGFiZWxLZXlzID0gcHJvcEhhc2goZWxlLCBbJ3RhcmdldC1sYWJlbCddLCBzay5sYWJlbERpbWVuc2lvbnMpO1xuICAgIF9wLnRhcmdldExhYmVsS2V5ID0gY29tYmluZUhhc2hlc0FycmF5KHRhcmdldExhYmVsS2V5cyk7XG4gICAgX3AudGFyZ2V0TGFiZWxTdHlsZUtleSA9IGNvbWJpbmVIYXNoZXNBcnJheShoYXNoQXJyYXlzKHNrLmNvbW1vbkxhYmVsLCB0YXJnZXRMYWJlbEtleXMpKTtcbiAgfVxuXG4gIC8vIG5vZGVcbiAgLy9cblxuICBpZiAoaXNOb2RlKSB7XG4gICAgdmFyIF9wJHN0eWxlS2V5cyA9IF9wLnN0eWxlS2V5cyxcbiAgICAgIG5vZGVCb2R5ID0gX3Akc3R5bGVLZXlzLm5vZGVCb2R5LFxuICAgICAgbm9kZUJvcmRlciA9IF9wJHN0eWxlS2V5cy5ub2RlQm9yZGVyLFxuICAgICAgbm9kZU91dGxpbmUgPSBfcCRzdHlsZUtleXMubm9kZU91dGxpbmUsXG4gICAgICBiYWNrZ3JvdW5kSW1hZ2UgPSBfcCRzdHlsZUtleXMuYmFja2dyb3VuZEltYWdlLFxuICAgICAgY29tcG91bmQgPSBfcCRzdHlsZUtleXMuY29tcG91bmQsXG4gICAgICBwaWUgPSBfcCRzdHlsZUtleXMucGllO1xuICAgIHZhciBub2RlS2V5cyA9IFtub2RlQm9keSwgbm9kZUJvcmRlciwgbm9kZU91dGxpbmUsIGJhY2tncm91bmRJbWFnZSwgY29tcG91bmQsIHBpZV0uZmlsdGVyKGZ1bmN0aW9uIChrKSB7XG4gICAgICByZXR1cm4gayAhPSBudWxsO1xuICAgIH0pLnJlZHVjZShoYXNoQXJyYXlzLCBbREVGQVVMVF9IQVNIX1NFRUQsIERFRkFVTFRfSEFTSF9TRUVEX0FMVF0pO1xuICAgIF9wLm5vZGVLZXkgPSBjb21iaW5lSGFzaGVzQXJyYXkobm9kZUtleXMpO1xuICAgIF9wLmhhc1BpZSA9IHBpZSAhPSBudWxsICYmIHBpZVswXSAhPT0gREVGQVVMVF9IQVNIX1NFRUQgJiYgcGllWzFdICE9PSBERUZBVUxUX0hBU0hfU0VFRF9BTFQ7XG4gIH1cbiAgcmV0dXJuIG9sZFN0eWxlS2V5ICE9PSBfcC5zdHlsZUtleTtcbn07XG5zdHlmbiQ4LmNsZWFyU3R5bGVIaW50cyA9IGZ1bmN0aW9uIChlbGUpIHtcbiAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuICBfcC5zdHlsZUN4dEtleSA9ICcnO1xuICBfcC5zdHlsZUtleXMgPSB7fTtcbiAgX3Auc3R5bGVLZXkgPSBudWxsO1xuICBfcC5sYWJlbEtleSA9IG51bGw7XG4gIF9wLmxhYmVsU3R5bGVLZXkgPSBudWxsO1xuICBfcC5zb3VyY2VMYWJlbEtleSA9IG51bGw7XG4gIF9wLnNvdXJjZUxhYmVsU3R5bGVLZXkgPSBudWxsO1xuICBfcC50YXJnZXRMYWJlbEtleSA9IG51bGw7XG4gIF9wLnRhcmdldExhYmVsU3R5bGVLZXkgPSBudWxsO1xuICBfcC5ub2RlS2V5ID0gbnVsbDtcbiAgX3AuaGFzUGllID0gbnVsbDtcbn07XG5cbi8vIGFwcGx5IGEgcHJvcGVydHkgdG8gdGhlIHN0eWxlIChmb3IgaW50ZXJuYWwgdXNlKVxuLy8gcmV0dXJucyB3aGV0aGVyIGFwcGxpY2F0aW9uIHdhcyBzdWNjZXNzZnVsXG4vL1xuLy8gbm93LCB0aGlzIGZ1bmN0aW9uIGZsYXR0ZW5zIHRoZSBwcm9wZXJ0eSwgYW5kIGhlcmUncyBob3c6XG4vL1xuLy8gZm9yIHBhcnNlZFByb3A6eyBieXBhc3M6IHRydWUsIGRlbGV0ZUJ5cGFzczogdHJ1ZSB9XG4vLyBubyBwcm9wZXJ0eSBpcyBnZW5lcmF0ZWQsIGluc3RlYWQgdGhlIGJ5cGFzcyBwcm9wZXJ0eSBpbiB0aGVcbi8vIGVsZW1lbnQncyBzdHlsZSBpcyByZXBsYWNlZCBieSB3aGF0J3MgcG9pbnRlZCB0byBieSB0aGUgYGJ5cGFzc2VkYFxuLy8gZmllbGQgaW4gdGhlIGJ5cGFzcyBwcm9wZXJ0eSAoaS5lLiByZXN0b3JpbmcgdGhlIHByb3BlcnR5IHRoZVxuLy8gYnlwYXNzIHdhcyBvdmVycmlkaW5nKVxuLy9cbi8vIGZvciBwYXJzZWRQcm9wOnsgbWFwcGVkOiB0cnV0aHkgfVxuLy8gdGhlIGdlbmVyYXRlZCBmbGF0dGVuZWRQcm9wOnsgbWFwcGluZzogcHJvcCB9XG4vL1xuLy8gZm9yIHBhcnNlZFByb3A6eyBieXBhc3M6IHRydWUgfVxuLy8gdGhlIGdlbmVyYXRlZCBmbGF0dGVuZWRQcm9wOnsgYnlwYXNzZWQ6IHBhcnNlZFByb3AgfVxuc3R5Zm4kOC5hcHBseVBhcnNlZFByb3BlcnR5ID0gZnVuY3Rpb24gKGVsZSwgcGFyc2VkUHJvcCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBwcm9wID0gcGFyc2VkUHJvcDtcbiAgdmFyIHN0eWxlID0gZWxlLl9wcml2YXRlLnN0eWxlO1xuICB2YXIgZmxhdFByb3A7XG4gIHZhciB0eXBlcyA9IHNlbGYudHlwZXM7XG4gIHZhciB0eXBlID0gc2VsZi5wcm9wZXJ0aWVzW3Byb3AubmFtZV0udHlwZTtcbiAgdmFyIHByb3BJc0J5cGFzcyA9IHByb3AuYnlwYXNzO1xuICB2YXIgb3JpZ1Byb3AgPSBzdHlsZVtwcm9wLm5hbWVdO1xuICB2YXIgb3JpZ1Byb3BJc0J5cGFzcyA9IG9yaWdQcm9wICYmIG9yaWdQcm9wLmJ5cGFzcztcbiAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuICB2YXIgZmxhdFByb3BNYXBwaW5nID0gJ21hcHBpbmcnO1xuICB2YXIgZ2V0VmFsID0gZnVuY3Rpb24gZ2V0VmFsKHApIHtcbiAgICBpZiAocCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IGVsc2UgaWYgKHAucGZWYWx1ZSAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gcC5wZlZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcC52YWx1ZTtcbiAgICB9XG4gIH07XG4gIHZhciBjaGVja1RyaWdnZXJzID0gZnVuY3Rpb24gY2hlY2tUcmlnZ2VycygpIHtcbiAgICB2YXIgZnJvbVZhbCA9IGdldFZhbChvcmlnUHJvcCk7XG4gICAgdmFyIHRvVmFsID0gZ2V0VmFsKHByb3ApO1xuICAgIHNlbGYuY2hlY2tUcmlnZ2VycyhlbGUsIHByb3AubmFtZSwgZnJvbVZhbCwgdG9WYWwpO1xuICB9O1xuXG4gIC8vIGVkZ2Ugc2FuaXR5IGNoZWNrcyB0byBwcmV2ZW50IHRoZSBjbGllbnQgZnJvbSBtYWtpbmcgc2VyaW91cyBtaXN0YWtlc1xuICBpZiAocGFyc2VkUHJvcC5uYW1lID09PSAnY3VydmUtc3R5bGUnICYmIGVsZS5pc0VkZ2UoKSAmJiAoXG4gIC8vIGxvb3BzIG11c3QgYmUgYnVuZGxlZCBiZXppZXJzXG4gIHBhcnNlZFByb3AudmFsdWUgIT09ICdiZXppZXInICYmIGVsZS5pc0xvb3AoKSB8fFxuICAvLyBlZGdlcyBjb25uZWN0ZWQgdG8gY29tcG91bmQgbm9kZXMgY2FuIG5vdCBiZSBoYXlzdGFja3NcbiAgcGFyc2VkUHJvcC52YWx1ZSA9PT0gJ2hheXN0YWNrJyAmJiAoZWxlLnNvdXJjZSgpLmlzUGFyZW50KCkgfHwgZWxlLnRhcmdldCgpLmlzUGFyZW50KCkpKSkge1xuICAgIHByb3AgPSBwYXJzZWRQcm9wID0gdGhpcy5wYXJzZShwYXJzZWRQcm9wLm5hbWUsICdiZXppZXInLCBwcm9wSXNCeXBhc3MpO1xuICB9XG4gIGlmIChwcm9wW1wiZGVsZXRlXCJdKSB7XG4gICAgLy8gZGVsZXRlIHRoZSBwcm9wZXJ0eSBhbmQgdXNlIHRoZSBkZWZhdWx0IHZhbHVlIG9uIGZhbHNleSB2YWx1ZVxuICAgIHN0eWxlW3Byb3AubmFtZV0gPSB1bmRlZmluZWQ7XG4gICAgY2hlY2tUcmlnZ2VycygpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChwcm9wLmRlbGV0ZUJ5cGFzc2VkKSB7XG4gICAgLy8gZGVsZXRlIHRoZSBwcm9wZXJ0eSB0aGF0IHRoZVxuICAgIGlmICghb3JpZ1Byb3ApIHtcbiAgICAgIGNoZWNrVHJpZ2dlcnMoKTtcbiAgICAgIHJldHVybiB0cnVlOyAvLyBjYW4ndCBkZWxldGUgaWYgbm8gcHJvcFxuICAgIH0gZWxzZSBpZiAob3JpZ1Byb3AuYnlwYXNzKSB7XG4gICAgICAvLyBkZWxldGUgYnlwYXNzZWRcbiAgICAgIG9yaWdQcm9wLmJ5cGFzc2VkID0gdW5kZWZpbmVkO1xuICAgICAgY2hlY2tUcmlnZ2VycygpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZTsgLy8gd2UncmUgdW5zdWNjZXNzZnVsIGRlbGV0aW5nIHRoZSBieXBhc3NlZFxuICAgIH1cbiAgfVxuXG4gIC8vIGNoZWNrIGlmIHdlIG5lZWQgdG8gZGVsZXRlIHRoZSBjdXJyZW50IGJ5cGFzc1xuICBpZiAocHJvcC5kZWxldGVCeXBhc3MpIHtcbiAgICAvLyB0aGVuIHRoaXMgcHJvcGVydHkgaXMganVzdCBoZXJlIHRvIGluZGljYXRlIHdlIG5lZWQgdG8gZGVsZXRlXG4gICAgaWYgKCFvcmlnUHJvcCkge1xuICAgICAgY2hlY2tUcmlnZ2VycygpO1xuICAgICAgcmV0dXJuIHRydWU7IC8vIHByb3BlcnR5IGlzIGFscmVhZHkgbm90IGRlZmluZWRcbiAgICB9IGVsc2UgaWYgKG9yaWdQcm9wLmJ5cGFzcykge1xuICAgICAgLy8gdGhlbiByZXBsYWNlIHRoZSBieXBhc3MgcHJvcGVydHkgd2l0aCB0aGUgb3JpZ2luYWxcbiAgICAgIC8vIGJlY2F1c2UgdGhlIGJ5cGFzc2VkIHByb3BlcnR5IHdhcyBhbHJlYWR5IGFwcGxpZWQgKGFuZCB0aGVyZWZvcmUgcGFyc2VkKSwgd2UgY2FuIGp1c3QgcmVwbGFjZSBpdCAobm8gcmVhcHBseWluZyBuZWNlc3NhcnkpXG4gICAgICBzdHlsZVtwcm9wLm5hbWVdID0gb3JpZ1Byb3AuYnlwYXNzZWQ7XG4gICAgICBjaGVja1RyaWdnZXJzKCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlOyAvLyB3ZSdyZSB1bnN1Y2Nlc3NmdWwgZGVsZXRpbmcgdGhlIGJ5cGFzc1xuICAgIH1cbiAgfVxuXG4gIHZhciBwcmludE1hcHBpbmdFcnIgPSBmdW5jdGlvbiBwcmludE1hcHBpbmdFcnIoKSB7XG4gICAgd2FybignRG8gbm90IGFzc2lnbiBtYXBwaW5ncyB0byBlbGVtZW50cyB3aXRob3V0IGNvcnJlc3BvbmRpbmcgZGF0YSAoaS5lLiBlbGUgYCcgKyBlbGUuaWQoKSArICdgIGhhcyBubyBtYXBwaW5nIGZvciBwcm9wZXJ0eSBgJyArIHByb3AubmFtZSArICdgIHdpdGggZGF0YSBmaWVsZCBgJyArIHByb3AuZmllbGQgKyAnYCk7IHRyeSBhIGBbJyArIHByb3AuZmllbGQgKyAnXWAgc2VsZWN0b3IgdG8gbGltaXQgc2NvcGUgdG8gZWxlbWVudHMgd2l0aCBgJyArIHByb3AuZmllbGQgKyAnYCBkZWZpbmVkJyk7XG4gIH07XG5cbiAgLy8gcHV0IHRoZSBwcm9wZXJ0eSBpbiB0aGUgc3R5bGUgb2JqZWN0c1xuICBzd2l0Y2ggKHByb3AubWFwcGVkKSB7XG4gICAgLy8gZmxhdHRlbiB0aGUgcHJvcGVydHkgaWYgbWFwcGVkXG4gICAgY2FzZSB0eXBlcy5tYXBEYXRhOlxuICAgICAge1xuICAgICAgICAvLyBmbGF0dGVuIHRoZSBmaWVsZCAoZS5nLiBkYXRhLmZvby5iYXIpXG4gICAgICAgIHZhciBmaWVsZHMgPSBwcm9wLmZpZWxkLnNwbGl0KCcuJyk7XG4gICAgICAgIHZhciBmaWVsZFZhbCA9IF9wLmRhdGE7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmllbGRzLmxlbmd0aCAmJiBmaWVsZFZhbDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGZpZWxkID0gZmllbGRzW2ldO1xuICAgICAgICAgIGZpZWxkVmFsID0gZmllbGRWYWxbZmllbGRdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmaWVsZFZhbCA9PSBudWxsKSB7XG4gICAgICAgICAgcHJpbnRNYXBwaW5nRXJyKCk7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwZXJjZW50O1xuICAgICAgICBpZiAoIW51bWJlciQxKGZpZWxkVmFsKSkge1xuICAgICAgICAgIC8vIHRoZW4gZG9uJ3QgYXBwbHkgYW5kIGZhbGwgYmFjayBvbiB0aGUgZXhpc3Rpbmcgc3R5bGVcbiAgICAgICAgICB3YXJuKCdEbyBub3QgdXNlIGNvbnRpbnVvdXMgbWFwcGVycyB3aXRob3V0IHNwZWNpZnlpbmcgbnVtZXJpYyBkYXRhIChpLmUuIGAnICsgcHJvcC5maWVsZCArICc6ICcgKyBmaWVsZFZhbCArICdgIGZvciBgJyArIGVsZS5pZCgpICsgJ2AgaXMgbm9uLW51bWVyaWMpJyk7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBmaWVsZFdpZHRoID0gcHJvcC5maWVsZE1heCAtIHByb3AuZmllbGRNaW47XG4gICAgICAgICAgaWYgKGZpZWxkV2lkdGggPT09IDApIHtcbiAgICAgICAgICAgIC8vIHNhZmV0eSBjaGVjayAtLSBub3Qgc3RyaWN0bHkgbmVjZXNzYXJ5IGFzIG5vIHByb3BzIG9mIHplcm8gcmFuZ2Ugc2hvdWxkIGJlIHBhc3NlZCBoZXJlXG4gICAgICAgICAgICBwZXJjZW50ID0gMDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGVyY2VudCA9IChmaWVsZFZhbCAtIHByb3AuZmllbGRNaW4pIC8gZmllbGRXaWR0aDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBtYWtlIHN1cmUgdG8gYm91bmQgcGVyY2VudCB2YWx1ZVxuICAgICAgICBpZiAocGVyY2VudCA8IDApIHtcbiAgICAgICAgICBwZXJjZW50ID0gMDtcbiAgICAgICAgfSBlbHNlIGlmIChwZXJjZW50ID4gMSkge1xuICAgICAgICAgIHBlcmNlbnQgPSAxO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlLmNvbG9yKSB7XG4gICAgICAgICAgdmFyIHIxID0gcHJvcC52YWx1ZU1pblswXTtcbiAgICAgICAgICB2YXIgcjIgPSBwcm9wLnZhbHVlTWF4WzBdO1xuICAgICAgICAgIHZhciBnMSA9IHByb3AudmFsdWVNaW5bMV07XG4gICAgICAgICAgdmFyIGcyID0gcHJvcC52YWx1ZU1heFsxXTtcbiAgICAgICAgICB2YXIgYjEgPSBwcm9wLnZhbHVlTWluWzJdO1xuICAgICAgICAgIHZhciBiMiA9IHByb3AudmFsdWVNYXhbMl07XG4gICAgICAgICAgdmFyIGExID0gcHJvcC52YWx1ZU1pblszXSA9PSBudWxsID8gMSA6IHByb3AudmFsdWVNaW5bM107XG4gICAgICAgICAgdmFyIGEyID0gcHJvcC52YWx1ZU1heFszXSA9PSBudWxsID8gMSA6IHByb3AudmFsdWVNYXhbM107XG4gICAgICAgICAgdmFyIGNsciA9IFtNYXRoLnJvdW5kKHIxICsgKHIyIC0gcjEpICogcGVyY2VudCksIE1hdGgucm91bmQoZzEgKyAoZzIgLSBnMSkgKiBwZXJjZW50KSwgTWF0aC5yb3VuZChiMSArIChiMiAtIGIxKSAqIHBlcmNlbnQpLCBNYXRoLnJvdW5kKGExICsgKGEyIC0gYTEpICogcGVyY2VudCldO1xuICAgICAgICAgIGZsYXRQcm9wID0ge1xuICAgICAgICAgICAgLy8gY29sb3VycyBhcmUgc2ltcGxlLCBzbyBqdXN0IGNyZWF0ZSB0aGUgZmxhdCBwcm9wZXJ0eSBpbnN0ZWFkIG9mIGV4cGVuc2l2ZSBzdHJpbmcgcGFyc2luZ1xuICAgICAgICAgICAgYnlwYXNzOiBwcm9wLmJ5cGFzcyxcbiAgICAgICAgICAgIC8vIHdlJ3JlIGEgYnlwYXNzIGlmIHRoZSBtYXBwaW5nIHByb3BlcnR5IGlzIGEgYnlwYXNzXG4gICAgICAgICAgICBuYW1lOiBwcm9wLm5hbWUsXG4gICAgICAgICAgICB2YWx1ZTogY2xyLFxuICAgICAgICAgICAgc3RyVmFsdWU6ICdyZ2IoJyArIGNsclswXSArICcsICcgKyBjbHJbMV0gKyAnLCAnICsgY2xyWzJdICsgJyknXG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlLm51bWJlcikge1xuICAgICAgICAgIHZhciBjYWxjVmFsdWUgPSBwcm9wLnZhbHVlTWluICsgKHByb3AudmFsdWVNYXggLSBwcm9wLnZhbHVlTWluKSAqIHBlcmNlbnQ7XG4gICAgICAgICAgZmxhdFByb3AgPSB0aGlzLnBhcnNlKHByb3AubmFtZSwgY2FsY1ZhbHVlLCBwcm9wLmJ5cGFzcywgZmxhdFByb3BNYXBwaW5nKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7IC8vIGNhbiBvbmx5IG1hcCB0byBjb2xvdXJzIGFuZCBudW1iZXJzXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWZsYXRQcm9wKSB7XG4gICAgICAgICAgLy8gaWYgd2UgY2FuJ3QgZmxhdHRlbiB0aGUgcHJvcGVydHksIHRoZW4gZG9uJ3QgYXBwbHkgdGhlIHByb3BlcnR5IGFuZCBmYWxsIGJhY2sgb24gdGhlIGV4aXN0aW5nIHN0eWxlXG4gICAgICAgICAgcHJpbnRNYXBwaW5nRXJyKCk7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGZsYXRQcm9wLm1hcHBpbmcgPSBwcm9wOyAvLyBrZWVwIGEgcmVmZXJlbmNlIHRvIHRoZSBtYXBwaW5nXG4gICAgICAgIHByb3AgPSBmbGF0UHJvcDsgLy8gdGhlIGZsYXR0ZW5lZCAobWFwcGVkKSBwcm9wZXJ0eSBpcyB0aGUgb25lIHdlIHdhbnRcblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIC8vIGRpcmVjdCBtYXBwaW5nXG4gICAgY2FzZSB0eXBlcy5kYXRhOlxuICAgICAge1xuICAgICAgICAvLyBmbGF0dGVuIHRoZSBmaWVsZCAoZS5nLiBkYXRhLmZvby5iYXIpXG4gICAgICAgIHZhciBfZmllbGRzID0gcHJvcC5maWVsZC5zcGxpdCgnLicpO1xuICAgICAgICB2YXIgX2ZpZWxkVmFsID0gX3AuZGF0YTtcbiAgICAgICAgZm9yICh2YXIgX2kzID0gMDsgX2kzIDwgX2ZpZWxkcy5sZW5ndGggJiYgX2ZpZWxkVmFsOyBfaTMrKykge1xuICAgICAgICAgIHZhciBfZmllbGQgPSBfZmllbGRzW19pM107XG4gICAgICAgICAgX2ZpZWxkVmFsID0gX2ZpZWxkVmFsW19maWVsZF07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKF9maWVsZFZhbCAhPSBudWxsKSB7XG4gICAgICAgICAgZmxhdFByb3AgPSB0aGlzLnBhcnNlKHByb3AubmFtZSwgX2ZpZWxkVmFsLCBwcm9wLmJ5cGFzcywgZmxhdFByb3BNYXBwaW5nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWZsYXRQcm9wKSB7XG4gICAgICAgICAgLy8gaWYgd2UgY2FuJ3QgZmxhdHRlbiB0aGUgcHJvcGVydHksIHRoZW4gZG9uJ3QgYXBwbHkgYW5kIGZhbGwgYmFjayBvbiB0aGUgZXhpc3Rpbmcgc3R5bGVcbiAgICAgICAgICBwcmludE1hcHBpbmdFcnIoKTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZmxhdFByb3AubWFwcGluZyA9IHByb3A7IC8vIGtlZXAgYSByZWZlcmVuY2UgdG8gdGhlIG1hcHBpbmdcbiAgICAgICAgcHJvcCA9IGZsYXRQcm9wOyAvLyB0aGUgZmxhdHRlbmVkIChtYXBwZWQpIHByb3BlcnR5IGlzIHRoZSBvbmUgd2Ugd2FudFxuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIGNhc2UgdHlwZXMuZm46XG4gICAgICB7XG4gICAgICAgIHZhciBmbiA9IHByb3AudmFsdWU7XG4gICAgICAgIHZhciBmblJldFZhbCA9IHByb3AuZm5WYWx1ZSAhPSBudWxsID8gcHJvcC5mblZhbHVlIDogZm4oZWxlKTsgLy8gY2hlY2sgZm9yIGNhY2hlZCB2YWx1ZSBiZWZvcmUgY2FsbGluZyBmdW5jdGlvblxuXG4gICAgICAgIHByb3AucHJldkZuVmFsdWUgPSBmblJldFZhbDtcbiAgICAgICAgaWYgKGZuUmV0VmFsID09IG51bGwpIHtcbiAgICAgICAgICB3YXJuKCdDdXN0b20gZnVuY3Rpb24gbWFwcGVycyBtYXkgbm90IHJldHVybiBudWxsIChpLmUuIGAnICsgcHJvcC5uYW1lICsgJ2AgZm9yIGVsZSBgJyArIGVsZS5pZCgpICsgJ2AgaXMgbnVsbCknKTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZmxhdFByb3AgPSB0aGlzLnBhcnNlKHByb3AubmFtZSwgZm5SZXRWYWwsIHByb3AuYnlwYXNzLCBmbGF0UHJvcE1hcHBpbmcpO1xuICAgICAgICBpZiAoIWZsYXRQcm9wKSB7XG4gICAgICAgICAgd2FybignQ3VzdG9tIGZ1bmN0aW9uIG1hcHBlcnMgbWF5IG5vdCByZXR1cm4gaW52YWxpZCB2YWx1ZXMgZm9yIHRoZSBwcm9wZXJ0eSB0eXBlIChpLmUuIGAnICsgcHJvcC5uYW1lICsgJ2AgZm9yIGVsZSBgJyArIGVsZS5pZCgpICsgJ2AgaXMgaW52YWxpZCknKTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZmxhdFByb3AubWFwcGluZyA9IGNvcHkocHJvcCk7IC8vIGtlZXAgYSByZWZlcmVuY2UgdG8gdGhlIG1hcHBpbmdcbiAgICAgICAgcHJvcCA9IGZsYXRQcm9wOyAvLyB0aGUgZmxhdHRlbmVkIChtYXBwZWQpIHByb3BlcnR5IGlzIHRoZSBvbmUgd2Ugd2FudFxuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIGNhc2UgdW5kZWZpbmVkOlxuICAgICAgYnJlYWs7XG4gICAgLy8ganVzdCBzZXQgdGhlIHByb3BlcnR5XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIC8vIG5vdCBhIHZhbGlkIG1hcHBpbmdcbiAgfVxuXG4gIC8vIGlmIHRoZSBwcm9wZXJ0eSBpcyBhIGJ5cGFzcyBwcm9wZXJ0eSwgdGhlbiBsaW5rIHRoZSByZXN1bHRhbnQgcHJvcGVydHkgdG8gdGhlIG9yaWdpbmFsIG9uZVxuICBpZiAocHJvcElzQnlwYXNzKSB7XG4gICAgaWYgKG9yaWdQcm9wSXNCeXBhc3MpIHtcbiAgICAgIC8vIHRoZW4gdGhpcyBieXBhc3Mgb3ZlcnJpZGVzIHRoZSBleGlzdGluZyBvbmVcbiAgICAgIHByb3AuYnlwYXNzZWQgPSBvcmlnUHJvcC5ieXBhc3NlZDsgLy8gc3RlYWwgYnlwYXNzZWQgcHJvcCBmcm9tIG9sZCBieXBhc3NcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gdGhlbiBsaW5rIHRoZSBvcmlnIHByb3AgdG8gdGhlIG5ldyBieXBhc3NcbiAgICAgIHByb3AuYnlwYXNzZWQgPSBvcmlnUHJvcDtcbiAgICB9XG4gICAgc3R5bGVbcHJvcC5uYW1lXSA9IHByb3A7IC8vIGFuZCBzZXRcbiAgfSBlbHNlIHtcbiAgICAvLyBwcm9wIGlzIG5vdCBieXBhc3NcbiAgICBpZiAob3JpZ1Byb3BJc0J5cGFzcykge1xuICAgICAgLy8gdGhlbiBrZWVwIHRoZSBvcmlnIHByb3AgKHNpbmNlIGl0J3MgYSBieXBhc3MpIGFuZCBsaW5rIHRvIHRoZSBuZXcgcHJvcFxuICAgICAgb3JpZ1Byb3AuYnlwYXNzZWQgPSBwcm9wO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB0aGVuIGp1c3QgcmVwbGFjZSB0aGUgb2xkIHByb3Agd2l0aCB0aGUgbmV3IG9uZVxuICAgICAgc3R5bGVbcHJvcC5uYW1lXSA9IHByb3A7XG4gICAgfVxuICB9XG4gIGNoZWNrVHJpZ2dlcnMoKTtcbiAgcmV0dXJuIHRydWU7XG59O1xuc3R5Zm4kOC5jbGVhbkVsZW1lbnRzID0gZnVuY3Rpb24gKGVsZXMsIGtlZXBCeXBhc3Nlcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZWxlID0gZWxlc1tpXTtcbiAgICB0aGlzLmNsZWFyU3R5bGVIaW50cyhlbGUpO1xuICAgIGVsZS5kaXJ0eUNvbXBvdW5kQm91bmRzQ2FjaGUoKTtcbiAgICBlbGUuZGlydHlCb3VuZGluZ0JveENhY2hlKCk7XG4gICAgaWYgKCFrZWVwQnlwYXNzZXMpIHtcbiAgICAgIGVsZS5fcHJpdmF0ZS5zdHlsZSA9IHt9O1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgc3R5bGUgPSBlbGUuX3ByaXZhdGUuc3R5bGU7XG4gICAgICB2YXIgcHJvcE5hbWVzID0gT2JqZWN0LmtleXMoc3R5bGUpO1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBwcm9wTmFtZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgdmFyIHByb3BOYW1lID0gcHJvcE5hbWVzW2pdO1xuICAgICAgICB2YXIgZWxlUHJvcCA9IHN0eWxlW3Byb3BOYW1lXTtcbiAgICAgICAgaWYgKGVsZVByb3AgIT0gbnVsbCkge1xuICAgICAgICAgIGlmIChlbGVQcm9wLmJ5cGFzcykge1xuICAgICAgICAgICAgZWxlUHJvcC5ieXBhc3NlZCA9IG51bGw7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0eWxlW3Byb3BOYW1lXSA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG4vLyB1cGRhdGVzIHRoZSB2aXN1YWwgc3R5bGUgZm9yIGFsbCBlbGVtZW50cyAodXNlZnVsIGZvciBtYW51YWwgc3R5bGUgbW9kaWZpY2F0aW9uIGFmdGVyIGluaXQpXG5zdHlmbiQ4LnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeTtcbiAgdmFyIGVsZXMgPSBjeS5tdXRhYmxlRWxlbWVudHMoKTtcbiAgZWxlcy51cGRhdGVTdHlsZSgpO1xufTtcblxuLy8gZGlmZlByb3BzIDogeyBuYW1lID0+IHsgcHJldiwgbmV4dCB9IH1cbnN0eWZuJDgudXBkYXRlVHJhbnNpdGlvbnMgPSBmdW5jdGlvbiAoZWxlLCBkaWZmUHJvcHMpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gIHZhciBwcm9wcyA9IGVsZS5wc3R5bGUoJ3RyYW5zaXRpb24tcHJvcGVydHknKS52YWx1ZTtcbiAgdmFyIGR1cmF0aW9uID0gZWxlLnBzdHlsZSgndHJhbnNpdGlvbi1kdXJhdGlvbicpLnBmVmFsdWU7XG4gIHZhciBkZWxheSA9IGVsZS5wc3R5bGUoJ3RyYW5zaXRpb24tZGVsYXknKS5wZlZhbHVlO1xuICBpZiAocHJvcHMubGVuZ3RoID4gMCAmJiBkdXJhdGlvbiA+IDApIHtcbiAgICB2YXIgc3R5bGUgPSB7fTtcblxuICAgIC8vIGJ1aWxkIHVwIHRoZSBzdHlsZSB0byBhbmltYXRlIHRvd2FyZHNcbiAgICB2YXIgYW55UHJldiA9IGZhbHNlO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBwcm9wID0gcHJvcHNbaV07XG4gICAgICB2YXIgc3R5UHJvcCA9IGVsZS5wc3R5bGUocHJvcCk7XG4gICAgICB2YXIgZGlmZlByb3AgPSBkaWZmUHJvcHNbcHJvcF07XG4gICAgICBpZiAoIWRpZmZQcm9wKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdmFyIHByZXZQcm9wID0gZGlmZlByb3AucHJldjtcbiAgICAgIHZhciBmcm9tUHJvcCA9IHByZXZQcm9wO1xuICAgICAgdmFyIHRvUHJvcCA9IGRpZmZQcm9wLm5leHQgIT0gbnVsbCA/IGRpZmZQcm9wLm5leHQgOiBzdHlQcm9wO1xuICAgICAgdmFyIGRpZmYgPSBmYWxzZTtcbiAgICAgIHZhciBpbml0VmFsID0gdm9pZCAwO1xuICAgICAgdmFyIGluaXREdCA9IDAuMDAwMDAxOyAvLyBkZWx0YSB0aW1lICUgdmFsdWUgZm9yIGluaXRWYWwgKGFsbG93cyBhbmltYXRpbmcgb3V0IG9mIGluaXQgemVybyBvcGFjaXR5KVxuXG4gICAgICBpZiAoIWZyb21Qcm9wKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBjb25zaWRlciBweCB2YWx1ZXNcbiAgICAgIGlmIChudW1iZXIkMShmcm9tUHJvcC5wZlZhbHVlKSAmJiBudW1iZXIkMSh0b1Byb3AucGZWYWx1ZSkpIHtcbiAgICAgICAgZGlmZiA9IHRvUHJvcC5wZlZhbHVlIC0gZnJvbVByb3AucGZWYWx1ZTsgLy8gbm9uemVybyBpcyB0cnV0aHlcbiAgICAgICAgaW5pdFZhbCA9IGZyb21Qcm9wLnBmVmFsdWUgKyBpbml0RHQgKiBkaWZmO1xuXG4gICAgICAgIC8vIGNvbnNpZGVyIG51bWVyaWNhbCB2YWx1ZXNcbiAgICAgIH0gZWxzZSBpZiAobnVtYmVyJDEoZnJvbVByb3AudmFsdWUpICYmIG51bWJlciQxKHRvUHJvcC52YWx1ZSkpIHtcbiAgICAgICAgZGlmZiA9IHRvUHJvcC52YWx1ZSAtIGZyb21Qcm9wLnZhbHVlOyAvLyBub256ZXJvIGlzIHRydXRoeVxuICAgICAgICBpbml0VmFsID0gZnJvbVByb3AudmFsdWUgKyBpbml0RHQgKiBkaWZmO1xuXG4gICAgICAgIC8vIGNvbnNpZGVyIGNvbG91ciB2YWx1ZXNcbiAgICAgIH0gZWxzZSBpZiAoYXJyYXkoZnJvbVByb3AudmFsdWUpICYmIGFycmF5KHRvUHJvcC52YWx1ZSkpIHtcbiAgICAgICAgZGlmZiA9IGZyb21Qcm9wLnZhbHVlWzBdICE9PSB0b1Byb3AudmFsdWVbMF0gfHwgZnJvbVByb3AudmFsdWVbMV0gIT09IHRvUHJvcC52YWx1ZVsxXSB8fCBmcm9tUHJvcC52YWx1ZVsyXSAhPT0gdG9Qcm9wLnZhbHVlWzJdO1xuICAgICAgICBpbml0VmFsID0gZnJvbVByb3Auc3RyVmFsdWU7XG4gICAgICB9XG5cbiAgICAgIC8vIHRoZSBwcmV2aW91cyB2YWx1ZSBpcyBnb29kIGZvciBhbiBhbmltYXRpb24gb25seSBpZiBpdCdzIGRpZmZlcmVudFxuICAgICAgaWYgKGRpZmYpIHtcbiAgICAgICAgc3R5bGVbcHJvcF0gPSB0b1Byb3Auc3RyVmFsdWU7IC8vIHRvIHZhbFxuICAgICAgICB0aGlzLmFwcGx5QnlwYXNzKGVsZSwgcHJvcCwgaW5pdFZhbCk7IC8vIGZyb20gdmFsXG4gICAgICAgIGFueVByZXYgPSB0cnVlO1xuICAgICAgfVxuICAgIH0gLy8gZW5kIGlmIHByb3BzIGFsbG93IGFuaVxuXG4gICAgLy8gY2FuJ3QgdHJhbnNpdGlvbiBpZiB0aGVyZSdzIG5vdGhpbmcgcHJldmlvdXMgdG8gdHJhbnNpdGlvbiBmcm9tXG4gICAgaWYgKCFhbnlQcmV2KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIF9wLnRyYW5zaXRpb25pbmcgPSB0cnVlO1xuICAgIG5ldyBQcm9taXNlJDEoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgIGlmIChkZWxheSA+IDApIHtcbiAgICAgICAgZWxlLmRlbGF5QW5pbWF0aW9uKGRlbGF5KS5wbGF5KCkucHJvbWlzZSgpLnRoZW4ocmVzb2x2ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXNvbHZlKCk7XG4gICAgICB9XG4gICAgfSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gZWxlLmFuaW1hdGlvbih7XG4gICAgICAgIHN0eWxlOiBzdHlsZSxcbiAgICAgICAgZHVyYXRpb246IGR1cmF0aW9uLFxuICAgICAgICBlYXNpbmc6IGVsZS5wc3R5bGUoJ3RyYW5zaXRpb24tdGltaW5nLWZ1bmN0aW9uJykudmFsdWUsXG4gICAgICAgIHF1ZXVlOiBmYWxzZVxuICAgICAgfSkucGxheSgpLnByb21pc2UoKTtcbiAgICB9KS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIGlmKCAhaXNCeXBhc3MgKXtcbiAgICAgIHNlbGYucmVtb3ZlQnlwYXNzZXMoZWxlLCBwcm9wcyk7XG4gICAgICBlbGUuZW1pdEFuZE5vdGlmeSgnc3R5bGUnKTtcbiAgICAgIC8vIH1cblxuICAgICAgX3AudHJhbnNpdGlvbmluZyA9IGZhbHNlO1xuICAgIH0pO1xuICB9IGVsc2UgaWYgKF9wLnRyYW5zaXRpb25pbmcpIHtcbiAgICB0aGlzLnJlbW92ZUJ5cGFzc2VzKGVsZSwgcHJvcHMpO1xuICAgIGVsZS5lbWl0QW5kTm90aWZ5KCdzdHlsZScpO1xuICAgIF9wLnRyYW5zaXRpb25pbmcgPSBmYWxzZTtcbiAgfVxufTtcbnN0eWZuJDguY2hlY2tUcmlnZ2VyID0gZnVuY3Rpb24gKGVsZSwgbmFtZSwgZnJvbVZhbHVlLCB0b1ZhbHVlLCBnZXRUcmlnZ2VyLCBvblRyaWdnZXIpIHtcbiAgdmFyIHByb3AgPSB0aGlzLnByb3BlcnRpZXNbbmFtZV07XG4gIHZhciB0cmlnZ2VyQ2hlY2sgPSBnZXRUcmlnZ2VyKHByb3ApO1xuICBpZiAodHJpZ2dlckNoZWNrICE9IG51bGwgJiYgdHJpZ2dlckNoZWNrKGZyb21WYWx1ZSwgdG9WYWx1ZSkpIHtcbiAgICBvblRyaWdnZXIocHJvcCk7XG4gIH1cbn07XG5zdHlmbiQ4LmNoZWNrWk9yZGVyVHJpZ2dlciA9IGZ1bmN0aW9uIChlbGUsIG5hbWUsIGZyb21WYWx1ZSwgdG9WYWx1ZSkge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuICB0aGlzLmNoZWNrVHJpZ2dlcihlbGUsIG5hbWUsIGZyb21WYWx1ZSwgdG9WYWx1ZSwgZnVuY3Rpb24gKHByb3ApIHtcbiAgICByZXR1cm4gcHJvcC50cmlnZ2Vyc1pPcmRlcjtcbiAgfSwgZnVuY3Rpb24gKCkge1xuICAgIF90aGlzLl9wcml2YXRlLmN5Lm5vdGlmeSgnem9yZGVyJywgZWxlKTtcbiAgfSk7XG59O1xuc3R5Zm4kOC5jaGVja0JvdW5kc1RyaWdnZXIgPSBmdW5jdGlvbiAoZWxlLCBuYW1lLCBmcm9tVmFsdWUsIHRvVmFsdWUpIHtcbiAgdGhpcy5jaGVja1RyaWdnZXIoZWxlLCBuYW1lLCBmcm9tVmFsdWUsIHRvVmFsdWUsIGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgcmV0dXJuIHByb3AudHJpZ2dlcnNCb3VuZHM7XG4gIH0sIGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgZWxlLmRpcnR5Q29tcG91bmRCb3VuZHNDYWNoZSgpO1xuICAgIGVsZS5kaXJ0eUJvdW5kaW5nQm94Q2FjaGUoKTtcblxuICAgIC8vIGlmIHRoZSBwcm9wIGNoYW5nZSBtYWtlcyB0aGUgYmIgb2YgcGxsIGJlemllciBlZGdlcyBpbnZhbGlkLFxuICAgIC8vIHRoZW4gZGlydHkgdGhlIHBsbCBlZGdlIGJiIGNhY2hlIGFzIHdlbGxcbiAgICBpZiAoXG4gICAgLy8gb25seSBmb3IgYmV6aWVycyAtLSBzbyBwZXJmb3JtYW5jZSBvZiBvdGhlciBlZGdlcyBpc24ndCBhZmZlY3RlZFxuICAgIHByb3AudHJpZ2dlcnNCb3VuZHNPZlBhcmFsbGVsQmV6aWVycyAmJiBuYW1lID09PSAnY3VydmUtc3R5bGUnICYmIChmcm9tVmFsdWUgPT09ICdiZXppZXInIHx8IHRvVmFsdWUgPT09ICdiZXppZXInKSkge1xuICAgICAgZWxlLnBhcmFsbGVsRWRnZXMoKS5mb3JFYWNoKGZ1bmN0aW9uIChwbGxFZGdlKSB7XG4gICAgICAgIHBsbEVkZ2UuZGlydHlCb3VuZGluZ0JveENhY2hlKCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHByb3AudHJpZ2dlcnNCb3VuZHNPZkNvbm5lY3RlZEVkZ2VzICYmIG5hbWUgPT09ICdkaXNwbGF5JyAmJiAoZnJvbVZhbHVlID09PSAnbm9uZScgfHwgdG9WYWx1ZSA9PT0gJ25vbmUnKSkge1xuICAgICAgZWxlLmNvbm5lY3RlZEVkZ2VzKCkuZm9yRWFjaChmdW5jdGlvbiAoZWRnZSkge1xuICAgICAgICBlZGdlLmRpcnR5Qm91bmRpbmdCb3hDYWNoZSgpO1xuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbn07XG5zdHlmbiQ4LmNoZWNrVHJpZ2dlcnMgPSBmdW5jdGlvbiAoZWxlLCBuYW1lLCBmcm9tVmFsdWUsIHRvVmFsdWUpIHtcbiAgZWxlLmRpcnR5U3R5bGVDYWNoZSgpO1xuICB0aGlzLmNoZWNrWk9yZGVyVHJpZ2dlcihlbGUsIG5hbWUsIGZyb21WYWx1ZSwgdG9WYWx1ZSk7XG4gIHRoaXMuY2hlY2tCb3VuZHNUcmlnZ2VyKGVsZSwgbmFtZSwgZnJvbVZhbHVlLCB0b1ZhbHVlKTtcbn07XG5cbnZhciBzdHlmbiQ3ID0ge307XG5cbi8vIGJ5cGFzc2VzIGFyZSBhcHBsaWVkIHRvIGFuIGV4aXN0aW5nIHN0eWxlIG9uIGFuIGVsZW1lbnQsIGFuZCBqdXN0IHRhY2tlZCBvbiB0ZW1wb3JhcmlseVxuLy8gcmV0dXJucyB0cnVlIGlmZiBhcHBsaWNhdGlvbiB3YXMgc3VjY2Vzc2Z1bCBmb3IgYXQgbGVhc3QgMSBzcGVjaWZpZWQgcHJvcGVydHlcbnN0eWZuJDcuYXBwbHlCeXBhc3MgPSBmdW5jdGlvbiAoZWxlcywgbmFtZSwgdmFsdWUsIHVwZGF0ZVRyYW5zaXRpb25zKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHByb3BzID0gW107XG4gIHZhciBpc0J5cGFzcyA9IHRydWU7XG5cbiAgLy8gcHV0IGFsbCB0aGUgcHJvcGVydGllcyAoY2FuIHNwZWNpZnkgb25lIG9yIG1hbnkpIGluIGFuIGFycmF5IGFmdGVyIHBhcnNpbmcgdGhlbVxuICBpZiAobmFtZSA9PT0gJyonIHx8IG5hbWUgPT09ICcqKicpIHtcbiAgICAvLyBhcHBseSB0byBhbGwgcHJvcGVydHkgbmFtZXNcblxuICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbGYucHJvcGVydGllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcHJvcCA9IHNlbGYucHJvcGVydGllc1tpXTtcbiAgICAgICAgdmFyIF9uYW1lID0gcHJvcC5uYW1lO1xuICAgICAgICB2YXIgcGFyc2VkUHJvcCA9IHRoaXMucGFyc2UoX25hbWUsIHZhbHVlLCB0cnVlKTtcbiAgICAgICAgaWYgKHBhcnNlZFByb3ApIHtcbiAgICAgICAgICBwcm9wcy5wdXNoKHBhcnNlZFByb3ApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKHN0cmluZyhuYW1lKSkge1xuICAgIC8vIHRoZW4gcGFyc2UgdGhlIHNpbmdsZSBwcm9wZXJ0eVxuICAgIHZhciBfcGFyc2VkUHJvcCA9IHRoaXMucGFyc2UobmFtZSwgdmFsdWUsIHRydWUpO1xuICAgIGlmIChfcGFyc2VkUHJvcCkge1xuICAgICAgcHJvcHMucHVzaChfcGFyc2VkUHJvcCk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHBsYWluT2JqZWN0KG5hbWUpKSB7XG4gICAgLy8gdGhlbiBwYXJzZSBlYWNoIHByb3BlcnR5XG4gICAgdmFyIHNwZWNpZmllZFByb3BzID0gbmFtZTtcbiAgICB1cGRhdGVUcmFuc2l0aW9ucyA9IHZhbHVlO1xuICAgIHZhciBuYW1lcyA9IE9iamVjdC5rZXlzKHNwZWNpZmllZFByb3BzKTtcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgbmFtZXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICB2YXIgX25hbWUyID0gbmFtZXNbX2ldO1xuICAgICAgdmFyIF92YWx1ZSA9IHNwZWNpZmllZFByb3BzW19uYW1lMl07XG4gICAgICBpZiAoX3ZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gdHJ5IGNhbWVsIGNhc2UgbmFtZSB0b29cbiAgICAgICAgX3ZhbHVlID0gc3BlY2lmaWVkUHJvcHNbZGFzaDJjYW1lbChfbmFtZTIpXTtcbiAgICAgIH1cbiAgICAgIGlmIChfdmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgX3BhcnNlZFByb3AyID0gdGhpcy5wYXJzZShfbmFtZTIsIF92YWx1ZSwgdHJ1ZSk7XG4gICAgICAgIGlmIChfcGFyc2VkUHJvcDIpIHtcbiAgICAgICAgICBwcm9wcy5wdXNoKF9wYXJzZWRQcm9wMik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gY2FuJ3QgZG8gYW55dGhpbmcgd2l0aG91dCB3ZWxsIGRlZmluZWQgcHJvcGVydGllc1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIHdlJ3ZlIGZhaWxlZCBpZiB0aGVyZSBhcmUgbm8gdmFsaWQgcHJvcGVydGllc1xuICBpZiAocHJvcHMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gbm93LCBhcHBseSB0aGUgYnlwYXNzIHByb3BlcnRpZXMgb24gdGhlIGVsZW1lbnRzXG4gIHZhciByZXQgPSBmYWxzZTsgLy8gcmV0dXJuIHRydWUgaWYgYXQgbGVhc3Qgb25lIHN1Y2Nlc2Z1bCBieXBhc3MgYXBwbGllZFxuICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBlbGVzLmxlbmd0aDsgX2kyKyspIHtcbiAgICAvLyBmb3IgZWFjaCBlbGVcbiAgICB2YXIgZWxlID0gZWxlc1tfaTJdO1xuICAgIHZhciBkaWZmUHJvcHMgPSB7fTtcbiAgICB2YXIgZGlmZlByb3AgPSB2b2lkIDA7XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBwcm9wcy5sZW5ndGg7IGorKykge1xuICAgICAgLy8gZm9yIGVhY2ggcHJvcFxuICAgICAgdmFyIF9wcm9wID0gcHJvcHNbal07XG4gICAgICBpZiAodXBkYXRlVHJhbnNpdGlvbnMpIHtcbiAgICAgICAgdmFyIHByZXZQcm9wID0gZWxlLnBzdHlsZShfcHJvcC5uYW1lKTtcbiAgICAgICAgZGlmZlByb3AgPSBkaWZmUHJvcHNbX3Byb3AubmFtZV0gPSB7XG4gICAgICAgICAgcHJldjogcHJldlByb3BcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldCA9IHRoaXMuYXBwbHlQYXJzZWRQcm9wZXJ0eShlbGUsIGNvcHkoX3Byb3ApKSB8fCByZXQ7XG4gICAgICBpZiAodXBkYXRlVHJhbnNpdGlvbnMpIHtcbiAgICAgICAgZGlmZlByb3AubmV4dCA9IGVsZS5wc3R5bGUoX3Byb3AubmFtZSk7XG4gICAgICB9XG4gICAgfSAvLyBmb3IgcHJvcHNcblxuICAgIGlmIChyZXQpIHtcbiAgICAgIHRoaXMudXBkYXRlU3R5bGVIaW50cyhlbGUpO1xuICAgIH1cbiAgICBpZiAodXBkYXRlVHJhbnNpdGlvbnMpIHtcbiAgICAgIHRoaXMudXBkYXRlVHJhbnNpdGlvbnMoZWxlLCBkaWZmUHJvcHMsIGlzQnlwYXNzKTtcbiAgICB9XG4gIH0gLy8gZm9yIGVsZXNcblxuICByZXR1cm4gcmV0O1xufTtcblxuLy8gb25seSB1c2VmdWwgaW4gc3BlY2lmaWMgY2FzZXMgbGlrZSBhbmltYXRpb25cbnN0eWZuJDcub3ZlcnJpZGVCeXBhc3MgPSBmdW5jdGlvbiAoZWxlcywgbmFtZSwgdmFsdWUpIHtcbiAgbmFtZSA9IGNhbWVsMmRhc2gobmFtZSk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBlbGUgPSBlbGVzW2ldO1xuICAgIHZhciBwcm9wID0gZWxlLl9wcml2YXRlLnN0eWxlW25hbWVdO1xuICAgIHZhciB0eXBlID0gdGhpcy5wcm9wZXJ0aWVzW25hbWVdLnR5cGU7XG4gICAgdmFyIGlzQ29sb3IgPSB0eXBlLmNvbG9yO1xuICAgIHZhciBpc011bHRpID0gdHlwZS5tdXRpcGxlO1xuICAgIHZhciBvbGRWYWx1ZSA9ICFwcm9wID8gbnVsbCA6IHByb3AucGZWYWx1ZSAhPSBudWxsID8gcHJvcC5wZlZhbHVlIDogcHJvcC52YWx1ZTtcbiAgICBpZiAoIXByb3AgfHwgIXByb3AuYnlwYXNzKSB7XG4gICAgICAvLyBuZWVkIGEgYnlwYXNzIGlmIG9uZSBkb2Vzbid0IGV4aXN0XG4gICAgICB0aGlzLmFwcGx5QnlwYXNzKGVsZSwgbmFtZSwgdmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcm9wLnZhbHVlID0gdmFsdWU7XG4gICAgICBpZiAocHJvcC5wZlZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgcHJvcC5wZlZhbHVlID0gdmFsdWU7XG4gICAgICB9XG4gICAgICBpZiAoaXNDb2xvcikge1xuICAgICAgICBwcm9wLnN0clZhbHVlID0gJ3JnYignICsgdmFsdWUuam9pbignLCcpICsgJyknO1xuICAgICAgfSBlbHNlIGlmIChpc011bHRpKSB7XG4gICAgICAgIHByb3Auc3RyVmFsdWUgPSB2YWx1ZS5qb2luKCcgJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9wLnN0clZhbHVlID0gJycgKyB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHRoaXMudXBkYXRlU3R5bGVIaW50cyhlbGUpO1xuICAgIH1cbiAgICB0aGlzLmNoZWNrVHJpZ2dlcnMoZWxlLCBuYW1lLCBvbGRWYWx1ZSwgdmFsdWUpO1xuICB9XG59O1xuc3R5Zm4kNy5yZW1vdmVBbGxCeXBhc3NlcyA9IGZ1bmN0aW9uIChlbGVzLCB1cGRhdGVUcmFuc2l0aW9ucykge1xuICByZXR1cm4gdGhpcy5yZW1vdmVCeXBhc3NlcyhlbGVzLCB0aGlzLnByb3BlcnR5TmFtZXMsIHVwZGF0ZVRyYW5zaXRpb25zKTtcbn07XG5zdHlmbiQ3LnJlbW92ZUJ5cGFzc2VzID0gZnVuY3Rpb24gKGVsZXMsIHByb3BzLCB1cGRhdGVUcmFuc2l0aW9ucykge1xuICB2YXIgaXNCeXBhc3MgPSB0cnVlO1xuICBmb3IgKHZhciBqID0gMDsgaiA8IGVsZXMubGVuZ3RoOyBqKyspIHtcbiAgICB2YXIgZWxlID0gZWxlc1tqXTtcbiAgICB2YXIgZGlmZlByb3BzID0ge307XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIG5hbWUgPSBwcm9wc1tpXTtcbiAgICAgIHZhciBwcm9wID0gdGhpcy5wcm9wZXJ0aWVzW25hbWVdO1xuICAgICAgdmFyIHByZXZQcm9wID0gZWxlLnBzdHlsZShwcm9wLm5hbWUpO1xuICAgICAgaWYgKCFwcmV2UHJvcCB8fCAhcHJldlByb3AuYnlwYXNzKSB7XG4gICAgICAgIC8vIGlmIGEgYnlwYXNzIGRvZXNuJ3QgZXhpc3QgZm9yIHRoZSBwcm9wLCBub3RoaW5nIG5lZWRzIHRvIGJlIHJlbW92ZWRcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB2YXIgdmFsdWUgPSAnJzsgLy8gZW1wdHkgPT4gcmVtb3ZlIGJ5cGFzc1xuICAgICAgdmFyIHBhcnNlZFByb3AgPSB0aGlzLnBhcnNlKG5hbWUsIHZhbHVlLCB0cnVlKTtcbiAgICAgIHZhciBkaWZmUHJvcCA9IGRpZmZQcm9wc1twcm9wLm5hbWVdID0ge1xuICAgICAgICBwcmV2OiBwcmV2UHJvcFxuICAgICAgfTtcbiAgICAgIHRoaXMuYXBwbHlQYXJzZWRQcm9wZXJ0eShlbGUsIHBhcnNlZFByb3ApO1xuICAgICAgZGlmZlByb3AubmV4dCA9IGVsZS5wc3R5bGUocHJvcC5uYW1lKTtcbiAgICB9IC8vIGZvciBwcm9wc1xuXG4gICAgdGhpcy51cGRhdGVTdHlsZUhpbnRzKGVsZSk7XG4gICAgaWYgKHVwZGF0ZVRyYW5zaXRpb25zKSB7XG4gICAgICB0aGlzLnVwZGF0ZVRyYW5zaXRpb25zKGVsZSwgZGlmZlByb3BzLCBpc0J5cGFzcyk7XG4gICAgfVxuICB9IC8vIGZvciBlbGVzXG59O1xuXG52YXIgc3R5Zm4kNiA9IHt9O1xuXG4vLyBnZXRzIHdoYXQgYW4gZW0gc2l6ZSBjb3JyZXNwb25kcyB0byBpbiBwaXhlbHMgcmVsYXRpdmUgdG8gYSBkb20gZWxlbWVudFxuc3R5Zm4kNi5nZXRFbVNpemVJblBpeGVscyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHB4ID0gdGhpcy5jb250YWluZXJDc3MoJ2ZvbnQtc2l6ZScpO1xuICBpZiAocHggIT0gbnVsbCkge1xuICAgIHJldHVybiBwYXJzZUZsb2F0KHB4KTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gMTsgLy8gZm9yIGhlYWRsZXNzXG4gIH1cbn07XG5cbi8vIGdldHMgY3NzIHByb3BlcnR5IGZyb20gdGhlIGNvcmUgY29udGFpbmVyXG5zdHlmbiQ2LmNvbnRhaW5lckNzcyA9IGZ1bmN0aW9uIChwcm9wTmFtZSkge1xuICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5O1xuICB2YXIgZG9tRWxlbWVudCA9IGN5LmNvbnRhaW5lcigpO1xuICB2YXIgY29udGFpbmVyV2luZG93ID0gY3kud2luZG93KCk7XG4gIGlmIChjb250YWluZXJXaW5kb3cgJiYgZG9tRWxlbWVudCAmJiBjb250YWluZXJXaW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSkge1xuICAgIHJldHVybiBjb250YWluZXJXaW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShkb21FbGVtZW50KS5nZXRQcm9wZXJ0eVZhbHVlKHByb3BOYW1lKTtcbiAgfVxufTtcblxudmFyIHN0eWZuJDUgPSB7fTtcblxuLy8gZ2V0cyB0aGUgcmVuZGVyZWQgc3R5bGUgZm9yIGFuIGVsZW1lbnRcbnN0eWZuJDUuZ2V0UmVuZGVyZWRTdHlsZSA9IGZ1bmN0aW9uIChlbGUsIHByb3ApIHtcbiAgaWYgKHByb3ApIHtcbiAgICByZXR1cm4gdGhpcy5nZXRTdHlsZVByb3BlcnR5VmFsdWUoZWxlLCBwcm9wLCB0cnVlKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdGhpcy5nZXRSYXdTdHlsZShlbGUsIHRydWUpO1xuICB9XG59O1xuXG4vLyBnZXRzIHRoZSByYXcgc3R5bGUgZm9yIGFuIGVsZW1lbnRcbnN0eWZuJDUuZ2V0UmF3U3R5bGUgPSBmdW5jdGlvbiAoZWxlLCBpc1JlbmRlcmVkVmFsKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgZWxlID0gZWxlWzBdOyAvLyBpbnN1cmUgaXQncyBhbiBlbGVtZW50XG5cbiAgaWYgKGVsZSkge1xuICAgIHZhciByc3R5bGUgPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbGYucHJvcGVydGllcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHByb3AgPSBzZWxmLnByb3BlcnRpZXNbaV07XG4gICAgICB2YXIgdmFsID0gc2VsZi5nZXRTdHlsZVByb3BlcnR5VmFsdWUoZWxlLCBwcm9wLm5hbWUsIGlzUmVuZGVyZWRWYWwpO1xuICAgICAgaWYgKHZhbCAhPSBudWxsKSB7XG4gICAgICAgIHJzdHlsZVtwcm9wLm5hbWVdID0gdmFsO1xuICAgICAgICByc3R5bGVbZGFzaDJjYW1lbChwcm9wLm5hbWUpXSA9IHZhbDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJzdHlsZTtcbiAgfVxufTtcbnN0eWZuJDUuZ2V0SW5kZXhlZFN0eWxlID0gZnVuY3Rpb24gKGVsZSwgcHJvcGVydHksIHN1YnByb3BlcnR5LCBpbmRleCkge1xuICB2YXIgcHN0eWxlID0gZWxlLnBzdHlsZShwcm9wZXJ0eSlbc3VicHJvcGVydHldW2luZGV4XTtcbiAgcmV0dXJuIHBzdHlsZSAhPSBudWxsID8gcHN0eWxlIDogZWxlLmN5KCkuc3R5bGUoKS5nZXREZWZhdWx0UHJvcGVydHkocHJvcGVydHkpW3N1YnByb3BlcnR5XVswXTtcbn07XG5zdHlmbiQ1LmdldFN0eWxlUHJvcGVydHlWYWx1ZSA9IGZ1bmN0aW9uIChlbGUsIHByb3BOYW1lLCBpc1JlbmRlcmVkVmFsKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgZWxlID0gZWxlWzBdOyAvLyBpbnN1cmUgaXQncyBhbiBlbGVtZW50XG5cbiAgaWYgKGVsZSkge1xuICAgIHZhciBwcm9wID0gc2VsZi5wcm9wZXJ0aWVzW3Byb3BOYW1lXTtcbiAgICBpZiAocHJvcC5hbGlhcykge1xuICAgICAgcHJvcCA9IHByb3AucG9pbnRzVG87XG4gICAgfVxuICAgIHZhciB0eXBlID0gcHJvcC50eXBlO1xuICAgIHZhciBzdHlsZVByb3AgPSBlbGUucHN0eWxlKHByb3AubmFtZSk7XG4gICAgaWYgKHN0eWxlUHJvcCkge1xuICAgICAgdmFyIHZhbHVlID0gc3R5bGVQcm9wLnZhbHVlLFxuICAgICAgICB1bml0cyA9IHN0eWxlUHJvcC51bml0cyxcbiAgICAgICAgc3RyVmFsdWUgPSBzdHlsZVByb3Auc3RyVmFsdWU7XG4gICAgICBpZiAoaXNSZW5kZXJlZFZhbCAmJiB0eXBlLm51bWJlciAmJiB2YWx1ZSAhPSBudWxsICYmIG51bWJlciQxKHZhbHVlKSkge1xuICAgICAgICB2YXIgem9vbSA9IGVsZS5jeSgpLnpvb20oKTtcbiAgICAgICAgdmFyIGdldFJlbmRlcmVkVmFsdWUgPSBmdW5jdGlvbiBnZXRSZW5kZXJlZFZhbHVlKHZhbCkge1xuICAgICAgICAgIHJldHVybiB2YWwgKiB6b29tO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgZ2V0VmFsdWVTdHJpbmdXaXRoVW5pdHMgPSBmdW5jdGlvbiBnZXRWYWx1ZVN0cmluZ1dpdGhVbml0cyh2YWwsIHVuaXRzKSB7XG4gICAgICAgICAgcmV0dXJuIGdldFJlbmRlcmVkVmFsdWUodmFsKSArIHVuaXRzO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgaXNBcnJheVZhbHVlID0gYXJyYXkodmFsdWUpO1xuICAgICAgICB2YXIgaGF2ZVVuaXRzID0gaXNBcnJheVZhbHVlID8gdW5pdHMuZXZlcnkoZnVuY3Rpb24gKHUpIHtcbiAgICAgICAgICByZXR1cm4gdSAhPSBudWxsO1xuICAgICAgICB9KSA6IHVuaXRzICE9IG51bGw7XG4gICAgICAgIGlmIChoYXZlVW5pdHMpIHtcbiAgICAgICAgICBpZiAoaXNBcnJheVZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUubWFwKGZ1bmN0aW9uICh2LCBpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBnZXRWYWx1ZVN0cmluZ1dpdGhVbml0cyh2LCB1bml0c1tpXSk7XG4gICAgICAgICAgICB9KS5qb2luKCcgJyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRWYWx1ZVN0cmluZ1dpdGhVbml0cyh2YWx1ZSwgdW5pdHMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoaXNBcnJheVZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUubWFwKGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICAgIHJldHVybiBzdHJpbmcodikgPyB2IDogJycgKyBnZXRSZW5kZXJlZFZhbHVlKHYpO1xuICAgICAgICAgICAgfSkuam9pbignICcpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gJycgKyBnZXRSZW5kZXJlZFZhbHVlKHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoc3RyVmFsdWUgIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gc3RyVmFsdWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG59O1xuc3R5Zm4kNS5nZXRBbmltYXRpb25TdGFydFN0eWxlID0gZnVuY3Rpb24gKGVsZSwgYW5pUHJvcHMpIHtcbiAgdmFyIHJzdHlsZSA9IHt9O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFuaVByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGFuaVByb3AgPSBhbmlQcm9wc1tpXTtcbiAgICB2YXIgbmFtZSA9IGFuaVByb3AubmFtZTtcbiAgICB2YXIgc3R5bGVQcm9wID0gZWxlLnBzdHlsZShuYW1lKTtcbiAgICBpZiAoc3R5bGVQcm9wICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIHRoZW4gbWFrZSBhIHByb3Agb2YgaXRcbiAgICAgIGlmIChwbGFpbk9iamVjdChzdHlsZVByb3ApKSB7XG4gICAgICAgIHN0eWxlUHJvcCA9IHRoaXMucGFyc2UobmFtZSwgc3R5bGVQcm9wLnN0clZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0eWxlUHJvcCA9IHRoaXMucGFyc2UobmFtZSwgc3R5bGVQcm9wKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHN0eWxlUHJvcCkge1xuICAgICAgcnN0eWxlW25hbWVdID0gc3R5bGVQcm9wO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcnN0eWxlO1xufTtcbnN0eWZuJDUuZ2V0UHJvcHNMaXN0ID0gZnVuY3Rpb24gKHByb3BzT2JqKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHJzdHlsZSA9IFtdO1xuICB2YXIgc3R5bGUgPSBwcm9wc09iajtcbiAgdmFyIHByb3BzID0gc2VsZi5wcm9wZXJ0aWVzO1xuICBpZiAoc3R5bGUpIHtcbiAgICB2YXIgbmFtZXMgPSBPYmplY3Qua2V5cyhzdHlsZSk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIG5hbWUgPSBuYW1lc1tpXTtcbiAgICAgIHZhciB2YWwgPSBzdHlsZVtuYW1lXTtcbiAgICAgIHZhciBwcm9wID0gcHJvcHNbbmFtZV0gfHwgcHJvcHNbY2FtZWwyZGFzaChuYW1lKV07XG4gICAgICB2YXIgc3R5bGVQcm9wID0gdGhpcy5wYXJzZShwcm9wLm5hbWUsIHZhbCk7XG4gICAgICBpZiAoc3R5bGVQcm9wKSB7XG4gICAgICAgIHJzdHlsZS5wdXNoKHN0eWxlUHJvcCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiByc3R5bGU7XG59O1xuc3R5Zm4kNS5nZXROb25EZWZhdWx0UHJvcGVydGllc0hhc2ggPSBmdW5jdGlvbiAoZWxlLCBwcm9wTmFtZXMsIHNlZWQpIHtcbiAgdmFyIGhhc2ggPSBzZWVkLnNsaWNlKCk7XG4gIHZhciBuYW1lLCB2YWwsIHN0clZhbCwgY2hWYWw7XG4gIHZhciBpLCBqO1xuICBmb3IgKGkgPSAwOyBpIDwgcHJvcE5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgbmFtZSA9IHByb3BOYW1lc1tpXTtcbiAgICB2YWwgPSBlbGUucHN0eWxlKG5hbWUsIGZhbHNlKTtcbiAgICBpZiAodmFsID09IG51bGwpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH0gZWxzZSBpZiAodmFsLnBmVmFsdWUgIT0gbnVsbCkge1xuICAgICAgaGFzaFswXSA9IGhhc2hJbnQoY2hWYWwsIGhhc2hbMF0pO1xuICAgICAgaGFzaFsxXSA9IGhhc2hJbnRBbHQoY2hWYWwsIGhhc2hbMV0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHJWYWwgPSB2YWwuc3RyVmFsdWU7XG4gICAgICBmb3IgKGogPSAwOyBqIDwgc3RyVmFsLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGNoVmFsID0gc3RyVmFsLmNoYXJDb2RlQXQoaik7XG4gICAgICAgIGhhc2hbMF0gPSBoYXNoSW50KGNoVmFsLCBoYXNoWzBdKTtcbiAgICAgICAgaGFzaFsxXSA9IGhhc2hJbnRBbHQoY2hWYWwsIGhhc2hbMV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gaGFzaDtcbn07XG5zdHlmbiQ1LmdldFByb3BlcnRpZXNIYXNoID0gc3R5Zm4kNS5nZXROb25EZWZhdWx0UHJvcGVydGllc0hhc2g7XG5cbnZhciBzdHlmbiQ0ID0ge307XG5zdHlmbiQ0LmFwcGVuZEZyb21Kc29uID0gZnVuY3Rpb24gKGpzb24pIHtcbiAgdmFyIHN0eWxlID0gdGhpcztcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBqc29uLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGNvbnRleHQgPSBqc29uW2ldO1xuICAgIHZhciBzZWxlY3RvciA9IGNvbnRleHQuc2VsZWN0b3I7XG4gICAgdmFyIHByb3BzID0gY29udGV4dC5zdHlsZSB8fCBjb250ZXh0LmNzcztcbiAgICB2YXIgbmFtZXMgPSBPYmplY3Qua2V5cyhwcm9wcyk7XG4gICAgc3R5bGUuc2VsZWN0b3Ioc2VsZWN0b3IpOyAvLyBhcHBseSBzZWxlY3RvclxuXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBuYW1lcy5sZW5ndGg7IGorKykge1xuICAgICAgdmFyIG5hbWUgPSBuYW1lc1tqXTtcbiAgICAgIHZhciB2YWx1ZSA9IHByb3BzW25hbWVdO1xuICAgICAgc3R5bGUuY3NzKG5hbWUsIHZhbHVlKTsgLy8gYXBwbHkgcHJvcGVydHlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3R5bGU7XG59O1xuXG4vLyBhY2Nlc3NpYmxlIGN5LnN0eWxlKCkgZnVuY3Rpb25cbnN0eWZuJDQuZnJvbUpzb24gPSBmdW5jdGlvbiAoanNvbikge1xuICB2YXIgc3R5bGUgPSB0aGlzO1xuICBzdHlsZS5yZXNldFRvRGVmYXVsdCgpO1xuICBzdHlsZS5hcHBlbmRGcm9tSnNvbihqc29uKTtcbiAgcmV0dXJuIHN0eWxlO1xufTtcblxuLy8gZ2V0IGpzb24gZnJvbSBjeS5zdHlsZSgpIGFwaVxuc3R5Zm4kNC5qc29uID0gZnVuY3Rpb24gKCkge1xuICB2YXIganNvbiA9IFtdO1xuICBmb3IgKHZhciBpID0gdGhpcy5kZWZhdWx0TGVuZ3RoOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBjeHQgPSB0aGlzW2ldO1xuICAgIHZhciBzZWxlY3RvciA9IGN4dC5zZWxlY3RvcjtcbiAgICB2YXIgcHJvcHMgPSBjeHQucHJvcGVydGllcztcbiAgICB2YXIgY3NzID0ge307XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBwcm9wcy5sZW5ndGg7IGorKykge1xuICAgICAgdmFyIHByb3AgPSBwcm9wc1tqXTtcbiAgICAgIGNzc1twcm9wLm5hbWVdID0gcHJvcC5zdHJWYWx1ZTtcbiAgICB9XG4gICAganNvbi5wdXNoKHtcbiAgICAgIHNlbGVjdG9yOiAhc2VsZWN0b3IgPyAnY29yZScgOiBzZWxlY3Rvci50b1N0cmluZygpLFxuICAgICAgc3R5bGU6IGNzc1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBqc29uO1xufTtcblxudmFyIHN0eWZuJDMgPSB7fTtcbnN0eWZuJDMuYXBwZW5kRnJvbVN0cmluZyA9IGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgc3R5bGUgPSB0aGlzO1xuICB2YXIgcmVtYWluaW5nID0gJycgKyBzdHJpbmc7XG4gIHZhciBzZWxBbmRCbG9ja1N0cjtcbiAgdmFyIGJsb2NrUmVtO1xuICB2YXIgcHJvcEFuZFZhbFN0cjtcblxuICAvLyByZW1vdmUgY29tbWVudHMgZnJvbSB0aGUgc3R5bGUgc3RyaW5nXG4gIHJlbWFpbmluZyA9IHJlbWFpbmluZy5yZXBsYWNlKC9bL11bKl0oXFxzfC4pKz9bKl1bL10vZywgJycpO1xuICBmdW5jdGlvbiByZW1vdmVTZWxBbmRCbG9ja0Zyb21SZW1haW5pbmcoKSB7XG4gICAgLy8gcmVtb3ZlIHRoZSBwYXJzZWQgc2VsZWN0b3IgYW5kIGJsb2NrIGZyb20gdGhlIHJlbWFpbmluZyB0ZXh0IHRvIHBhcnNlXG4gICAgaWYgKHJlbWFpbmluZy5sZW5ndGggPiBzZWxBbmRCbG9ja1N0ci5sZW5ndGgpIHtcbiAgICAgIHJlbWFpbmluZyA9IHJlbWFpbmluZy5zdWJzdHIoc2VsQW5kQmxvY2tTdHIubGVuZ3RoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVtYWluaW5nID0gJyc7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHJlbW92ZVByb3BBbmRWYWxGcm9tUmVtKCkge1xuICAgIC8vIHJlbW92ZSB0aGUgcGFyc2VkIHByb3BlcnR5IGFuZCB2YWx1ZSBmcm9tIHRoZSByZW1haW5pbmcgYmxvY2sgdGV4dCB0byBwYXJzZVxuICAgIGlmIChibG9ja1JlbS5sZW5ndGggPiBwcm9wQW5kVmFsU3RyLmxlbmd0aCkge1xuICAgICAgYmxvY2tSZW0gPSBibG9ja1JlbS5zdWJzdHIocHJvcEFuZFZhbFN0ci5sZW5ndGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBibG9ja1JlbSA9ICcnO1xuICAgIH1cbiAgfVxuICBmb3IgKDs7KSB7XG4gICAgdmFyIG5vdGhpbmdMZWZ0VG9QYXJzZSA9IHJlbWFpbmluZy5tYXRjaCgvXlxccyokLyk7XG4gICAgaWYgKG5vdGhpbmdMZWZ0VG9QYXJzZSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHZhciBzZWxBbmRCbG9jayA9IHJlbWFpbmluZy5tYXRjaCgvXlxccyooKD86LnxcXHMpKz8pXFxzKlxceygoPzoufFxccykrPylcXH0vKTtcbiAgICBpZiAoIXNlbEFuZEJsb2NrKSB7XG4gICAgICB3YXJuKCdIYWx0aW5nIHN0eWxlc2hlZXQgcGFyc2luZzogU3RyaW5nIHN0eWxlc2hlZXQgY29udGFpbnMgbW9yZSB0byBwYXJzZSBidXQgbm8gc2VsZWN0b3IgYW5kIGJsb2NrIGZvdW5kIGluOiAnICsgcmVtYWluaW5nKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBzZWxBbmRCbG9ja1N0ciA9IHNlbEFuZEJsb2NrWzBdO1xuXG4gICAgLy8gcGFyc2UgdGhlIHNlbGVjdG9yXG4gICAgdmFyIHNlbGVjdG9yU3RyID0gc2VsQW5kQmxvY2tbMV07XG4gICAgaWYgKHNlbGVjdG9yU3RyICE9PSAnY29yZScpIHtcbiAgICAgIHZhciBzZWxlY3RvciA9IG5ldyBTZWxlY3RvcihzZWxlY3RvclN0cik7XG4gICAgICBpZiAoc2VsZWN0b3IuaW52YWxpZCkge1xuICAgICAgICB3YXJuKCdTa2lwcGluZyBwYXJzaW5nIG9mIGJsb2NrOiBJbnZhbGlkIHNlbGVjdG9yIGZvdW5kIGluIHN0cmluZyBzdHlsZXNoZWV0OiAnICsgc2VsZWN0b3JTdHIpO1xuXG4gICAgICAgIC8vIHNraXAgdGhpcyBzZWxlY3RvciBhbmQgYmxvY2tcbiAgICAgICAgcmVtb3ZlU2VsQW5kQmxvY2tGcm9tUmVtYWluaW5nKCk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHBhcnNlIHRoZSBibG9jayBvZiBwcm9wZXJ0aWVzIGFuZCB2YWx1ZXNcbiAgICB2YXIgYmxvY2tTdHIgPSBzZWxBbmRCbG9ja1syXTtcbiAgICB2YXIgaW52YWxpZEJsb2NrID0gZmFsc2U7XG4gICAgYmxvY2tSZW0gPSBibG9ja1N0cjtcbiAgICB2YXIgcHJvcHMgPSBbXTtcbiAgICBmb3IgKDs7KSB7XG4gICAgICB2YXIgX25vdGhpbmdMZWZ0VG9QYXJzZSA9IGJsb2NrUmVtLm1hdGNoKC9eXFxzKiQvKTtcbiAgICAgIGlmIChfbm90aGluZ0xlZnRUb1BhcnNlKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgdmFyIHByb3BBbmRWYWwgPSBibG9ja1JlbS5tYXRjaCgvXlxccyooLis/KVxccyo6XFxzKiguKz8pKD86XFxzKjt8XFxzKiQpLyk7XG4gICAgICBpZiAoIXByb3BBbmRWYWwpIHtcbiAgICAgICAgd2FybignU2tpcHBpbmcgcGFyc2luZyBvZiBibG9jazogSW52YWxpZCBmb3JtYXR0aW5nIG9mIHN0eWxlIHByb3BlcnR5IGFuZCB2YWx1ZSBkZWZpbml0aW9ucyBmb3VuZCBpbjonICsgYmxvY2tTdHIpO1xuICAgICAgICBpbnZhbGlkQmxvY2sgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHByb3BBbmRWYWxTdHIgPSBwcm9wQW5kVmFsWzBdO1xuICAgICAgdmFyIHByb3BTdHIgPSBwcm9wQW5kVmFsWzFdO1xuICAgICAgdmFyIHZhbFN0ciA9IHByb3BBbmRWYWxbMl07XG4gICAgICB2YXIgcHJvcCA9IHNlbGYucHJvcGVydGllc1twcm9wU3RyXTtcbiAgICAgIGlmICghcHJvcCkge1xuICAgICAgICB3YXJuKCdTa2lwcGluZyBwcm9wZXJ0eTogSW52YWxpZCBwcm9wZXJ0eSBuYW1lIGluOiAnICsgcHJvcEFuZFZhbFN0cik7XG5cbiAgICAgICAgLy8gc2tpcCB0aGlzIHByb3BlcnR5IGluIHRoZSBibG9ja1xuICAgICAgICByZW1vdmVQcm9wQW5kVmFsRnJvbVJlbSgpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHZhciBwYXJzZWRQcm9wID0gc3R5bGUucGFyc2UocHJvcFN0ciwgdmFsU3RyKTtcbiAgICAgIGlmICghcGFyc2VkUHJvcCkge1xuICAgICAgICB3YXJuKCdTa2lwcGluZyBwcm9wZXJ0eTogSW52YWxpZCBwcm9wZXJ0eSBkZWZpbml0aW9uIGluOiAnICsgcHJvcEFuZFZhbFN0cik7XG5cbiAgICAgICAgLy8gc2tpcCB0aGlzIHByb3BlcnR5IGluIHRoZSBibG9ja1xuICAgICAgICByZW1vdmVQcm9wQW5kVmFsRnJvbVJlbSgpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHByb3BzLnB1c2goe1xuICAgICAgICBuYW1lOiBwcm9wU3RyLFxuICAgICAgICB2YWw6IHZhbFN0clxuICAgICAgfSk7XG4gICAgICByZW1vdmVQcm9wQW5kVmFsRnJvbVJlbSgpO1xuICAgIH1cbiAgICBpZiAoaW52YWxpZEJsb2NrKSB7XG4gICAgICByZW1vdmVTZWxBbmRCbG9ja0Zyb21SZW1haW5pbmcoKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIC8vIHB1dCB0aGUgcGFyc2VkIGJsb2NrIGluIHRoZSBzdHlsZVxuICAgIHN0eWxlLnNlbGVjdG9yKHNlbGVjdG9yU3RyKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgX3Byb3AgPSBwcm9wc1tpXTtcbiAgICAgIHN0eWxlLmNzcyhfcHJvcC5uYW1lLCBfcHJvcC52YWwpO1xuICAgIH1cbiAgICByZW1vdmVTZWxBbmRCbG9ja0Zyb21SZW1haW5pbmcoKTtcbiAgfVxuICByZXR1cm4gc3R5bGU7XG59O1xuc3R5Zm4kMy5mcm9tU3RyaW5nID0gZnVuY3Rpb24gKHN0cmluZykge1xuICB2YXIgc3R5bGUgPSB0aGlzO1xuICBzdHlsZS5yZXNldFRvRGVmYXVsdCgpO1xuICBzdHlsZS5hcHBlbmRGcm9tU3RyaW5nKHN0cmluZyk7XG4gIHJldHVybiBzdHlsZTtcbn07XG5cbnZhciBzdHlmbiQyID0ge307XG4oZnVuY3Rpb24gKCkge1xuICB2YXIgbnVtYmVyJDEgPSBudW1iZXI7XG4gIHZhciByZ2JhID0gcmdiYU5vQmFja1JlZnM7XG4gIHZhciBoc2xhID0gaHNsYU5vQmFja1JlZnM7XG4gIHZhciBoZXgzJDEgPSBoZXgzO1xuICB2YXIgaGV4NiQxID0gaGV4NjtcbiAgdmFyIGRhdGEgPSBmdW5jdGlvbiBkYXRhKHByZWZpeCkge1xuICAgIHJldHVybiAnXicgKyBwcmVmaXggKyAnXFxcXHMqXFxcXChcXFxccyooW1xcXFx3XFxcXC5dKylcXFxccypcXFxcKSQnO1xuICB9O1xuICB2YXIgbWFwRGF0YSA9IGZ1bmN0aW9uIG1hcERhdGEocHJlZml4KSB7XG4gICAgdmFyIG1hcEFyZyA9IG51bWJlciQxICsgJ3xcXFxcdyt8JyArIHJnYmEgKyAnfCcgKyBoc2xhICsgJ3wnICsgaGV4MyQxICsgJ3wnICsgaGV4NiQxO1xuICAgIHJldHVybiAnXicgKyBwcmVmaXggKyAnXFxcXHMqXFxcXCgoW1xcXFx3XFxcXC5dKylcXFxccypcXFxcLFxcXFxzKignICsgbnVtYmVyJDEgKyAnKVxcXFxzKlxcXFwsXFxcXHMqKCcgKyBudW1iZXIkMSArICcpXFxcXHMqLFxcXFxzKignICsgbWFwQXJnICsgJylcXFxccypcXFxcLFxcXFxzKignICsgbWFwQXJnICsgJylcXFxcKSQnO1xuICB9O1xuICB2YXIgdXJsUmVnZXhlcyA9IFsnXnVybFxcXFxzKlxcXFwoXFxcXHMqW1xcJ1wiXT8oLis/KVtcXCdcIl0/XFxcXHMqXFxcXCkkJywgJ14obm9uZSkkJywgJ14oLispJCddO1xuXG4gIC8vIGVhY2ggdmlzdWFsIHN0eWxlIHByb3BlcnR5IGhhcyBhIHR5cGUgYW5kIG5lZWRzIHRvIGJlIHZhbGlkYXRlZCBhY2NvcmRpbmcgdG8gaXRcbiAgc3R5Zm4kMi50eXBlcyA9IHtcbiAgICB0aW1lOiB7XG4gICAgICBudW1iZXI6IHRydWUsXG4gICAgICBtaW46IDAsXG4gICAgICB1bml0czogJ3N8bXMnLFxuICAgICAgaW1wbGljaXRVbml0czogJ21zJ1xuICAgIH0sXG4gICAgcGVyY2VudDoge1xuICAgICAgbnVtYmVyOiB0cnVlLFxuICAgICAgbWluOiAwLFxuICAgICAgbWF4OiAxMDAsXG4gICAgICB1bml0czogJyUnLFxuICAgICAgaW1wbGljaXRVbml0czogJyUnXG4gICAgfSxcbiAgICBwZXJjZW50YWdlczoge1xuICAgICAgbnVtYmVyOiB0cnVlLFxuICAgICAgbWluOiAwLFxuICAgICAgbWF4OiAxMDAsXG4gICAgICB1bml0czogJyUnLFxuICAgICAgaW1wbGljaXRVbml0czogJyUnLFxuICAgICAgbXVsdGlwbGU6IHRydWVcbiAgICB9LFxuICAgIHplcm9PbmVOdW1iZXI6IHtcbiAgICAgIG51bWJlcjogdHJ1ZSxcbiAgICAgIG1pbjogMCxcbiAgICAgIG1heDogMSxcbiAgICAgIHVuaXRsZXNzOiB0cnVlXG4gICAgfSxcbiAgICB6ZXJvT25lTnVtYmVyczoge1xuICAgICAgbnVtYmVyOiB0cnVlLFxuICAgICAgbWluOiAwLFxuICAgICAgbWF4OiAxLFxuICAgICAgdW5pdGxlc3M6IHRydWUsXG4gICAgICBtdWx0aXBsZTogdHJ1ZVxuICAgIH0sXG4gICAgbk9uZU9uZU51bWJlcjoge1xuICAgICAgbnVtYmVyOiB0cnVlLFxuICAgICAgbWluOiAtMSxcbiAgICAgIG1heDogMSxcbiAgICAgIHVuaXRsZXNzOiB0cnVlXG4gICAgfSxcbiAgICBub25OZWdhdGl2ZUludDoge1xuICAgICAgbnVtYmVyOiB0cnVlLFxuICAgICAgbWluOiAwLFxuICAgICAgaW50ZWdlcjogdHJ1ZSxcbiAgICAgIHVuaXRsZXNzOiB0cnVlXG4gICAgfSxcbiAgICBub25OZWdhdGl2ZU51bWJlcjoge1xuICAgICAgbnVtYmVyOiB0cnVlLFxuICAgICAgbWluOiAwLFxuICAgICAgdW5pdGxlc3M6IHRydWVcbiAgICB9LFxuICAgIHBvc2l0aW9uOiB7XG4gICAgICBlbnVtczogWydwYXJlbnQnLCAnb3JpZ2luJ11cbiAgICB9LFxuICAgIG5vZGVTaXplOiB7XG4gICAgICBudW1iZXI6IHRydWUsXG4gICAgICBtaW46IDAsXG4gICAgICBlbnVtczogWydsYWJlbCddXG4gICAgfSxcbiAgICBudW1iZXI6IHtcbiAgICAgIG51bWJlcjogdHJ1ZSxcbiAgICAgIHVuaXRsZXNzOiB0cnVlXG4gICAgfSxcbiAgICBudW1iZXJzOiB7XG4gICAgICBudW1iZXI6IHRydWUsXG4gICAgICB1bml0bGVzczogdHJ1ZSxcbiAgICAgIG11bHRpcGxlOiB0cnVlXG4gICAgfSxcbiAgICBwb3NpdGl2ZU51bWJlcjoge1xuICAgICAgbnVtYmVyOiB0cnVlLFxuICAgICAgdW5pdGxlc3M6IHRydWUsXG4gICAgICBtaW46IDAsXG4gICAgICBzdHJpY3RNaW46IHRydWVcbiAgICB9LFxuICAgIHNpemU6IHtcbiAgICAgIG51bWJlcjogdHJ1ZSxcbiAgICAgIG1pbjogMFxuICAgIH0sXG4gICAgYmlkaXJlY3Rpb25hbFNpemU6IHtcbiAgICAgIG51bWJlcjogdHJ1ZVxuICAgIH0sXG4gICAgLy8gYWxsb3dzIG5lZ2F0aXZlXG4gICAgYmlkaXJlY3Rpb25hbFNpemVNYXliZVBlcmNlbnQ6IHtcbiAgICAgIG51bWJlcjogdHJ1ZSxcbiAgICAgIGFsbG93UGVyY2VudDogdHJ1ZVxuICAgIH0sXG4gICAgLy8gYWxsb3dzIG5lZ2F0aXZlXG4gICAgYmlkaXJlY3Rpb25hbFNpemVzOiB7XG4gICAgICBudW1iZXI6IHRydWUsXG4gICAgICBtdWx0aXBsZTogdHJ1ZVxuICAgIH0sXG4gICAgLy8gYWxsb3dzIG5lZ2F0aXZlXG4gICAgc2l6ZU1heWJlUGVyY2VudDoge1xuICAgICAgbnVtYmVyOiB0cnVlLFxuICAgICAgbWluOiAwLFxuICAgICAgYWxsb3dQZXJjZW50OiB0cnVlXG4gICAgfSxcbiAgICBheGlzRGlyZWN0aW9uOiB7XG4gICAgICBlbnVtczogWydob3Jpem9udGFsJywgJ2xlZnR3YXJkJywgJ3JpZ2h0d2FyZCcsICd2ZXJ0aWNhbCcsICd1cHdhcmQnLCAnZG93bndhcmQnLCAnYXV0byddXG4gICAgfSxcbiAgICBwYWRkaW5nUmVsYXRpdmVUbzoge1xuICAgICAgZW51bXM6IFsnd2lkdGgnLCAnaGVpZ2h0JywgJ2F2ZXJhZ2UnLCAnbWluJywgJ21heCddXG4gICAgfSxcbiAgICBiZ1dIOiB7XG4gICAgICBudW1iZXI6IHRydWUsXG4gICAgICBtaW46IDAsXG4gICAgICBhbGxvd1BlcmNlbnQ6IHRydWUsXG4gICAgICBlbnVtczogWydhdXRvJ10sXG4gICAgICBtdWx0aXBsZTogdHJ1ZVxuICAgIH0sXG4gICAgYmdQb3M6IHtcbiAgICAgIG51bWJlcjogdHJ1ZSxcbiAgICAgIGFsbG93UGVyY2VudDogdHJ1ZSxcbiAgICAgIG11bHRpcGxlOiB0cnVlXG4gICAgfSxcbiAgICBiZ1JlbGF0aXZlVG86IHtcbiAgICAgIGVudW1zOiBbJ2lubmVyJywgJ2luY2x1ZGUtcGFkZGluZyddLFxuICAgICAgbXVsdGlwbGU6IHRydWVcbiAgICB9LFxuICAgIGJnUmVwZWF0OiB7XG4gICAgICBlbnVtczogWydyZXBlYXQnLCAncmVwZWF0LXgnLCAncmVwZWF0LXknLCAnbm8tcmVwZWF0J10sXG4gICAgICBtdWx0aXBsZTogdHJ1ZVxuICAgIH0sXG4gICAgYmdGaXQ6IHtcbiAgICAgIGVudW1zOiBbJ25vbmUnLCAnY29udGFpbicsICdjb3ZlciddLFxuICAgICAgbXVsdGlwbGU6IHRydWVcbiAgICB9LFxuICAgIGJnQ3Jvc3NPcmlnaW46IHtcbiAgICAgIGVudW1zOiBbJ2Fub255bW91cycsICd1c2UtY3JlZGVudGlhbHMnLCAnbnVsbCddLFxuICAgICAgbXVsdGlwbGU6IHRydWVcbiAgICB9LFxuICAgIGJnQ2xpcDoge1xuICAgICAgZW51bXM6IFsnbm9uZScsICdub2RlJ10sXG4gICAgICBtdWx0aXBsZTogdHJ1ZVxuICAgIH0sXG4gICAgYmdDb250YWlubWVudDoge1xuICAgICAgZW51bXM6IFsnaW5zaWRlJywgJ292ZXInXSxcbiAgICAgIG11bHRpcGxlOiB0cnVlXG4gICAgfSxcbiAgICBjb2xvcjoge1xuICAgICAgY29sb3I6IHRydWVcbiAgICB9LFxuICAgIGNvbG9yczoge1xuICAgICAgY29sb3I6IHRydWUsXG4gICAgICBtdWx0aXBsZTogdHJ1ZVxuICAgIH0sXG4gICAgZmlsbDoge1xuICAgICAgZW51bXM6IFsnc29saWQnLCAnbGluZWFyLWdyYWRpZW50JywgJ3JhZGlhbC1ncmFkaWVudCddXG4gICAgfSxcbiAgICBib29sOiB7XG4gICAgICBlbnVtczogWyd5ZXMnLCAnbm8nXVxuICAgIH0sXG4gICAgYm9vbHM6IHtcbiAgICAgIGVudW1zOiBbJ3llcycsICdubyddLFxuICAgICAgbXVsdGlwbGU6IHRydWVcbiAgICB9LFxuICAgIGxpbmVTdHlsZToge1xuICAgICAgZW51bXM6IFsnc29saWQnLCAnZG90dGVkJywgJ2Rhc2hlZCddXG4gICAgfSxcbiAgICBsaW5lQ2FwOiB7XG4gICAgICBlbnVtczogWydidXR0JywgJ3JvdW5kJywgJ3NxdWFyZSddXG4gICAgfSxcbiAgICBsaW5lUG9zaXRpb246IHtcbiAgICAgIGVudW1zOiBbJ2NlbnRlcicsICdpbnNpZGUnLCAnb3V0c2lkZSddXG4gICAgfSxcbiAgICBsaW5lSm9pbjoge1xuICAgICAgZW51bXM6IFsncm91bmQnLCAnYmV2ZWwnLCAnbWl0ZXInXVxuICAgIH0sXG4gICAgYm9yZGVyU3R5bGU6IHtcbiAgICAgIGVudW1zOiBbJ3NvbGlkJywgJ2RvdHRlZCcsICdkYXNoZWQnLCAnZG91YmxlJ11cbiAgICB9LFxuICAgIGN1cnZlU3R5bGU6IHtcbiAgICAgIGVudW1zOiBbJ2JlemllcicsICd1bmJ1bmRsZWQtYmV6aWVyJywgJ2hheXN0YWNrJywgJ3NlZ21lbnRzJywgJ3N0cmFpZ2h0JywgJ3N0cmFpZ2h0LXRyaWFuZ2xlJywgJ3RheGknLCAncm91bmQtc2VnbWVudHMnLCAncm91bmQtdGF4aSddXG4gICAgfSxcbiAgICByYWRpdXNUeXBlOiB7XG4gICAgICBlbnVtczogWydhcmMtcmFkaXVzJywgJ2luZmx1ZW5jZS1yYWRpdXMnXSxcbiAgICAgIG11bHRpcGxlOiB0cnVlXG4gICAgfSxcbiAgICBmb250RmFtaWx5OiB7XG4gICAgICByZWdleDogJ14oW1xcXFx3LSBcXFxcXCJdKyg/OlxcXFxzKixcXFxccypbXFxcXHctIFxcXFxcIl0rKSopJCdcbiAgICB9LFxuICAgIGZvbnRTdHlsZToge1xuICAgICAgZW51bXM6IFsnaXRhbGljJywgJ25vcm1hbCcsICdvYmxpcXVlJ11cbiAgICB9LFxuICAgIGZvbnRXZWlnaHQ6IHtcbiAgICAgIGVudW1zOiBbJ25vcm1hbCcsICdib2xkJywgJ2JvbGRlcicsICdsaWdodGVyJywgJzEwMCcsICcyMDAnLCAnMzAwJywgJzQwMCcsICc1MDAnLCAnNjAwJywgJzgwMCcsICc5MDAnLCAxMDAsIDIwMCwgMzAwLCA0MDAsIDUwMCwgNjAwLCA3MDAsIDgwMCwgOTAwXVxuICAgIH0sXG4gICAgdGV4dERlY29yYXRpb246IHtcbiAgICAgIGVudW1zOiBbJ25vbmUnLCAndW5kZXJsaW5lJywgJ292ZXJsaW5lJywgJ2xpbmUtdGhyb3VnaCddXG4gICAgfSxcbiAgICB0ZXh0VHJhbnNmb3JtOiB7XG4gICAgICBlbnVtczogWydub25lJywgJ3VwcGVyY2FzZScsICdsb3dlcmNhc2UnXVxuICAgIH0sXG4gICAgdGV4dFdyYXA6IHtcbiAgICAgIGVudW1zOiBbJ25vbmUnLCAnd3JhcCcsICdlbGxpcHNpcyddXG4gICAgfSxcbiAgICB0ZXh0T3ZlcmZsb3dXcmFwOiB7XG4gICAgICBlbnVtczogWyd3aGl0ZXNwYWNlJywgJ2FueXdoZXJlJ11cbiAgICB9LFxuICAgIHRleHRCYWNrZ3JvdW5kU2hhcGU6IHtcbiAgICAgIGVudW1zOiBbJ3JlY3RhbmdsZScsICdyb3VuZHJlY3RhbmdsZScsICdyb3VuZC1yZWN0YW5nbGUnXVxuICAgIH0sXG4gICAgbm9kZVNoYXBlOiB7XG4gICAgICBlbnVtczogWydyZWN0YW5nbGUnLCAncm91bmRyZWN0YW5nbGUnLCAncm91bmQtcmVjdGFuZ2xlJywgJ2N1dHJlY3RhbmdsZScsICdjdXQtcmVjdGFuZ2xlJywgJ2JvdHRvbXJvdW5kcmVjdGFuZ2xlJywgJ2JvdHRvbS1yb3VuZC1yZWN0YW5nbGUnLCAnYmFycmVsJywgJ2VsbGlwc2UnLCAndHJpYW5nbGUnLCAncm91bmQtdHJpYW5nbGUnLCAnc3F1YXJlJywgJ3BlbnRhZ29uJywgJ3JvdW5kLXBlbnRhZ29uJywgJ2hleGFnb24nLCAncm91bmQtaGV4YWdvbicsICdjb25jYXZlaGV4YWdvbicsICdjb25jYXZlLWhleGFnb24nLCAnaGVwdGFnb24nLCAncm91bmQtaGVwdGFnb24nLCAnb2N0YWdvbicsICdyb3VuZC1vY3RhZ29uJywgJ3RhZycsICdyb3VuZC10YWcnLCAnc3RhcicsICdkaWFtb25kJywgJ3JvdW5kLWRpYW1vbmQnLCAndmVlJywgJ3Job21ib2lkJywgJ3JpZ2h0LXJob21ib2lkJywgJ3BvbHlnb24nXVxuICAgIH0sXG4gICAgb3ZlcmxheVNoYXBlOiB7XG4gICAgICBlbnVtczogWydyb3VuZHJlY3RhbmdsZScsICdyb3VuZC1yZWN0YW5nbGUnLCAnZWxsaXBzZSddXG4gICAgfSxcbiAgICBjb3JuZXJSYWRpdXM6IHtcbiAgICAgIG51bWJlcjogdHJ1ZSxcbiAgICAgIG1pbjogMCxcbiAgICAgIHVuaXRzOiAncHh8ZW0nLFxuICAgICAgaW1wbGljaXRVbml0czogJ3B4JyxcbiAgICAgIGVudW1zOiBbJ2F1dG8nXVxuICAgIH0sXG4gICAgY29tcG91bmRJbmNsdWRlTGFiZWxzOiB7XG4gICAgICBlbnVtczogWydpbmNsdWRlJywgJ2V4Y2x1ZGUnXVxuICAgIH0sXG4gICAgYXJyb3dTaGFwZToge1xuICAgICAgZW51bXM6IFsndGVlJywgJ3RyaWFuZ2xlJywgJ3RyaWFuZ2xlLXRlZScsICdjaXJjbGUtdHJpYW5nbGUnLCAndHJpYW5nbGUtY3Jvc3MnLCAndHJpYW5nbGUtYmFja2N1cnZlJywgJ3ZlZScsICdzcXVhcmUnLCAnY2lyY2xlJywgJ2RpYW1vbmQnLCAnY2hldnJvbicsICdub25lJ11cbiAgICB9LFxuICAgIGFycm93RmlsbDoge1xuICAgICAgZW51bXM6IFsnZmlsbGVkJywgJ2hvbGxvdyddXG4gICAgfSxcbiAgICBhcnJvd1dpZHRoOiB7XG4gICAgICBudW1iZXI6IHRydWUsXG4gICAgICB1bml0czogJyV8cHh8ZW0nLFxuICAgICAgaW1wbGljaXRVbml0czogJ3B4JyxcbiAgICAgIGVudW1zOiBbJ21hdGNoLWxpbmUnXVxuICAgIH0sXG4gICAgZGlzcGxheToge1xuICAgICAgZW51bXM6IFsnZWxlbWVudCcsICdub25lJ11cbiAgICB9LFxuICAgIHZpc2liaWxpdHk6IHtcbiAgICAgIGVudW1zOiBbJ2hpZGRlbicsICd2aXNpYmxlJ11cbiAgICB9LFxuICAgIHpDb21wb3VuZERlcHRoOiB7XG4gICAgICBlbnVtczogWydib3R0b20nLCAnb3JwaGFuJywgJ2F1dG8nLCAndG9wJ11cbiAgICB9LFxuICAgIHpJbmRleENvbXBhcmU6IHtcbiAgICAgIGVudW1zOiBbJ2F1dG8nLCAnbWFudWFsJ11cbiAgICB9LFxuICAgIHZhbGlnbjoge1xuICAgICAgZW51bXM6IFsndG9wJywgJ2NlbnRlcicsICdib3R0b20nXVxuICAgIH0sXG4gICAgaGFsaWduOiB7XG4gICAgICBlbnVtczogWydsZWZ0JywgJ2NlbnRlcicsICdyaWdodCddXG4gICAgfSxcbiAgICBqdXN0aWZpY2F0aW9uOiB7XG4gICAgICBlbnVtczogWydsZWZ0JywgJ2NlbnRlcicsICdyaWdodCcsICdhdXRvJ11cbiAgICB9LFxuICAgIHRleHQ6IHtcbiAgICAgIHN0cmluZzogdHJ1ZVxuICAgIH0sXG4gICAgZGF0YToge1xuICAgICAgbWFwcGluZzogdHJ1ZSxcbiAgICAgIHJlZ2V4OiBkYXRhKCdkYXRhJylcbiAgICB9LFxuICAgIGxheW91dERhdGE6IHtcbiAgICAgIG1hcHBpbmc6IHRydWUsXG4gICAgICByZWdleDogZGF0YSgnbGF5b3V0RGF0YScpXG4gICAgfSxcbiAgICBzY3JhdGNoOiB7XG4gICAgICBtYXBwaW5nOiB0cnVlLFxuICAgICAgcmVnZXg6IGRhdGEoJ3NjcmF0Y2gnKVxuICAgIH0sXG4gICAgbWFwRGF0YToge1xuICAgICAgbWFwcGluZzogdHJ1ZSxcbiAgICAgIHJlZ2V4OiBtYXBEYXRhKCdtYXBEYXRhJylcbiAgICB9LFxuICAgIG1hcExheW91dERhdGE6IHtcbiAgICAgIG1hcHBpbmc6IHRydWUsXG4gICAgICByZWdleDogbWFwRGF0YSgnbWFwTGF5b3V0RGF0YScpXG4gICAgfSxcbiAgICBtYXBTY3JhdGNoOiB7XG4gICAgICBtYXBwaW5nOiB0cnVlLFxuICAgICAgcmVnZXg6IG1hcERhdGEoJ21hcFNjcmF0Y2gnKVxuICAgIH0sXG4gICAgZm46IHtcbiAgICAgIG1hcHBpbmc6IHRydWUsXG4gICAgICBmbjogdHJ1ZVxuICAgIH0sXG4gICAgdXJsOiB7XG4gICAgICByZWdleGVzOiB1cmxSZWdleGVzLFxuICAgICAgc2luZ2xlUmVnZXhNYXRjaFZhbHVlOiB0cnVlXG4gICAgfSxcbiAgICB1cmxzOiB7XG4gICAgICByZWdleGVzOiB1cmxSZWdleGVzLFxuICAgICAgc2luZ2xlUmVnZXhNYXRjaFZhbHVlOiB0cnVlLFxuICAgICAgbXVsdGlwbGU6IHRydWVcbiAgICB9LFxuICAgIHByb3BMaXN0OiB7XG4gICAgICBwcm9wTGlzdDogdHJ1ZVxuICAgIH0sXG4gICAgYW5nbGU6IHtcbiAgICAgIG51bWJlcjogdHJ1ZSxcbiAgICAgIHVuaXRzOiAnZGVnfHJhZCcsXG4gICAgICBpbXBsaWNpdFVuaXRzOiAncmFkJ1xuICAgIH0sXG4gICAgdGV4dFJvdGF0aW9uOiB7XG4gICAgICBudW1iZXI6IHRydWUsXG4gICAgICB1bml0czogJ2RlZ3xyYWQnLFxuICAgICAgaW1wbGljaXRVbml0czogJ3JhZCcsXG4gICAgICBlbnVtczogWydub25lJywgJ2F1dG9yb3RhdGUnXVxuICAgIH0sXG4gICAgcG9seWdvblBvaW50TGlzdDoge1xuICAgICAgbnVtYmVyOiB0cnVlLFxuICAgICAgbXVsdGlwbGU6IHRydWUsXG4gICAgICBldmVuTXVsdGlwbGU6IHRydWUsXG4gICAgICBtaW46IC0xLFxuICAgICAgbWF4OiAxLFxuICAgICAgdW5pdGxlc3M6IHRydWVcbiAgICB9LFxuICAgIGVkZ2VEaXN0YW5jZXM6IHtcbiAgICAgIGVudW1zOiBbJ2ludGVyc2VjdGlvbicsICdub2RlLXBvc2l0aW9uJywgJ2VuZHBvaW50cyddXG4gICAgfSxcbiAgICBlZGdlRW5kcG9pbnQ6IHtcbiAgICAgIG51bWJlcjogdHJ1ZSxcbiAgICAgIG11bHRpcGxlOiB0cnVlLFxuICAgICAgdW5pdHM6ICclfHB4fGVtfGRlZ3xyYWQnLFxuICAgICAgaW1wbGljaXRVbml0czogJ3B4JyxcbiAgICAgIGVudW1zOiBbJ2luc2lkZS10by1ub2RlJywgJ291dHNpZGUtdG8tbm9kZScsICdvdXRzaWRlLXRvLW5vZGUtb3ItbGFiZWwnLCAnb3V0c2lkZS10by1saW5lJywgJ291dHNpZGUtdG8tbGluZS1vci1sYWJlbCddLFxuICAgICAgc2luZ2xlRW51bTogdHJ1ZSxcbiAgICAgIHZhbGlkYXRlOiBmdW5jdGlvbiB2YWxpZGF0ZSh2YWxBcnIsIHVuaXRzQXJyKSB7XG4gICAgICAgIHN3aXRjaCAodmFsQXJyLmxlbmd0aCkge1xuICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIC8vIGNhbiBiZSAlIG9yIHB4IG9ubHlcbiAgICAgICAgICAgIHJldHVybiB1bml0c0FyclswXSAhPT0gJ2RlZycgJiYgdW5pdHNBcnJbMF0gIT09ICdyYWQnICYmIHVuaXRzQXJyWzFdICE9PSAnZGVnJyAmJiB1bml0c0FyclsxXSAhPT0gJ3JhZCc7XG4gICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgLy8gY2FuIGJlIGVudW0sIGRlZywgb3IgcmFkIG9ubHlcbiAgICAgICAgICAgIHJldHVybiBzdHJpbmcodmFsQXJyWzBdKSB8fCB1bml0c0FyclswXSA9PT0gJ2RlZycgfHwgdW5pdHNBcnJbMF0gPT09ICdyYWQnO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGVhc2luZzoge1xuICAgICAgcmVnZXhlczogWydeKHNwcmluZylcXFxccypcXFxcKFxcXFxzKignICsgbnVtYmVyJDEgKyAnKVxcXFxzKixcXFxccyooJyArIG51bWJlciQxICsgJylcXFxccypcXFxcKSQnLCAnXihjdWJpYy1iZXppZXIpXFxcXHMqXFxcXChcXFxccyooJyArIG51bWJlciQxICsgJylcXFxccyosXFxcXHMqKCcgKyBudW1iZXIkMSArICcpXFxcXHMqLFxcXFxzKignICsgbnVtYmVyJDEgKyAnKVxcXFxzKixcXFxccyooJyArIG51bWJlciQxICsgJylcXFxccypcXFxcKSQnXSxcbiAgICAgIGVudW1zOiBbJ2xpbmVhcicsICdlYXNlJywgJ2Vhc2UtaW4nLCAnZWFzZS1vdXQnLCAnZWFzZS1pbi1vdXQnLCAnZWFzZS1pbi1zaW5lJywgJ2Vhc2Utb3V0LXNpbmUnLCAnZWFzZS1pbi1vdXQtc2luZScsICdlYXNlLWluLXF1YWQnLCAnZWFzZS1vdXQtcXVhZCcsICdlYXNlLWluLW91dC1xdWFkJywgJ2Vhc2UtaW4tY3ViaWMnLCAnZWFzZS1vdXQtY3ViaWMnLCAnZWFzZS1pbi1vdXQtY3ViaWMnLCAnZWFzZS1pbi1xdWFydCcsICdlYXNlLW91dC1xdWFydCcsICdlYXNlLWluLW91dC1xdWFydCcsICdlYXNlLWluLXF1aW50JywgJ2Vhc2Utb3V0LXF1aW50JywgJ2Vhc2UtaW4tb3V0LXF1aW50JywgJ2Vhc2UtaW4tZXhwbycsICdlYXNlLW91dC1leHBvJywgJ2Vhc2UtaW4tb3V0LWV4cG8nLCAnZWFzZS1pbi1jaXJjJywgJ2Vhc2Utb3V0LWNpcmMnLCAnZWFzZS1pbi1vdXQtY2lyYyddXG4gICAgfSxcbiAgICBncmFkaWVudERpcmVjdGlvbjoge1xuICAgICAgZW51bXM6IFsndG8tYm90dG9tJywgJ3RvLXRvcCcsICd0by1sZWZ0JywgJ3RvLXJpZ2h0JywgJ3RvLWJvdHRvbS1yaWdodCcsICd0by1ib3R0b20tbGVmdCcsICd0by10b3AtcmlnaHQnLCAndG8tdG9wLWxlZnQnLCAndG8tcmlnaHQtYm90dG9tJywgJ3RvLWxlZnQtYm90dG9tJywgJ3RvLXJpZ2h0LXRvcCcsICd0by1sZWZ0LXRvcCcgLy8gZGlmZmVyZW50IG9yZGVyXG4gICAgICBdXG4gICAgfSxcblxuICAgIGJvdW5kc0V4cGFuc2lvbjoge1xuICAgICAgbnVtYmVyOiB0cnVlLFxuICAgICAgbXVsdGlwbGU6IHRydWUsXG4gICAgICBtaW46IDAsXG4gICAgICB2YWxpZGF0ZTogZnVuY3Rpb24gdmFsaWRhdGUodmFsQXJyKSB7XG4gICAgICAgIHZhciBsZW5ndGggPSB2YWxBcnIubGVuZ3RoO1xuICAgICAgICByZXR1cm4gbGVuZ3RoID09PSAxIHx8IGxlbmd0aCA9PT0gMiB8fCBsZW5ndGggPT09IDQ7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICB2YXIgZGlmZiA9IHtcbiAgICB6ZXJvTm9uWmVybzogZnVuY3Rpb24gemVyb05vblplcm8odmFsMSwgdmFsMikge1xuICAgICAgaWYgKCh2YWwxID09IG51bGwgfHwgdmFsMiA9PSBudWxsKSAmJiB2YWwxICE9PSB2YWwyKSB7XG4gICAgICAgIHJldHVybiB0cnVlOyAvLyBudWxsIGNhc2VzIGNvdWxkIHJlcHJlc2VudCBhbnkgdmFsdWVcbiAgICAgIH1cbiAgICAgIGlmICh2YWwxID09IDAgJiYgdmFsMiAhPSAwKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBlbHNlIGlmICh2YWwxICE9IDAgJiYgdmFsMiA9PSAwKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0sXG4gICAgYW55OiBmdW5jdGlvbiBhbnkodmFsMSwgdmFsMikge1xuICAgICAgcmV0dXJuIHZhbDEgIT0gdmFsMjtcbiAgICB9LFxuICAgIGVtcHR5Tm9uRW1wdHk6IGZ1bmN0aW9uIGVtcHR5Tm9uRW1wdHkoc3RyMSwgc3RyMikge1xuICAgICAgdmFyIGVtcHR5MSA9IGVtcHR5U3RyaW5nKHN0cjEpO1xuICAgICAgdmFyIGVtcHR5MiA9IGVtcHR5U3RyaW5nKHN0cjIpO1xuICAgICAgcmV0dXJuIGVtcHR5MSAmJiAhZW1wdHkyIHx8ICFlbXB0eTEgJiYgZW1wdHkyO1xuICAgIH1cbiAgfTtcblxuICAvLyBkZWZpbmUgdmlzdWFsIHN0eWxlIHByb3BlcnRpZXNcbiAgLy9cbiAgLy8gLSBuLmIuIGFkZGluZyBhIG5ldyBncm91cCBvZiBwcm9wcyBtYXkgcmVxdWlyZSB1cGRhdGVzIHRvIHVwZGF0ZVN0eWxlSGludHMoKVxuICAvLyAtIGFkZGluZyBuZXcgcHJvcHMgdG8gYW4gZXhpc3RpbmcgZ3JvdXAgZ2V0cyBoYW5kbGVkIGF1dG9tYXRpY2FsbHlcblxuICB2YXIgdCA9IHN0eWZuJDIudHlwZXM7XG4gIHZhciBtYWluTGFiZWwgPSBbe1xuICAgIG5hbWU6ICdsYWJlbCcsXG4gICAgdHlwZTogdC50ZXh0LFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueSxcbiAgICB0cmlnZ2Vyc1pPcmRlcjogZGlmZi5lbXB0eU5vbkVtcHR5XG4gIH0sIHtcbiAgICBuYW1lOiAndGV4dC1yb3RhdGlvbicsXG4gICAgdHlwZTogdC50ZXh0Um90YXRpb24sXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAndGV4dC1tYXJnaW4teCcsXG4gICAgdHlwZTogdC5iaWRpcmVjdGlvbmFsU2l6ZSxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICd0ZXh0LW1hcmdpbi15JyxcbiAgICB0eXBlOiB0LmJpZGlyZWN0aW9uYWxTaXplLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9XTtcbiAgdmFyIHNvdXJjZUxhYmVsID0gW3tcbiAgICBuYW1lOiAnc291cmNlLWxhYmVsJyxcbiAgICB0eXBlOiB0LnRleHQsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAnc291cmNlLXRleHQtcm90YXRpb24nLFxuICAgIHR5cGU6IHQudGV4dFJvdGF0aW9uLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ3NvdXJjZS10ZXh0LW1hcmdpbi14JyxcbiAgICB0eXBlOiB0LmJpZGlyZWN0aW9uYWxTaXplLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ3NvdXJjZS10ZXh0LW1hcmdpbi15JyxcbiAgICB0eXBlOiB0LmJpZGlyZWN0aW9uYWxTaXplLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ3NvdXJjZS10ZXh0LW9mZnNldCcsXG4gICAgdHlwZTogdC5zaXplLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9XTtcbiAgdmFyIHRhcmdldExhYmVsID0gW3tcbiAgICBuYW1lOiAndGFyZ2V0LWxhYmVsJyxcbiAgICB0eXBlOiB0LnRleHQsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAndGFyZ2V0LXRleHQtcm90YXRpb24nLFxuICAgIHR5cGU6IHQudGV4dFJvdGF0aW9uLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ3RhcmdldC10ZXh0LW1hcmdpbi14JyxcbiAgICB0eXBlOiB0LmJpZGlyZWN0aW9uYWxTaXplLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ3RhcmdldC10ZXh0LW1hcmdpbi15JyxcbiAgICB0eXBlOiB0LmJpZGlyZWN0aW9uYWxTaXplLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ3RhcmdldC10ZXh0LW9mZnNldCcsXG4gICAgdHlwZTogdC5zaXplLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9XTtcbiAgdmFyIGxhYmVsRGltZW5zaW9ucyA9IFt7XG4gICAgbmFtZTogJ2ZvbnQtZmFtaWx5JyxcbiAgICB0eXBlOiB0LmZvbnRGYW1pbHksXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAnZm9udC1zdHlsZScsXG4gICAgdHlwZTogdC5mb250U3R5bGUsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAnZm9udC13ZWlnaHQnLFxuICAgIHR5cGU6IHQuZm9udFdlaWdodCxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICdmb250LXNpemUnLFxuICAgIHR5cGU6IHQuc2l6ZSxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICd0ZXh0LXRyYW5zZm9ybScsXG4gICAgdHlwZTogdC50ZXh0VHJhbnNmb3JtLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ3RleHQtd3JhcCcsXG4gICAgdHlwZTogdC50ZXh0V3JhcCxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICd0ZXh0LW92ZXJmbG93LXdyYXAnLFxuICAgIHR5cGU6IHQudGV4dE92ZXJmbG93V3JhcCxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICd0ZXh0LW1heC13aWR0aCcsXG4gICAgdHlwZTogdC5zaXplLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ3RleHQtb3V0bGluZS13aWR0aCcsXG4gICAgdHlwZTogdC5zaXplLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ2xpbmUtaGVpZ2h0JyxcbiAgICB0eXBlOiB0LnBvc2l0aXZlTnVtYmVyLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9XTtcbiAgdmFyIGNvbW1vbkxhYmVsID0gW3tcbiAgICBuYW1lOiAndGV4dC12YWxpZ24nLFxuICAgIHR5cGU6IHQudmFsaWduLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ3RleHQtaGFsaWduJyxcbiAgICB0eXBlOiB0LmhhbGlnbixcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICdjb2xvcicsXG4gICAgdHlwZTogdC5jb2xvclxuICB9LCB7XG4gICAgbmFtZTogJ3RleHQtb3V0bGluZS1jb2xvcicsXG4gICAgdHlwZTogdC5jb2xvclxuICB9LCB7XG4gICAgbmFtZTogJ3RleHQtb3V0bGluZS1vcGFjaXR5JyxcbiAgICB0eXBlOiB0Lnplcm9PbmVOdW1iZXJcbiAgfSwge1xuICAgIG5hbWU6ICd0ZXh0LWJhY2tncm91bmQtY29sb3InLFxuICAgIHR5cGU6IHQuY29sb3JcbiAgfSwge1xuICAgIG5hbWU6ICd0ZXh0LWJhY2tncm91bmQtb3BhY2l0eScsXG4gICAgdHlwZTogdC56ZXJvT25lTnVtYmVyXG4gIH0sIHtcbiAgICBuYW1lOiAndGV4dC1iYWNrZ3JvdW5kLXBhZGRpbmcnLFxuICAgIHR5cGU6IHQuc2l6ZSxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICd0ZXh0LWJvcmRlci1vcGFjaXR5JyxcbiAgICB0eXBlOiB0Lnplcm9PbmVOdW1iZXJcbiAgfSwge1xuICAgIG5hbWU6ICd0ZXh0LWJvcmRlci1jb2xvcicsXG4gICAgdHlwZTogdC5jb2xvclxuICB9LCB7XG4gICAgbmFtZTogJ3RleHQtYm9yZGVyLXdpZHRoJyxcbiAgICB0eXBlOiB0LnNpemUsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAndGV4dC1ib3JkZXItc3R5bGUnLFxuICAgIHR5cGU6IHQuYm9yZGVyU3R5bGUsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAndGV4dC1iYWNrZ3JvdW5kLXNoYXBlJyxcbiAgICB0eXBlOiB0LnRleHRCYWNrZ3JvdW5kU2hhcGUsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAndGV4dC1qdXN0aWZpY2F0aW9uJyxcbiAgICB0eXBlOiB0Lmp1c3RpZmljYXRpb25cbiAgfV07XG4gIHZhciBiZWhhdmlvciA9IFt7XG4gICAgbmFtZTogJ2V2ZW50cycsXG4gICAgdHlwZTogdC5ib29sLFxuICAgIHRyaWdnZXJzWk9yZGVyOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ3RleHQtZXZlbnRzJyxcbiAgICB0eXBlOiB0LmJvb2wsXG4gICAgdHJpZ2dlcnNaT3JkZXI6IGRpZmYuYW55XG4gIH1dO1xuICB2YXIgdmlzaWJpbGl0eSA9IFt7XG4gICAgbmFtZTogJ2Rpc3BsYXknLFxuICAgIHR5cGU6IHQuZGlzcGxheSxcbiAgICB0cmlnZ2Vyc1pPcmRlcjogZGlmZi5hbnksXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55LFxuICAgIHRyaWdnZXJzQm91bmRzT2ZDb25uZWN0ZWRFZGdlczogdHJ1ZVxuICB9LCB7XG4gICAgbmFtZTogJ3Zpc2liaWxpdHknLFxuICAgIHR5cGU6IHQudmlzaWJpbGl0eSxcbiAgICB0cmlnZ2Vyc1pPcmRlcjogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICdvcGFjaXR5JyxcbiAgICB0eXBlOiB0Lnplcm9PbmVOdW1iZXIsXG4gICAgdHJpZ2dlcnNaT3JkZXI6IGRpZmYuemVyb05vblplcm9cbiAgfSwge1xuICAgIG5hbWU6ICd0ZXh0LW9wYWNpdHknLFxuICAgIHR5cGU6IHQuemVyb09uZU51bWJlclxuICB9LCB7XG4gICAgbmFtZTogJ21pbi16b29tZWQtZm9udC1zaXplJyxcbiAgICB0eXBlOiB0LnNpemVcbiAgfSwge1xuICAgIG5hbWU6ICd6LWNvbXBvdW5kLWRlcHRoJyxcbiAgICB0eXBlOiB0LnpDb21wb3VuZERlcHRoLFxuICAgIHRyaWdnZXJzWk9yZGVyOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ3otaW5kZXgtY29tcGFyZScsXG4gICAgdHlwZTogdC56SW5kZXhDb21wYXJlLFxuICAgIHRyaWdnZXJzWk9yZGVyOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ3otaW5kZXgnLFxuICAgIHR5cGU6IHQubnVtYmVyLFxuICAgIHRyaWdnZXJzWk9yZGVyOiBkaWZmLmFueVxuICB9XTtcbiAgdmFyIG92ZXJsYXkgPSBbe1xuICAgIG5hbWU6ICdvdmVybGF5LXBhZGRpbmcnLFxuICAgIHR5cGU6IHQuc2l6ZSxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICdvdmVybGF5LWNvbG9yJyxcbiAgICB0eXBlOiB0LmNvbG9yXG4gIH0sIHtcbiAgICBuYW1lOiAnb3ZlcmxheS1vcGFjaXR5JyxcbiAgICB0eXBlOiB0Lnplcm9PbmVOdW1iZXIsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuemVyb05vblplcm9cbiAgfSwge1xuICAgIG5hbWU6ICdvdmVybGF5LXNoYXBlJyxcbiAgICB0eXBlOiB0Lm92ZXJsYXlTaGFwZSxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICdvdmVybGF5LWNvcm5lci1yYWRpdXMnLFxuICAgIHR5cGU6IHQuY29ybmVyUmFkaXVzXG4gIH1dO1xuICB2YXIgdW5kZXJsYXkgPSBbe1xuICAgIG5hbWU6ICd1bmRlcmxheS1wYWRkaW5nJyxcbiAgICB0eXBlOiB0LnNpemUsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAndW5kZXJsYXktY29sb3InLFxuICAgIHR5cGU6IHQuY29sb3JcbiAgfSwge1xuICAgIG5hbWU6ICd1bmRlcmxheS1vcGFjaXR5JyxcbiAgICB0eXBlOiB0Lnplcm9PbmVOdW1iZXIsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuemVyb05vblplcm9cbiAgfSwge1xuICAgIG5hbWU6ICd1bmRlcmxheS1zaGFwZScsXG4gICAgdHlwZTogdC5vdmVybGF5U2hhcGUsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAndW5kZXJsYXktY29ybmVyLXJhZGl1cycsXG4gICAgdHlwZTogdC5jb3JuZXJSYWRpdXNcbiAgfV07XG4gIHZhciB0cmFuc2l0aW9uID0gW3tcbiAgICBuYW1lOiAndHJhbnNpdGlvbi1wcm9wZXJ0eScsXG4gICAgdHlwZTogdC5wcm9wTGlzdFxuICB9LCB7XG4gICAgbmFtZTogJ3RyYW5zaXRpb24tZHVyYXRpb24nLFxuICAgIHR5cGU6IHQudGltZVxuICB9LCB7XG4gICAgbmFtZTogJ3RyYW5zaXRpb24tZGVsYXknLFxuICAgIHR5cGU6IHQudGltZVxuICB9LCB7XG4gICAgbmFtZTogJ3RyYW5zaXRpb24tdGltaW5nLWZ1bmN0aW9uJyxcbiAgICB0eXBlOiB0LmVhc2luZ1xuICB9XTtcbiAgdmFyIG5vZGVTaXplSGFzaE92ZXJyaWRlID0gZnVuY3Rpb24gbm9kZVNpemVIYXNoT3ZlcnJpZGUoZWxlLCBwYXJzZWRQcm9wKSB7XG4gICAgaWYgKHBhcnNlZFByb3AudmFsdWUgPT09ICdsYWJlbCcpIHtcbiAgICAgIHJldHVybiAtZWxlLnBvb2xJbmRleCgpOyAvLyBubyBoYXNoIGtleSBoaXRzIGlzIHVzaW5nIGxhYmVsIHNpemUgKGhpdHJhdGUgZm9yIHBlcmYgcHJvYmFibHkgbG93IGFueXdheSlcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHBhcnNlZFByb3AucGZWYWx1ZTtcbiAgICB9XG4gIH07XG4gIHZhciBub2RlQm9keSA9IFt7XG4gICAgbmFtZTogJ2hlaWdodCcsXG4gICAgdHlwZTogdC5ub2RlU2l6ZSxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnksXG4gICAgaGFzaE92ZXJyaWRlOiBub2RlU2l6ZUhhc2hPdmVycmlkZVxuICB9LCB7XG4gICAgbmFtZTogJ3dpZHRoJyxcbiAgICB0eXBlOiB0Lm5vZGVTaXplLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueSxcbiAgICBoYXNoT3ZlcnJpZGU6IG5vZGVTaXplSGFzaE92ZXJyaWRlXG4gIH0sIHtcbiAgICBuYW1lOiAnc2hhcGUnLFxuICAgIHR5cGU6IHQubm9kZVNoYXBlLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ3NoYXBlLXBvbHlnb24tcG9pbnRzJyxcbiAgICB0eXBlOiB0LnBvbHlnb25Qb2ludExpc3QsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAnY29ybmVyLXJhZGl1cycsXG4gICAgdHlwZTogdC5jb3JuZXJSYWRpdXNcbiAgfSwge1xuICAgIG5hbWU6ICdiYWNrZ3JvdW5kLWNvbG9yJyxcbiAgICB0eXBlOiB0LmNvbG9yXG4gIH0sIHtcbiAgICBuYW1lOiAnYmFja2dyb3VuZC1maWxsJyxcbiAgICB0eXBlOiB0LmZpbGxcbiAgfSwge1xuICAgIG5hbWU6ICdiYWNrZ3JvdW5kLW9wYWNpdHknLFxuICAgIHR5cGU6IHQuemVyb09uZU51bWJlclxuICB9LCB7XG4gICAgbmFtZTogJ2JhY2tncm91bmQtYmxhY2tlbicsXG4gICAgdHlwZTogdC5uT25lT25lTnVtYmVyXG4gIH0sIHtcbiAgICBuYW1lOiAnYmFja2dyb3VuZC1ncmFkaWVudC1zdG9wLWNvbG9ycycsXG4gICAgdHlwZTogdC5jb2xvcnNcbiAgfSwge1xuICAgIG5hbWU6ICdiYWNrZ3JvdW5kLWdyYWRpZW50LXN0b3AtcG9zaXRpb25zJyxcbiAgICB0eXBlOiB0LnBlcmNlbnRhZ2VzXG4gIH0sIHtcbiAgICBuYW1lOiAnYmFja2dyb3VuZC1ncmFkaWVudC1kaXJlY3Rpb24nLFxuICAgIHR5cGU6IHQuZ3JhZGllbnREaXJlY3Rpb25cbiAgfSwge1xuICAgIG5hbWU6ICdwYWRkaW5nJyxcbiAgICB0eXBlOiB0LnNpemVNYXliZVBlcmNlbnQsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAncGFkZGluZy1yZWxhdGl2ZS10bycsXG4gICAgdHlwZTogdC5wYWRkaW5nUmVsYXRpdmVUbyxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICdib3VuZHMtZXhwYW5zaW9uJyxcbiAgICB0eXBlOiB0LmJvdW5kc0V4cGFuc2lvbixcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfV07XG4gIHZhciBub2RlQm9yZGVyID0gW3tcbiAgICBuYW1lOiAnYm9yZGVyLWNvbG9yJyxcbiAgICB0eXBlOiB0LmNvbG9yXG4gIH0sIHtcbiAgICBuYW1lOiAnYm9yZGVyLW9wYWNpdHknLFxuICAgIHR5cGU6IHQuemVyb09uZU51bWJlclxuICB9LCB7XG4gICAgbmFtZTogJ2JvcmRlci13aWR0aCcsXG4gICAgdHlwZTogdC5zaXplLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ2JvcmRlci1zdHlsZScsXG4gICAgdHlwZTogdC5ib3JkZXJTdHlsZVxuICB9LCB7XG4gICAgbmFtZTogJ2JvcmRlci1jYXAnLFxuICAgIHR5cGU6IHQubGluZUNhcFxuICB9LCB7XG4gICAgbmFtZTogJ2JvcmRlci1qb2luJyxcbiAgICB0eXBlOiB0LmxpbmVKb2luXG4gIH0sIHtcbiAgICBuYW1lOiAnYm9yZGVyLWRhc2gtcGF0dGVybicsXG4gICAgdHlwZTogdC5udW1iZXJzXG4gIH0sIHtcbiAgICBuYW1lOiAnYm9yZGVyLWRhc2gtb2Zmc2V0JyxcbiAgICB0eXBlOiB0Lm51bWJlclxuICB9LCB7XG4gICAgbmFtZTogJ2JvcmRlci1wb3NpdGlvbicsXG4gICAgdHlwZTogdC5saW5lUG9zaXRpb25cbiAgfV07XG4gIHZhciBub2RlT3V0bGluZSA9IFt7XG4gICAgbmFtZTogJ291dGxpbmUtY29sb3InLFxuICAgIHR5cGU6IHQuY29sb3JcbiAgfSwge1xuICAgIG5hbWU6ICdvdXRsaW5lLW9wYWNpdHknLFxuICAgIHR5cGU6IHQuemVyb09uZU51bWJlclxuICB9LCB7XG4gICAgbmFtZTogJ291dGxpbmUtd2lkdGgnLFxuICAgIHR5cGU6IHQuc2l6ZSxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICdvdXRsaW5lLXN0eWxlJyxcbiAgICB0eXBlOiB0LmJvcmRlclN0eWxlXG4gIH0sIHtcbiAgICBuYW1lOiAnb3V0bGluZS1vZmZzZXQnLFxuICAgIHR5cGU6IHQuc2l6ZSxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfV07XG4gIHZhciBiYWNrZ3JvdW5kSW1hZ2UgPSBbe1xuICAgIG5hbWU6ICdiYWNrZ3JvdW5kLWltYWdlJyxcbiAgICB0eXBlOiB0LnVybHNcbiAgfSwge1xuICAgIG5hbWU6ICdiYWNrZ3JvdW5kLWltYWdlLWNyb3Nzb3JpZ2luJyxcbiAgICB0eXBlOiB0LmJnQ3Jvc3NPcmlnaW5cbiAgfSwge1xuICAgIG5hbWU6ICdiYWNrZ3JvdW5kLWltYWdlLW9wYWNpdHknLFxuICAgIHR5cGU6IHQuemVyb09uZU51bWJlcnNcbiAgfSwge1xuICAgIG5hbWU6ICdiYWNrZ3JvdW5kLWltYWdlLWNvbnRhaW5tZW50JyxcbiAgICB0eXBlOiB0LmJnQ29udGFpbm1lbnRcbiAgfSwge1xuICAgIG5hbWU6ICdiYWNrZ3JvdW5kLWltYWdlLXNtb290aGluZycsXG4gICAgdHlwZTogdC5ib29sc1xuICB9LCB7XG4gICAgbmFtZTogJ2JhY2tncm91bmQtcG9zaXRpb24teCcsXG4gICAgdHlwZTogdC5iZ1Bvc1xuICB9LCB7XG4gICAgbmFtZTogJ2JhY2tncm91bmQtcG9zaXRpb24teScsXG4gICAgdHlwZTogdC5iZ1Bvc1xuICB9LCB7XG4gICAgbmFtZTogJ2JhY2tncm91bmQtd2lkdGgtcmVsYXRpdmUtdG8nLFxuICAgIHR5cGU6IHQuYmdSZWxhdGl2ZVRvXG4gIH0sIHtcbiAgICBuYW1lOiAnYmFja2dyb3VuZC1oZWlnaHQtcmVsYXRpdmUtdG8nLFxuICAgIHR5cGU6IHQuYmdSZWxhdGl2ZVRvXG4gIH0sIHtcbiAgICBuYW1lOiAnYmFja2dyb3VuZC1yZXBlYXQnLFxuICAgIHR5cGU6IHQuYmdSZXBlYXRcbiAgfSwge1xuICAgIG5hbWU6ICdiYWNrZ3JvdW5kLWZpdCcsXG4gICAgdHlwZTogdC5iZ0ZpdFxuICB9LCB7XG4gICAgbmFtZTogJ2JhY2tncm91bmQtY2xpcCcsXG4gICAgdHlwZTogdC5iZ0NsaXBcbiAgfSwge1xuICAgIG5hbWU6ICdiYWNrZ3JvdW5kLXdpZHRoJyxcbiAgICB0eXBlOiB0LmJnV0hcbiAgfSwge1xuICAgIG5hbWU6ICdiYWNrZ3JvdW5kLWhlaWdodCcsXG4gICAgdHlwZTogdC5iZ1dIXG4gIH0sIHtcbiAgICBuYW1lOiAnYmFja2dyb3VuZC1vZmZzZXQteCcsXG4gICAgdHlwZTogdC5iZ1Bvc1xuICB9LCB7XG4gICAgbmFtZTogJ2JhY2tncm91bmQtb2Zmc2V0LXknLFxuICAgIHR5cGU6IHQuYmdQb3NcbiAgfV07XG4gIHZhciBjb21wb3VuZCA9IFt7XG4gICAgbmFtZTogJ3Bvc2l0aW9uJyxcbiAgICB0eXBlOiB0LnBvc2l0aW9uLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ2NvbXBvdW5kLXNpemluZy13cnQtbGFiZWxzJyxcbiAgICB0eXBlOiB0LmNvbXBvdW5kSW5jbHVkZUxhYmVscyxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICdtaW4td2lkdGgnLFxuICAgIHR5cGU6IHQuc2l6ZSxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICdtaW4td2lkdGgtYmlhcy1sZWZ0JyxcbiAgICB0eXBlOiB0LnNpemVNYXliZVBlcmNlbnQsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAnbWluLXdpZHRoLWJpYXMtcmlnaHQnLFxuICAgIHR5cGU6IHQuc2l6ZU1heWJlUGVyY2VudCxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICdtaW4taGVpZ2h0JyxcbiAgICB0eXBlOiB0LnNpemUsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAnbWluLWhlaWdodC1iaWFzLXRvcCcsXG4gICAgdHlwZTogdC5zaXplTWF5YmVQZXJjZW50LFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ21pbi1oZWlnaHQtYmlhcy1ib3R0b20nLFxuICAgIHR5cGU6IHQuc2l6ZU1heWJlUGVyY2VudCxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfV07XG4gIHZhciBlZGdlTGluZSA9IFt7XG4gICAgbmFtZTogJ2xpbmUtc3R5bGUnLFxuICAgIHR5cGU6IHQubGluZVN0eWxlXG4gIH0sIHtcbiAgICBuYW1lOiAnbGluZS1jb2xvcicsXG4gICAgdHlwZTogdC5jb2xvclxuICB9LCB7XG4gICAgbmFtZTogJ2xpbmUtZmlsbCcsXG4gICAgdHlwZTogdC5maWxsXG4gIH0sIHtcbiAgICBuYW1lOiAnbGluZS1jYXAnLFxuICAgIHR5cGU6IHQubGluZUNhcFxuICB9LCB7XG4gICAgbmFtZTogJ2xpbmUtb3BhY2l0eScsXG4gICAgdHlwZTogdC56ZXJvT25lTnVtYmVyXG4gIH0sIHtcbiAgICBuYW1lOiAnbGluZS1kYXNoLXBhdHRlcm4nLFxuICAgIHR5cGU6IHQubnVtYmVyc1xuICB9LCB7XG4gICAgbmFtZTogJ2xpbmUtZGFzaC1vZmZzZXQnLFxuICAgIHR5cGU6IHQubnVtYmVyXG4gIH0sIHtcbiAgICBuYW1lOiAnbGluZS1vdXRsaW5lLXdpZHRoJyxcbiAgICB0eXBlOiB0LnNpemVcbiAgfSwge1xuICAgIG5hbWU6ICdsaW5lLW91dGxpbmUtY29sb3InLFxuICAgIHR5cGU6IHQuY29sb3JcbiAgfSwge1xuICAgIG5hbWU6ICdsaW5lLWdyYWRpZW50LXN0b3AtY29sb3JzJyxcbiAgICB0eXBlOiB0LmNvbG9yc1xuICB9LCB7XG4gICAgbmFtZTogJ2xpbmUtZ3JhZGllbnQtc3RvcC1wb3NpdGlvbnMnLFxuICAgIHR5cGU6IHQucGVyY2VudGFnZXNcbiAgfSwge1xuICAgIG5hbWU6ICdjdXJ2ZS1zdHlsZScsXG4gICAgdHlwZTogdC5jdXJ2ZVN0eWxlLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueSxcbiAgICB0cmlnZ2Vyc0JvdW5kc09mUGFyYWxsZWxCZXppZXJzOiB0cnVlXG4gIH0sIHtcbiAgICBuYW1lOiAnaGF5c3RhY2stcmFkaXVzJyxcbiAgICB0eXBlOiB0Lnplcm9PbmVOdW1iZXIsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAnc291cmNlLWVuZHBvaW50JyxcbiAgICB0eXBlOiB0LmVkZ2VFbmRwb2ludCxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICd0YXJnZXQtZW5kcG9pbnQnLFxuICAgIHR5cGU6IHQuZWRnZUVuZHBvaW50LFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ2NvbnRyb2wtcG9pbnQtc3RlcC1zaXplJyxcbiAgICB0eXBlOiB0LnNpemUsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAnY29udHJvbC1wb2ludC1kaXN0YW5jZXMnLFxuICAgIHR5cGU6IHQuYmlkaXJlY3Rpb25hbFNpemVzLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ2NvbnRyb2wtcG9pbnQtd2VpZ2h0cycsXG4gICAgdHlwZTogdC5udW1iZXJzLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ3NlZ21lbnQtZGlzdGFuY2VzJyxcbiAgICB0eXBlOiB0LmJpZGlyZWN0aW9uYWxTaXplcyxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICdzZWdtZW50LXdlaWdodHMnLFxuICAgIHR5cGU6IHQubnVtYmVycyxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICdzZWdtZW50LXJhZGlpJyxcbiAgICB0eXBlOiB0Lm51bWJlcnMsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAncmFkaXVzLXR5cGUnLFxuICAgIHR5cGU6IHQucmFkaXVzVHlwZSxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICd0YXhpLXR1cm4nLFxuICAgIHR5cGU6IHQuYmlkaXJlY3Rpb25hbFNpemVNYXliZVBlcmNlbnQsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAndGF4aS10dXJuLW1pbi1kaXN0YW5jZScsXG4gICAgdHlwZTogdC5zaXplLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ3RheGktZGlyZWN0aW9uJyxcbiAgICB0eXBlOiB0LmF4aXNEaXJlY3Rpb24sXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAndGF4aS1yYWRpdXMnLFxuICAgIHR5cGU6IHQubnVtYmVyLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ2VkZ2UtZGlzdGFuY2VzJyxcbiAgICB0eXBlOiB0LmVkZ2VEaXN0YW5jZXMsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAnYXJyb3ctc2NhbGUnLFxuICAgIHR5cGU6IHQucG9zaXRpdmVOdW1iZXIsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAnbG9vcC1kaXJlY3Rpb24nLFxuICAgIHR5cGU6IHQuYW5nbGUsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAnbG9vcC1zd2VlcCcsXG4gICAgdHlwZTogdC5hbmdsZSxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICdzb3VyY2UtZGlzdGFuY2UtZnJvbS1ub2RlJyxcbiAgICB0eXBlOiB0LnNpemUsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAndGFyZ2V0LWRpc3RhbmNlLWZyb20tbm9kZScsXG4gICAgdHlwZTogdC5zaXplLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9XTtcbiAgdmFyIGdob3N0ID0gW3tcbiAgICBuYW1lOiAnZ2hvc3QnLFxuICAgIHR5cGU6IHQuYm9vbCxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICdnaG9zdC1vZmZzZXQteCcsXG4gICAgdHlwZTogdC5iaWRpcmVjdGlvbmFsU2l6ZSxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICdnaG9zdC1vZmZzZXQteScsXG4gICAgdHlwZTogdC5iaWRpcmVjdGlvbmFsU2l6ZSxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICdnaG9zdC1vcGFjaXR5JyxcbiAgICB0eXBlOiB0Lnplcm9PbmVOdW1iZXJcbiAgfV07XG4gIHZhciBjb3JlID0gW3tcbiAgICBuYW1lOiAnc2VsZWN0aW9uLWJveC1jb2xvcicsXG4gICAgdHlwZTogdC5jb2xvclxuICB9LCB7XG4gICAgbmFtZTogJ3NlbGVjdGlvbi1ib3gtb3BhY2l0eScsXG4gICAgdHlwZTogdC56ZXJvT25lTnVtYmVyXG4gIH0sIHtcbiAgICBuYW1lOiAnc2VsZWN0aW9uLWJveC1ib3JkZXItY29sb3InLFxuICAgIHR5cGU6IHQuY29sb3JcbiAgfSwge1xuICAgIG5hbWU6ICdzZWxlY3Rpb24tYm94LWJvcmRlci13aWR0aCcsXG4gICAgdHlwZTogdC5zaXplXG4gIH0sIHtcbiAgICBuYW1lOiAnYWN0aXZlLWJnLWNvbG9yJyxcbiAgICB0eXBlOiB0LmNvbG9yXG4gIH0sIHtcbiAgICBuYW1lOiAnYWN0aXZlLWJnLW9wYWNpdHknLFxuICAgIHR5cGU6IHQuemVyb09uZU51bWJlclxuICB9LCB7XG4gICAgbmFtZTogJ2FjdGl2ZS1iZy1zaXplJyxcbiAgICB0eXBlOiB0LnNpemVcbiAgfSwge1xuICAgIG5hbWU6ICdvdXRzaWRlLXRleHR1cmUtYmctY29sb3InLFxuICAgIHR5cGU6IHQuY29sb3JcbiAgfSwge1xuICAgIG5hbWU6ICdvdXRzaWRlLXRleHR1cmUtYmctb3BhY2l0eScsXG4gICAgdHlwZTogdC56ZXJvT25lTnVtYmVyXG4gIH1dO1xuXG4gIC8vIHBpZSBiYWNrZ3JvdW5kcyBmb3Igbm9kZXNcbiAgdmFyIHBpZSA9IFtdO1xuICBzdHlmbiQyLnBpZUJhY2tncm91bmROID0gMTY7IC8vIGJlY2F1c2UgdGhlIHBpZSBwcm9wZXJ0aWVzIGFyZSBudW1iZXJlZCwgZ2l2ZSBhY2Nlc3MgdG8gYSBjb25zdGFudCBOIChmb3IgcmVuZGVyZXIgdXNlKVxuICBwaWUucHVzaCh7XG4gICAgbmFtZTogJ3BpZS1zaXplJyxcbiAgICB0eXBlOiB0LnNpemVNYXliZVBlcmNlbnRcbiAgfSk7XG4gIGZvciAodmFyIGkgPSAxOyBpIDw9IHN0eWZuJDIucGllQmFja2dyb3VuZE47IGkrKykge1xuICAgIHBpZS5wdXNoKHtcbiAgICAgIG5hbWU6ICdwaWUtJyArIGkgKyAnLWJhY2tncm91bmQtY29sb3InLFxuICAgICAgdHlwZTogdC5jb2xvclxuICAgIH0pO1xuICAgIHBpZS5wdXNoKHtcbiAgICAgIG5hbWU6ICdwaWUtJyArIGkgKyAnLWJhY2tncm91bmQtc2l6ZScsXG4gICAgICB0eXBlOiB0LnBlcmNlbnRcbiAgICB9KTtcbiAgICBwaWUucHVzaCh7XG4gICAgICBuYW1lOiAncGllLScgKyBpICsgJy1iYWNrZ3JvdW5kLW9wYWNpdHknLFxuICAgICAgdHlwZTogdC56ZXJvT25lTnVtYmVyXG4gICAgfSk7XG4gIH1cblxuICAvLyBlZGdlIGFycm93c1xuICB2YXIgZWRnZUFycm93ID0gW107XG4gIHZhciBhcnJvd1ByZWZpeGVzID0gc3R5Zm4kMi5hcnJvd1ByZWZpeGVzID0gWydzb3VyY2UnLCAnbWlkLXNvdXJjZScsICd0YXJnZXQnLCAnbWlkLXRhcmdldCddO1xuICBbe1xuICAgIG5hbWU6ICdhcnJvdy1zaGFwZScsXG4gICAgdHlwZTogdC5hcnJvd1NoYXBlLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ2Fycm93LWNvbG9yJyxcbiAgICB0eXBlOiB0LmNvbG9yXG4gIH0sIHtcbiAgICBuYW1lOiAnYXJyb3ctZmlsbCcsXG4gICAgdHlwZTogdC5hcnJvd0ZpbGxcbiAgfSwge1xuICAgIG5hbWU6ICdhcnJvdy13aWR0aCcsXG4gICAgdHlwZTogdC5hcnJvd1dpZHRoXG4gIH1dLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICBhcnJvd1ByZWZpeGVzLmZvckVhY2goZnVuY3Rpb24gKHByZWZpeCkge1xuICAgICAgdmFyIG5hbWUgPSBwcmVmaXggKyAnLScgKyBwcm9wLm5hbWU7XG4gICAgICB2YXIgdHlwZSA9IHByb3AudHlwZSxcbiAgICAgICAgdHJpZ2dlcnNCb3VuZHMgPSBwcm9wLnRyaWdnZXJzQm91bmRzO1xuICAgICAgZWRnZUFycm93LnB1c2goe1xuICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICB0cmlnZ2Vyc0JvdW5kczogdHJpZ2dlcnNCb3VuZHNcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9LCB7fSk7XG4gIHZhciBwcm9wcyA9IHN0eWZuJDIucHJvcGVydGllcyA9IFtdLmNvbmNhdChiZWhhdmlvciwgdHJhbnNpdGlvbiwgdmlzaWJpbGl0eSwgb3ZlcmxheSwgdW5kZXJsYXksIGdob3N0LCBjb21tb25MYWJlbCwgbGFiZWxEaW1lbnNpb25zLCBtYWluTGFiZWwsIHNvdXJjZUxhYmVsLCB0YXJnZXRMYWJlbCwgbm9kZUJvZHksIG5vZGVCb3JkZXIsIG5vZGVPdXRsaW5lLCBiYWNrZ3JvdW5kSW1hZ2UsIHBpZSwgY29tcG91bmQsIGVkZ2VMaW5lLCBlZGdlQXJyb3csIGNvcmUpO1xuICB2YXIgcHJvcEdyb3VwcyA9IHN0eWZuJDIucHJvcGVydHlHcm91cHMgPSB7XG4gICAgLy8gY29tbW9uIHRvIGFsbCBlbGVzXG4gICAgYmVoYXZpb3I6IGJlaGF2aW9yLFxuICAgIHRyYW5zaXRpb246IHRyYW5zaXRpb24sXG4gICAgdmlzaWJpbGl0eTogdmlzaWJpbGl0eSxcbiAgICBvdmVybGF5OiBvdmVybGF5LFxuICAgIHVuZGVybGF5OiB1bmRlcmxheSxcbiAgICBnaG9zdDogZ2hvc3QsXG4gICAgLy8gbGFiZWxzXG4gICAgY29tbW9uTGFiZWw6IGNvbW1vbkxhYmVsLFxuICAgIGxhYmVsRGltZW5zaW9uczogbGFiZWxEaW1lbnNpb25zLFxuICAgIG1haW5MYWJlbDogbWFpbkxhYmVsLFxuICAgIHNvdXJjZUxhYmVsOiBzb3VyY2VMYWJlbCxcbiAgICB0YXJnZXRMYWJlbDogdGFyZ2V0TGFiZWwsXG4gICAgLy8gbm9kZSBwcm9wc1xuICAgIG5vZGVCb2R5OiBub2RlQm9keSxcbiAgICBub2RlQm9yZGVyOiBub2RlQm9yZGVyLFxuICAgIG5vZGVPdXRsaW5lOiBub2RlT3V0bGluZSxcbiAgICBiYWNrZ3JvdW5kSW1hZ2U6IGJhY2tncm91bmRJbWFnZSxcbiAgICBwaWU6IHBpZSxcbiAgICBjb21wb3VuZDogY29tcG91bmQsXG4gICAgLy8gZWRnZSBwcm9wc1xuICAgIGVkZ2VMaW5lOiBlZGdlTGluZSxcbiAgICBlZGdlQXJyb3c6IGVkZ2VBcnJvdyxcbiAgICBjb3JlOiBjb3JlXG4gIH07XG4gIHZhciBwcm9wR3JvdXBOYW1lcyA9IHN0eWZuJDIucHJvcGVydHlHcm91cE5hbWVzID0ge307XG4gIHZhciBwcm9wR3JvdXBLZXlzID0gc3R5Zm4kMi5wcm9wZXJ0eUdyb3VwS2V5cyA9IE9iamVjdC5rZXlzKHByb3BHcm91cHMpO1xuICBwcm9wR3JvdXBLZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIHByb3BHcm91cE5hbWVzW2tleV0gPSBwcm9wR3JvdXBzW2tleV0ubWFwKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICByZXR1cm4gcHJvcC5uYW1lO1xuICAgIH0pO1xuICAgIHByb3BHcm91cHNba2V5XS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICByZXR1cm4gcHJvcC5ncm91cEtleSA9IGtleTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgLy8gZGVmaW5lIGFsaWFzZXNcbiAgdmFyIGFsaWFzZXMgPSBzdHlmbiQyLmFsaWFzZXMgPSBbe1xuICAgIG5hbWU6ICdjb250ZW50JyxcbiAgICBwb2ludHNUbzogJ2xhYmVsJ1xuICB9LCB7XG4gICAgbmFtZTogJ2NvbnRyb2wtcG9pbnQtZGlzdGFuY2UnLFxuICAgIHBvaW50c1RvOiAnY29udHJvbC1wb2ludC1kaXN0YW5jZXMnXG4gIH0sIHtcbiAgICBuYW1lOiAnY29udHJvbC1wb2ludC13ZWlnaHQnLFxuICAgIHBvaW50c1RvOiAnY29udHJvbC1wb2ludC13ZWlnaHRzJ1xuICB9LCB7XG4gICAgbmFtZTogJ3NlZ21lbnQtZGlzdGFuY2UnLFxuICAgIHBvaW50c1RvOiAnc2VnbWVudC1kaXN0YW5jZXMnXG4gIH0sIHtcbiAgICBuYW1lOiAnc2VnbWVudC13ZWlnaHQnLFxuICAgIHBvaW50c1RvOiAnc2VnbWVudC13ZWlnaHRzJ1xuICB9LCB7XG4gICAgbmFtZTogJ3NlZ21lbnQtcmFkaXVzJyxcbiAgICBwb2ludHNUbzogJ3NlZ21lbnQtcmFkaWknXG4gIH0sIHtcbiAgICBuYW1lOiAnZWRnZS10ZXh0LXJvdGF0aW9uJyxcbiAgICBwb2ludHNUbzogJ3RleHQtcm90YXRpb24nXG4gIH0sIHtcbiAgICBuYW1lOiAncGFkZGluZy1sZWZ0JyxcbiAgICBwb2ludHNUbzogJ3BhZGRpbmcnXG4gIH0sIHtcbiAgICBuYW1lOiAncGFkZGluZy1yaWdodCcsXG4gICAgcG9pbnRzVG86ICdwYWRkaW5nJ1xuICB9LCB7XG4gICAgbmFtZTogJ3BhZGRpbmctdG9wJyxcbiAgICBwb2ludHNUbzogJ3BhZGRpbmcnXG4gIH0sIHtcbiAgICBuYW1lOiAncGFkZGluZy1ib3R0b20nLFxuICAgIHBvaW50c1RvOiAncGFkZGluZydcbiAgfV07XG5cbiAgLy8gbGlzdCBvZiBwcm9wZXJ0eSBuYW1lc1xuICBzdHlmbiQyLnByb3BlcnR5TmFtZXMgPSBwcm9wcy5tYXAoZnVuY3Rpb24gKHApIHtcbiAgICByZXR1cm4gcC5uYW1lO1xuICB9KTtcblxuICAvLyBhbGxvdyBhY2Nlc3Mgb2YgcHJvcGVydGllcyBieSBuYW1lICggZS5nLiBzdHlsZS5wcm9wZXJ0aWVzLmhlaWdodCApXG4gIGZvciAodmFyIF9pID0gMDsgX2kgPCBwcm9wcy5sZW5ndGg7IF9pKyspIHtcbiAgICB2YXIgcHJvcCA9IHByb3BzW19pXTtcbiAgICBwcm9wc1twcm9wLm5hbWVdID0gcHJvcDsgLy8gYWxsb3cgbG9va3VwIGJ5IG5hbWVcbiAgfVxuXG4gIC8vIG1hcCBhbGlhc2VzXG4gIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IGFsaWFzZXMubGVuZ3RoOyBfaTIrKykge1xuICAgIHZhciBhbGlhcyA9IGFsaWFzZXNbX2kyXTtcbiAgICB2YXIgcG9pbnRzVG9Qcm9wID0gcHJvcHNbYWxpYXMucG9pbnRzVG9dO1xuICAgIHZhciBhbGlhc1Byb3AgPSB7XG4gICAgICBuYW1lOiBhbGlhcy5uYW1lLFxuICAgICAgYWxpYXM6IHRydWUsXG4gICAgICBwb2ludHNUbzogcG9pbnRzVG9Qcm9wXG4gICAgfTtcblxuICAgIC8vIGFkZCBhbGlhcyBwcm9wIGZvciBwYXJzaW5nXG4gICAgcHJvcHMucHVzaChhbGlhc1Byb3ApO1xuICAgIHByb3BzW2FsaWFzLm5hbWVdID0gYWxpYXNQcm9wOyAvLyBhbGxvdyBsb29rdXAgYnkgbmFtZVxuICB9XG59KSgpO1xuXG5zdHlmbiQyLmdldERlZmF1bHRQcm9wZXJ0eSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiB0aGlzLmdldERlZmF1bHRQcm9wZXJ0aWVzKClbbmFtZV07XG59O1xuc3R5Zm4kMi5nZXREZWZhdWx0UHJvcGVydGllcyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZTtcbiAgaWYgKF9wLmRlZmF1bHRQcm9wZXJ0aWVzICE9IG51bGwpIHtcbiAgICByZXR1cm4gX3AuZGVmYXVsdFByb3BlcnRpZXM7XG4gIH1cbiAgdmFyIHJhd1Byb3BzID0gZXh0ZW5kKHtcbiAgICAvLyBjb3JlIHByb3BzXG4gICAgJ3NlbGVjdGlvbi1ib3gtY29sb3InOiAnI2RkZCcsXG4gICAgJ3NlbGVjdGlvbi1ib3gtb3BhY2l0eSc6IDAuNjUsXG4gICAgJ3NlbGVjdGlvbi1ib3gtYm9yZGVyLWNvbG9yJzogJyNhYWEnLFxuICAgICdzZWxlY3Rpb24tYm94LWJvcmRlci13aWR0aCc6IDEsXG4gICAgJ2FjdGl2ZS1iZy1jb2xvcic6ICdibGFjaycsXG4gICAgJ2FjdGl2ZS1iZy1vcGFjaXR5JzogMC4xNSxcbiAgICAnYWN0aXZlLWJnLXNpemUnOiAzMCxcbiAgICAnb3V0c2lkZS10ZXh0dXJlLWJnLWNvbG9yJzogJyMwMDAnLFxuICAgICdvdXRzaWRlLXRleHR1cmUtYmctb3BhY2l0eSc6IDAuMTI1LFxuICAgIC8vIGNvbW1vbiBub2RlL2VkZ2UgcHJvcHNcbiAgICAnZXZlbnRzJzogJ3llcycsXG4gICAgJ3RleHQtZXZlbnRzJzogJ25vJyxcbiAgICAndGV4dC12YWxpZ24nOiAndG9wJyxcbiAgICAndGV4dC1oYWxpZ24nOiAnY2VudGVyJyxcbiAgICAndGV4dC1qdXN0aWZpY2F0aW9uJzogJ2F1dG8nLFxuICAgICdsaW5lLWhlaWdodCc6IDEsXG4gICAgJ2NvbG9yJzogJyMwMDAnLFxuICAgICd0ZXh0LW91dGxpbmUtY29sb3InOiAnIzAwMCcsXG4gICAgJ3RleHQtb3V0bGluZS13aWR0aCc6IDAsXG4gICAgJ3RleHQtb3V0bGluZS1vcGFjaXR5JzogMSxcbiAgICAndGV4dC1vcGFjaXR5JzogMSxcbiAgICAndGV4dC1kZWNvcmF0aW9uJzogJ25vbmUnLFxuICAgICd0ZXh0LXRyYW5zZm9ybSc6ICdub25lJyxcbiAgICAndGV4dC13cmFwJzogJ25vbmUnLFxuICAgICd0ZXh0LW92ZXJmbG93LXdyYXAnOiAnd2hpdGVzcGFjZScsXG4gICAgJ3RleHQtbWF4LXdpZHRoJzogOTk5OSxcbiAgICAndGV4dC1iYWNrZ3JvdW5kLWNvbG9yJzogJyMwMDAnLFxuICAgICd0ZXh0LWJhY2tncm91bmQtb3BhY2l0eSc6IDAsXG4gICAgJ3RleHQtYmFja2dyb3VuZC1zaGFwZSc6ICdyZWN0YW5nbGUnLFxuICAgICd0ZXh0LWJhY2tncm91bmQtcGFkZGluZyc6IDAsXG4gICAgJ3RleHQtYm9yZGVyLW9wYWNpdHknOiAwLFxuICAgICd0ZXh0LWJvcmRlci13aWR0aCc6IDAsXG4gICAgJ3RleHQtYm9yZGVyLXN0eWxlJzogJ3NvbGlkJyxcbiAgICAndGV4dC1ib3JkZXItY29sb3InOiAnIzAwMCcsXG4gICAgJ2ZvbnQtZmFtaWx5JzogJ0hlbHZldGljYSBOZXVlLCBIZWx2ZXRpY2EsIHNhbnMtc2VyaWYnLFxuICAgICdmb250LXN0eWxlJzogJ25vcm1hbCcsXG4gICAgJ2ZvbnQtd2VpZ2h0JzogJ25vcm1hbCcsXG4gICAgJ2ZvbnQtc2l6ZSc6IDE2LFxuICAgICdtaW4tem9vbWVkLWZvbnQtc2l6ZSc6IDAsXG4gICAgJ3RleHQtcm90YXRpb24nOiAnbm9uZScsXG4gICAgJ3NvdXJjZS10ZXh0LXJvdGF0aW9uJzogJ25vbmUnLFxuICAgICd0YXJnZXQtdGV4dC1yb3RhdGlvbic6ICdub25lJyxcbiAgICAndmlzaWJpbGl0eSc6ICd2aXNpYmxlJyxcbiAgICAnZGlzcGxheSc6ICdlbGVtZW50JyxcbiAgICAnb3BhY2l0eSc6IDEsXG4gICAgJ3otY29tcG91bmQtZGVwdGgnOiAnYXV0bycsXG4gICAgJ3otaW5kZXgtY29tcGFyZSc6ICdhdXRvJyxcbiAgICAnei1pbmRleCc6IDAsXG4gICAgJ2xhYmVsJzogJycsXG4gICAgJ3RleHQtbWFyZ2luLXgnOiAwLFxuICAgICd0ZXh0LW1hcmdpbi15JzogMCxcbiAgICAnc291cmNlLWxhYmVsJzogJycsXG4gICAgJ3NvdXJjZS10ZXh0LW9mZnNldCc6IDAsXG4gICAgJ3NvdXJjZS10ZXh0LW1hcmdpbi14JzogMCxcbiAgICAnc291cmNlLXRleHQtbWFyZ2luLXknOiAwLFxuICAgICd0YXJnZXQtbGFiZWwnOiAnJyxcbiAgICAndGFyZ2V0LXRleHQtb2Zmc2V0JzogMCxcbiAgICAndGFyZ2V0LXRleHQtbWFyZ2luLXgnOiAwLFxuICAgICd0YXJnZXQtdGV4dC1tYXJnaW4teSc6IDAsXG4gICAgJ292ZXJsYXktb3BhY2l0eSc6IDAsXG4gICAgJ292ZXJsYXktY29sb3InOiAnIzAwMCcsXG4gICAgJ292ZXJsYXktcGFkZGluZyc6IDEwLFxuICAgICdvdmVybGF5LXNoYXBlJzogJ3JvdW5kLXJlY3RhbmdsZScsXG4gICAgJ292ZXJsYXktY29ybmVyLXJhZGl1cyc6ICdhdXRvJyxcbiAgICAndW5kZXJsYXktb3BhY2l0eSc6IDAsXG4gICAgJ3VuZGVybGF5LWNvbG9yJzogJyMwMDAnLFxuICAgICd1bmRlcmxheS1wYWRkaW5nJzogMTAsXG4gICAgJ3VuZGVybGF5LXNoYXBlJzogJ3JvdW5kLXJlY3RhbmdsZScsXG4gICAgJ3VuZGVybGF5LWNvcm5lci1yYWRpdXMnOiAnYXV0bycsXG4gICAgJ3RyYW5zaXRpb24tcHJvcGVydHknOiAnbm9uZScsXG4gICAgJ3RyYW5zaXRpb24tZHVyYXRpb24nOiAwLFxuICAgICd0cmFuc2l0aW9uLWRlbGF5JzogMCxcbiAgICAndHJhbnNpdGlvbi10aW1pbmctZnVuY3Rpb24nOiAnbGluZWFyJyxcbiAgICAvLyBub2RlIHByb3BzXG4gICAgJ2JhY2tncm91bmQtYmxhY2tlbic6IDAsXG4gICAgJ2JhY2tncm91bmQtY29sb3InOiAnIzk5OScsXG4gICAgJ2JhY2tncm91bmQtZmlsbCc6ICdzb2xpZCcsXG4gICAgJ2JhY2tncm91bmQtb3BhY2l0eSc6IDEsXG4gICAgJ2JhY2tncm91bmQtaW1hZ2UnOiAnbm9uZScsXG4gICAgJ2JhY2tncm91bmQtaW1hZ2UtY3Jvc3NvcmlnaW4nOiAnYW5vbnltb3VzJyxcbiAgICAnYmFja2dyb3VuZC1pbWFnZS1vcGFjaXR5JzogMSxcbiAgICAnYmFja2dyb3VuZC1pbWFnZS1jb250YWlubWVudCc6ICdpbnNpZGUnLFxuICAgICdiYWNrZ3JvdW5kLWltYWdlLXNtb290aGluZyc6ICd5ZXMnLFxuICAgICdiYWNrZ3JvdW5kLXBvc2l0aW9uLXgnOiAnNTAlJyxcbiAgICAnYmFja2dyb3VuZC1wb3NpdGlvbi15JzogJzUwJScsXG4gICAgJ2JhY2tncm91bmQtb2Zmc2V0LXgnOiAwLFxuICAgICdiYWNrZ3JvdW5kLW9mZnNldC15JzogMCxcbiAgICAnYmFja2dyb3VuZC13aWR0aC1yZWxhdGl2ZS10byc6ICdpbmNsdWRlLXBhZGRpbmcnLFxuICAgICdiYWNrZ3JvdW5kLWhlaWdodC1yZWxhdGl2ZS10byc6ICdpbmNsdWRlLXBhZGRpbmcnLFxuICAgICdiYWNrZ3JvdW5kLXJlcGVhdCc6ICduby1yZXBlYXQnLFxuICAgICdiYWNrZ3JvdW5kLWZpdCc6ICdub25lJyxcbiAgICAnYmFja2dyb3VuZC1jbGlwJzogJ25vZGUnLFxuICAgICdiYWNrZ3JvdW5kLXdpZHRoJzogJ2F1dG8nLFxuICAgICdiYWNrZ3JvdW5kLWhlaWdodCc6ICdhdXRvJyxcbiAgICAnYm9yZGVyLWNvbG9yJzogJyMwMDAnLFxuICAgICdib3JkZXItb3BhY2l0eSc6IDEsXG4gICAgJ2JvcmRlci13aWR0aCc6IDAsXG4gICAgJ2JvcmRlci1zdHlsZSc6ICdzb2xpZCcsXG4gICAgJ2JvcmRlci1kYXNoLXBhdHRlcm4nOiBbNCwgMl0sXG4gICAgJ2JvcmRlci1kYXNoLW9mZnNldCc6IDAsXG4gICAgJ2JvcmRlci1jYXAnOiAnYnV0dCcsXG4gICAgJ2JvcmRlci1qb2luJzogJ21pdGVyJyxcbiAgICAnYm9yZGVyLXBvc2l0aW9uJzogJ2NlbnRlcicsXG4gICAgJ291dGxpbmUtY29sb3InOiAnIzk5OScsXG4gICAgJ291dGxpbmUtb3BhY2l0eSc6IDEsXG4gICAgJ291dGxpbmUtd2lkdGgnOiAwLFxuICAgICdvdXRsaW5lLW9mZnNldCc6IDAsXG4gICAgJ291dGxpbmUtc3R5bGUnOiAnc29saWQnLFxuICAgICdoZWlnaHQnOiAzMCxcbiAgICAnd2lkdGgnOiAzMCxcbiAgICAnc2hhcGUnOiAnZWxsaXBzZScsXG4gICAgJ3NoYXBlLXBvbHlnb24tcG9pbnRzJzogJy0xLCAtMSwgICAxLCAtMSwgICAxLCAxLCAgIC0xLCAxJyxcbiAgICAnY29ybmVyLXJhZGl1cyc6ICdhdXRvJyxcbiAgICAnYm91bmRzLWV4cGFuc2lvbic6IDAsXG4gICAgLy8gbm9kZSBncmFkaWVudFxuICAgICdiYWNrZ3JvdW5kLWdyYWRpZW50LWRpcmVjdGlvbic6ICd0by1ib3R0b20nLFxuICAgICdiYWNrZ3JvdW5kLWdyYWRpZW50LXN0b3AtY29sb3JzJzogJyM5OTknLFxuICAgICdiYWNrZ3JvdW5kLWdyYWRpZW50LXN0b3AtcG9zaXRpb25zJzogJzAlJyxcbiAgICAvLyBnaG9zdCBwcm9wc1xuICAgICdnaG9zdCc6ICdubycsXG4gICAgJ2dob3N0LW9mZnNldC15JzogMCxcbiAgICAnZ2hvc3Qtb2Zmc2V0LXgnOiAwLFxuICAgICdnaG9zdC1vcGFjaXR5JzogMCxcbiAgICAvLyBjb21wb3VuZCBwcm9wc1xuICAgICdwYWRkaW5nJzogMCxcbiAgICAncGFkZGluZy1yZWxhdGl2ZS10byc6ICd3aWR0aCcsXG4gICAgJ3Bvc2l0aW9uJzogJ29yaWdpbicsXG4gICAgJ2NvbXBvdW5kLXNpemluZy13cnQtbGFiZWxzJzogJ2luY2x1ZGUnLFxuICAgICdtaW4td2lkdGgnOiAwLFxuICAgICdtaW4td2lkdGgtYmlhcy1sZWZ0JzogMCxcbiAgICAnbWluLXdpZHRoLWJpYXMtcmlnaHQnOiAwLFxuICAgICdtaW4taGVpZ2h0JzogMCxcbiAgICAnbWluLWhlaWdodC1iaWFzLXRvcCc6IDAsXG4gICAgJ21pbi1oZWlnaHQtYmlhcy1ib3R0b20nOiAwXG4gIH0sIHtcbiAgICAvLyBub2RlIHBpZSBiZ1xuICAgICdwaWUtc2l6ZSc6ICcxMDAlJ1xuICB9LCBbe1xuICAgIG5hbWU6ICdwaWUte3tpfX0tYmFja2dyb3VuZC1jb2xvcicsXG4gICAgdmFsdWU6ICdibGFjaydcbiAgfSwge1xuICAgIG5hbWU6ICdwaWUte3tpfX0tYmFja2dyb3VuZC1zaXplJyxcbiAgICB2YWx1ZTogJzAlJ1xuICB9LCB7XG4gICAgbmFtZTogJ3BpZS17e2l9fS1iYWNrZ3JvdW5kLW9wYWNpdHknLFxuICAgIHZhbHVlOiAxXG4gIH1dLnJlZHVjZShmdW5jdGlvbiAoY3NzLCBwcm9wKSB7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPD0gc3R5Zm4kMi5waWVCYWNrZ3JvdW5kTjsgaSsrKSB7XG4gICAgICB2YXIgbmFtZSA9IHByb3AubmFtZS5yZXBsYWNlKCd7e2l9fScsIGkpO1xuICAgICAgdmFyIHZhbCA9IHByb3AudmFsdWU7XG4gICAgICBjc3NbbmFtZV0gPSB2YWw7XG4gICAgfVxuICAgIHJldHVybiBjc3M7XG4gIH0sIHt9KSwge1xuICAgIC8vIGVkZ2UgcHJvcHNcbiAgICAnbGluZS1zdHlsZSc6ICdzb2xpZCcsXG4gICAgJ2xpbmUtY29sb3InOiAnIzk5OScsXG4gICAgJ2xpbmUtZmlsbCc6ICdzb2xpZCcsXG4gICAgJ2xpbmUtY2FwJzogJ2J1dHQnLFxuICAgICdsaW5lLW9wYWNpdHknOiAxLFxuICAgICdsaW5lLW91dGxpbmUtd2lkdGgnOiAwLFxuICAgICdsaW5lLW91dGxpbmUtY29sb3InOiAnIzAwMCcsXG4gICAgJ2xpbmUtZ3JhZGllbnQtc3RvcC1jb2xvcnMnOiAnIzk5OScsXG4gICAgJ2xpbmUtZ3JhZGllbnQtc3RvcC1wb3NpdGlvbnMnOiAnMCUnLFxuICAgICdjb250cm9sLXBvaW50LXN0ZXAtc2l6ZSc6IDQwLFxuICAgICdjb250cm9sLXBvaW50LXdlaWdodHMnOiAwLjUsXG4gICAgJ3NlZ21lbnQtd2VpZ2h0cyc6IDAuNSxcbiAgICAnc2VnbWVudC1kaXN0YW5jZXMnOiAyMCxcbiAgICAnc2VnbWVudC1yYWRpaSc6IDE1LFxuICAgICdyYWRpdXMtdHlwZSc6ICdhcmMtcmFkaXVzJyxcbiAgICAndGF4aS10dXJuJzogJzUwJScsXG4gICAgJ3RheGktcmFkaXVzJzogMTUsXG4gICAgJ3RheGktdHVybi1taW4tZGlzdGFuY2UnOiAxMCxcbiAgICAndGF4aS1kaXJlY3Rpb24nOiAnYXV0bycsXG4gICAgJ2VkZ2UtZGlzdGFuY2VzJzogJ2ludGVyc2VjdGlvbicsXG4gICAgJ2N1cnZlLXN0eWxlJzogJ2hheXN0YWNrJyxcbiAgICAnaGF5c3RhY2stcmFkaXVzJzogMCxcbiAgICAnYXJyb3ctc2NhbGUnOiAxLFxuICAgICdsb29wLWRpcmVjdGlvbic6ICctNDVkZWcnLFxuICAgICdsb29wLXN3ZWVwJzogJy05MGRlZycsXG4gICAgJ3NvdXJjZS1kaXN0YW5jZS1mcm9tLW5vZGUnOiAwLFxuICAgICd0YXJnZXQtZGlzdGFuY2UtZnJvbS1ub2RlJzogMCxcbiAgICAnc291cmNlLWVuZHBvaW50JzogJ291dHNpZGUtdG8tbm9kZScsXG4gICAgJ3RhcmdldC1lbmRwb2ludCc6ICdvdXRzaWRlLXRvLW5vZGUnLFxuICAgICdsaW5lLWRhc2gtcGF0dGVybic6IFs2LCAzXSxcbiAgICAnbGluZS1kYXNoLW9mZnNldCc6IDBcbiAgfSwgW3tcbiAgICBuYW1lOiAnYXJyb3ctc2hhcGUnLFxuICAgIHZhbHVlOiAnbm9uZSdcbiAgfSwge1xuICAgIG5hbWU6ICdhcnJvdy1jb2xvcicsXG4gICAgdmFsdWU6ICcjOTk5J1xuICB9LCB7XG4gICAgbmFtZTogJ2Fycm93LWZpbGwnLFxuICAgIHZhbHVlOiAnZmlsbGVkJ1xuICB9LCB7XG4gICAgbmFtZTogJ2Fycm93LXdpZHRoJyxcbiAgICB2YWx1ZTogMVxuICB9XS5yZWR1Y2UoZnVuY3Rpb24gKGNzcywgcHJvcCkge1xuICAgIHN0eWZuJDIuYXJyb3dQcmVmaXhlcy5mb3JFYWNoKGZ1bmN0aW9uIChwcmVmaXgpIHtcbiAgICAgIHZhciBuYW1lID0gcHJlZml4ICsgJy0nICsgcHJvcC5uYW1lO1xuICAgICAgdmFyIHZhbCA9IHByb3AudmFsdWU7XG4gICAgICBjc3NbbmFtZV0gPSB2YWw7XG4gICAgfSk7XG4gICAgcmV0dXJuIGNzcztcbiAgfSwge30pKTtcbiAgdmFyIHBhcnNlZFByb3BzID0ge307XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5wcm9wZXJ0aWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHByb3AgPSB0aGlzLnByb3BlcnRpZXNbaV07XG4gICAgaWYgKHByb3AucG9pbnRzVG8pIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB2YXIgbmFtZSA9IHByb3AubmFtZTtcbiAgICB2YXIgdmFsID0gcmF3UHJvcHNbbmFtZV07XG4gICAgdmFyIHBhcnNlZFByb3AgPSB0aGlzLnBhcnNlKG5hbWUsIHZhbCk7XG4gICAgcGFyc2VkUHJvcHNbbmFtZV0gPSBwYXJzZWRQcm9wO1xuICB9XG4gIF9wLmRlZmF1bHRQcm9wZXJ0aWVzID0gcGFyc2VkUHJvcHM7XG4gIHJldHVybiBfcC5kZWZhdWx0UHJvcGVydGllcztcbn07XG5zdHlmbiQyLmFkZERlZmF1bHRTdHlsZXNoZWV0ID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLnNlbGVjdG9yKCc6cGFyZW50JykuY3NzKHtcbiAgICAnc2hhcGUnOiAncmVjdGFuZ2xlJyxcbiAgICAncGFkZGluZyc6IDEwLFxuICAgICdiYWNrZ3JvdW5kLWNvbG9yJzogJyNlZWUnLFxuICAgICdib3JkZXItY29sb3InOiAnI2NjYycsXG4gICAgJ2JvcmRlci13aWR0aCc6IDFcbiAgfSkuc2VsZWN0b3IoJ2VkZ2UnKS5jc3Moe1xuICAgICd3aWR0aCc6IDNcbiAgfSkuc2VsZWN0b3IoJzpsb29wJykuY3NzKHtcbiAgICAnY3VydmUtc3R5bGUnOiAnYmV6aWVyJ1xuICB9KS5zZWxlY3RvcignZWRnZTpjb21wb3VuZCcpLmNzcyh7XG4gICAgJ2N1cnZlLXN0eWxlJzogJ2JlemllcicsXG4gICAgJ3NvdXJjZS1lbmRwb2ludCc6ICdvdXRzaWRlLXRvLWxpbmUnLFxuICAgICd0YXJnZXQtZW5kcG9pbnQnOiAnb3V0c2lkZS10by1saW5lJ1xuICB9KS5zZWxlY3RvcignOnNlbGVjdGVkJykuY3NzKHtcbiAgICAnYmFja2dyb3VuZC1jb2xvcic6ICcjMDE2OUQ5JyxcbiAgICAnbGluZS1jb2xvcic6ICcjMDE2OUQ5JyxcbiAgICAnc291cmNlLWFycm93LWNvbG9yJzogJyMwMTY5RDknLFxuICAgICd0YXJnZXQtYXJyb3ctY29sb3InOiAnIzAxNjlEOScsXG4gICAgJ21pZC1zb3VyY2UtYXJyb3ctY29sb3InOiAnIzAxNjlEOScsXG4gICAgJ21pZC10YXJnZXQtYXJyb3ctY29sb3InOiAnIzAxNjlEOSdcbiAgfSkuc2VsZWN0b3IoJzpwYXJlbnQ6c2VsZWN0ZWQnKS5jc3Moe1xuICAgICdiYWNrZ3JvdW5kLWNvbG9yJzogJyNDQ0UxRjknLFxuICAgICdib3JkZXItY29sb3InOiAnI2FlYzhlNSdcbiAgfSkuc2VsZWN0b3IoJzphY3RpdmUnKS5jc3Moe1xuICAgICdvdmVybGF5LWNvbG9yJzogJ2JsYWNrJyxcbiAgICAnb3ZlcmxheS1wYWRkaW5nJzogMTAsXG4gICAgJ292ZXJsYXktb3BhY2l0eSc6IDAuMjVcbiAgfSk7XG4gIHRoaXMuZGVmYXVsdExlbmd0aCA9IHRoaXMubGVuZ3RoO1xufTtcblxudmFyIHN0eWZuJDEgPSB7fTtcblxuLy8gYSBjYWNoaW5nIGxheWVyIGZvciBwcm9wZXJ0eSBwYXJzaW5nXG5zdHlmbiQxLnBhcnNlID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlLCBwcm9wSXNCeXBhc3MsIHByb3BJc0ZsYXQpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIC8vIGZ1bmN0aW9uIHZhbHVlcyBjYW4ndCBiZSBjYWNoZWQgaW4gYWxsIGNhc2VzLCBhbmQgdGhlcmUgaXNuJ3QgbXVjaCBiZW5lZml0IG9mIGNhY2hpbmcgdGhlbSBhbnl3YXlcbiAgaWYgKGZuJDYodmFsdWUpKSB7XG4gICAgcmV0dXJuIHNlbGYucGFyc2VJbXBsV2FybihuYW1lLCB2YWx1ZSwgcHJvcElzQnlwYXNzLCBwcm9wSXNGbGF0KTtcbiAgfVxuICB2YXIgZmxhdEtleSA9IHByb3BJc0ZsYXQgPT09ICdtYXBwaW5nJyB8fCBwcm9wSXNGbGF0ID09PSB0cnVlIHx8IHByb3BJc0ZsYXQgPT09IGZhbHNlIHx8IHByb3BJc0ZsYXQgPT0gbnVsbCA/ICdkb250Y2FyZScgOiBwcm9wSXNGbGF0O1xuICB2YXIgYnlwYXNzS2V5ID0gcHJvcElzQnlwYXNzID8gJ3QnIDogJ2YnO1xuICB2YXIgdmFsdWVLZXkgPSAnJyArIHZhbHVlO1xuICB2YXIgYXJnSGFzaCA9IGhhc2hTdHJpbmdzKG5hbWUsIHZhbHVlS2V5LCBieXBhc3NLZXksIGZsYXRLZXkpO1xuICB2YXIgcHJvcENhY2hlID0gc2VsZi5wcm9wQ2FjaGUgPSBzZWxmLnByb3BDYWNoZSB8fCBbXTtcbiAgdmFyIHJldDtcbiAgaWYgKCEocmV0ID0gcHJvcENhY2hlW2FyZ0hhc2hdKSkge1xuICAgIHJldCA9IHByb3BDYWNoZVthcmdIYXNoXSA9IHNlbGYucGFyc2VJbXBsV2FybihuYW1lLCB2YWx1ZSwgcHJvcElzQnlwYXNzLCBwcm9wSXNGbGF0KTtcbiAgfVxuXG4gIC8vIC0gYnlwYXNzZXMgY2FuJ3QgYmUgc2hhcmVkIGIvYyB0aGUgdmFsdWUgY2FuIGJlIGNoYW5nZWQgYnkgYW5pbWF0aW9ucyBvciBvdGhlcndpc2Ugb3ZlcnJpZGRlblxuICAvLyAtIG1hcHBpbmdzIGNhbid0IGJlIHNoYXJlZCBiL2MgbWFwcGluZ3MgYXJlIHBlci1lbGVtZW50XG4gIGlmIChwcm9wSXNCeXBhc3MgfHwgcHJvcElzRmxhdCA9PT0gJ21hcHBpbmcnKSB7XG4gICAgLy8gbmVlZCBhIGNvcHkgc2luY2UgcHJvcHMgYXJlIG11dGF0ZWQgbGF0ZXIgaW4gdGhlaXIgbGlmZWN5Y2xlc1xuICAgIHJldCA9IGNvcHkocmV0KTtcbiAgICBpZiAocmV0KSB7XG4gICAgICByZXQudmFsdWUgPSBjb3B5KHJldC52YWx1ZSk7IC8vIGJlY2F1c2UgaXQgY291bGQgYmUgYW4gYXJyYXksIGUuZy4gY29sb3VyXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJldDtcbn07XG5zdHlmbiQxLnBhcnNlSW1wbFdhcm4gPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUsIHByb3BJc0J5cGFzcywgcHJvcElzRmxhdCkge1xuICB2YXIgcHJvcCA9IHRoaXMucGFyc2VJbXBsKG5hbWUsIHZhbHVlLCBwcm9wSXNCeXBhc3MsIHByb3BJc0ZsYXQpO1xuICBpZiAoIXByb3AgJiYgdmFsdWUgIT0gbnVsbCkge1xuICAgIHdhcm4oXCJUaGUgc3R5bGUgcHJvcGVydHkgYFwiLmNvbmNhdChuYW1lLCBcIjogXCIpLmNvbmNhdCh2YWx1ZSwgXCJgIGlzIGludmFsaWRcIikpO1xuICB9XG4gIGlmIChwcm9wICYmIChwcm9wLm5hbWUgPT09ICd3aWR0aCcgfHwgcHJvcC5uYW1lID09PSAnaGVpZ2h0JykgJiYgdmFsdWUgPT09ICdsYWJlbCcpIHtcbiAgICB3YXJuKCdUaGUgc3R5bGUgdmFsdWUgb2YgYGxhYmVsYCBpcyBkZXByZWNhdGVkIGZvciBgJyArIHByb3AubmFtZSArICdgJyk7XG4gIH1cbiAgcmV0dXJuIHByb3A7XG59O1xuXG4vLyBwYXJzZSBhIHByb3BlcnR5OyByZXR1cm4gbnVsbCBvbiBpbnZhbGlkOyByZXR1cm4gcGFyc2VkIHByb3BlcnR5IG90aGVyd2lzZVxuLy8gZmllbGRzIDpcbi8vIC0gbmFtZSA6IHRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eVxuLy8gLSB2YWx1ZSA6IHRoZSBwYXJzZWQsIG5hdGl2ZS10eXBlZCB2YWx1ZSBvZiB0aGUgcHJvcGVydHlcbi8vIC0gc3RyVmFsdWUgOiBhIHN0cmluZyB2YWx1ZSB0aGF0IHJlcHJlc2VudHMgdGhlIHByb3BlcnR5IHZhbHVlIGluIHZhbGlkIGNzc1xuLy8gLSBieXBhc3MgOiB0cnVlIGlmZiB0aGUgcHJvcGVydHkgaXMgYSBieXBhc3MgcHJvcGVydHlcbnN0eWZuJDEucGFyc2VJbXBsID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlLCBwcm9wSXNCeXBhc3MsIHByb3BJc0ZsYXQpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBuYW1lID0gY2FtZWwyZGFzaChuYW1lKTsgLy8gbWFrZSBzdXJlIHRoZSBwcm9wZXJ0eSBuYW1lIGlzIGluIGRhc2ggZm9ybSAoZS5nLiAncHJvcGVydHktbmFtZScgbm90ICdwcm9wZXJ0eU5hbWUnKVxuXG4gIHZhciBwcm9wZXJ0eSA9IHNlbGYucHJvcGVydGllc1tuYW1lXTtcbiAgdmFyIHBhc3NlZFZhbHVlID0gdmFsdWU7XG4gIHZhciB0eXBlcyA9IHNlbGYudHlwZXM7XG4gIGlmICghcHJvcGVydHkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfSAvLyByZXR1cm4gbnVsbCBvbiBwcm9wZXJ0eSBvZiB1bmtub3duIG5hbWVcbiAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfSAvLyBjYW4ndCBhc3NpZ24gdW5kZWZpbmVkXG5cbiAgLy8gdGhlIHByb3BlcnR5IG1heSBiZSBhbiBhbGlhc1xuICBpZiAocHJvcGVydHkuYWxpYXMpIHtcbiAgICBwcm9wZXJ0eSA9IHByb3BlcnR5LnBvaW50c1RvO1xuICAgIG5hbWUgPSBwcm9wZXJ0eS5uYW1lO1xuICB9XG4gIHZhciB2YWx1ZUlzU3RyaW5nID0gc3RyaW5nKHZhbHVlKTtcbiAgaWYgKHZhbHVlSXNTdHJpbmcpIHtcbiAgICAvLyB0cmltIHRoZSB2YWx1ZSB0byBtYWtlIHBhcnNpbmcgZWFzaWVyXG4gICAgdmFsdWUgPSB2YWx1ZS50cmltKCk7XG4gIH1cbiAgdmFyIHR5cGUgPSBwcm9wZXJ0eS50eXBlO1xuICBpZiAoIXR5cGUpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfSAvLyBubyB0eXBlLCBubyBsdWNrXG5cbiAgLy8gY2hlY2sgaWYgYnlwYXNzIGlzIG51bGwgb3IgZW1wdHkgc3RyaW5nIChpLmUuIGluZGljYXRpb24gdG8gZGVsZXRlIGJ5cGFzcyBwcm9wZXJ0eSlcbiAgaWYgKHByb3BJc0J5cGFzcyAmJiAodmFsdWUgPT09ICcnIHx8IHZhbHVlID09PSBudWxsKSkge1xuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiBuYW1lLFxuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgYnlwYXNzOiB0cnVlLFxuICAgICAgZGVsZXRlQnlwYXNzOiB0cnVlXG4gICAgfTtcbiAgfVxuXG4gIC8vIGNoZWNrIGlmIHZhbHVlIGlzIGEgZnVuY3Rpb24gdXNlZCBhcyBhIG1hcHBlclxuICBpZiAoZm4kNih2YWx1ZSkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogbmFtZSxcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIHN0clZhbHVlOiAnZm4nLFxuICAgICAgbWFwcGVkOiB0eXBlcy5mbixcbiAgICAgIGJ5cGFzczogcHJvcElzQnlwYXNzXG4gICAgfTtcbiAgfVxuXG4gIC8vIGNoZWNrIGlmIHZhbHVlIGlzIG1hcHBlZFxuICB2YXIgZGF0YSwgbWFwRGF0YTtcbiAgaWYgKCF2YWx1ZUlzU3RyaW5nIHx8IHByb3BJc0ZsYXQgfHwgdmFsdWUubGVuZ3RoIDwgNyB8fCB2YWx1ZVsxXSAhPT0gJ2EnKSA7IGVsc2UgaWYgKHZhbHVlLmxlbmd0aCA+PSA3ICYmIHZhbHVlWzBdID09PSAnZCcgJiYgKGRhdGEgPSBuZXcgUmVnRXhwKHR5cGVzLmRhdGEucmVnZXgpLmV4ZWModmFsdWUpKSkge1xuICAgIGlmIChwcm9wSXNCeXBhc3MpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IC8vIG1hcHBlcnMgbm90IGFsbG93ZWQgaW4gYnlwYXNzXG5cbiAgICB2YXIgbWFwcGVkID0gdHlwZXMuZGF0YTtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogbmFtZSxcbiAgICAgIHZhbHVlOiBkYXRhLFxuICAgICAgc3RyVmFsdWU6ICcnICsgdmFsdWUsXG4gICAgICBtYXBwZWQ6IG1hcHBlZCxcbiAgICAgIGZpZWxkOiBkYXRhWzFdLFxuICAgICAgYnlwYXNzOiBwcm9wSXNCeXBhc3NcbiAgICB9O1xuICB9IGVsc2UgaWYgKHZhbHVlLmxlbmd0aCA+PSAxMCAmJiB2YWx1ZVswXSA9PT0gJ20nICYmIChtYXBEYXRhID0gbmV3IFJlZ0V4cCh0eXBlcy5tYXBEYXRhLnJlZ2V4KS5leGVjKHZhbHVlKSkpIHtcbiAgICBpZiAocHJvcElzQnlwYXNzKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSAvLyBtYXBwZXJzIG5vdCBhbGxvd2VkIGluIGJ5cGFzc1xuICAgIGlmICh0eXBlLm11bHRpcGxlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSAvLyBpbXBvc3NpYmxlIHRvIG1hcCB0byBudW1cblxuICAgIHZhciBfbWFwcGVkID0gdHlwZXMubWFwRGF0YTtcblxuICAgIC8vIHdlIGNhbiBtYXAgb25seSBpZiB0aGUgdHlwZSBpcyBhIGNvbG91ciBvciBhIG51bWJlclxuICAgIGlmICghKHR5cGUuY29sb3IgfHwgdHlwZS5udW1iZXIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHZhciB2YWx1ZU1pbiA9IHRoaXMucGFyc2UobmFtZSwgbWFwRGF0YVs0XSk7IC8vIHBhcnNlIHRvIHZhbGlkYXRlXG4gICAgaWYgKCF2YWx1ZU1pbiB8fCB2YWx1ZU1pbi5tYXBwZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IC8vIGNhbid0IGJlIGludmFsaWQgb3IgbWFwcGVkXG5cbiAgICB2YXIgdmFsdWVNYXggPSB0aGlzLnBhcnNlKG5hbWUsIG1hcERhdGFbNV0pOyAvLyBwYXJzZSB0byB2YWxpZGF0ZVxuICAgIGlmICghdmFsdWVNYXggfHwgdmFsdWVNYXgubWFwcGVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSAvLyBjYW4ndCBiZSBpbnZhbGlkIG9yIG1hcHBlZFxuXG4gICAgLy8gY2hlY2sgaWYgdmFsdWVNaW4gYW5kIHZhbHVlTWF4IGFyZSB0aGUgc2FtZVxuICAgIGlmICh2YWx1ZU1pbi5wZlZhbHVlID09PSB2YWx1ZU1heC5wZlZhbHVlIHx8IHZhbHVlTWluLnN0clZhbHVlID09PSB2YWx1ZU1heC5zdHJWYWx1ZSkge1xuICAgICAgd2FybignYCcgKyBuYW1lICsgJzogJyArIHZhbHVlICsgJ2AgaXMgbm90IGEgdmFsaWQgbWFwcGVyIGJlY2F1c2UgdGhlIG91dHB1dCByYW5nZSBpcyB6ZXJvOyBjb252ZXJ0aW5nIHRvIGAnICsgbmFtZSArICc6ICcgKyB2YWx1ZU1pbi5zdHJWYWx1ZSArICdgJyk7XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZShuYW1lLCB2YWx1ZU1pbi5zdHJWYWx1ZSk7IC8vIGNhbid0IG1ha2UgbXVjaCBvZiBhIG1hcHBlciB3aXRob3V0IGEgcmFuZ2VcbiAgICB9IGVsc2UgaWYgKHR5cGUuY29sb3IpIHtcbiAgICAgIHZhciBjMSA9IHZhbHVlTWluLnZhbHVlO1xuICAgICAgdmFyIGMyID0gdmFsdWVNYXgudmFsdWU7XG4gICAgICB2YXIgc2FtZSA9IGMxWzBdID09PSBjMlswXSAvLyByZWRcbiAgICAgICYmIGMxWzFdID09PSBjMlsxXSAvLyBncmVlblxuICAgICAgJiYgYzFbMl0gPT09IGMyWzJdIC8vIGJsdWVcbiAgICAgICYmIChcbiAgICAgIC8vIG9wdGlvbmFsIGFscGhhXG4gICAgICBjMVszXSA9PT0gYzJbM10gLy8gc2FtZSBhbHBoYSBvdXRyaWdodFxuICAgICAgfHwgKGMxWzNdID09IG51bGwgfHwgYzFbM10gPT09IDEgLy8gZnVsbCBvcGFjaXR5IGZvciBjb2xvdXIgMT9cbiAgICAgICkgJiYgKGMyWzNdID09IG51bGwgfHwgYzJbM10gPT09IDEpIC8vIGZ1bGwgb3BhY2l0eSBmb3IgY29sb3VyIDI/XG4gICAgICApO1xuXG4gICAgICBpZiAoc2FtZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IC8vIGNhbid0IG1ha2UgYSBtYXBwZXIgd2l0aG91dCBhIHJhbmdlXG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6IG5hbWUsXG4gICAgICB2YWx1ZTogbWFwRGF0YSxcbiAgICAgIHN0clZhbHVlOiAnJyArIHZhbHVlLFxuICAgICAgbWFwcGVkOiBfbWFwcGVkLFxuICAgICAgZmllbGQ6IG1hcERhdGFbMV0sXG4gICAgICBmaWVsZE1pbjogcGFyc2VGbG9hdChtYXBEYXRhWzJdKSxcbiAgICAgIC8vIG1pbiAmIG1heCBhcmUgbnVtZXJpY1xuICAgICAgZmllbGRNYXg6IHBhcnNlRmxvYXQobWFwRGF0YVszXSksXG4gICAgICB2YWx1ZU1pbjogdmFsdWVNaW4udmFsdWUsXG4gICAgICB2YWx1ZU1heDogdmFsdWVNYXgudmFsdWUsXG4gICAgICBieXBhc3M6IHByb3BJc0J5cGFzc1xuICAgIH07XG4gIH1cbiAgaWYgKHR5cGUubXVsdGlwbGUgJiYgcHJvcElzRmxhdCAhPT0gJ211bHRpcGxlJykge1xuICAgIHZhciB2YWxzO1xuICAgIGlmICh2YWx1ZUlzU3RyaW5nKSB7XG4gICAgICB2YWxzID0gdmFsdWUuc3BsaXQoL1xccysvKTtcbiAgICB9IGVsc2UgaWYgKGFycmF5KHZhbHVlKSkge1xuICAgICAgdmFscyA9IHZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWxzID0gW3ZhbHVlXTtcbiAgICB9XG4gICAgaWYgKHR5cGUuZXZlbk11bHRpcGxlICYmIHZhbHMubGVuZ3RoICUgMiAhPT0gMCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciB2YWxBcnIgPSBbXTtcbiAgICB2YXIgdW5pdHNBcnIgPSBbXTtcbiAgICB2YXIgcGZWYWxBcnIgPSBbXTtcbiAgICB2YXIgc3RyVmFsID0gJyc7XG4gICAgdmFyIGhhc0VudW0gPSBmYWxzZTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBwID0gc2VsZi5wYXJzZShuYW1lLCB2YWxzW2ldLCBwcm9wSXNCeXBhc3MsICdtdWx0aXBsZScpO1xuICAgICAgaGFzRW51bSA9IGhhc0VudW0gfHwgc3RyaW5nKHAudmFsdWUpO1xuICAgICAgdmFsQXJyLnB1c2gocC52YWx1ZSk7XG4gICAgICBwZlZhbEFyci5wdXNoKHAucGZWYWx1ZSAhPSBudWxsID8gcC5wZlZhbHVlIDogcC52YWx1ZSk7XG4gICAgICB1bml0c0Fyci5wdXNoKHAudW5pdHMpO1xuICAgICAgc3RyVmFsICs9IChpID4gMCA/ICcgJyA6ICcnKSArIHAuc3RyVmFsdWU7XG4gICAgfVxuICAgIGlmICh0eXBlLnZhbGlkYXRlICYmICF0eXBlLnZhbGlkYXRlKHZhbEFyciwgdW5pdHNBcnIpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKHR5cGUuc2luZ2xlRW51bSAmJiBoYXNFbnVtKSB7XG4gICAgICBpZiAodmFsQXJyLmxlbmd0aCA9PT0gMSAmJiBzdHJpbmcodmFsQXJyWzBdKSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgdmFsdWU6IHZhbEFyclswXSxcbiAgICAgICAgICBzdHJWYWx1ZTogdmFsQXJyWzBdLFxuICAgICAgICAgIGJ5cGFzczogcHJvcElzQnlwYXNzXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6IG5hbWUsXG4gICAgICB2YWx1ZTogdmFsQXJyLFxuICAgICAgcGZWYWx1ZTogcGZWYWxBcnIsXG4gICAgICBzdHJWYWx1ZTogc3RyVmFsLFxuICAgICAgYnlwYXNzOiBwcm9wSXNCeXBhc3MsXG4gICAgICB1bml0czogdW5pdHNBcnJcbiAgICB9O1xuICB9XG5cbiAgLy8gc2V2ZXJhbCB0eXBlcyBhbHNvIGFsbG93IGVudW1zXG4gIHZhciBjaGVja0VudW1zID0gZnVuY3Rpb24gY2hlY2tFbnVtcygpIHtcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgdHlwZS5lbnVtcy5sZW5ndGg7IF9pKyspIHtcbiAgICAgIHZhciBlbiA9IHR5cGUuZW51bXNbX2ldO1xuICAgICAgaWYgKGVuID09PSB2YWx1ZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgIHN0clZhbHVlOiAnJyArIHZhbHVlLFxuICAgICAgICAgIGJ5cGFzczogcHJvcElzQnlwYXNzXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9O1xuXG4gIC8vIGNoZWNrIHRoZSB0eXBlIGFuZCByZXR1cm4gdGhlIGFwcHJvcHJpYXRlIG9iamVjdFxuICBpZiAodHlwZS5udW1iZXIpIHtcbiAgICB2YXIgdW5pdHM7XG4gICAgdmFyIGltcGxpY2l0VW5pdHMgPSAncHgnOyAvLyBub3Qgc2V0ID0+IHB4XG5cbiAgICBpZiAodHlwZS51bml0cykge1xuICAgICAgLy8gdXNlIHNwZWNpZmllZCB1bml0cyBpZiBzZXRcbiAgICAgIHVuaXRzID0gdHlwZS51bml0cztcbiAgICB9XG4gICAgaWYgKHR5cGUuaW1wbGljaXRVbml0cykge1xuICAgICAgaW1wbGljaXRVbml0cyA9IHR5cGUuaW1wbGljaXRVbml0cztcbiAgICB9XG4gICAgaWYgKCF0eXBlLnVuaXRsZXNzKSB7XG4gICAgICBpZiAodmFsdWVJc1N0cmluZykge1xuICAgICAgICB2YXIgdW5pdHNSZWdleCA9ICdweHxlbScgKyAodHlwZS5hbGxvd1BlcmNlbnQgPyAnfFxcXFwlJyA6ICcnKTtcbiAgICAgICAgaWYgKHVuaXRzKSB7XG4gICAgICAgICAgdW5pdHNSZWdleCA9IHVuaXRzO1xuICAgICAgICB9IC8vIG9ubHkgYWxsb3cgZXhwbGljaXQgdW5pdHMgaWYgc28gc2V0XG4gICAgICAgIHZhciBtYXRjaCA9IHZhbHVlLm1hdGNoKCdeKCcgKyBudW1iZXIgKyAnKSgnICsgdW5pdHNSZWdleCArICcpPycgKyAnJCcpO1xuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICB2YWx1ZSA9IG1hdGNoWzFdO1xuICAgICAgICAgIHVuaXRzID0gbWF0Y2hbMl0gfHwgaW1wbGljaXRVbml0cztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICghdW5pdHMgfHwgdHlwZS5pbXBsaWNpdFVuaXRzKSB7XG4gICAgICAgIHVuaXRzID0gaW1wbGljaXRVbml0czsgLy8gaW1wbGljaXRseSBweCBpZiB1bnNwZWNpZmllZFxuICAgICAgfVxuICAgIH1cblxuICAgIHZhbHVlID0gcGFyc2VGbG9hdCh2YWx1ZSk7XG5cbiAgICAvLyBpZiBub3QgYSBudW1iZXIgYW5kIGVudW1zIG5vdCBhbGxvd2VkLCB0aGVuIHRoZSB2YWx1ZSBpcyBpbnZhbGlkXG4gICAgaWYgKGlzTmFOKHZhbHVlKSAmJiB0eXBlLmVudW1zID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8vIGNoZWNrIGlmIHRoaXMgbnVtYmVyIHR5cGUgYWxzbyBhY2NlcHRzIHNwZWNpYWwga2V5d29yZHMgaW4gcGxhY2Ugb2YgbnVtYmVyc1xuICAgIC8vIChpLmUuIGBsZWZ0YCwgYGF1dG9gLCBldGMpXG4gICAgaWYgKGlzTmFOKHZhbHVlKSAmJiB0eXBlLmVudW1zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhbHVlID0gcGFzc2VkVmFsdWU7XG4gICAgICByZXR1cm4gY2hlY2tFbnVtcygpO1xuICAgIH1cblxuICAgIC8vIGNoZWNrIGlmIHZhbHVlIG11c3QgYmUgYW4gaW50ZWdlclxuICAgIGlmICh0eXBlLmludGVnZXIgJiYgIWludGVnZXIodmFsdWUpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBjaGVjayB2YWx1ZSBpcyB3aXRoaW4gcmFuZ2VcbiAgICBpZiAodHlwZS5taW4gIT09IHVuZGVmaW5lZCAmJiAodmFsdWUgPCB0eXBlLm1pbiB8fCB0eXBlLnN0cmljdE1pbiAmJiB2YWx1ZSA9PT0gdHlwZS5taW4pIHx8IHR5cGUubWF4ICE9PSB1bmRlZmluZWQgJiYgKHZhbHVlID4gdHlwZS5tYXggfHwgdHlwZS5zdHJpY3RNYXggJiYgdmFsdWUgPT09IHR5cGUubWF4KSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciByZXQgPSB7XG4gICAgICBuYW1lOiBuYW1lLFxuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgc3RyVmFsdWU6ICcnICsgdmFsdWUgKyAodW5pdHMgPyB1bml0cyA6ICcnKSxcbiAgICAgIHVuaXRzOiB1bml0cyxcbiAgICAgIGJ5cGFzczogcHJvcElzQnlwYXNzXG4gICAgfTtcblxuICAgIC8vIG5vcm1hbGlzZSB2YWx1ZSBpbiBwaXhlbHNcbiAgICBpZiAodHlwZS51bml0bGVzcyB8fCB1bml0cyAhPT0gJ3B4JyAmJiB1bml0cyAhPT0gJ2VtJykge1xuICAgICAgcmV0LnBmVmFsdWUgPSB2YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0LnBmVmFsdWUgPSB1bml0cyA9PT0gJ3B4JyB8fCAhdW5pdHMgPyB2YWx1ZSA6IHRoaXMuZ2V0RW1TaXplSW5QaXhlbHMoKSAqIHZhbHVlO1xuICAgIH1cblxuICAgIC8vIG5vcm1hbGlzZSB2YWx1ZSBpbiBtc1xuICAgIGlmICh1bml0cyA9PT0gJ21zJyB8fCB1bml0cyA9PT0gJ3MnKSB7XG4gICAgICByZXQucGZWYWx1ZSA9IHVuaXRzID09PSAnbXMnID8gdmFsdWUgOiAxMDAwICogdmFsdWU7XG4gICAgfVxuXG4gICAgLy8gbm9ybWFsaXNlIHZhbHVlIGluIHJhZFxuICAgIGlmICh1bml0cyA9PT0gJ2RlZycgfHwgdW5pdHMgPT09ICdyYWQnKSB7XG4gICAgICByZXQucGZWYWx1ZSA9IHVuaXRzID09PSAncmFkJyA/IHZhbHVlIDogZGVnMnJhZCh2YWx1ZSk7XG4gICAgfVxuXG4gICAgLy8gbm9ybWFsaXplIHZhbHVlIGluICVcbiAgICBpZiAodW5pdHMgPT09ICclJykge1xuICAgICAgcmV0LnBmVmFsdWUgPSB2YWx1ZSAvIDEwMDtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfSBlbHNlIGlmICh0eXBlLnByb3BMaXN0KSB7XG4gICAgdmFyIHByb3BzID0gW107XG4gICAgdmFyIHByb3BzU3RyID0gJycgKyB2YWx1ZTtcbiAgICBpZiAocHJvcHNTdHIgPT09ICdub25lJykgOyBlbHNlIHtcbiAgICAgIC8vIGdvIG92ZXIgZWFjaCBwcm9wXG5cbiAgICAgIHZhciBwcm9wc1NwbGl0ID0gcHJvcHNTdHIuc3BsaXQoL1xccyosXFxzKnxcXHMrLyk7XG4gICAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBwcm9wc1NwbGl0Lmxlbmd0aDsgX2kyKyspIHtcbiAgICAgICAgdmFyIHByb3BOYW1lID0gcHJvcHNTcGxpdFtfaTJdLnRyaW0oKTtcbiAgICAgICAgaWYgKHNlbGYucHJvcGVydGllc1twcm9wTmFtZV0pIHtcbiAgICAgICAgICBwcm9wcy5wdXNoKHByb3BOYW1lKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3YXJuKCdgJyArIHByb3BOYW1lICsgJ2AgaXMgbm90IGEgdmFsaWQgcHJvcGVydHkgbmFtZScpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocHJvcHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogbmFtZSxcbiAgICAgIHZhbHVlOiBwcm9wcyxcbiAgICAgIHN0clZhbHVlOiBwcm9wcy5sZW5ndGggPT09IDAgPyAnbm9uZScgOiBwcm9wcy5qb2luKCcgJyksXG4gICAgICBieXBhc3M6IHByb3BJc0J5cGFzc1xuICAgIH07XG4gIH0gZWxzZSBpZiAodHlwZS5jb2xvcikge1xuICAgIHZhciB0dXBsZSA9IGNvbG9yMnR1cGxlKHZhbHVlKTtcbiAgICBpZiAoIXR1cGxlKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6IG5hbWUsXG4gICAgICB2YWx1ZTogdHVwbGUsXG4gICAgICBwZlZhbHVlOiB0dXBsZSxcbiAgICAgIHN0clZhbHVlOiAncmdiKCcgKyB0dXBsZVswXSArICcsJyArIHR1cGxlWzFdICsgJywnICsgdHVwbGVbMl0gKyAnKScsXG4gICAgICAvLyBuLmIuIG5vIHNwYWNlcyBiL2Mgb2YgbXVsdGlwbGUgc3VwcG9ydFxuICAgICAgYnlwYXNzOiBwcm9wSXNCeXBhc3NcbiAgICB9O1xuICB9IGVsc2UgaWYgKHR5cGUucmVnZXggfHwgdHlwZS5yZWdleGVzKSB7XG4gICAgLy8gZmlyc3QgY2hlY2sgZW51bXNcbiAgICBpZiAodHlwZS5lbnVtcykge1xuICAgICAgdmFyIGVudW1Qcm9wID0gY2hlY2tFbnVtcygpO1xuICAgICAgaWYgKGVudW1Qcm9wKSB7XG4gICAgICAgIHJldHVybiBlbnVtUHJvcDtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIHJlZ2V4ZXMgPSB0eXBlLnJlZ2V4ZXMgPyB0eXBlLnJlZ2V4ZXMgOiBbdHlwZS5yZWdleF07XG4gICAgZm9yICh2YXIgX2kzID0gMDsgX2kzIDwgcmVnZXhlcy5sZW5ndGg7IF9pMysrKSB7XG4gICAgICB2YXIgcmVnZXggPSBuZXcgUmVnRXhwKHJlZ2V4ZXNbX2kzXSk7IC8vIG1ha2UgYSByZWdleCBmcm9tIHRoZSB0eXBlIHN0cmluZ1xuICAgICAgdmFyIG0gPSByZWdleC5leGVjKHZhbHVlKTtcbiAgICAgIGlmIChtKSB7XG4gICAgICAgIC8vIHJlZ2V4IG1hdGNoZXNcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgIHZhbHVlOiB0eXBlLnNpbmdsZVJlZ2V4TWF0Y2hWYWx1ZSA/IG1bMV0gOiBtLFxuICAgICAgICAgIHN0clZhbHVlOiAnJyArIHZhbHVlLFxuICAgICAgICAgIGJ5cGFzczogcHJvcElzQnlwYXNzXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsOyAvLyBkaWRuJ3QgbWF0Y2ggYW55XG4gIH0gZWxzZSBpZiAodHlwZS5zdHJpbmcpIHtcbiAgICAvLyBqdXN0IHJldHVyblxuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiBuYW1lLFxuICAgICAgdmFsdWU6ICcnICsgdmFsdWUsXG4gICAgICBzdHJWYWx1ZTogJycgKyB2YWx1ZSxcbiAgICAgIGJ5cGFzczogcHJvcElzQnlwYXNzXG4gICAgfTtcbiAgfSBlbHNlIGlmICh0eXBlLmVudW1zKSB7XG4gICAgLy8gY2hlY2sgZW51bXMgbGFzdCBiZWNhdXNlIGl0J3MgYSBjb21ibyB0eXBlIGluIG90aGVyc1xuICAgIHJldHVybiBjaGVja0VudW1zKCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG51bGw7IC8vIG5vdCBhIHR5cGUgd2UgY2FuIGhhbmRsZVxuICB9XG59O1xuXG52YXIgU3R5bGUgPSBmdW5jdGlvbiBTdHlsZShjeSkge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgU3R5bGUpKSB7XG4gICAgcmV0dXJuIG5ldyBTdHlsZShjeSk7XG4gIH1cbiAgaWYgKCFjb3JlKGN5KSkge1xuICAgIGVycm9yKCdBIHN0eWxlIG11c3QgaGF2ZSBhIGNvcmUgcmVmZXJlbmNlJyk7XG4gICAgcmV0dXJuO1xuICB9XG4gIHRoaXMuX3ByaXZhdGUgPSB7XG4gICAgY3k6IGN5LFxuICAgIGNvcmVTdHlsZToge31cbiAgfTtcbiAgdGhpcy5sZW5ndGggPSAwO1xuICB0aGlzLnJlc2V0VG9EZWZhdWx0KCk7XG59O1xudmFyIHN0eWZuID0gU3R5bGUucHJvdG90eXBlO1xuc3R5Zm4uaW5zdGFuY2VTdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAnc3R5bGUnO1xufTtcblxuLy8gcmVtb3ZlIGFsbCBjb250ZXh0c1xuc3R5Zm4uY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBfcCA9IHRoaXMuX3ByaXZhdGU7XG4gIHZhciBjeSA9IF9wLmN5O1xuICB2YXIgZWxlcyA9IGN5LmVsZW1lbnRzKCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgIHRoaXNbaV0gPSB1bmRlZmluZWQ7XG4gIH1cbiAgdGhpcy5sZW5ndGggPSAwO1xuICBfcC5jb250ZXh0U3R5bGVzID0ge307XG4gIF9wLnByb3BEaWZmcyA9IHt9O1xuICB0aGlzLmNsZWFuRWxlbWVudHMoZWxlcywgdHJ1ZSk7XG4gIGVsZXMuZm9yRWFjaChmdW5jdGlvbiAoZWxlKSB7XG4gICAgdmFyIGVsZV9wID0gZWxlWzBdLl9wcml2YXRlO1xuICAgIGVsZV9wLnN0eWxlRGlydHkgPSB0cnVlO1xuICAgIGVsZV9wLmFwcGxpZWRJbml0U3R5bGUgPSBmYWxzZTtcbiAgfSk7XG4gIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xufTtcblxuc3R5Zm4ucmVzZXRUb0RlZmF1bHQgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuY2xlYXIoKTtcbiAgdGhpcy5hZGREZWZhdWx0U3R5bGVzaGVldCgpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIGJ1aWxkcyBhIHN0eWxlIG9iamVjdCBmb3IgdGhlICdjb3JlJyBzZWxlY3Rvclxuc3R5Zm4uY29yZSA9IGZ1bmN0aW9uIChwcm9wTmFtZSkge1xuICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5jb3JlU3R5bGVbcHJvcE5hbWVdIHx8IHRoaXMuZ2V0RGVmYXVsdFByb3BlcnR5KHByb3BOYW1lKTtcbn07XG5cbi8vIGNyZWF0ZSBhIG5ldyBjb250ZXh0IGZyb20gdGhlIHNwZWNpZmllZCBzZWxlY3RvciBzdHJpbmcgYW5kIHN3aXRjaCB0byB0aGF0IGNvbnRleHRcbnN0eWZuLnNlbGVjdG9yID0gZnVuY3Rpb24gKHNlbGVjdG9yU3RyKSB7XG4gIC8vICdjb3JlJyBpcyBhIHNwZWNpYWwgY2FzZSBhbmQgZG9lcyBub3QgbmVlZCBhIHNlbGVjdG9yXG4gIHZhciBzZWxlY3RvciA9IHNlbGVjdG9yU3RyID09PSAnY29yZScgPyBudWxsIDogbmV3IFNlbGVjdG9yKHNlbGVjdG9yU3RyKTtcbiAgdmFyIGkgPSB0aGlzLmxlbmd0aCsrOyAvLyBuZXcgY29udGV4dCBtZWFucyBuZXcgaW5kZXhcbiAgdGhpc1tpXSA9IHtcbiAgICBzZWxlY3Rvcjogc2VsZWN0b3IsXG4gICAgcHJvcGVydGllczogW10sXG4gICAgbWFwcGVkUHJvcGVydGllczogW10sXG4gICAgaW5kZXg6IGlcbiAgfTtcbiAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG59O1xuXG4vLyBhZGQgb25lIG9yIG1hbnkgY3NzIHJ1bGVzIHRvIHRoZSBjdXJyZW50IGNvbnRleHRcbnN0eWZuLmNzcyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgaWYgKGFyZ3MubGVuZ3RoID09PSAxKSB7XG4gICAgdmFyIG1hcCA9IGFyZ3NbMF07XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWxmLnByb3BlcnRpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBwcm9wID0gc2VsZi5wcm9wZXJ0aWVzW2ldO1xuICAgICAgdmFyIG1hcFZhbCA9IG1hcFtwcm9wLm5hbWVdO1xuICAgICAgaWYgKG1hcFZhbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG1hcFZhbCA9IG1hcFtkYXNoMmNhbWVsKHByb3AubmFtZSldO1xuICAgICAgfVxuICAgICAgaWYgKG1hcFZhbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuY3NzUnVsZShwcm9wLm5hbWUsIG1hcFZhbCk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGFyZ3MubGVuZ3RoID09PSAyKSB7XG4gICAgdGhpcy5jc3NSdWxlKGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICB9XG5cbiAgLy8gZG8gbm90aGluZyBpZiBhcmdzIGFyZSBpbnZhbGlkXG5cbiAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG59O1xuXG5zdHlmbi5zdHlsZSA9IHN0eWZuLmNzcztcblxuLy8gYWRkIGEgc2luZ2xlIGNzcyBydWxlIHRvIHRoZSBjdXJyZW50IGNvbnRleHRcbnN0eWZuLmNzc1J1bGUgPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgLy8gbmFtZS12YWx1ZSBwYWlyXG4gIHZhciBwcm9wZXJ0eSA9IHRoaXMucGFyc2UobmFtZSwgdmFsdWUpO1xuXG4gIC8vIGFkZCBwcm9wZXJ0eSB0byBjdXJyZW50IGNvbnRleHQgaWYgdmFsaWRcbiAgaWYgKHByb3BlcnR5KSB7XG4gICAgdmFyIGkgPSB0aGlzLmxlbmd0aCAtIDE7XG4gICAgdGhpc1tpXS5wcm9wZXJ0aWVzLnB1c2gocHJvcGVydHkpO1xuICAgIHRoaXNbaV0ucHJvcGVydGllc1twcm9wZXJ0eS5uYW1lXSA9IHByb3BlcnR5OyAvLyBhbGxvdyBhY2Nlc3MgYnkgbmFtZSBhcyB3ZWxsXG5cbiAgICBpZiAocHJvcGVydHkubmFtZS5tYXRjaCgvcGllLShcXGQrKS1iYWNrZ3JvdW5kLXNpemUvKSAmJiBwcm9wZXJ0eS52YWx1ZSkge1xuICAgICAgdGhpcy5fcHJpdmF0ZS5oYXNQaWUgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAocHJvcGVydHkubWFwcGVkKSB7XG4gICAgICB0aGlzW2ldLm1hcHBlZFByb3BlcnRpZXMucHVzaChwcm9wZXJ0eSk7XG4gICAgfVxuXG4gICAgLy8gYWRkIHRvIGNvcmUgc3R5bGUgaWYgbmVjZXNzYXJ5XG4gICAgdmFyIGN1cnJlbnRTZWxlY3RvcklzQ29yZSA9ICF0aGlzW2ldLnNlbGVjdG9yO1xuICAgIGlmIChjdXJyZW50U2VsZWN0b3JJc0NvcmUpIHtcbiAgICAgIHRoaXMuX3ByaXZhdGUuY29yZVN0eWxlW3Byb3BlcnR5Lm5hbWVdID0gcHJvcGVydHk7XG4gICAgfVxuICB9XG4gIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xufTtcblxuc3R5Zm4uYXBwZW5kID0gZnVuY3Rpb24gKHN0eWxlKSB7XG4gIGlmIChzdHlsZXNoZWV0KHN0eWxlKSkge1xuICAgIHN0eWxlLmFwcGVuZFRvU3R5bGUodGhpcyk7XG4gIH0gZWxzZSBpZiAoYXJyYXkoc3R5bGUpKSB7XG4gICAgdGhpcy5hcHBlbmRGcm9tSnNvbihzdHlsZSk7XG4gIH0gZWxzZSBpZiAoc3RyaW5nKHN0eWxlKSkge1xuICAgIHRoaXMuYXBwZW5kRnJvbVN0cmluZyhzdHlsZSk7XG4gIH0gLy8geW91IHByb2JhYmx5IHdvdWxkbid0IHdhbnQgdG8gYXBwZW5kIGEgU3R5bGUsIHNpbmNlIHlvdSdkIGR1cGxpY2F0ZSB0aGUgZGVmYXVsdCBwYXJ0c1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gc3RhdGljIGZ1bmN0aW9uXG5TdHlsZS5mcm9tSnNvbiA9IGZ1bmN0aW9uIChjeSwganNvbikge1xuICB2YXIgc3R5bGUgPSBuZXcgU3R5bGUoY3kpO1xuICBzdHlsZS5mcm9tSnNvbihqc29uKTtcbiAgcmV0dXJuIHN0eWxlO1xufTtcblN0eWxlLmZyb21TdHJpbmcgPSBmdW5jdGlvbiAoY3ksIHN0cmluZykge1xuICByZXR1cm4gbmV3IFN0eWxlKGN5KS5mcm9tU3RyaW5nKHN0cmluZyk7XG59O1xuW3N0eWZuJDgsIHN0eWZuJDcsIHN0eWZuJDYsIHN0eWZuJDUsIHN0eWZuJDQsIHN0eWZuJDMsIHN0eWZuJDIsIHN0eWZuJDFdLmZvckVhY2goZnVuY3Rpb24gKHByb3BzKSB7XG4gIGV4dGVuZChzdHlmbiwgcHJvcHMpO1xufSk7XG5TdHlsZS50eXBlcyA9IHN0eWZuLnR5cGVzO1xuU3R5bGUucHJvcGVydGllcyA9IHN0eWZuLnByb3BlcnRpZXM7XG5TdHlsZS5wcm9wZXJ0eUdyb3VwcyA9IHN0eWZuLnByb3BlcnR5R3JvdXBzO1xuU3R5bGUucHJvcGVydHlHcm91cE5hbWVzID0gc3R5Zm4ucHJvcGVydHlHcm91cE5hbWVzO1xuU3R5bGUucHJvcGVydHlHcm91cEtleXMgPSBzdHlmbi5wcm9wZXJ0eUdyb3VwS2V5cztcblxudmFyIGNvcmVmbiQyID0ge1xuICBzdHlsZTogZnVuY3Rpb24gc3R5bGUobmV3U3R5bGUpIHtcbiAgICBpZiAobmV3U3R5bGUpIHtcbiAgICAgIHZhciBzID0gdGhpcy5zZXRTdHlsZShuZXdTdHlsZSk7XG4gICAgICBzLnVwZGF0ZSgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5zdHlsZTtcbiAgfSxcbiAgc2V0U3R5bGU6IGZ1bmN0aW9uIHNldFN0eWxlKHN0eWxlKSB7XG4gICAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZTtcbiAgICBpZiAoc3R5bGVzaGVldChzdHlsZSkpIHtcbiAgICAgIF9wLnN0eWxlID0gc3R5bGUuZ2VuZXJhdGVTdHlsZSh0aGlzKTtcbiAgICB9IGVsc2UgaWYgKGFycmF5KHN0eWxlKSkge1xuICAgICAgX3Auc3R5bGUgPSBTdHlsZS5mcm9tSnNvbih0aGlzLCBzdHlsZSk7XG4gICAgfSBlbHNlIGlmIChzdHJpbmcoc3R5bGUpKSB7XG4gICAgICBfcC5zdHlsZSA9IFN0eWxlLmZyb21TdHJpbmcodGhpcywgc3R5bGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBfcC5zdHlsZSA9IFN0eWxlKHRoaXMpO1xuICAgIH1cbiAgICByZXR1cm4gX3Auc3R5bGU7XG4gIH0sXG4gIC8vIGUuZy4gY3kuZGF0YSgpIGNoYW5nZWQgPT4gcmVjYWxjIGVsZSBtYXBwZXJzXG4gIHVwZGF0ZVN0eWxlOiBmdW5jdGlvbiB1cGRhdGVTdHlsZSgpIHtcbiAgICB0aGlzLm11dGFibGVFbGVtZW50cygpLnVwZGF0ZVN0eWxlKCk7IC8vIGp1c3Qgc2VuZCB0byBhbGwgZWxlc1xuICB9XG59O1xuXG52YXIgZGVmYXVsdFNlbGVjdGlvblR5cGUgPSAnc2luZ2xlJztcbnZhciBjb3JlZm4kMSA9IHtcbiAgYXV0b2xvY2s6IGZ1bmN0aW9uIGF1dG9sb2NrKGJvb2wpIHtcbiAgICBpZiAoYm9vbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLl9wcml2YXRlLmF1dG9sb2NrID0gYm9vbCA/IHRydWUgOiBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUuYXV0b2xvY2s7XG4gICAgfVxuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9LFxuXG4gIGF1dG91bmdyYWJpZnk6IGZ1bmN0aW9uIGF1dG91bmdyYWJpZnkoYm9vbCkge1xuICAgIGlmIChib29sICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuX3ByaXZhdGUuYXV0b3VuZ3JhYmlmeSA9IGJvb2wgPyB0cnVlIDogZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlLmF1dG91bmdyYWJpZnk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9LFxuXG4gIGF1dG91bnNlbGVjdGlmeTogZnVuY3Rpb24gYXV0b3Vuc2VsZWN0aWZ5KGJvb2wpIHtcbiAgICBpZiAoYm9vbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLl9wcml2YXRlLmF1dG91bnNlbGVjdGlmeSA9IGJvb2wgPyB0cnVlIDogZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlLmF1dG91bnNlbGVjdGlmeTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH0sXG5cbiAgc2VsZWN0aW9uVHlwZTogZnVuY3Rpb24gc2VsZWN0aW9uVHlwZShzZWxUeXBlKSB7XG4gICAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZTtcbiAgICBpZiAoX3Auc2VsZWN0aW9uVHlwZSA9PSBudWxsKSB7XG4gICAgICBfcC5zZWxlY3Rpb25UeXBlID0gZGVmYXVsdFNlbGVjdGlvblR5cGU7XG4gICAgfVxuICAgIGlmIChzZWxUeXBlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChzZWxUeXBlID09PSAnYWRkaXRpdmUnIHx8IHNlbFR5cGUgPT09ICdzaW5nbGUnKSB7XG4gICAgICAgIF9wLnNlbGVjdGlvblR5cGUgPSBzZWxUeXBlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gX3Auc2VsZWN0aW9uVHlwZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIHBhbm5pbmdFbmFibGVkOiBmdW5jdGlvbiBwYW5uaW5nRW5hYmxlZChib29sKSB7XG4gICAgaWYgKGJvb2wgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5fcHJpdmF0ZS5wYW5uaW5nRW5hYmxlZCA9IGJvb2wgPyB0cnVlIDogZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlLnBhbm5pbmdFbmFibGVkO1xuICAgIH1cbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfSxcblxuICB1c2VyUGFubmluZ0VuYWJsZWQ6IGZ1bmN0aW9uIHVzZXJQYW5uaW5nRW5hYmxlZChib29sKSB7XG4gICAgaWYgKGJvb2wgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5fcHJpdmF0ZS51c2VyUGFubmluZ0VuYWJsZWQgPSBib29sID8gdHJ1ZSA6IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS51c2VyUGFubmluZ0VuYWJsZWQ7XG4gICAgfVxuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9LFxuXG4gIHpvb21pbmdFbmFibGVkOiBmdW5jdGlvbiB6b29taW5nRW5hYmxlZChib29sKSB7XG4gICAgaWYgKGJvb2wgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5fcHJpdmF0ZS56b29taW5nRW5hYmxlZCA9IGJvb2wgPyB0cnVlIDogZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlLnpvb21pbmdFbmFibGVkO1xuICAgIH1cbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfSxcblxuICB1c2VyWm9vbWluZ0VuYWJsZWQ6IGZ1bmN0aW9uIHVzZXJab29taW5nRW5hYmxlZChib29sKSB7XG4gICAgaWYgKGJvb2wgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5fcHJpdmF0ZS51c2VyWm9vbWluZ0VuYWJsZWQgPSBib29sID8gdHJ1ZSA6IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS51c2VyWm9vbWluZ0VuYWJsZWQ7XG4gICAgfVxuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9LFxuXG4gIGJveFNlbGVjdGlvbkVuYWJsZWQ6IGZ1bmN0aW9uIGJveFNlbGVjdGlvbkVuYWJsZWQoYm9vbCkge1xuICAgIGlmIChib29sICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuX3ByaXZhdGUuYm94U2VsZWN0aW9uRW5hYmxlZCA9IGJvb2wgPyB0cnVlIDogZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlLmJveFNlbGVjdGlvbkVuYWJsZWQ7XG4gICAgfVxuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9LFxuXG4gIHBhbjogZnVuY3Rpb24gcGFuKCkge1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgIHZhciBwYW4gPSB0aGlzLl9wcml2YXRlLnBhbjtcbiAgICB2YXIgZGltLCB2YWwsIGRpbXMsIHgsIHk7XG4gICAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgICAgY2FzZSAwOlxuICAgICAgICAvLyAucGFuKClcbiAgICAgICAgcmV0dXJuIHBhbjtcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgaWYgKHN0cmluZyhhcmdzWzBdKSkge1xuICAgICAgICAgIC8vIC5wYW4oJ3gnKVxuICAgICAgICAgIGRpbSA9IGFyZ3NbMF07XG4gICAgICAgICAgcmV0dXJuIHBhbltkaW1dO1xuICAgICAgICB9IGVsc2UgaWYgKHBsYWluT2JqZWN0KGFyZ3NbMF0pKSB7XG4gICAgICAgICAgLy8gLnBhbih7IHg6IDAsIHk6IDEwMCB9KVxuICAgICAgICAgIGlmICghdGhpcy5fcHJpdmF0ZS5wYW5uaW5nRW5hYmxlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRpbXMgPSBhcmdzWzBdO1xuICAgICAgICAgIHggPSBkaW1zLng7XG4gICAgICAgICAgeSA9IGRpbXMueTtcbiAgICAgICAgICBpZiAobnVtYmVyJDEoeCkpIHtcbiAgICAgICAgICAgIHBhbi54ID0geDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG51bWJlciQxKHkpKSB7XG4gICAgICAgICAgICBwYW4ueSA9IHk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuZW1pdCgncGFuIHZpZXdwb3J0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIC8vIC5wYW4oJ3gnLCAxMDApXG4gICAgICAgIGlmICghdGhpcy5fcHJpdmF0ZS5wYW5uaW5nRW5hYmxlZCkge1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGRpbSA9IGFyZ3NbMF07XG4gICAgICAgIHZhbCA9IGFyZ3NbMV07XG4gICAgICAgIGlmICgoZGltID09PSAneCcgfHwgZGltID09PSAneScpICYmIG51bWJlciQxKHZhbCkpIHtcbiAgICAgICAgICBwYW5bZGltXSA9IHZhbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVtaXQoJ3BhbiB2aWV3cG9ydCcpO1xuICAgICAgICBicmVhaztcbiAgICAgIC8vIGludmFsaWRcbiAgICB9XG5cbiAgICB0aGlzLm5vdGlmeSgndmlld3BvcnQnKTtcbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfSxcblxuICBwYW5CeTogZnVuY3Rpb24gcGFuQnkoYXJnMCwgYXJnMSkge1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgIHZhciBwYW4gPSB0aGlzLl9wcml2YXRlLnBhbjtcbiAgICB2YXIgZGltLCB2YWwsIGRpbXMsIHgsIHk7XG4gICAgaWYgKCF0aGlzLl9wcml2YXRlLnBhbm5pbmdFbmFibGVkKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgICAgY2FzZSAxOlxuICAgICAgICBpZiAocGxhaW5PYmplY3QoYXJnMCkpIHtcbiAgICAgICAgICAvLyAucGFuQnkoeyB4OiAwLCB5OiAxMDAgfSlcbiAgICAgICAgICBkaW1zID0gYXJnc1swXTtcbiAgICAgICAgICB4ID0gZGltcy54O1xuICAgICAgICAgIHkgPSBkaW1zLnk7XG4gICAgICAgICAgaWYgKG51bWJlciQxKHgpKSB7XG4gICAgICAgICAgICBwYW4ueCArPSB4O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobnVtYmVyJDEoeSkpIHtcbiAgICAgICAgICAgIHBhbi55ICs9IHk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuZW1pdCgncGFuIHZpZXdwb3J0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIC8vIC5wYW5CeSgneCcsIDEwMClcbiAgICAgICAgZGltID0gYXJnMDtcbiAgICAgICAgdmFsID0gYXJnMTtcbiAgICAgICAgaWYgKChkaW0gPT09ICd4JyB8fCBkaW0gPT09ICd5JykgJiYgbnVtYmVyJDEodmFsKSkge1xuICAgICAgICAgIHBhbltkaW1dICs9IHZhbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVtaXQoJ3BhbiB2aWV3cG9ydCcpO1xuICAgICAgICBicmVhaztcbiAgICAgIC8vIGludmFsaWRcbiAgICB9XG5cbiAgICB0aGlzLm5vdGlmeSgndmlld3BvcnQnKTtcbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfSxcblxuICBmaXQ6IGZ1bmN0aW9uIGZpdChlbGVtZW50cywgcGFkZGluZykge1xuICAgIHZhciB2aWV3cG9ydFN0YXRlID0gdGhpcy5nZXRGaXRWaWV3cG9ydChlbGVtZW50cywgcGFkZGluZyk7XG4gICAgaWYgKHZpZXdwb3J0U3RhdGUpIHtcbiAgICAgIHZhciBfcCA9IHRoaXMuX3ByaXZhdGU7XG4gICAgICBfcC56b29tID0gdmlld3BvcnRTdGF0ZS56b29tO1xuICAgICAgX3AucGFuID0gdmlld3BvcnRTdGF0ZS5wYW47XG4gICAgICB0aGlzLmVtaXQoJ3BhbiB6b29tIHZpZXdwb3J0Jyk7XG4gICAgICB0aGlzLm5vdGlmeSgndmlld3BvcnQnKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH0sXG5cbiAgZ2V0Rml0Vmlld3BvcnQ6IGZ1bmN0aW9uIGdldEZpdFZpZXdwb3J0KGVsZW1lbnRzLCBwYWRkaW5nKSB7XG4gICAgaWYgKG51bWJlciQxKGVsZW1lbnRzKSAmJiBwYWRkaW5nID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIGVsZW1lbnRzIGlzIG9wdGlvbmFsXG4gICAgICBwYWRkaW5nID0gZWxlbWVudHM7XG4gICAgICBlbGVtZW50cyA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaWYgKCF0aGlzLl9wcml2YXRlLnBhbm5pbmdFbmFibGVkIHx8ICF0aGlzLl9wcml2YXRlLnpvb21pbmdFbmFibGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBiYjtcbiAgICBpZiAoc3RyaW5nKGVsZW1lbnRzKSkge1xuICAgICAgdmFyIHNlbCA9IGVsZW1lbnRzO1xuICAgICAgZWxlbWVudHMgPSB0aGlzLiQoc2VsKTtcbiAgICB9IGVsc2UgaWYgKGJvdW5kaW5nQm94KGVsZW1lbnRzKSkge1xuICAgICAgLy8gYXNzdW1lIGJiXG4gICAgICB2YXIgYmJlID0gZWxlbWVudHM7XG4gICAgICBiYiA9IHtcbiAgICAgICAgeDE6IGJiZS54MSxcbiAgICAgICAgeTE6IGJiZS55MSxcbiAgICAgICAgeDI6IGJiZS54MixcbiAgICAgICAgeTI6IGJiZS55MlxuICAgICAgfTtcbiAgICAgIGJiLncgPSBiYi54MiAtIGJiLngxO1xuICAgICAgYmIuaCA9IGJiLnkyIC0gYmIueTE7XG4gICAgfSBlbHNlIGlmICghZWxlbWVudE9yQ29sbGVjdGlvbihlbGVtZW50cykpIHtcbiAgICAgIGVsZW1lbnRzID0gdGhpcy5tdXRhYmxlRWxlbWVudHMoKTtcbiAgICB9XG4gICAgaWYgKGVsZW1lbnRPckNvbGxlY3Rpb24oZWxlbWVudHMpICYmIGVsZW1lbnRzLmVtcHR5KCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIGNhbid0IGZpdCB0byBub3RoaW5nXG5cbiAgICBiYiA9IGJiIHx8IGVsZW1lbnRzLmJvdW5kaW5nQm94KCk7XG4gICAgdmFyIHcgPSB0aGlzLndpZHRoKCk7XG4gICAgdmFyIGggPSB0aGlzLmhlaWdodCgpO1xuICAgIHZhciB6b29tO1xuICAgIHBhZGRpbmcgPSBudW1iZXIkMShwYWRkaW5nKSA/IHBhZGRpbmcgOiAwO1xuICAgIGlmICghaXNOYU4odykgJiYgIWlzTmFOKGgpICYmIHcgPiAwICYmIGggPiAwICYmICFpc05hTihiYi53KSAmJiAhaXNOYU4oYmIuaCkgJiYgYmIudyA+IDAgJiYgYmIuaCA+IDApIHtcbiAgICAgIHpvb20gPSBNYXRoLm1pbigodyAtIDIgKiBwYWRkaW5nKSAvIGJiLncsIChoIC0gMiAqIHBhZGRpbmcpIC8gYmIuaCk7XG5cbiAgICAgIC8vIGNyb3Agem9vbVxuICAgICAgem9vbSA9IHpvb20gPiB0aGlzLl9wcml2YXRlLm1heFpvb20gPyB0aGlzLl9wcml2YXRlLm1heFpvb20gOiB6b29tO1xuICAgICAgem9vbSA9IHpvb20gPCB0aGlzLl9wcml2YXRlLm1pblpvb20gPyB0aGlzLl9wcml2YXRlLm1pblpvb20gOiB6b29tO1xuICAgICAgdmFyIHBhbiA9IHtcbiAgICAgICAgLy8gbm93IHBhbiB0byBtaWRkbGVcbiAgICAgICAgeDogKHcgLSB6b29tICogKGJiLngxICsgYmIueDIpKSAvIDIsXG4gICAgICAgIHk6IChoIC0gem9vbSAqIChiYi55MSArIGJiLnkyKSkgLyAyXG4gICAgICB9O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgem9vbTogem9vbSxcbiAgICAgICAgcGFuOiBwYW5cbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybjtcbiAgfSxcbiAgem9vbVJhbmdlOiBmdW5jdGlvbiB6b29tUmFuZ2UobWluLCBtYXgpIHtcbiAgICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlO1xuICAgIGlmIChtYXggPT0gbnVsbCkge1xuICAgICAgdmFyIG9wdHMgPSBtaW47XG4gICAgICBtaW4gPSBvcHRzLm1pbjtcbiAgICAgIG1heCA9IG9wdHMubWF4O1xuICAgIH1cbiAgICBpZiAobnVtYmVyJDEobWluKSAmJiBudW1iZXIkMShtYXgpICYmIG1pbiA8PSBtYXgpIHtcbiAgICAgIF9wLm1pblpvb20gPSBtaW47XG4gICAgICBfcC5tYXhab29tID0gbWF4O1xuICAgIH0gZWxzZSBpZiAobnVtYmVyJDEobWluKSAmJiBtYXggPT09IHVuZGVmaW5lZCAmJiBtaW4gPD0gX3AubWF4Wm9vbSkge1xuICAgICAgX3AubWluWm9vbSA9IG1pbjtcbiAgICB9IGVsc2UgaWYgKG51bWJlciQxKG1heCkgJiYgbWluID09PSB1bmRlZmluZWQgJiYgbWF4ID49IF9wLm1pblpvb20pIHtcbiAgICAgIF9wLm1heFpvb20gPSBtYXg7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBtaW5ab29tOiBmdW5jdGlvbiBtaW5ab29tKHpvb20pIHtcbiAgICBpZiAoem9vbSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5taW5ab29tO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy56b29tUmFuZ2Uoe1xuICAgICAgICBtaW46IHpvb21cbiAgICAgIH0pO1xuICAgIH1cbiAgfSxcbiAgbWF4Wm9vbTogZnVuY3Rpb24gbWF4Wm9vbSh6b29tKSB7XG4gICAgaWYgKHpvb20gPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUubWF4Wm9vbTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuem9vbVJhbmdlKHtcbiAgICAgICAgbWF4OiB6b29tXG4gICAgICB9KTtcbiAgICB9XG4gIH0sXG4gIGdldFpvb21lZFZpZXdwb3J0OiBmdW5jdGlvbiBnZXRab29tZWRWaWV3cG9ydChwYXJhbXMpIHtcbiAgICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlO1xuICAgIHZhciBjdXJyZW50UGFuID0gX3AucGFuO1xuICAgIHZhciBjdXJyZW50Wm9vbSA9IF9wLnpvb207XG4gICAgdmFyIHBvczsgLy8gaW4gcmVuZGVyZWQgcHhcbiAgICB2YXIgem9vbTtcbiAgICB2YXIgYmFpbCA9IGZhbHNlO1xuICAgIGlmICghX3Auem9vbWluZ0VuYWJsZWQpIHtcbiAgICAgIC8vIHpvb21pbmcgZGlzYWJsZWRcbiAgICAgIGJhaWwgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAobnVtYmVyJDEocGFyYW1zKSkge1xuICAgICAgLy8gdGhlbiBzZXQgdGhlIHpvb21cbiAgICAgIHpvb20gPSBwYXJhbXM7XG4gICAgfSBlbHNlIGlmIChwbGFpbk9iamVjdChwYXJhbXMpKSB7XG4gICAgICAvLyB0aGVuIHpvb20gYWJvdXQgYSBwb2ludFxuICAgICAgem9vbSA9IHBhcmFtcy5sZXZlbDtcbiAgICAgIGlmIChwYXJhbXMucG9zaXRpb24gIT0gbnVsbCkge1xuICAgICAgICBwb3MgPSBtb2RlbFRvUmVuZGVyZWRQb3NpdGlvbihwYXJhbXMucG9zaXRpb24sIGN1cnJlbnRab29tLCBjdXJyZW50UGFuKTtcbiAgICAgIH0gZWxzZSBpZiAocGFyYW1zLnJlbmRlcmVkUG9zaXRpb24gIT0gbnVsbCkge1xuICAgICAgICBwb3MgPSBwYXJhbXMucmVuZGVyZWRQb3NpdGlvbjtcbiAgICAgIH1cbiAgICAgIGlmIChwb3MgIT0gbnVsbCAmJiAhX3AucGFubmluZ0VuYWJsZWQpIHtcbiAgICAgICAgLy8gcGFubmluZyBkaXNhYmxlZFxuICAgICAgICBiYWlsID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBjcm9wIHpvb21cbiAgICB6b29tID0gem9vbSA+IF9wLm1heFpvb20gPyBfcC5tYXhab29tIDogem9vbTtcbiAgICB6b29tID0gem9vbSA8IF9wLm1pblpvb20gPyBfcC5taW5ab29tIDogem9vbTtcblxuICAgIC8vIGNhbid0IHpvb20gd2l0aCBpbnZhbGlkIHBhcmFtc1xuICAgIGlmIChiYWlsIHx8ICFudW1iZXIkMSh6b29tKSB8fCB6b29tID09PSBjdXJyZW50Wm9vbSB8fCBwb3MgIT0gbnVsbCAmJiAoIW51bWJlciQxKHBvcy54KSB8fCAhbnVtYmVyJDEocG9zLnkpKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmIChwb3MgIT0gbnVsbCkge1xuICAgICAgLy8gc2V0IHpvb20gYWJvdXQgcG9zaXRpb25cbiAgICAgIHZhciBwYW4xID0gY3VycmVudFBhbjtcbiAgICAgIHZhciB6b29tMSA9IGN1cnJlbnRab29tO1xuICAgICAgdmFyIHpvb20yID0gem9vbTtcbiAgICAgIHZhciBwYW4yID0ge1xuICAgICAgICB4OiAtem9vbTIgLyB6b29tMSAqIChwb3MueCAtIHBhbjEueCkgKyBwb3MueCxcbiAgICAgICAgeTogLXpvb20yIC8gem9vbTEgKiAocG9zLnkgLSBwYW4xLnkpICsgcG9zLnlcbiAgICAgIH07XG4gICAgICByZXR1cm4ge1xuICAgICAgICB6b29tZWQ6IHRydWUsXG4gICAgICAgIHBhbm5lZDogdHJ1ZSxcbiAgICAgICAgem9vbTogem9vbTIsXG4gICAgICAgIHBhbjogcGFuMlxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8ganVzdCBzZXQgdGhlIHpvb21cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHpvb21lZDogdHJ1ZSxcbiAgICAgICAgcGFubmVkOiBmYWxzZSxcbiAgICAgICAgem9vbTogem9vbSxcbiAgICAgICAgcGFuOiBjdXJyZW50UGFuXG4gICAgICB9O1xuICAgIH1cbiAgfSxcbiAgem9vbTogZnVuY3Rpb24gem9vbShwYXJhbXMpIHtcbiAgICBpZiAocGFyYW1zID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIGdldFxuICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUuem9vbTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gc2V0XG4gICAgICB2YXIgdnAgPSB0aGlzLmdldFpvb21lZFZpZXdwb3J0KHBhcmFtcyk7XG4gICAgICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlO1xuICAgICAgaWYgKHZwID09IG51bGwgfHwgIXZwLnpvb21lZCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIF9wLnpvb20gPSB2cC56b29tO1xuICAgICAgaWYgKHZwLnBhbm5lZCkge1xuICAgICAgICBfcC5wYW4ueCA9IHZwLnBhbi54O1xuICAgICAgICBfcC5wYW4ueSA9IHZwLnBhbi55O1xuICAgICAgfVxuICAgICAgdGhpcy5lbWl0KCd6b29tJyArICh2cC5wYW5uZWQgPyAnIHBhbicgOiAnJykgKyAnIHZpZXdwb3J0Jyk7XG4gICAgICB0aGlzLm5vdGlmeSgndmlld3BvcnQnKTtcbiAgICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICAgIH1cbiAgfSxcblxuICB2aWV3cG9ydDogZnVuY3Rpb24gdmlld3BvcnQob3B0cykge1xuICAgIHZhciBfcCA9IHRoaXMuX3ByaXZhdGU7XG4gICAgdmFyIHpvb21EZWZkID0gdHJ1ZTtcbiAgICB2YXIgcGFuRGVmZCA9IHRydWU7XG4gICAgdmFyIGV2ZW50cyA9IFtdOyAvLyB0byB0cmlnZ2VyXG4gICAgdmFyIHpvb21GYWlsZWQgPSBmYWxzZTtcbiAgICB2YXIgcGFuRmFpbGVkID0gZmFsc2U7XG4gICAgaWYgKCFvcHRzKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgaWYgKCFudW1iZXIkMShvcHRzLnpvb20pKSB7XG4gICAgICB6b29tRGVmZCA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAoIXBsYWluT2JqZWN0KG9wdHMucGFuKSkge1xuICAgICAgcGFuRGVmZCA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAoIXpvb21EZWZkICYmICFwYW5EZWZkKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgaWYgKHpvb21EZWZkKSB7XG4gICAgICB2YXIgeiA9IG9wdHMuem9vbTtcbiAgICAgIGlmICh6IDwgX3AubWluWm9vbSB8fCB6ID4gX3AubWF4Wm9vbSB8fCAhX3Auem9vbWluZ0VuYWJsZWQpIHtcbiAgICAgICAgem9vbUZhaWxlZCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfcC56b29tID0gejtcbiAgICAgICAgZXZlbnRzLnB1c2goJ3pvb20nKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHBhbkRlZmQgJiYgKCF6b29tRmFpbGVkIHx8ICFvcHRzLmNhbmNlbE9uRmFpbGVkWm9vbSkgJiYgX3AucGFubmluZ0VuYWJsZWQpIHtcbiAgICAgIHZhciBwID0gb3B0cy5wYW47XG4gICAgICBpZiAobnVtYmVyJDEocC54KSkge1xuICAgICAgICBfcC5wYW4ueCA9IHAueDtcbiAgICAgICAgcGFuRmFpbGVkID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAobnVtYmVyJDEocC55KSkge1xuICAgICAgICBfcC5wYW4ueSA9IHAueTtcbiAgICAgICAgcGFuRmFpbGVkID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoIXBhbkZhaWxlZCkge1xuICAgICAgICBldmVudHMucHVzaCgncGFuJyk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChldmVudHMubGVuZ3RoID4gMCkge1xuICAgICAgZXZlbnRzLnB1c2goJ3ZpZXdwb3J0Jyk7XG4gICAgICB0aGlzLmVtaXQoZXZlbnRzLmpvaW4oJyAnKSk7XG4gICAgICB0aGlzLm5vdGlmeSgndmlld3BvcnQnKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH0sXG5cbiAgY2VudGVyOiBmdW5jdGlvbiBjZW50ZXIoZWxlbWVudHMpIHtcbiAgICB2YXIgcGFuID0gdGhpcy5nZXRDZW50ZXJQYW4oZWxlbWVudHMpO1xuICAgIGlmIChwYW4pIHtcbiAgICAgIHRoaXMuX3ByaXZhdGUucGFuID0gcGFuO1xuICAgICAgdGhpcy5lbWl0KCdwYW4gdmlld3BvcnQnKTtcbiAgICAgIHRoaXMubm90aWZ5KCd2aWV3cG9ydCcpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfSxcblxuICBnZXRDZW50ZXJQYW46IGZ1bmN0aW9uIGdldENlbnRlclBhbihlbGVtZW50cywgem9vbSkge1xuICAgIGlmICghdGhpcy5fcHJpdmF0ZS5wYW5uaW5nRW5hYmxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoc3RyaW5nKGVsZW1lbnRzKSkge1xuICAgICAgdmFyIHNlbGVjdG9yID0gZWxlbWVudHM7XG4gICAgICBlbGVtZW50cyA9IHRoaXMubXV0YWJsZUVsZW1lbnRzKCkuZmlsdGVyKHNlbGVjdG9yKTtcbiAgICB9IGVsc2UgaWYgKCFlbGVtZW50T3JDb2xsZWN0aW9uKGVsZW1lbnRzKSkge1xuICAgICAgZWxlbWVudHMgPSB0aGlzLm11dGFibGVFbGVtZW50cygpO1xuICAgIH1cbiAgICBpZiAoZWxlbWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBjYW4ndCBjZW50cmUgcGFuIHRvIG5vdGhpbmdcblxuICAgIHZhciBiYiA9IGVsZW1lbnRzLmJvdW5kaW5nQm94KCk7XG4gICAgdmFyIHcgPSB0aGlzLndpZHRoKCk7XG4gICAgdmFyIGggPSB0aGlzLmhlaWdodCgpO1xuICAgIHpvb20gPSB6b29tID09PSB1bmRlZmluZWQgPyB0aGlzLl9wcml2YXRlLnpvb20gOiB6b29tO1xuICAgIHZhciBwYW4gPSB7XG4gICAgICAvLyBtaWRkbGVcbiAgICAgIHg6ICh3IC0gem9vbSAqIChiYi54MSArIGJiLngyKSkgLyAyLFxuICAgICAgeTogKGggLSB6b29tICogKGJiLnkxICsgYmIueTIpKSAvIDJcbiAgICB9O1xuICAgIHJldHVybiBwYW47XG4gIH0sXG4gIHJlc2V0OiBmdW5jdGlvbiByZXNldCgpIHtcbiAgICBpZiAoIXRoaXMuX3ByaXZhdGUucGFubmluZ0VuYWJsZWQgfHwgIXRoaXMuX3ByaXZhdGUuem9vbWluZ0VuYWJsZWQpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB0aGlzLnZpZXdwb3J0KHtcbiAgICAgIHBhbjoge1xuICAgICAgICB4OiAwLFxuICAgICAgICB5OiAwXG4gICAgICB9LFxuICAgICAgem9vbTogMVxuICAgIH0pO1xuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9LFxuXG4gIGludmFsaWRhdGVTaXplOiBmdW5jdGlvbiBpbnZhbGlkYXRlU2l6ZSgpIHtcbiAgICB0aGlzLl9wcml2YXRlLnNpemVDYWNoZSA9IG51bGw7XG4gIH0sXG4gIHNpemU6IGZ1bmN0aW9uIHNpemUoKSB7XG4gICAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZTtcbiAgICB2YXIgY29udGFpbmVyID0gX3AuY29udGFpbmVyO1xuICAgIHZhciBjeSA9IHRoaXM7XG4gICAgcmV0dXJuIF9wLnNpemVDYWNoZSA9IF9wLnNpemVDYWNoZSB8fCAoY29udGFpbmVyID8gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHN0eWxlID0gY3kud2luZG93KCkuZ2V0Q29tcHV0ZWRTdHlsZShjb250YWluZXIpO1xuICAgICAgdmFyIHZhbCA9IGZ1bmN0aW9uIHZhbChuYW1lKSB7XG4gICAgICAgIHJldHVybiBwYXJzZUZsb2F0KHN0eWxlLmdldFByb3BlcnR5VmFsdWUobmFtZSkpO1xuICAgICAgfTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHdpZHRoOiBjb250YWluZXIuY2xpZW50V2lkdGggLSB2YWwoJ3BhZGRpbmctbGVmdCcpIC0gdmFsKCdwYWRkaW5nLXJpZ2h0JyksXG4gICAgICAgIGhlaWdodDogY29udGFpbmVyLmNsaWVudEhlaWdodCAtIHZhbCgncGFkZGluZy10b3AnKSAtIHZhbCgncGFkZGluZy1ib3R0b20nKVxuICAgICAgfTtcbiAgICB9KCkgOiB7XG4gICAgICAvLyBmYWxsYmFjayBpZiBubyBjb250YWluZXIgKG5vdCAwIGIvYyBjYW4gYmUgdXNlZCBmb3IgZGl2aWRpbmcgZXRjKVxuICAgICAgd2lkdGg6IDEsXG4gICAgICBoZWlnaHQ6IDFcbiAgICB9KTtcbiAgfSxcbiAgd2lkdGg6IGZ1bmN0aW9uIHdpZHRoKCkge1xuICAgIHJldHVybiB0aGlzLnNpemUoKS53aWR0aDtcbiAgfSxcbiAgaGVpZ2h0OiBmdW5jdGlvbiBoZWlnaHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2l6ZSgpLmhlaWdodDtcbiAgfSxcbiAgZXh0ZW50OiBmdW5jdGlvbiBleHRlbnQoKSB7XG4gICAgdmFyIHBhbiA9IHRoaXMuX3ByaXZhdGUucGFuO1xuICAgIHZhciB6b29tID0gdGhpcy5fcHJpdmF0ZS56b29tO1xuICAgIHZhciByYiA9IHRoaXMucmVuZGVyZWRFeHRlbnQoKTtcbiAgICB2YXIgYiA9IHtcbiAgICAgIHgxOiAocmIueDEgLSBwYW4ueCkgLyB6b29tLFxuICAgICAgeDI6IChyYi54MiAtIHBhbi54KSAvIHpvb20sXG4gICAgICB5MTogKHJiLnkxIC0gcGFuLnkpIC8gem9vbSxcbiAgICAgIHkyOiAocmIueTIgLSBwYW4ueSkgLyB6b29tXG4gICAgfTtcbiAgICBiLncgPSBiLngyIC0gYi54MTtcbiAgICBiLmggPSBiLnkyIC0gYi55MTtcbiAgICByZXR1cm4gYjtcbiAgfSxcbiAgcmVuZGVyZWRFeHRlbnQ6IGZ1bmN0aW9uIHJlbmRlcmVkRXh0ZW50KCkge1xuICAgIHZhciB3aWR0aCA9IHRoaXMud2lkdGgoKTtcbiAgICB2YXIgaGVpZ2h0ID0gdGhpcy5oZWlnaHQoKTtcbiAgICByZXR1cm4ge1xuICAgICAgeDE6IDAsXG4gICAgICB5MTogMCxcbiAgICAgIHgyOiB3aWR0aCxcbiAgICAgIHkyOiBoZWlnaHQsXG4gICAgICB3OiB3aWR0aCxcbiAgICAgIGg6IGhlaWdodFxuICAgIH07XG4gIH0sXG4gIG11bHRpQ2xpY2tEZWJvdW5jZVRpbWU6IGZ1bmN0aW9uIG11bHRpQ2xpY2tEZWJvdW5jZVRpbWUoX2ludCkge1xuICAgIGlmIChfaW50KSB0aGlzLl9wcml2YXRlLm11bHRpQ2xpY2tEZWJvdW5jZVRpbWUgPSBfaW50O2Vsc2UgcmV0dXJuIHRoaXMuX3ByaXZhdGUubXVsdGlDbGlja0RlYm91bmNlVGltZTtcbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfVxufTtcblxuLy8gYWxpYXNlc1xuY29yZWZuJDEuY2VudHJlID0gY29yZWZuJDEuY2VudGVyO1xuXG4vLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuY29yZWZuJDEuYXV0b2xvY2tOb2RlcyA9IGNvcmVmbiQxLmF1dG9sb2NrO1xuY29yZWZuJDEuYXV0b3VuZ3JhYmlmeU5vZGVzID0gY29yZWZuJDEuYXV0b3VuZ3JhYmlmeTtcblxudmFyIGZuID0ge1xuICBkYXRhOiBkZWZpbmUuZGF0YSh7XG4gICAgZmllbGQ6ICdkYXRhJyxcbiAgICBiaW5kaW5nRXZlbnQ6ICdkYXRhJyxcbiAgICBhbGxvd0JpbmRpbmc6IHRydWUsXG4gICAgYWxsb3dTZXR0aW5nOiB0cnVlLFxuICAgIHNldHRpbmdFdmVudDogJ2RhdGEnLFxuICAgIHNldHRpbmdUcmlnZ2Vyc0V2ZW50OiB0cnVlLFxuICAgIHRyaWdnZXJGbk5hbWU6ICd0cmlnZ2VyJyxcbiAgICBhbGxvd0dldHRpbmc6IHRydWUsXG4gICAgdXBkYXRlU3R5bGU6IHRydWVcbiAgfSksXG4gIHJlbW92ZURhdGE6IGRlZmluZS5yZW1vdmVEYXRhKHtcbiAgICBmaWVsZDogJ2RhdGEnLFxuICAgIGV2ZW50OiAnZGF0YScsXG4gICAgdHJpZ2dlckZuTmFtZTogJ3RyaWdnZXInLFxuICAgIHRyaWdnZXJFdmVudDogdHJ1ZSxcbiAgICB1cGRhdGVTdHlsZTogdHJ1ZVxuICB9KSxcbiAgc2NyYXRjaDogZGVmaW5lLmRhdGEoe1xuICAgIGZpZWxkOiAnc2NyYXRjaCcsXG4gICAgYmluZGluZ0V2ZW50OiAnc2NyYXRjaCcsXG4gICAgYWxsb3dCaW5kaW5nOiB0cnVlLFxuICAgIGFsbG93U2V0dGluZzogdHJ1ZSxcbiAgICBzZXR0aW5nRXZlbnQ6ICdzY3JhdGNoJyxcbiAgICBzZXR0aW5nVHJpZ2dlcnNFdmVudDogdHJ1ZSxcbiAgICB0cmlnZ2VyRm5OYW1lOiAndHJpZ2dlcicsXG4gICAgYWxsb3dHZXR0aW5nOiB0cnVlLFxuICAgIHVwZGF0ZVN0eWxlOiB0cnVlXG4gIH0pLFxuICByZW1vdmVTY3JhdGNoOiBkZWZpbmUucmVtb3ZlRGF0YSh7XG4gICAgZmllbGQ6ICdzY3JhdGNoJyxcbiAgICBldmVudDogJ3NjcmF0Y2gnLFxuICAgIHRyaWdnZXJGbk5hbWU6ICd0cmlnZ2VyJyxcbiAgICB0cmlnZ2VyRXZlbnQ6IHRydWUsXG4gICAgdXBkYXRlU3R5bGU6IHRydWVcbiAgfSlcbn07XG5cbi8vIGFsaWFzZXNcbmZuLmF0dHIgPSBmbi5kYXRhO1xuZm4ucmVtb3ZlQXR0ciA9IGZuLnJlbW92ZURhdGE7XG5cbnZhciBDb3JlID0gZnVuY3Rpb24gQ29yZShvcHRzKSB7XG4gIHZhciBjeSA9IHRoaXM7XG4gIG9wdHMgPSBleHRlbmQoe30sIG9wdHMpO1xuICB2YXIgY29udGFpbmVyID0gb3B0cy5jb250YWluZXI7XG5cbiAgLy8gYWxsb3cgZm9yIHBhc3NpbmcgYSB3cmFwcGVkIGpxdWVyeSBvYmplY3RcbiAgLy8gZS5nLiBjeXRvc2NhcGUoeyBjb250YWluZXI6ICQoJyNjeScpIH0pXG4gIGlmIChjb250YWluZXIgJiYgIWh0bWxFbGVtZW50KGNvbnRhaW5lcikgJiYgaHRtbEVsZW1lbnQoY29udGFpbmVyWzBdKSkge1xuICAgIGNvbnRhaW5lciA9IGNvbnRhaW5lclswXTtcbiAgfVxuICB2YXIgcmVnID0gY29udGFpbmVyID8gY29udGFpbmVyLl9jeXJlZyA6IG51bGw7IC8vIGUuZy4gYWxyZWFkeSByZWdpc3RlcmVkIHNvbWUgaW5mbyAoZS5nLiByZWFkaWVzKSB2aWEganF1ZXJ5XG4gIHJlZyA9IHJlZyB8fCB7fTtcbiAgaWYgKHJlZyAmJiByZWcuY3kpIHtcbiAgICByZWcuY3kuZGVzdHJveSgpO1xuICAgIHJlZyA9IHt9OyAvLyBvbGQgaW5zdGFuY2UgPT4gcmVwbGFjZSByZWcgY29tcGxldGVseVxuICB9XG5cbiAgdmFyIHJlYWRpZXMgPSByZWcucmVhZGllcyA9IHJlZy5yZWFkaWVzIHx8IFtdO1xuICBpZiAoY29udGFpbmVyKSB7XG4gICAgY29udGFpbmVyLl9jeXJlZyA9IHJlZztcbiAgfSAvLyBtYWtlIHN1cmUgY29udGFpbmVyIGFzc29jJ2QgcmVnIHBvaW50cyB0byB0aGlzIGN5XG4gIHJlZy5jeSA9IGN5O1xuICB2YXIgaGVhZCA9IF93aW5kb3cgIT09IHVuZGVmaW5lZCAmJiBjb250YWluZXIgIT09IHVuZGVmaW5lZCAmJiAhb3B0cy5oZWFkbGVzcztcbiAgdmFyIG9wdGlvbnMgPSBvcHRzO1xuICBvcHRpb25zLmxheW91dCA9IGV4dGVuZCh7XG4gICAgbmFtZTogaGVhZCA/ICdncmlkJyA6ICdudWxsJ1xuICB9LCBvcHRpb25zLmxheW91dCk7XG4gIG9wdGlvbnMucmVuZGVyZXIgPSBleHRlbmQoe1xuICAgIG5hbWU6IGhlYWQgPyAnY2FudmFzJyA6ICdudWxsJ1xuICB9LCBvcHRpb25zLnJlbmRlcmVyKTtcbiAgdmFyIGRlZlZhbCA9IGZ1bmN0aW9uIGRlZlZhbChkZWYsIHZhbCwgYWx0VmFsKSB7XG4gICAgaWYgKHZhbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdmFsO1xuICAgIH0gZWxzZSBpZiAoYWx0VmFsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBhbHRWYWw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBkZWY7XG4gICAgfVxuICB9O1xuICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlID0ge1xuICAgIGNvbnRhaW5lcjogY29udGFpbmVyLFxuICAgIC8vIGh0bWwgZG9tIGVsZSBjb250YWluZXJcbiAgICByZWFkeTogZmFsc2UsXG4gICAgLy8gd2hldGhlciByZWFkeSBoYXMgYmVlbiB0cmlnZ2VyZWRcbiAgICBvcHRpb25zOiBvcHRpb25zLFxuICAgIC8vIGNhY2hlZCBvcHRpb25zXG4gICAgZWxlbWVudHM6IG5ldyBDb2xsZWN0aW9uKHRoaXMpLFxuICAgIC8vIGVsZW1lbnRzIGluIHRoZSBncmFwaFxuICAgIGxpc3RlbmVyczogW10sXG4gICAgLy8gbGlzdCBvZiBsaXN0ZW5lcnNcbiAgICBhbmlFbGVzOiBuZXcgQ29sbGVjdGlvbih0aGlzKSxcbiAgICAvLyBlbGVtZW50cyBiZWluZyBhbmltYXRlZFxuICAgIGRhdGE6IG9wdGlvbnMuZGF0YSB8fCB7fSxcbiAgICAvLyBkYXRhIGZvciB0aGUgY29yZVxuICAgIHNjcmF0Y2g6IHt9LFxuICAgIC8vIHNjcmF0Y2ggb2JqZWN0IGZvciBjb3JlXG4gICAgbGF5b3V0OiBudWxsLFxuICAgIHJlbmRlcmVyOiBudWxsLFxuICAgIGRlc3Ryb3llZDogZmFsc2UsXG4gICAgLy8gd2hldGhlciBkZXN0cm95IHdhcyBjYWxsZWRcbiAgICBub3RpZmljYXRpb25zRW5hYmxlZDogdHJ1ZSxcbiAgICAvLyB3aGV0aGVyIG5vdGlmaWNhdGlvbnMgYXJlIHNlbnQgdG8gdGhlIHJlbmRlcmVyXG4gICAgbWluWm9vbTogMWUtNTAsXG4gICAgbWF4Wm9vbTogMWU1MCxcbiAgICB6b29taW5nRW5hYmxlZDogZGVmVmFsKHRydWUsIG9wdGlvbnMuem9vbWluZ0VuYWJsZWQpLFxuICAgIHVzZXJab29taW5nRW5hYmxlZDogZGVmVmFsKHRydWUsIG9wdGlvbnMudXNlclpvb21pbmdFbmFibGVkKSxcbiAgICBwYW5uaW5nRW5hYmxlZDogZGVmVmFsKHRydWUsIG9wdGlvbnMucGFubmluZ0VuYWJsZWQpLFxuICAgIHVzZXJQYW5uaW5nRW5hYmxlZDogZGVmVmFsKHRydWUsIG9wdGlvbnMudXNlclBhbm5pbmdFbmFibGVkKSxcbiAgICBib3hTZWxlY3Rpb25FbmFibGVkOiBkZWZWYWwodHJ1ZSwgb3B0aW9ucy5ib3hTZWxlY3Rpb25FbmFibGVkKSxcbiAgICBhdXRvbG9jazogZGVmVmFsKGZhbHNlLCBvcHRpb25zLmF1dG9sb2NrLCBvcHRpb25zLmF1dG9sb2NrTm9kZXMpLFxuICAgIGF1dG91bmdyYWJpZnk6IGRlZlZhbChmYWxzZSwgb3B0aW9ucy5hdXRvdW5ncmFiaWZ5LCBvcHRpb25zLmF1dG91bmdyYWJpZnlOb2RlcyksXG4gICAgYXV0b3Vuc2VsZWN0aWZ5OiBkZWZWYWwoZmFsc2UsIG9wdGlvbnMuYXV0b3Vuc2VsZWN0aWZ5KSxcbiAgICBzdHlsZUVuYWJsZWQ6IG9wdGlvbnMuc3R5bGVFbmFibGVkID09PSB1bmRlZmluZWQgPyBoZWFkIDogb3B0aW9ucy5zdHlsZUVuYWJsZWQsXG4gICAgem9vbTogbnVtYmVyJDEob3B0aW9ucy56b29tKSA/IG9wdGlvbnMuem9vbSA6IDEsXG4gICAgcGFuOiB7XG4gICAgICB4OiBwbGFpbk9iamVjdChvcHRpb25zLnBhbikgJiYgbnVtYmVyJDEob3B0aW9ucy5wYW4ueCkgPyBvcHRpb25zLnBhbi54IDogMCxcbiAgICAgIHk6IHBsYWluT2JqZWN0KG9wdGlvbnMucGFuKSAmJiBudW1iZXIkMShvcHRpb25zLnBhbi55KSA/IG9wdGlvbnMucGFuLnkgOiAwXG4gICAgfSxcbiAgICBhbmltYXRpb246IHtcbiAgICAgIC8vIG9iamVjdCBmb3IgY3VycmVudGx5LXJ1bm5pbmcgYW5pbWF0aW9uc1xuICAgICAgY3VycmVudDogW10sXG4gICAgICBxdWV1ZTogW11cbiAgICB9LFxuICAgIGhhc0NvbXBvdW5kTm9kZXM6IGZhbHNlLFxuICAgIG11bHRpQ2xpY2tEZWJvdW5jZVRpbWU6IGRlZlZhbCgyNTAsIG9wdGlvbnMubXVsdGlDbGlja0RlYm91bmNlVGltZSlcbiAgfTtcbiAgdGhpcy5jcmVhdGVFbWl0dGVyKCk7XG5cbiAgLy8gc2V0IHNlbGVjdGlvbiB0eXBlXG4gIHRoaXMuc2VsZWN0aW9uVHlwZShvcHRpb25zLnNlbGVjdGlvblR5cGUpO1xuXG4gIC8vIGluaXQgem9vbSBib3VuZHNcbiAgdGhpcy56b29tUmFuZ2Uoe1xuICAgIG1pbjogb3B0aW9ucy5taW5ab29tLFxuICAgIG1heDogb3B0aW9ucy5tYXhab29tXG4gIH0pO1xuICB2YXIgbG9hZEV4dERhdGEgPSBmdW5jdGlvbiBsb2FkRXh0RGF0YShleHREYXRhLCBuZXh0KSB7XG4gICAgdmFyIGFueUlzUHJvbWlzZSA9IGV4dERhdGEuc29tZShwcm9taXNlKTtcbiAgICBpZiAoYW55SXNQcm9taXNlKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZSQxLmFsbChleHREYXRhKS50aGVuKG5leHQpOyAvLyBsb2FkIGFsbCBkYXRhIGFzeW5jaHJvbm91c2x5LCB0aGVuIGV4ZWMgcmVzdCBvZiBpbml0XG4gICAgfSBlbHNlIHtcbiAgICAgIG5leHQoZXh0RGF0YSk7IC8vIGV4ZWMgc3luY2hyb25vdXNseSBmb3IgY29udmVuaWVuY2VcbiAgICB9XG4gIH07XG5cbiAgLy8gc3RhcnQgd2l0aCB0aGUgZGVmYXVsdCBzdHlsZXNoZWV0IHNvIHdlIGhhdmUgc29tZXRoaW5nIGJlZm9yZSBsb2FkaW5nIGFuIGV4dGVybmFsIHN0eWxlc2hlZXRcbiAgaWYgKF9wLnN0eWxlRW5hYmxlZCkge1xuICAgIGN5LnNldFN0eWxlKFtdKTtcbiAgfVxuXG4gIC8vIGNyZWF0ZSB0aGUgcmVuZGVyZXJcbiAgdmFyIHJlbmRlcmVyT3B0aW9ucyA9IGV4dGVuZCh7fSwgb3B0aW9ucywgb3B0aW9ucy5yZW5kZXJlcik7IC8vIGFsbG93IHJlbmRlcmluZyBoaW50cyBpbiB0b3AgbGV2ZWwgb3B0aW9uc1xuICBjeS5pbml0UmVuZGVyZXIocmVuZGVyZXJPcHRpb25zKTtcbiAgdmFyIHNldEVsZXNBbmRMYXlvdXQgPSBmdW5jdGlvbiBzZXRFbGVzQW5kTGF5b3V0KGVsZW1lbnRzLCBvbmxvYWQsIG9uZG9uZSkge1xuICAgIGN5Lm5vdGlmaWNhdGlvbnMoZmFsc2UpO1xuXG4gICAgLy8gcmVtb3ZlIG9sZCBlbGVtZW50c1xuICAgIHZhciBvbGRFbGVzID0gY3kubXV0YWJsZUVsZW1lbnRzKCk7XG4gICAgaWYgKG9sZEVsZXMubGVuZ3RoID4gMCkge1xuICAgICAgb2xkRWxlcy5yZW1vdmUoKTtcbiAgICB9XG4gICAgaWYgKGVsZW1lbnRzICE9IG51bGwpIHtcbiAgICAgIGlmIChwbGFpbk9iamVjdChlbGVtZW50cykgfHwgYXJyYXkoZWxlbWVudHMpKSB7XG4gICAgICAgIGN5LmFkZChlbGVtZW50cyk7XG4gICAgICB9XG4gICAgfVxuICAgIGN5Lm9uZSgnbGF5b3V0cmVhZHknLCBmdW5jdGlvbiAoZSkge1xuICAgICAgY3kubm90aWZpY2F0aW9ucyh0cnVlKTtcbiAgICAgIGN5LmVtaXQoZSk7IC8vIHdlIG1pc3NlZCB0aGlzIGV2ZW50IGJ5IHR1cm5pbmcgbm90aWZpY2F0aW9ucyBvZmYsIHNvIHBhc3MgaXQgb25cblxuICAgICAgY3kub25lKCdsb2FkJywgb25sb2FkKTtcbiAgICAgIGN5LmVtaXRBbmROb3RpZnkoJ2xvYWQnKTtcbiAgICB9KS5vbmUoJ2xheW91dHN0b3AnLCBmdW5jdGlvbiAoKSB7XG4gICAgICBjeS5vbmUoJ2RvbmUnLCBvbmRvbmUpO1xuICAgICAgY3kuZW1pdCgnZG9uZScpO1xuICAgIH0pO1xuICAgIHZhciBsYXlvdXRPcHRzID0gZXh0ZW5kKHt9LCBjeS5fcHJpdmF0ZS5vcHRpb25zLmxheW91dCk7XG4gICAgbGF5b3V0T3B0cy5lbGVzID0gY3kuZWxlbWVudHMoKTtcbiAgICBjeS5sYXlvdXQobGF5b3V0T3B0cykucnVuKCk7XG4gIH07XG4gIGxvYWRFeHREYXRhKFtvcHRpb25zLnN0eWxlLCBvcHRpb25zLmVsZW1lbnRzXSwgZnVuY3Rpb24gKHRoZW5zKSB7XG4gICAgdmFyIGluaXRTdHlsZSA9IHRoZW5zWzBdO1xuICAgIHZhciBpbml0RWxlcyA9IHRoZW5zWzFdO1xuXG4gICAgLy8gaW5pdCBzdHlsZVxuICAgIGlmIChfcC5zdHlsZUVuYWJsZWQpIHtcbiAgICAgIGN5LnN0eWxlKCkuYXBwZW5kKGluaXRTdHlsZSk7XG4gICAgfVxuXG4gICAgLy8gaW5pdGlhbCBsb2FkXG4gICAgc2V0RWxlc0FuZExheW91dChpbml0RWxlcywgZnVuY3Rpb24gKCkge1xuICAgICAgLy8gb25yZWFkeVxuICAgICAgY3kuc3RhcnRBbmltYXRpb25Mb29wKCk7XG4gICAgICBfcC5yZWFkeSA9IHRydWU7XG5cbiAgICAgIC8vIGlmIGEgcmVhZHkgY2FsbGJhY2sgaXMgc3BlY2lmaWVkIGFzIGFuIG9wdGlvbiwgdGhlIGJpbmQgaXRcbiAgICAgIGlmIChmbiQ2KG9wdGlvbnMucmVhZHkpKSB7XG4gICAgICAgIGN5Lm9uKCdyZWFkeScsIG9wdGlvbnMucmVhZHkpO1xuICAgICAgfVxuXG4gICAgICAvLyBiaW5kIGFsbCB0aGUgcmVhZHkgaGFuZGxlcnMgcmVnaXN0ZXJlZCBiZWZvcmUgY3JlYXRpbmcgdGhpcyBpbnN0YW5jZVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZWFkaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBmbiA9IHJlYWRpZXNbaV07XG4gICAgICAgIGN5Lm9uKCdyZWFkeScsIGZuKTtcbiAgICAgIH1cbiAgICAgIGlmIChyZWcpIHtcbiAgICAgICAgcmVnLnJlYWRpZXMgPSBbXTtcbiAgICAgIH0gLy8gY2xlYXIgYi9jIHdlJ3ZlIGJvdW5kIHRoZW0gYWxsIGFuZCBkb24ndCB3YW50IHRvIGtlZXAgaXQgYXJvdW5kIGluIGNhc2UgYSBuZXcgY29yZSB1c2VzIHRoZSBzYW1lIGRpdiBldGNcblxuICAgICAgY3kuZW1pdCgncmVhZHknKTtcbiAgICB9LCBvcHRpb25zLmRvbmUpO1xuICB9KTtcbn07XG52YXIgY29yZWZuID0gQ29yZS5wcm90b3R5cGU7IC8vIHNob3J0IGFsaWFzXG5cbmV4dGVuZChjb3JlZm4sIHtcbiAgaW5zdGFuY2VTdHJpbmc6IGZ1bmN0aW9uIGluc3RhbmNlU3RyaW5nKCkge1xuICAgIHJldHVybiAnY29yZSc7XG4gIH0sXG4gIGlzUmVhZHk6IGZ1bmN0aW9uIGlzUmVhZHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUucmVhZHk7XG4gIH0sXG4gIGRlc3Ryb3llZDogZnVuY3Rpb24gZGVzdHJveWVkKCkge1xuICAgIHJldHVybiB0aGlzLl9wcml2YXRlLmRlc3Ryb3llZDtcbiAgfSxcbiAgcmVhZHk6IGZ1bmN0aW9uIHJlYWR5KGZuKSB7XG4gICAgaWYgKHRoaXMuaXNSZWFkeSgpKSB7XG4gICAgICB0aGlzLmVtaXR0ZXIoKS5lbWl0KCdyZWFkeScsIFtdLCBmbik7IC8vIGp1c3QgY2FsbHMgZm4gYXMgdGhvdWdoIHRyaWdnZXJlZCB2aWEgcmVhZHkgZXZlbnRcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5vbigncmVhZHknLCBmbik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgIHZhciBjeSA9IHRoaXM7XG4gICAgaWYgKGN5LmRlc3Ryb3llZCgpKSByZXR1cm47XG4gICAgY3kuc3RvcEFuaW1hdGlvbkxvb3AoKTtcbiAgICBjeS5kZXN0cm95UmVuZGVyZXIoKTtcbiAgICB0aGlzLmVtaXQoJ2Rlc3Ryb3knKTtcbiAgICBjeS5fcHJpdmF0ZS5kZXN0cm95ZWQgPSB0cnVlO1xuICAgIHJldHVybiBjeTtcbiAgfSxcbiAgaGFzRWxlbWVudFdpdGhJZDogZnVuY3Rpb24gaGFzRWxlbWVudFdpdGhJZChpZCkge1xuICAgIHJldHVybiB0aGlzLl9wcml2YXRlLmVsZW1lbnRzLmhhc0VsZW1lbnRXaXRoSWQoaWQpO1xuICB9LFxuICBnZXRFbGVtZW50QnlJZDogZnVuY3Rpb24gZ2V0RWxlbWVudEJ5SWQoaWQpIHtcbiAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5lbGVtZW50cy5nZXRFbGVtZW50QnlJZChpZCk7XG4gIH0sXG4gIGhhc0NvbXBvdW5kTm9kZXM6IGZ1bmN0aW9uIGhhc0NvbXBvdW5kTm9kZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUuaGFzQ29tcG91bmROb2RlcztcbiAgfSxcbiAgaGVhZGxlc3M6IGZ1bmN0aW9uIGhlYWRsZXNzKCkge1xuICAgIHJldHVybiB0aGlzLl9wcml2YXRlLnJlbmRlcmVyLmlzSGVhZGxlc3MoKTtcbiAgfSxcbiAgc3R5bGVFbmFibGVkOiBmdW5jdGlvbiBzdHlsZUVuYWJsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUuc3R5bGVFbmFibGVkO1xuICB9LFxuICBhZGRUb1Bvb2w6IGZ1bmN0aW9uIGFkZFRvUG9vbChlbGVzKSB7XG4gICAgdGhpcy5fcHJpdmF0ZS5lbGVtZW50cy5tZXJnZShlbGVzKTtcbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfSxcblxuICByZW1vdmVGcm9tUG9vbDogZnVuY3Rpb24gcmVtb3ZlRnJvbVBvb2woZWxlcykge1xuICAgIHRoaXMuX3ByaXZhdGUuZWxlbWVudHMudW5tZXJnZShlbGVzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgY29udGFpbmVyOiBmdW5jdGlvbiBjb250YWluZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUuY29udGFpbmVyIHx8IG51bGw7XG4gIH0sXG4gIHdpbmRvdzogZnVuY3Rpb24gd2luZG93KCkge1xuICAgIHZhciBjb250YWluZXIgPSB0aGlzLl9wcml2YXRlLmNvbnRhaW5lcjtcbiAgICBpZiAoY29udGFpbmVyID09IG51bGwpIHJldHVybiBfd2luZG93O1xuICAgIHZhciBvd25lckRvY3VtZW50ID0gdGhpcy5fcHJpdmF0ZS5jb250YWluZXIub3duZXJEb2N1bWVudDtcbiAgICBpZiAob3duZXJEb2N1bWVudCA9PT0gdW5kZWZpbmVkIHx8IG93bmVyRG9jdW1lbnQgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIF93aW5kb3c7XG4gICAgfVxuICAgIHJldHVybiBvd25lckRvY3VtZW50LmRlZmF1bHRWaWV3IHx8IF93aW5kb3c7XG4gIH0sXG4gIG1vdW50OiBmdW5jdGlvbiBtb3VudChjb250YWluZXIpIHtcbiAgICBpZiAoY29udGFpbmVyID09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGN5ID0gdGhpcztcbiAgICB2YXIgX3AgPSBjeS5fcHJpdmF0ZTtcbiAgICB2YXIgb3B0aW9ucyA9IF9wLm9wdGlvbnM7XG4gICAgaWYgKCFodG1sRWxlbWVudChjb250YWluZXIpICYmIGh0bWxFbGVtZW50KGNvbnRhaW5lclswXSkpIHtcbiAgICAgIGNvbnRhaW5lciA9IGNvbnRhaW5lclswXTtcbiAgICB9XG4gICAgY3kuc3RvcEFuaW1hdGlvbkxvb3AoKTtcbiAgICBjeS5kZXN0cm95UmVuZGVyZXIoKTtcbiAgICBfcC5jb250YWluZXIgPSBjb250YWluZXI7XG4gICAgX3Auc3R5bGVFbmFibGVkID0gdHJ1ZTtcbiAgICBjeS5pbnZhbGlkYXRlU2l6ZSgpO1xuICAgIGN5LmluaXRSZW5kZXJlcihleHRlbmQoe30sIG9wdGlvbnMsIG9wdGlvbnMucmVuZGVyZXIsIHtcbiAgICAgIC8vIGFsbG93IGN1c3RvbSByZW5kZXJlciBuYW1lIHRvIGJlIHJlLXVzZWQsIG90aGVyd2lzZSB1c2UgY2FudmFzXG4gICAgICBuYW1lOiBvcHRpb25zLnJlbmRlcmVyLm5hbWUgPT09ICdudWxsJyA/ICdjYW52YXMnIDogb3B0aW9ucy5yZW5kZXJlci5uYW1lXG4gICAgfSkpO1xuICAgIGN5LnN0YXJ0QW5pbWF0aW9uTG9vcCgpO1xuICAgIGN5LnN0eWxlKG9wdGlvbnMuc3R5bGUpO1xuICAgIGN5LmVtaXQoJ21vdW50Jyk7XG4gICAgcmV0dXJuIGN5O1xuICB9LFxuICB1bm1vdW50OiBmdW5jdGlvbiB1bm1vdW50KCkge1xuICAgIHZhciBjeSA9IHRoaXM7XG4gICAgY3kuc3RvcEFuaW1hdGlvbkxvb3AoKTtcbiAgICBjeS5kZXN0cm95UmVuZGVyZXIoKTtcbiAgICBjeS5pbml0UmVuZGVyZXIoe1xuICAgICAgbmFtZTogJ251bGwnXG4gICAgfSk7XG4gICAgY3kuZW1pdCgndW5tb3VudCcpO1xuICAgIHJldHVybiBjeTtcbiAgfSxcbiAgb3B0aW9uczogZnVuY3Rpb24gb3B0aW9ucygpIHtcbiAgICByZXR1cm4gY29weSh0aGlzLl9wcml2YXRlLm9wdGlvbnMpO1xuICB9LFxuICBqc29uOiBmdW5jdGlvbiBqc29uKG9iaikge1xuICAgIHZhciBjeSA9IHRoaXM7XG4gICAgdmFyIF9wID0gY3kuX3ByaXZhdGU7XG4gICAgdmFyIGVsZXMgPSBjeS5tdXRhYmxlRWxlbWVudHMoKTtcbiAgICB2YXIgZ2V0RnJlc2hSZWYgPSBmdW5jdGlvbiBnZXRGcmVzaFJlZihlbGUpIHtcbiAgICAgIHJldHVybiBjeS5nZXRFbGVtZW50QnlJZChlbGUuaWQoKSk7XG4gICAgfTtcbiAgICBpZiAocGxhaW5PYmplY3Qob2JqKSkge1xuICAgICAgLy8gc2V0XG5cbiAgICAgIGN5LnN0YXJ0QmF0Y2goKTtcbiAgICAgIGlmIChvYmouZWxlbWVudHMpIHtcbiAgICAgICAgdmFyIGlkSW5Kc29uID0ge307XG4gICAgICAgIHZhciB1cGRhdGVFbGVzID0gZnVuY3Rpb24gdXBkYXRlRWxlcyhqc29ucywgZ3IpIHtcbiAgICAgICAgICB2YXIgdG9BZGQgPSBbXTtcbiAgICAgICAgICB2YXIgdG9Nb2QgPSBbXTtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGpzb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIganNvbiA9IGpzb25zW2ldO1xuICAgICAgICAgICAgaWYgKCFqc29uLmRhdGEuaWQpIHtcbiAgICAgICAgICAgICAgd2FybignY3kuanNvbigpIGNhbm5vdCBoYW5kbGUgZWxlbWVudHMgd2l0aG91dCBhbiBJRCBhdHRyaWJ1dGUnKTtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgaWQgPSAnJyArIGpzb24uZGF0YS5pZDsgLy8gaWQgbXVzdCBiZSBzdHJpbmdcbiAgICAgICAgICAgIHZhciBlbGUgPSBjeS5nZXRFbGVtZW50QnlJZChpZCk7XG4gICAgICAgICAgICBpZEluSnNvbltpZF0gPSB0cnVlO1xuICAgICAgICAgICAgaWYgKGVsZS5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgICAgLy8gZXhpc3RpbmcgZWxlbWVudCBzaG91bGQgYmUgdXBkYXRlZFxuICAgICAgICAgICAgICB0b01vZC5wdXNoKHtcbiAgICAgICAgICAgICAgICBlbGU6IGVsZSxcbiAgICAgICAgICAgICAgICBqc29uOiBqc29uXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIHNob3VsZCBiZSBhZGRlZFxuICAgICAgICAgICAgICBpZiAoZ3IpIHtcbiAgICAgICAgICAgICAgICBqc29uLmdyb3VwID0gZ3I7XG4gICAgICAgICAgICAgICAgdG9BZGQucHVzaChqc29uKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0b0FkZC5wdXNoKGpzb24pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGN5LmFkZCh0b0FkZCk7XG4gICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IHRvTW9kLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIF90b01vZCRfaSA9IHRvTW9kW19pXSxcbiAgICAgICAgICAgICAgX2VsZSA9IF90b01vZCRfaS5lbGUsXG4gICAgICAgICAgICAgIF9qc29uID0gX3RvTW9kJF9pLmpzb247XG4gICAgICAgICAgICBfZWxlLmpzb24oX2pzb24pO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGFycmF5KG9iai5lbGVtZW50cykpIHtcbiAgICAgICAgICAvLyBlbGVtZW50czogW11cbiAgICAgICAgICB1cGRhdGVFbGVzKG9iai5lbGVtZW50cyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gZWxlbWVudHM6IHsgbm9kZXM6IFtdLCBlZGdlczogW10gfVxuICAgICAgICAgIHZhciBncnMgPSBbJ25vZGVzJywgJ2VkZ2VzJ107XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBncnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBnciA9IGdyc1tpXTtcbiAgICAgICAgICAgIHZhciBlbGVtZW50cyA9IG9iai5lbGVtZW50c1tncl07XG4gICAgICAgICAgICBpZiAoYXJyYXkoZWxlbWVudHMpKSB7XG4gICAgICAgICAgICAgIHVwZGF0ZUVsZXMoZWxlbWVudHMsIGdyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBhcmVudHNUb1JlbW92ZSA9IGN5LmNvbGxlY3Rpb24oKTtcbiAgICAgICAgZWxlcy5maWx0ZXIoZnVuY3Rpb24gKGVsZSkge1xuICAgICAgICAgIHJldHVybiAhaWRJbkpzb25bZWxlLmlkKCldO1xuICAgICAgICB9KS5mb3JFYWNoKGZ1bmN0aW9uIChlbGUpIHtcbiAgICAgICAgICBpZiAoZWxlLmlzUGFyZW50KCkpIHtcbiAgICAgICAgICAgIHBhcmVudHNUb1JlbW92ZS5tZXJnZShlbGUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlbGUucmVtb3ZlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBzbyB0aGF0IGNoaWxkcmVuIGFyZSBub3QgcmVtb3ZlZCB3L3BhcmVudFxuICAgICAgICBwYXJlbnRzVG9SZW1vdmUuZm9yRWFjaChmdW5jdGlvbiAoZWxlKSB7XG4gICAgICAgICAgcmV0dXJuIGVsZS5jaGlsZHJlbigpLm1vdmUoe1xuICAgICAgICAgICAgcGFyZW50OiBudWxsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIGludGVybWVkaWF0ZSBwYXJlbnRzIG1heSBiZSBtb3ZlZCBieSBwcmlvciBsaW5lLCBzbyBtYWtlIHN1cmUgd2UgcmVtb3ZlIGJ5IGZyZXNoIHJlZnNcbiAgICAgICAgcGFyZW50c1RvUmVtb3ZlLmZvckVhY2goZnVuY3Rpb24gKGVsZSkge1xuICAgICAgICAgIHJldHVybiBnZXRGcmVzaFJlZihlbGUpLnJlbW92ZSgpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChvYmouc3R5bGUpIHtcbiAgICAgICAgY3kuc3R5bGUob2JqLnN0eWxlKTtcbiAgICAgIH1cbiAgICAgIGlmIChvYmouem9vbSAhPSBudWxsICYmIG9iai56b29tICE9PSBfcC56b29tKSB7XG4gICAgICAgIGN5Lnpvb20ob2JqLnpvb20pO1xuICAgICAgfVxuICAgICAgaWYgKG9iai5wYW4pIHtcbiAgICAgICAgaWYgKG9iai5wYW4ueCAhPT0gX3AucGFuLnggfHwgb2JqLnBhbi55ICE9PSBfcC5wYW4ueSkge1xuICAgICAgICAgIGN5LnBhbihvYmoucGFuKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG9iai5kYXRhKSB7XG4gICAgICAgIGN5LmRhdGEob2JqLmRhdGEpO1xuICAgICAgfVxuICAgICAgdmFyIGZpZWxkcyA9IFsnbWluWm9vbScsICdtYXhab29tJywgJ3pvb21pbmdFbmFibGVkJywgJ3VzZXJab29taW5nRW5hYmxlZCcsICdwYW5uaW5nRW5hYmxlZCcsICd1c2VyUGFubmluZ0VuYWJsZWQnLCAnYm94U2VsZWN0aW9uRW5hYmxlZCcsICdhdXRvbG9jaycsICdhdXRvdW5ncmFiaWZ5JywgJ2F1dG91bnNlbGVjdGlmeScsICdtdWx0aUNsaWNrRGVib3VuY2VUaW1lJ107XG4gICAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBmaWVsZHMubGVuZ3RoOyBfaTIrKykge1xuICAgICAgICB2YXIgZiA9IGZpZWxkc1tfaTJdO1xuICAgICAgICBpZiAob2JqW2ZdICE9IG51bGwpIHtcbiAgICAgICAgICBjeVtmXShvYmpbZl0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjeS5lbmRCYXRjaCgpO1xuICAgICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGdldFxuICAgICAgdmFyIGZsYXQgPSAhIW9iajtcbiAgICAgIHZhciBqc29uID0ge307XG4gICAgICBpZiAoZmxhdCkge1xuICAgICAgICBqc29uLmVsZW1lbnRzID0gdGhpcy5lbGVtZW50cygpLm1hcChmdW5jdGlvbiAoZWxlKSB7XG4gICAgICAgICAgcmV0dXJuIGVsZS5qc29uKCk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAganNvbi5lbGVtZW50cyA9IHt9O1xuICAgICAgICBlbGVzLmZvckVhY2goZnVuY3Rpb24gKGVsZSkge1xuICAgICAgICAgIHZhciBncm91cCA9IGVsZS5ncm91cCgpO1xuICAgICAgICAgIGlmICghanNvbi5lbGVtZW50c1tncm91cF0pIHtcbiAgICAgICAgICAgIGpzb24uZWxlbWVudHNbZ3JvdXBdID0gW107XG4gICAgICAgICAgfVxuICAgICAgICAgIGpzb24uZWxlbWVudHNbZ3JvdXBdLnB1c2goZWxlLmpzb24oKSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX3ByaXZhdGUuc3R5bGVFbmFibGVkKSB7XG4gICAgICAgIGpzb24uc3R5bGUgPSBjeS5zdHlsZSgpLmpzb24oKTtcbiAgICAgIH1cbiAgICAgIGpzb24uZGF0YSA9IGNvcHkoY3kuZGF0YSgpKTtcbiAgICAgIHZhciBvcHRpb25zID0gX3Aub3B0aW9ucztcbiAgICAgIGpzb24uem9vbWluZ0VuYWJsZWQgPSBfcC56b29taW5nRW5hYmxlZDtcbiAgICAgIGpzb24udXNlclpvb21pbmdFbmFibGVkID0gX3AudXNlclpvb21pbmdFbmFibGVkO1xuICAgICAganNvbi56b29tID0gX3Auem9vbTtcbiAgICAgIGpzb24ubWluWm9vbSA9IF9wLm1pblpvb207XG4gICAgICBqc29uLm1heFpvb20gPSBfcC5tYXhab29tO1xuICAgICAganNvbi5wYW5uaW5nRW5hYmxlZCA9IF9wLnBhbm5pbmdFbmFibGVkO1xuICAgICAganNvbi51c2VyUGFubmluZ0VuYWJsZWQgPSBfcC51c2VyUGFubmluZ0VuYWJsZWQ7XG4gICAgICBqc29uLnBhbiA9IGNvcHkoX3AucGFuKTtcbiAgICAgIGpzb24uYm94U2VsZWN0aW9uRW5hYmxlZCA9IF9wLmJveFNlbGVjdGlvbkVuYWJsZWQ7XG4gICAgICBqc29uLnJlbmRlcmVyID0gY29weShvcHRpb25zLnJlbmRlcmVyKTtcbiAgICAgIGpzb24uaGlkZUVkZ2VzT25WaWV3cG9ydCA9IG9wdGlvbnMuaGlkZUVkZ2VzT25WaWV3cG9ydDtcbiAgICAgIGpzb24udGV4dHVyZU9uVmlld3BvcnQgPSBvcHRpb25zLnRleHR1cmVPblZpZXdwb3J0O1xuICAgICAganNvbi53aGVlbFNlbnNpdGl2aXR5ID0gb3B0aW9ucy53aGVlbFNlbnNpdGl2aXR5O1xuICAgICAganNvbi5tb3Rpb25CbHVyID0gb3B0aW9ucy5tb3Rpb25CbHVyO1xuICAgICAganNvbi5tdWx0aUNsaWNrRGVib3VuY2VUaW1lID0gb3B0aW9ucy5tdWx0aUNsaWNrRGVib3VuY2VUaW1lO1xuICAgICAgcmV0dXJuIGpzb247XG4gICAgfVxuICB9XG59KTtcbmNvcmVmbi4kaWQgPSBjb3JlZm4uZ2V0RWxlbWVudEJ5SWQ7XG5bY29yZWZuJDksIGNvcmVmbiQ4LCBlbGVzZm4sIGNvcmVmbiQ3LCBjb3JlZm4kNiwgY29yZWZuJDUsIGNvcmVmbiQ0LCBjb3JlZm4kMywgY29yZWZuJDIsIGNvcmVmbiQxLCBmbl0uZm9yRWFjaChmdW5jdGlvbiAocHJvcHMpIHtcbiAgZXh0ZW5kKGNvcmVmbiwgcHJvcHMpO1xufSk7XG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG52YXIgZGVmYXVsdHMkNyA9IHtcbiAgZml0OiB0cnVlLFxuICAvLyB3aGV0aGVyIHRvIGZpdCB0aGUgdmlld3BvcnQgdG8gdGhlIGdyYXBoXG4gIGRpcmVjdGVkOiBmYWxzZSxcbiAgLy8gd2hldGhlciB0aGUgdHJlZSBpcyBkaXJlY3RlZCBkb3dud2FyZHMgKG9yIGVkZ2VzIGNhbiBwb2ludCBpbiBhbnkgZGlyZWN0aW9uIGlmIGZhbHNlKVxuICBwYWRkaW5nOiAzMCxcbiAgLy8gcGFkZGluZyBvbiBmaXRcbiAgY2lyY2xlOiBmYWxzZSxcbiAgLy8gcHV0IGRlcHRocyBpbiBjb25jZW50cmljIGNpcmNsZXMgaWYgdHJ1ZSwgcHV0IGRlcHRocyB0b3AgZG93biBpZiBmYWxzZVxuICBncmlkOiBmYWxzZSxcbiAgLy8gd2hldGhlciB0byBjcmVhdGUgYW4gZXZlbiBncmlkIGludG8gd2hpY2ggdGhlIERBRyBpcyBwbGFjZWQgKGNpcmNsZTpmYWxzZSBvbmx5KVxuICBzcGFjaW5nRmFjdG9yOiAxLjc1LFxuICAvLyBwb3NpdGl2ZSBzcGFjaW5nIGZhY3RvciwgbGFyZ2VyID0+IG1vcmUgc3BhY2UgYmV0d2VlbiBub2RlcyAoTi5CLiBuL2EgaWYgY2F1c2VzIG92ZXJsYXApXG4gIGJvdW5kaW5nQm94OiB1bmRlZmluZWQsXG4gIC8vIGNvbnN0cmFpbiBsYXlvdXQgYm91bmRzOyB7IHgxLCB5MSwgeDIsIHkyIH0gb3IgeyB4MSwgeTEsIHcsIGggfVxuICBhdm9pZE92ZXJsYXA6IHRydWUsXG4gIC8vIHByZXZlbnRzIG5vZGUgb3ZlcmxhcCwgbWF5IG92ZXJmbG93IGJvdW5kaW5nQm94IGlmIG5vdCBlbm91Z2ggc3BhY2VcbiAgbm9kZURpbWVuc2lvbnNJbmNsdWRlTGFiZWxzOiBmYWxzZSxcbiAgLy8gRXhjbHVkZXMgdGhlIGxhYmVsIHdoZW4gY2FsY3VsYXRpbmcgbm9kZSBib3VuZGluZyBib3hlcyBmb3IgdGhlIGxheW91dCBhbGdvcml0aG1cbiAgcm9vdHM6IHVuZGVmaW5lZCxcbiAgLy8gdGhlIHJvb3RzIG9mIHRoZSB0cmVlc1xuICBkZXB0aFNvcnQ6IHVuZGVmaW5lZCxcbiAgLy8gYSBzb3J0aW5nIGZ1bmN0aW9uIHRvIG9yZGVyIG5vZGVzIGF0IGVxdWFsIGRlcHRoLiBlLmcuIGZ1bmN0aW9uKGEsIGIpeyByZXR1cm4gYS5kYXRhKCd3ZWlnaHQnKSAtIGIuZGF0YSgnd2VpZ2h0JykgfVxuICBhbmltYXRlOiBmYWxzZSxcbiAgLy8gd2hldGhlciB0byB0cmFuc2l0aW9uIHRoZSBub2RlIHBvc2l0aW9uc1xuICBhbmltYXRpb25EdXJhdGlvbjogNTAwLFxuICAvLyBkdXJhdGlvbiBvZiBhbmltYXRpb24gaW4gbXMgaWYgZW5hYmxlZFxuICBhbmltYXRpb25FYXNpbmc6IHVuZGVmaW5lZCxcbiAgLy8gZWFzaW5nIG9mIGFuaW1hdGlvbiBpZiBlbmFibGVkLFxuICBhbmltYXRlRmlsdGVyOiBmdW5jdGlvbiBhbmltYXRlRmlsdGVyKG5vZGUsIGkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSxcbiAgLy8gYSBmdW5jdGlvbiB0aGF0IGRldGVybWluZXMgd2hldGhlciB0aGUgbm9kZSBzaG91bGQgYmUgYW5pbWF0ZWQuICBBbGwgbm9kZXMgYW5pbWF0ZWQgYnkgZGVmYXVsdCBvbiBhbmltYXRlIGVuYWJsZWQuICBOb24tYW5pbWF0ZWQgbm9kZXMgYXJlIHBvc2l0aW9uZWQgaW1tZWRpYXRlbHkgd2hlbiB0aGUgbGF5b3V0IHN0YXJ0c1xuICByZWFkeTogdW5kZWZpbmVkLFxuICAvLyBjYWxsYmFjayBvbiBsYXlvdXRyZWFkeVxuICBzdG9wOiB1bmRlZmluZWQsXG4gIC8vIGNhbGxiYWNrIG9uIGxheW91dHN0b3BcbiAgdHJhbnNmb3JtOiBmdW5jdGlvbiB0cmFuc2Zvcm0obm9kZSwgcG9zaXRpb24pIHtcbiAgICByZXR1cm4gcG9zaXRpb247XG4gIH0gLy8gdHJhbnNmb3JtIGEgZ2l2ZW4gbm9kZSBwb3NpdGlvbi4gVXNlZnVsIGZvciBjaGFuZ2luZyBmbG93IGRpcmVjdGlvbiBpbiBkaXNjcmV0ZSBsYXlvdXRzXG59O1xuXG52YXIgZGVwcmVjYXRlZE9wdGlvbkRlZmF1bHRzID0ge1xuICBtYXhpbWFsOiBmYWxzZSxcbiAgLy8gd2hldGhlciB0byBzaGlmdCBub2RlcyBkb3duIHRoZWlyIG5hdHVyYWwgQkZTIGRlcHRocyBpbiBvcmRlciB0byBhdm9pZCB1cHdhcmRzIGVkZ2VzIChEQUdTIG9ubHkpOyBzZXR0aW5nIGFjeWNsaWMgdG8gdHJ1ZSBzZXRzIG1heGltYWwgdG8gdHJ1ZSBhbHNvXG4gIGFjeWNsaWM6IGZhbHNlIC8vIHdoZXRoZXIgdGhlIHRyZWUgaXMgYWN5Y2xpYyBhbmQgdGh1cyBhIG5vZGUgY291bGQgYmUgc2hpZnRlZCAoZHVlIHRvIHRoZSBtYXhpbWFsIG9wdGlvbikgbXVsdGlwbGUgdGltZXMgd2l0aG91dCBjYXVzaW5nIGFuIGluZmluaXRlIGxvb3A7IHNldHRpbmcgdG8gdHJ1ZSBzZXRzIG1heGltYWwgdG8gdHJ1ZSBhbHNvOyBpZiB5b3UgYXJlIHVuY2VydGFpbiB3aGV0aGVyIGEgdHJlZSBpcyBhY3ljbGljLCBzZXQgdG8gZmFsc2UgdG8gYXZvaWQgcG90ZW50aWFsIGluZmluaXRlIGxvb3BzXG59O1xuXG4vKiBlc2xpbnQtZW5hYmxlICovXG5cbnZhciBnZXRJbmZvID0gZnVuY3Rpb24gZ2V0SW5mbyhlbGUpIHtcbiAgcmV0dXJuIGVsZS5zY3JhdGNoKCdicmVhZHRoZmlyc3QnKTtcbn07XG52YXIgc2V0SW5mbyA9IGZ1bmN0aW9uIHNldEluZm8oZWxlLCBvYmopIHtcbiAgcmV0dXJuIGVsZS5zY3JhdGNoKCdicmVhZHRoZmlyc3QnLCBvYmopO1xufTtcbmZ1bmN0aW9uIEJyZWFkdGhGaXJzdExheW91dChvcHRpb25zKSB7XG4gIHRoaXMub3B0aW9ucyA9IGV4dGVuZCh7fSwgZGVmYXVsdHMkNywgZGVwcmVjYXRlZE9wdGlvbkRlZmF1bHRzLCBvcHRpb25zKTtcbn1cbkJyZWFkdGhGaXJzdExheW91dC5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICB2YXIgcGFyYW1zID0gdGhpcy5vcHRpb25zO1xuICB2YXIgb3B0aW9ucyA9IHBhcmFtcztcbiAgdmFyIGN5ID0gcGFyYW1zLmN5O1xuICB2YXIgZWxlcyA9IG9wdGlvbnMuZWxlcztcbiAgdmFyIG5vZGVzID0gZWxlcy5ub2RlcygpLmZpbHRlcihmdW5jdGlvbiAobikge1xuICAgIHJldHVybiAhbi5pc1BhcmVudCgpO1xuICB9KTtcbiAgdmFyIGdyYXBoID0gZWxlcztcbiAgdmFyIGRpcmVjdGVkID0gb3B0aW9ucy5kaXJlY3RlZDtcbiAgdmFyIG1heGltYWwgPSBvcHRpb25zLmFjeWNsaWMgfHwgb3B0aW9ucy5tYXhpbWFsIHx8IG9wdGlvbnMubWF4aW1hbEFkanVzdG1lbnRzID4gMDsgLy8gbWF4aW1hbEFkanVzdG1lbnRzIGZvciBjb21wYXQuIHcvIG9sZCBjb2RlOyBhbHNvLCBzZXR0aW5nIGFjeWNsaWMgdG8gdHJ1ZSBzZXRzIG1heGltYWwgdG8gdHJ1ZVxuXG4gIHZhciBiYiA9IG1ha2VCb3VuZGluZ0JveChvcHRpb25zLmJvdW5kaW5nQm94ID8gb3B0aW9ucy5ib3VuZGluZ0JveCA6IHtcbiAgICB4MTogMCxcbiAgICB5MTogMCxcbiAgICB3OiBjeS53aWR0aCgpLFxuICAgIGg6IGN5LmhlaWdodCgpXG4gIH0pO1xuICB2YXIgcm9vdHM7XG4gIGlmIChlbGVtZW50T3JDb2xsZWN0aW9uKG9wdGlvbnMucm9vdHMpKSB7XG4gICAgcm9vdHMgPSBvcHRpb25zLnJvb3RzO1xuICB9IGVsc2UgaWYgKGFycmF5KG9wdGlvbnMucm9vdHMpKSB7XG4gICAgdmFyIHJvb3RzQXJyYXkgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9wdGlvbnMucm9vdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBpZCA9IG9wdGlvbnMucm9vdHNbaV07XG4gICAgICB2YXIgZWxlID0gY3kuZ2V0RWxlbWVudEJ5SWQoaWQpO1xuICAgICAgcm9vdHNBcnJheS5wdXNoKGVsZSk7XG4gICAgfVxuICAgIHJvb3RzID0gY3kuY29sbGVjdGlvbihyb290c0FycmF5KTtcbiAgfSBlbHNlIGlmIChzdHJpbmcob3B0aW9ucy5yb290cykpIHtcbiAgICByb290cyA9IGN5LiQob3B0aW9ucy5yb290cyk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKGRpcmVjdGVkKSB7XG4gICAgICByb290cyA9IG5vZGVzLnJvb3RzKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBjb21wb25lbnRzID0gZWxlcy5jb21wb25lbnRzKCk7XG4gICAgICByb290cyA9IGN5LmNvbGxlY3Rpb24oKTtcbiAgICAgIHZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKF9pKSB7XG4gICAgICAgIHZhciBjb21wID0gY29tcG9uZW50c1tfaV07XG4gICAgICAgIHZhciBtYXhEZWdyZWUgPSBjb21wLm1heERlZ3JlZShmYWxzZSk7XG4gICAgICAgIHZhciBjb21wUm9vdHMgPSBjb21wLmZpbHRlcihmdW5jdGlvbiAoZWxlKSB7XG4gICAgICAgICAgcmV0dXJuIGVsZS5kZWdyZWUoZmFsc2UpID09PSBtYXhEZWdyZWU7XG4gICAgICAgIH0pO1xuICAgICAgICByb290cyA9IHJvb3RzLmFkZChjb21wUm9vdHMpO1xuICAgICAgfTtcbiAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBjb21wb25lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICBfbG9vcChfaSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHZhciBkZXB0aHMgPSBbXTtcbiAgdmFyIGZvdW5kQnlCZnMgPSB7fTtcbiAgdmFyIGFkZFRvRGVwdGggPSBmdW5jdGlvbiBhZGRUb0RlcHRoKGVsZSwgZCkge1xuICAgIGlmIChkZXB0aHNbZF0gPT0gbnVsbCkge1xuICAgICAgZGVwdGhzW2RdID0gW107XG4gICAgfVxuICAgIHZhciBpID0gZGVwdGhzW2RdLmxlbmd0aDtcbiAgICBkZXB0aHNbZF0ucHVzaChlbGUpO1xuICAgIHNldEluZm8oZWxlLCB7XG4gICAgICBpbmRleDogaSxcbiAgICAgIGRlcHRoOiBkXG4gICAgfSk7XG4gIH07XG4gIHZhciBjaGFuZ2VEZXB0aCA9IGZ1bmN0aW9uIGNoYW5nZURlcHRoKGVsZSwgbmV3RGVwdGgpIHtcbiAgICB2YXIgX2dldEluZm8gPSBnZXRJbmZvKGVsZSksXG4gICAgICBkZXB0aCA9IF9nZXRJbmZvLmRlcHRoLFxuICAgICAgaW5kZXggPSBfZ2V0SW5mby5pbmRleDtcbiAgICBkZXB0aHNbZGVwdGhdW2luZGV4XSA9IG51bGw7XG4gICAgYWRkVG9EZXB0aChlbGUsIG5ld0RlcHRoKTtcbiAgfTtcblxuICAvLyBmaW5kIHRoZSBkZXB0aHMgb2YgdGhlIG5vZGVzXG4gIGdyYXBoLmJmcyh7XG4gICAgcm9vdHM6IHJvb3RzLFxuICAgIGRpcmVjdGVkOiBvcHRpb25zLmRpcmVjdGVkLFxuICAgIHZpc2l0OiBmdW5jdGlvbiB2aXNpdChub2RlLCBlZGdlLCBwTm9kZSwgaSwgZGVwdGgpIHtcbiAgICAgIHZhciBlbGUgPSBub2RlWzBdO1xuICAgICAgdmFyIGlkID0gZWxlLmlkKCk7XG4gICAgICBhZGRUb0RlcHRoKGVsZSwgZGVwdGgpO1xuICAgICAgZm91bmRCeUJmc1tpZF0gPSB0cnVlO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gY2hlY2sgZm9yIG5vZGVzIG5vdCBmb3VuZCBieSBiZnNcbiAgdmFyIG9ycGhhbk5vZGVzID0gW107XG4gIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IG5vZGVzLmxlbmd0aDsgX2kyKyspIHtcbiAgICB2YXIgX2VsZSA9IG5vZGVzW19pMl07XG4gICAgaWYgKGZvdW5kQnlCZnNbX2VsZS5pZCgpXSkge1xuICAgICAgY29udGludWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9ycGhhbk5vZGVzLnB1c2goX2VsZSk7XG4gICAgfVxuICB9XG5cbiAgLy8gYXNzaWduIHRoZSBub2RlcyBhIGRlcHRoIGFuZCBpbmRleFxuXG4gIHZhciBhc3NpZ25EZXB0aHNBdCA9IGZ1bmN0aW9uIGFzc2lnbkRlcHRoc0F0KGkpIHtcbiAgICB2YXIgZWxlcyA9IGRlcHRoc1tpXTtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IGVsZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgIHZhciBfZWxlMiA9IGVsZXNbal07XG4gICAgICBpZiAoX2VsZTIgPT0gbnVsbCkge1xuICAgICAgICBlbGVzLnNwbGljZShqLCAxKTtcbiAgICAgICAgai0tO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHNldEluZm8oX2VsZTIsIHtcbiAgICAgICAgZGVwdGg6IGksXG4gICAgICAgIGluZGV4OiBqXG4gICAgICB9KTtcbiAgICB9XG4gIH07XG4gIHZhciBhc3NpZ25EZXB0aHMgPSBmdW5jdGlvbiBhc3NpZ25EZXB0aHMoKSB7XG4gICAgZm9yICh2YXIgX2kzID0gMDsgX2kzIDwgZGVwdGhzLmxlbmd0aDsgX2kzKyspIHtcbiAgICAgIGFzc2lnbkRlcHRoc0F0KF9pMyk7XG4gICAgfVxuICB9O1xuICB2YXIgYWRqdXN0TWF4aW1hbGx5ID0gZnVuY3Rpb24gYWRqdXN0TWF4aW1hbGx5KGVsZSwgc2hpZnRlZCkge1xuICAgIHZhciBlSW5mbyA9IGdldEluZm8oZWxlKTtcbiAgICB2YXIgaW5jb21lcnMgPSBlbGUuaW5jb21lcnMoKS5maWx0ZXIoZnVuY3Rpb24gKGVsKSB7XG4gICAgICByZXR1cm4gZWwuaXNOb2RlKCkgJiYgZWxlcy5oYXMoZWwpO1xuICAgIH0pO1xuICAgIHZhciBtYXhEZXB0aCA9IC0xO1xuICAgIHZhciBpZCA9IGVsZS5pZCgpO1xuICAgIGZvciAodmFyIGsgPSAwOyBrIDwgaW5jb21lcnMubGVuZ3RoOyBrKyspIHtcbiAgICAgIHZhciBpbmNtciA9IGluY29tZXJzW2tdO1xuICAgICAgdmFyIGlJbmZvID0gZ2V0SW5mbyhpbmNtcik7XG4gICAgICBtYXhEZXB0aCA9IE1hdGgubWF4KG1heERlcHRoLCBpSW5mby5kZXB0aCk7XG4gICAgfVxuICAgIGlmIChlSW5mby5kZXB0aCA8PSBtYXhEZXB0aCkge1xuICAgICAgaWYgKCFvcHRpb25zLmFjeWNsaWMgJiYgc2hpZnRlZFtpZF0pIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICB2YXIgbmV3RGVwdGggPSBtYXhEZXB0aCArIDE7XG4gICAgICBjaGFuZ2VEZXB0aChlbGUsIG5ld0RlcHRoKTtcbiAgICAgIHNoaWZ0ZWRbaWRdID0gbmV3RGVwdGg7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIC8vIGZvciB0aGUgZGlyZWN0ZWQgY2FzZSwgdHJ5IHRvIG1ha2UgdGhlIGVkZ2VzIGFsbCBnbyBkb3duIChpLmUuIGRlcHRoIGkgPT4gZGVwdGggaSArIDEpXG4gIGlmIChkaXJlY3RlZCAmJiBtYXhpbWFsKSB7XG4gICAgdmFyIFEgPSBbXTtcbiAgICB2YXIgc2hpZnRlZCA9IHt9O1xuICAgIHZhciBlbnF1ZXVlID0gZnVuY3Rpb24gZW5xdWV1ZShuKSB7XG4gICAgICByZXR1cm4gUS5wdXNoKG4pO1xuICAgIH07XG4gICAgdmFyIGRlcXVldWUgPSBmdW5jdGlvbiBkZXF1ZXVlKCkge1xuICAgICAgcmV0dXJuIFEuc2hpZnQoKTtcbiAgICB9O1xuICAgIG5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG4pIHtcbiAgICAgIHJldHVybiBRLnB1c2gobik7XG4gICAgfSk7XG4gICAgd2hpbGUgKFEubGVuZ3RoID4gMCkge1xuICAgICAgdmFyIF9lbGUzID0gZGVxdWV1ZSgpO1xuICAgICAgdmFyIGRpZFNoaWZ0ID0gYWRqdXN0TWF4aW1hbGx5KF9lbGUzLCBzaGlmdGVkKTtcbiAgICAgIGlmIChkaWRTaGlmdCkge1xuICAgICAgICBfZWxlMy5vdXRnb2VycygpLmZpbHRlcihmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICByZXR1cm4gZWwuaXNOb2RlKCkgJiYgZWxlcy5oYXMoZWwpO1xuICAgICAgICB9KS5mb3JFYWNoKGVucXVldWUpO1xuICAgICAgfSBlbHNlIGlmIChkaWRTaGlmdCA9PT0gbnVsbCkge1xuICAgICAgICB3YXJuKCdEZXRlY3RlZCBkb3VibGUgbWF4aW1hbCBzaGlmdCBmb3Igbm9kZSBgJyArIF9lbGUzLmlkKCkgKyAnYC4gIEJhaWxpbmcgbWF4aW1hbCBhZGp1c3RtZW50IGR1ZSB0byBjeWNsZS4gIFVzZSBgb3B0aW9ucy5tYXhpbWFsOiB0cnVlYCBvbmx5IG9uIERBR3MuJyk7XG4gICAgICAgIGJyZWFrOyAvLyBleGl0IG9uIGZhaWx1cmVcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBhc3NpZ25EZXB0aHMoKTsgLy8gY2xlYXIgaG9sZXNcblxuICAvLyBmaW5kIG1pbiBkaXN0YW5jZSB3ZSBuZWVkIHRvIGxlYXZlIGJldHdlZW4gbm9kZXNcbiAgdmFyIG1pbkRpc3RhbmNlID0gMDtcbiAgaWYgKG9wdGlvbnMuYXZvaWRPdmVybGFwKSB7XG4gICAgZm9yICh2YXIgX2k0ID0gMDsgX2k0IDwgbm9kZXMubGVuZ3RoOyBfaTQrKykge1xuICAgICAgdmFyIG4gPSBub2Rlc1tfaTRdO1xuICAgICAgdmFyIG5iYiA9IG4ubGF5b3V0RGltZW5zaW9ucyhvcHRpb25zKTtcbiAgICAgIHZhciB3ID0gbmJiLnc7XG4gICAgICB2YXIgaCA9IG5iYi5oO1xuICAgICAgbWluRGlzdGFuY2UgPSBNYXRoLm1heChtaW5EaXN0YW5jZSwgdywgaCk7XG4gICAgfVxuICB9XG5cbiAgLy8gZ2V0IHRoZSB3ZWlnaHRlZCBwZXJjZW50IGZvciBhbiBlbGVtZW50IGJhc2VkIG9uIGl0cyBjb25uZWN0aXZpdHkgdG8gb3RoZXIgbGV2ZWxzXG4gIHZhciBjYWNoZWRXZWlnaHRlZFBlcmNlbnQgPSB7fTtcbiAgdmFyIGdldFdlaWdodGVkUGVyY2VudCA9IGZ1bmN0aW9uIGdldFdlaWdodGVkUGVyY2VudChlbGUpIHtcbiAgICBpZiAoY2FjaGVkV2VpZ2h0ZWRQZXJjZW50W2VsZS5pZCgpXSkge1xuICAgICAgcmV0dXJuIGNhY2hlZFdlaWdodGVkUGVyY2VudFtlbGUuaWQoKV07XG4gICAgfVxuICAgIHZhciBlbGVEZXB0aCA9IGdldEluZm8oZWxlKS5kZXB0aDtcbiAgICB2YXIgbmVpZ2hib3JzID0gZWxlLm5laWdoYm9yaG9vZCgpO1xuICAgIHZhciBwZXJjZW50ID0gMDtcbiAgICB2YXIgc2FtcGxlcyA9IDA7XG4gICAgZm9yICh2YXIgX2k1ID0gMDsgX2k1IDwgbmVpZ2hib3JzLmxlbmd0aDsgX2k1KyspIHtcbiAgICAgIHZhciBuZWlnaGJvciA9IG5laWdoYm9yc1tfaTVdO1xuICAgICAgaWYgKG5laWdoYm9yLmlzRWRnZSgpIHx8IG5laWdoYm9yLmlzUGFyZW50KCkgfHwgIW5vZGVzLmhhcyhuZWlnaGJvcikpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB2YXIgYmYgPSBnZXRJbmZvKG5laWdoYm9yKTtcbiAgICAgIGlmIChiZiA9PSBudWxsKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdmFyIGluZGV4ID0gYmYuaW5kZXg7XG4gICAgICB2YXIgZGVwdGggPSBiZi5kZXB0aDtcblxuICAgICAgLy8gdW5hc3NpZ25lZCBuZWlnaGJvdXJzIHNob3VsZG4ndCBhZmZlY3QgdGhlIG9yZGVyaW5nXG4gICAgICBpZiAoaW5kZXggPT0gbnVsbCB8fCBkZXB0aCA9PSBudWxsKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdmFyIG5EZXB0aCA9IGRlcHRoc1tkZXB0aF0ubGVuZ3RoO1xuICAgICAgaWYgKGRlcHRoIDwgZWxlRGVwdGgpIHtcbiAgICAgICAgLy8gb25seSBnZXQgaW5mbHVlbmNlZCBieSBlbGVtZW50cyBhYm92ZVxuICAgICAgICBwZXJjZW50ICs9IGluZGV4IC8gbkRlcHRoO1xuICAgICAgICBzYW1wbGVzKys7XG4gICAgICB9XG4gICAgfVxuICAgIHNhbXBsZXMgPSBNYXRoLm1heCgxLCBzYW1wbGVzKTtcbiAgICBwZXJjZW50ID0gcGVyY2VudCAvIHNhbXBsZXM7XG4gICAgaWYgKHNhbXBsZXMgPT09IDApIHtcbiAgICAgIC8vIHB1dCBsb25lIG5vZGVzIGF0IHRoZSBzdGFydFxuICAgICAgcGVyY2VudCA9IDA7XG4gICAgfVxuICAgIGNhY2hlZFdlaWdodGVkUGVyY2VudFtlbGUuaWQoKV0gPSBwZXJjZW50O1xuICAgIHJldHVybiBwZXJjZW50O1xuICB9O1xuXG4gIC8vIHJlYXJyYW5nZSB0aGUgaW5kaWNlcyBpbiBlYWNoIGRlcHRoIGxldmVsIGJhc2VkIG9uIGNvbm5lY3Rpdml0eVxuXG4gIHZhciBzb3J0Rm4gPSBmdW5jdGlvbiBzb3J0Rm4oYSwgYikge1xuICAgIHZhciBhcGN0ID0gZ2V0V2VpZ2h0ZWRQZXJjZW50KGEpO1xuICAgIHZhciBicGN0ID0gZ2V0V2VpZ2h0ZWRQZXJjZW50KGIpO1xuICAgIHZhciBkaWZmID0gYXBjdCAtIGJwY3Q7XG4gICAgaWYgKGRpZmYgPT09IDApIHtcbiAgICAgIHJldHVybiBhc2NlbmRpbmcoYS5pZCgpLCBiLmlkKCkpOyAvLyBtYWtlIHN1cmUgc29ydCBkb2Vzbid0IGhhdmUgZG9uJ3QtY2FyZSBjb21wYXJpc29uc1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZGlmZjtcbiAgICB9XG4gIH07XG4gIGlmIChvcHRpb25zLmRlcHRoU29ydCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgc29ydEZuID0gb3B0aW9ucy5kZXB0aFNvcnQ7XG4gIH1cblxuICAvLyBzb3J0IGVhY2ggbGV2ZWwgdG8gbWFrZSBjb25uZWN0ZWQgbm9kZXMgY2xvc2VyXG4gIGZvciAodmFyIF9pNiA9IDA7IF9pNiA8IGRlcHRocy5sZW5ndGg7IF9pNisrKSB7XG4gICAgZGVwdGhzW19pNl0uc29ydChzb3J0Rm4pO1xuICAgIGFzc2lnbkRlcHRoc0F0KF9pNik7XG4gIH1cblxuICAvLyBhc3NpZ24gb3JwaGFuIG5vZGVzIHRvIGEgbmV3IHRvcC1sZXZlbCBkZXB0aFxuICB2YXIgb3JwaGFuRGVwdGggPSBbXTtcbiAgZm9yICh2YXIgX2k3ID0gMDsgX2k3IDwgb3JwaGFuTm9kZXMubGVuZ3RoOyBfaTcrKykge1xuICAgIG9ycGhhbkRlcHRoLnB1c2gob3JwaGFuTm9kZXNbX2k3XSk7XG4gIH1cbiAgZGVwdGhzLnVuc2hpZnQob3JwaGFuRGVwdGgpO1xuICBhc3NpZ25EZXB0aHMoKTtcbiAgdmFyIGJpZ2dlc3REZXB0aFNpemUgPSAwO1xuICBmb3IgKHZhciBfaTggPSAwOyBfaTggPCBkZXB0aHMubGVuZ3RoOyBfaTgrKykge1xuICAgIGJpZ2dlc3REZXB0aFNpemUgPSBNYXRoLm1heChkZXB0aHNbX2k4XS5sZW5ndGgsIGJpZ2dlc3REZXB0aFNpemUpO1xuICB9XG4gIHZhciBjZW50ZXIgPSB7XG4gICAgeDogYmIueDEgKyBiYi53IC8gMixcbiAgICB5OiBiYi54MSArIGJiLmggLyAyXG4gIH07XG4gIHZhciBtYXhEZXB0aFNpemUgPSBkZXB0aHMucmVkdWNlKGZ1bmN0aW9uIChtYXgsIGVsZXMpIHtcbiAgICByZXR1cm4gTWF0aC5tYXgobWF4LCBlbGVzLmxlbmd0aCk7XG4gIH0sIDApO1xuICB2YXIgZ2V0UG9zaXRpb24gPSBmdW5jdGlvbiBnZXRQb3NpdGlvbihlbGUpIHtcbiAgICB2YXIgX2dldEluZm8yID0gZ2V0SW5mbyhlbGUpLFxuICAgICAgZGVwdGggPSBfZ2V0SW5mbzIuZGVwdGgsXG4gICAgICBpbmRleCA9IF9nZXRJbmZvMi5pbmRleDtcbiAgICB2YXIgZGVwdGhTaXplID0gZGVwdGhzW2RlcHRoXS5sZW5ndGg7XG4gICAgdmFyIGRpc3RhbmNlWCA9IE1hdGgubWF4KGJiLncgLyAoKG9wdGlvbnMuZ3JpZCA/IG1heERlcHRoU2l6ZSA6IGRlcHRoU2l6ZSkgKyAxKSwgbWluRGlzdGFuY2UpO1xuICAgIHZhciBkaXN0YW5jZVkgPSBNYXRoLm1heChiYi5oIC8gKGRlcHRocy5sZW5ndGggKyAxKSwgbWluRGlzdGFuY2UpO1xuICAgIHZhciByYWRpdXNTdGVwU2l6ZSA9IE1hdGgubWluKGJiLncgLyAyIC8gZGVwdGhzLmxlbmd0aCwgYmIuaCAvIDIgLyBkZXB0aHMubGVuZ3RoKTtcbiAgICByYWRpdXNTdGVwU2l6ZSA9IE1hdGgubWF4KHJhZGl1c1N0ZXBTaXplLCBtaW5EaXN0YW5jZSk7XG4gICAgaWYgKCFvcHRpb25zLmNpcmNsZSkge1xuICAgICAgdmFyIGVwb3MgPSB7XG4gICAgICAgIHg6IGNlbnRlci54ICsgKGluZGV4ICsgMSAtIChkZXB0aFNpemUgKyAxKSAvIDIpICogZGlzdGFuY2VYLFxuICAgICAgICB5OiAoZGVwdGggKyAxKSAqIGRpc3RhbmNlWVxuICAgICAgfTtcbiAgICAgIHJldHVybiBlcG9zO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcmFkaXVzID0gcmFkaXVzU3RlcFNpemUgKiBkZXB0aCArIHJhZGl1c1N0ZXBTaXplIC0gKGRlcHRocy5sZW5ndGggPiAwICYmIGRlcHRoc1swXS5sZW5ndGggPD0gMyA/IHJhZGl1c1N0ZXBTaXplIC8gMiA6IDApO1xuICAgICAgdmFyIHRoZXRhID0gMiAqIE1hdGguUEkgLyBkZXB0aHNbZGVwdGhdLmxlbmd0aCAqIGluZGV4O1xuICAgICAgaWYgKGRlcHRoID09PSAwICYmIGRlcHRoc1swXS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmFkaXVzID0gMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IGNlbnRlci54ICsgcmFkaXVzICogTWF0aC5jb3ModGhldGEpLFxuICAgICAgICB5OiBjZW50ZXIueSArIHJhZGl1cyAqIE1hdGguc2luKHRoZXRhKVxuICAgICAgfTtcbiAgICB9XG4gIH07XG4gIGVsZXMubm9kZXMoKS5sYXlvdXRQb3NpdGlvbnModGhpcywgb3B0aW9ucywgZ2V0UG9zaXRpb24pO1xuICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbn07XG5cbnZhciBkZWZhdWx0cyQ2ID0ge1xuICBmaXQ6IHRydWUsXG4gIC8vIHdoZXRoZXIgdG8gZml0IHRoZSB2aWV3cG9ydCB0byB0aGUgZ3JhcGhcbiAgcGFkZGluZzogMzAsXG4gIC8vIHRoZSBwYWRkaW5nIG9uIGZpdFxuICBib3VuZGluZ0JveDogdW5kZWZpbmVkLFxuICAvLyBjb25zdHJhaW4gbGF5b3V0IGJvdW5kczsgeyB4MSwgeTEsIHgyLCB5MiB9IG9yIHsgeDEsIHkxLCB3LCBoIH1cbiAgYXZvaWRPdmVybGFwOiB0cnVlLFxuICAvLyBwcmV2ZW50cyBub2RlIG92ZXJsYXAsIG1heSBvdmVyZmxvdyBib3VuZGluZ0JveCBhbmQgcmFkaXVzIGlmIG5vdCBlbm91Z2ggc3BhY2VcbiAgbm9kZURpbWVuc2lvbnNJbmNsdWRlTGFiZWxzOiBmYWxzZSxcbiAgLy8gRXhjbHVkZXMgdGhlIGxhYmVsIHdoZW4gY2FsY3VsYXRpbmcgbm9kZSBib3VuZGluZyBib3hlcyBmb3IgdGhlIGxheW91dCBhbGdvcml0aG1cbiAgc3BhY2luZ0ZhY3RvcjogdW5kZWZpbmVkLFxuICAvLyBBcHBsaWVzIGEgbXVsdGlwbGljYXRpdmUgZmFjdG9yICg+MCkgdG8gZXhwYW5kIG9yIGNvbXByZXNzIHRoZSBvdmVyYWxsIGFyZWEgdGhhdCB0aGUgbm9kZXMgdGFrZSB1cFxuICByYWRpdXM6IHVuZGVmaW5lZCxcbiAgLy8gdGhlIHJhZGl1cyBvZiB0aGUgY2lyY2xlXG4gIHN0YXJ0QW5nbGU6IDMgLyAyICogTWF0aC5QSSxcbiAgLy8gd2hlcmUgbm9kZXMgc3RhcnQgaW4gcmFkaWFuc1xuICBzd2VlcDogdW5kZWZpbmVkLFxuICAvLyBob3cgbWFueSByYWRpYW5zIHNob3VsZCBiZSBiZXR3ZWVuIHRoZSBmaXJzdCBhbmQgbGFzdCBub2RlIChkZWZhdWx0cyB0byBmdWxsIGNpcmNsZSlcbiAgY2xvY2t3aXNlOiB0cnVlLFxuICAvLyB3aGV0aGVyIHRoZSBsYXlvdXQgc2hvdWxkIGdvIGNsb2Nrd2lzZSAodHJ1ZSkgb3IgY291bnRlcmNsb2Nrd2lzZS9hbnRpY2xvY2t3aXNlIChmYWxzZSlcbiAgc29ydDogdW5kZWZpbmVkLFxuICAvLyBhIHNvcnRpbmcgZnVuY3Rpb24gdG8gb3JkZXIgdGhlIG5vZGVzOyBlLmcuIGZ1bmN0aW9uKGEsIGIpeyByZXR1cm4gYS5kYXRhKCd3ZWlnaHQnKSAtIGIuZGF0YSgnd2VpZ2h0JykgfVxuICBhbmltYXRlOiBmYWxzZSxcbiAgLy8gd2hldGhlciB0byB0cmFuc2l0aW9uIHRoZSBub2RlIHBvc2l0aW9uc1xuICBhbmltYXRpb25EdXJhdGlvbjogNTAwLFxuICAvLyBkdXJhdGlvbiBvZiBhbmltYXRpb24gaW4gbXMgaWYgZW5hYmxlZFxuICBhbmltYXRpb25FYXNpbmc6IHVuZGVmaW5lZCxcbiAgLy8gZWFzaW5nIG9mIGFuaW1hdGlvbiBpZiBlbmFibGVkXG4gIGFuaW1hdGVGaWx0ZXI6IGZ1bmN0aW9uIGFuaW1hdGVGaWx0ZXIobm9kZSwgaSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9LFxuICAvLyBhIGZ1bmN0aW9uIHRoYXQgZGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBub2RlIHNob3VsZCBiZSBhbmltYXRlZC4gIEFsbCBub2RlcyBhbmltYXRlZCBieSBkZWZhdWx0IG9uIGFuaW1hdGUgZW5hYmxlZC4gIE5vbi1hbmltYXRlZCBub2RlcyBhcmUgcG9zaXRpb25lZCBpbW1lZGlhdGVseSB3aGVuIHRoZSBsYXlvdXQgc3RhcnRzXG4gIHJlYWR5OiB1bmRlZmluZWQsXG4gIC8vIGNhbGxiYWNrIG9uIGxheW91dHJlYWR5XG4gIHN0b3A6IHVuZGVmaW5lZCxcbiAgLy8gY2FsbGJhY2sgb24gbGF5b3V0c3RvcFxuICB0cmFuc2Zvcm06IGZ1bmN0aW9uIHRyYW5zZm9ybShub2RlLCBwb3NpdGlvbikge1xuICAgIHJldHVybiBwb3NpdGlvbjtcbiAgfSAvLyB0cmFuc2Zvcm0gYSBnaXZlbiBub2RlIHBvc2l0aW9uLiBVc2VmdWwgZm9yIGNoYW5naW5nIGZsb3cgZGlyZWN0aW9uIGluIGRpc2NyZXRlIGxheW91dHMgXG59O1xuXG5mdW5jdGlvbiBDaXJjbGVMYXlvdXQob3B0aW9ucykge1xuICB0aGlzLm9wdGlvbnMgPSBleHRlbmQoe30sIGRlZmF1bHRzJDYsIG9wdGlvbnMpO1xufVxuQ2lyY2xlTGF5b3V0LnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBwYXJhbXMgPSB0aGlzLm9wdGlvbnM7XG4gIHZhciBvcHRpb25zID0gcGFyYW1zO1xuICB2YXIgY3kgPSBwYXJhbXMuY3k7XG4gIHZhciBlbGVzID0gb3B0aW9ucy5lbGVzO1xuICB2YXIgY2xvY2t3aXNlID0gb3B0aW9ucy5jb3VudGVyY2xvY2t3aXNlICE9PSB1bmRlZmluZWQgPyAhb3B0aW9ucy5jb3VudGVyY2xvY2t3aXNlIDogb3B0aW9ucy5jbG9ja3dpc2U7XG4gIHZhciBub2RlcyA9IGVsZXMubm9kZXMoKS5ub3QoJzpwYXJlbnQnKTtcbiAgaWYgKG9wdGlvbnMuc29ydCkge1xuICAgIG5vZGVzID0gbm9kZXMuc29ydChvcHRpb25zLnNvcnQpO1xuICB9XG4gIHZhciBiYiA9IG1ha2VCb3VuZGluZ0JveChvcHRpb25zLmJvdW5kaW5nQm94ID8gb3B0aW9ucy5ib3VuZGluZ0JveCA6IHtcbiAgICB4MTogMCxcbiAgICB5MTogMCxcbiAgICB3OiBjeS53aWR0aCgpLFxuICAgIGg6IGN5LmhlaWdodCgpXG4gIH0pO1xuICB2YXIgY2VudGVyID0ge1xuICAgIHg6IGJiLngxICsgYmIudyAvIDIsXG4gICAgeTogYmIueTEgKyBiYi5oIC8gMlxuICB9O1xuICB2YXIgc3dlZXAgPSBvcHRpb25zLnN3ZWVwID09PSB1bmRlZmluZWQgPyAyICogTWF0aC5QSSAtIDIgKiBNYXRoLlBJIC8gbm9kZXMubGVuZ3RoIDogb3B0aW9ucy5zd2VlcDtcbiAgdmFyIGRUaGV0YSA9IHN3ZWVwIC8gTWF0aC5tYXgoMSwgbm9kZXMubGVuZ3RoIC0gMSk7XG4gIHZhciByO1xuICB2YXIgbWluRGlzdGFuY2UgPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG4gPSBub2Rlc1tpXTtcbiAgICB2YXIgbmJiID0gbi5sYXlvdXREaW1lbnNpb25zKG9wdGlvbnMpO1xuICAgIHZhciB3ID0gbmJiLnc7XG4gICAgdmFyIGggPSBuYmIuaDtcbiAgICBtaW5EaXN0YW5jZSA9IE1hdGgubWF4KG1pbkRpc3RhbmNlLCB3LCBoKTtcbiAgfVxuICBpZiAobnVtYmVyJDEob3B0aW9ucy5yYWRpdXMpKSB7XG4gICAgciA9IG9wdGlvbnMucmFkaXVzO1xuICB9IGVsc2UgaWYgKG5vZGVzLmxlbmd0aCA8PSAxKSB7XG4gICAgciA9IDA7XG4gIH0gZWxzZSB7XG4gICAgciA9IE1hdGgubWluKGJiLmgsIGJiLncpIC8gMiAtIG1pbkRpc3RhbmNlO1xuICB9XG5cbiAgLy8gY2FsY3VsYXRlIHRoZSByYWRpdXNcbiAgaWYgKG5vZGVzLmxlbmd0aCA+IDEgJiYgb3B0aW9ucy5hdm9pZE92ZXJsYXApIHtcbiAgICAvLyBidXQgb25seSBpZiBtb3JlIHRoYW4gb25lIG5vZGUgKGNhbid0IG92ZXJsYXApXG4gICAgbWluRGlzdGFuY2UgKj0gMS43NTsgLy8ganVzdCB0byBoYXZlIHNvbWUgbmljZSBzcGFjaW5nXG5cbiAgICB2YXIgZGNvcyA9IE1hdGguY29zKGRUaGV0YSkgLSBNYXRoLmNvcygwKTtcbiAgICB2YXIgZHNpbiA9IE1hdGguc2luKGRUaGV0YSkgLSBNYXRoLnNpbigwKTtcbiAgICB2YXIgck1pbiA9IE1hdGguc3FydChtaW5EaXN0YW5jZSAqIG1pbkRpc3RhbmNlIC8gKGRjb3MgKiBkY29zICsgZHNpbiAqIGRzaW4pKTsgLy8gcy50LiBubyBub2RlcyBvdmVybGFwcGluZ1xuICAgIHIgPSBNYXRoLm1heChyTWluLCByKTtcbiAgfVxuICB2YXIgZ2V0UG9zID0gZnVuY3Rpb24gZ2V0UG9zKGVsZSwgaSkge1xuICAgIHZhciB0aGV0YSA9IG9wdGlvbnMuc3RhcnRBbmdsZSArIGkgKiBkVGhldGEgKiAoY2xvY2t3aXNlID8gMSA6IC0xKTtcbiAgICB2YXIgcnggPSByICogTWF0aC5jb3ModGhldGEpO1xuICAgIHZhciByeSA9IHIgKiBNYXRoLnNpbih0aGV0YSk7XG4gICAgdmFyIHBvcyA9IHtcbiAgICAgIHg6IGNlbnRlci54ICsgcngsXG4gICAgICB5OiBjZW50ZXIueSArIHJ5XG4gICAgfTtcbiAgICByZXR1cm4gcG9zO1xuICB9O1xuICBlbGVzLm5vZGVzKCkubGF5b3V0UG9zaXRpb25zKHRoaXMsIG9wdGlvbnMsIGdldFBvcyk7XG4gIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xufTtcblxudmFyIGRlZmF1bHRzJDUgPSB7XG4gIGZpdDogdHJ1ZSxcbiAgLy8gd2hldGhlciB0byBmaXQgdGhlIHZpZXdwb3J0IHRvIHRoZSBncmFwaFxuICBwYWRkaW5nOiAzMCxcbiAgLy8gdGhlIHBhZGRpbmcgb24gZml0XG4gIHN0YXJ0QW5nbGU6IDMgLyAyICogTWF0aC5QSSxcbiAgLy8gd2hlcmUgbm9kZXMgc3RhcnQgaW4gcmFkaWFuc1xuICBzd2VlcDogdW5kZWZpbmVkLFxuICAvLyBob3cgbWFueSByYWRpYW5zIHNob3VsZCBiZSBiZXR3ZWVuIHRoZSBmaXJzdCBhbmQgbGFzdCBub2RlIChkZWZhdWx0cyB0byBmdWxsIGNpcmNsZSlcbiAgY2xvY2t3aXNlOiB0cnVlLFxuICAvLyB3aGV0aGVyIHRoZSBsYXlvdXQgc2hvdWxkIGdvIGNsb2Nrd2lzZSAodHJ1ZSkgb3IgY291bnRlcmNsb2Nrd2lzZS9hbnRpY2xvY2t3aXNlIChmYWxzZSlcbiAgZXF1aWRpc3RhbnQ6IGZhbHNlLFxuICAvLyB3aGV0aGVyIGxldmVscyBoYXZlIGFuIGVxdWFsIHJhZGlhbCBkaXN0YW5jZSBiZXR3ZW4gdGhlbSwgbWF5IGNhdXNlIGJvdW5kaW5nIGJveCBvdmVyZmxvd1xuICBtaW5Ob2RlU3BhY2luZzogMTAsXG4gIC8vIG1pbiBzcGFjaW5nIGJldHdlZW4gb3V0c2lkZSBvZiBub2RlcyAodXNlZCBmb3IgcmFkaXVzIGFkanVzdG1lbnQpXG4gIGJvdW5kaW5nQm94OiB1bmRlZmluZWQsXG4gIC8vIGNvbnN0cmFpbiBsYXlvdXQgYm91bmRzOyB7IHgxLCB5MSwgeDIsIHkyIH0gb3IgeyB4MSwgeTEsIHcsIGggfVxuICBhdm9pZE92ZXJsYXA6IHRydWUsXG4gIC8vIHByZXZlbnRzIG5vZGUgb3ZlcmxhcCwgbWF5IG92ZXJmbG93IGJvdW5kaW5nQm94IGlmIG5vdCBlbm91Z2ggc3BhY2VcbiAgbm9kZURpbWVuc2lvbnNJbmNsdWRlTGFiZWxzOiBmYWxzZSxcbiAgLy8gRXhjbHVkZXMgdGhlIGxhYmVsIHdoZW4gY2FsY3VsYXRpbmcgbm9kZSBib3VuZGluZyBib3hlcyBmb3IgdGhlIGxheW91dCBhbGdvcml0aG1cbiAgaGVpZ2h0OiB1bmRlZmluZWQsXG4gIC8vIGhlaWdodCBvZiBsYXlvdXQgYXJlYSAob3ZlcnJpZGVzIGNvbnRhaW5lciBoZWlnaHQpXG4gIHdpZHRoOiB1bmRlZmluZWQsXG4gIC8vIHdpZHRoIG9mIGxheW91dCBhcmVhIChvdmVycmlkZXMgY29udGFpbmVyIHdpZHRoKVxuICBzcGFjaW5nRmFjdG9yOiB1bmRlZmluZWQsXG4gIC8vIEFwcGxpZXMgYSBtdWx0aXBsaWNhdGl2ZSBmYWN0b3IgKD4wKSB0byBleHBhbmQgb3IgY29tcHJlc3MgdGhlIG92ZXJhbGwgYXJlYSB0aGF0IHRoZSBub2RlcyB0YWtlIHVwXG4gIGNvbmNlbnRyaWM6IGZ1bmN0aW9uIGNvbmNlbnRyaWMobm9kZSkge1xuICAgIC8vIHJldHVybnMgbnVtZXJpYyB2YWx1ZSBmb3IgZWFjaCBub2RlLCBwbGFjaW5nIGhpZ2hlciBub2RlcyBpbiBsZXZlbHMgdG93YXJkcyB0aGUgY2VudHJlXG4gICAgcmV0dXJuIG5vZGUuZGVncmVlKCk7XG4gIH0sXG4gIGxldmVsV2lkdGg6IGZ1bmN0aW9uIGxldmVsV2lkdGgobm9kZXMpIHtcbiAgICAvLyB0aGUgdmFyaWF0aW9uIG9mIGNvbmNlbnRyaWMgdmFsdWVzIGluIGVhY2ggbGV2ZWxcbiAgICByZXR1cm4gbm9kZXMubWF4RGVncmVlKCkgLyA0O1xuICB9LFxuICBhbmltYXRlOiBmYWxzZSxcbiAgLy8gd2hldGhlciB0byB0cmFuc2l0aW9uIHRoZSBub2RlIHBvc2l0aW9uc1xuICBhbmltYXRpb25EdXJhdGlvbjogNTAwLFxuICAvLyBkdXJhdGlvbiBvZiBhbmltYXRpb24gaW4gbXMgaWYgZW5hYmxlZFxuICBhbmltYXRpb25FYXNpbmc6IHVuZGVmaW5lZCxcbiAgLy8gZWFzaW5nIG9mIGFuaW1hdGlvbiBpZiBlbmFibGVkXG4gIGFuaW1hdGVGaWx0ZXI6IGZ1bmN0aW9uIGFuaW1hdGVGaWx0ZXIobm9kZSwgaSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9LFxuICAvLyBhIGZ1bmN0aW9uIHRoYXQgZGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBub2RlIHNob3VsZCBiZSBhbmltYXRlZC4gIEFsbCBub2RlcyBhbmltYXRlZCBieSBkZWZhdWx0IG9uIGFuaW1hdGUgZW5hYmxlZC4gIE5vbi1hbmltYXRlZCBub2RlcyBhcmUgcG9zaXRpb25lZCBpbW1lZGlhdGVseSB3aGVuIHRoZSBsYXlvdXQgc3RhcnRzXG4gIHJlYWR5OiB1bmRlZmluZWQsXG4gIC8vIGNhbGxiYWNrIG9uIGxheW91dHJlYWR5XG4gIHN0b3A6IHVuZGVmaW5lZCxcbiAgLy8gY2FsbGJhY2sgb24gbGF5b3V0c3RvcFxuICB0cmFuc2Zvcm06IGZ1bmN0aW9uIHRyYW5zZm9ybShub2RlLCBwb3NpdGlvbikge1xuICAgIHJldHVybiBwb3NpdGlvbjtcbiAgfSAvLyB0cmFuc2Zvcm0gYSBnaXZlbiBub2RlIHBvc2l0aW9uLiBVc2VmdWwgZm9yIGNoYW5naW5nIGZsb3cgZGlyZWN0aW9uIGluIGRpc2NyZXRlIGxheW91dHNcbn07XG5cbmZ1bmN0aW9uIENvbmNlbnRyaWNMYXlvdXQob3B0aW9ucykge1xuICB0aGlzLm9wdGlvbnMgPSBleHRlbmQoe30sIGRlZmF1bHRzJDUsIG9wdGlvbnMpO1xufVxuQ29uY2VudHJpY0xheW91dC5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICB2YXIgcGFyYW1zID0gdGhpcy5vcHRpb25zO1xuICB2YXIgb3B0aW9ucyA9IHBhcmFtcztcbiAgdmFyIGNsb2Nrd2lzZSA9IG9wdGlvbnMuY291bnRlcmNsb2Nrd2lzZSAhPT0gdW5kZWZpbmVkID8gIW9wdGlvbnMuY291bnRlcmNsb2Nrd2lzZSA6IG9wdGlvbnMuY2xvY2t3aXNlO1xuICB2YXIgY3kgPSBwYXJhbXMuY3k7XG4gIHZhciBlbGVzID0gb3B0aW9ucy5lbGVzO1xuICB2YXIgbm9kZXMgPSBlbGVzLm5vZGVzKCkubm90KCc6cGFyZW50Jyk7XG4gIHZhciBiYiA9IG1ha2VCb3VuZGluZ0JveChvcHRpb25zLmJvdW5kaW5nQm94ID8gb3B0aW9ucy5ib3VuZGluZ0JveCA6IHtcbiAgICB4MTogMCxcbiAgICB5MTogMCxcbiAgICB3OiBjeS53aWR0aCgpLFxuICAgIGg6IGN5LmhlaWdodCgpXG4gIH0pO1xuICB2YXIgY2VudGVyID0ge1xuICAgIHg6IGJiLngxICsgYmIudyAvIDIsXG4gICAgeTogYmIueTEgKyBiYi5oIC8gMlxuICB9O1xuICB2YXIgbm9kZVZhbHVlcyA9IFtdOyAvLyB7IG5vZGUsIHZhbHVlIH1cbiAgdmFyIG1heE5vZGVTaXplID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBub2RlID0gbm9kZXNbaV07XG4gICAgdmFyIHZhbHVlID0gdm9pZCAwO1xuXG4gICAgLy8gY2FsY3VsYXRlIHRoZSBub2RlIHZhbHVlXG4gICAgdmFsdWUgPSBvcHRpb25zLmNvbmNlbnRyaWMobm9kZSk7XG4gICAgbm9kZVZhbHVlcy5wdXNoKHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIG5vZGU6IG5vZGVcbiAgICB9KTtcblxuICAgIC8vIGZvciBzdHlsZSBtYXBwaW5nXG4gICAgbm9kZS5fcHJpdmF0ZS5zY3JhdGNoLmNvbmNlbnRyaWMgPSB2YWx1ZTtcbiAgfVxuXG4gIC8vIGluIGNhc2Ugd2UgdXNlZCB0aGUgYGNvbmNlbnRyaWNgIGluIHN0eWxlXG4gIG5vZGVzLnVwZGF0ZVN0eWxlKCk7XG5cbiAgLy8gY2FsY3VsYXRlIG1heCBzaXplIG5vdyBiYXNlZCBvbiBwb3RlbnRpYWxseSB1cGRhdGVkIG1hcHBlcnNcbiAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IG5vZGVzLmxlbmd0aDsgX2krKykge1xuICAgIHZhciBfbm9kZSA9IG5vZGVzW19pXTtcbiAgICB2YXIgbmJiID0gX25vZGUubGF5b3V0RGltZW5zaW9ucyhvcHRpb25zKTtcbiAgICBtYXhOb2RlU2l6ZSA9IE1hdGgubWF4KG1heE5vZGVTaXplLCBuYmIudywgbmJiLmgpO1xuICB9XG5cbiAgLy8gc29ydCBub2RlIHZhbHVlcyBpbiBkZXNjcmVhc2luZyBvcmRlclxuICBub2RlVmFsdWVzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gYi52YWx1ZSAtIGEudmFsdWU7XG4gIH0pO1xuICB2YXIgbGV2ZWxXaWR0aCA9IG9wdGlvbnMubGV2ZWxXaWR0aChub2Rlcyk7XG5cbiAgLy8gcHV0IHRoZSB2YWx1ZXMgaW50byBsZXZlbHNcbiAgdmFyIGxldmVscyA9IFtbXV07XG4gIHZhciBjdXJyZW50TGV2ZWwgPSBsZXZlbHNbMF07XG4gIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IG5vZGVWYWx1ZXMubGVuZ3RoOyBfaTIrKykge1xuICAgIHZhciB2YWwgPSBub2RlVmFsdWVzW19pMl07XG4gICAgaWYgKGN1cnJlbnRMZXZlbC5sZW5ndGggPiAwKSB7XG4gICAgICB2YXIgZGlmZiA9IE1hdGguYWJzKGN1cnJlbnRMZXZlbFswXS52YWx1ZSAtIHZhbC52YWx1ZSk7XG4gICAgICBpZiAoZGlmZiA+PSBsZXZlbFdpZHRoKSB7XG4gICAgICAgIGN1cnJlbnRMZXZlbCA9IFtdO1xuICAgICAgICBsZXZlbHMucHVzaChjdXJyZW50TGV2ZWwpO1xuICAgICAgfVxuICAgIH1cbiAgICBjdXJyZW50TGV2ZWwucHVzaCh2YWwpO1xuICB9XG5cbiAgLy8gY3JlYXRlIHBvc2l0aW9ucyBmcm9tIGxldmVsc1xuXG4gIHZhciBtaW5EaXN0ID0gbWF4Tm9kZVNpemUgKyBvcHRpb25zLm1pbk5vZGVTcGFjaW5nOyAvLyBtaW4gZGlzdCBiZXR3ZWVuIG5vZGVzXG5cbiAgaWYgKCFvcHRpb25zLmF2b2lkT3ZlcmxhcCkge1xuICAgIC8vIHRoZW4gc3RyaWN0bHkgY29uc3RyYWluIHRvIGJiXG4gICAgdmFyIGZpcnN0THZsSGFzTXVsdGkgPSBsZXZlbHMubGVuZ3RoID4gMCAmJiBsZXZlbHNbMF0ubGVuZ3RoID4gMTtcbiAgICB2YXIgbWF4UiA9IE1hdGgubWluKGJiLncsIGJiLmgpIC8gMiAtIG1pbkRpc3Q7XG4gICAgdmFyIHJTdGVwID0gbWF4UiAvIChsZXZlbHMubGVuZ3RoICsgZmlyc3RMdmxIYXNNdWx0aSA/IDEgOiAwKTtcbiAgICBtaW5EaXN0ID0gTWF0aC5taW4obWluRGlzdCwgclN0ZXApO1xuICB9XG5cbiAgLy8gZmluZCB0aGUgbWV0cmljcyBmb3IgZWFjaCBsZXZlbFxuICB2YXIgciA9IDA7XG4gIGZvciAodmFyIF9pMyA9IDA7IF9pMyA8IGxldmVscy5sZW5ndGg7IF9pMysrKSB7XG4gICAgdmFyIGxldmVsID0gbGV2ZWxzW19pM107XG4gICAgdmFyIHN3ZWVwID0gb3B0aW9ucy5zd2VlcCA9PT0gdW5kZWZpbmVkID8gMiAqIE1hdGguUEkgLSAyICogTWF0aC5QSSAvIGxldmVsLmxlbmd0aCA6IG9wdGlvbnMuc3dlZXA7XG4gICAgdmFyIGRUaGV0YSA9IGxldmVsLmRUaGV0YSA9IHN3ZWVwIC8gTWF0aC5tYXgoMSwgbGV2ZWwubGVuZ3RoIC0gMSk7XG5cbiAgICAvLyBjYWxjdWxhdGUgdGhlIHJhZGl1c1xuICAgIGlmIChsZXZlbC5sZW5ndGggPiAxICYmIG9wdGlvbnMuYXZvaWRPdmVybGFwKSB7XG4gICAgICAvLyBidXQgb25seSBpZiBtb3JlIHRoYW4gb25lIG5vZGUgKGNhbid0IG92ZXJsYXApXG4gICAgICB2YXIgZGNvcyA9IE1hdGguY29zKGRUaGV0YSkgLSBNYXRoLmNvcygwKTtcbiAgICAgIHZhciBkc2luID0gTWF0aC5zaW4oZFRoZXRhKSAtIE1hdGguc2luKDApO1xuICAgICAgdmFyIHJNaW4gPSBNYXRoLnNxcnQobWluRGlzdCAqIG1pbkRpc3QgLyAoZGNvcyAqIGRjb3MgKyBkc2luICogZHNpbikpOyAvLyBzLnQuIG5vIG5vZGVzIG92ZXJsYXBwaW5nXG5cbiAgICAgIHIgPSBNYXRoLm1heChyTWluLCByKTtcbiAgICB9XG4gICAgbGV2ZWwuciA9IHI7XG4gICAgciArPSBtaW5EaXN0O1xuICB9XG4gIGlmIChvcHRpb25zLmVxdWlkaXN0YW50KSB7XG4gICAgdmFyIHJEZWx0YU1heCA9IDA7XG4gICAgdmFyIF9yID0gMDtcbiAgICBmb3IgKHZhciBfaTQgPSAwOyBfaTQgPCBsZXZlbHMubGVuZ3RoOyBfaTQrKykge1xuICAgICAgdmFyIF9sZXZlbCA9IGxldmVsc1tfaTRdO1xuICAgICAgdmFyIHJEZWx0YSA9IF9sZXZlbC5yIC0gX3I7XG4gICAgICByRGVsdGFNYXggPSBNYXRoLm1heChyRGVsdGFNYXgsIHJEZWx0YSk7XG4gICAgfVxuICAgIF9yID0gMDtcbiAgICBmb3IgKHZhciBfaTUgPSAwOyBfaTUgPCBsZXZlbHMubGVuZ3RoOyBfaTUrKykge1xuICAgICAgdmFyIF9sZXZlbDIgPSBsZXZlbHNbX2k1XTtcbiAgICAgIGlmIChfaTUgPT09IDApIHtcbiAgICAgICAgX3IgPSBfbGV2ZWwyLnI7XG4gICAgICB9XG4gICAgICBfbGV2ZWwyLnIgPSBfcjtcbiAgICAgIF9yICs9IHJEZWx0YU1heDtcbiAgICB9XG4gIH1cblxuICAvLyBjYWxjdWxhdGUgdGhlIG5vZGUgcG9zaXRpb25zXG4gIHZhciBwb3MgPSB7fTsgLy8gaWQgPT4gcG9zaXRpb25cbiAgZm9yICh2YXIgX2k2ID0gMDsgX2k2IDwgbGV2ZWxzLmxlbmd0aDsgX2k2KyspIHtcbiAgICB2YXIgX2xldmVsMyA9IGxldmVsc1tfaTZdO1xuICAgIHZhciBfZFRoZXRhID0gX2xldmVsMy5kVGhldGE7XG4gICAgdmFyIF9yMiA9IF9sZXZlbDMucjtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IF9sZXZlbDMubGVuZ3RoOyBqKyspIHtcbiAgICAgIHZhciBfdmFsID0gX2xldmVsM1tqXTtcbiAgICAgIHZhciB0aGV0YSA9IG9wdGlvbnMuc3RhcnRBbmdsZSArIChjbG9ja3dpc2UgPyAxIDogLTEpICogX2RUaGV0YSAqIGo7XG4gICAgICB2YXIgcCA9IHtcbiAgICAgICAgeDogY2VudGVyLnggKyBfcjIgKiBNYXRoLmNvcyh0aGV0YSksXG4gICAgICAgIHk6IGNlbnRlci55ICsgX3IyICogTWF0aC5zaW4odGhldGEpXG4gICAgICB9O1xuICAgICAgcG9zW192YWwubm9kZS5pZCgpXSA9IHA7XG4gICAgfVxuICB9XG5cbiAgLy8gcG9zaXRpb24gdGhlIG5vZGVzXG4gIGVsZXMubm9kZXMoKS5sYXlvdXRQb3NpdGlvbnModGhpcywgb3B0aW9ucywgZnVuY3Rpb24gKGVsZSkge1xuICAgIHZhciBpZCA9IGVsZS5pZCgpO1xuICAgIHJldHVybiBwb3NbaWRdO1xuICB9KTtcbiAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG59O1xuXG4vKlxuVGhlIENvU0UgbGF5b3V0IHdhcyB3cml0dGVuIGJ5IEdlcmFyZG8gSHVjay5cbmh0dHBzOi8vd3d3LmxpbmtlZGluLmNvbS9pbi9nZXJhcmRvaHVjay9cblxuQmFzZWQgb24gdGhlIGZvbGxvd2luZyBhcnRpY2xlOlxuaHR0cDovL2RsLmFjbS5vcmcvY2l0YXRpb24uY2ZtP2lkPTE0OTgwNDdcblxuTW9kaWZpY2F0aW9ucyB0cmFja2VkIG9uIEdpdGh1Yi5cbiovXG52YXIgREVCVUc7XG5cbi8qKlxuICogQGJyaWVmIDogIGRlZmF1bHQgbGF5b3V0IG9wdGlvbnNcbiAqL1xudmFyIGRlZmF1bHRzJDQgPSB7XG4gIC8vIENhbGxlZCBvbiBgbGF5b3V0cmVhZHlgXG4gIHJlYWR5OiBmdW5jdGlvbiByZWFkeSgpIHt9LFxuICAvLyBDYWxsZWQgb24gYGxheW91dHN0b3BgXG4gIHN0b3A6IGZ1bmN0aW9uIHN0b3AoKSB7fSxcbiAgLy8gV2hldGhlciB0byBhbmltYXRlIHdoaWxlIHJ1bm5pbmcgdGhlIGxheW91dFxuICAvLyB0cnVlIDogQW5pbWF0ZSBjb250aW51b3VzbHkgYXMgdGhlIGxheW91dCBpcyBydW5uaW5nXG4gIC8vIGZhbHNlIDogSnVzdCBzaG93IHRoZSBlbmQgcmVzdWx0XG4gIC8vICdlbmQnIDogQW5pbWF0ZSB3aXRoIHRoZSBlbmQgcmVzdWx0LCBmcm9tIHRoZSBpbml0aWFsIHBvc2l0aW9ucyB0byB0aGUgZW5kIHBvc2l0aW9uc1xuICBhbmltYXRlOiB0cnVlLFxuICAvLyBFYXNpbmcgb2YgdGhlIGFuaW1hdGlvbiBmb3IgYW5pbWF0ZTonZW5kJ1xuICBhbmltYXRpb25FYXNpbmc6IHVuZGVmaW5lZCxcbiAgLy8gVGhlIGR1cmF0aW9uIG9mIHRoZSBhbmltYXRpb24gZm9yIGFuaW1hdGU6J2VuZCdcbiAgYW5pbWF0aW9uRHVyYXRpb246IHVuZGVmaW5lZCxcbiAgLy8gQSBmdW5jdGlvbiB0aGF0IGRldGVybWluZXMgd2hldGhlciB0aGUgbm9kZSBzaG91bGQgYmUgYW5pbWF0ZWRcbiAgLy8gQWxsIG5vZGVzIGFuaW1hdGVkIGJ5IGRlZmF1bHQgb24gYW5pbWF0ZSBlbmFibGVkXG4gIC8vIE5vbi1hbmltYXRlZCBub2RlcyBhcmUgcG9zaXRpb25lZCBpbW1lZGlhdGVseSB3aGVuIHRoZSBsYXlvdXQgc3RhcnRzXG4gIGFuaW1hdGVGaWx0ZXI6IGZ1bmN0aW9uIGFuaW1hdGVGaWx0ZXIobm9kZSwgaSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9LFxuICAvLyBUaGUgbGF5b3V0IGFuaW1hdGVzIG9ubHkgYWZ0ZXIgdGhpcyBtYW55IG1pbGxpc2Vjb25kcyBmb3IgYW5pbWF0ZTp0cnVlXG4gIC8vIChwcmV2ZW50cyBmbGFzaGluZyBvbiBmYXN0IHJ1bnMpXG4gIGFuaW1hdGlvblRocmVzaG9sZDogMjUwLFxuICAvLyBOdW1iZXIgb2YgaXRlcmF0aW9ucyBiZXR3ZWVuIGNvbnNlY3V0aXZlIHNjcmVlbiBwb3NpdGlvbnMgdXBkYXRlXG4gIHJlZnJlc2g6IDIwLFxuICAvLyBXaGV0aGVyIHRvIGZpdCB0aGUgbmV0d29yayB2aWV3IGFmdGVyIHdoZW4gZG9uZVxuICBmaXQ6IHRydWUsXG4gIC8vIFBhZGRpbmcgb24gZml0XG4gIHBhZGRpbmc6IDMwLFxuICAvLyBDb25zdHJhaW4gbGF5b3V0IGJvdW5kczsgeyB4MSwgeTEsIHgyLCB5MiB9IG9yIHsgeDEsIHkxLCB3LCBoIH1cbiAgYm91bmRpbmdCb3g6IHVuZGVmaW5lZCxcbiAgLy8gRXhjbHVkZXMgdGhlIGxhYmVsIHdoZW4gY2FsY3VsYXRpbmcgbm9kZSBib3VuZGluZyBib3hlcyBmb3IgdGhlIGxheW91dCBhbGdvcml0aG1cbiAgbm9kZURpbWVuc2lvbnNJbmNsdWRlTGFiZWxzOiBmYWxzZSxcbiAgLy8gUmFuZG9taXplIHRoZSBpbml0aWFsIHBvc2l0aW9ucyBvZiB0aGUgbm9kZXMgKHRydWUpIG9yIHVzZSBleGlzdGluZyBwb3NpdGlvbnMgKGZhbHNlKVxuICByYW5kb21pemU6IGZhbHNlLFxuICAvLyBFeHRyYSBzcGFjaW5nIGJldHdlZW4gY29tcG9uZW50cyBpbiBub24tY29tcG91bmQgZ3JhcGhzXG4gIGNvbXBvbmVudFNwYWNpbmc6IDQwLFxuICAvLyBOb2RlIHJlcHVsc2lvbiAobm9uIG92ZXJsYXBwaW5nKSBtdWx0aXBsaWVyXG4gIG5vZGVSZXB1bHNpb246IGZ1bmN0aW9uIG5vZGVSZXB1bHNpb24obm9kZSkge1xuICAgIHJldHVybiAyMDQ4O1xuICB9LFxuICAvLyBOb2RlIHJlcHVsc2lvbiAob3ZlcmxhcHBpbmcpIG11bHRpcGxpZXJcbiAgbm9kZU92ZXJsYXA6IDQsXG4gIC8vIElkZWFsIGVkZ2UgKG5vbiBuZXN0ZWQpIGxlbmd0aFxuICBpZGVhbEVkZ2VMZW5ndGg6IGZ1bmN0aW9uIGlkZWFsRWRnZUxlbmd0aChlZGdlKSB7XG4gICAgcmV0dXJuIDMyO1xuICB9LFxuICAvLyBEaXZpc29yIHRvIGNvbXB1dGUgZWRnZSBmb3JjZXNcbiAgZWRnZUVsYXN0aWNpdHk6IGZ1bmN0aW9uIGVkZ2VFbGFzdGljaXR5KGVkZ2UpIHtcbiAgICByZXR1cm4gMzI7XG4gIH0sXG4gIC8vIE5lc3RpbmcgZmFjdG9yIChtdWx0aXBsaWVyKSB0byBjb21wdXRlIGlkZWFsIGVkZ2UgbGVuZ3RoIGZvciBuZXN0ZWQgZWRnZXNcbiAgbmVzdGluZ0ZhY3RvcjogMS4yLFxuICAvLyBHcmF2aXR5IGZvcmNlIChjb25zdGFudClcbiAgZ3Jhdml0eTogMSxcbiAgLy8gTWF4aW11bSBudW1iZXIgb2YgaXRlcmF0aW9ucyB0byBwZXJmb3JtXG4gIG51bUl0ZXI6IDEwMDAsXG4gIC8vIEluaXRpYWwgdGVtcGVyYXR1cmUgKG1heGltdW0gbm9kZSBkaXNwbGFjZW1lbnQpXG4gIGluaXRpYWxUZW1wOiAxMDAwLFxuICAvLyBDb29saW5nIGZhY3RvciAoaG93IHRoZSB0ZW1wZXJhdHVyZSBpcyByZWR1Y2VkIGJldHdlZW4gY29uc2VjdXRpdmUgaXRlcmF0aW9uc1xuICBjb29saW5nRmFjdG9yOiAwLjk5LFxuICAvLyBMb3dlciB0ZW1wZXJhdHVyZSB0aHJlc2hvbGQgKGJlbG93IHRoaXMgcG9pbnQgdGhlIGxheW91dCB3aWxsIGVuZClcbiAgbWluVGVtcDogMS4wXG59O1xuXG4vKipcbiAqIEBicmllZiAgICAgICA6IGNvbnN0cnVjdG9yXG4gKiBAYXJnIG9wdGlvbnMgOiBvYmplY3QgY29udGFpbmluZyBsYXlvdXQgb3B0aW9uc1xuICovXG5mdW5jdGlvbiBDb3NlTGF5b3V0KG9wdGlvbnMpIHtcbiAgdGhpcy5vcHRpb25zID0gZXh0ZW5kKHt9LCBkZWZhdWx0cyQ0LCBvcHRpb25zKTtcbiAgdGhpcy5vcHRpb25zLmxheW91dCA9IHRoaXM7XG5cbiAgLy8gRXhjbHVkZSBhbnkgZWRnZSB0aGF0IGhhcyBhIHNvdXJjZSBvciB0YXJnZXQgbm9kZSB0aGF0IGlzIG5vdCBpbiB0aGUgc2V0IG9mIHBhc3NlZC1pbiBub2Rlc1xuICB2YXIgbm9kZXMgPSB0aGlzLm9wdGlvbnMuZWxlcy5ub2RlcygpO1xuICB2YXIgZWRnZXMgPSB0aGlzLm9wdGlvbnMuZWxlcy5lZGdlcygpO1xuICB2YXIgbm90RWRnZXMgPSBlZGdlcy5maWx0ZXIoZnVuY3Rpb24gKGUpIHtcbiAgICB2YXIgc291cmNlSWQgPSBlLnNvdXJjZSgpLmRhdGEoJ2lkJyk7XG4gICAgdmFyIHRhcmdldElkID0gZS50YXJnZXQoKS5kYXRhKCdpZCcpO1xuICAgIHZhciBoYXNTb3VyY2UgPSBub2Rlcy5zb21lKGZ1bmN0aW9uIChuKSB7XG4gICAgICByZXR1cm4gbi5kYXRhKCdpZCcpID09PSBzb3VyY2VJZDtcbiAgICB9KTtcbiAgICB2YXIgaGFzVGFyZ2V0ID0gbm9kZXMuc29tZShmdW5jdGlvbiAobikge1xuICAgICAgcmV0dXJuIG4uZGF0YSgnaWQnKSA9PT0gdGFyZ2V0SWQ7XG4gICAgfSk7XG4gICAgcmV0dXJuICFoYXNTb3VyY2UgfHwgIWhhc1RhcmdldDtcbiAgfSk7XG4gIHRoaXMub3B0aW9ucy5lbGVzID0gdGhpcy5vcHRpb25zLmVsZXMubm90KG5vdEVkZ2VzKTtcbn1cblxuLyoqXG4gKiBAYnJpZWYgOiBydW5zIHRoZSBsYXlvdXRcbiAqL1xuQ29zZUxheW91dC5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgdmFyIGN5ID0gb3B0aW9ucy5jeTtcbiAgdmFyIGxheW91dCA9IHRoaXM7XG4gIGxheW91dC5zdG9wcGVkID0gZmFsc2U7XG4gIGlmIChvcHRpb25zLmFuaW1hdGUgPT09IHRydWUgfHwgb3B0aW9ucy5hbmltYXRlID09PSBmYWxzZSkge1xuICAgIGxheW91dC5lbWl0KHtcbiAgICAgIHR5cGU6ICdsYXlvdXRzdGFydCcsXG4gICAgICBsYXlvdXQ6IGxheW91dFxuICAgIH0pO1xuICB9XG5cbiAgLy8gU2V0IERFQlVHIC0gR2xvYmFsIHZhcmlhYmxlXG4gIGlmICh0cnVlID09PSBvcHRpb25zLmRlYnVnKSB7XG4gICAgREVCVUcgPSB0cnVlO1xuICB9IGVsc2Uge1xuICAgIERFQlVHID0gZmFsc2U7XG4gIH1cblxuICAvLyBJbml0aWFsaXplIGxheW91dCBpbmZvXG4gIHZhciBsYXlvdXRJbmZvID0gY3JlYXRlTGF5b3V0SW5mbyhjeSwgbGF5b3V0LCBvcHRpb25zKTtcblxuICAvLyBTaG93IExheW91dEluZm8gY29udGVudHMgaWYgZGVidWdnaW5nXG4gIGlmIChERUJVRykge1xuICAgIHByaW50TGF5b3V0SW5mbyhsYXlvdXRJbmZvKTtcbiAgfVxuXG4gIC8vIElmIHJlcXVpcmVkLCByYW5kb21pemUgbm9kZSBwb3NpdGlvbnNcbiAgaWYgKG9wdGlvbnMucmFuZG9taXplKSB7XG4gICAgcmFuZG9taXplUG9zaXRpb25zKGxheW91dEluZm8pO1xuICB9XG4gIHZhciBzdGFydFRpbWUgPSBwZXJmb3JtYW5jZU5vdygpO1xuICB2YXIgcmVmcmVzaCA9IGZ1bmN0aW9uIHJlZnJlc2goKSB7XG4gICAgcmVmcmVzaFBvc2l0aW9ucyhsYXlvdXRJbmZvLCBjeSwgb3B0aW9ucyk7XG5cbiAgICAvLyBGaXQgdGhlIGdyYXBoIGlmIG5lY2Vzc2FyeVxuICAgIGlmICh0cnVlID09PSBvcHRpb25zLmZpdCkge1xuICAgICAgY3kuZml0KG9wdGlvbnMucGFkZGluZyk7XG4gICAgfVxuICB9O1xuICB2YXIgbWFpbkxvb3AgPSBmdW5jdGlvbiBtYWluTG9vcChpKSB7XG4gICAgaWYgKGxheW91dC5zdG9wcGVkIHx8IGkgPj0gb3B0aW9ucy5udW1JdGVyKSB7XG4gICAgICAvLyBsb2dEZWJ1ZyhcIkxheW91dCBtYW51YWxseSBzdG9wcGVkLiBTdG9wcGluZyBjb21wdXRhdGlvbiBpbiBzdGVwIFwiICsgaSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gRG8gb25lIHN0ZXAgaW4gdGhlIHBoaXNpY2FsIHNpbXVsYXRpb25cbiAgICBzdGVwKGxheW91dEluZm8sIG9wdGlvbnMpO1xuXG4gICAgLy8gVXBkYXRlIHRlbXBlcmF0dXJlXG4gICAgbGF5b3V0SW5mby50ZW1wZXJhdHVyZSA9IGxheW91dEluZm8udGVtcGVyYXR1cmUgKiBvcHRpb25zLmNvb2xpbmdGYWN0b3I7XG4gICAgLy8gbG9nRGVidWcoXCJOZXcgdGVtcGVyYXR1cmU6IFwiICsgbGF5b3V0SW5mby50ZW1wZXJhdHVyZSk7XG5cbiAgICBpZiAobGF5b3V0SW5mby50ZW1wZXJhdHVyZSA8IG9wdGlvbnMubWluVGVtcCkge1xuICAgICAgLy8gbG9nRGVidWcoXCJUZW1wZXJhdHVyZSBkcm9wIGJlbG93IG1pbmltdW0gdGhyZXNob2xkLiBTdG9wcGluZyBjb21wdXRhdGlvbiBpbiBzdGVwIFwiICsgaSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuICB2YXIgZG9uZSA9IGZ1bmN0aW9uIGRvbmUoKSB7XG4gICAgaWYgKG9wdGlvbnMuYW5pbWF0ZSA9PT0gdHJ1ZSB8fCBvcHRpb25zLmFuaW1hdGUgPT09IGZhbHNlKSB7XG4gICAgICByZWZyZXNoKCk7XG5cbiAgICAgIC8vIExheW91dCBoYXMgZmluaXNoZWRcbiAgICAgIGxheW91dC5vbmUoJ2xheW91dHN0b3AnLCBvcHRpb25zLnN0b3ApO1xuICAgICAgbGF5b3V0LmVtaXQoe1xuICAgICAgICB0eXBlOiAnbGF5b3V0c3RvcCcsXG4gICAgICAgIGxheW91dDogbGF5b3V0XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIG5vZGVzID0gb3B0aW9ucy5lbGVzLm5vZGVzKCk7XG4gICAgICB2YXIgZ2V0U2NhbGVkUG9zID0gZ2V0U2NhbGVJbkJvdW5kc0ZuKGxheW91dEluZm8sIG9wdGlvbnMsIG5vZGVzKTtcbiAgICAgIG5vZGVzLmxheW91dFBvc2l0aW9ucyhsYXlvdXQsIG9wdGlvbnMsIGdldFNjYWxlZFBvcyk7XG4gICAgfVxuICB9O1xuICB2YXIgaSA9IDA7XG4gIHZhciBsb29wUmV0ID0gdHJ1ZTtcbiAgaWYgKG9wdGlvbnMuYW5pbWF0ZSA9PT0gdHJ1ZSkge1xuICAgIHZhciBmcmFtZSA9IGZ1bmN0aW9uIGZyYW1lKCkge1xuICAgICAgdmFyIGYgPSAwO1xuICAgICAgd2hpbGUgKGxvb3BSZXQgJiYgZiA8IG9wdGlvbnMucmVmcmVzaCkge1xuICAgICAgICBsb29wUmV0ID0gbWFpbkxvb3AoaSk7XG4gICAgICAgIGkrKztcbiAgICAgICAgZisrO1xuICAgICAgfVxuICAgICAgaWYgKCFsb29wUmV0KSB7XG4gICAgICAgIC8vIGl0J3MgZG9uZVxuICAgICAgICBzZXBhcmF0ZUNvbXBvbmVudHMobGF5b3V0SW5mbywgb3B0aW9ucyk7XG4gICAgICAgIGRvbmUoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBub3cgPSBwZXJmb3JtYW5jZU5vdygpO1xuICAgICAgICBpZiAobm93IC0gc3RhcnRUaW1lID49IG9wdGlvbnMuYW5pbWF0aW9uVGhyZXNob2xkKSB7XG4gICAgICAgICAgcmVmcmVzaCgpO1xuICAgICAgICB9XG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShmcmFtZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBmcmFtZSgpO1xuICB9IGVsc2Uge1xuICAgIHdoaWxlIChsb29wUmV0KSB7XG4gICAgICBsb29wUmV0ID0gbWFpbkxvb3AoaSk7XG4gICAgICBpKys7XG4gICAgfVxuICAgIHNlcGFyYXRlQ29tcG9uZW50cyhsYXlvdXRJbmZvLCBvcHRpb25zKTtcbiAgICBkb25lKCk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG59O1xuXG4vKipcbiAqIEBicmllZiA6IGNhbGxlZCBvbiBjb250aW51b3VzIGxheW91dHMgdG8gc3RvcCB0aGVtIGJlZm9yZSB0aGV5IGZpbmlzaFxuICovXG5Db3NlTGF5b3V0LnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLnN0b3BwZWQgPSB0cnVlO1xuICBpZiAodGhpcy50aHJlYWQpIHtcbiAgICB0aGlzLnRocmVhZC5zdG9wKCk7XG4gIH1cbiAgdGhpcy5lbWl0KCdsYXlvdXRzdG9wJyk7XG4gIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xufTtcblxuQ29zZUxheW91dC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMudGhyZWFkKSB7XG4gICAgdGhpcy50aHJlYWQuc3RvcCgpO1xuICB9XG4gIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xufTtcblxuLyoqXG4gKiBAYnJpZWYgICAgIDogQ3JlYXRlcyBhbiBvYmplY3Qgd2hpY2ggaXMgY29udGFpbnMgYWxsIHRoZSBkYXRhXG4gKiAgICAgICAgICAgICAgdXNlZCBpbiB0aGUgbGF5b3V0IHByb2Nlc3NcbiAqIEBhcmcgY3kgICAgOiBjeXRvc2NhcGUuanMgb2JqZWN0XG4gKiBAcmV0dXJuICAgIDogbGF5b3V0SW5mbyBvYmplY3QgaW5pdGlhbGl6ZWRcbiAqL1xudmFyIGNyZWF0ZUxheW91dEluZm8gPSBmdW5jdGlvbiBjcmVhdGVMYXlvdXRJbmZvKGN5LCBsYXlvdXQsIG9wdGlvbnMpIHtcbiAgLy8gU2hvcnRjdXRcbiAgdmFyIGVkZ2VzID0gb3B0aW9ucy5lbGVzLmVkZ2VzKCk7XG4gIHZhciBub2RlcyA9IG9wdGlvbnMuZWxlcy5ub2RlcygpO1xuICB2YXIgYmIgPSBtYWtlQm91bmRpbmdCb3gob3B0aW9ucy5ib3VuZGluZ0JveCA/IG9wdGlvbnMuYm91bmRpbmdCb3ggOiB7XG4gICAgeDE6IDAsXG4gICAgeTE6IDAsXG4gICAgdzogY3kud2lkdGgoKSxcbiAgICBoOiBjeS5oZWlnaHQoKVxuICB9KTtcbiAgdmFyIGxheW91dEluZm8gPSB7XG4gICAgaXNDb21wb3VuZDogY3kuaGFzQ29tcG91bmROb2RlcygpLFxuICAgIGxheW91dE5vZGVzOiBbXSxcbiAgICBpZFRvSW5kZXg6IHt9LFxuICAgIG5vZGVTaXplOiBub2Rlcy5zaXplKCksXG4gICAgZ3JhcGhTZXQ6IFtdLFxuICAgIGluZGV4VG9HcmFwaDogW10sXG4gICAgbGF5b3V0RWRnZXM6IFtdLFxuICAgIGVkZ2VTaXplOiBlZGdlcy5zaXplKCksXG4gICAgdGVtcGVyYXR1cmU6IG9wdGlvbnMuaW5pdGlhbFRlbXAsXG4gICAgY2xpZW50V2lkdGg6IGJiLncsXG4gICAgY2xpZW50SGVpZ2h0OiBiYi5oLFxuICAgIGJvdW5kaW5nQm94OiBiYlxuICB9O1xuICB2YXIgY29tcG9uZW50cyA9IG9wdGlvbnMuZWxlcy5jb21wb25lbnRzKCk7XG4gIHZhciBpZDJjbXB0SWQgPSB7fTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb21wb25lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGNvbXBvbmVudCA9IGNvbXBvbmVudHNbaV07XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBjb21wb25lbnQubGVuZ3RoOyBqKyspIHtcbiAgICAgIHZhciBub2RlID0gY29tcG9uZW50W2pdO1xuICAgICAgaWQyY21wdElkW25vZGUuaWQoKV0gPSBpO1xuICAgIH1cbiAgfVxuXG4gIC8vIEl0ZXJhdGUgb3ZlciBhbGwgbm9kZXMsIGNyZWF0aW5nIGxheW91dCBub2Rlc1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxheW91dEluZm8ubm9kZVNpemU7IGkrKykge1xuICAgIHZhciBuID0gbm9kZXNbaV07XG4gICAgdmFyIG5iYiA9IG4ubGF5b3V0RGltZW5zaW9ucyhvcHRpb25zKTtcbiAgICB2YXIgdGVtcE5vZGUgPSB7fTtcbiAgICB0ZW1wTm9kZS5pc0xvY2tlZCA9IG4ubG9ja2VkKCk7XG4gICAgdGVtcE5vZGUuaWQgPSBuLmRhdGEoJ2lkJyk7XG4gICAgdGVtcE5vZGUucGFyZW50SWQgPSBuLmRhdGEoJ3BhcmVudCcpO1xuICAgIHRlbXBOb2RlLmNtcHRJZCA9IGlkMmNtcHRJZFtuLmlkKCldO1xuICAgIHRlbXBOb2RlLmNoaWxkcmVuID0gW107XG4gICAgdGVtcE5vZGUucG9zaXRpb25YID0gbi5wb3NpdGlvbigneCcpO1xuICAgIHRlbXBOb2RlLnBvc2l0aW9uWSA9IG4ucG9zaXRpb24oJ3knKTtcbiAgICB0ZW1wTm9kZS5vZmZzZXRYID0gMDtcbiAgICB0ZW1wTm9kZS5vZmZzZXRZID0gMDtcbiAgICB0ZW1wTm9kZS5oZWlnaHQgPSBuYmIudztcbiAgICB0ZW1wTm9kZS53aWR0aCA9IG5iYi5oO1xuICAgIHRlbXBOb2RlLm1heFggPSB0ZW1wTm9kZS5wb3NpdGlvblggKyB0ZW1wTm9kZS53aWR0aCAvIDI7XG4gICAgdGVtcE5vZGUubWluWCA9IHRlbXBOb2RlLnBvc2l0aW9uWCAtIHRlbXBOb2RlLndpZHRoIC8gMjtcbiAgICB0ZW1wTm9kZS5tYXhZID0gdGVtcE5vZGUucG9zaXRpb25ZICsgdGVtcE5vZGUuaGVpZ2h0IC8gMjtcbiAgICB0ZW1wTm9kZS5taW5ZID0gdGVtcE5vZGUucG9zaXRpb25ZIC0gdGVtcE5vZGUuaGVpZ2h0IC8gMjtcbiAgICB0ZW1wTm9kZS5wYWRMZWZ0ID0gcGFyc2VGbG9hdChuLnN0eWxlKCdwYWRkaW5nJykpO1xuICAgIHRlbXBOb2RlLnBhZFJpZ2h0ID0gcGFyc2VGbG9hdChuLnN0eWxlKCdwYWRkaW5nJykpO1xuICAgIHRlbXBOb2RlLnBhZFRvcCA9IHBhcnNlRmxvYXQobi5zdHlsZSgncGFkZGluZycpKTtcbiAgICB0ZW1wTm9kZS5wYWRCb3R0b20gPSBwYXJzZUZsb2F0KG4uc3R5bGUoJ3BhZGRpbmcnKSk7XG5cbiAgICAvLyBmb3JjZXNcbiAgICB0ZW1wTm9kZS5ub2RlUmVwdWxzaW9uID0gZm4kNihvcHRpb25zLm5vZGVSZXB1bHNpb24pID8gb3B0aW9ucy5ub2RlUmVwdWxzaW9uKG4pIDogb3B0aW9ucy5ub2RlUmVwdWxzaW9uO1xuXG4gICAgLy8gQWRkIG5ldyBub2RlXG4gICAgbGF5b3V0SW5mby5sYXlvdXROb2Rlcy5wdXNoKHRlbXBOb2RlKTtcbiAgICAvLyBBZGQgZW50cnkgdG8gaWQtaW5kZXggbWFwXG4gICAgbGF5b3V0SW5mby5pZFRvSW5kZXhbdGVtcE5vZGUuaWRdID0gaTtcbiAgfVxuXG4gIC8vIElubGluZSBpbXBsZW1lbnRhdGlvbiBvZiBhIHF1ZXVlLCB1c2VkIGZvciB0cmF2ZXJzaW5nIHRoZSBncmFwaCBpbiBCRlMgb3JkZXJcbiAgdmFyIHF1ZXVlID0gW107XG4gIHZhciBzdGFydCA9IDA7IC8vIFBvaW50cyB0byB0aGUgc3RhcnQgdGhlIHF1ZXVlXG4gIHZhciBlbmQgPSAtMTsgLy8gUG9pbnRzIHRvIHRoZSBlbmQgb2YgdGhlIHF1ZXVlXG5cbiAgdmFyIHRlbXBHcmFwaCA9IFtdO1xuXG4gIC8vIFNlY29uZCBwYXNzIHRvIGFkZCBjaGlsZCBpbmZvcm1hdGlvbiBhbmRcbiAgLy8gaW5pdGlhbGl6ZSBxdWV1ZSBmb3IgaGllcmFyY2hpY2FsIHRyYXZlcnNhbFxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxheW91dEluZm8ubm9kZVNpemU7IGkrKykge1xuICAgIHZhciBuID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1tpXTtcbiAgICB2YXIgcF9pZCA9IG4ucGFyZW50SWQ7XG4gICAgLy8gQ2hlY2sgaWYgbm9kZSBuIGhhcyBhIHBhcmVudCBub2RlXG4gICAgaWYgKG51bGwgIT0gcF9pZCkge1xuICAgICAgLy8gQWRkIG5vZGUgSWQgdG8gcGFyZW50J3MgbGlzdCBvZiBjaGlsZHJlblxuICAgICAgbGF5b3V0SW5mby5sYXlvdXROb2Rlc1tsYXlvdXRJbmZvLmlkVG9JbmRleFtwX2lkXV0uY2hpbGRyZW4ucHVzaChuLmlkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgYSBub2RlIGRvZXNuJ3QgaGF2ZSBhIHBhcmVudCwgdGhlbiBpdCdzIGluIHRoZSByb290IGdyYXBoXG4gICAgICBxdWV1ZVsrK2VuZF0gPSBuLmlkO1xuICAgICAgdGVtcEdyYXBoLnB1c2gobi5pZCk7XG4gICAgfVxuICB9XG5cbiAgLy8gQWRkIHJvb3QgZ3JhcGggdG8gZ3JhcGhTZXRcbiAgbGF5b3V0SW5mby5ncmFwaFNldC5wdXNoKHRlbXBHcmFwaCk7XG5cbiAgLy8gVHJhdmVyc2UgdGhlIGdyYXBoLCBsZXZlbCBieSBsZXZlbCxcbiAgd2hpbGUgKHN0YXJ0IDw9IGVuZCkge1xuICAgIC8vIEdldCB0aGUgbm9kZSB0byB2aXNpdCBhbmQgcmVtb3ZlIGl0IGZyb20gcXVldWVcbiAgICB2YXIgbm9kZV9pZCA9IHF1ZXVlW3N0YXJ0KytdO1xuICAgIHZhciBub2RlX2l4ID0gbGF5b3V0SW5mby5pZFRvSW5kZXhbbm9kZV9pZF07XG4gICAgdmFyIG5vZGUgPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzW25vZGVfaXhdO1xuICAgIHZhciBjaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW47XG4gICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgIC8vIEFkZCBjaGlsZHJlbiBub2RlcyBhcyBhIG5ldyBncmFwaCB0byBncmFwaCBzZXRcbiAgICAgIGxheW91dEluZm8uZ3JhcGhTZXQucHVzaChjaGlsZHJlbik7XG4gICAgICAvLyBBZGQgY2hpbGRyZW4gdG8gcXVlIHF1ZXVlIHRvIGJlIHZpc2l0ZWRcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcXVldWVbKytlbmRdID0gY2hpbGRyZW5baV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gQ3JlYXRlIGluZGV4VG9HcmFwaCBtYXBcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXlvdXRJbmZvLmdyYXBoU2V0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGdyYXBoID0gbGF5b3V0SW5mby5ncmFwaFNldFtpXTtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IGdyYXBoLmxlbmd0aDsgaisrKSB7XG4gICAgICB2YXIgaW5kZXggPSBsYXlvdXRJbmZvLmlkVG9JbmRleFtncmFwaFtqXV07XG4gICAgICBsYXlvdXRJbmZvLmluZGV4VG9HcmFwaFtpbmRleF0gPSBpO1xuICAgIH1cbiAgfVxuXG4gIC8vIEl0ZXJhdGUgb3ZlciBhbGwgZWRnZXMsIGNyZWF0aW5nIExheW91dCBFZGdlc1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxheW91dEluZm8uZWRnZVNpemU7IGkrKykge1xuICAgIHZhciBlID0gZWRnZXNbaV07XG4gICAgdmFyIHRlbXBFZGdlID0ge307XG4gICAgdGVtcEVkZ2UuaWQgPSBlLmRhdGEoJ2lkJyk7XG4gICAgdGVtcEVkZ2Uuc291cmNlSWQgPSBlLmRhdGEoJ3NvdXJjZScpO1xuICAgIHRlbXBFZGdlLnRhcmdldElkID0gZS5kYXRhKCd0YXJnZXQnKTtcblxuICAgIC8vIENvbXB1dGUgaWRlYWwgbGVuZ3RoXG4gICAgdmFyIGlkZWFsTGVuZ3RoID0gZm4kNihvcHRpb25zLmlkZWFsRWRnZUxlbmd0aCkgPyBvcHRpb25zLmlkZWFsRWRnZUxlbmd0aChlKSA6IG9wdGlvbnMuaWRlYWxFZGdlTGVuZ3RoO1xuICAgIHZhciBlbGFzdGljaXR5ID0gZm4kNihvcHRpb25zLmVkZ2VFbGFzdGljaXR5KSA/IG9wdGlvbnMuZWRnZUVsYXN0aWNpdHkoZSkgOiBvcHRpb25zLmVkZ2VFbGFzdGljaXR5O1xuXG4gICAgLy8gQ2hlY2sgaWYgaXQncyBhbiBpbnRlciBncmFwaCBlZGdlXG4gICAgdmFyIHNvdXJjZUl4ID0gbGF5b3V0SW5mby5pZFRvSW5kZXhbdGVtcEVkZ2Uuc291cmNlSWRdO1xuICAgIHZhciB0YXJnZXRJeCA9IGxheW91dEluZm8uaWRUb0luZGV4W3RlbXBFZGdlLnRhcmdldElkXTtcbiAgICB2YXIgc291cmNlR3JhcGggPSBsYXlvdXRJbmZvLmluZGV4VG9HcmFwaFtzb3VyY2VJeF07XG4gICAgdmFyIHRhcmdldEdyYXBoID0gbGF5b3V0SW5mby5pbmRleFRvR3JhcGhbdGFyZ2V0SXhdO1xuICAgIGlmIChzb3VyY2VHcmFwaCAhPSB0YXJnZXRHcmFwaCkge1xuICAgICAgLy8gRmluZCBsb3dlc3QgY29tbW9uIGdyYXBoIGFuY2VzdG9yXG4gICAgICB2YXIgbGNhID0gZmluZExDQSh0ZW1wRWRnZS5zb3VyY2VJZCwgdGVtcEVkZ2UudGFyZ2V0SWQsIGxheW91dEluZm8pO1xuXG4gICAgICAvLyBDb21wdXRlIHN1bSBvZiBub2RlIGRlcHRocywgcmVsYXRpdmUgdG8gbGNhIGdyYXBoXG4gICAgICB2YXIgbGNhR3JhcGggPSBsYXlvdXRJbmZvLmdyYXBoU2V0W2xjYV07XG4gICAgICB2YXIgZGVwdGggPSAwO1xuXG4gICAgICAvLyBTb3VyY2UgZGVwdGhcbiAgICAgIHZhciB0ZW1wTm9kZSA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbc291cmNlSXhdO1xuICAgICAgd2hpbGUgKC0xID09PSBsY2FHcmFwaC5pbmRleE9mKHRlbXBOb2RlLmlkKSkge1xuICAgICAgICB0ZW1wTm9kZSA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbbGF5b3V0SW5mby5pZFRvSW5kZXhbdGVtcE5vZGUucGFyZW50SWRdXTtcbiAgICAgICAgZGVwdGgrKztcbiAgICAgIH1cblxuICAgICAgLy8gVGFyZ2V0IGRlcHRoXG4gICAgICB0ZW1wTm9kZSA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbdGFyZ2V0SXhdO1xuICAgICAgd2hpbGUgKC0xID09PSBsY2FHcmFwaC5pbmRleE9mKHRlbXBOb2RlLmlkKSkge1xuICAgICAgICB0ZW1wTm9kZSA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbbGF5b3V0SW5mby5pZFRvSW5kZXhbdGVtcE5vZGUucGFyZW50SWRdXTtcbiAgICAgICAgZGVwdGgrKztcbiAgICAgIH1cblxuICAgICAgLy8gbG9nRGVidWcoJ0xDQSBvZiBub2RlcyAnICsgdGVtcEVkZ2Uuc291cmNlSWQgKyAnIGFuZCAnICsgdGVtcEVkZ2UudGFyZ2V0SWQgK1xuICAgICAgLy8gIFwiLiBJbmRleDogXCIgKyBsY2EgKyBcIiBDb250ZW50czogXCIgKyBsY2FHcmFwaC50b1N0cmluZygpICtcbiAgICAgIC8vICBcIi4gRGVwdGg6IFwiICsgZGVwdGgpO1xuXG4gICAgICAvLyBVcGRhdGUgaWRlYWxMZW5ndGhcbiAgICAgIGlkZWFsTGVuZ3RoICo9IGRlcHRoICogb3B0aW9ucy5uZXN0aW5nRmFjdG9yO1xuICAgIH1cbiAgICB0ZW1wRWRnZS5pZGVhbExlbmd0aCA9IGlkZWFsTGVuZ3RoO1xuICAgIHRlbXBFZGdlLmVsYXN0aWNpdHkgPSBlbGFzdGljaXR5O1xuICAgIGxheW91dEluZm8ubGF5b3V0RWRnZXMucHVzaCh0ZW1wRWRnZSk7XG4gIH1cblxuICAvLyBGaW5hbGx5LCByZXR1cm4gbGF5b3V0SW5mbyBvYmplY3RcbiAgcmV0dXJuIGxheW91dEluZm87XG59O1xuXG4vKipcbiAqIEBicmllZiA6IFRoaXMgZnVuY3Rpb24gZmluZHMgdGhlIGluZGV4IG9mIHRoZSBsb3dlc3QgY29tbW9uXG4gKiAgICAgICAgICBncmFwaCBhbmNlc3RvciBiZXR3ZWVuIDIgbm9kZXMgaW4gdGhlIHN1YnRyZWVcbiAqICAgICAgICAgIChmcm9tIHRoZSBncmFwaCBoaWVyYXJjaHkgaW5kdWNlZCB0cmVlKSB3aG9zZVxuICogICAgICAgICAgcm9vdCBpcyBncmFwaEl4XG4gKlxuICogQGFyZyBub2RlMTogbm9kZTEncyBJRFxuICogQGFyZyBub2RlMjogbm9kZTIncyBJRFxuICogQGFyZyBsYXlvdXRJbmZvOiBsYXlvdXRJbmZvIG9iamVjdFxuICpcbiAqL1xudmFyIGZpbmRMQ0EgPSBmdW5jdGlvbiBmaW5kTENBKG5vZGUxLCBub2RlMiwgbGF5b3V0SW5mbykge1xuICAvLyBGaW5kIHRoZWlyIGNvbW1vbiBhbmNlc3Rlciwgc3RhcnRpbmcgZnJvbSB0aGUgcm9vdCBncmFwaFxuICB2YXIgcmVzID0gZmluZExDQV9hdXgobm9kZTEsIG5vZGUyLCAwLCBsYXlvdXRJbmZvKTtcbiAgaWYgKDIgPiByZXMuY291bnQpIHtcbiAgICAvLyBJZiBhdXggZnVuY3Rpb24gY291bGRuJ3QgZmluZCB0aGUgY29tbW9uIGFuY2VzdGVyLFxuICAgIC8vIHRoZW4gaXQgaXMgdGhlIHJvb3QgZ3JhcGhcbiAgICByZXR1cm4gMDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcmVzLmdyYXBoO1xuICB9XG59O1xuXG4vKipcbiAqIEBicmllZiAgICAgICAgICA6IEF1eGlsaWFyeSBmdW5jdGlvbiB1c2VkIGZvciBMQ0EgY29tcHV0YXRpb25cbiAqXG4gKiBAYXJnIG5vZGUxICAgICAgOiBub2RlMSdzIElEXG4gKiBAYXJnIG5vZGUyICAgICAgOiBub2RlMidzIElEXG4gKiBAYXJnIGdyYXBoSXggICAgOiBzdWJncmFwaCBpbmRleFxuICogQGFyZyBsYXlvdXRJbmZvIDogbGF5b3V0SW5mbyBvYmplY3RcbiAqXG4gKiBAcmV0dXJuICAgICAgICAgOiBvYmplY3Qgb2YgdGhlIGZvcm0ge2NvdW50OiBYLCBncmFwaDogWX0sIHdoZXJlOlxuICogICAgICAgICAgICAgICAgICAgWCBpcyB0aGUgbnVtYmVyIG9mIGFuY2VzdG9ycyAobWF4OiAyKSBmb3VuZCBpblxuICogICAgICAgICAgICAgICAgICAgZ3JhcGhJeCAoYW5kIGl0J3Mgc3ViZ3JhcGhzKSxcbiAqICAgICAgICAgICAgICAgICAgIFkgaXMgdGhlIGdyYXBoIGluZGV4IG9mIHRoZSBsb3dlc3QgZ3JhcGggY29udGFpbmluZ1xuICogICAgICAgICAgICAgICAgICAgYWxsIFggbm9kZXNcbiAqL1xudmFyIGZpbmRMQ0FfYXV4ID0gZnVuY3Rpb24gZmluZExDQV9hdXgobm9kZTEsIG5vZGUyLCBncmFwaEl4LCBsYXlvdXRJbmZvKSB7XG4gIHZhciBncmFwaCA9IGxheW91dEluZm8uZ3JhcGhTZXRbZ3JhcGhJeF07XG4gIC8vIElmIGJvdGggbm9kZXMgYmVsb25ncyB0byBncmFwaEl4XG4gIGlmICgtMSA8IGdyYXBoLmluZGV4T2Yobm9kZTEpICYmIC0xIDwgZ3JhcGguaW5kZXhPZihub2RlMikpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY291bnQ6IDIsXG4gICAgICBncmFwaDogZ3JhcGhJeFxuICAgIH07XG4gIH1cblxuICAvLyBNYWtlIHJlY3Vyc2l2ZSBjYWxscyBmb3IgYWxsIHN1YmdyYXBoc1xuICB2YXIgYyA9IDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZ3JhcGgubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbm9kZUlkID0gZ3JhcGhbaV07XG4gICAgdmFyIG5vZGVJeCA9IGxheW91dEluZm8uaWRUb0luZGV4W25vZGVJZF07XG4gICAgdmFyIGNoaWxkcmVuID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1tub2RlSXhdLmNoaWxkcmVuO1xuXG4gICAgLy8gSWYgdGhlIG5vZGUgaGFzIG5vIGNoaWxkLCBza2lwIGl0XG4gICAgaWYgKDAgPT09IGNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHZhciBjaGlsZEdyYXBoSXggPSBsYXlvdXRJbmZvLmluZGV4VG9HcmFwaFtsYXlvdXRJbmZvLmlkVG9JbmRleFtjaGlsZHJlblswXV1dO1xuICAgIHZhciByZXN1bHQgPSBmaW5kTENBX2F1eChub2RlMSwgbm9kZTIsIGNoaWxkR3JhcGhJeCwgbGF5b3V0SW5mbyk7XG4gICAgaWYgKDAgPT09IHJlc3VsdC5jb3VudCkge1xuICAgICAgLy8gTmVpdGhlciBub2RlMSBub3Igbm9kZTIgYXJlIHByZXNlbnQgaW4gdGhpcyBzdWJncmFwaFxuICAgICAgY29udGludWU7XG4gICAgfSBlbHNlIGlmICgxID09PSByZXN1bHQuY291bnQpIHtcbiAgICAgIC8vIE9uZSBvZiAobm9kZTEsIG5vZGUyKSBpcyBwcmVzZW50IGluIHRoaXMgc3ViZ3JhcGhcbiAgICAgIGMrKztcbiAgICAgIGlmICgyID09PSBjKSB7XG4gICAgICAgIC8vIFdlJ3ZlIGFscmVhZHkgZm91bmQgYm90aCBub2Rlcywgbm8gbmVlZCB0byBrZWVwIHNlYXJjaGluZ1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQm90aCBub2RlcyBhcmUgcHJlc2VudCBpbiB0aGlzIHN1YmdyYXBoXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIGNvdW50OiBjLFxuICAgIGdyYXBoOiBncmFwaEl4XG4gIH07XG59O1xuXG4vKipcbiAqIEBicmllZjogcHJpbnRzTGF5b3V0SW5mbyBpbnRvIGpzIGNvbnNvbGVcbiAqICAgICAgICAgT25seSB1c2VkIGZvciBkZWJidWdpbmdcbiAqL1xudmFyIHByaW50TGF5b3V0SW5mbzsgXG5cbi8qKlxuICogQGJyaWVmIDogUmFuZG9taXplcyB0aGUgcG9zaXRpb24gb2YgYWxsIG5vZGVzXG4gKi9cbnZhciByYW5kb21pemVQb3NpdGlvbnMgPSBmdW5jdGlvbiByYW5kb21pemVQb3NpdGlvbnMobGF5b3V0SW5mbywgY3kpIHtcbiAgdmFyIHdpZHRoID0gbGF5b3V0SW5mby5jbGllbnRXaWR0aDtcbiAgdmFyIGhlaWdodCA9IGxheW91dEluZm8uY2xpZW50SGVpZ2h0O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxheW91dEluZm8ubm9kZVNpemU7IGkrKykge1xuICAgIHZhciBuID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1tpXTtcblxuICAgIC8vIE5vIG5lZWQgdG8gcmFuZG9taXplIGNvbXBvdW5kIG5vZGVzIG9yIGxvY2tlZCBub2Rlc1xuICAgIGlmICgwID09PSBuLmNoaWxkcmVuLmxlbmd0aCAmJiAhbi5pc0xvY2tlZCkge1xuICAgICAgbi5wb3NpdGlvblggPSBNYXRoLnJhbmRvbSgpICogd2lkdGg7XG4gICAgICBuLnBvc2l0aW9uWSA9IE1hdGgucmFuZG9tKCkgKiBoZWlnaHQ7XG4gICAgfVxuICB9XG59O1xudmFyIGdldFNjYWxlSW5Cb3VuZHNGbiA9IGZ1bmN0aW9uIGdldFNjYWxlSW5Cb3VuZHNGbihsYXlvdXRJbmZvLCBvcHRpb25zLCBub2Rlcykge1xuICB2YXIgYmIgPSBsYXlvdXRJbmZvLmJvdW5kaW5nQm94O1xuICB2YXIgY29zZUJCID0ge1xuICAgIHgxOiBJbmZpbml0eSxcbiAgICB4MjogLUluZmluaXR5LFxuICAgIHkxOiBJbmZpbml0eSxcbiAgICB5MjogLUluZmluaXR5XG4gIH07XG4gIGlmIChvcHRpb25zLmJvdW5kaW5nQm94KSB7XG4gICAgbm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgdmFyIGxub2RlID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1tsYXlvdXRJbmZvLmlkVG9JbmRleFtub2RlLmRhdGEoJ2lkJyldXTtcbiAgICAgIGNvc2VCQi54MSA9IE1hdGgubWluKGNvc2VCQi54MSwgbG5vZGUucG9zaXRpb25YKTtcbiAgICAgIGNvc2VCQi54MiA9IE1hdGgubWF4KGNvc2VCQi54MiwgbG5vZGUucG9zaXRpb25YKTtcbiAgICAgIGNvc2VCQi55MSA9IE1hdGgubWluKGNvc2VCQi55MSwgbG5vZGUucG9zaXRpb25ZKTtcbiAgICAgIGNvc2VCQi55MiA9IE1hdGgubWF4KGNvc2VCQi55MiwgbG5vZGUucG9zaXRpb25ZKTtcbiAgICB9KTtcbiAgICBjb3NlQkIudyA9IGNvc2VCQi54MiAtIGNvc2VCQi54MTtcbiAgICBjb3NlQkIuaCA9IGNvc2VCQi55MiAtIGNvc2VCQi55MTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24gKGVsZSwgaSkge1xuICAgIHZhciBsbm9kZSA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbbGF5b3V0SW5mby5pZFRvSW5kZXhbZWxlLmRhdGEoJ2lkJyldXTtcbiAgICBpZiAob3B0aW9ucy5ib3VuZGluZ0JveCkge1xuICAgICAgLy8gdGhlbiBhZGQgZXh0cmEgYm91bmRpbmcgYm94IGNvbnN0cmFpbnRcbiAgICAgIHZhciBwY3RYID0gKGxub2RlLnBvc2l0aW9uWCAtIGNvc2VCQi54MSkgLyBjb3NlQkIudztcbiAgICAgIHZhciBwY3RZID0gKGxub2RlLnBvc2l0aW9uWSAtIGNvc2VCQi55MSkgLyBjb3NlQkIuaDtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IGJiLngxICsgcGN0WCAqIGJiLncsXG4gICAgICAgIHk6IGJiLnkxICsgcGN0WSAqIGJiLmhcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IGxub2RlLnBvc2l0aW9uWCxcbiAgICAgICAgeTogbG5vZGUucG9zaXRpb25ZXG4gICAgICB9O1xuICAgIH1cbiAgfTtcbn07XG5cbi8qKlxuICogQGJyaWVmICAgICAgICAgIDogVXBkYXRlcyB0aGUgcG9zaXRpb25zIG9mIG5vZGVzIGluIHRoZSBuZXR3b3JrXG4gKiBAYXJnIGxheW91dEluZm8gOiBMYXlvdXRJbmZvIG9iamVjdFxuICogQGFyZyBjeSAgICAgICAgIDogQ3l0b3NjYXBlIG9iamVjdFxuICogQGFyZyBvcHRpb25zICAgIDogTGF5b3V0IG9wdGlvbnNcbiAqL1xudmFyIHJlZnJlc2hQb3NpdGlvbnMgPSBmdW5jdGlvbiByZWZyZXNoUG9zaXRpb25zKGxheW91dEluZm8sIGN5LCBvcHRpb25zKSB7XG4gIC8vIHZhciBzID0gJ1JlZnJlc2hpbmcgcG9zaXRpb25zJztcbiAgLy8gbG9nRGVidWcocyk7XG5cbiAgdmFyIGxheW91dCA9IG9wdGlvbnMubGF5b3V0O1xuICB2YXIgbm9kZXMgPSBvcHRpb25zLmVsZXMubm9kZXMoKTtcbiAgdmFyIGdldFNjYWxlZFBvcyA9IGdldFNjYWxlSW5Cb3VuZHNGbihsYXlvdXRJbmZvLCBvcHRpb25zLCBub2Rlcyk7XG4gIG5vZGVzLnBvc2l0aW9ucyhnZXRTY2FsZWRQb3MpO1xuXG4gIC8vIFRyaWdnZXIgbGF5b3V0UmVhZHkgb25seSBvbiBmaXJzdCBjYWxsXG4gIGlmICh0cnVlICE9PSBsYXlvdXRJbmZvLnJlYWR5KSB7XG4gICAgLy8gcyA9ICdUcmlnZ2VyaW5nIGxheW91dHJlYWR5JztcbiAgICAvLyBsb2dEZWJ1ZyhzKTtcbiAgICBsYXlvdXRJbmZvLnJlYWR5ID0gdHJ1ZTtcbiAgICBsYXlvdXQub25lKCdsYXlvdXRyZWFkeScsIG9wdGlvbnMucmVhZHkpO1xuICAgIGxheW91dC5lbWl0KHtcbiAgICAgIHR5cGU6ICdsYXlvdXRyZWFkeScsXG4gICAgICBsYXlvdXQ6IHRoaXNcbiAgICB9KTtcbiAgfVxufTtcblxuLyoqXG4gKiBAYnJpZWYgOiBMb2dzIGEgZGVidWcgbWVzc2FnZSBpbiBKUyBjb25zb2xlLCBpZiBERUJVRyBpcyBPTlxuICovXG4vLyB2YXIgbG9nRGVidWcgPSBmdW5jdGlvbih0ZXh0KSB7XG4vLyAgIGlmIChERUJVRykge1xuLy8gICAgIGNvbnNvbGUuZGVidWcodGV4dCk7XG4vLyAgIH1cbi8vIH07XG5cbi8qKlxuICogQGJyaWVmICAgICAgICAgIDogUGVyZm9ybXMgb25lIGl0ZXJhdGlvbiBvZiB0aGUgcGh5c2ljYWwgc2ltdWxhdGlvblxuICogQGFyZyBsYXlvdXRJbmZvIDogTGF5b3V0SW5mbyBvYmplY3QgYWxyZWFkeSBpbml0aWFsaXplZFxuICogQGFyZyBjeSAgICAgICAgIDogQ3l0b3NjYXBlIG9iamVjdFxuICogQGFyZyBvcHRpb25zICAgIDogTGF5b3V0IG9wdGlvbnNcbiAqL1xudmFyIHN0ZXAgPSBmdW5jdGlvbiBzdGVwKGxheW91dEluZm8sIG9wdGlvbnMsIF9zdGVwKSB7XG4gIC8vIHZhciBzID0gXCJcXG5cXG4jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXCI7XG4gIC8vIHMgKz0gXCJcXG5TVEVQOiBcIiArIHN0ZXA7XG4gIC8vIHMgKz0gXCJcXG4jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXFxuXCI7XG4gIC8vIGxvZ0RlYnVnKHMpO1xuXG4gIC8vIENhbGN1bGF0ZSBub2RlIHJlcHVsc2lvbnNcbiAgY2FsY3VsYXRlTm9kZUZvcmNlcyhsYXlvdXRJbmZvLCBvcHRpb25zKTtcbiAgLy8gQ2FsY3VsYXRlIGVkZ2UgZm9yY2VzXG4gIGNhbGN1bGF0ZUVkZ2VGb3JjZXMobGF5b3V0SW5mbyk7XG4gIC8vIENhbGN1bGF0ZSBncmF2aXR5IGZvcmNlc1xuICBjYWxjdWxhdGVHcmF2aXR5Rm9yY2VzKGxheW91dEluZm8sIG9wdGlvbnMpO1xuICAvLyBQcm9wYWdhdGUgZm9yY2VzIGZyb20gcGFyZW50IHRvIGNoaWxkXG4gIHByb3BhZ2F0ZUZvcmNlcyhsYXlvdXRJbmZvKTtcbiAgLy8gVXBkYXRlIHBvc2l0aW9ucyBiYXNlZCBvbiBjYWxjdWxhdGVkIGZvcmNlc1xuICB1cGRhdGVQb3NpdGlvbnMobGF5b3V0SW5mbyk7XG59O1xuXG4vKipcbiAqIEBicmllZiA6IENvbXB1dGVzIHRoZSBub2RlIHJlcHVsc2lvbiBmb3JjZXNcbiAqL1xudmFyIGNhbGN1bGF0ZU5vZGVGb3JjZXMgPSBmdW5jdGlvbiBjYWxjdWxhdGVOb2RlRm9yY2VzKGxheW91dEluZm8sIG9wdGlvbnMpIHtcbiAgLy8gR28gdGhyb3VnaCBlYWNoIG9mIHRoZSBncmFwaHMgaW4gZ3JhcGhTZXRcbiAgLy8gTm9kZXMgb25seSByZXBlbCBlYWNoIG90aGVyIGlmIHRoZXkgYmVsb25nIHRvIHRoZSBzYW1lIGdyYXBoXG4gIC8vIHZhciBzID0gJ2NhbGN1bGF0ZU5vZGVGb3JjZXMnO1xuICAvLyBsb2dEZWJ1ZyhzKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXlvdXRJbmZvLmdyYXBoU2V0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGdyYXBoID0gbGF5b3V0SW5mby5ncmFwaFNldFtpXTtcbiAgICB2YXIgbnVtTm9kZXMgPSBncmFwaC5sZW5ndGg7XG5cbiAgICAvLyBzID0gXCJTZXQ6IFwiICsgZ3JhcGgudG9TdHJpbmcoKTtcbiAgICAvLyBsb2dEZWJ1ZyhzKTtcblxuICAgIC8vIE5vdyBnZXQgYWxsIHRoZSBwYWlycyBvZiBub2Rlc1xuICAgIC8vIE9ubHkgZ2V0IGVhY2ggcGFpciBvbmNlLCAoQSwgQikgPSAoQiwgQSlcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IG51bU5vZGVzOyBqKyspIHtcbiAgICAgIHZhciBub2RlMSA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbbGF5b3V0SW5mby5pZFRvSW5kZXhbZ3JhcGhbal1dXTtcbiAgICAgIGZvciAodmFyIGsgPSBqICsgMTsgayA8IG51bU5vZGVzOyBrKyspIHtcbiAgICAgICAgdmFyIG5vZGUyID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1tsYXlvdXRJbmZvLmlkVG9JbmRleFtncmFwaFtrXV1dO1xuICAgICAgICBub2RlUmVwdWxzaW9uKG5vZGUxLCBub2RlMiwgbGF5b3V0SW5mbywgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xudmFyIHJhbmRvbURpc3RhbmNlID0gZnVuY3Rpb24gcmFuZG9tRGlzdGFuY2UobWF4KSB7XG4gIHJldHVybiAtbWF4ICsgMiAqIG1heCAqIE1hdGgucmFuZG9tKCk7XG59O1xuXG4vKipcbiAqIEBicmllZiA6IENvbXB1dGUgdGhlIG5vZGUgcmVwdWxzaW9uIGZvcmNlcyBiZXR3ZWVuIGEgcGFpciBvZiBub2Rlc1xuICovXG52YXIgbm9kZVJlcHVsc2lvbiA9IGZ1bmN0aW9uIG5vZGVSZXB1bHNpb24obm9kZTEsIG5vZGUyLCBsYXlvdXRJbmZvLCBvcHRpb25zKSB7XG4gIC8vIHZhciBzID0gXCJOb2RlIHJlcHVsc2lvbi4gTm9kZTE6IFwiICsgbm9kZTEuaWQgKyBcIiBOb2RlMjogXCIgKyBub2RlMi5pZDtcblxuICB2YXIgY21wdElkMSA9IG5vZGUxLmNtcHRJZDtcbiAgdmFyIGNtcHRJZDIgPSBub2RlMi5jbXB0SWQ7XG4gIGlmIChjbXB0SWQxICE9PSBjbXB0SWQyICYmICFsYXlvdXRJbmZvLmlzQ29tcG91bmQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBHZXQgZGlyZWN0aW9uIG9mIGxpbmUgY29ubmVjdGluZyBib3RoIG5vZGUgY2VudGVyc1xuICB2YXIgZGlyZWN0aW9uWCA9IG5vZGUyLnBvc2l0aW9uWCAtIG5vZGUxLnBvc2l0aW9uWDtcbiAgdmFyIGRpcmVjdGlvblkgPSBub2RlMi5wb3NpdGlvblkgLSBub2RlMS5wb3NpdGlvblk7XG4gIHZhciBtYXhSYW5kRGlzdCA9IDE7XG4gIC8vIHMgKz0gXCJcXG5kaXJlY3Rpb25YOiBcIiArIGRpcmVjdGlvblggKyBcIiwgZGlyZWN0aW9uWTogXCIgKyBkaXJlY3Rpb25ZO1xuXG4gIC8vIElmIGJvdGggY2VudGVycyBhcmUgdGhlIHNhbWUsIGFwcGx5IGEgcmFuZG9tIGZvcmNlXG4gIGlmICgwID09PSBkaXJlY3Rpb25YICYmIDAgPT09IGRpcmVjdGlvblkpIHtcbiAgICBkaXJlY3Rpb25YID0gcmFuZG9tRGlzdGFuY2UobWF4UmFuZERpc3QpO1xuICAgIGRpcmVjdGlvblkgPSByYW5kb21EaXN0YW5jZShtYXhSYW5kRGlzdCk7XG4gIH1cbiAgdmFyIG92ZXJsYXAgPSBub2Rlc092ZXJsYXAobm9kZTEsIG5vZGUyLCBkaXJlY3Rpb25YLCBkaXJlY3Rpb25ZKTtcbiAgaWYgKG92ZXJsYXAgPiAwKSB7XG4gICAgLy8gcyArPSBcIlxcbk5vZGVzIERPIG92ZXJsYXAuXCI7XG4gICAgLy8gcyArPSBcIlxcbk92ZXJsYXA6IFwiICsgb3ZlcmxhcDtcbiAgICAvLyBJZiBub2RlcyBvdmVybGFwLCByZXB1bHNpb24gZm9yY2UgaXMgcHJvcG9ydGlvbmFsXG4gICAgLy8gdG8gdGhlIG92ZXJsYXBcbiAgICB2YXIgZm9yY2UgPSBvcHRpb25zLm5vZGVPdmVybGFwICogb3ZlcmxhcDtcblxuICAgIC8vIENvbXB1dGUgdGhlIG1vZHVsZSBhbmQgY29tcG9uZW50cyBvZiB0aGUgZm9yY2UgdmVjdG9yXG4gICAgdmFyIGRpc3RhbmNlID0gTWF0aC5zcXJ0KGRpcmVjdGlvblggKiBkaXJlY3Rpb25YICsgZGlyZWN0aW9uWSAqIGRpcmVjdGlvblkpO1xuICAgIC8vIHMgKz0gXCJcXG5EaXN0YW5jZTogXCIgKyBkaXN0YW5jZTtcbiAgICB2YXIgZm9yY2VYID0gZm9yY2UgKiBkaXJlY3Rpb25YIC8gZGlzdGFuY2U7XG4gICAgdmFyIGZvcmNlWSA9IGZvcmNlICogZGlyZWN0aW9uWSAvIGRpc3RhbmNlO1xuICB9IGVsc2Uge1xuICAgIC8vIHMgKz0gXCJcXG5Ob2RlcyBkbyBOT1Qgb3ZlcmxhcC5cIjtcbiAgICAvLyBJZiB0aGVyZSdzIG5vIG92ZXJsYXAsIGZvcmNlIGlzIGludmVyc2VseSBwcm9wb3J0aW9uYWxcbiAgICAvLyB0byBzcXVhcmVkIGRpc3RhbmNlXG5cbiAgICAvLyBHZXQgY2xpcHBpbmcgcG9pbnRzIGZvciBib3RoIG5vZGVzXG4gICAgdmFyIHBvaW50MSA9IGZpbmRDbGlwcGluZ1BvaW50KG5vZGUxLCBkaXJlY3Rpb25YLCBkaXJlY3Rpb25ZKTtcbiAgICB2YXIgcG9pbnQyID0gZmluZENsaXBwaW5nUG9pbnQobm9kZTIsIC0xICogZGlyZWN0aW9uWCwgLTEgKiBkaXJlY3Rpb25ZKTtcblxuICAgIC8vIFVzZSBjbGlwcGluZyBwb2ludHMgdG8gY29tcHV0ZSBkaXN0YW5jZVxuICAgIHZhciBkaXN0YW5jZVggPSBwb2ludDIueCAtIHBvaW50MS54O1xuICAgIHZhciBkaXN0YW5jZVkgPSBwb2ludDIueSAtIHBvaW50MS55O1xuICAgIHZhciBkaXN0YW5jZVNxciA9IGRpc3RhbmNlWCAqIGRpc3RhbmNlWCArIGRpc3RhbmNlWSAqIGRpc3RhbmNlWTtcbiAgICB2YXIgZGlzdGFuY2UgPSBNYXRoLnNxcnQoZGlzdGFuY2VTcXIpO1xuICAgIC8vIHMgKz0gXCJcXG5EaXN0YW5jZTogXCIgKyBkaXN0YW5jZTtcblxuICAgIC8vIENvbXB1dGUgdGhlIG1vZHVsZSBhbmQgY29tcG9uZW50cyBvZiB0aGUgZm9yY2UgdmVjdG9yXG4gICAgdmFyIGZvcmNlID0gKG5vZGUxLm5vZGVSZXB1bHNpb24gKyBub2RlMi5ub2RlUmVwdWxzaW9uKSAvIGRpc3RhbmNlU3FyO1xuICAgIHZhciBmb3JjZVggPSBmb3JjZSAqIGRpc3RhbmNlWCAvIGRpc3RhbmNlO1xuICAgIHZhciBmb3JjZVkgPSBmb3JjZSAqIGRpc3RhbmNlWSAvIGRpc3RhbmNlO1xuICB9XG5cbiAgLy8gQXBwbHkgZm9yY2VcbiAgaWYgKCFub2RlMS5pc0xvY2tlZCkge1xuICAgIG5vZGUxLm9mZnNldFggLT0gZm9yY2VYO1xuICAgIG5vZGUxLm9mZnNldFkgLT0gZm9yY2VZO1xuICB9XG4gIGlmICghbm9kZTIuaXNMb2NrZWQpIHtcbiAgICBub2RlMi5vZmZzZXRYICs9IGZvcmNlWDtcbiAgICBub2RlMi5vZmZzZXRZICs9IGZvcmNlWTtcbiAgfVxuXG4gIC8vIHMgKz0gXCJcXG5Gb3JjZVg6IFwiICsgZm9yY2VYICsgXCIgRm9yY2VZOiBcIiArIGZvcmNlWTtcbiAgLy8gbG9nRGVidWcocyk7XG5cbiAgcmV0dXJuO1xufTtcblxuLyoqXG4gKiBAYnJpZWYgIDogRGV0ZXJtaW5lcyB3aGV0aGVyIHR3byBub2RlcyBvdmVybGFwIG9yIG5vdFxuICogQHJldHVybiA6IEFtb3VudCBvZiBvdmVybGFwcGluZyAoMCA9PiBubyBvdmVybGFwKVxuICovXG52YXIgbm9kZXNPdmVybGFwID0gZnVuY3Rpb24gbm9kZXNPdmVybGFwKG5vZGUxLCBub2RlMiwgZFgsIGRZKSB7XG4gIGlmIChkWCA+IDApIHtcbiAgICB2YXIgb3ZlcmxhcFggPSBub2RlMS5tYXhYIC0gbm9kZTIubWluWDtcbiAgfSBlbHNlIHtcbiAgICB2YXIgb3ZlcmxhcFggPSBub2RlMi5tYXhYIC0gbm9kZTEubWluWDtcbiAgfVxuICBpZiAoZFkgPiAwKSB7XG4gICAgdmFyIG92ZXJsYXBZID0gbm9kZTEubWF4WSAtIG5vZGUyLm1pblk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIG92ZXJsYXBZID0gbm9kZTIubWF4WSAtIG5vZGUxLm1pblk7XG4gIH1cbiAgaWYgKG92ZXJsYXBYID49IDAgJiYgb3ZlcmxhcFkgPj0gMCkge1xuICAgIHJldHVybiBNYXRoLnNxcnQob3ZlcmxhcFggKiBvdmVybGFwWCArIG92ZXJsYXBZICogb3ZlcmxhcFkpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAwO1xuICB9XG59O1xuXG4vKipcbiAqIEBicmllZiA6IEZpbmRzIHRoZSBwb2ludCBpbiB3aGljaCBhbiBlZGdlIChkaXJlY3Rpb24gZFgsIGRZKSBpbnRlcnNlY3RzXG4gKiAgICAgICAgICB0aGUgcmVjdGFuZ3VsYXIgYm91bmRpbmcgYm94IG9mIGl0J3Mgc291cmNlL3RhcmdldCBub2RlXG4gKi9cbnZhciBmaW5kQ2xpcHBpbmdQb2ludCA9IGZ1bmN0aW9uIGZpbmRDbGlwcGluZ1BvaW50KG5vZGUsIGRYLCBkWSkge1xuICAvLyBTaG9yY3V0c1xuICB2YXIgWCA9IG5vZGUucG9zaXRpb25YO1xuICB2YXIgWSA9IG5vZGUucG9zaXRpb25ZO1xuICB2YXIgSCA9IG5vZGUuaGVpZ2h0IHx8IDE7XG4gIHZhciBXID0gbm9kZS53aWR0aCB8fCAxO1xuICB2YXIgZGlyU2xvcGUgPSBkWSAvIGRYO1xuICB2YXIgbm9kZVNsb3BlID0gSCAvIFc7XG5cbiAgLy8gdmFyIHMgPSAnQ29tcHV0aW5nIGNsaXBwaW5nIHBvaW50IG9mIG5vZGUgJyArIG5vZGUuaWQgK1xuICAvLyAgIFwiIC4gSGVpZ2h0OiAgXCIgKyBIICsgXCIsIFdpZHRoOiBcIiArIFcgK1xuICAvLyAgIFwiXFxuRGlyZWN0aW9uIFwiICsgZFggKyBcIiwgXCIgKyBkWTtcbiAgLy9cbiAgLy8gQ29tcHV0ZSBpbnRlcnNlY3Rpb25cbiAgdmFyIHJlcyA9IHt9O1xuXG4gIC8vIENhc2U6IFZlcnRpY2FsIGRpcmVjdGlvbiAodXApXG4gIGlmICgwID09PSBkWCAmJiAwIDwgZFkpIHtcbiAgICByZXMueCA9IFg7XG4gICAgLy8gcyArPSBcIlxcblVwIGRpcmVjdGlvblwiO1xuICAgIHJlcy55ID0gWSArIEggLyAyO1xuICAgIHJldHVybiByZXM7XG4gIH1cblxuICAvLyBDYXNlOiBWZXJ0aWNhbCBkaXJlY3Rpb24gKGRvd24pXG4gIGlmICgwID09PSBkWCAmJiAwID4gZFkpIHtcbiAgICByZXMueCA9IFg7XG4gICAgcmVzLnkgPSBZICsgSCAvIDI7XG4gICAgLy8gcyArPSBcIlxcbkRvd24gZGlyZWN0aW9uXCI7XG5cbiAgICByZXR1cm4gcmVzO1xuICB9XG5cbiAgLy8gQ2FzZTogSW50ZXJzZWN0cyB0aGUgcmlnaHQgYm9yZGVyXG4gIGlmICgwIDwgZFggJiYgLTEgKiBub2RlU2xvcGUgPD0gZGlyU2xvcGUgJiYgZGlyU2xvcGUgPD0gbm9kZVNsb3BlKSB7XG4gICAgcmVzLnggPSBYICsgVyAvIDI7XG4gICAgcmVzLnkgPSBZICsgVyAqIGRZIC8gMiAvIGRYO1xuICAgIC8vIHMgKz0gXCJcXG5SaWdodGJvcmRlclwiO1xuXG4gICAgcmV0dXJuIHJlcztcbiAgfVxuXG4gIC8vIENhc2U6IEludGVyc2VjdHMgdGhlIGxlZnQgYm9yZGVyXG4gIGlmICgwID4gZFggJiYgLTEgKiBub2RlU2xvcGUgPD0gZGlyU2xvcGUgJiYgZGlyU2xvcGUgPD0gbm9kZVNsb3BlKSB7XG4gICAgcmVzLnggPSBYIC0gVyAvIDI7XG4gICAgcmVzLnkgPSBZIC0gVyAqIGRZIC8gMiAvIGRYO1xuICAgIC8vIHMgKz0gXCJcXG5MZWZ0Ym9yZGVyXCI7XG5cbiAgICByZXR1cm4gcmVzO1xuICB9XG5cbiAgLy8gQ2FzZTogSW50ZXJzZWN0cyB0aGUgdG9wIGJvcmRlclxuICBpZiAoMCA8IGRZICYmIChkaXJTbG9wZSA8PSAtMSAqIG5vZGVTbG9wZSB8fCBkaXJTbG9wZSA+PSBub2RlU2xvcGUpKSB7XG4gICAgcmVzLnggPSBYICsgSCAqIGRYIC8gMiAvIGRZO1xuICAgIHJlcy55ID0gWSArIEggLyAyO1xuICAgIC8vIHMgKz0gXCJcXG5Ub3AgYm9yZGVyXCI7XG5cbiAgICByZXR1cm4gcmVzO1xuICB9XG5cbiAgLy8gQ2FzZTogSW50ZXJzZWN0cyB0aGUgYm90dG9tIGJvcmRlclxuICBpZiAoMCA+IGRZICYmIChkaXJTbG9wZSA8PSAtMSAqIG5vZGVTbG9wZSB8fCBkaXJTbG9wZSA+PSBub2RlU2xvcGUpKSB7XG4gICAgcmVzLnggPSBYIC0gSCAqIGRYIC8gMiAvIGRZO1xuICAgIHJlcy55ID0gWSAtIEggLyAyO1xuICAgIC8vIHMgKz0gXCJcXG5Cb3R0b20gYm9yZGVyXCI7XG5cbiAgICByZXR1cm4gcmVzO1xuICB9XG5cbiAgLy8gcyArPSBcIlxcbkNsaXBwaW5nIHBvaW50IGZvdW5kIGF0IFwiICsgcmVzLnggKyBcIiwgXCIgKyByZXMueTtcbiAgLy8gbG9nRGVidWcocyk7XG4gIHJldHVybiByZXM7XG59O1xuXG4vKipcbiAqIEBicmllZiA6IENhbGN1bGF0ZXMgYWxsIGVkZ2UgZm9yY2VzXG4gKi9cbnZhciBjYWxjdWxhdGVFZGdlRm9yY2VzID0gZnVuY3Rpb24gY2FsY3VsYXRlRWRnZUZvcmNlcyhsYXlvdXRJbmZvLCBvcHRpb25zKSB7XG4gIC8vIEl0ZXJhdGUgb3ZlciBhbGwgZWRnZXNcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXlvdXRJbmZvLmVkZ2VTaXplOyBpKyspIHtcbiAgICAvLyBHZXQgZWRnZSwgc291cmNlICYgdGFyZ2V0IG5vZGVzXG4gICAgdmFyIGVkZ2UgPSBsYXlvdXRJbmZvLmxheW91dEVkZ2VzW2ldO1xuICAgIHZhciBzb3VyY2VJeCA9IGxheW91dEluZm8uaWRUb0luZGV4W2VkZ2Uuc291cmNlSWRdO1xuICAgIHZhciBzb3VyY2UgPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzW3NvdXJjZUl4XTtcbiAgICB2YXIgdGFyZ2V0SXggPSBsYXlvdXRJbmZvLmlkVG9JbmRleFtlZGdlLnRhcmdldElkXTtcbiAgICB2YXIgdGFyZ2V0ID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1t0YXJnZXRJeF07XG5cbiAgICAvLyBHZXQgZGlyZWN0aW9uIG9mIGxpbmUgY29ubmVjdGluZyBib3RoIG5vZGUgY2VudGVyc1xuICAgIHZhciBkaXJlY3Rpb25YID0gdGFyZ2V0LnBvc2l0aW9uWCAtIHNvdXJjZS5wb3NpdGlvblg7XG4gICAgdmFyIGRpcmVjdGlvblkgPSB0YXJnZXQucG9zaXRpb25ZIC0gc291cmNlLnBvc2l0aW9uWTtcblxuICAgIC8vIElmIGJvdGggY2VudGVycyBhcmUgdGhlIHNhbWUsIGRvIG5vdGhpbmcuXG4gICAgLy8gQSByYW5kb20gZm9yY2UgaGFzIGFscmVhZHkgYmVlbiBhcHBsaWVkIGFzIG5vZGUgcmVwdWxzaW9uXG4gICAgaWYgKDAgPT09IGRpcmVjdGlvblggJiYgMCA9PT0gZGlyZWN0aW9uWSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gR2V0IGNsaXBwaW5nIHBvaW50cyBmb3IgYm90aCBub2Rlc1xuICAgIHZhciBwb2ludDEgPSBmaW5kQ2xpcHBpbmdQb2ludChzb3VyY2UsIGRpcmVjdGlvblgsIGRpcmVjdGlvblkpO1xuICAgIHZhciBwb2ludDIgPSBmaW5kQ2xpcHBpbmdQb2ludCh0YXJnZXQsIC0xICogZGlyZWN0aW9uWCwgLTEgKiBkaXJlY3Rpb25ZKTtcbiAgICB2YXIgbHggPSBwb2ludDIueCAtIHBvaW50MS54O1xuICAgIHZhciBseSA9IHBvaW50Mi55IC0gcG9pbnQxLnk7XG4gICAgdmFyIGwgPSBNYXRoLnNxcnQobHggKiBseCArIGx5ICogbHkpO1xuICAgIHZhciBmb3JjZSA9IE1hdGgucG93KGVkZ2UuaWRlYWxMZW5ndGggLSBsLCAyKSAvIGVkZ2UuZWxhc3RpY2l0eTtcbiAgICBpZiAoMCAhPT0gbCkge1xuICAgICAgdmFyIGZvcmNlWCA9IGZvcmNlICogbHggLyBsO1xuICAgICAgdmFyIGZvcmNlWSA9IGZvcmNlICogbHkgLyBsO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZm9yY2VYID0gMDtcbiAgICAgIHZhciBmb3JjZVkgPSAwO1xuICAgIH1cblxuICAgIC8vIEFkZCB0aGlzIGZvcmNlIHRvIHRhcmdldCBhbmQgc291cmNlIG5vZGVzXG4gICAgaWYgKCFzb3VyY2UuaXNMb2NrZWQpIHtcbiAgICAgIHNvdXJjZS5vZmZzZXRYICs9IGZvcmNlWDtcbiAgICAgIHNvdXJjZS5vZmZzZXRZICs9IGZvcmNlWTtcbiAgICB9XG4gICAgaWYgKCF0YXJnZXQuaXNMb2NrZWQpIHtcbiAgICAgIHRhcmdldC5vZmZzZXRYIC09IGZvcmNlWDtcbiAgICAgIHRhcmdldC5vZmZzZXRZIC09IGZvcmNlWTtcbiAgICB9XG5cbiAgICAvLyB2YXIgcyA9ICdFZGdlIGZvcmNlIGJldHdlZW4gbm9kZXMgJyArIHNvdXJjZS5pZCArICcgYW5kICcgKyB0YXJnZXQuaWQ7XG4gICAgLy8gcyArPSBcIlxcbkRpc3RhbmNlOiBcIiArIGwgKyBcIiBGb3JjZTogKFwiICsgZm9yY2VYICsgXCIsIFwiICsgZm9yY2VZICsgXCIpXCI7XG4gICAgLy8gbG9nRGVidWcocyk7XG4gIH1cbn07XG5cbi8qKlxuICogQGJyaWVmIDogQ29tcHV0ZXMgZ3Jhdml0eSBmb3JjZXMgZm9yIGFsbCBub2Rlc1xuICovXG52YXIgY2FsY3VsYXRlR3Jhdml0eUZvcmNlcyA9IGZ1bmN0aW9uIGNhbGN1bGF0ZUdyYXZpdHlGb3JjZXMobGF5b3V0SW5mbywgb3B0aW9ucykge1xuICBpZiAob3B0aW9ucy5ncmF2aXR5ID09PSAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBkaXN0VGhyZXNob2xkID0gMTtcblxuICAvLyB2YXIgcyA9ICdjYWxjdWxhdGVHcmF2aXR5Rm9yY2VzJztcbiAgLy8gbG9nRGVidWcocyk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGF5b3V0SW5mby5ncmFwaFNldC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBncmFwaCA9IGxheW91dEluZm8uZ3JhcGhTZXRbaV07XG4gICAgdmFyIG51bU5vZGVzID0gZ3JhcGgubGVuZ3RoO1xuXG4gICAgLy8gcyA9IFwiU2V0OiBcIiArIGdyYXBoLnRvU3RyaW5nKCk7XG4gICAgLy8gbG9nRGVidWcocyk7XG5cbiAgICAvLyBDb21wdXRlIGdyYXBoIGNlbnRlclxuICAgIGlmICgwID09PSBpKSB7XG4gICAgICB2YXIgY2VudGVyWCA9IGxheW91dEluZm8uY2xpZW50SGVpZ2h0IC8gMjtcbiAgICAgIHZhciBjZW50ZXJZID0gbGF5b3V0SW5mby5jbGllbnRXaWR0aCAvIDI7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEdldCBQYXJlbnQgbm9kZSBmb3IgdGhpcyBncmFwaCwgYW5kIHVzZSBpdHMgcG9zaXRpb24gYXMgY2VudGVyXG4gICAgICB2YXIgdGVtcCA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbbGF5b3V0SW5mby5pZFRvSW5kZXhbZ3JhcGhbMF1dXTtcbiAgICAgIHZhciBwYXJlbnQgPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzW2xheW91dEluZm8uaWRUb0luZGV4W3RlbXAucGFyZW50SWRdXTtcbiAgICAgIHZhciBjZW50ZXJYID0gcGFyZW50LnBvc2l0aW9uWDtcbiAgICAgIHZhciBjZW50ZXJZID0gcGFyZW50LnBvc2l0aW9uWTtcbiAgICB9XG4gICAgLy8gcyA9IFwiQ2VudGVyIGZvdW5kIGF0OiBcIiArIGNlbnRlclggKyBcIiwgXCIgKyBjZW50ZXJZO1xuICAgIC8vIGxvZ0RlYnVnKHMpO1xuXG4gICAgLy8gQXBwbHkgZm9yY2UgdG8gYWxsIG5vZGVzIGluIGdyYXBoXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBudW1Ob2RlczsgaisrKSB7XG4gICAgICB2YXIgbm9kZSA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbbGF5b3V0SW5mby5pZFRvSW5kZXhbZ3JhcGhbal1dXTtcbiAgICAgIC8vIHMgPSBcIk5vZGU6IFwiICsgbm9kZS5pZDtcblxuICAgICAgaWYgKG5vZGUuaXNMb2NrZWQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB2YXIgZHggPSBjZW50ZXJYIC0gbm9kZS5wb3NpdGlvblg7XG4gICAgICB2YXIgZHkgPSBjZW50ZXJZIC0gbm9kZS5wb3NpdGlvblk7XG4gICAgICB2YXIgZCA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gICAgICBpZiAoZCA+IGRpc3RUaHJlc2hvbGQpIHtcbiAgICAgICAgdmFyIGZ4ID0gb3B0aW9ucy5ncmF2aXR5ICogZHggLyBkO1xuICAgICAgICB2YXIgZnkgPSBvcHRpb25zLmdyYXZpdHkgKiBkeSAvIGQ7XG4gICAgICAgIG5vZGUub2Zmc2V0WCArPSBmeDtcbiAgICAgICAgbm9kZS5vZmZzZXRZICs9IGZ5O1xuICAgICAgICAvLyBzICs9IFwiOiBBcHBsaWVkIGZvcmNlOiBcIiArIGZ4ICsgXCIsIFwiICsgZnk7XG4gICAgICB9XG4gICAgICAvLyBsb2dEZWJ1ZyhzKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogQGJyaWVmICAgICAgICAgIDogVGhpcyBmdW5jdGlvbiBwcm9wYWdhdGVzIHRoZSBleGlzdGluZyBvZmZzZXRzIGZyb21cbiAqICAgICAgICAgICAgICAgICAgIHBhcmVudCBub2RlcyB0byBpdHMgZGVzY2VuZGVudHMuXG4gKiBAYXJnIGxheW91dEluZm8gOiBsYXlvdXRJbmZvIE9iamVjdFxuICogQGFyZyBjeSAgICAgICAgIDogY3l0b3NjYXBlIE9iamVjdFxuICogQGFyZyBvcHRpb25zICAgIDogTGF5b3V0IG9wdGlvbnNcbiAqL1xudmFyIHByb3BhZ2F0ZUZvcmNlcyA9IGZ1bmN0aW9uIHByb3BhZ2F0ZUZvcmNlcyhsYXlvdXRJbmZvLCBvcHRpb25zKSB7XG4gIC8vIElubGluZSBpbXBsZW1lbnRhdGlvbiBvZiBhIHF1ZXVlLCB1c2VkIGZvciB0cmF2ZXJzaW5nIHRoZSBncmFwaCBpbiBCRlMgb3JkZXJcbiAgdmFyIHF1ZXVlID0gW107XG4gIHZhciBzdGFydCA9IDA7IC8vIFBvaW50cyB0byB0aGUgc3RhcnQgdGhlIHF1ZXVlXG4gIHZhciBlbmQgPSAtMTsgLy8gUG9pbnRzIHRvIHRoZSBlbmQgb2YgdGhlIHF1ZXVlXG5cbiAgLy8gbG9nRGVidWcoJ3Byb3BhZ2F0ZUZvcmNlcycpO1xuXG4gIC8vIFN0YXJ0IGJ5IHZpc2l0aW5nIHRoZSBub2RlcyBpbiB0aGUgcm9vdCBncmFwaFxuICBxdWV1ZS5wdXNoLmFwcGx5KHF1ZXVlLCBsYXlvdXRJbmZvLmdyYXBoU2V0WzBdKTtcbiAgZW5kICs9IGxheW91dEluZm8uZ3JhcGhTZXRbMF0ubGVuZ3RoO1xuXG4gIC8vIFRyYXZlcnNlIHRoZSBncmFwaCwgbGV2ZWwgYnkgbGV2ZWwsXG4gIHdoaWxlIChzdGFydCA8PSBlbmQpIHtcbiAgICAvLyBHZXQgdGhlIG5vZGUgdG8gdmlzaXQgYW5kIHJlbW92ZSBpdCBmcm9tIHF1ZXVlXG4gICAgdmFyIG5vZGVJZCA9IHF1ZXVlW3N0YXJ0KytdO1xuICAgIHZhciBub2RlSW5kZXggPSBsYXlvdXRJbmZvLmlkVG9JbmRleFtub2RlSWRdO1xuICAgIHZhciBub2RlID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1tub2RlSW5kZXhdO1xuICAgIHZhciBjaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW47XG5cbiAgICAvLyBXZSBvbmx5IG5lZWQgdG8gcHJvY2VzcyB0aGUgbm9kZSBpZiBpdCdzIGNvbXBvdW5kXG4gICAgaWYgKDAgPCBjaGlsZHJlbi5sZW5ndGggJiYgIW5vZGUuaXNMb2NrZWQpIHtcbiAgICAgIHZhciBvZmZYID0gbm9kZS5vZmZzZXRYO1xuICAgICAgdmFyIG9mZlkgPSBub2RlLm9mZnNldFk7XG5cbiAgICAgIC8vIHZhciBzID0gXCJQcm9wYWdhdGluZyBvZmZzZXQgZnJvbSBwYXJlbnQgbm9kZSA6IFwiICsgbm9kZS5pZCArXG4gICAgICAvLyAgIFwiLiBPZmZzZXRYOiBcIiArIG9mZlggKyBcIi4gT2Zmc2V0WTogXCIgKyBvZmZZO1xuICAgICAgLy8gcyArPSBcIlxcbiBDaGlsZHJlbjogXCIgKyBjaGlsZHJlbi50b1N0cmluZygpO1xuICAgICAgLy8gbG9nRGVidWcocyk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNoaWxkTm9kZSA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbbGF5b3V0SW5mby5pZFRvSW5kZXhbY2hpbGRyZW5baV1dXTtcbiAgICAgICAgLy8gUHJvcGFnYXRlIG9mZnNldFxuICAgICAgICBjaGlsZE5vZGUub2Zmc2V0WCArPSBvZmZYO1xuICAgICAgICBjaGlsZE5vZGUub2Zmc2V0WSArPSBvZmZZO1xuICAgICAgICAvLyBBZGQgY2hpbGRyZW4gdG8gcXVldWUgdG8gYmUgdmlzaXRlZFxuICAgICAgICBxdWV1ZVsrK2VuZF0gPSBjaGlsZHJlbltpXTtcbiAgICAgIH1cblxuICAgICAgLy8gUmVzZXQgcGFyZW50IG9mZnNldHNcbiAgICAgIG5vZGUub2Zmc2V0WCA9IDA7XG4gICAgICBub2RlLm9mZnNldFkgPSAwO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBAYnJpZWYgOiBVcGRhdGVzIHRoZSBsYXlvdXQgbW9kZWwgcG9zaXRpb25zLCBiYXNlZCBvblxuICogICAgICAgICAgdGhlIGFjY3VtdWxhdGVkIGZvcmNlc1xuICovXG52YXIgdXBkYXRlUG9zaXRpb25zID0gZnVuY3Rpb24gdXBkYXRlUG9zaXRpb25zKGxheW91dEluZm8sIG9wdGlvbnMpIHtcbiAgLy8gdmFyIHMgPSAnVXBkYXRpbmcgcG9zaXRpb25zJztcbiAgLy8gbG9nRGVidWcocyk7XG5cbiAgLy8gUmVzZXQgYm91bmRhcmllcyBmb3IgY29tcG91bmQgbm9kZXNcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXlvdXRJbmZvLm5vZGVTaXplOyBpKyspIHtcbiAgICB2YXIgbiA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbaV07XG4gICAgaWYgKDAgPCBuLmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgLy8gbG9nRGVidWcoXCJSZXNldHRpbmcgYm91bmRhcmllcyBvZiBjb21wb3VuZCBub2RlOiBcIiArIG4uaWQpO1xuICAgICAgbi5tYXhYID0gdW5kZWZpbmVkO1xuICAgICAgbi5taW5YID0gdW5kZWZpbmVkO1xuICAgICAgbi5tYXhZID0gdW5kZWZpbmVkO1xuICAgICAgbi5taW5ZID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxheW91dEluZm8ubm9kZVNpemU7IGkrKykge1xuICAgIHZhciBuID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1tpXTtcbiAgICBpZiAoMCA8IG4uY2hpbGRyZW4ubGVuZ3RoIHx8IG4uaXNMb2NrZWQpIHtcbiAgICAgIC8vIE5vIG5lZWQgdG8gc2V0IGNvbXBvdW5kIG9yIGxvY2tlZCBub2RlIHBvc2l0aW9uXG4gICAgICAvLyBsb2dEZWJ1ZyhcIlNraXBwaW5nIHBvc2l0aW9uIHVwZGF0ZSBvZiBub2RlOiBcIiArIG4uaWQpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIC8vIHMgPSBcIk5vZGU6IFwiICsgbi5pZCArIFwiIFByZXZpb3VzIHBvc2l0aW9uOiAoXCIgK1xuICAgIC8vIG4ucG9zaXRpb25YICsgXCIsIFwiICsgbi5wb3NpdGlvblkgKyBcIikuXCI7XG5cbiAgICAvLyBMaW1pdCBkaXNwbGFjZW1lbnQgaW4gb3JkZXIgdG8gaW1wcm92ZSBzdGFiaWxpdHlcbiAgICB2YXIgdGVtcEZvcmNlID0gbGltaXRGb3JjZShuLm9mZnNldFgsIG4ub2Zmc2V0WSwgbGF5b3V0SW5mby50ZW1wZXJhdHVyZSk7XG4gICAgbi5wb3NpdGlvblggKz0gdGVtcEZvcmNlLng7XG4gICAgbi5wb3NpdGlvblkgKz0gdGVtcEZvcmNlLnk7XG4gICAgbi5vZmZzZXRYID0gMDtcbiAgICBuLm9mZnNldFkgPSAwO1xuICAgIG4ubWluWCA9IG4ucG9zaXRpb25YIC0gbi53aWR0aDtcbiAgICBuLm1heFggPSBuLnBvc2l0aW9uWCArIG4ud2lkdGg7XG4gICAgbi5taW5ZID0gbi5wb3NpdGlvblkgLSBuLmhlaWdodDtcbiAgICBuLm1heFkgPSBuLnBvc2l0aW9uWSArIG4uaGVpZ2h0O1xuICAgIC8vIHMgKz0gXCIgTmV3IFBvc2l0aW9uOiAoXCIgKyBuLnBvc2l0aW9uWCArIFwiLCBcIiArIG4ucG9zaXRpb25ZICsgXCIpLlwiO1xuICAgIC8vIGxvZ0RlYnVnKHMpO1xuXG4gICAgLy8gVXBkYXRlIGFuY2VzdHJ5IGJvdWRhcmllc1xuICAgIHVwZGF0ZUFuY2VzdHJ5Qm91bmRhcmllcyhuLCBsYXlvdXRJbmZvKTtcbiAgfVxuXG4gIC8vIFVwZGF0ZSBzaXplLCBwb3NpdGlvbiBvZiBjb21wdW5kIG5vZGVzXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGF5b3V0SW5mby5ub2RlU2l6ZTsgaSsrKSB7XG4gICAgdmFyIG4gPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzW2ldO1xuICAgIGlmICgwIDwgbi5jaGlsZHJlbi5sZW5ndGggJiYgIW4uaXNMb2NrZWQpIHtcbiAgICAgIG4ucG9zaXRpb25YID0gKG4ubWF4WCArIG4ubWluWCkgLyAyO1xuICAgICAgbi5wb3NpdGlvblkgPSAobi5tYXhZICsgbi5taW5ZKSAvIDI7XG4gICAgICBuLndpZHRoID0gbi5tYXhYIC0gbi5taW5YO1xuICAgICAgbi5oZWlnaHQgPSBuLm1heFkgLSBuLm1pblk7XG4gICAgICAvLyBzID0gXCJVcGRhdGluZyBwb3NpdGlvbiwgc2l6ZSBvZiBjb21wb3VuZCBub2RlIFwiICsgbi5pZDtcbiAgICAgIC8vIHMgKz0gXCJcXG5Qb3NpdGlvblg6IFwiICsgbi5wb3NpdGlvblggKyBcIiwgUG9zaXRpb25ZOiBcIiArIG4ucG9zaXRpb25ZO1xuICAgICAgLy8gcyArPSBcIlxcbldpZHRoOiBcIiArIG4ud2lkdGggKyBcIiwgSGVpZ2h0OiBcIiArIG4uaGVpZ2h0O1xuICAgICAgLy8gbG9nRGVidWcocyk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIEBicmllZiA6IExpbWl0cyBhIGZvcmNlIChmb3JjZVgsIGZvcmNlWSkgdG8gYmUgbm90XG4gKiAgICAgICAgICBncmVhdGVyIChpbiBtb2R1bG8pIHRoYW4gbWF4LlxuIDggICAgICAgICAgUHJlc2VydmVzIGZvcmNlIGRpcmVjdGlvbi5cbiAgKi9cbnZhciBsaW1pdEZvcmNlID0gZnVuY3Rpb24gbGltaXRGb3JjZShmb3JjZVgsIGZvcmNlWSwgbWF4KSB7XG4gIC8vIHZhciBzID0gXCJMaW1pdGluZyBmb3JjZTogKFwiICsgZm9yY2VYICsgXCIsIFwiICsgZm9yY2VZICsgXCIpLiBNYXg6IFwiICsgbWF4O1xuICB2YXIgZm9yY2UgPSBNYXRoLnNxcnQoZm9yY2VYICogZm9yY2VYICsgZm9yY2VZICogZm9yY2VZKTtcbiAgaWYgKGZvcmNlID4gbWF4KSB7XG4gICAgdmFyIHJlcyA9IHtcbiAgICAgIHg6IG1heCAqIGZvcmNlWCAvIGZvcmNlLFxuICAgICAgeTogbWF4ICogZm9yY2VZIC8gZm9yY2VcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHZhciByZXMgPSB7XG4gICAgICB4OiBmb3JjZVgsXG4gICAgICB5OiBmb3JjZVlcbiAgICB9O1xuICB9XG5cbiAgLy8gcyArPSBcIi5cXG5SZXN1bHQ6IChcIiArIHJlcy54ICsgXCIsIFwiICsgcmVzLnkgKyBcIilcIjtcbiAgLy8gbG9nRGVidWcocyk7XG5cbiAgcmV0dXJuIHJlcztcbn07XG5cbi8qKlxuICogQGJyaWVmIDogRnVuY3Rpb24gdXNlZCBmb3Iga2VlcGluZyB0cmFjayBvZiBjb21wb3VuZCBub2RlXG4gKiAgICAgICAgICBzaXplcywgc2luY2UgdGhleSBzaG91bGQgYm91bmQgYWxsIHRoZWlyIHN1Ym5vZGVzLlxuICovXG52YXIgdXBkYXRlQW5jZXN0cnlCb3VuZGFyaWVzID0gZnVuY3Rpb24gdXBkYXRlQW5jZXN0cnlCb3VuZGFyaWVzKG5vZGUsIGxheW91dEluZm8pIHtcbiAgLy8gdmFyIHMgPSBcIlByb3BhZ2F0aW5nIG5ldyBwb3NpdGlvbi9zaXplIG9mIG5vZGUgXCIgKyBub2RlLmlkO1xuICB2YXIgcGFyZW50SWQgPSBub2RlLnBhcmVudElkO1xuICBpZiAobnVsbCA9PSBwYXJlbnRJZCkge1xuICAgIC8vIElmIHRoZXJlJ3Mgbm8gcGFyZW50LCB3ZSBhcmUgZG9uZVxuICAgIC8vIHMgKz0gXCIuIE5vIHBhcmVudCBub2RlLlwiO1xuICAgIC8vIGxvZ0RlYnVnKHMpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIEdldCBQYXJlbnQgTm9kZVxuICB2YXIgcCA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbbGF5b3V0SW5mby5pZFRvSW5kZXhbcGFyZW50SWRdXTtcbiAgdmFyIGZsYWcgPSBmYWxzZTtcblxuICAvLyBNYXhYXG4gIGlmIChudWxsID09IHAubWF4WCB8fCBub2RlLm1heFggKyBwLnBhZFJpZ2h0ID4gcC5tYXhYKSB7XG4gICAgcC5tYXhYID0gbm9kZS5tYXhYICsgcC5wYWRSaWdodDtcbiAgICBmbGFnID0gdHJ1ZTtcbiAgICAvLyBzICs9IFwiXFxuTmV3IG1heFggZm9yIHBhcmVudCBub2RlIFwiICsgcC5pZCArIFwiOiBcIiArIHAubWF4WDtcbiAgfVxuXG4gIC8vIE1pblhcbiAgaWYgKG51bGwgPT0gcC5taW5YIHx8IG5vZGUubWluWCAtIHAucGFkTGVmdCA8IHAubWluWCkge1xuICAgIHAubWluWCA9IG5vZGUubWluWCAtIHAucGFkTGVmdDtcbiAgICBmbGFnID0gdHJ1ZTtcbiAgICAvLyBzICs9IFwiXFxuTmV3IG1pblggZm9yIHBhcmVudCBub2RlIFwiICsgcC5pZCArIFwiOiBcIiArIHAubWluWDtcbiAgfVxuXG4gIC8vIE1heFlcbiAgaWYgKG51bGwgPT0gcC5tYXhZIHx8IG5vZGUubWF4WSArIHAucGFkQm90dG9tID4gcC5tYXhZKSB7XG4gICAgcC5tYXhZID0gbm9kZS5tYXhZICsgcC5wYWRCb3R0b207XG4gICAgZmxhZyA9IHRydWU7XG4gICAgLy8gcyArPSBcIlxcbk5ldyBtYXhZIGZvciBwYXJlbnQgbm9kZSBcIiArIHAuaWQgKyBcIjogXCIgKyBwLm1heFk7XG4gIH1cblxuICAvLyBNaW5ZXG4gIGlmIChudWxsID09IHAubWluWSB8fCBub2RlLm1pblkgLSBwLnBhZFRvcCA8IHAubWluWSkge1xuICAgIHAubWluWSA9IG5vZGUubWluWSAtIHAucGFkVG9wO1xuICAgIGZsYWcgPSB0cnVlO1xuICAgIC8vIHMgKz0gXCJcXG5OZXcgbWluWSBmb3IgcGFyZW50IG5vZGUgXCIgKyBwLmlkICsgXCI6IFwiICsgcC5taW5ZO1xuICB9XG5cbiAgLy8gSWYgdXBkYXRlZCBib3VuZGFyaWVzLCBwcm9wYWdhdGUgY2hhbmdlcyB1cHdhcmRcbiAgaWYgKGZsYWcpIHtcbiAgICAvLyBsb2dEZWJ1ZyhzKTtcbiAgICByZXR1cm4gdXBkYXRlQW5jZXN0cnlCb3VuZGFyaWVzKHAsIGxheW91dEluZm8pO1xuICB9XG5cbiAgLy8gcyArPSBcIi4gTm8gY2hhbmdlcyBpbiBib3VuZGFyaWVzL3Bvc2l0aW9uIG9mIHBhcmVudCBub2RlIFwiICsgcC5pZDtcbiAgLy8gbG9nRGVidWcocyk7XG4gIHJldHVybjtcbn07XG52YXIgc2VwYXJhdGVDb21wb25lbnRzID0gZnVuY3Rpb24gc2VwYXJhdGVDb21wb25lbnRzKGxheW91dEluZm8sIG9wdGlvbnMpIHtcbiAgdmFyIG5vZGVzID0gbGF5b3V0SW5mby5sYXlvdXROb2RlcztcbiAgdmFyIGNvbXBvbmVudHMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBub2RlID0gbm9kZXNbaV07XG4gICAgdmFyIGNpZCA9IG5vZGUuY21wdElkO1xuICAgIHZhciBjb21wb25lbnQgPSBjb21wb25lbnRzW2NpZF0gPSBjb21wb25lbnRzW2NpZF0gfHwgW107XG4gICAgY29tcG9uZW50LnB1c2gobm9kZSk7XG4gIH1cbiAgdmFyIHRvdGFsQSA9IDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY29tcG9uZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBjID0gY29tcG9uZW50c1tpXTtcbiAgICBpZiAoIWMpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjLngxID0gSW5maW5pdHk7XG4gICAgYy54MiA9IC1JbmZpbml0eTtcbiAgICBjLnkxID0gSW5maW5pdHk7XG4gICAgYy55MiA9IC1JbmZpbml0eTtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IGMubGVuZ3RoOyBqKyspIHtcbiAgICAgIHZhciBuID0gY1tqXTtcbiAgICAgIGMueDEgPSBNYXRoLm1pbihjLngxLCBuLnBvc2l0aW9uWCAtIG4ud2lkdGggLyAyKTtcbiAgICAgIGMueDIgPSBNYXRoLm1heChjLngyLCBuLnBvc2l0aW9uWCArIG4ud2lkdGggLyAyKTtcbiAgICAgIGMueTEgPSBNYXRoLm1pbihjLnkxLCBuLnBvc2l0aW9uWSAtIG4uaGVpZ2h0IC8gMik7XG4gICAgICBjLnkyID0gTWF0aC5tYXgoYy55Miwgbi5wb3NpdGlvblkgKyBuLmhlaWdodCAvIDIpO1xuICAgIH1cbiAgICBjLncgPSBjLngyIC0gYy54MTtcbiAgICBjLmggPSBjLnkyIC0gYy55MTtcbiAgICB0b3RhbEEgKz0gYy53ICogYy5oO1xuICB9XG4gIGNvbXBvbmVudHMuc29ydChmdW5jdGlvbiAoYzEsIGMyKSB7XG4gICAgcmV0dXJuIGMyLncgKiBjMi5oIC0gYzEudyAqIGMxLmg7XG4gIH0pO1xuICB2YXIgeCA9IDA7XG4gIHZhciB5ID0gMDtcbiAgdmFyIHVzZWRXID0gMDtcbiAgdmFyIHJvd0ggPSAwO1xuICB2YXIgbWF4Um93VyA9IE1hdGguc3FydCh0b3RhbEEpICogbGF5b3V0SW5mby5jbGllbnRXaWR0aCAvIGxheW91dEluZm8uY2xpZW50SGVpZ2h0O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbXBvbmVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgYyA9IGNvbXBvbmVudHNbaV07XG4gICAgaWYgKCFjKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBjLmxlbmd0aDsgaisrKSB7XG4gICAgICB2YXIgbiA9IGNbal07XG4gICAgICBpZiAoIW4uaXNMb2NrZWQpIHtcbiAgICAgICAgbi5wb3NpdGlvblggKz0geCAtIGMueDE7XG4gICAgICAgIG4ucG9zaXRpb25ZICs9IHkgLSBjLnkxO1xuICAgICAgfVxuICAgIH1cbiAgICB4ICs9IGMudyArIG9wdGlvbnMuY29tcG9uZW50U3BhY2luZztcbiAgICB1c2VkVyArPSBjLncgKyBvcHRpb25zLmNvbXBvbmVudFNwYWNpbmc7XG4gICAgcm93SCA9IE1hdGgubWF4KHJvd0gsIGMuaCk7XG4gICAgaWYgKHVzZWRXID4gbWF4Um93Vykge1xuICAgICAgeSArPSByb3dIICsgb3B0aW9ucy5jb21wb25lbnRTcGFjaW5nO1xuICAgICAgeCA9IDA7XG4gICAgICB1c2VkVyA9IDA7XG4gICAgICByb3dIID0gMDtcbiAgICB9XG4gIH1cbn07XG5cbnZhciBkZWZhdWx0cyQzID0ge1xuICBmaXQ6IHRydWUsXG4gIC8vIHdoZXRoZXIgdG8gZml0IHRoZSB2aWV3cG9ydCB0byB0aGUgZ3JhcGhcbiAgcGFkZGluZzogMzAsXG4gIC8vIHBhZGRpbmcgdXNlZCBvbiBmaXRcbiAgYm91bmRpbmdCb3g6IHVuZGVmaW5lZCxcbiAgLy8gY29uc3RyYWluIGxheW91dCBib3VuZHM7IHsgeDEsIHkxLCB4MiwgeTIgfSBvciB7IHgxLCB5MSwgdywgaCB9XG4gIGF2b2lkT3ZlcmxhcDogdHJ1ZSxcbiAgLy8gcHJldmVudHMgbm9kZSBvdmVybGFwLCBtYXkgb3ZlcmZsb3cgYm91bmRpbmdCb3ggaWYgbm90IGVub3VnaCBzcGFjZVxuICBhdm9pZE92ZXJsYXBQYWRkaW5nOiAxMCxcbiAgLy8gZXh0cmEgc3BhY2luZyBhcm91bmQgbm9kZXMgd2hlbiBhdm9pZE92ZXJsYXA6IHRydWVcbiAgbm9kZURpbWVuc2lvbnNJbmNsdWRlTGFiZWxzOiBmYWxzZSxcbiAgLy8gRXhjbHVkZXMgdGhlIGxhYmVsIHdoZW4gY2FsY3VsYXRpbmcgbm9kZSBib3VuZGluZyBib3hlcyBmb3IgdGhlIGxheW91dCBhbGdvcml0aG1cbiAgc3BhY2luZ0ZhY3RvcjogdW5kZWZpbmVkLFxuICAvLyBBcHBsaWVzIGEgbXVsdGlwbGljYXRpdmUgZmFjdG9yICg+MCkgdG8gZXhwYW5kIG9yIGNvbXByZXNzIHRoZSBvdmVyYWxsIGFyZWEgdGhhdCB0aGUgbm9kZXMgdGFrZSB1cFxuICBjb25kZW5zZTogZmFsc2UsXG4gIC8vIHVzZXMgYWxsIGF2YWlsYWJsZSBzcGFjZSBvbiBmYWxzZSwgdXNlcyBtaW5pbWFsIHNwYWNlIG9uIHRydWVcbiAgcm93czogdW5kZWZpbmVkLFxuICAvLyBmb3JjZSBudW0gb2Ygcm93cyBpbiB0aGUgZ3JpZFxuICBjb2xzOiB1bmRlZmluZWQsXG4gIC8vIGZvcmNlIG51bSBvZiBjb2x1bW5zIGluIHRoZSBncmlkXG4gIHBvc2l0aW9uOiBmdW5jdGlvbiBwb3NpdGlvbihub2RlKSB7fSxcbiAgLy8gcmV0dXJucyB7IHJvdywgY29sIH0gZm9yIGVsZW1lbnRcbiAgc29ydDogdW5kZWZpbmVkLFxuICAvLyBhIHNvcnRpbmcgZnVuY3Rpb24gdG8gb3JkZXIgdGhlIG5vZGVzOyBlLmcuIGZ1bmN0aW9uKGEsIGIpeyByZXR1cm4gYS5kYXRhKCd3ZWlnaHQnKSAtIGIuZGF0YSgnd2VpZ2h0JykgfVxuICBhbmltYXRlOiBmYWxzZSxcbiAgLy8gd2hldGhlciB0byB0cmFuc2l0aW9uIHRoZSBub2RlIHBvc2l0aW9uc1xuICBhbmltYXRpb25EdXJhdGlvbjogNTAwLFxuICAvLyBkdXJhdGlvbiBvZiBhbmltYXRpb24gaW4gbXMgaWYgZW5hYmxlZFxuICBhbmltYXRpb25FYXNpbmc6IHVuZGVmaW5lZCxcbiAgLy8gZWFzaW5nIG9mIGFuaW1hdGlvbiBpZiBlbmFibGVkXG4gIGFuaW1hdGVGaWx0ZXI6IGZ1bmN0aW9uIGFuaW1hdGVGaWx0ZXIobm9kZSwgaSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9LFxuICAvLyBhIGZ1bmN0aW9uIHRoYXQgZGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBub2RlIHNob3VsZCBiZSBhbmltYXRlZC4gIEFsbCBub2RlcyBhbmltYXRlZCBieSBkZWZhdWx0IG9uIGFuaW1hdGUgZW5hYmxlZC4gIE5vbi1hbmltYXRlZCBub2RlcyBhcmUgcG9zaXRpb25lZCBpbW1lZGlhdGVseSB3aGVuIHRoZSBsYXlvdXQgc3RhcnRzXG4gIHJlYWR5OiB1bmRlZmluZWQsXG4gIC8vIGNhbGxiYWNrIG9uIGxheW91dHJlYWR5XG4gIHN0b3A6IHVuZGVmaW5lZCxcbiAgLy8gY2FsbGJhY2sgb24gbGF5b3V0c3RvcFxuICB0cmFuc2Zvcm06IGZ1bmN0aW9uIHRyYW5zZm9ybShub2RlLCBwb3NpdGlvbikge1xuICAgIHJldHVybiBwb3NpdGlvbjtcbiAgfSAvLyB0cmFuc2Zvcm0gYSBnaXZlbiBub2RlIHBvc2l0aW9uLiBVc2VmdWwgZm9yIGNoYW5naW5nIGZsb3cgZGlyZWN0aW9uIGluIGRpc2NyZXRlIGxheW91dHMgXG59O1xuXG5mdW5jdGlvbiBHcmlkTGF5b3V0KG9wdGlvbnMpIHtcbiAgdGhpcy5vcHRpb25zID0gZXh0ZW5kKHt9LCBkZWZhdWx0cyQzLCBvcHRpb25zKTtcbn1cbkdyaWRMYXlvdXQucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHBhcmFtcyA9IHRoaXMub3B0aW9ucztcbiAgdmFyIG9wdGlvbnMgPSBwYXJhbXM7XG4gIHZhciBjeSA9IHBhcmFtcy5jeTtcbiAgdmFyIGVsZXMgPSBvcHRpb25zLmVsZXM7XG4gIHZhciBub2RlcyA9IGVsZXMubm9kZXMoKS5ub3QoJzpwYXJlbnQnKTtcbiAgaWYgKG9wdGlvbnMuc29ydCkge1xuICAgIG5vZGVzID0gbm9kZXMuc29ydChvcHRpb25zLnNvcnQpO1xuICB9XG4gIHZhciBiYiA9IG1ha2VCb3VuZGluZ0JveChvcHRpb25zLmJvdW5kaW5nQm94ID8gb3B0aW9ucy5ib3VuZGluZ0JveCA6IHtcbiAgICB4MTogMCxcbiAgICB5MTogMCxcbiAgICB3OiBjeS53aWR0aCgpLFxuICAgIGg6IGN5LmhlaWdodCgpXG4gIH0pO1xuICBpZiAoYmIuaCA9PT0gMCB8fCBiYi53ID09PSAwKSB7XG4gICAgZWxlcy5ub2RlcygpLmxheW91dFBvc2l0aW9ucyh0aGlzLCBvcHRpb25zLCBmdW5jdGlvbiAoZWxlKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiBiYi54MSxcbiAgICAgICAgeTogYmIueTFcbiAgICAgIH07XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gd2lkdGgvaGVpZ2h0ICogc3BsaXRzXjIgPSBjZWxscyB3aGVyZSBzcGxpdHMgaXMgbnVtYmVyIG9mIHRpbWVzIHRvIHNwbGl0IHdpZHRoXG4gICAgdmFyIGNlbGxzID0gbm9kZXMuc2l6ZSgpO1xuICAgIHZhciBzcGxpdHMgPSBNYXRoLnNxcnQoY2VsbHMgKiBiYi5oIC8gYmIudyk7XG4gICAgdmFyIHJvd3MgPSBNYXRoLnJvdW5kKHNwbGl0cyk7XG4gICAgdmFyIGNvbHMgPSBNYXRoLnJvdW5kKGJiLncgLyBiYi5oICogc3BsaXRzKTtcbiAgICB2YXIgc21hbGwgPSBmdW5jdGlvbiBzbWFsbCh2YWwpIHtcbiAgICAgIGlmICh2YWwgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gTWF0aC5taW4ocm93cywgY29scyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgbWluID0gTWF0aC5taW4ocm93cywgY29scyk7XG4gICAgICAgIGlmIChtaW4gPT0gcm93cykge1xuICAgICAgICAgIHJvd3MgPSB2YWw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29scyA9IHZhbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgdmFyIGxhcmdlID0gZnVuY3Rpb24gbGFyZ2UodmFsKSB7XG4gICAgICBpZiAodmFsID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIE1hdGgubWF4KHJvd3MsIGNvbHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIG1heCA9IE1hdGgubWF4KHJvd3MsIGNvbHMpO1xuICAgICAgICBpZiAobWF4ID09IHJvd3MpIHtcbiAgICAgICAgICByb3dzID0gdmFsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbHMgPSB2YWw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciBvUm93cyA9IG9wdGlvbnMucm93cztcbiAgICB2YXIgb0NvbHMgPSBvcHRpb25zLmNvbHMgIT0gbnVsbCA/IG9wdGlvbnMuY29scyA6IG9wdGlvbnMuY29sdW1ucztcblxuICAgIC8vIGlmIHJvd3Mgb3IgY29sdW1ucyB3ZXJlIHNldCBpbiBvcHRpb25zLCB1c2UgdGhvc2UgdmFsdWVzXG4gICAgaWYgKG9Sb3dzICE9IG51bGwgJiYgb0NvbHMgIT0gbnVsbCkge1xuICAgICAgcm93cyA9IG9Sb3dzO1xuICAgICAgY29scyA9IG9Db2xzO1xuICAgIH0gZWxzZSBpZiAob1Jvd3MgIT0gbnVsbCAmJiBvQ29scyA9PSBudWxsKSB7XG4gICAgICByb3dzID0gb1Jvd3M7XG4gICAgICBjb2xzID0gTWF0aC5jZWlsKGNlbGxzIC8gcm93cyk7XG4gICAgfSBlbHNlIGlmIChvUm93cyA9PSBudWxsICYmIG9Db2xzICE9IG51bGwpIHtcbiAgICAgIGNvbHMgPSBvQ29scztcbiAgICAgIHJvd3MgPSBNYXRoLmNlaWwoY2VsbHMgLyBjb2xzKTtcbiAgICB9XG5cbiAgICAvLyBvdGhlcndpc2UgdXNlIHRoZSBhdXRvbWF0aWMgdmFsdWVzIGFuZCBhZGp1c3QgYWNjb3JkaW5nbHlcblxuICAgIC8vIGlmIHJvdW5kaW5nIHdhcyB1cCwgc2VlIGlmIHdlIGNhbiByZWR1Y2Ugcm93cyBvciBjb2x1bW5zXG4gICAgZWxzZSBpZiAoY29scyAqIHJvd3MgPiBjZWxscykge1xuICAgICAgdmFyIHNtID0gc21hbGwoKTtcbiAgICAgIHZhciBsZyA9IGxhcmdlKCk7XG5cbiAgICAgIC8vIHJlZHVjaW5nIHRoZSBzbWFsbCBzaWRlIHRha2VzIGF3YXkgdGhlIG1vc3QgY2VsbHMsIHNvIHRyeSBpdCBmaXJzdFxuICAgICAgaWYgKChzbSAtIDEpICogbGcgPj0gY2VsbHMpIHtcbiAgICAgICAgc21hbGwoc20gLSAxKTtcbiAgICAgIH0gZWxzZSBpZiAoKGxnIC0gMSkgKiBzbSA+PSBjZWxscykge1xuICAgICAgICBsYXJnZShsZyAtIDEpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBpZiByb3VuZGluZyB3YXMgdG9vIGxvdywgYWRkIHJvd3Mgb3IgY29sdW1uc1xuICAgICAgd2hpbGUgKGNvbHMgKiByb3dzIDwgY2VsbHMpIHtcbiAgICAgICAgdmFyIF9zbSA9IHNtYWxsKCk7XG4gICAgICAgIHZhciBfbGcgPSBsYXJnZSgpO1xuXG4gICAgICAgIC8vIHRyeSB0byBhZGQgdG8gbGFyZ2VyIHNpZGUgZmlyc3QgKGFkZHMgbGVzcyBpbiBtdWx0aXBsaWNhdGlvbilcbiAgICAgICAgaWYgKChfbGcgKyAxKSAqIF9zbSA+PSBjZWxscykge1xuICAgICAgICAgIGxhcmdlKF9sZyArIDEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNtYWxsKF9zbSArIDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBjZWxsV2lkdGggPSBiYi53IC8gY29scztcbiAgICB2YXIgY2VsbEhlaWdodCA9IGJiLmggLyByb3dzO1xuICAgIGlmIChvcHRpb25zLmNvbmRlbnNlKSB7XG4gICAgICBjZWxsV2lkdGggPSAwO1xuICAgICAgY2VsbEhlaWdodCA9IDA7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmF2b2lkT3ZlcmxhcCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICB2YXIgcG9zID0gbm9kZS5fcHJpdmF0ZS5wb3NpdGlvbjtcbiAgICAgICAgaWYgKHBvcy54ID09IG51bGwgfHwgcG9zLnkgPT0gbnVsbCkge1xuICAgICAgICAgIC8vIGZvciBiYlxuICAgICAgICAgIHBvcy54ID0gMDtcbiAgICAgICAgICBwb3MueSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5iYiA9IG5vZGUubGF5b3V0RGltZW5zaW9ucyhvcHRpb25zKTtcbiAgICAgICAgdmFyIHAgPSBvcHRpb25zLmF2b2lkT3ZlcmxhcFBhZGRpbmc7XG4gICAgICAgIHZhciB3ID0gbmJiLncgKyBwO1xuICAgICAgICB2YXIgaCA9IG5iYi5oICsgcDtcbiAgICAgICAgY2VsbFdpZHRoID0gTWF0aC5tYXgoY2VsbFdpZHRoLCB3KTtcbiAgICAgICAgY2VsbEhlaWdodCA9IE1hdGgubWF4KGNlbGxIZWlnaHQsIGgpO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgY2VsbFVzZWQgPSB7fTsgLy8gZS5nLiAnYy0wLTInID0+IHRydWVcblxuICAgIHZhciB1c2VkID0gZnVuY3Rpb24gdXNlZChyb3csIGNvbCkge1xuICAgICAgcmV0dXJuIGNlbGxVc2VkWydjLScgKyByb3cgKyAnLScgKyBjb2xdID8gdHJ1ZSA6IGZhbHNlO1xuICAgIH07XG4gICAgdmFyIHVzZSA9IGZ1bmN0aW9uIHVzZShyb3csIGNvbCkge1xuICAgICAgY2VsbFVzZWRbJ2MtJyArIHJvdyArICctJyArIGNvbF0gPSB0cnVlO1xuICAgIH07XG5cbiAgICAvLyB0byBrZWVwIHRyYWNrIG9mIGN1cnJlbnQgY2VsbCBwb3NpdGlvblxuICAgIHZhciByb3cgPSAwO1xuICAgIHZhciBjb2wgPSAwO1xuICAgIHZhciBtb3ZlVG9OZXh0Q2VsbCA9IGZ1bmN0aW9uIG1vdmVUb05leHRDZWxsKCkge1xuICAgICAgY29sKys7XG4gICAgICBpZiAoY29sID49IGNvbHMpIHtcbiAgICAgICAgY29sID0gMDtcbiAgICAgICAgcm93Kys7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8vIGdldCBhIGNhY2hlIG9mIGFsbCB0aGUgbWFudWFsIHBvc2l0aW9uc1xuICAgIHZhciBpZDJtYW5Qb3MgPSB7fTtcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgbm9kZXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICB2YXIgX25vZGUgPSBub2Rlc1tfaV07XG4gICAgICB2YXIgcmNQb3MgPSBvcHRpb25zLnBvc2l0aW9uKF9ub2RlKTtcbiAgICAgIGlmIChyY1BvcyAmJiAocmNQb3Mucm93ICE9PSB1bmRlZmluZWQgfHwgcmNQb3MuY29sICE9PSB1bmRlZmluZWQpKSB7XG4gICAgICAgIC8vIG11c3QgaGF2ZSBhdCBsZWFzdCByb3cgb3IgY29sIGRlZidkXG4gICAgICAgIHZhciBfcG9zID0ge1xuICAgICAgICAgIHJvdzogcmNQb3Mucm93LFxuICAgICAgICAgIGNvbDogcmNQb3MuY29sXG4gICAgICAgIH07XG4gICAgICAgIGlmIChfcG9zLmNvbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgLy8gZmluZCB1bnVzZWQgY29sXG4gICAgICAgICAgX3Bvcy5jb2wgPSAwO1xuICAgICAgICAgIHdoaWxlICh1c2VkKF9wb3Mucm93LCBfcG9zLmNvbCkpIHtcbiAgICAgICAgICAgIF9wb3MuY29sKys7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKF9wb3Mucm93ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAvLyBmaW5kIHVudXNlZCByb3dcbiAgICAgICAgICBfcG9zLnJvdyA9IDA7XG4gICAgICAgICAgd2hpbGUgKHVzZWQoX3Bvcy5yb3csIF9wb3MuY29sKSkge1xuICAgICAgICAgICAgX3Bvcy5yb3crKztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWQybWFuUG9zW19ub2RlLmlkKCldID0gX3BvcztcbiAgICAgICAgdXNlKF9wb3Mucm93LCBfcG9zLmNvbCk7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBnZXRQb3MgPSBmdW5jdGlvbiBnZXRQb3MoZWxlbWVudCwgaSkge1xuICAgICAgdmFyIHgsIHk7XG4gICAgICBpZiAoZWxlbWVudC5sb2NrZWQoKSB8fCBlbGVtZW50LmlzUGFyZW50KCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICAvLyBzZWUgaWYgd2UgaGF2ZSBhIG1hbnVhbCBwb3NpdGlvbiBzZXRcbiAgICAgIHZhciByY1BvcyA9IGlkMm1hblBvc1tlbGVtZW50LmlkKCldO1xuICAgICAgaWYgKHJjUG9zKSB7XG4gICAgICAgIHggPSByY1Bvcy5jb2wgKiBjZWxsV2lkdGggKyBjZWxsV2lkdGggLyAyICsgYmIueDE7XG4gICAgICAgIHkgPSByY1Bvcy5yb3cgKiBjZWxsSGVpZ2h0ICsgY2VsbEhlaWdodCAvIDIgKyBiYi55MTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIG90aGVyd2lzZSBzZXQgYXV0b21hdGljYWxseVxuXG4gICAgICAgIHdoaWxlICh1c2VkKHJvdywgY29sKSkge1xuICAgICAgICAgIG1vdmVUb05leHRDZWxsKCk7XG4gICAgICAgIH1cbiAgICAgICAgeCA9IGNvbCAqIGNlbGxXaWR0aCArIGNlbGxXaWR0aCAvIDIgKyBiYi54MTtcbiAgICAgICAgeSA9IHJvdyAqIGNlbGxIZWlnaHQgKyBjZWxsSGVpZ2h0IC8gMiArIGJiLnkxO1xuICAgICAgICB1c2Uocm93LCBjb2wpO1xuICAgICAgICBtb3ZlVG9OZXh0Q2VsbCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogeCxcbiAgICAgICAgeTogeVxuICAgICAgfTtcbiAgICB9O1xuICAgIG5vZGVzLmxheW91dFBvc2l0aW9ucyh0aGlzLCBvcHRpb25zLCBnZXRQb3MpO1xuICB9XG4gIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xufTtcblxuLy8gZGVmYXVsdCBsYXlvdXQgb3B0aW9uc1xudmFyIGRlZmF1bHRzJDIgPSB7XG4gIHJlYWR5OiBmdW5jdGlvbiByZWFkeSgpIHt9LFxuICAvLyBvbiBsYXlvdXRyZWFkeVxuICBzdG9wOiBmdW5jdGlvbiBzdG9wKCkge30gLy8gb24gbGF5b3V0c3RvcFxufTtcblxuLy8gY29uc3RydWN0b3Jcbi8vIG9wdGlvbnMgOiBvYmplY3QgY29udGFpbmluZyBsYXlvdXQgb3B0aW9uc1xuZnVuY3Rpb24gTnVsbExheW91dChvcHRpb25zKSB7XG4gIHRoaXMub3B0aW9ucyA9IGV4dGVuZCh7fSwgZGVmYXVsdHMkMiwgb3B0aW9ucyk7XG59XG5cbi8vIHJ1bnMgdGhlIGxheW91dFxuTnVsbExheW91dC5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgdmFyIGVsZXMgPSBvcHRpb25zLmVsZXM7IC8vIGVsZW1lbnRzIHRvIGNvbnNpZGVyIGluIHRoZSBsYXlvdXRcbiAgdmFyIGxheW91dCA9IHRoaXM7XG5cbiAgLy8gY3kgaXMgYXV0b21hdGljYWxseSBwb3B1bGF0ZWQgZm9yIHVzIGluIHRoZSBjb25zdHJ1Y3RvclxuICAvLyAoZGlzYWJsZSBlc2xpbnQgZm9yIG5leHQgbGluZSBhcyB0aGlzIHNlcnZlcyBhcyBleGFtcGxlIGxheW91dCBjb2RlIHRvIGV4dGVybmFsIGRldmVsb3BlcnMpXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuICBvcHRpb25zLmN5O1xuICBsYXlvdXQuZW1pdCgnbGF5b3V0c3RhcnQnKTtcblxuICAvLyBwdXRzIGFsbCBub2RlcyBhdCAoMCwgMClcbiAgLy8gbi5iLiBtb3N0IGxheW91dHMgd291bGQgdXNlIGxheW91dFBvc2l0aW9ucygpLCBpbnN0ZWFkIG9mIHBvc2l0aW9ucygpIGFuZCBtYW51YWwgZXZlbnRzXG4gIGVsZXMubm9kZXMoKS5wb3NpdGlvbnMoZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB7XG4gICAgICB4OiAwLFxuICAgICAgeTogMFxuICAgIH07XG4gIH0pO1xuXG4gIC8vIHRyaWdnZXIgbGF5b3V0cmVhZHkgd2hlbiBlYWNoIG5vZGUgaGFzIGhhZCBpdHMgcG9zaXRpb24gc2V0IGF0IGxlYXN0IG9uY2VcbiAgbGF5b3V0Lm9uZSgnbGF5b3V0cmVhZHknLCBvcHRpb25zLnJlYWR5KTtcbiAgbGF5b3V0LmVtaXQoJ2xheW91dHJlYWR5Jyk7XG5cbiAgLy8gdHJpZ2dlciBsYXlvdXRzdG9wIHdoZW4gdGhlIGxheW91dCBzdG9wcyAoZS5nLiBmaW5pc2hlcylcbiAgbGF5b3V0Lm9uZSgnbGF5b3V0c3RvcCcsIG9wdGlvbnMuc3RvcCk7XG4gIGxheW91dC5lbWl0KCdsYXlvdXRzdG9wJyk7XG4gIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xufTtcblxuLy8gY2FsbGVkIG9uIGNvbnRpbnVvdXMgbGF5b3V0cyB0byBzdG9wIHRoZW0gYmVmb3JlIHRoZXkgZmluaXNoXG5OdWxsTGF5b3V0LnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbn07XG5cbnZhciBkZWZhdWx0cyQxID0ge1xuICBwb3NpdGlvbnM6IHVuZGVmaW5lZCxcbiAgLy8gbWFwIG9mIChub2RlIGlkKSA9PiAocG9zaXRpb24gb2JqKTsgb3IgZnVuY3Rpb24obm9kZSl7IHJldHVybiBzb21Qb3M7IH1cbiAgem9vbTogdW5kZWZpbmVkLFxuICAvLyB0aGUgem9vbSBsZXZlbCB0byBzZXQgKHByb2Igd2FudCBmaXQgPSBmYWxzZSBpZiBzZXQpXG4gIHBhbjogdW5kZWZpbmVkLFxuICAvLyB0aGUgcGFuIGxldmVsIHRvIHNldCAocHJvYiB3YW50IGZpdCA9IGZhbHNlIGlmIHNldClcbiAgZml0OiB0cnVlLFxuICAvLyB3aGV0aGVyIHRvIGZpdCB0byB2aWV3cG9ydFxuICBwYWRkaW5nOiAzMCxcbiAgLy8gcGFkZGluZyBvbiBmaXRcbiAgc3BhY2luZ0ZhY3RvcjogdW5kZWZpbmVkLFxuICAvLyBBcHBsaWVzIGEgbXVsdGlwbGljYXRpdmUgZmFjdG9yICg+MCkgdG8gZXhwYW5kIG9yIGNvbXByZXNzIHRoZSBvdmVyYWxsIGFyZWEgdGhhdCB0aGUgbm9kZXMgdGFrZSB1cFxuICBhbmltYXRlOiBmYWxzZSxcbiAgLy8gd2hldGhlciB0byB0cmFuc2l0aW9uIHRoZSBub2RlIHBvc2l0aW9uc1xuICBhbmltYXRpb25EdXJhdGlvbjogNTAwLFxuICAvLyBkdXJhdGlvbiBvZiBhbmltYXRpb24gaW4gbXMgaWYgZW5hYmxlZFxuICBhbmltYXRpb25FYXNpbmc6IHVuZGVmaW5lZCxcbiAgLy8gZWFzaW5nIG9mIGFuaW1hdGlvbiBpZiBlbmFibGVkXG4gIGFuaW1hdGVGaWx0ZXI6IGZ1bmN0aW9uIGFuaW1hdGVGaWx0ZXIobm9kZSwgaSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9LFxuICAvLyBhIGZ1bmN0aW9uIHRoYXQgZGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBub2RlIHNob3VsZCBiZSBhbmltYXRlZC4gIEFsbCBub2RlcyBhbmltYXRlZCBieSBkZWZhdWx0IG9uIGFuaW1hdGUgZW5hYmxlZC4gIE5vbi1hbmltYXRlZCBub2RlcyBhcmUgcG9zaXRpb25lZCBpbW1lZGlhdGVseSB3aGVuIHRoZSBsYXlvdXQgc3RhcnRzXG4gIHJlYWR5OiB1bmRlZmluZWQsXG4gIC8vIGNhbGxiYWNrIG9uIGxheW91dHJlYWR5XG4gIHN0b3A6IHVuZGVmaW5lZCxcbiAgLy8gY2FsbGJhY2sgb24gbGF5b3V0c3RvcFxuICB0cmFuc2Zvcm06IGZ1bmN0aW9uIHRyYW5zZm9ybShub2RlLCBwb3NpdGlvbikge1xuICAgIHJldHVybiBwb3NpdGlvbjtcbiAgfSAvLyB0cmFuc2Zvcm0gYSBnaXZlbiBub2RlIHBvc2l0aW9uLiBVc2VmdWwgZm9yIGNoYW5naW5nIGZsb3cgZGlyZWN0aW9uIGluIGRpc2NyZXRlIGxheW91dHNcbn07XG5cbmZ1bmN0aW9uIFByZXNldExheW91dChvcHRpb25zKSB7XG4gIHRoaXMub3B0aW9ucyA9IGV4dGVuZCh7fSwgZGVmYXVsdHMkMSwgb3B0aW9ucyk7XG59XG5QcmVzZXRMYXlvdXQucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gIHZhciBlbGVzID0gb3B0aW9ucy5lbGVzO1xuICB2YXIgbm9kZXMgPSBlbGVzLm5vZGVzKCk7XG4gIHZhciBwb3NJc0ZuID0gZm4kNihvcHRpb25zLnBvc2l0aW9ucyk7XG4gIGZ1bmN0aW9uIGdldFBvc2l0aW9uKG5vZGUpIHtcbiAgICBpZiAob3B0aW9ucy5wb3NpdGlvbnMgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGNvcHlQb3NpdGlvbihub2RlLnBvc2l0aW9uKCkpO1xuICAgIH1cbiAgICBpZiAocG9zSXNGbikge1xuICAgICAgcmV0dXJuIG9wdGlvbnMucG9zaXRpb25zKG5vZGUpO1xuICAgIH1cbiAgICB2YXIgcG9zID0gb3B0aW9ucy5wb3NpdGlvbnNbbm9kZS5fcHJpdmF0ZS5kYXRhLmlkXTtcbiAgICBpZiAocG9zID09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gcG9zO1xuICB9XG4gIG5vZGVzLmxheW91dFBvc2l0aW9ucyh0aGlzLCBvcHRpb25zLCBmdW5jdGlvbiAobm9kZSwgaSkge1xuICAgIHZhciBwb3NpdGlvbiA9IGdldFBvc2l0aW9uKG5vZGUpO1xuICAgIGlmIChub2RlLmxvY2tlZCgpIHx8IHBvc2l0aW9uID09IG51bGwpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHBvc2l0aW9uO1xuICB9KTtcbiAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG59O1xuXG52YXIgZGVmYXVsdHMgPSB7XG4gIGZpdDogdHJ1ZSxcbiAgLy8gd2hldGhlciB0byBmaXQgdG8gdmlld3BvcnRcbiAgcGFkZGluZzogMzAsXG4gIC8vIGZpdCBwYWRkaW5nXG4gIGJvdW5kaW5nQm94OiB1bmRlZmluZWQsXG4gIC8vIGNvbnN0cmFpbiBsYXlvdXQgYm91bmRzOyB7IHgxLCB5MSwgeDIsIHkyIH0gb3IgeyB4MSwgeTEsIHcsIGggfVxuICBhbmltYXRlOiBmYWxzZSxcbiAgLy8gd2hldGhlciB0byB0cmFuc2l0aW9uIHRoZSBub2RlIHBvc2l0aW9uc1xuICBhbmltYXRpb25EdXJhdGlvbjogNTAwLFxuICAvLyBkdXJhdGlvbiBvZiBhbmltYXRpb24gaW4gbXMgaWYgZW5hYmxlZFxuICBhbmltYXRpb25FYXNpbmc6IHVuZGVmaW5lZCxcbiAgLy8gZWFzaW5nIG9mIGFuaW1hdGlvbiBpZiBlbmFibGVkXG4gIGFuaW1hdGVGaWx0ZXI6IGZ1bmN0aW9uIGFuaW1hdGVGaWx0ZXIobm9kZSwgaSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9LFxuICAvLyBhIGZ1bmN0aW9uIHRoYXQgZGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBub2RlIHNob3VsZCBiZSBhbmltYXRlZC4gIEFsbCBub2RlcyBhbmltYXRlZCBieSBkZWZhdWx0IG9uIGFuaW1hdGUgZW5hYmxlZC4gIE5vbi1hbmltYXRlZCBub2RlcyBhcmUgcG9zaXRpb25lZCBpbW1lZGlhdGVseSB3aGVuIHRoZSBsYXlvdXQgc3RhcnRzXG4gIHJlYWR5OiB1bmRlZmluZWQsXG4gIC8vIGNhbGxiYWNrIG9uIGxheW91dHJlYWR5XG4gIHN0b3A6IHVuZGVmaW5lZCxcbiAgLy8gY2FsbGJhY2sgb24gbGF5b3V0c3RvcFxuICB0cmFuc2Zvcm06IGZ1bmN0aW9uIHRyYW5zZm9ybShub2RlLCBwb3NpdGlvbikge1xuICAgIHJldHVybiBwb3NpdGlvbjtcbiAgfSAvLyB0cmFuc2Zvcm0gYSBnaXZlbiBub2RlIHBvc2l0aW9uLiBVc2VmdWwgZm9yIGNoYW5naW5nIGZsb3cgZGlyZWN0aW9uIGluIGRpc2NyZXRlIGxheW91dHMgXG59O1xuXG5mdW5jdGlvbiBSYW5kb21MYXlvdXQob3B0aW9ucykge1xuICB0aGlzLm9wdGlvbnMgPSBleHRlbmQoe30sIGRlZmF1bHRzLCBvcHRpb25zKTtcbn1cblJhbmRvbUxheW91dC5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgdmFyIGN5ID0gb3B0aW9ucy5jeTtcbiAgdmFyIGVsZXMgPSBvcHRpb25zLmVsZXM7XG4gIHZhciBiYiA9IG1ha2VCb3VuZGluZ0JveChvcHRpb25zLmJvdW5kaW5nQm94ID8gb3B0aW9ucy5ib3VuZGluZ0JveCA6IHtcbiAgICB4MTogMCxcbiAgICB5MTogMCxcbiAgICB3OiBjeS53aWR0aCgpLFxuICAgIGg6IGN5LmhlaWdodCgpXG4gIH0pO1xuICB2YXIgZ2V0UG9zID0gZnVuY3Rpb24gZ2V0UG9zKG5vZGUsIGkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDogYmIueDEgKyBNYXRoLnJvdW5kKE1hdGgucmFuZG9tKCkgKiBiYi53KSxcbiAgICAgIHk6IGJiLnkxICsgTWF0aC5yb3VuZChNYXRoLnJhbmRvbSgpICogYmIuaClcbiAgICB9O1xuICB9O1xuICBlbGVzLm5vZGVzKCkubGF5b3V0UG9zaXRpb25zKHRoaXMsIG9wdGlvbnMsIGdldFBvcyk7XG4gIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xufTtcblxudmFyIGxheW91dCA9IFt7XG4gIG5hbWU6ICdicmVhZHRoZmlyc3QnLFxuICBpbXBsOiBCcmVhZHRoRmlyc3RMYXlvdXRcbn0sIHtcbiAgbmFtZTogJ2NpcmNsZScsXG4gIGltcGw6IENpcmNsZUxheW91dFxufSwge1xuICBuYW1lOiAnY29uY2VudHJpYycsXG4gIGltcGw6IENvbmNlbnRyaWNMYXlvdXRcbn0sIHtcbiAgbmFtZTogJ2Nvc2UnLFxuICBpbXBsOiBDb3NlTGF5b3V0XG59LCB7XG4gIG5hbWU6ICdncmlkJyxcbiAgaW1wbDogR3JpZExheW91dFxufSwge1xuICBuYW1lOiAnbnVsbCcsXG4gIGltcGw6IE51bGxMYXlvdXRcbn0sIHtcbiAgbmFtZTogJ3ByZXNldCcsXG4gIGltcGw6IFByZXNldExheW91dFxufSwge1xuICBuYW1lOiAncmFuZG9tJyxcbiAgaW1wbDogUmFuZG9tTGF5b3V0XG59XTtcblxuZnVuY3Rpb24gTnVsbFJlbmRlcmVyKG9wdGlvbnMpIHtcbiAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgdGhpcy5ub3RpZmljYXRpb25zID0gMDsgLy8gZm9yIHRlc3Rpbmdcbn1cblxudmFyIG5vb3AgPSBmdW5jdGlvbiBub29wKCkge307XG52YXIgdGhyb3dJbWdFcnIgPSBmdW5jdGlvbiB0aHJvd0ltZ0VycigpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdBIGhlYWRsZXNzIGluc3RhbmNlIGNhbiBub3QgcmVuZGVyIGltYWdlcycpO1xufTtcbk51bGxSZW5kZXJlci5wcm90b3R5cGUgPSB7XG4gIHJlY2FsY3VsYXRlUmVuZGVyZWRTdHlsZTogbm9vcCxcbiAgbm90aWZ5OiBmdW5jdGlvbiBub3RpZnkoKSB7XG4gICAgdGhpcy5ub3RpZmljYXRpb25zKys7XG4gIH0sXG4gIGluaXQ6IG5vb3AsXG4gIGlzSGVhZGxlc3M6IGZ1bmN0aW9uIGlzSGVhZGxlc3MoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sXG4gIHBuZzogdGhyb3dJbWdFcnIsXG4gIGpwZzogdGhyb3dJbWdFcnJcbn07XG5cbnZhciBCUnAkZiA9IHt9O1xuQlJwJGYuYXJyb3dTaGFwZVdpZHRoID0gMC4zO1xuQlJwJGYucmVnaXN0ZXJBcnJvd1NoYXBlcyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGFycm93U2hhcGVzID0gdGhpcy5hcnJvd1NoYXBlcyA9IHt9O1xuICB2YXIgcmVuZGVyZXIgPSB0aGlzO1xuXG4gIC8vIENvbnRyYWN0IGZvciBhcnJvdyBzaGFwZXM6XG4gIC8vIDAsIDAgaXMgYXJyb3cgdGlwXG4gIC8vICgwLCAxKSBpcyBkaXJlY3Rpb24gdG93YXJkcyBub2RlXG4gIC8vICgxLCAwKSBpcyByaWdodFxuICAvL1xuICAvLyBmdW5jdGlvbmFsIGFwaTpcbiAgLy8gY29sbGlkZTogY2hlY2sgeCwgeSBpbiBzaGFwZVxuICAvLyByb3VnaENvbGxpZGU6IGNhbGxlZCBiZWZvcmUgY29sbGlkZSwgbm8gZmFsc2UgbmVnYXRpdmVzXG4gIC8vIGRyYXc6IGRyYXdcbiAgLy8gc3BhY2luZzogZGlzdChhcnJvd1RpcCwgbm9kZUJvdW5kYXJ5KVxuICAvLyBnYXA6IGRpc3QoZWRnZVRpcCwgbm9kZUJvdW5kYXJ5KSwgZWRnZVRpcCBtYXkgIT0gYXJyb3dUaXBcblxuICB2YXIgYmJDb2xsaWRlID0gZnVuY3Rpb24gYmJDb2xsaWRlKHgsIHksIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbiwgZWRnZVdpZHRoLCBwYWRkaW5nKSB7XG4gICAgdmFyIHgxID0gdHJhbnNsYXRpb24ueCAtIHNpemUgLyAyIC0gcGFkZGluZztcbiAgICB2YXIgeDIgPSB0cmFuc2xhdGlvbi54ICsgc2l6ZSAvIDIgKyBwYWRkaW5nO1xuICAgIHZhciB5MSA9IHRyYW5zbGF0aW9uLnkgLSBzaXplIC8gMiAtIHBhZGRpbmc7XG4gICAgdmFyIHkyID0gdHJhbnNsYXRpb24ueSArIHNpemUgLyAyICsgcGFkZGluZztcbiAgICB2YXIgaW5zaWRlID0geDEgPD0geCAmJiB4IDw9IHgyICYmIHkxIDw9IHkgJiYgeSA8PSB5MjtcbiAgICByZXR1cm4gaW5zaWRlO1xuICB9O1xuICB2YXIgdHJhbnNmb3JtID0gZnVuY3Rpb24gdHJhbnNmb3JtKHgsIHksIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbikge1xuICAgIHZhciB4Um90YXRlZCA9IHggKiBNYXRoLmNvcyhhbmdsZSkgLSB5ICogTWF0aC5zaW4oYW5nbGUpO1xuICAgIHZhciB5Um90YXRlZCA9IHggKiBNYXRoLnNpbihhbmdsZSkgKyB5ICogTWF0aC5jb3MoYW5nbGUpO1xuICAgIHZhciB4U2NhbGVkID0geFJvdGF0ZWQgKiBzaXplO1xuICAgIHZhciB5U2NhbGVkID0geVJvdGF0ZWQgKiBzaXplO1xuICAgIHZhciB4VHJhbnNsYXRlZCA9IHhTY2FsZWQgKyB0cmFuc2xhdGlvbi54O1xuICAgIHZhciB5VHJhbnNsYXRlZCA9IHlTY2FsZWQgKyB0cmFuc2xhdGlvbi55O1xuICAgIHJldHVybiB7XG4gICAgICB4OiB4VHJhbnNsYXRlZCxcbiAgICAgIHk6IHlUcmFuc2xhdGVkXG4gICAgfTtcbiAgfTtcbiAgdmFyIHRyYW5zZm9ybVBvaW50cyA9IGZ1bmN0aW9uIHRyYW5zZm9ybVBvaW50cyhwdHMsIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbikge1xuICAgIHZhciByZXRQdHMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHB0cy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgdmFyIHggPSBwdHNbaV07XG4gICAgICB2YXIgeSA9IHB0c1tpICsgMV07XG4gICAgICByZXRQdHMucHVzaCh0cmFuc2Zvcm0oeCwgeSwgc2l6ZSwgYW5nbGUsIHRyYW5zbGF0aW9uKSk7XG4gICAgfVxuICAgIHJldHVybiByZXRQdHM7XG4gIH07XG4gIHZhciBwb2ludHNUb0FyciA9IGZ1bmN0aW9uIHBvaW50c1RvQXJyKHB0cykge1xuICAgIHZhciByZXQgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHB0cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHAgPSBwdHNbaV07XG4gICAgICByZXQucHVzaChwLngsIHAueSk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH07XG4gIHZhciBzdGFuZGFyZEdhcCA9IGZ1bmN0aW9uIHN0YW5kYXJkR2FwKGVkZ2UpIHtcbiAgICByZXR1cm4gZWRnZS5wc3R5bGUoJ3dpZHRoJykucGZWYWx1ZSAqIGVkZ2UucHN0eWxlKCdhcnJvdy1zY2FsZScpLnBmVmFsdWUgKiAyO1xuICB9O1xuICB2YXIgZGVmaW5lQXJyb3dTaGFwZSA9IGZ1bmN0aW9uIGRlZmluZUFycm93U2hhcGUobmFtZSwgZGVmbikge1xuICAgIGlmIChzdHJpbmcoZGVmbikpIHtcbiAgICAgIGRlZm4gPSBhcnJvd1NoYXBlc1tkZWZuXTtcbiAgICB9XG4gICAgYXJyb3dTaGFwZXNbbmFtZV0gPSBleHRlbmQoe1xuICAgICAgbmFtZTogbmFtZSxcbiAgICAgIHBvaW50czogWy0wLjE1LCAtMC4zLCAwLjE1LCAtMC4zLCAwLjE1LCAwLjMsIC0wLjE1LCAwLjNdLFxuICAgICAgY29sbGlkZTogZnVuY3Rpb24gY29sbGlkZSh4LCB5LCBzaXplLCBhbmdsZSwgdHJhbnNsYXRpb24sIHBhZGRpbmcpIHtcbiAgICAgICAgdmFyIHBvaW50cyA9IHBvaW50c1RvQXJyKHRyYW5zZm9ybVBvaW50cyh0aGlzLnBvaW50cywgc2l6ZSArIDIgKiBwYWRkaW5nLCBhbmdsZSwgdHJhbnNsYXRpb24pKTtcbiAgICAgICAgdmFyIGluc2lkZSA9IHBvaW50SW5zaWRlUG9seWdvblBvaW50cyh4LCB5LCBwb2ludHMpO1xuICAgICAgICByZXR1cm4gaW5zaWRlO1xuICAgICAgfSxcbiAgICAgIHJvdWdoQ29sbGlkZTogYmJDb2xsaWRlLFxuICAgICAgZHJhdzogZnVuY3Rpb24gZHJhdyhjb250ZXh0LCBzaXplLCBhbmdsZSwgdHJhbnNsYXRpb24pIHtcbiAgICAgICAgdmFyIHBvaW50cyA9IHRyYW5zZm9ybVBvaW50cyh0aGlzLnBvaW50cywgc2l6ZSwgYW5nbGUsIHRyYW5zbGF0aW9uKTtcbiAgICAgICAgcmVuZGVyZXIuYXJyb3dTaGFwZUltcGwoJ3BvbHlnb24nKShjb250ZXh0LCBwb2ludHMpO1xuICAgICAgfSxcbiAgICAgIHNwYWNpbmc6IGZ1bmN0aW9uIHNwYWNpbmcoZWRnZSkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH0sXG4gICAgICBnYXA6IHN0YW5kYXJkR2FwXG4gICAgfSwgZGVmbik7XG4gIH07XG4gIGRlZmluZUFycm93U2hhcGUoJ25vbmUnLCB7XG4gICAgY29sbGlkZTogZmFsc2lmeSxcbiAgICByb3VnaENvbGxpZGU6IGZhbHNpZnksXG4gICAgZHJhdzogbm9vcCQxLFxuICAgIHNwYWNpbmc6IHplcm9pZnksXG4gICAgZ2FwOiB6ZXJvaWZ5XG4gIH0pO1xuICBkZWZpbmVBcnJvd1NoYXBlKCd0cmlhbmdsZScsIHtcbiAgICBwb2ludHM6IFstMC4xNSwgLTAuMywgMCwgMCwgMC4xNSwgLTAuM11cbiAgfSk7XG4gIGRlZmluZUFycm93U2hhcGUoJ2Fycm93JywgJ3RyaWFuZ2xlJyk7XG4gIGRlZmluZUFycm93U2hhcGUoJ3RyaWFuZ2xlLWJhY2tjdXJ2ZScsIHtcbiAgICBwb2ludHM6IGFycm93U2hhcGVzWyd0cmlhbmdsZSddLnBvaW50cyxcbiAgICBjb250cm9sUG9pbnQ6IFswLCAtMC4xNV0sXG4gICAgcm91Z2hDb2xsaWRlOiBiYkNvbGxpZGUsXG4gICAgZHJhdzogZnVuY3Rpb24gZHJhdyhjb250ZXh0LCBzaXplLCBhbmdsZSwgdHJhbnNsYXRpb24sIGVkZ2VXaWR0aCkge1xuICAgICAgdmFyIHB0c1RyYW5zID0gdHJhbnNmb3JtUG9pbnRzKHRoaXMucG9pbnRzLCBzaXplLCBhbmdsZSwgdHJhbnNsYXRpb24pO1xuICAgICAgdmFyIGN0cmxQdCA9IHRoaXMuY29udHJvbFBvaW50O1xuICAgICAgdmFyIGN0cmxQdFRyYW5zID0gdHJhbnNmb3JtKGN0cmxQdFswXSwgY3RybFB0WzFdLCBzaXplLCBhbmdsZSwgdHJhbnNsYXRpb24pO1xuICAgICAgcmVuZGVyZXIuYXJyb3dTaGFwZUltcGwodGhpcy5uYW1lKShjb250ZXh0LCBwdHNUcmFucywgY3RybFB0VHJhbnMpO1xuICAgIH0sXG4gICAgZ2FwOiBmdW5jdGlvbiBnYXAoZWRnZSkge1xuICAgICAgcmV0dXJuIHN0YW5kYXJkR2FwKGVkZ2UpICogMC44O1xuICAgIH1cbiAgfSk7XG4gIGRlZmluZUFycm93U2hhcGUoJ3RyaWFuZ2xlLXRlZScsIHtcbiAgICBwb2ludHM6IFswLCAwLCAwLjE1LCAtMC4zLCAtMC4xNSwgLTAuMywgMCwgMF0sXG4gICAgcG9pbnRzVGVlOiBbLTAuMTUsIC0wLjQsIC0wLjE1LCAtMC41LCAwLjE1LCAtMC41LCAwLjE1LCAtMC40XSxcbiAgICBjb2xsaWRlOiBmdW5jdGlvbiBjb2xsaWRlKHgsIHksIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbiwgZWRnZVdpZHRoLCBwYWRkaW5nKSB7XG4gICAgICB2YXIgdHJpUHRzID0gcG9pbnRzVG9BcnIodHJhbnNmb3JtUG9pbnRzKHRoaXMucG9pbnRzLCBzaXplICsgMiAqIHBhZGRpbmcsIGFuZ2xlLCB0cmFuc2xhdGlvbikpO1xuICAgICAgdmFyIHRlZVB0cyA9IHBvaW50c1RvQXJyKHRyYW5zZm9ybVBvaW50cyh0aGlzLnBvaW50c1RlZSwgc2l6ZSArIDIgKiBwYWRkaW5nLCBhbmdsZSwgdHJhbnNsYXRpb24pKTtcbiAgICAgIHZhciBpbnNpZGUgPSBwb2ludEluc2lkZVBvbHlnb25Qb2ludHMoeCwgeSwgdHJpUHRzKSB8fCBwb2ludEluc2lkZVBvbHlnb25Qb2ludHMoeCwgeSwgdGVlUHRzKTtcbiAgICAgIHJldHVybiBpbnNpZGU7XG4gICAgfSxcbiAgICBkcmF3OiBmdW5jdGlvbiBkcmF3KGNvbnRleHQsIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbiwgZWRnZVdpZHRoKSB7XG4gICAgICB2YXIgdHJpUHRzID0gdHJhbnNmb3JtUG9pbnRzKHRoaXMucG9pbnRzLCBzaXplLCBhbmdsZSwgdHJhbnNsYXRpb24pO1xuICAgICAgdmFyIHRlZVB0cyA9IHRyYW5zZm9ybVBvaW50cyh0aGlzLnBvaW50c1RlZSwgc2l6ZSwgYW5nbGUsIHRyYW5zbGF0aW9uKTtcbiAgICAgIHJlbmRlcmVyLmFycm93U2hhcGVJbXBsKHRoaXMubmFtZSkoY29udGV4dCwgdHJpUHRzLCB0ZWVQdHMpO1xuICAgIH1cbiAgfSk7XG4gIGRlZmluZUFycm93U2hhcGUoJ2NpcmNsZS10cmlhbmdsZScsIHtcbiAgICByYWRpdXM6IDAuMTUsXG4gICAgcG9pbnRzVHI6IFswLCAtMC4xNSwgMC4xNSwgLTAuNDUsIC0wLjE1LCAtMC40NSwgMCwgLTAuMTVdLFxuICAgIGNvbGxpZGU6IGZ1bmN0aW9uIGNvbGxpZGUoeCwgeSwgc2l6ZSwgYW5nbGUsIHRyYW5zbGF0aW9uLCBlZGdlV2lkdGgsIHBhZGRpbmcpIHtcbiAgICAgIHZhciB0ID0gdHJhbnNsYXRpb247XG4gICAgICB2YXIgY2lyY2xlSW5zaWRlID0gTWF0aC5wb3codC54IC0geCwgMikgKyBNYXRoLnBvdyh0LnkgLSB5LCAyKSA8PSBNYXRoLnBvdygoc2l6ZSArIDIgKiBwYWRkaW5nKSAqIHRoaXMucmFkaXVzLCAyKTtcbiAgICAgIHZhciB0cmlQdHMgPSBwb2ludHNUb0Fycih0cmFuc2Zvcm1Qb2ludHModGhpcy5wb2ludHMsIHNpemUgKyAyICogcGFkZGluZywgYW5nbGUsIHRyYW5zbGF0aW9uKSk7XG4gICAgICByZXR1cm4gcG9pbnRJbnNpZGVQb2x5Z29uUG9pbnRzKHgsIHksIHRyaVB0cykgfHwgY2lyY2xlSW5zaWRlO1xuICAgIH0sXG4gICAgZHJhdzogZnVuY3Rpb24gZHJhdyhjb250ZXh0LCBzaXplLCBhbmdsZSwgdHJhbnNsYXRpb24sIGVkZ2VXaWR0aCkge1xuICAgICAgdmFyIHRyaVB0cyA9IHRyYW5zZm9ybVBvaW50cyh0aGlzLnBvaW50c1RyLCBzaXplLCBhbmdsZSwgdHJhbnNsYXRpb24pO1xuICAgICAgcmVuZGVyZXIuYXJyb3dTaGFwZUltcGwodGhpcy5uYW1lKShjb250ZXh0LCB0cmlQdHMsIHRyYW5zbGF0aW9uLngsIHRyYW5zbGF0aW9uLnksIHRoaXMucmFkaXVzICogc2l6ZSk7XG4gICAgfSxcbiAgICBzcGFjaW5nOiBmdW5jdGlvbiBzcGFjaW5nKGVkZ2UpIHtcbiAgICAgIHJldHVybiByZW5kZXJlci5nZXRBcnJvd1dpZHRoKGVkZ2UucHN0eWxlKCd3aWR0aCcpLnBmVmFsdWUsIGVkZ2UucHN0eWxlKCdhcnJvdy1zY2FsZScpLnZhbHVlKSAqIHRoaXMucmFkaXVzO1xuICAgIH1cbiAgfSk7XG4gIGRlZmluZUFycm93U2hhcGUoJ3RyaWFuZ2xlLWNyb3NzJywge1xuICAgIHBvaW50czogWzAsIDAsIDAuMTUsIC0wLjMsIC0wLjE1LCAtMC4zLCAwLCAwXSxcbiAgICBiYXNlQ3Jvc3NMaW5lUHRzOiBbLTAuMTUsIC0wLjQsXG4gICAgLy8gZmlyc3QgaGFsZiBvZiB0aGUgcmVjdGFuZ2xlXG4gICAgLTAuMTUsIC0wLjQsIDAuMTUsIC0wLjQsXG4gICAgLy8gc2Vjb25kIGhhbGYgb2YgdGhlIHJlY3RhbmdsZVxuICAgIDAuMTUsIC0wLjRdLFxuICAgIGNyb3NzTGluZVB0czogZnVuY3Rpb24gY3Jvc3NMaW5lUHRzKHNpemUsIGVkZ2VXaWR0aCkge1xuICAgICAgLy8gc2hpZnQgcG9pbnRzIHNvIHRoYXQgdGhlIGRpc3RhbmNlIGJldHdlZW4gdGhlIGNyb3NzIHBvaW50cyBtYXRjaGVzIGVkZ2Ugd2lkdGhcbiAgICAgIHZhciBwID0gdGhpcy5iYXNlQ3Jvc3NMaW5lUHRzLnNsaWNlKCk7XG4gICAgICB2YXIgc2hpZnRGYWN0b3IgPSBlZGdlV2lkdGggLyBzaXplO1xuICAgICAgdmFyIHkwID0gMztcbiAgICAgIHZhciB5MSA9IDU7XG4gICAgICBwW3kwXSA9IHBbeTBdIC0gc2hpZnRGYWN0b3I7XG4gICAgICBwW3kxXSA9IHBbeTFdIC0gc2hpZnRGYWN0b3I7XG4gICAgICByZXR1cm4gcDtcbiAgICB9LFxuICAgIGNvbGxpZGU6IGZ1bmN0aW9uIGNvbGxpZGUoeCwgeSwgc2l6ZSwgYW5nbGUsIHRyYW5zbGF0aW9uLCBlZGdlV2lkdGgsIHBhZGRpbmcpIHtcbiAgICAgIHZhciB0cmlQdHMgPSBwb2ludHNUb0Fycih0cmFuc2Zvcm1Qb2ludHModGhpcy5wb2ludHMsIHNpemUgKyAyICogcGFkZGluZywgYW5nbGUsIHRyYW5zbGF0aW9uKSk7XG4gICAgICB2YXIgdGVlUHRzID0gcG9pbnRzVG9BcnIodHJhbnNmb3JtUG9pbnRzKHRoaXMuY3Jvc3NMaW5lUHRzKHNpemUsIGVkZ2VXaWR0aCksIHNpemUgKyAyICogcGFkZGluZywgYW5nbGUsIHRyYW5zbGF0aW9uKSk7XG4gICAgICB2YXIgaW5zaWRlID0gcG9pbnRJbnNpZGVQb2x5Z29uUG9pbnRzKHgsIHksIHRyaVB0cykgfHwgcG9pbnRJbnNpZGVQb2x5Z29uUG9pbnRzKHgsIHksIHRlZVB0cyk7XG4gICAgICByZXR1cm4gaW5zaWRlO1xuICAgIH0sXG4gICAgZHJhdzogZnVuY3Rpb24gZHJhdyhjb250ZXh0LCBzaXplLCBhbmdsZSwgdHJhbnNsYXRpb24sIGVkZ2VXaWR0aCkge1xuICAgICAgdmFyIHRyaVB0cyA9IHRyYW5zZm9ybVBvaW50cyh0aGlzLnBvaW50cywgc2l6ZSwgYW5nbGUsIHRyYW5zbGF0aW9uKTtcbiAgICAgIHZhciBjcm9zc0xpbmVQdHMgPSB0cmFuc2Zvcm1Qb2ludHModGhpcy5jcm9zc0xpbmVQdHMoc2l6ZSwgZWRnZVdpZHRoKSwgc2l6ZSwgYW5nbGUsIHRyYW5zbGF0aW9uKTtcbiAgICAgIHJlbmRlcmVyLmFycm93U2hhcGVJbXBsKHRoaXMubmFtZSkoY29udGV4dCwgdHJpUHRzLCBjcm9zc0xpbmVQdHMpO1xuICAgIH1cbiAgfSk7XG4gIGRlZmluZUFycm93U2hhcGUoJ3ZlZScsIHtcbiAgICBwb2ludHM6IFstMC4xNSwgLTAuMywgMCwgMCwgMC4xNSwgLTAuMywgMCwgLTAuMTVdLFxuICAgIGdhcDogZnVuY3Rpb24gZ2FwKGVkZ2UpIHtcbiAgICAgIHJldHVybiBzdGFuZGFyZEdhcChlZGdlKSAqIDAuNTI1O1xuICAgIH1cbiAgfSk7XG4gIGRlZmluZUFycm93U2hhcGUoJ2NpcmNsZScsIHtcbiAgICByYWRpdXM6IDAuMTUsXG4gICAgY29sbGlkZTogZnVuY3Rpb24gY29sbGlkZSh4LCB5LCBzaXplLCBhbmdsZSwgdHJhbnNsYXRpb24sIGVkZ2VXaWR0aCwgcGFkZGluZykge1xuICAgICAgdmFyIHQgPSB0cmFuc2xhdGlvbjtcbiAgICAgIHZhciBpbnNpZGUgPSBNYXRoLnBvdyh0LnggLSB4LCAyKSArIE1hdGgucG93KHQueSAtIHksIDIpIDw9IE1hdGgucG93KChzaXplICsgMiAqIHBhZGRpbmcpICogdGhpcy5yYWRpdXMsIDIpO1xuICAgICAgcmV0dXJuIGluc2lkZTtcbiAgICB9LFxuICAgIGRyYXc6IGZ1bmN0aW9uIGRyYXcoY29udGV4dCwgc2l6ZSwgYW5nbGUsIHRyYW5zbGF0aW9uLCBlZGdlV2lkdGgpIHtcbiAgICAgIHJlbmRlcmVyLmFycm93U2hhcGVJbXBsKHRoaXMubmFtZSkoY29udGV4dCwgdHJhbnNsYXRpb24ueCwgdHJhbnNsYXRpb24ueSwgdGhpcy5yYWRpdXMgKiBzaXplKTtcbiAgICB9LFxuICAgIHNwYWNpbmc6IGZ1bmN0aW9uIHNwYWNpbmcoZWRnZSkge1xuICAgICAgcmV0dXJuIHJlbmRlcmVyLmdldEFycm93V2lkdGgoZWRnZS5wc3R5bGUoJ3dpZHRoJykucGZWYWx1ZSwgZWRnZS5wc3R5bGUoJ2Fycm93LXNjYWxlJykudmFsdWUpICogdGhpcy5yYWRpdXM7XG4gICAgfVxuICB9KTtcbiAgZGVmaW5lQXJyb3dTaGFwZSgndGVlJywge1xuICAgIHBvaW50czogWy0wLjE1LCAwLCAtMC4xNSwgLTAuMSwgMC4xNSwgLTAuMSwgMC4xNSwgMF0sXG4gICAgc3BhY2luZzogZnVuY3Rpb24gc3BhY2luZyhlZGdlKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9LFxuICAgIGdhcDogZnVuY3Rpb24gZ2FwKGVkZ2UpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgfSk7XG4gIGRlZmluZUFycm93U2hhcGUoJ3NxdWFyZScsIHtcbiAgICBwb2ludHM6IFstMC4xNSwgMC4wMCwgMC4xNSwgMC4wMCwgMC4xNSwgLTAuMywgLTAuMTUsIC0wLjNdXG4gIH0pO1xuICBkZWZpbmVBcnJvd1NoYXBlKCdkaWFtb25kJywge1xuICAgIHBvaW50czogWy0wLjE1LCAtMC4xNSwgMCwgLTAuMywgMC4xNSwgLTAuMTUsIDAsIDBdLFxuICAgIGdhcDogZnVuY3Rpb24gZ2FwKGVkZ2UpIHtcbiAgICAgIHJldHVybiBlZGdlLnBzdHlsZSgnd2lkdGgnKS5wZlZhbHVlICogZWRnZS5wc3R5bGUoJ2Fycm93LXNjYWxlJykudmFsdWU7XG4gICAgfVxuICB9KTtcbiAgZGVmaW5lQXJyb3dTaGFwZSgnY2hldnJvbicsIHtcbiAgICBwb2ludHM6IFswLCAwLCAtMC4xNSwgLTAuMTUsIC0wLjEsIC0wLjIsIDAsIC0wLjEsIDAuMSwgLTAuMiwgMC4xNSwgLTAuMTVdLFxuICAgIGdhcDogZnVuY3Rpb24gZ2FwKGVkZ2UpIHtcbiAgICAgIHJldHVybiAwLjk1ICogZWRnZS5wc3R5bGUoJ3dpZHRoJykucGZWYWx1ZSAqIGVkZ2UucHN0eWxlKCdhcnJvdy1zY2FsZScpLnZhbHVlO1xuICAgIH1cbiAgfSk7XG59O1xuXG52YXIgQlJwJGUgPSB7fTtcblxuLy8gUHJvamVjdCBtb3VzZVxuQlJwJGUucHJvamVjdEludG9WaWV3cG9ydCA9IGZ1bmN0aW9uIChjbGllbnRYLCBjbGllbnRZKSB7XG4gIHZhciBjeSA9IHRoaXMuY3k7XG4gIHZhciBvZmZzZXRzID0gdGhpcy5maW5kQ29udGFpbmVyQ2xpZW50Q29vcmRzKCk7XG4gIHZhciBvZmZzZXRMZWZ0ID0gb2Zmc2V0c1swXTtcbiAgdmFyIG9mZnNldFRvcCA9IG9mZnNldHNbMV07XG4gIHZhciBzY2FsZSA9IG9mZnNldHNbNF07XG4gIHZhciBwYW4gPSBjeS5wYW4oKTtcbiAgdmFyIHpvb20gPSBjeS56b29tKCk7XG4gIHZhciB4ID0gKChjbGllbnRYIC0gb2Zmc2V0TGVmdCkgLyBzY2FsZSAtIHBhbi54KSAvIHpvb207XG4gIHZhciB5ID0gKChjbGllbnRZIC0gb2Zmc2V0VG9wKSAvIHNjYWxlIC0gcGFuLnkpIC8gem9vbTtcbiAgcmV0dXJuIFt4LCB5XTtcbn07XG5CUnAkZS5maW5kQ29udGFpbmVyQ2xpZW50Q29vcmRzID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5jb250YWluZXJCQikge1xuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lckJCO1xuICB9XG4gIHZhciBjb250YWluZXIgPSB0aGlzLmNvbnRhaW5lcjtcbiAgdmFyIHJlY3QgPSBjb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIHZhciBzdHlsZSA9IHRoaXMuY3kud2luZG93KCkuZ2V0Q29tcHV0ZWRTdHlsZShjb250YWluZXIpO1xuICB2YXIgc3R5bGVWYWx1ZSA9IGZ1bmN0aW9uIHN0eWxlVmFsdWUobmFtZSkge1xuICAgIHJldHVybiBwYXJzZUZsb2F0KHN0eWxlLmdldFByb3BlcnR5VmFsdWUobmFtZSkpO1xuICB9O1xuICB2YXIgcGFkZGluZyA9IHtcbiAgICBsZWZ0OiBzdHlsZVZhbHVlKCdwYWRkaW5nLWxlZnQnKSxcbiAgICByaWdodDogc3R5bGVWYWx1ZSgncGFkZGluZy1yaWdodCcpLFxuICAgIHRvcDogc3R5bGVWYWx1ZSgncGFkZGluZy10b3AnKSxcbiAgICBib3R0b206IHN0eWxlVmFsdWUoJ3BhZGRpbmctYm90dG9tJylcbiAgfTtcbiAgdmFyIGJvcmRlciA9IHtcbiAgICBsZWZ0OiBzdHlsZVZhbHVlKCdib3JkZXItbGVmdC13aWR0aCcpLFxuICAgIHJpZ2h0OiBzdHlsZVZhbHVlKCdib3JkZXItcmlnaHQtd2lkdGgnKSxcbiAgICB0b3A6IHN0eWxlVmFsdWUoJ2JvcmRlci10b3Atd2lkdGgnKSxcbiAgICBib3R0b206IHN0eWxlVmFsdWUoJ2JvcmRlci1ib3R0b20td2lkdGgnKVxuICB9O1xuICB2YXIgY2xpZW50V2lkdGggPSBjb250YWluZXIuY2xpZW50V2lkdGg7XG4gIHZhciBjbGllbnRIZWlnaHQgPSBjb250YWluZXIuY2xpZW50SGVpZ2h0O1xuICB2YXIgcGFkZGluZ0hvciA9IHBhZGRpbmcubGVmdCArIHBhZGRpbmcucmlnaHQ7XG4gIHZhciBwYWRkaW5nVmVyID0gcGFkZGluZy50b3AgKyBwYWRkaW5nLmJvdHRvbTtcbiAgdmFyIGJvcmRlckhvciA9IGJvcmRlci5sZWZ0ICsgYm9yZGVyLnJpZ2h0O1xuICB2YXIgc2NhbGUgPSByZWN0LndpZHRoIC8gKGNsaWVudFdpZHRoICsgYm9yZGVySG9yKTtcbiAgdmFyIHVuc2NhbGVkVyA9IGNsaWVudFdpZHRoIC0gcGFkZGluZ0hvcjtcbiAgdmFyIHVuc2NhbGVkSCA9IGNsaWVudEhlaWdodCAtIHBhZGRpbmdWZXI7XG4gIHZhciBsZWZ0ID0gcmVjdC5sZWZ0ICsgcGFkZGluZy5sZWZ0ICsgYm9yZGVyLmxlZnQ7XG4gIHZhciB0b3AgPSByZWN0LnRvcCArIHBhZGRpbmcudG9wICsgYm9yZGVyLnRvcDtcbiAgcmV0dXJuIHRoaXMuY29udGFpbmVyQkIgPSBbbGVmdCwgdG9wLCB1bnNjYWxlZFcsIHVuc2NhbGVkSCwgc2NhbGVdO1xufTtcbkJScCRlLmludmFsaWRhdGVDb250YWluZXJDbGllbnRDb29yZHNDYWNoZSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5jb250YWluZXJCQiA9IG51bGw7XG59O1xuQlJwJGUuZmluZE5lYXJlc3RFbGVtZW50ID0gZnVuY3Rpb24gKHgsIHksIGludGVyYWN0aXZlRWxlbWVudHNPbmx5LCBpc1RvdWNoKSB7XG4gIHJldHVybiB0aGlzLmZpbmROZWFyZXN0RWxlbWVudHMoeCwgeSwgaW50ZXJhY3RpdmVFbGVtZW50c09ubHksIGlzVG91Y2gpWzBdO1xufTtcbkJScCRlLmZpbmROZWFyZXN0RWxlbWVudHMgPSBmdW5jdGlvbiAoeCwgeSwgaW50ZXJhY3RpdmVFbGVtZW50c09ubHksIGlzVG91Y2gpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgciA9IHRoaXM7XG4gIHZhciBlbGVzID0gci5nZXRDYWNoZWRaU29ydGVkRWxlcygpO1xuICB2YXIgbmVhciA9IFtdOyAvLyAxIG5vZGUgbWF4LCAxIGVkZ2UgbWF4XG4gIHZhciB6b29tID0gci5jeS56b29tKCk7XG4gIHZhciBoYXNDb21wb3VuZHMgPSByLmN5Lmhhc0NvbXBvdW5kTm9kZXMoKTtcbiAgdmFyIGVkZ2VUaHJlc2hvbGQgPSAoaXNUb3VjaCA/IDI0IDogOCkgLyB6b29tO1xuICB2YXIgbm9kZVRocmVzaG9sZCA9IChpc1RvdWNoID8gOCA6IDIpIC8gem9vbTtcbiAgdmFyIGxhYmVsVGhyZXNob2xkID0gKGlzVG91Y2ggPyA4IDogMikgLyB6b29tO1xuICB2YXIgbWluU3FEaXN0ID0gSW5maW5pdHk7XG4gIHZhciBuZWFyRWRnZTtcbiAgdmFyIG5lYXJOb2RlO1xuICBpZiAoaW50ZXJhY3RpdmVFbGVtZW50c09ubHkpIHtcbiAgICBlbGVzID0gZWxlcy5pbnRlcmFjdGl2ZTtcbiAgfVxuICBmdW5jdGlvbiBhZGRFbGUoZWxlLCBzcURpc3QpIHtcbiAgICBpZiAoZWxlLmlzTm9kZSgpKSB7XG4gICAgICBpZiAobmVhck5vZGUpIHtcbiAgICAgICAgcmV0dXJuOyAvLyBjYW4ndCByZXBsYWNlIG5vZGVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5lYXJOb2RlID0gZWxlO1xuICAgICAgICBuZWFyLnB1c2goZWxlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGVsZS5pc0VkZ2UoKSAmJiAoc3FEaXN0ID09IG51bGwgfHwgc3FEaXN0IDwgbWluU3FEaXN0KSkge1xuICAgICAgaWYgKG5lYXJFZGdlKSB7XG4gICAgICAgIC8vIHRoZW4gcmVwbGFjZSBleGlzdGluZyBlZGdlXG4gICAgICAgIC8vIGNhbiByZXBsYWNlIG9ubHkgaWYgc2FtZSB6LWluZGV4XG4gICAgICAgIGlmIChuZWFyRWRnZS5wc3R5bGUoJ3otY29tcG91bmQtZGVwdGgnKS52YWx1ZSA9PT0gZWxlLnBzdHlsZSgnei1jb21wb3VuZC1kZXB0aCcpLnZhbHVlICYmIG5lYXJFZGdlLnBzdHlsZSgnei1jb21wb3VuZC1kZXB0aCcpLnZhbHVlID09PSBlbGUucHN0eWxlKCd6LWNvbXBvdW5kLWRlcHRoJykudmFsdWUpIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5lYXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChuZWFyW2ldLmlzRWRnZSgpKSB7XG4gICAgICAgICAgICAgIG5lYXJbaV0gPSBlbGU7XG4gICAgICAgICAgICAgIG5lYXJFZGdlID0gZWxlO1xuICAgICAgICAgICAgICBtaW5TcURpc3QgPSBzcURpc3QgIT0gbnVsbCA/IHNxRGlzdCA6IG1pblNxRGlzdDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZWFyLnB1c2goZWxlKTtcbiAgICAgICAgbmVhckVkZ2UgPSBlbGU7XG4gICAgICAgIG1pblNxRGlzdCA9IHNxRGlzdCAhPSBudWxsID8gc3FEaXN0IDogbWluU3FEaXN0O1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBjaGVja05vZGUobm9kZSkge1xuICAgIHZhciB3aWR0aCA9IG5vZGUub3V0ZXJXaWR0aCgpICsgMiAqIG5vZGVUaHJlc2hvbGQ7XG4gICAgdmFyIGhlaWdodCA9IG5vZGUub3V0ZXJIZWlnaHQoKSArIDIgKiBub2RlVGhyZXNob2xkO1xuICAgIHZhciBodyA9IHdpZHRoIC8gMjtcbiAgICB2YXIgaGggPSBoZWlnaHQgLyAyO1xuICAgIHZhciBwb3MgPSBub2RlLnBvc2l0aW9uKCk7XG4gICAgdmFyIGNvcm5lclJhZGl1cyA9IG5vZGUucHN0eWxlKCdjb3JuZXItcmFkaXVzJykudmFsdWUgPT09ICdhdXRvJyA/ICdhdXRvJyA6IG5vZGUucHN0eWxlKCdjb3JuZXItcmFkaXVzJykucGZWYWx1ZTtcbiAgICB2YXIgcnMgPSBub2RlLl9wcml2YXRlLnJzY3JhdGNoO1xuICAgIGlmIChwb3MueCAtIGh3IDw9IHggJiYgeCA8PSBwb3MueCArIGh3IC8vIGJiIGNoZWNrIHhcbiAgICAmJiBwb3MueSAtIGhoIDw9IHkgJiYgeSA8PSBwb3MueSArIGhoIC8vIGJiIGNoZWNrIHlcbiAgICApIHtcbiAgICAgIHZhciBzaGFwZSA9IHIubm9kZVNoYXBlc1tzZWxmLmdldE5vZGVTaGFwZShub2RlKV07XG4gICAgICBpZiAoc2hhcGUuY2hlY2tQb2ludCh4LCB5LCAwLCB3aWR0aCwgaGVpZ2h0LCBwb3MueCwgcG9zLnksIGNvcm5lclJhZGl1cywgcnMpKSB7XG4gICAgICAgIGFkZEVsZShub2RlLCAwKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGNoZWNrRWRnZShlZGdlKSB7XG4gICAgdmFyIF9wID0gZWRnZS5fcHJpdmF0ZTtcbiAgICB2YXIgcnMgPSBfcC5yc2NyYXRjaDtcbiAgICB2YXIgc3R5bGVXaWR0aCA9IGVkZ2UucHN0eWxlKCd3aWR0aCcpLnBmVmFsdWU7XG4gICAgdmFyIHNjYWxlID0gZWRnZS5wc3R5bGUoJ2Fycm93LXNjYWxlJykudmFsdWU7XG4gICAgdmFyIHdpZHRoID0gc3R5bGVXaWR0aCAvIDIgKyBlZGdlVGhyZXNob2xkOyAvLyBtb3JlIGxpa2UgYSBkaXN0YW5jZSByYWRpdXMgZnJvbSBjZW50cmVcbiAgICB2YXIgd2lkdGhTcSA9IHdpZHRoICogd2lkdGg7XG4gICAgdmFyIHdpZHRoMiA9IHdpZHRoICogMjtcbiAgICB2YXIgc3JjID0gX3Auc291cmNlO1xuICAgIHZhciB0Z3QgPSBfcC50YXJnZXQ7XG4gICAgdmFyIHNxRGlzdDtcbiAgICBpZiAocnMuZWRnZVR5cGUgPT09ICdzZWdtZW50cycgfHwgcnMuZWRnZVR5cGUgPT09ICdzdHJhaWdodCcgfHwgcnMuZWRnZVR5cGUgPT09ICdoYXlzdGFjaycpIHtcbiAgICAgIHZhciBwdHMgPSBycy5hbGxwdHM7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSArIDMgPCBwdHMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgaWYgKGluTGluZVZpY2luaXR5KHgsIHksIHB0c1tpXSwgcHRzW2kgKyAxXSwgcHRzW2kgKyAyXSwgcHRzW2kgKyAzXSwgd2lkdGgyKSAmJiB3aWR0aFNxID4gKHNxRGlzdCA9IHNxZGlzdFRvRmluaXRlTGluZSh4LCB5LCBwdHNbaV0sIHB0c1tpICsgMV0sIHB0c1tpICsgMl0sIHB0c1tpICsgM10pKSkge1xuICAgICAgICAgIGFkZEVsZShlZGdlLCBzcURpc3QpO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChycy5lZGdlVHlwZSA9PT0gJ2JlemllcicgfHwgcnMuZWRnZVR5cGUgPT09ICdtdWx0aWJlemllcicgfHwgcnMuZWRnZVR5cGUgPT09ICdzZWxmJyB8fCBycy5lZGdlVHlwZSA9PT0gJ2NvbXBvdW5kJykge1xuICAgICAgdmFyIHB0cyA9IHJzLmFsbHB0cztcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpICsgNSA8IHJzLmFsbHB0cy5sZW5ndGg7IGkgKz0gNCkge1xuICAgICAgICBpZiAoaW5CZXppZXJWaWNpbml0eSh4LCB5LCBwdHNbaV0sIHB0c1tpICsgMV0sIHB0c1tpICsgMl0sIHB0c1tpICsgM10sIHB0c1tpICsgNF0sIHB0c1tpICsgNV0sIHdpZHRoMikgJiYgd2lkdGhTcSA+IChzcURpc3QgPSBzcWRpc3RUb1F1YWRyYXRpY0Jlemllcih4LCB5LCBwdHNbaV0sIHB0c1tpICsgMV0sIHB0c1tpICsgMl0sIHB0c1tpICsgM10sIHB0c1tpICsgNF0sIHB0c1tpICsgNV0pKSkge1xuICAgICAgICAgIGFkZEVsZShlZGdlLCBzcURpc3QpO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gaWYgd2UncmUgY2xvc2UgdG8gdGhlIGVkZ2UgYnV0IGRpZG4ndCBoaXQgaXQsIG1heWJlIHdlIGhpdCBpdHMgYXJyb3dzXG5cbiAgICB2YXIgc3JjID0gc3JjIHx8IF9wLnNvdXJjZTtcbiAgICB2YXIgdGd0ID0gdGd0IHx8IF9wLnRhcmdldDtcbiAgICB2YXIgYXJTaXplID0gc2VsZi5nZXRBcnJvd1dpZHRoKHN0eWxlV2lkdGgsIHNjYWxlKTtcbiAgICB2YXIgYXJyb3dzID0gW3tcbiAgICAgIG5hbWU6ICdzb3VyY2UnLFxuICAgICAgeDogcnMuYXJyb3dTdGFydFgsXG4gICAgICB5OiBycy5hcnJvd1N0YXJ0WSxcbiAgICAgIGFuZ2xlOiBycy5zcmNBcnJvd0FuZ2xlXG4gICAgfSwge1xuICAgICAgbmFtZTogJ3RhcmdldCcsXG4gICAgICB4OiBycy5hcnJvd0VuZFgsXG4gICAgICB5OiBycy5hcnJvd0VuZFksXG4gICAgICBhbmdsZTogcnMudGd0QXJyb3dBbmdsZVxuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdtaWQtc291cmNlJyxcbiAgICAgIHg6IHJzLm1pZFgsXG4gICAgICB5OiBycy5taWRZLFxuICAgICAgYW5nbGU6IHJzLm1pZHNyY0Fycm93QW5nbGVcbiAgICB9LCB7XG4gICAgICBuYW1lOiAnbWlkLXRhcmdldCcsXG4gICAgICB4OiBycy5taWRYLFxuICAgICAgeTogcnMubWlkWSxcbiAgICAgIGFuZ2xlOiBycy5taWR0Z3RBcnJvd0FuZ2xlXG4gICAgfV07XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJvd3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBhciA9IGFycm93c1tpXTtcbiAgICAgIHZhciBzaGFwZSA9IHIuYXJyb3dTaGFwZXNbZWRnZS5wc3R5bGUoYXIubmFtZSArICctYXJyb3ctc2hhcGUnKS52YWx1ZV07XG4gICAgICB2YXIgZWRnZVdpZHRoID0gZWRnZS5wc3R5bGUoJ3dpZHRoJykucGZWYWx1ZTtcbiAgICAgIGlmIChzaGFwZS5yb3VnaENvbGxpZGUoeCwgeSwgYXJTaXplLCBhci5hbmdsZSwge1xuICAgICAgICB4OiBhci54LFxuICAgICAgICB5OiBhci55XG4gICAgICB9LCBlZGdlV2lkdGgsIGVkZ2VUaHJlc2hvbGQpICYmIHNoYXBlLmNvbGxpZGUoeCwgeSwgYXJTaXplLCBhci5hbmdsZSwge1xuICAgICAgICB4OiBhci54LFxuICAgICAgICB5OiBhci55XG4gICAgICB9LCBlZGdlV2lkdGgsIGVkZ2VUaHJlc2hvbGQpKSB7XG4gICAgICAgIGFkZEVsZShlZGdlKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gZm9yIGNvbXBvdW5kIGdyYXBocywgaGl0dGluZyBlZGdlIG1heSBhY3R1YWxseSB3YW50IGEgY29ubmVjdGVkIG5vZGUgaW5zdGVhZCAoYi9jIGVkZ2UgbWF5IGhhdmUgZ3JlYXRlciB6LWluZGV4IHByZWNlZGVuY2UpXG4gICAgaWYgKGhhc0NvbXBvdW5kcyAmJiBuZWFyLmxlbmd0aCA+IDApIHtcbiAgICAgIGNoZWNrTm9kZShzcmMpO1xuICAgICAgY2hlY2tOb2RlKHRndCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHByZXByb3Aob2JqLCBuYW1lLCBwcmUpIHtcbiAgICByZXR1cm4gZ2V0UHJlZml4ZWRQcm9wZXJ0eShvYmosIG5hbWUsIHByZSk7XG4gIH1cbiAgZnVuY3Rpb24gY2hlY2tMYWJlbChlbGUsIHByZWZpeCkge1xuICAgIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgICB2YXIgdGggPSBsYWJlbFRocmVzaG9sZDtcbiAgICB2YXIgcHJlZml4RGFzaDtcbiAgICBpZiAocHJlZml4KSB7XG4gICAgICBwcmVmaXhEYXNoID0gcHJlZml4ICsgJy0nO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcmVmaXhEYXNoID0gJyc7XG4gICAgfVxuICAgIGVsZS5ib3VuZGluZ0JveCgpO1xuICAgIHZhciBiYiA9IF9wLmxhYmVsQm91bmRzW3ByZWZpeCB8fCAnbWFpbiddO1xuICAgIHZhciB0ZXh0ID0gZWxlLnBzdHlsZShwcmVmaXhEYXNoICsgJ2xhYmVsJykudmFsdWU7XG4gICAgdmFyIGV2ZW50c0VuYWJsZWQgPSBlbGUucHN0eWxlKCd0ZXh0LWV2ZW50cycpLnN0clZhbHVlID09PSAneWVzJztcbiAgICBpZiAoIWV2ZW50c0VuYWJsZWQgfHwgIXRleHQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGx4ID0gcHJlcHJvcChfcC5yc2NyYXRjaCwgJ2xhYmVsWCcsIHByZWZpeCk7XG4gICAgdmFyIGx5ID0gcHJlcHJvcChfcC5yc2NyYXRjaCwgJ2xhYmVsWScsIHByZWZpeCk7XG4gICAgdmFyIHRoZXRhID0gcHJlcHJvcChfcC5yc2NyYXRjaCwgJ2xhYmVsQW5nbGUnLCBwcmVmaXgpO1xuICAgIHZhciBveCA9IGVsZS5wc3R5bGUocHJlZml4RGFzaCArICd0ZXh0LW1hcmdpbi14JykucGZWYWx1ZTtcbiAgICB2YXIgb3kgPSBlbGUucHN0eWxlKHByZWZpeERhc2ggKyAndGV4dC1tYXJnaW4teScpLnBmVmFsdWU7XG4gICAgdmFyIGx4MSA9IGJiLngxIC0gdGggLSBveDsgLy8gKC1veCwgLW95KSBhcyBiYiBhbHJlYWR5IGluY2x1ZGVzIG1hcmdpblxuICAgIHZhciBseDIgPSBiYi54MiArIHRoIC0gb3g7IC8vIGFuZCByb3RhdGlvbiBpcyBhYm91dCAobHgsIGx5KVxuICAgIHZhciBseTEgPSBiYi55MSAtIHRoIC0gb3k7XG4gICAgdmFyIGx5MiA9IGJiLnkyICsgdGggLSBveTtcbiAgICBpZiAodGhldGEpIHtcbiAgICAgIHZhciBjb3MgPSBNYXRoLmNvcyh0aGV0YSk7XG4gICAgICB2YXIgc2luID0gTWF0aC5zaW4odGhldGEpO1xuICAgICAgdmFyIHJvdGF0ZSA9IGZ1bmN0aW9uIHJvdGF0ZSh4LCB5KSB7XG4gICAgICAgIHggPSB4IC0gbHg7XG4gICAgICAgIHkgPSB5IC0gbHk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgeDogeCAqIGNvcyAtIHkgKiBzaW4gKyBseCxcbiAgICAgICAgICB5OiB4ICogc2luICsgeSAqIGNvcyArIGx5XG4gICAgICAgIH07XG4gICAgICB9O1xuICAgICAgdmFyIHB4MXkxID0gcm90YXRlKGx4MSwgbHkxKTtcbiAgICAgIHZhciBweDF5MiA9IHJvdGF0ZShseDEsIGx5Mik7XG4gICAgICB2YXIgcHgyeTEgPSByb3RhdGUobHgyLCBseTEpO1xuICAgICAgdmFyIHB4MnkyID0gcm90YXRlKGx4MiwgbHkyKTtcbiAgICAgIHZhciBwb2ludHMgPSBbXG4gICAgICAvLyB3aXRoIHRoZSBtYXJnaW4gYWRkZWQgYWZ0ZXIgdGhlIHJvdGF0aW9uIGlzIGFwcGxpZWRcbiAgICAgIHB4MXkxLnggKyBveCwgcHgxeTEueSArIG95LCBweDJ5MS54ICsgb3gsIHB4MnkxLnkgKyBveSwgcHgyeTIueCArIG94LCBweDJ5Mi55ICsgb3ksIHB4MXkyLnggKyBveCwgcHgxeTIueSArIG95XTtcbiAgICAgIGlmIChwb2ludEluc2lkZVBvbHlnb25Qb2ludHMoeCwgeSwgcG9pbnRzKSkge1xuICAgICAgICBhZGRFbGUoZWxlKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGRvIGEgY2hlYXBlciBiYiBjaGVja1xuICAgICAgaWYgKGluQm91bmRpbmdCb3goYmIsIHgsIHkpKSB7XG4gICAgICAgIGFkZEVsZShlbGUpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZm9yICh2YXIgaSA9IGVsZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAvLyByZXZlcnNlIG9yZGVyIGZvciBwcmVjZWRlbmNlXG4gICAgdmFyIGVsZSA9IGVsZXNbaV07XG4gICAgaWYgKGVsZS5pc05vZGUoKSkge1xuICAgICAgY2hlY2tOb2RlKGVsZSkgfHwgY2hlY2tMYWJlbChlbGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB0aGVuIGVkZ2VcbiAgICAgIGNoZWNrRWRnZShlbGUpIHx8IGNoZWNrTGFiZWwoZWxlKSB8fCBjaGVja0xhYmVsKGVsZSwgJ3NvdXJjZScpIHx8IGNoZWNrTGFiZWwoZWxlLCAndGFyZ2V0Jyk7XG4gICAgfVxuICB9XG4gIHJldHVybiBuZWFyO1xufTtcblxuLy8gJ0dpdmUgbWUgZXZlcnl0aGluZyBmcm9tIHRoaXMgYm94J1xuQlJwJGUuZ2V0QWxsSW5Cb3ggPSBmdW5jdGlvbiAoeDEsIHkxLCB4MiwgeTIpIHtcbiAgdmFyIGVsZXMgPSB0aGlzLmdldENhY2hlZFpTb3J0ZWRFbGVzKCkuaW50ZXJhY3RpdmU7XG4gIHZhciBib3ggPSBbXTtcbiAgdmFyIHgxYyA9IE1hdGgubWluKHgxLCB4Mik7XG4gIHZhciB4MmMgPSBNYXRoLm1heCh4MSwgeDIpO1xuICB2YXIgeTFjID0gTWF0aC5taW4oeTEsIHkyKTtcbiAgdmFyIHkyYyA9IE1hdGgubWF4KHkxLCB5Mik7XG4gIHgxID0geDFjO1xuICB4MiA9IHgyYztcbiAgeTEgPSB5MWM7XG4gIHkyID0geTJjO1xuICB2YXIgYm94QmIgPSBtYWtlQm91bmRpbmdCb3goe1xuICAgIHgxOiB4MSxcbiAgICB5MTogeTEsXG4gICAgeDI6IHgyLFxuICAgIHkyOiB5MlxuICB9KTtcbiAgZm9yICh2YXIgZSA9IDA7IGUgPCBlbGVzLmxlbmd0aDsgZSsrKSB7XG4gICAgdmFyIGVsZSA9IGVsZXNbZV07XG4gICAgaWYgKGVsZS5pc05vZGUoKSkge1xuICAgICAgdmFyIG5vZGUgPSBlbGU7XG4gICAgICB2YXIgbm9kZUJiID0gbm9kZS5ib3VuZGluZ0JveCh7XG4gICAgICAgIGluY2x1ZGVOb2RlczogdHJ1ZSxcbiAgICAgICAgaW5jbHVkZUVkZ2VzOiBmYWxzZSxcbiAgICAgICAgaW5jbHVkZUxhYmVsczogZmFsc2VcbiAgICAgIH0pO1xuICAgICAgaWYgKGJvdW5kaW5nQm94ZXNJbnRlcnNlY3QoYm94QmIsIG5vZGVCYikgJiYgIWJvdW5kaW5nQm94SW5Cb3VuZGluZ0JveChub2RlQmIsIGJveEJiKSkge1xuICAgICAgICBib3gucHVzaChub2RlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGVkZ2UgPSBlbGU7XG4gICAgICB2YXIgX3AgPSBlZGdlLl9wcml2YXRlO1xuICAgICAgdmFyIHJzID0gX3AucnNjcmF0Y2g7XG4gICAgICBpZiAocnMuc3RhcnRYICE9IG51bGwgJiYgcnMuc3RhcnRZICE9IG51bGwgJiYgIWluQm91bmRpbmdCb3goYm94QmIsIHJzLnN0YXJ0WCwgcnMuc3RhcnRZKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChycy5lbmRYICE9IG51bGwgJiYgcnMuZW5kWSAhPSBudWxsICYmICFpbkJvdW5kaW5nQm94KGJveEJiLCBycy5lbmRYLCBycy5lbmRZKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChycy5lZGdlVHlwZSA9PT0gJ2JlemllcicgfHwgcnMuZWRnZVR5cGUgPT09ICdtdWx0aWJlemllcicgfHwgcnMuZWRnZVR5cGUgPT09ICdzZWxmJyB8fCBycy5lZGdlVHlwZSA9PT0gJ2NvbXBvdW5kJyB8fCBycy5lZGdlVHlwZSA9PT0gJ3NlZ21lbnRzJyB8fCBycy5lZGdlVHlwZSA9PT0gJ2hheXN0YWNrJykge1xuICAgICAgICB2YXIgcHRzID0gX3AucnN0eWxlLmJlemllclB0cyB8fCBfcC5yc3R5bGUubGluZVB0cyB8fCBfcC5yc3R5bGUuaGF5c3RhY2tQdHM7XG4gICAgICAgIHZhciBhbGxJbnNpZGUgPSB0cnVlO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHB0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmICghcG9pbnRJbkJvdW5kaW5nQm94KGJveEJiLCBwdHNbaV0pKSB7XG4gICAgICAgICAgICBhbGxJbnNpZGUgPSBmYWxzZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYWxsSW5zaWRlKSB7XG4gICAgICAgICAgYm94LnB1c2goZWRnZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAocnMuZWRnZVR5cGUgPT09ICdoYXlzdGFjaycgfHwgcnMuZWRnZVR5cGUgPT09ICdzdHJhaWdodCcpIHtcbiAgICAgICAgYm94LnB1c2goZWRnZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBib3g7XG59O1xuXG52YXIgQlJwJGQgPSB7fTtcbkJScCRkLmNhbGN1bGF0ZUFycm93QW5nbGVzID0gZnVuY3Rpb24gKGVkZ2UpIHtcbiAgdmFyIHJzID0gZWRnZS5fcHJpdmF0ZS5yc2NyYXRjaDtcbiAgdmFyIGlzSGF5c3RhY2sgPSBycy5lZGdlVHlwZSA9PT0gJ2hheXN0YWNrJztcbiAgdmFyIGlzQmV6aWVyID0gcnMuZWRnZVR5cGUgPT09ICdiZXppZXInO1xuICB2YXIgaXNNdWx0aWJlemllciA9IHJzLmVkZ2VUeXBlID09PSAnbXVsdGliZXppZXInO1xuICB2YXIgaXNTZWdtZW50cyA9IHJzLmVkZ2VUeXBlID09PSAnc2VnbWVudHMnO1xuICB2YXIgaXNDb21wb3VuZCA9IHJzLmVkZ2VUeXBlID09PSAnY29tcG91bmQnO1xuICB2YXIgaXNTZWxmID0gcnMuZWRnZVR5cGUgPT09ICdzZWxmJztcblxuICAvLyBEaXNwbGFjZW1lbnQgZ2l2ZXMgZGlyZWN0aW9uIGZvciBhcnJvd2hlYWQgb3JpZW50YXRpb25cbiAgdmFyIGRpc3BYLCBkaXNwWTtcbiAgdmFyIHN0YXJ0WCwgc3RhcnRZLCBlbmRYLCBlbmRZLCBtaWRYLCBtaWRZO1xuICBpZiAoaXNIYXlzdGFjaykge1xuICAgIHN0YXJ0WCA9IHJzLmhheXN0YWNrUHRzWzBdO1xuICAgIHN0YXJ0WSA9IHJzLmhheXN0YWNrUHRzWzFdO1xuICAgIGVuZFggPSBycy5oYXlzdGFja1B0c1syXTtcbiAgICBlbmRZID0gcnMuaGF5c3RhY2tQdHNbM107XG4gIH0gZWxzZSB7XG4gICAgc3RhcnRYID0gcnMuYXJyb3dTdGFydFg7XG4gICAgc3RhcnRZID0gcnMuYXJyb3dTdGFydFk7XG4gICAgZW5kWCA9IHJzLmFycm93RW5kWDtcbiAgICBlbmRZID0gcnMuYXJyb3dFbmRZO1xuICB9XG4gIG1pZFggPSBycy5taWRYO1xuICBtaWRZID0gcnMubWlkWTtcblxuICAvLyBzb3VyY2VcbiAgLy9cblxuICBpZiAoaXNTZWdtZW50cykge1xuICAgIGRpc3BYID0gc3RhcnRYIC0gcnMuc2VncHRzWzBdO1xuICAgIGRpc3BZID0gc3RhcnRZIC0gcnMuc2VncHRzWzFdO1xuICB9IGVsc2UgaWYgKGlzTXVsdGliZXppZXIgfHwgaXNDb21wb3VuZCB8fCBpc1NlbGYgfHwgaXNCZXppZXIpIHtcbiAgICB2YXIgcHRzID0gcnMuYWxscHRzO1xuICAgIHZhciBiWCA9IHFiZXppZXJBdChwdHNbMF0sIHB0c1syXSwgcHRzWzRdLCAwLjEpO1xuICAgIHZhciBiWSA9IHFiZXppZXJBdChwdHNbMV0sIHB0c1szXSwgcHRzWzVdLCAwLjEpO1xuICAgIGRpc3BYID0gc3RhcnRYIC0gYlg7XG4gICAgZGlzcFkgPSBzdGFydFkgLSBiWTtcbiAgfSBlbHNlIHtcbiAgICBkaXNwWCA9IHN0YXJ0WCAtIG1pZFg7XG4gICAgZGlzcFkgPSBzdGFydFkgLSBtaWRZO1xuICB9XG4gIHJzLnNyY0Fycm93QW5nbGUgPSBnZXRBbmdsZUZyb21EaXNwKGRpc3BYLCBkaXNwWSk7XG5cbiAgLy8gbWlkIHRhcmdldFxuICAvL1xuXG4gIHZhciBtaWRYID0gcnMubWlkWDtcbiAgdmFyIG1pZFkgPSBycy5taWRZO1xuICBpZiAoaXNIYXlzdGFjaykge1xuICAgIG1pZFggPSAoc3RhcnRYICsgZW5kWCkgLyAyO1xuICAgIG1pZFkgPSAoc3RhcnRZICsgZW5kWSkgLyAyO1xuICB9XG4gIGRpc3BYID0gZW5kWCAtIHN0YXJ0WDtcbiAgZGlzcFkgPSBlbmRZIC0gc3RhcnRZO1xuICBpZiAoaXNTZWdtZW50cykge1xuICAgIHZhciBwdHMgPSBycy5hbGxwdHM7XG4gICAgaWYgKHB0cy5sZW5ndGggLyAyICUgMiA9PT0gMCkge1xuICAgICAgdmFyIGkyID0gcHRzLmxlbmd0aCAvIDI7XG4gICAgICB2YXIgaTEgPSBpMiAtIDI7XG4gICAgICBkaXNwWCA9IHB0c1tpMl0gLSBwdHNbaTFdO1xuICAgICAgZGlzcFkgPSBwdHNbaTIgKyAxXSAtIHB0c1tpMSArIDFdO1xuICAgIH0gZWxzZSBpZiAocnMuaXNSb3VuZCkge1xuICAgICAgZGlzcFggPSBycy5taWRWZWN0b3JbMV07XG4gICAgICBkaXNwWSA9IC1ycy5taWRWZWN0b3JbMF07XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBpMiA9IHB0cy5sZW5ndGggLyAyIC0gMTtcbiAgICAgIHZhciBpMSA9IGkyIC0gMjtcbiAgICAgIGRpc3BYID0gcHRzW2kyXSAtIHB0c1tpMV07XG4gICAgICBkaXNwWSA9IHB0c1tpMiArIDFdIC0gcHRzW2kxICsgMV07XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzTXVsdGliZXppZXIgfHwgaXNDb21wb3VuZCB8fCBpc1NlbGYpIHtcbiAgICB2YXIgcHRzID0gcnMuYWxscHRzO1xuICAgIHZhciBjcHRzID0gcnMuY3RybHB0cztcbiAgICB2YXIgYnAweCwgYnAweTtcbiAgICB2YXIgYnAxeCwgYnAxeTtcbiAgICBpZiAoY3B0cy5sZW5ndGggLyAyICUgMiA9PT0gMCkge1xuICAgICAgdmFyIHAwID0gcHRzLmxlbmd0aCAvIDIgLSAxOyAvLyBzdGFydHB0XG4gICAgICB2YXIgaWMgPSBwMCArIDI7XG4gICAgICB2YXIgcDEgPSBpYyArIDI7XG4gICAgICBicDB4ID0gcWJlemllckF0KHB0c1twMF0sIHB0c1tpY10sIHB0c1twMV0sIDAuMCk7XG4gICAgICBicDB5ID0gcWJlemllckF0KHB0c1twMCArIDFdLCBwdHNbaWMgKyAxXSwgcHRzW3AxICsgMV0sIDAuMCk7XG4gICAgICBicDF4ID0gcWJlemllckF0KHB0c1twMF0sIHB0c1tpY10sIHB0c1twMV0sIDAuMDAwMSk7XG4gICAgICBicDF5ID0gcWJlemllckF0KHB0c1twMCArIDFdLCBwdHNbaWMgKyAxXSwgcHRzW3AxICsgMV0sIDAuMDAwMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBpYyA9IHB0cy5sZW5ndGggLyAyIC0gMTsgLy8gY3RycHRcbiAgICAgIHZhciBwMCA9IGljIC0gMjsgLy8gc3RhcnRwdFxuICAgICAgdmFyIHAxID0gaWMgKyAyOyAvLyBlbmRwdFxuXG4gICAgICBicDB4ID0gcWJlemllckF0KHB0c1twMF0sIHB0c1tpY10sIHB0c1twMV0sIDAuNDk5OSk7XG4gICAgICBicDB5ID0gcWJlemllckF0KHB0c1twMCArIDFdLCBwdHNbaWMgKyAxXSwgcHRzW3AxICsgMV0sIDAuNDk5OSk7XG4gICAgICBicDF4ID0gcWJlemllckF0KHB0c1twMF0sIHB0c1tpY10sIHB0c1twMV0sIDAuNSk7XG4gICAgICBicDF5ID0gcWJlemllckF0KHB0c1twMCArIDFdLCBwdHNbaWMgKyAxXSwgcHRzW3AxICsgMV0sIDAuNSk7XG4gICAgfVxuICAgIGRpc3BYID0gYnAxeCAtIGJwMHg7XG4gICAgZGlzcFkgPSBicDF5IC0gYnAweTtcbiAgfVxuICBycy5taWR0Z3RBcnJvd0FuZ2xlID0gZ2V0QW5nbGVGcm9tRGlzcChkaXNwWCwgZGlzcFkpO1xuICBycy5taWREaXNwWCA9IGRpc3BYO1xuICBycy5taWREaXNwWSA9IGRpc3BZO1xuXG4gIC8vIG1pZCBzb3VyY2VcbiAgLy9cblxuICBkaXNwWCAqPSAtMTtcbiAgZGlzcFkgKj0gLTE7XG4gIGlmIChpc1NlZ21lbnRzKSB7XG4gICAgdmFyIHB0cyA9IHJzLmFsbHB0cztcbiAgICBpZiAocHRzLmxlbmd0aCAvIDIgJSAyID09PSAwKSA7IGVsc2UgaWYgKCFycy5pc1JvdW5kKSB7XG4gICAgICB2YXIgaTIgPSBwdHMubGVuZ3RoIC8gMiAtIDE7XG4gICAgICB2YXIgaTMgPSBpMiArIDI7XG4gICAgICBkaXNwWCA9IC0ocHRzW2kzXSAtIHB0c1tpMl0pO1xuICAgICAgZGlzcFkgPSAtKHB0c1tpMyArIDFdIC0gcHRzW2kyICsgMV0pO1xuICAgIH1cbiAgfVxuICBycy5taWRzcmNBcnJvd0FuZ2xlID0gZ2V0QW5nbGVGcm9tRGlzcChkaXNwWCwgZGlzcFkpO1xuXG4gIC8vIHRhcmdldFxuICAvL1xuXG4gIGlmIChpc1NlZ21lbnRzKSB7XG4gICAgZGlzcFggPSBlbmRYIC0gcnMuc2VncHRzW3JzLnNlZ3B0cy5sZW5ndGggLSAyXTtcbiAgICBkaXNwWSA9IGVuZFkgLSBycy5zZWdwdHNbcnMuc2VncHRzLmxlbmd0aCAtIDFdO1xuICB9IGVsc2UgaWYgKGlzTXVsdGliZXppZXIgfHwgaXNDb21wb3VuZCB8fCBpc1NlbGYgfHwgaXNCZXppZXIpIHtcbiAgICB2YXIgcHRzID0gcnMuYWxscHRzO1xuICAgIHZhciBsID0gcHRzLmxlbmd0aDtcbiAgICB2YXIgYlggPSBxYmV6aWVyQXQocHRzW2wgLSA2XSwgcHRzW2wgLSA0XSwgcHRzW2wgLSAyXSwgMC45KTtcbiAgICB2YXIgYlkgPSBxYmV6aWVyQXQocHRzW2wgLSA1XSwgcHRzW2wgLSAzXSwgcHRzW2wgLSAxXSwgMC45KTtcbiAgICBkaXNwWCA9IGVuZFggLSBiWDtcbiAgICBkaXNwWSA9IGVuZFkgLSBiWTtcbiAgfSBlbHNlIHtcbiAgICBkaXNwWCA9IGVuZFggLSBtaWRYO1xuICAgIGRpc3BZID0gZW5kWSAtIG1pZFk7XG4gIH1cbiAgcnMudGd0QXJyb3dBbmdsZSA9IGdldEFuZ2xlRnJvbURpc3AoZGlzcFgsIGRpc3BZKTtcbn07XG5CUnAkZC5nZXRBcnJvd1dpZHRoID0gQlJwJGQuZ2V0QXJyb3dIZWlnaHQgPSBmdW5jdGlvbiAoZWRnZVdpZHRoLCBzY2FsZSkge1xuICB2YXIgY2FjaGUgPSB0aGlzLmFycm93V2lkdGhDYWNoZSA9IHRoaXMuYXJyb3dXaWR0aENhY2hlIHx8IHt9O1xuICB2YXIgY2FjaGVkVmFsID0gY2FjaGVbZWRnZVdpZHRoICsgJywgJyArIHNjYWxlXTtcbiAgaWYgKGNhY2hlZFZhbCkge1xuICAgIHJldHVybiBjYWNoZWRWYWw7XG4gIH1cbiAgY2FjaGVkVmFsID0gTWF0aC5tYXgoTWF0aC5wb3coZWRnZVdpZHRoICogMTMuMzcsIDAuOSksIDI5KSAqIHNjYWxlO1xuICBjYWNoZVtlZGdlV2lkdGggKyAnLCAnICsgc2NhbGVdID0gY2FjaGVkVmFsO1xuICByZXR1cm4gY2FjaGVkVmFsO1xufTtcblxuLyoqXG4gKiBFeHBsYWluZWQgYnkgQmxpbmRtYW42NyBhdCBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvNDQ4NTY5MjUvMTEwMjg4MjhcbiAqL1xuXG4vLyBEZWNsYXJlIHJldXNlZCB2YXJpYWJsZSB0byBhdm9pZCByZWFsbG9jYXRpbmcgdmFyaWFibGVzIGV2ZXJ5IHRpbWUgdGhlIGZ1bmN0aW9uIGlzIGNhbGxlZFxudmFyIHgsXG4gIHksXG4gIHYxID0ge30sXG4gIHYyID0ge30sXG4gIHNpbkEsXG4gIHNpbkE5MCxcbiAgcmFkRGlyZWN0aW9uLFxuICBkcmF3RGlyZWN0aW9uLFxuICBhbmdsZSxcbiAgaGFsZkFuZ2xlLFxuICBjUmFkaXVzLFxuICBsZW5PdXQsXG4gIHJhZGl1cyxcbiAgbGltaXQ7XG52YXIgc3RhcnRYLCBzdGFydFksIHN0b3BYLCBzdG9wWTtcbnZhciBsYXN0UG9pbnQ7XG5cbi8vIGNvbnZlcnQgMiBwb2ludHMgaW50byB2ZWN0b3IgZm9ybSwgcG9sYXIgZm9ybSwgYW5kIG5vcm1hbGlzZWRcbnZhciBhc1ZlYyA9IGZ1bmN0aW9uIGFzVmVjKHAsIHBwLCB2KSB7XG4gIHYueCA9IHBwLnggLSBwLng7XG4gIHYueSA9IHBwLnkgLSBwLnk7XG4gIHYubGVuID0gTWF0aC5zcXJ0KHYueCAqIHYueCArIHYueSAqIHYueSk7XG4gIHYubnggPSB2LnggLyB2LmxlbjtcbiAgdi5ueSA9IHYueSAvIHYubGVuO1xuICB2LmFuZyA9IE1hdGguYXRhbjIodi5ueSwgdi5ueCk7XG59O1xudmFyIGludmVydFZlYyA9IGZ1bmN0aW9uIGludmVydFZlYyhvcmlnaW5hbFYsIGludmVydGVkVikge1xuICBpbnZlcnRlZFYueCA9IG9yaWdpbmFsVi54ICogLTE7XG4gIGludmVydGVkVi55ID0gb3JpZ2luYWxWLnkgKiAtMTtcbiAgaW52ZXJ0ZWRWLm54ID0gb3JpZ2luYWxWLm54ICogLTE7XG4gIGludmVydGVkVi5ueSA9IG9yaWdpbmFsVi5ueSAqIC0xO1xuICBpbnZlcnRlZFYuYW5nID0gb3JpZ2luYWxWLmFuZyA+IDAgPyAtKE1hdGguUEkgLSBvcmlnaW5hbFYuYW5nKSA6IE1hdGguUEkgKyBvcmlnaW5hbFYuYW5nO1xufTtcbnZhciBjYWxjQ29ybmVyQXJjID0gZnVuY3Rpb24gY2FsY0Nvcm5lckFyYyhwcmV2aW91c1BvaW50LCBjdXJyZW50UG9pbnQsIG5leHRQb2ludCwgcmFkaXVzTWF4LCBpc0FyY1JhZGl1cykge1xuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIFBhcnQgMVxuICBwcmV2aW91c1BvaW50ICE9PSBsYXN0UG9pbnQgPyBhc1ZlYyhjdXJyZW50UG9pbnQsIHByZXZpb3VzUG9pbnQsIHYxKSA6IGludmVydFZlYyh2MiwgdjEpOyAvLyBBdm9pZCByZWNhbGN1bGF0aW5nIHZlYyBpZiBpdCBpcyB0aGUgaW52ZXJ0IG9mIHRoZSBsYXN0IG9uZSBjYWxjdWxhdGVkXG4gIGFzVmVjKGN1cnJlbnRQb2ludCwgbmV4dFBvaW50LCB2Mik7XG4gIHNpbkEgPSB2MS5ueCAqIHYyLm55IC0gdjEubnkgKiB2Mi5ueDtcbiAgc2luQTkwID0gdjEubnggKiB2Mi5ueCAtIHYxLm55ICogLXYyLm55O1xuICBhbmdsZSA9IE1hdGguYXNpbihNYXRoLm1heCgtMSwgTWF0aC5taW4oMSwgc2luQSkpKTtcbiAgaWYgKE1hdGguYWJzKGFuZ2xlKSA8IDFlLTYpIHtcbiAgICB4ID0gY3VycmVudFBvaW50Lng7XG4gICAgeSA9IGN1cnJlbnRQb2ludC55O1xuICAgIGNSYWRpdXMgPSByYWRpdXMgPSAwO1xuICAgIHJldHVybjtcbiAgfVxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIHJhZERpcmVjdGlvbiA9IDE7XG4gIGRyYXdEaXJlY3Rpb24gPSBmYWxzZTtcbiAgaWYgKHNpbkE5MCA8IDApIHtcbiAgICBpZiAoYW5nbGUgPCAwKSB7XG4gICAgICBhbmdsZSA9IE1hdGguUEkgKyBhbmdsZTtcbiAgICB9IGVsc2Uge1xuICAgICAgYW5nbGUgPSBNYXRoLlBJIC0gYW5nbGU7XG4gICAgICByYWREaXJlY3Rpb24gPSAtMTtcbiAgICAgIGRyYXdEaXJlY3Rpb24gPSB0cnVlO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoYW5nbGUgPiAwKSB7XG4gICAgICByYWREaXJlY3Rpb24gPSAtMTtcbiAgICAgIGRyYXdEaXJlY3Rpb24gPSB0cnVlO1xuICAgIH1cbiAgfVxuICBpZiAoY3VycmVudFBvaW50LnJhZGl1cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmFkaXVzID0gY3VycmVudFBvaW50LnJhZGl1cztcbiAgfSBlbHNlIHtcbiAgICByYWRpdXMgPSByYWRpdXNNYXg7XG4gIH1cbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyBQYXJ0IDJcbiAgaGFsZkFuZ2xlID0gYW5nbGUgLyAyO1xuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgbGltaXQgPSBNYXRoLm1pbih2MS5sZW4gLyAyLCB2Mi5sZW4gLyAyKTtcbiAgaWYgKGlzQXJjUmFkaXVzKSB7XG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIFBhcnQgM1xuICAgIGxlbk91dCA9IE1hdGguYWJzKE1hdGguY29zKGhhbGZBbmdsZSkgKiByYWRpdXMgLyBNYXRoLnNpbihoYWxmQW5nbGUpKTtcblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBTcGVjaWFsIHBhcnQgQVxuICAgIGlmIChsZW5PdXQgPiBsaW1pdCkge1xuICAgICAgbGVuT3V0ID0gbGltaXQ7XG4gICAgICBjUmFkaXVzID0gTWF0aC5hYnMobGVuT3V0ICogTWF0aC5zaW4oaGFsZkFuZ2xlKSAvIE1hdGguY29zKGhhbGZBbmdsZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjUmFkaXVzID0gcmFkaXVzO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBsZW5PdXQgPSBNYXRoLm1pbihsaW1pdCwgcmFkaXVzKTtcbiAgICBjUmFkaXVzID0gTWF0aC5hYnMobGVuT3V0ICogTWF0aC5zaW4oaGFsZkFuZ2xlKSAvIE1hdGguY29zKGhhbGZBbmdsZSkpO1xuICB9XG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIFBhcnQgNFxuICBzdG9wWCA9IGN1cnJlbnRQb2ludC54ICsgdjIubnggKiBsZW5PdXQ7XG4gIHN0b3BZID0gY3VycmVudFBvaW50LnkgKyB2Mi5ueSAqIGxlbk91dDtcbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyBQYXJ0IDVcbiAgeCA9IHN0b3BYIC0gdjIubnkgKiBjUmFkaXVzICogcmFkRGlyZWN0aW9uO1xuICB5ID0gc3RvcFkgKyB2Mi5ueCAqIGNSYWRpdXMgKiByYWREaXJlY3Rpb247XG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gQWRkaXRpb25hbCBQYXJ0IDogY2FsY3VsYXRlIHN0YXJ0IHBvaW50IEVcbiAgc3RhcnRYID0gY3VycmVudFBvaW50LnggKyB2MS5ueCAqIGxlbk91dDtcbiAgc3RhcnRZID0gY3VycmVudFBvaW50LnkgKyB2MS5ueSAqIGxlbk91dDtcblxuICAvLyBTYXZlIGxhc3QgcG9pbnQgdG8gYXZvaWQgcmVjYWxjdWxhdGluZyB2ZWN0b3Igd2hlbiBub3QgbmVlZGVkXG4gIGxhc3RQb2ludCA9IGN1cnJlbnRQb2ludDtcbn07XG5cbi8qKlxuICogRHJhdyBjb3JuZXIgcHJvdmlkZWQgYnkge0BsaW5rIGdldFJvdW5kQ29ybmVyfVxuICpcbiAqIEBwYXJhbSBjdHggOkNhbnZhc1JlbmRlcmluZ0NvbnRleHQyRFxuICogQHBhcmFtIHJvdW5kQ29ybmVyIHt7Y3g6bnVtYmVyLCBjeTpudW1iZXIsIHJhZGl1czpudW1iZXIsIGVuZEFuZ2xlOiBudW1iZXIsIHN0YXJ0QW5nbGU6IG51bWJlciwgY291bnRlckNsb2Nrd2lzZTogYm9vbGVhbn19XG4gKi9cbmZ1bmN0aW9uIGRyYXdQcmVwYXJlZFJvdW5kQ29ybmVyKGN0eCwgcm91bmRDb3JuZXIpIHtcbiAgaWYgKHJvdW5kQ29ybmVyLnJhZGl1cyA9PT0gMCkgY3R4LmxpbmVUbyhyb3VuZENvcm5lci5jeCwgcm91bmRDb3JuZXIuY3kpO2Vsc2UgY3R4LmFyYyhyb3VuZENvcm5lci5jeCwgcm91bmRDb3JuZXIuY3ksIHJvdW5kQ29ybmVyLnJhZGl1cywgcm91bmRDb3JuZXIuc3RhcnRBbmdsZSwgcm91bmRDb3JuZXIuZW5kQW5nbGUsIHJvdW5kQ29ybmVyLmNvdW50ZXJDbG9ja3dpc2UpO1xufVxuXG4vKipcbiAqIEdldCByb3VuZCBjb3JuZXIgZnJvbSBhIHBvaW50IGFuZCBpdHMgcHJldmlvdXMgYW5kIG5leHQgbmVpZ2hib3VycyBpbiBhIHBhdGhcbiAqXG4gKiBAcGFyYW0gcHJldmlvdXNQb2ludCB7e3g6IG51bWJlciwgeTpudW1iZXIsIHJhZGl1czogbnVtYmVyP319XG4gKiBAcGFyYW0gY3VycmVudFBvaW50IHt7eDogbnVtYmVyLCB5Om51bWJlciwgcmFkaXVzOiBudW1iZXI/fX1cbiAqIEBwYXJhbSBuZXh0UG9pbnQge3t4OiBudW1iZXIsIHk6bnVtYmVyLCByYWRpdXM6IG51bWJlcj99fVxuICogQHBhcmFtIHJhZGl1c01heCA6bnVtYmVyXG4gKiBAcGFyYW0gaXNBcmNSYWRpdXMgOmJvb2xlYW5cbiAqIEByZXR1cm4ge3tcbiAqIGN4Om51bWJlciwgY3k6bnVtYmVyLCByYWRpdXM6bnVtYmVyLFxuICogc3RhcnRYOm51bWJlciwgc3RhcnRZOm51bWJlcixcbiAqIHN0b3BYOm51bWJlciwgc3RvcFk6IG51bWJlcixcbiAqIGVuZEFuZ2xlOiBudW1iZXIsIHN0YXJ0QW5nbGU6IG51bWJlciwgY291bnRlckNsb2Nrd2lzZTogYm9vbGVhblxuICogfX1cbiAqL1xuZnVuY3Rpb24gZ2V0Um91bmRDb3JuZXIocHJldmlvdXNQb2ludCwgY3VycmVudFBvaW50LCBuZXh0UG9pbnQsIHJhZGl1c01heCkge1xuICB2YXIgaXNBcmNSYWRpdXMgPSBhcmd1bWVudHMubGVuZ3RoID4gNCAmJiBhcmd1bWVudHNbNF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s0XSA6IHRydWU7XG4gIGlmIChyYWRpdXNNYXggPT09IDAgfHwgY3VycmVudFBvaW50LnJhZGl1cyA9PT0gMCkgcmV0dXJuIHtcbiAgICBjeDogY3VycmVudFBvaW50LngsXG4gICAgY3k6IGN1cnJlbnRQb2ludC55LFxuICAgIHJhZGl1czogMCxcbiAgICBzdGFydFg6IGN1cnJlbnRQb2ludC54LFxuICAgIHN0YXJ0WTogY3VycmVudFBvaW50LnksXG4gICAgc3RvcFg6IGN1cnJlbnRQb2ludC54LFxuICAgIHN0b3BZOiBjdXJyZW50UG9pbnQueSxcbiAgICBzdGFydEFuZ2xlOiB1bmRlZmluZWQsXG4gICAgZW5kQW5nbGU6IHVuZGVmaW5lZCxcbiAgICBjb3VudGVyQ2xvY2t3aXNlOiB1bmRlZmluZWRcbiAgfTtcbiAgY2FsY0Nvcm5lckFyYyhwcmV2aW91c1BvaW50LCBjdXJyZW50UG9pbnQsIG5leHRQb2ludCwgcmFkaXVzTWF4LCBpc0FyY1JhZGl1cyk7XG4gIHJldHVybiB7XG4gICAgY3g6IHgsXG4gICAgY3k6IHksXG4gICAgcmFkaXVzOiBjUmFkaXVzLFxuICAgIHN0YXJ0WDogc3RhcnRYLFxuICAgIHN0YXJ0WTogc3RhcnRZLFxuICAgIHN0b3BYOiBzdG9wWCxcbiAgICBzdG9wWTogc3RvcFksXG4gICAgc3RhcnRBbmdsZTogdjEuYW5nICsgTWF0aC5QSSAvIDIgKiByYWREaXJlY3Rpb24sXG4gICAgZW5kQW5nbGU6IHYyLmFuZyAtIE1hdGguUEkgLyAyICogcmFkRGlyZWN0aW9uLFxuICAgIGNvdW50ZXJDbG9ja3dpc2U6IGRyYXdEaXJlY3Rpb25cbiAgfTtcbn1cblxudmFyIEJScCRjID0ge307XG5CUnAkYy5maW5kTWlkcHRQdHNFdGMgPSBmdW5jdGlvbiAoZWRnZSwgcGFpckluZm8pIHtcbiAgdmFyIHBvc1B0cyA9IHBhaXJJbmZvLnBvc1B0cyxcbiAgICBpbnRlcnNlY3Rpb25QdHMgPSBwYWlySW5mby5pbnRlcnNlY3Rpb25QdHMsXG4gICAgdmVjdG9yTm9ybUludmVyc2UgPSBwYWlySW5mby52ZWN0b3JOb3JtSW52ZXJzZTtcbiAgdmFyIG1pZHB0UHRzO1xuXG4gIC8vIG4uYi4gYXNzdW1lcyBhbGwgZWRnZXMgaW4gYmV6aWVyIGJ1bmRsZSBoYXZlIHNhbWUgZW5kcG9pbnRzIHNwZWNpZmllZFxuICB2YXIgc3JjTWFuRW5kcHQgPSBlZGdlLnBzdHlsZSgnc291cmNlLWVuZHBvaW50Jyk7XG4gIHZhciB0Z3RNYW5FbmRwdCA9IGVkZ2UucHN0eWxlKCd0YXJnZXQtZW5kcG9pbnQnKTtcbiAgdmFyIGhhdmVNYW51YWxFbmRQdHMgPSBzcmNNYW5FbmRwdC51bml0cyAhPSBudWxsICYmIHRndE1hbkVuZHB0LnVuaXRzICE9IG51bGw7XG4gIHZhciByZWNhbGNWZWN0b3JOb3JtSW52ZXJzZSA9IGZ1bmN0aW9uIHJlY2FsY1ZlY3Rvck5vcm1JbnZlcnNlKHgxLCB5MSwgeDIsIHkyKSB7XG4gICAgdmFyIGR5ID0geTIgLSB5MTtcbiAgICB2YXIgZHggPSB4MiAtIHgxO1xuICAgIHZhciBsID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcbiAgICByZXR1cm4ge1xuICAgICAgeDogLWR5IC8gbCxcbiAgICAgIHk6IGR4IC8gbFxuICAgIH07XG4gIH07XG4gIHZhciBlZGdlRGlzdGFuY2VzID0gZWRnZS5wc3R5bGUoJ2VkZ2UtZGlzdGFuY2VzJykudmFsdWU7XG4gIHN3aXRjaCAoZWRnZURpc3RhbmNlcykge1xuICAgIGNhc2UgJ25vZGUtcG9zaXRpb24nOlxuICAgICAgbWlkcHRQdHMgPSBwb3NQdHM7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdpbnRlcnNlY3Rpb24nOlxuICAgICAgbWlkcHRQdHMgPSBpbnRlcnNlY3Rpb25QdHM7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdlbmRwb2ludHMnOlxuICAgICAge1xuICAgICAgICBpZiAoaGF2ZU1hbnVhbEVuZFB0cykge1xuICAgICAgICAgIHZhciBfdGhpcyRtYW51YWxFbmRwdFRvUHggPSB0aGlzLm1hbnVhbEVuZHB0VG9QeChlZGdlLnNvdXJjZSgpWzBdLCBzcmNNYW5FbmRwdCksXG4gICAgICAgICAgICBfdGhpcyRtYW51YWxFbmRwdFRvUHgyID0gX3NsaWNlZFRvQXJyYXkoX3RoaXMkbWFudWFsRW5kcHRUb1B4LCAyKSxcbiAgICAgICAgICAgIHgxID0gX3RoaXMkbWFudWFsRW5kcHRUb1B4MlswXSxcbiAgICAgICAgICAgIHkxID0gX3RoaXMkbWFudWFsRW5kcHRUb1B4MlsxXTtcbiAgICAgICAgICB2YXIgX3RoaXMkbWFudWFsRW5kcHRUb1B4MyA9IHRoaXMubWFudWFsRW5kcHRUb1B4KGVkZ2UudGFyZ2V0KClbMF0sIHRndE1hbkVuZHB0KSxcbiAgICAgICAgICAgIF90aGlzJG1hbnVhbEVuZHB0VG9QeDQgPSBfc2xpY2VkVG9BcnJheShfdGhpcyRtYW51YWxFbmRwdFRvUHgzLCAyKSxcbiAgICAgICAgICAgIHgyID0gX3RoaXMkbWFudWFsRW5kcHRUb1B4NFswXSxcbiAgICAgICAgICAgIHkyID0gX3RoaXMkbWFudWFsRW5kcHRUb1B4NFsxXTtcbiAgICAgICAgICB2YXIgZW5kUHRzID0ge1xuICAgICAgICAgICAgeDE6IHgxLFxuICAgICAgICAgICAgeTE6IHkxLFxuICAgICAgICAgICAgeDI6IHgyLFxuICAgICAgICAgICAgeTI6IHkyXG4gICAgICAgICAgfTtcbiAgICAgICAgICB2ZWN0b3JOb3JtSW52ZXJzZSA9IHJlY2FsY1ZlY3Rvck5vcm1JbnZlcnNlKHgxLCB5MSwgeDIsIHkyKTtcbiAgICAgICAgICBtaWRwdFB0cyA9IGVuZFB0cztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3YXJuKFwiRWRnZSBcIi5jb25jYXQoZWRnZS5pZCgpLCBcIiBoYXMgZWRnZS1kaXN0YW5jZXM6ZW5kcG9pbnRzIHNwZWNpZmllZCB3aXRob3V0IG1hbnVhbCBlbmRwb2ludHMgc3BlY2lmaWVkIHZpYSBzb3VyY2UtZW5kcG9pbnQgYW5kIHRhcmdldC1lbmRwb2ludC4gIEZhbGxpbmcgYmFjayBvbiBlZGdlLWRpc3RhbmNlczppbnRlcnNlY3Rpb24gKGRlZmF1bHQpLlwiKSk7XG4gICAgICAgICAgbWlkcHRQdHMgPSBpbnRlcnNlY3Rpb25QdHM7IC8vIGJhY2sgdG8gZGVmYXVsdFxuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBtaWRwdFB0czogbWlkcHRQdHMsXG4gICAgdmVjdG9yTm9ybUludmVyc2U6IHZlY3Rvck5vcm1JbnZlcnNlXG4gIH07XG59O1xuQlJwJGMuZmluZEhheXN0YWNrUG9pbnRzID0gZnVuY3Rpb24gKGVkZ2VzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZWRnZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZWRnZSA9IGVkZ2VzW2ldO1xuICAgIHZhciBfcCA9IGVkZ2UuX3ByaXZhdGU7XG4gICAgdmFyIHJzID0gX3AucnNjcmF0Y2g7XG4gICAgaWYgKCFycy5oYXlzdGFjaykge1xuICAgICAgdmFyIGFuZ2xlID0gTWF0aC5yYW5kb20oKSAqIDIgKiBNYXRoLlBJO1xuICAgICAgcnMuc291cmNlID0ge1xuICAgICAgICB4OiBNYXRoLmNvcyhhbmdsZSksXG4gICAgICAgIHk6IE1hdGguc2luKGFuZ2xlKVxuICAgICAgfTtcbiAgICAgIGFuZ2xlID0gTWF0aC5yYW5kb20oKSAqIDIgKiBNYXRoLlBJO1xuICAgICAgcnMudGFyZ2V0ID0ge1xuICAgICAgICB4OiBNYXRoLmNvcyhhbmdsZSksXG4gICAgICAgIHk6IE1hdGguc2luKGFuZ2xlKVxuICAgICAgfTtcbiAgICB9XG4gICAgdmFyIHNyYyA9IF9wLnNvdXJjZTtcbiAgICB2YXIgdGd0ID0gX3AudGFyZ2V0O1xuICAgIHZhciBzcmNQb3MgPSBzcmMucG9zaXRpb24oKTtcbiAgICB2YXIgdGd0UG9zID0gdGd0LnBvc2l0aW9uKCk7XG4gICAgdmFyIHNyY1cgPSBzcmMud2lkdGgoKTtcbiAgICB2YXIgdGd0VyA9IHRndC53aWR0aCgpO1xuICAgIHZhciBzcmNIID0gc3JjLmhlaWdodCgpO1xuICAgIHZhciB0Z3RIID0gdGd0LmhlaWdodCgpO1xuICAgIHZhciByYWRpdXMgPSBlZGdlLnBzdHlsZSgnaGF5c3RhY2stcmFkaXVzJykudmFsdWU7XG4gICAgdmFyIGhhbGZSYWRpdXMgPSByYWRpdXMgLyAyOyAvLyBiL2MgaGF2ZSB0byBoYWxmIHdpZHRoL2hlaWdodFxuXG4gICAgcnMuaGF5c3RhY2tQdHMgPSBycy5hbGxwdHMgPSBbcnMuc291cmNlLnggKiBzcmNXICogaGFsZlJhZGl1cyArIHNyY1Bvcy54LCBycy5zb3VyY2UueSAqIHNyY0ggKiBoYWxmUmFkaXVzICsgc3JjUG9zLnksIHJzLnRhcmdldC54ICogdGd0VyAqIGhhbGZSYWRpdXMgKyB0Z3RQb3MueCwgcnMudGFyZ2V0LnkgKiB0Z3RIICogaGFsZlJhZGl1cyArIHRndFBvcy55XTtcbiAgICBycy5taWRYID0gKHJzLmFsbHB0c1swXSArIHJzLmFsbHB0c1syXSkgLyAyO1xuICAgIHJzLm1pZFkgPSAocnMuYWxscHRzWzFdICsgcnMuYWxscHRzWzNdKSAvIDI7XG5cbiAgICAvLyBhbHdheXMgb3ZlcnJpZGUgYXMgaGF5c3RhY2sgaW4gY2FzZSBzZXQgdG8gZGlmZmVyZW50IHR5cGUgcHJldmlvdXNseVxuICAgIHJzLmVkZ2VUeXBlID0gJ2hheXN0YWNrJztcbiAgICBycy5oYXlzdGFjayA9IHRydWU7XG4gICAgdGhpcy5zdG9yZUVkZ2VQcm9qZWN0aW9ucyhlZGdlKTtcbiAgICB0aGlzLmNhbGN1bGF0ZUFycm93QW5nbGVzKGVkZ2UpO1xuICAgIHRoaXMucmVjYWxjdWxhdGVFZGdlTGFiZWxQcm9qZWN0aW9ucyhlZGdlKTtcbiAgICB0aGlzLmNhbGN1bGF0ZUxhYmVsQW5nbGVzKGVkZ2UpO1xuICB9XG59O1xuQlJwJGMuZmluZFNlZ21lbnRzUG9pbnRzID0gZnVuY3Rpb24gKGVkZ2UsIHBhaXJJbmZvKSB7XG4gIC8vIFNlZ21lbnRzIChtdWx0aXBsZSBzdHJhaWdodCBsaW5lcylcblxuICB2YXIgcnMgPSBlZGdlLl9wcml2YXRlLnJzY3JhdGNoO1xuICB2YXIgc2VnbWVudFdzID0gZWRnZS5wc3R5bGUoJ3NlZ21lbnQtd2VpZ2h0cycpO1xuICB2YXIgc2VnbWVudERzID0gZWRnZS5wc3R5bGUoJ3NlZ21lbnQtZGlzdGFuY2VzJyk7XG4gIHZhciBzZWdtZW50UnMgPSBlZGdlLnBzdHlsZSgnc2VnbWVudC1yYWRpaScpO1xuICB2YXIgc2VnbWVudFRzID0gZWRnZS5wc3R5bGUoJ3JhZGl1cy10eXBlJyk7XG4gIHZhciBzZWdtZW50c04gPSBNYXRoLm1pbihzZWdtZW50V3MucGZWYWx1ZS5sZW5ndGgsIHNlZ21lbnREcy5wZlZhbHVlLmxlbmd0aCk7XG4gIHZhciBsYXN0UmFkaXVzID0gc2VnbWVudFJzLnBmVmFsdWVbc2VnbWVudFJzLnBmVmFsdWUubGVuZ3RoIC0gMV07XG4gIHZhciBsYXN0UmFkaXVzVHlwZSA9IHNlZ21lbnRUcy5wZlZhbHVlW3NlZ21lbnRUcy5wZlZhbHVlLmxlbmd0aCAtIDFdO1xuICBycy5lZGdlVHlwZSA9ICdzZWdtZW50cyc7XG4gIHJzLnNlZ3B0cyA9IFtdO1xuICBycy5yYWRpaSA9IFtdO1xuICBycy5pc0FyY1JhZGl1cyA9IFtdO1xuICBmb3IgKHZhciBzID0gMDsgcyA8IHNlZ21lbnRzTjsgcysrKSB7XG4gICAgdmFyIHcgPSBzZWdtZW50V3MucGZWYWx1ZVtzXTtcbiAgICB2YXIgZCA9IHNlZ21lbnREcy5wZlZhbHVlW3NdO1xuICAgIHZhciB3MSA9IDEgLSB3O1xuICAgIHZhciB3MiA9IHc7XG4gICAgdmFyIF90aGlzJGZpbmRNaWRwdFB0c0V0YyA9IHRoaXMuZmluZE1pZHB0UHRzRXRjKGVkZ2UsIHBhaXJJbmZvKSxcbiAgICAgIG1pZHB0UHRzID0gX3RoaXMkZmluZE1pZHB0UHRzRXRjLm1pZHB0UHRzLFxuICAgICAgdmVjdG9yTm9ybUludmVyc2UgPSBfdGhpcyRmaW5kTWlkcHRQdHNFdGMudmVjdG9yTm9ybUludmVyc2U7XG4gICAgdmFyIGFkanVzdGVkTWlkcHQgPSB7XG4gICAgICB4OiBtaWRwdFB0cy54MSAqIHcxICsgbWlkcHRQdHMueDIgKiB3MixcbiAgICAgIHk6IG1pZHB0UHRzLnkxICogdzEgKyBtaWRwdFB0cy55MiAqIHcyXG4gICAgfTtcbiAgICBycy5zZWdwdHMucHVzaChhZGp1c3RlZE1pZHB0LnggKyB2ZWN0b3JOb3JtSW52ZXJzZS54ICogZCwgYWRqdXN0ZWRNaWRwdC55ICsgdmVjdG9yTm9ybUludmVyc2UueSAqIGQpO1xuICAgIHJzLnJhZGlpLnB1c2goc2VnbWVudFJzLnBmVmFsdWVbc10gIT09IHVuZGVmaW5lZCA/IHNlZ21lbnRScy5wZlZhbHVlW3NdIDogbGFzdFJhZGl1cyk7XG4gICAgcnMuaXNBcmNSYWRpdXMucHVzaCgoc2VnbWVudFRzLnBmVmFsdWVbc10gIT09IHVuZGVmaW5lZCA/IHNlZ21lbnRUcy5wZlZhbHVlW3NdIDogbGFzdFJhZGl1c1R5cGUpID09PSAnYXJjLXJhZGl1cycpO1xuICB9XG59O1xuQlJwJGMuZmluZExvb3BQb2ludHMgPSBmdW5jdGlvbiAoZWRnZSwgcGFpckluZm8sIGksIGVkZ2VJc1VuYnVuZGxlZCkge1xuICAvLyBTZWxmLWVkZ2VcblxuICB2YXIgcnMgPSBlZGdlLl9wcml2YXRlLnJzY3JhdGNoO1xuICB2YXIgZGlyQ291bnRzID0gcGFpckluZm8uZGlyQ291bnRzLFxuICAgIHNyY1BvcyA9IHBhaXJJbmZvLnNyY1BvcztcbiAgdmFyIGN0cmxwdERpc3RzID0gZWRnZS5wc3R5bGUoJ2NvbnRyb2wtcG9pbnQtZGlzdGFuY2VzJyk7XG4gIHZhciBjdHJscHREaXN0ID0gY3RybHB0RGlzdHMgPyBjdHJscHREaXN0cy5wZlZhbHVlWzBdIDogdW5kZWZpbmVkO1xuICB2YXIgbG9vcERpciA9IGVkZ2UucHN0eWxlKCdsb29wLWRpcmVjdGlvbicpLnBmVmFsdWU7XG4gIHZhciBsb29wU3dwID0gZWRnZS5wc3R5bGUoJ2xvb3Atc3dlZXAnKS5wZlZhbHVlO1xuICB2YXIgc3RlcFNpemUgPSBlZGdlLnBzdHlsZSgnY29udHJvbC1wb2ludC1zdGVwLXNpemUnKS5wZlZhbHVlO1xuICBycy5lZGdlVHlwZSA9ICdzZWxmJztcbiAgdmFyIGogPSBpO1xuICB2YXIgbG9vcERpc3QgPSBzdGVwU2l6ZTtcbiAgaWYgKGVkZ2VJc1VuYnVuZGxlZCkge1xuICAgIGogPSAwO1xuICAgIGxvb3BEaXN0ID0gY3RybHB0RGlzdDtcbiAgfVxuICB2YXIgbG9vcEFuZ2xlID0gbG9vcERpciAtIE1hdGguUEkgLyAyO1xuICB2YXIgb3V0QW5nbGUgPSBsb29wQW5nbGUgLSBsb29wU3dwIC8gMjtcbiAgdmFyIGluQW5nbGUgPSBsb29wQW5nbGUgKyBsb29wU3dwIC8gMjtcblxuICAvLyBpbmNyZWFzZSBieSBzdGVwIHNpemUgZm9yIG92ZXJsYXBwaW5nIGxvb3BzLCBrZXllZCBvbiBkaXJlY3Rpb24gYW5kIHN3ZWVwIHZhbHVlc1xuICB2YXIgZGMgPSBTdHJpbmcobG9vcERpciArICdfJyArIGxvb3BTd3ApO1xuICBqID0gZGlyQ291bnRzW2RjXSA9PT0gdW5kZWZpbmVkID8gZGlyQ291bnRzW2RjXSA9IDAgOiArK2RpckNvdW50c1tkY107XG4gIHJzLmN0cmxwdHMgPSBbc3JjUG9zLnggKyBNYXRoLmNvcyhvdXRBbmdsZSkgKiAxLjQgKiBsb29wRGlzdCAqIChqIC8gMyArIDEpLCBzcmNQb3MueSArIE1hdGguc2luKG91dEFuZ2xlKSAqIDEuNCAqIGxvb3BEaXN0ICogKGogLyAzICsgMSksIHNyY1Bvcy54ICsgTWF0aC5jb3MoaW5BbmdsZSkgKiAxLjQgKiBsb29wRGlzdCAqIChqIC8gMyArIDEpLCBzcmNQb3MueSArIE1hdGguc2luKGluQW5nbGUpICogMS40ICogbG9vcERpc3QgKiAoaiAvIDMgKyAxKV07XG59O1xuQlJwJGMuZmluZENvbXBvdW5kTG9vcFBvaW50cyA9IGZ1bmN0aW9uIChlZGdlLCBwYWlySW5mbywgaSwgZWRnZUlzVW5idW5kbGVkKSB7XG4gIC8vIENvbXBvdW5kIGVkZ2VcblxuICB2YXIgcnMgPSBlZGdlLl9wcml2YXRlLnJzY3JhdGNoO1xuICBycy5lZGdlVHlwZSA9ICdjb21wb3VuZCc7XG4gIHZhciBzcmNQb3MgPSBwYWlySW5mby5zcmNQb3MsXG4gICAgdGd0UG9zID0gcGFpckluZm8udGd0UG9zLFxuICAgIHNyY1cgPSBwYWlySW5mby5zcmNXLFxuICAgIHNyY0ggPSBwYWlySW5mby5zcmNILFxuICAgIHRndFcgPSBwYWlySW5mby50Z3RXLFxuICAgIHRndEggPSBwYWlySW5mby50Z3RIO1xuICB2YXIgc3RlcFNpemUgPSBlZGdlLnBzdHlsZSgnY29udHJvbC1wb2ludC1zdGVwLXNpemUnKS5wZlZhbHVlO1xuICB2YXIgY3RybHB0RGlzdHMgPSBlZGdlLnBzdHlsZSgnY29udHJvbC1wb2ludC1kaXN0YW5jZXMnKTtcbiAgdmFyIGN0cmxwdERpc3QgPSBjdHJscHREaXN0cyA/IGN0cmxwdERpc3RzLnBmVmFsdWVbMF0gOiB1bmRlZmluZWQ7XG4gIHZhciBqID0gaTtcbiAgdmFyIGxvb3BEaXN0ID0gc3RlcFNpemU7XG4gIGlmIChlZGdlSXNVbmJ1bmRsZWQpIHtcbiAgICBqID0gMDtcbiAgICBsb29wRGlzdCA9IGN0cmxwdERpc3Q7XG4gIH1cbiAgdmFyIGxvb3BXID0gNTA7XG4gIHZhciBsb29wYVBvcyA9IHtcbiAgICB4OiBzcmNQb3MueCAtIHNyY1cgLyAyLFxuICAgIHk6IHNyY1Bvcy55IC0gc3JjSCAvIDJcbiAgfTtcbiAgdmFyIGxvb3BiUG9zID0ge1xuICAgIHg6IHRndFBvcy54IC0gdGd0VyAvIDIsXG4gICAgeTogdGd0UG9zLnkgLSB0Z3RIIC8gMlxuICB9O1xuICB2YXIgbG9vcFBvcyA9IHtcbiAgICB4OiBNYXRoLm1pbihsb29wYVBvcy54LCBsb29wYlBvcy54KSxcbiAgICB5OiBNYXRoLm1pbihsb29wYVBvcy55LCBsb29wYlBvcy55KVxuICB9O1xuXG4gIC8vIGF2b2lkcyBjYXNlcyB3aXRoIGltcG9zc2libGUgYmV6aWVyc1xuICB2YXIgbWluQ29tcG91bmRTdHJldGNoID0gMC41O1xuICB2YXIgY29tcG91bmRTdHJldGNoQSA9IE1hdGgubWF4KG1pbkNvbXBvdW5kU3RyZXRjaCwgTWF0aC5sb2coc3JjVyAqIDAuMDEpKTtcbiAgdmFyIGNvbXBvdW5kU3RyZXRjaEIgPSBNYXRoLm1heChtaW5Db21wb3VuZFN0cmV0Y2gsIE1hdGgubG9nKHRndFcgKiAwLjAxKSk7XG4gIHJzLmN0cmxwdHMgPSBbbG9vcFBvcy54LCBsb29wUG9zLnkgLSAoMSArIE1hdGgucG93KGxvb3BXLCAxLjEyKSAvIDEwMCkgKiBsb29wRGlzdCAqIChqIC8gMyArIDEpICogY29tcG91bmRTdHJldGNoQSwgbG9vcFBvcy54IC0gKDEgKyBNYXRoLnBvdyhsb29wVywgMS4xMikgLyAxMDApICogbG9vcERpc3QgKiAoaiAvIDMgKyAxKSAqIGNvbXBvdW5kU3RyZXRjaEIsIGxvb3BQb3MueV07XG59O1xuQlJwJGMuZmluZFN0cmFpZ2h0RWRnZVBvaW50cyA9IGZ1bmN0aW9uIChlZGdlKSB7XG4gIC8vIFN0cmFpZ2h0IGVkZ2Ugd2l0aGluIGJ1bmRsZVxuXG4gIGVkZ2UuX3ByaXZhdGUucnNjcmF0Y2guZWRnZVR5cGUgPSAnc3RyYWlnaHQnO1xufTtcbkJScCRjLmZpbmRCZXppZXJQb2ludHMgPSBmdW5jdGlvbiAoZWRnZSwgcGFpckluZm8sIGksIGVkZ2VJc1VuYnVuZGxlZCwgZWRnZUlzU3dhcHBlZCkge1xuICB2YXIgcnMgPSBlZGdlLl9wcml2YXRlLnJzY3JhdGNoO1xuICB2YXIgc3RlcFNpemUgPSBlZGdlLnBzdHlsZSgnY29udHJvbC1wb2ludC1zdGVwLXNpemUnKS5wZlZhbHVlO1xuICB2YXIgY3RybHB0RGlzdHMgPSBlZGdlLnBzdHlsZSgnY29udHJvbC1wb2ludC1kaXN0YW5jZXMnKTtcbiAgdmFyIGN0cmxwdFdzID0gZWRnZS5wc3R5bGUoJ2NvbnRyb2wtcG9pbnQtd2VpZ2h0cycpO1xuICB2YXIgYmV6aWVyTiA9IGN0cmxwdERpc3RzICYmIGN0cmxwdFdzID8gTWF0aC5taW4oY3RybHB0RGlzdHMudmFsdWUubGVuZ3RoLCBjdHJscHRXcy52YWx1ZS5sZW5ndGgpIDogMTtcbiAgdmFyIGN0cmxwdERpc3QgPSBjdHJscHREaXN0cyA/IGN0cmxwdERpc3RzLnBmVmFsdWVbMF0gOiB1bmRlZmluZWQ7XG4gIHZhciBjdHJscHRXZWlnaHQgPSBjdHJscHRXcy52YWx1ZVswXTtcblxuICAvLyAoTXVsdGkpYmV6aWVyXG5cbiAgdmFyIG11bHRpID0gZWRnZUlzVW5idW5kbGVkO1xuICBycy5lZGdlVHlwZSA9IG11bHRpID8gJ211bHRpYmV6aWVyJyA6ICdiZXppZXInO1xuICBycy5jdHJscHRzID0gW107XG4gIGZvciAodmFyIGIgPSAwOyBiIDwgYmV6aWVyTjsgYisrKSB7XG4gICAgdmFyIG5vcm1jdHJscHREaXN0ID0gKDAuNSAtIHBhaXJJbmZvLmVsZXMubGVuZ3RoIC8gMiArIGkpICogc3RlcFNpemUgKiAoZWRnZUlzU3dhcHBlZCA/IC0xIDogMSk7XG4gICAgdmFyIG1hbmN0cmxwdERpc3QgPSB2b2lkIDA7XG4gICAgdmFyIHNpZ24gPSBzaWdudW0obm9ybWN0cmxwdERpc3QpO1xuICAgIGlmIChtdWx0aSkge1xuICAgICAgY3RybHB0RGlzdCA9IGN0cmxwdERpc3RzID8gY3RybHB0RGlzdHMucGZWYWx1ZVtiXSA6IHN0ZXBTaXplOyAvLyBmYWxsIGJhY2sgb24gc3RlcCBzaXplXG4gICAgICBjdHJscHRXZWlnaHQgPSBjdHJscHRXcy52YWx1ZVtiXTtcbiAgICB9XG4gICAgaWYgKGVkZ2VJc1VuYnVuZGxlZCkge1xuICAgICAgLy8gbXVsdGkgb3Igc2luZ2xlIHVuYnVuZGxlZFxuICAgICAgbWFuY3RybHB0RGlzdCA9IGN0cmxwdERpc3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1hbmN0cmxwdERpc3QgPSBjdHJscHREaXN0ICE9PSB1bmRlZmluZWQgPyBzaWduICogY3RybHB0RGlzdCA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgdmFyIGRpc3RhbmNlRnJvbU1pZHBvaW50ID0gbWFuY3RybHB0RGlzdCAhPT0gdW5kZWZpbmVkID8gbWFuY3RybHB0RGlzdCA6IG5vcm1jdHJscHREaXN0O1xuICAgIHZhciB3MSA9IDEgLSBjdHJscHRXZWlnaHQ7XG4gICAgdmFyIHcyID0gY3RybHB0V2VpZ2h0O1xuICAgIHZhciBfdGhpcyRmaW5kTWlkcHRQdHNFdGMyID0gdGhpcy5maW5kTWlkcHRQdHNFdGMoZWRnZSwgcGFpckluZm8pLFxuICAgICAgbWlkcHRQdHMgPSBfdGhpcyRmaW5kTWlkcHRQdHNFdGMyLm1pZHB0UHRzLFxuICAgICAgdmVjdG9yTm9ybUludmVyc2UgPSBfdGhpcyRmaW5kTWlkcHRQdHNFdGMyLnZlY3Rvck5vcm1JbnZlcnNlO1xuICAgIHZhciBhZGp1c3RlZE1pZHB0ID0ge1xuICAgICAgeDogbWlkcHRQdHMueDEgKiB3MSArIG1pZHB0UHRzLngyICogdzIsXG4gICAgICB5OiBtaWRwdFB0cy55MSAqIHcxICsgbWlkcHRQdHMueTIgKiB3MlxuICAgIH07XG4gICAgcnMuY3RybHB0cy5wdXNoKGFkanVzdGVkTWlkcHQueCArIHZlY3Rvck5vcm1JbnZlcnNlLnggKiBkaXN0YW5jZUZyb21NaWRwb2ludCwgYWRqdXN0ZWRNaWRwdC55ICsgdmVjdG9yTm9ybUludmVyc2UueSAqIGRpc3RhbmNlRnJvbU1pZHBvaW50KTtcbiAgfVxufTtcbkJScCRjLmZpbmRUYXhpUG9pbnRzID0gZnVuY3Rpb24gKGVkZ2UsIHBhaXJJbmZvKSB7XG4gIC8vIFRheGljYWIgZ2VvbWV0cnkgd2l0aCB0d28gdHVybnMgbWF4aW11bVxuXG4gIHZhciBycyA9IGVkZ2UuX3ByaXZhdGUucnNjcmF0Y2g7XG4gIHJzLmVkZ2VUeXBlID0gJ3NlZ21lbnRzJztcbiAgdmFyIFZFUlRJQ0FMID0gJ3ZlcnRpY2FsJztcbiAgdmFyIEhPUklaT05UQUwgPSAnaG9yaXpvbnRhbCc7XG4gIHZhciBMRUZUV0FSRCA9ICdsZWZ0d2FyZCc7XG4gIHZhciBSSUdIVFdBUkQgPSAncmlnaHR3YXJkJztcbiAgdmFyIERPV05XQVJEID0gJ2Rvd253YXJkJztcbiAgdmFyIFVQV0FSRCA9ICd1cHdhcmQnO1xuICB2YXIgQVVUTyA9ICdhdXRvJztcbiAgdmFyIHBvc1B0cyA9IHBhaXJJbmZvLnBvc1B0cyxcbiAgICBzcmNXID0gcGFpckluZm8uc3JjVyxcbiAgICBzcmNIID0gcGFpckluZm8uc3JjSCxcbiAgICB0Z3RXID0gcGFpckluZm8udGd0VyxcbiAgICB0Z3RIID0gcGFpckluZm8udGd0SDtcbiAgdmFyIGVkZ2VEaXN0YW5jZXMgPSBlZGdlLnBzdHlsZSgnZWRnZS1kaXN0YW5jZXMnKS52YWx1ZTtcbiAgdmFyIGRJbmNsdWRlc05vZGVCb2R5ID0gZWRnZURpc3RhbmNlcyAhPT0gJ25vZGUtcG9zaXRpb24nO1xuICB2YXIgdGF4aURpciA9IGVkZ2UucHN0eWxlKCd0YXhpLWRpcmVjdGlvbicpLnZhbHVlO1xuICB2YXIgcmF3VGF4aURpciA9IHRheGlEaXI7IC8vIHVucHJvY2Vzc2VkIHZhbHVlXG4gIHZhciB0YXhpVHVybiA9IGVkZ2UucHN0eWxlKCd0YXhpLXR1cm4nKTtcbiAgdmFyIHR1cm5Jc1BlcmNlbnQgPSB0YXhpVHVybi51bml0cyA9PT0gJyUnO1xuICB2YXIgdGF4aVR1cm5QZlZhbCA9IHRheGlUdXJuLnBmVmFsdWU7XG4gIHZhciB0dXJuSXNOZWdhdGl2ZSA9IHRheGlUdXJuUGZWYWwgPCAwOyAvLyBpLmUuIGZyb20gdGFyZ2V0IHNpZGVcbiAgdmFyIG1pbkQgPSBlZGdlLnBzdHlsZSgndGF4aS10dXJuLW1pbi1kaXN0YW5jZScpLnBmVmFsdWU7XG4gIHZhciBkdyA9IGRJbmNsdWRlc05vZGVCb2R5ID8gKHNyY1cgKyB0Z3RXKSAvIDIgOiAwO1xuICB2YXIgZGggPSBkSW5jbHVkZXNOb2RlQm9keSA/IChzcmNIICsgdGd0SCkgLyAyIDogMDtcbiAgdmFyIHBkeCA9IHBvc1B0cy54MiAtIHBvc1B0cy54MTtcbiAgdmFyIHBkeSA9IHBvc1B0cy55MiAtIHBvc1B0cy55MTtcblxuICAvLyB0YWtlIGF3YXkgdGhlIGVmZmVjdGl2ZSB3L2ggZnJvbSB0aGUgbWFnbml0dWRlIG9mIHRoZSBkZWx0YSB2YWx1ZVxuICB2YXIgc3ViRFdIID0gZnVuY3Rpb24gc3ViRFdIKGR4eSwgZHdoKSB7XG4gICAgaWYgKGR4eSA+IDApIHtcbiAgICAgIHJldHVybiBNYXRoLm1heChkeHkgLSBkd2gsIDApO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gTWF0aC5taW4oZHh5ICsgZHdoLCAwKTtcbiAgICB9XG4gIH07XG4gIHZhciBkeCA9IHN1YkRXSChwZHgsIGR3KTtcbiAgdmFyIGR5ID0gc3ViRFdIKHBkeSwgZGgpO1xuICB2YXIgaXNFeHBsaWNpdERpciA9IGZhbHNlO1xuICBpZiAocmF3VGF4aURpciA9PT0gQVVUTykge1xuICAgIHRheGlEaXIgPSBNYXRoLmFicyhkeCkgPiBNYXRoLmFicyhkeSkgPyBIT1JJWk9OVEFMIDogVkVSVElDQUw7XG4gIH0gZWxzZSBpZiAocmF3VGF4aURpciA9PT0gVVBXQVJEIHx8IHJhd1RheGlEaXIgPT09IERPV05XQVJEKSB7XG4gICAgdGF4aURpciA9IFZFUlRJQ0FMO1xuICAgIGlzRXhwbGljaXREaXIgPSB0cnVlO1xuICB9IGVsc2UgaWYgKHJhd1RheGlEaXIgPT09IExFRlRXQVJEIHx8IHJhd1RheGlEaXIgPT09IFJJR0hUV0FSRCkge1xuICAgIHRheGlEaXIgPSBIT1JJWk9OVEFMO1xuICAgIGlzRXhwbGljaXREaXIgPSB0cnVlO1xuICB9XG4gIHZhciBpc1ZlcnQgPSB0YXhpRGlyID09PSBWRVJUSUNBTDtcbiAgdmFyIGwgPSBpc1ZlcnQgPyBkeSA6IGR4O1xuICB2YXIgcGwgPSBpc1ZlcnQgPyBwZHkgOiBwZHg7XG4gIHZhciBzZ25MID0gc2lnbnVtKHBsKTtcbiAgdmFyIGZvcmNlZERpciA9IGZhbHNlO1xuICBpZiAoIShpc0V4cGxpY2l0RGlyICYmICh0dXJuSXNQZXJjZW50IHx8IHR1cm5Jc05lZ2F0aXZlKSkgLy8gZm9yY2luZyBpbiB0aGlzIGNhc2Ugd291bGQgY2F1c2Ugd2VpcmQgZ3Jvd2luZyBpbiB0aGUgb3Bwb3NpdGUgZGlyZWN0aW9uXG4gICYmIChyYXdUYXhpRGlyID09PSBET1dOV0FSRCAmJiBwbCA8IDAgfHwgcmF3VGF4aURpciA9PT0gVVBXQVJEICYmIHBsID4gMCB8fCByYXdUYXhpRGlyID09PSBMRUZUV0FSRCAmJiBwbCA+IDAgfHwgcmF3VGF4aURpciA9PT0gUklHSFRXQVJEICYmIHBsIDwgMCkpIHtcbiAgICBzZ25MICo9IC0xO1xuICAgIGwgPSBzZ25MICogTWF0aC5hYnMobCk7XG4gICAgZm9yY2VkRGlyID0gdHJ1ZTtcbiAgfVxuICB2YXIgZDtcbiAgaWYgKHR1cm5Jc1BlcmNlbnQpIHtcbiAgICB2YXIgcCA9IHRheGlUdXJuUGZWYWwgPCAwID8gMSArIHRheGlUdXJuUGZWYWwgOiB0YXhpVHVyblBmVmFsO1xuICAgIGQgPSBwICogbDtcbiAgfSBlbHNlIHtcbiAgICB2YXIgayA9IHRheGlUdXJuUGZWYWwgPCAwID8gbCA6IDA7XG4gICAgZCA9IGsgKyB0YXhpVHVyblBmVmFsICogc2duTDtcbiAgfVxuICB2YXIgZ2V0SXNUb29DbG9zZSA9IGZ1bmN0aW9uIGdldElzVG9vQ2xvc2UoZCkge1xuICAgIHJldHVybiBNYXRoLmFicyhkKSA8IG1pbkQgfHwgTWF0aC5hYnMoZCkgPj0gTWF0aC5hYnMobCk7XG4gIH07XG4gIHZhciBpc1Rvb0Nsb3NlU3JjID0gZ2V0SXNUb29DbG9zZShkKTtcbiAgdmFyIGlzVG9vQ2xvc2VUZ3QgPSBnZXRJc1Rvb0Nsb3NlKE1hdGguYWJzKGwpIC0gTWF0aC5hYnMoZCkpO1xuICB2YXIgaXNUb29DbG9zZSA9IGlzVG9vQ2xvc2VTcmMgfHwgaXNUb29DbG9zZVRndDtcbiAgaWYgKGlzVG9vQ2xvc2UgJiYgIWZvcmNlZERpcikge1xuICAgIC8vIG5vbi1pZGVhbCByb3V0aW5nXG4gICAgaWYgKGlzVmVydCkge1xuICAgICAgLy8gdmVydGljYWwgZmFsbGJhY2tzXG4gICAgICB2YXIgbFNoYXBlSW5zaWRlU3JjID0gTWF0aC5hYnMocGwpIDw9IHNyY0ggLyAyO1xuICAgICAgdmFyIGxTaGFwZUluc2lkZVRndCA9IE1hdGguYWJzKHBkeCkgPD0gdGd0VyAvIDI7XG4gICAgICBpZiAobFNoYXBlSW5zaWRlU3JjKSB7XG4gICAgICAgIC8vIGhvcml6b250YWwgWi1zaGFwZSAoZGlyZWN0aW9uIG5vdCByZXNwZWN0ZWQpXG4gICAgICAgIHZhciB4ID0gKHBvc1B0cy54MSArIHBvc1B0cy54MikgLyAyO1xuICAgICAgICB2YXIgeTEgPSBwb3NQdHMueTEsXG4gICAgICAgICAgeTIgPSBwb3NQdHMueTI7XG4gICAgICAgIHJzLnNlZ3B0cyA9IFt4LCB5MSwgeCwgeTJdO1xuICAgICAgfSBlbHNlIGlmIChsU2hhcGVJbnNpZGVUZ3QpIHtcbiAgICAgICAgLy8gdmVydGljYWwgWi1zaGFwZSAoZGlzdGFuY2Ugbm90IHJlc3BlY3RlZClcbiAgICAgICAgdmFyIHkgPSAocG9zUHRzLnkxICsgcG9zUHRzLnkyKSAvIDI7XG4gICAgICAgIHZhciB4MSA9IHBvc1B0cy54MSxcbiAgICAgICAgICB4MiA9IHBvc1B0cy54MjtcbiAgICAgICAgcnMuc2VncHRzID0gW3gxLCB5LCB4MiwgeV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBMLXNoYXBlIGZhbGxiYWNrICh0dXJuIGRpc3RhbmNlIG5vdCByZXNwZWN0ZWQsIGJ1dCB3b3JrcyB3ZWxsIHdpdGggdHJlZSBzaWJsaW5ncylcbiAgICAgICAgcnMuc2VncHRzID0gW3Bvc1B0cy54MSwgcG9zUHRzLnkyXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaG9yaXpvbnRhbCBmYWxsYmFja3NcbiAgICAgIHZhciBfbFNoYXBlSW5zaWRlU3JjID0gTWF0aC5hYnMocGwpIDw9IHNyY1cgLyAyO1xuICAgICAgdmFyIF9sU2hhcGVJbnNpZGVUZ3QgPSBNYXRoLmFicyhwZHkpIDw9IHRndEggLyAyO1xuICAgICAgaWYgKF9sU2hhcGVJbnNpZGVTcmMpIHtcbiAgICAgICAgLy8gdmVydGljYWwgWi1zaGFwZSAoZGlyZWN0aW9uIG5vdCByZXNwZWN0ZWQpXG4gICAgICAgIHZhciBfeSA9IChwb3NQdHMueTEgKyBwb3NQdHMueTIpIC8gMjtcbiAgICAgICAgdmFyIF94ID0gcG9zUHRzLngxLFxuICAgICAgICAgIF94MiA9IHBvc1B0cy54MjtcbiAgICAgICAgcnMuc2VncHRzID0gW194LCBfeSwgX3gyLCBfeV07XG4gICAgICB9IGVsc2UgaWYgKF9sU2hhcGVJbnNpZGVUZ3QpIHtcbiAgICAgICAgLy8gaG9yaXpvbnRhbCBaLXNoYXBlICh0dXJuIGRpc3RhbmNlIG5vdCByZXNwZWN0ZWQpXG4gICAgICAgIHZhciBfeDMgPSAocG9zUHRzLngxICsgcG9zUHRzLngyKSAvIDI7XG4gICAgICAgIHZhciBfeTIgPSBwb3NQdHMueTEsXG4gICAgICAgICAgX3kzID0gcG9zUHRzLnkyO1xuICAgICAgICBycy5zZWdwdHMgPSBbX3gzLCBfeTIsIF94MywgX3kzXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEwtc2hhcGUgKHR1cm4gZGlzdGFuY2Ugbm90IHJlc3BlY3RlZCwgYnV0IHdvcmtzIHdlbGwgZm9yIHRyZWUgc2libGluZ3MpXG4gICAgICAgIHJzLnNlZ3B0cyA9IFtwb3NQdHMueDIsIHBvc1B0cy55MV07XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIGlkZWFsIHJvdXRpbmdcbiAgICBpZiAoaXNWZXJ0KSB7XG4gICAgICB2YXIgX3k0ID0gcG9zUHRzLnkxICsgZCArIChkSW5jbHVkZXNOb2RlQm9keSA/IHNyY0ggLyAyICogc2duTCA6IDApO1xuICAgICAgdmFyIF94NCA9IHBvc1B0cy54MSxcbiAgICAgICAgX3g1ID0gcG9zUHRzLngyO1xuICAgICAgcnMuc2VncHRzID0gW194NCwgX3k0LCBfeDUsIF95NF07XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGhvcml6b250YWxcbiAgICAgIHZhciBfeDYgPSBwb3NQdHMueDEgKyBkICsgKGRJbmNsdWRlc05vZGVCb2R5ID8gc3JjVyAvIDIgKiBzZ25MIDogMCk7XG4gICAgICB2YXIgX3k1ID0gcG9zUHRzLnkxLFxuICAgICAgICBfeTYgPSBwb3NQdHMueTI7XG4gICAgICBycy5zZWdwdHMgPSBbX3g2LCBfeTUsIF94NiwgX3k2XTtcbiAgICB9XG4gIH1cbiAgaWYgKHJzLmlzUm91bmQpIHtcbiAgICB2YXIgcmFkaXVzID0gZWRnZS5wc3R5bGUoJ3RheGktcmFkaXVzJykudmFsdWU7XG4gICAgdmFyIGlzQXJjUmFkaXVzID0gZWRnZS5wc3R5bGUoJ3JhZGl1cy10eXBlJykudmFsdWVbMF0gPT09ICdhcmMtcmFkaXVzJztcbiAgICBycy5yYWRpaSA9IG5ldyBBcnJheShycy5zZWdwdHMubGVuZ3RoIC8gMikuZmlsbChyYWRpdXMpO1xuICAgIHJzLmlzQXJjUmFkaXVzID0gbmV3IEFycmF5KHJzLnNlZ3B0cy5sZW5ndGggLyAyKS5maWxsKGlzQXJjUmFkaXVzKTtcbiAgfVxufTtcbkJScCRjLnRyeVRvQ29ycmVjdEludmFsaWRQb2ludHMgPSBmdW5jdGlvbiAoZWRnZSwgcGFpckluZm8pIHtcbiAgdmFyIHJzID0gZWRnZS5fcHJpdmF0ZS5yc2NyYXRjaDtcblxuICAvLyBjYW4gb25seSBjb3JyZWN0IGJlemllcnMgZm9yIG5vdy4uLlxuICBpZiAocnMuZWRnZVR5cGUgPT09ICdiZXppZXInKSB7XG4gICAgdmFyIHNyY1BvcyA9IHBhaXJJbmZvLnNyY1BvcyxcbiAgICAgIHRndFBvcyA9IHBhaXJJbmZvLnRndFBvcyxcbiAgICAgIHNyY1cgPSBwYWlySW5mby5zcmNXLFxuICAgICAgc3JjSCA9IHBhaXJJbmZvLnNyY0gsXG4gICAgICB0Z3RXID0gcGFpckluZm8udGd0VyxcbiAgICAgIHRndEggPSBwYWlySW5mby50Z3RILFxuICAgICAgc3JjU2hhcGUgPSBwYWlySW5mby5zcmNTaGFwZSxcbiAgICAgIHRndFNoYXBlID0gcGFpckluZm8udGd0U2hhcGUsXG4gICAgICBzcmNDb3JuZXJSYWRpdXMgPSBwYWlySW5mby5zcmNDb3JuZXJSYWRpdXMsXG4gICAgICB0Z3RDb3JuZXJSYWRpdXMgPSBwYWlySW5mby50Z3RDb3JuZXJSYWRpdXMsXG4gICAgICBzcmNScyA9IHBhaXJJbmZvLnNyY1JzLFxuICAgICAgdGd0UnMgPSBwYWlySW5mby50Z3RScztcbiAgICB2YXIgYmFkU3RhcnQgPSAhbnVtYmVyJDEocnMuc3RhcnRYKSB8fCAhbnVtYmVyJDEocnMuc3RhcnRZKTtcbiAgICB2YXIgYmFkQVN0YXJ0ID0gIW51bWJlciQxKHJzLmFycm93U3RhcnRYKSB8fCAhbnVtYmVyJDEocnMuYXJyb3dTdGFydFkpO1xuICAgIHZhciBiYWRFbmQgPSAhbnVtYmVyJDEocnMuZW5kWCkgfHwgIW51bWJlciQxKHJzLmVuZFkpO1xuICAgIHZhciBiYWRBRW5kID0gIW51bWJlciQxKHJzLmFycm93RW5kWCkgfHwgIW51bWJlciQxKHJzLmFycm93RW5kWSk7XG4gICAgdmFyIG1pbkNwQURpc3RGYWN0b3IgPSAzO1xuICAgIHZhciBhcnJvd1cgPSB0aGlzLmdldEFycm93V2lkdGgoZWRnZS5wc3R5bGUoJ3dpZHRoJykucGZWYWx1ZSwgZWRnZS5wc3R5bGUoJ2Fycm93LXNjYWxlJykudmFsdWUpICogdGhpcy5hcnJvd1NoYXBlV2lkdGg7XG4gICAgdmFyIG1pbkNwQURpc3QgPSBtaW5DcEFEaXN0RmFjdG9yICogYXJyb3dXO1xuICAgIHZhciBzdGFydEFDcERpc3QgPSBkaXN0KHtcbiAgICAgIHg6IHJzLmN0cmxwdHNbMF0sXG4gICAgICB5OiBycy5jdHJscHRzWzFdXG4gICAgfSwge1xuICAgICAgeDogcnMuc3RhcnRYLFxuICAgICAgeTogcnMuc3RhcnRZXG4gICAgfSk7XG4gICAgdmFyIGNsb3NlU3RhcnRBQ3AgPSBzdGFydEFDcERpc3QgPCBtaW5DcEFEaXN0O1xuICAgIHZhciBlbmRBQ3BEaXN0ID0gZGlzdCh7XG4gICAgICB4OiBycy5jdHJscHRzWzBdLFxuICAgICAgeTogcnMuY3RybHB0c1sxXVxuICAgIH0sIHtcbiAgICAgIHg6IHJzLmVuZFgsXG4gICAgICB5OiBycy5lbmRZXG4gICAgfSk7XG4gICAgdmFyIGNsb3NlRW5kQUNwID0gZW5kQUNwRGlzdCA8IG1pbkNwQURpc3Q7XG4gICAgdmFyIG92ZXJsYXBwaW5nID0gZmFsc2U7XG4gICAgaWYgKGJhZFN0YXJ0IHx8IGJhZEFTdGFydCB8fCBjbG9zZVN0YXJ0QUNwKSB7XG4gICAgICBvdmVybGFwcGluZyA9IHRydWU7XG5cbiAgICAgIC8vIHByb2plY3QgY29udHJvbCBwb2ludCBhbG9uZyBsaW5lIGZyb20gc3JjIGNlbnRyZSB0byBvdXRzaWRlIHRoZSBzcmMgc2hhcGVcbiAgICAgIC8vIChvdGhlcndpc2UgaW50ZXJzZWN0aW9uIHdpbGwgeWllbGQgbm90aGluZylcbiAgICAgIHZhciBjcEQgPSB7XG4gICAgICAgIC8vIGRlbHRhXG4gICAgICAgIHg6IHJzLmN0cmxwdHNbMF0gLSBzcmNQb3MueCxcbiAgICAgICAgeTogcnMuY3RybHB0c1sxXSAtIHNyY1Bvcy55XG4gICAgICB9O1xuICAgICAgdmFyIGNwTCA9IE1hdGguc3FydChjcEQueCAqIGNwRC54ICsgY3BELnkgKiBjcEQueSk7IC8vIGxlbmd0aCBvZiBsaW5lXG4gICAgICB2YXIgY3BNID0ge1xuICAgICAgICAvLyBub3JtYWxpc2VkIGRlbHRhXG4gICAgICAgIHg6IGNwRC54IC8gY3BMLFxuICAgICAgICB5OiBjcEQueSAvIGNwTFxuICAgICAgfTtcbiAgICAgIHZhciByYWRpdXMgPSBNYXRoLm1heChzcmNXLCBzcmNIKTtcbiAgICAgIHZhciBjcFByb2ogPSB7XG4gICAgICAgIC8vICoyIHJhZGl1cyBndWFyYW50ZWVzIG91dHNpZGUgc2hhcGVcbiAgICAgICAgeDogcnMuY3RybHB0c1swXSArIGNwTS54ICogMiAqIHJhZGl1cyxcbiAgICAgICAgeTogcnMuY3RybHB0c1sxXSArIGNwTS55ICogMiAqIHJhZGl1c1xuICAgICAgfTtcbiAgICAgIHZhciBzcmNDdHJsUHRJbnRuID0gc3JjU2hhcGUuaW50ZXJzZWN0TGluZShzcmNQb3MueCwgc3JjUG9zLnksIHNyY1csIHNyY0gsIGNwUHJvai54LCBjcFByb2oueSwgMCwgc3JjQ29ybmVyUmFkaXVzLCBzcmNScyk7XG4gICAgICBpZiAoY2xvc2VTdGFydEFDcCkge1xuICAgICAgICBycy5jdHJscHRzWzBdID0gcnMuY3RybHB0c1swXSArIGNwTS54ICogKG1pbkNwQURpc3QgLSBzdGFydEFDcERpc3QpO1xuICAgICAgICBycy5jdHJscHRzWzFdID0gcnMuY3RybHB0c1sxXSArIGNwTS55ICogKG1pbkNwQURpc3QgLSBzdGFydEFDcERpc3QpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcnMuY3RybHB0c1swXSA9IHNyY0N0cmxQdEludG5bMF0gKyBjcE0ueCAqIG1pbkNwQURpc3Q7XG4gICAgICAgIHJzLmN0cmxwdHNbMV0gPSBzcmNDdHJsUHRJbnRuWzFdICsgY3BNLnkgKiBtaW5DcEFEaXN0O1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoYmFkRW5kIHx8IGJhZEFFbmQgfHwgY2xvc2VFbmRBQ3ApIHtcbiAgICAgIG92ZXJsYXBwaW5nID0gdHJ1ZTtcblxuICAgICAgLy8gcHJvamVjdCBjb250cm9sIHBvaW50IGFsb25nIGxpbmUgZnJvbSB0Z3QgY2VudHJlIHRvIG91dHNpZGUgdGhlIHRndCBzaGFwZVxuICAgICAgLy8gKG90aGVyd2lzZSBpbnRlcnNlY3Rpb24gd2lsbCB5aWVsZCBub3RoaW5nKVxuICAgICAgdmFyIF9jcEQgPSB7XG4gICAgICAgIC8vIGRlbHRhXG4gICAgICAgIHg6IHJzLmN0cmxwdHNbMF0gLSB0Z3RQb3MueCxcbiAgICAgICAgeTogcnMuY3RybHB0c1sxXSAtIHRndFBvcy55XG4gICAgICB9O1xuICAgICAgdmFyIF9jcEwgPSBNYXRoLnNxcnQoX2NwRC54ICogX2NwRC54ICsgX2NwRC55ICogX2NwRC55KTsgLy8gbGVuZ3RoIG9mIGxpbmVcbiAgICAgIHZhciBfY3BNID0ge1xuICAgICAgICAvLyBub3JtYWxpc2VkIGRlbHRhXG4gICAgICAgIHg6IF9jcEQueCAvIF9jcEwsXG4gICAgICAgIHk6IF9jcEQueSAvIF9jcExcbiAgICAgIH07XG4gICAgICB2YXIgX3JhZGl1cyA9IE1hdGgubWF4KHNyY1csIHNyY0gpO1xuICAgICAgdmFyIF9jcFByb2ogPSB7XG4gICAgICAgIC8vICoyIHJhZGl1cyBndWFyYW50ZWVzIG91dHNpZGUgc2hhcGVcbiAgICAgICAgeDogcnMuY3RybHB0c1swXSArIF9jcE0ueCAqIDIgKiBfcmFkaXVzLFxuICAgICAgICB5OiBycy5jdHJscHRzWzFdICsgX2NwTS55ICogMiAqIF9yYWRpdXNcbiAgICAgIH07XG4gICAgICB2YXIgdGd0Q3RybFB0SW50biA9IHRndFNoYXBlLmludGVyc2VjdExpbmUodGd0UG9zLngsIHRndFBvcy55LCB0Z3RXLCB0Z3RILCBfY3BQcm9qLngsIF9jcFByb2oueSwgMCwgdGd0Q29ybmVyUmFkaXVzLCB0Z3RScyk7XG4gICAgICBpZiAoY2xvc2VFbmRBQ3ApIHtcbiAgICAgICAgcnMuY3RybHB0c1swXSA9IHJzLmN0cmxwdHNbMF0gKyBfY3BNLnggKiAobWluQ3BBRGlzdCAtIGVuZEFDcERpc3QpO1xuICAgICAgICBycy5jdHJscHRzWzFdID0gcnMuY3RybHB0c1sxXSArIF9jcE0ueSAqIChtaW5DcEFEaXN0IC0gZW5kQUNwRGlzdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBycy5jdHJscHRzWzBdID0gdGd0Q3RybFB0SW50blswXSArIF9jcE0ueCAqIG1pbkNwQURpc3Q7XG4gICAgICAgIHJzLmN0cmxwdHNbMV0gPSB0Z3RDdHJsUHRJbnRuWzFdICsgX2NwTS55ICogbWluQ3BBRGlzdDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG92ZXJsYXBwaW5nKSB7XG4gICAgICAvLyByZWNhbGMgZW5kcHRzXG4gICAgICB0aGlzLmZpbmRFbmRwb2ludHMoZWRnZSk7XG4gICAgfVxuICB9XG59O1xuQlJwJGMuc3RvcmVBbGxwdHMgPSBmdW5jdGlvbiAoZWRnZSkge1xuICB2YXIgcnMgPSBlZGdlLl9wcml2YXRlLnJzY3JhdGNoO1xuICBpZiAocnMuZWRnZVR5cGUgPT09ICdtdWx0aWJlemllcicgfHwgcnMuZWRnZVR5cGUgPT09ICdiZXppZXInIHx8IHJzLmVkZ2VUeXBlID09PSAnc2VsZicgfHwgcnMuZWRnZVR5cGUgPT09ICdjb21wb3VuZCcpIHtcbiAgICBycy5hbGxwdHMgPSBbXTtcbiAgICBycy5hbGxwdHMucHVzaChycy5zdGFydFgsIHJzLnN0YXJ0WSk7XG4gICAgZm9yICh2YXIgYiA9IDA7IGIgKyAxIDwgcnMuY3RybHB0cy5sZW5ndGg7IGIgKz0gMikge1xuICAgICAgLy8gY3RybCBwdCBpdHNlbGZcbiAgICAgIHJzLmFsbHB0cy5wdXNoKHJzLmN0cmxwdHNbYl0sIHJzLmN0cmxwdHNbYiArIDFdKTtcblxuICAgICAgLy8gdGhlIG1pZHB0IGJldHdlZW4gY3RybHB0cyBhcyBpbnRlcm1lZGlhdGUgZGVzdGluYXRpb24gcHRzXG4gICAgICBpZiAoYiArIDMgPCBycy5jdHJscHRzLmxlbmd0aCkge1xuICAgICAgICBycy5hbGxwdHMucHVzaCgocnMuY3RybHB0c1tiXSArIHJzLmN0cmxwdHNbYiArIDJdKSAvIDIsIChycy5jdHJscHRzW2IgKyAxXSArIHJzLmN0cmxwdHNbYiArIDNdKSAvIDIpO1xuICAgICAgfVxuICAgIH1cbiAgICBycy5hbGxwdHMucHVzaChycy5lbmRYLCBycy5lbmRZKTtcbiAgICB2YXIgbSwgbXQ7XG4gICAgaWYgKHJzLmN0cmxwdHMubGVuZ3RoIC8gMiAlIDIgPT09IDApIHtcbiAgICAgIG0gPSBycy5hbGxwdHMubGVuZ3RoIC8gMiAtIDE7XG4gICAgICBycy5taWRYID0gcnMuYWxscHRzW21dO1xuICAgICAgcnMubWlkWSA9IHJzLmFsbHB0c1ttICsgMV07XG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSBycy5hbGxwdHMubGVuZ3RoIC8gMiAtIDM7XG4gICAgICBtdCA9IDAuNTtcbiAgICAgIHJzLm1pZFggPSBxYmV6aWVyQXQocnMuYWxscHRzW21dLCBycy5hbGxwdHNbbSArIDJdLCBycy5hbGxwdHNbbSArIDRdLCBtdCk7XG4gICAgICBycy5taWRZID0gcWJlemllckF0KHJzLmFsbHB0c1ttICsgMV0sIHJzLmFsbHB0c1ttICsgM10sIHJzLmFsbHB0c1ttICsgNV0sIG10KTtcbiAgICB9XG4gIH0gZWxzZSBpZiAocnMuZWRnZVR5cGUgPT09ICdzdHJhaWdodCcpIHtcbiAgICAvLyBuZWVkIHRvIGNhbGMgdGhlc2UgYWZ0ZXIgZW5kcHRzXG4gICAgcnMuYWxscHRzID0gW3JzLnN0YXJ0WCwgcnMuc3RhcnRZLCBycy5lbmRYLCBycy5lbmRZXTtcblxuICAgIC8vIGRlZmF1bHQgbWlkcHQgZm9yIGxhYmVscyBldGNcbiAgICBycy5taWRYID0gKHJzLnN0YXJ0WCArIHJzLmVuZFggKyBycy5hcnJvd1N0YXJ0WCArIHJzLmFycm93RW5kWCkgLyA0O1xuICAgIHJzLm1pZFkgPSAocnMuc3RhcnRZICsgcnMuZW5kWSArIHJzLmFycm93U3RhcnRZICsgcnMuYXJyb3dFbmRZKSAvIDQ7XG4gIH0gZWxzZSBpZiAocnMuZWRnZVR5cGUgPT09ICdzZWdtZW50cycpIHtcbiAgICBycy5hbGxwdHMgPSBbXTtcbiAgICBycy5hbGxwdHMucHVzaChycy5zdGFydFgsIHJzLnN0YXJ0WSk7XG4gICAgcnMuYWxscHRzLnB1c2guYXBwbHkocnMuYWxscHRzLCBycy5zZWdwdHMpO1xuICAgIHJzLmFsbHB0cy5wdXNoKHJzLmVuZFgsIHJzLmVuZFkpO1xuICAgIGlmIChycy5pc1JvdW5kKSB7XG4gICAgICBycy5yb3VuZENvcm5lcnMgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAyOyBpICsgMyA8IHJzLmFsbHB0cy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICB2YXIgcmFkaXVzID0gcnMucmFkaWlbaSAvIDIgLSAxXTtcbiAgICAgICAgdmFyIGlzQXJjUmFkaXVzID0gcnMuaXNBcmNSYWRpdXNbaSAvIDIgLSAxXTtcbiAgICAgICAgcnMucm91bmRDb3JuZXJzLnB1c2goZ2V0Um91bmRDb3JuZXIoe1xuICAgICAgICAgIHg6IHJzLmFsbHB0c1tpIC0gMl0sXG4gICAgICAgICAgeTogcnMuYWxscHRzW2kgLSAxXVxuICAgICAgICB9LCB7XG4gICAgICAgICAgeDogcnMuYWxscHRzW2ldLFxuICAgICAgICAgIHk6IHJzLmFsbHB0c1tpICsgMV0sXG4gICAgICAgICAgcmFkaXVzOiByYWRpdXNcbiAgICAgICAgfSwge1xuICAgICAgICAgIHg6IHJzLmFsbHB0c1tpICsgMl0sXG4gICAgICAgICAgeTogcnMuYWxscHRzW2kgKyAzXVxuICAgICAgICB9LCByYWRpdXMsIGlzQXJjUmFkaXVzKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChycy5zZWdwdHMubGVuZ3RoICUgNCA9PT0gMCkge1xuICAgICAgdmFyIGkyID0gcnMuc2VncHRzLmxlbmd0aCAvIDI7XG4gICAgICB2YXIgaTEgPSBpMiAtIDI7XG4gICAgICBycy5taWRYID0gKHJzLnNlZ3B0c1tpMV0gKyBycy5zZWdwdHNbaTJdKSAvIDI7XG4gICAgICBycy5taWRZID0gKHJzLnNlZ3B0c1tpMSArIDFdICsgcnMuc2VncHRzW2kyICsgMV0pIC8gMjtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIF9pID0gcnMuc2VncHRzLmxlbmd0aCAvIDIgLSAxO1xuICAgICAgaWYgKCFycy5pc1JvdW5kKSB7XG4gICAgICAgIHJzLm1pZFggPSBycy5zZWdwdHNbX2ldO1xuICAgICAgICBycy5taWRZID0gcnMuc2VncHRzW19pICsgMV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcG9pbnQgPSB7XG4gICAgICAgICAgeDogcnMuc2VncHRzW19pXSxcbiAgICAgICAgICB5OiBycy5zZWdwdHNbX2kgKyAxXVxuICAgICAgICB9O1xuICAgICAgICB2YXIgY29ybmVyID0gcnMucm91bmRDb3JuZXJzW19pIC8gMl07XG4gICAgICAgIHZhciB2ID0gW3BvaW50LnggLSBjb3JuZXIuY3gsIHBvaW50LnkgLSBjb3JuZXIuY3ldO1xuICAgICAgICB2YXIgZmFjdG9yID0gY29ybmVyLnJhZGl1cyAvIE1hdGguc3FydChNYXRoLnBvdyh2WzBdLCAyKSArIE1hdGgucG93KHZbMV0sIDIpKTtcbiAgICAgICAgdiA9IHYubWFwKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgcmV0dXJuIGMgKiBmYWN0b3I7XG4gICAgICAgIH0pO1xuICAgICAgICBycy5taWRYID0gY29ybmVyLmN4ICsgdlswXTtcbiAgICAgICAgcnMubWlkWSA9IGNvcm5lci5jeSArIHZbMV07XG4gICAgICAgIHJzLm1pZFZlY3RvciA9IHY7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuQlJwJGMuY2hlY2tGb3JJbnZhbGlkRWRnZVdhcm5pbmcgPSBmdW5jdGlvbiAoZWRnZSkge1xuICB2YXIgcnMgPSBlZGdlWzBdLl9wcml2YXRlLnJzY3JhdGNoO1xuICBpZiAocnMubm9kZXNPdmVybGFwIHx8IG51bWJlciQxKHJzLnN0YXJ0WCkgJiYgbnVtYmVyJDEocnMuc3RhcnRZKSAmJiBudW1iZXIkMShycy5lbmRYKSAmJiBudW1iZXIkMShycy5lbmRZKSkge1xuICAgIHJzLmxvZ2dlZEVyciA9IGZhbHNlO1xuICB9IGVsc2Uge1xuICAgIGlmICghcnMubG9nZ2VkRXJyKSB7XG4gICAgICBycy5sb2dnZWRFcnIgPSB0cnVlO1xuICAgICAgd2FybignRWRnZSBgJyArIGVkZ2UuaWQoKSArICdgIGhhcyBpbnZhbGlkIGVuZHBvaW50cyBhbmQgc28gaXQgaXMgaW1wb3NzaWJsZSB0byBkcmF3LiAgQWRqdXN0IHlvdXIgZWRnZSBzdHlsZSAoZS5nLiBjb250cm9sIHBvaW50cykgYWNjb3JkaW5nbHkgb3IgdXNlIGFuIGFsdGVybmF0aXZlIGVkZ2UgdHlwZS4gIFRoaXMgaXMgZXhwZWN0ZWQgYmVoYXZpb3VyIHdoZW4gdGhlIHNvdXJjZSBub2RlIGFuZCB0aGUgdGFyZ2V0IG5vZGUgb3ZlcmxhcC4nKTtcbiAgICB9XG4gIH1cbn07XG5CUnAkYy5maW5kRWRnZUNvbnRyb2xQb2ludHMgPSBmdW5jdGlvbiAoZWRnZXMpIHtcbiAgdmFyIF90aGlzID0gdGhpcztcbiAgaWYgKCFlZGdlcyB8fCBlZGdlcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIHIgPSB0aGlzO1xuICB2YXIgY3kgPSByLmN5O1xuICB2YXIgaGFzQ29tcG91bmRzID0gY3kuaGFzQ29tcG91bmROb2RlcygpO1xuICB2YXIgaGFzaFRhYmxlID0ge1xuICAgIG1hcDogbmV3IE1hcCQyKCksXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQocGFpcklkKSB7XG4gICAgICB2YXIgbWFwMiA9IHRoaXMubWFwLmdldChwYWlySWRbMF0pO1xuICAgICAgaWYgKG1hcDIgIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbWFwMi5nZXQocGFpcklkWzFdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQocGFpcklkLCB2YWwpIHtcbiAgICAgIHZhciBtYXAyID0gdGhpcy5tYXAuZ2V0KHBhaXJJZFswXSk7XG4gICAgICBpZiAobWFwMiA9PSBudWxsKSB7XG4gICAgICAgIG1hcDIgPSBuZXcgTWFwJDIoKTtcbiAgICAgICAgdGhpcy5tYXAuc2V0KHBhaXJJZFswXSwgbWFwMik7XG4gICAgICB9XG4gICAgICBtYXAyLnNldChwYWlySWRbMV0sIHZhbCk7XG4gICAgfVxuICB9O1xuICB2YXIgcGFpcklkcyA9IFtdO1xuICB2YXIgaGF5c3RhY2tFZGdlcyA9IFtdO1xuXG4gIC8vIGNyZWF0ZSBhIHRhYmxlIG9mIGVkZ2UgKHNyYywgdGd0KSA9PiBsaXN0IG9mIGVkZ2VzIGJldHdlZW4gdGhlbVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGVkZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGVkZ2UgPSBlZGdlc1tpXTtcbiAgICB2YXIgX3AgPSBlZGdlLl9wcml2YXRlO1xuICAgIHZhciBjdXJ2ZVN0eWxlID0gZWRnZS5wc3R5bGUoJ2N1cnZlLXN0eWxlJykudmFsdWU7XG5cbiAgICAvLyBpZ25vcmUgZWRnZXMgd2hvIGFyZSBub3QgdG8gYmUgZGlzcGxheWVkXG4gICAgLy8gdGhleSBzaG91bGRuJ3QgdGFrZSB1cCBzcGFjZVxuICAgIGlmIChlZGdlLnJlbW92ZWQoKSB8fCAhZWRnZS50YWtlc1VwU3BhY2UoKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChjdXJ2ZVN0eWxlID09PSAnaGF5c3RhY2snKSB7XG4gICAgICBoYXlzdGFja0VkZ2VzLnB1c2goZWRnZSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgdmFyIGVkZ2VJc1VuYnVuZGxlZCA9IGN1cnZlU3R5bGUgPT09ICd1bmJ1bmRsZWQtYmV6aWVyJyB8fCBjdXJ2ZVN0eWxlLmVuZHNXaXRoKCdzZWdtZW50cycpIHx8IGN1cnZlU3R5bGUgPT09ICdzdHJhaWdodCcgfHwgY3VydmVTdHlsZSA9PT0gJ3N0cmFpZ2h0LXRyaWFuZ2xlJyB8fCBjdXJ2ZVN0eWxlLmVuZHNXaXRoKCd0YXhpJyk7XG4gICAgdmFyIGVkZ2VJc0JlemllciA9IGN1cnZlU3R5bGUgPT09ICd1bmJ1bmRsZWQtYmV6aWVyJyB8fCBjdXJ2ZVN0eWxlID09PSAnYmV6aWVyJztcbiAgICB2YXIgc3JjID0gX3Auc291cmNlO1xuICAgIHZhciB0Z3QgPSBfcC50YXJnZXQ7XG4gICAgdmFyIHNyY0luZGV4ID0gc3JjLnBvb2xJbmRleCgpO1xuICAgIHZhciB0Z3RJbmRleCA9IHRndC5wb29sSW5kZXgoKTtcbiAgICB2YXIgcGFpcklkID0gW3NyY0luZGV4LCB0Z3RJbmRleF0uc29ydCgpO1xuICAgIHZhciB0YWJsZUVudHJ5ID0gaGFzaFRhYmxlLmdldChwYWlySWQpO1xuICAgIGlmICh0YWJsZUVudHJ5ID09IG51bGwpIHtcbiAgICAgIHRhYmxlRW50cnkgPSB7XG4gICAgICAgIGVsZXM6IFtdXG4gICAgICB9O1xuICAgICAgaGFzaFRhYmxlLnNldChwYWlySWQsIHRhYmxlRW50cnkpO1xuICAgICAgcGFpcklkcy5wdXNoKHBhaXJJZCk7XG4gICAgfVxuICAgIHRhYmxlRW50cnkuZWxlcy5wdXNoKGVkZ2UpO1xuICAgIGlmIChlZGdlSXNVbmJ1bmRsZWQpIHtcbiAgICAgIHRhYmxlRW50cnkuaGFzVW5idW5kbGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGVkZ2VJc0Jlemllcikge1xuICAgICAgdGFibGVFbnRyeS5oYXNCZXppZXIgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIC8vIGZvciBlYWNoIHBhaXIgKHNyYywgdGd0KSwgY3JlYXRlIHRoZSBjdHJsIHB0c1xuICAvLyBOZXN0ZWQgZm9yIGxvb3AgaXMgT0s7IHRvdGFsIG51bWJlciBvZiBpdGVyYXRpb25zIGZvciBib3RoIGxvb3BzID0gZWRnZUNvdW50XG4gIHZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKHApIHtcbiAgICB2YXIgcGFpcklkID0gcGFpcklkc1twXTtcbiAgICB2YXIgcGFpckluZm8gPSBoYXNoVGFibGUuZ2V0KHBhaXJJZCk7XG4gICAgdmFyIHN3YXBwZWRwYWlySW5mbyA9IHZvaWQgMDtcbiAgICBpZiAoIXBhaXJJbmZvLmhhc1VuYnVuZGxlZCkge1xuICAgICAgdmFyIHBsbEVkZ2VzID0gcGFpckluZm8uZWxlc1swXS5wYXJhbGxlbEVkZ2VzKCkuZmlsdGVyKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHJldHVybiBlLmlzQnVuZGxlZEJlemllcigpO1xuICAgICAgfSk7XG4gICAgICBjbGVhckFycmF5KHBhaXJJbmZvLmVsZXMpO1xuICAgICAgcGxsRWRnZXMuZm9yRWFjaChmdW5jdGlvbiAoZWRnZSkge1xuICAgICAgICByZXR1cm4gcGFpckluZm8uZWxlcy5wdXNoKGVkZ2UpO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIGZvciBlYWNoIHBhaXIgaWQsIHRoZSBlZGdlcyBzaG91bGQgYmUgc29ydGVkIGJ5IGluZGV4XG4gICAgICBwYWlySW5mby5lbGVzLnNvcnQoZnVuY3Rpb24gKGVkZ2UxLCBlZGdlMikge1xuICAgICAgICByZXR1cm4gZWRnZTEucG9vbEluZGV4KCkgLSBlZGdlMi5wb29sSW5kZXgoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICB2YXIgZmlyc3RFZGdlID0gcGFpckluZm8uZWxlc1swXTtcbiAgICB2YXIgc3JjID0gZmlyc3RFZGdlLnNvdXJjZSgpO1xuICAgIHZhciB0Z3QgPSBmaXJzdEVkZ2UudGFyZ2V0KCk7XG5cbiAgICAvLyBtYWtlIHN1cmUgc3JjL3RndCBkaXN0aW5jdGlvbiBpcyBjb25zaXN0ZW50IHcuci50LiBwYWlySWRcbiAgICBpZiAoc3JjLnBvb2xJbmRleCgpID4gdGd0LnBvb2xJbmRleCgpKSB7XG4gICAgICB2YXIgdGVtcCA9IHNyYztcbiAgICAgIHNyYyA9IHRndDtcbiAgICAgIHRndCA9IHRlbXA7XG4gICAgfVxuICAgIHZhciBzcmNQb3MgPSBwYWlySW5mby5zcmNQb3MgPSBzcmMucG9zaXRpb24oKTtcbiAgICB2YXIgdGd0UG9zID0gcGFpckluZm8udGd0UG9zID0gdGd0LnBvc2l0aW9uKCk7XG4gICAgdmFyIHNyY1cgPSBwYWlySW5mby5zcmNXID0gc3JjLm91dGVyV2lkdGgoKTtcbiAgICB2YXIgc3JjSCA9IHBhaXJJbmZvLnNyY0ggPSBzcmMub3V0ZXJIZWlnaHQoKTtcbiAgICB2YXIgdGd0VyA9IHBhaXJJbmZvLnRndFcgPSB0Z3Qub3V0ZXJXaWR0aCgpO1xuICAgIHZhciB0Z3RIID0gcGFpckluZm8udGd0SCA9IHRndC5vdXRlckhlaWdodCgpO1xuICAgIHZhciBzcmNTaGFwZSA9IHBhaXJJbmZvLnNyY1NoYXBlID0gci5ub2RlU2hhcGVzW190aGlzLmdldE5vZGVTaGFwZShzcmMpXTtcbiAgICB2YXIgdGd0U2hhcGUgPSBwYWlySW5mby50Z3RTaGFwZSA9IHIubm9kZVNoYXBlc1tfdGhpcy5nZXROb2RlU2hhcGUodGd0KV07XG4gICAgdmFyIHNyY0Nvcm5lclJhZGl1cyA9IHBhaXJJbmZvLnNyY0Nvcm5lclJhZGl1cyA9IHNyYy5wc3R5bGUoJ2Nvcm5lci1yYWRpdXMnKS52YWx1ZSA9PT0gJ2F1dG8nID8gJ2F1dG8nIDogc3JjLnBzdHlsZSgnY29ybmVyLXJhZGl1cycpLnBmVmFsdWU7XG4gICAgdmFyIHRndENvcm5lclJhZGl1cyA9IHBhaXJJbmZvLnRndENvcm5lclJhZGl1cyA9IHRndC5wc3R5bGUoJ2Nvcm5lci1yYWRpdXMnKS52YWx1ZSA9PT0gJ2F1dG8nID8gJ2F1dG8nIDogdGd0LnBzdHlsZSgnY29ybmVyLXJhZGl1cycpLnBmVmFsdWU7XG4gICAgdmFyIHRndFJzID0gcGFpckluZm8udGd0UnMgPSB0Z3QuX3ByaXZhdGUucnNjcmF0Y2g7XG4gICAgdmFyIHNyY1JzID0gcGFpckluZm8uc3JjUnMgPSBzcmMuX3ByaXZhdGUucnNjcmF0Y2g7XG4gICAgcGFpckluZm8uZGlyQ291bnRzID0ge1xuICAgICAgJ25vcnRoJzogMCxcbiAgICAgICd3ZXN0JzogMCxcbiAgICAgICdzb3V0aCc6IDAsXG4gICAgICAnZWFzdCc6IDAsXG4gICAgICAnbm9ydGh3ZXN0JzogMCxcbiAgICAgICdzb3V0aHdlc3QnOiAwLFxuICAgICAgJ25vcnRoZWFzdCc6IDAsXG4gICAgICAnc291dGhlYXN0JzogMFxuICAgIH07XG4gICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgcGFpckluZm8uZWxlcy5sZW5ndGg7IF9pMisrKSB7XG4gICAgICB2YXIgX2VkZ2UgPSBwYWlySW5mby5lbGVzW19pMl07XG4gICAgICB2YXIgcnMgPSBfZWRnZVswXS5fcHJpdmF0ZS5yc2NyYXRjaDtcbiAgICAgIHZhciBfY3VydmVTdHlsZSA9IF9lZGdlLnBzdHlsZSgnY3VydmUtc3R5bGUnKS52YWx1ZTtcbiAgICAgIHZhciBfZWRnZUlzVW5idW5kbGVkID0gX2N1cnZlU3R5bGUgPT09ICd1bmJ1bmRsZWQtYmV6aWVyJyB8fCBfY3VydmVTdHlsZS5lbmRzV2l0aCgnc2VnbWVudHMnKSB8fCBfY3VydmVTdHlsZS5lbmRzV2l0aCgndGF4aScpO1xuXG4gICAgICAvLyB3aGV0aGVyIHRoZSBub3JtYWxpc2VkIHBhaXIgb3JkZXIgaXMgdGhlIHJldmVyc2Ugb2YgdGhlIGVkZ2UncyBzcmMtdGd0IG9yZGVyXG4gICAgICB2YXIgZWRnZUlzU3dhcHBlZCA9ICFzcmMuc2FtZShfZWRnZS5zb3VyY2UoKSk7XG4gICAgICBpZiAoIXBhaXJJbmZvLmNhbGN1bGF0ZWRJbnRlcnNlY3Rpb24gJiYgc3JjICE9PSB0Z3QgJiYgKHBhaXJJbmZvLmhhc0JlemllciB8fCBwYWlySW5mby5oYXNVbmJ1bmRsZWQpKSB7XG4gICAgICAgIHBhaXJJbmZvLmNhbGN1bGF0ZWRJbnRlcnNlY3Rpb24gPSB0cnVlO1xuXG4gICAgICAgIC8vIHB0IG91dHNpZGUgc3JjIHNoYXBlIHRvIGNhbGMgZGlzdGFuY2UvZGlzcGxhY2VtZW50IGZyb20gc3JjIHRvIHRndFxuICAgICAgICB2YXIgc3JjT3V0c2lkZSA9IHNyY1NoYXBlLmludGVyc2VjdExpbmUoc3JjUG9zLngsIHNyY1Bvcy55LCBzcmNXLCBzcmNILCB0Z3RQb3MueCwgdGd0UG9zLnksIDAsIHNyY0Nvcm5lclJhZGl1cywgc3JjUnMpO1xuICAgICAgICB2YXIgc3JjSW50biA9IHBhaXJJbmZvLnNyY0ludG4gPSBzcmNPdXRzaWRlO1xuXG4gICAgICAgIC8vIHB0IG91dHNpZGUgdGd0IHNoYXBlIHRvIGNhbGMgZGlzdGFuY2UvZGlzcGxhY2VtZW50IGZyb20gc3JjIHRvIHRndFxuICAgICAgICB2YXIgdGd0T3V0c2lkZSA9IHRndFNoYXBlLmludGVyc2VjdExpbmUodGd0UG9zLngsIHRndFBvcy55LCB0Z3RXLCB0Z3RILCBzcmNQb3MueCwgc3JjUG9zLnksIDAsIHRndENvcm5lclJhZGl1cywgdGd0UnMpO1xuICAgICAgICB2YXIgdGd0SW50biA9IHBhaXJJbmZvLnRndEludG4gPSB0Z3RPdXRzaWRlO1xuICAgICAgICB2YXIgaW50ZXJzZWN0aW9uUHRzID0gcGFpckluZm8uaW50ZXJzZWN0aW9uUHRzID0ge1xuICAgICAgICAgIHgxOiBzcmNPdXRzaWRlWzBdLFxuICAgICAgICAgIHgyOiB0Z3RPdXRzaWRlWzBdLFxuICAgICAgICAgIHkxOiBzcmNPdXRzaWRlWzFdLFxuICAgICAgICAgIHkyOiB0Z3RPdXRzaWRlWzFdXG4gICAgICAgIH07XG4gICAgICAgIHZhciBwb3NQdHMgPSBwYWlySW5mby5wb3NQdHMgPSB7XG4gICAgICAgICAgeDE6IHNyY1Bvcy54LFxuICAgICAgICAgIHgyOiB0Z3RQb3MueCxcbiAgICAgICAgICB5MTogc3JjUG9zLnksXG4gICAgICAgICAgeTI6IHRndFBvcy55XG4gICAgICAgIH07XG4gICAgICAgIHZhciBkeSA9IHRndE91dHNpZGVbMV0gLSBzcmNPdXRzaWRlWzFdO1xuICAgICAgICB2YXIgZHggPSB0Z3RPdXRzaWRlWzBdIC0gc3JjT3V0c2lkZVswXTtcbiAgICAgICAgdmFyIGwgPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICAgICAgICB2YXIgdmVjdG9yID0gcGFpckluZm8udmVjdG9yID0ge1xuICAgICAgICAgIHg6IGR4LFxuICAgICAgICAgIHk6IGR5XG4gICAgICAgIH07XG4gICAgICAgIHZhciB2ZWN0b3JOb3JtID0gcGFpckluZm8udmVjdG9yTm9ybSA9IHtcbiAgICAgICAgICB4OiB2ZWN0b3IueCAvIGwsXG4gICAgICAgICAgeTogdmVjdG9yLnkgLyBsXG4gICAgICAgIH07XG4gICAgICAgIHZhciB2ZWN0b3JOb3JtSW52ZXJzZSA9IHtcbiAgICAgICAgICB4OiAtdmVjdG9yTm9ybS55LFxuICAgICAgICAgIHk6IHZlY3Rvck5vcm0ueFxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIGlmIG5vZGUgc2hhcGVzIG92ZXJsYXAsIHRoZW4gbm8gY3RybCBwdHMgdG8gZHJhd1xuICAgICAgICBwYWlySW5mby5ub2Rlc092ZXJsYXAgPSAhbnVtYmVyJDEobCkgfHwgdGd0U2hhcGUuY2hlY2tQb2ludChzcmNPdXRzaWRlWzBdLCBzcmNPdXRzaWRlWzFdLCAwLCB0Z3RXLCB0Z3RILCB0Z3RQb3MueCwgdGd0UG9zLnksIHRndENvcm5lclJhZGl1cywgdGd0UnMpIHx8IHNyY1NoYXBlLmNoZWNrUG9pbnQodGd0T3V0c2lkZVswXSwgdGd0T3V0c2lkZVsxXSwgMCwgc3JjVywgc3JjSCwgc3JjUG9zLngsIHNyY1Bvcy55LCBzcmNDb3JuZXJSYWRpdXMsIHNyY1JzKTtcbiAgICAgICAgcGFpckluZm8udmVjdG9yTm9ybUludmVyc2UgPSB2ZWN0b3JOb3JtSW52ZXJzZTtcbiAgICAgICAgc3dhcHBlZHBhaXJJbmZvID0ge1xuICAgICAgICAgIG5vZGVzT3ZlcmxhcDogcGFpckluZm8ubm9kZXNPdmVybGFwLFxuICAgICAgICAgIGRpckNvdW50czogcGFpckluZm8uZGlyQ291bnRzLFxuICAgICAgICAgIGNhbGN1bGF0ZWRJbnRlcnNlY3Rpb246IHRydWUsXG4gICAgICAgICAgaGFzQmV6aWVyOiBwYWlySW5mby5oYXNCZXppZXIsXG4gICAgICAgICAgaGFzVW5idW5kbGVkOiBwYWlySW5mby5oYXNVbmJ1bmRsZWQsXG4gICAgICAgICAgZWxlczogcGFpckluZm8uZWxlcyxcbiAgICAgICAgICBzcmNQb3M6IHRndFBvcyxcbiAgICAgICAgICBzcmNSczogdGd0UnMsXG4gICAgICAgICAgdGd0UG9zOiBzcmNQb3MsXG4gICAgICAgICAgdGd0UnM6IHNyY1JzLFxuICAgICAgICAgIHNyY1c6IHRndFcsXG4gICAgICAgICAgc3JjSDogdGd0SCxcbiAgICAgICAgICB0Z3RXOiBzcmNXLFxuICAgICAgICAgIHRndEg6IHNyY0gsXG4gICAgICAgICAgc3JjSW50bjogdGd0SW50bixcbiAgICAgICAgICB0Z3RJbnRuOiBzcmNJbnRuLFxuICAgICAgICAgIHNyY1NoYXBlOiB0Z3RTaGFwZSxcbiAgICAgICAgICB0Z3RTaGFwZTogc3JjU2hhcGUsXG4gICAgICAgICAgcG9zUHRzOiB7XG4gICAgICAgICAgICB4MTogcG9zUHRzLngyLFxuICAgICAgICAgICAgeTE6IHBvc1B0cy55MixcbiAgICAgICAgICAgIHgyOiBwb3NQdHMueDEsXG4gICAgICAgICAgICB5MjogcG9zUHRzLnkxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBpbnRlcnNlY3Rpb25QdHM6IHtcbiAgICAgICAgICAgIHgxOiBpbnRlcnNlY3Rpb25QdHMueDIsXG4gICAgICAgICAgICB5MTogaW50ZXJzZWN0aW9uUHRzLnkyLFxuICAgICAgICAgICAgeDI6IGludGVyc2VjdGlvblB0cy54MSxcbiAgICAgICAgICAgIHkyOiBpbnRlcnNlY3Rpb25QdHMueTFcbiAgICAgICAgICB9LFxuICAgICAgICAgIHZlY3Rvcjoge1xuICAgICAgICAgICAgeDogLXZlY3Rvci54LFxuICAgICAgICAgICAgeTogLXZlY3Rvci55XG4gICAgICAgICAgfSxcbiAgICAgICAgICB2ZWN0b3JOb3JtOiB7XG4gICAgICAgICAgICB4OiAtdmVjdG9yTm9ybS54LFxuICAgICAgICAgICAgeTogLXZlY3Rvck5vcm0ueVxuICAgICAgICAgIH0sXG4gICAgICAgICAgdmVjdG9yTm9ybUludmVyc2U6IHtcbiAgICAgICAgICAgIHg6IC12ZWN0b3JOb3JtSW52ZXJzZS54LFxuICAgICAgICAgICAgeTogLXZlY3Rvck5vcm1JbnZlcnNlLnlcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICB2YXIgcGFzc2VkUGFpckluZm8gPSBlZGdlSXNTd2FwcGVkID8gc3dhcHBlZHBhaXJJbmZvIDogcGFpckluZm87XG4gICAgICBycy5ub2Rlc092ZXJsYXAgPSBwYXNzZWRQYWlySW5mby5ub2Rlc092ZXJsYXA7XG4gICAgICBycy5zcmNJbnRuID0gcGFzc2VkUGFpckluZm8uc3JjSW50bjtcbiAgICAgIHJzLnRndEludG4gPSBwYXNzZWRQYWlySW5mby50Z3RJbnRuO1xuICAgICAgcnMuaXNSb3VuZCA9IF9jdXJ2ZVN0eWxlLnN0YXJ0c1dpdGgoJ3JvdW5kJyk7XG4gICAgICBpZiAoaGFzQ29tcG91bmRzICYmIChzcmMuaXNQYXJlbnQoKSB8fCBzcmMuaXNDaGlsZCgpIHx8IHRndC5pc1BhcmVudCgpIHx8IHRndC5pc0NoaWxkKCkpICYmIChzcmMucGFyZW50cygpLmFueVNhbWUodGd0KSB8fCB0Z3QucGFyZW50cygpLmFueVNhbWUoc3JjKSB8fCBzcmMuc2FtZSh0Z3QpICYmIHNyYy5pc1BhcmVudCgpKSkge1xuICAgICAgICBfdGhpcy5maW5kQ29tcG91bmRMb29wUG9pbnRzKF9lZGdlLCBwYXNzZWRQYWlySW5mbywgX2kyLCBfZWRnZUlzVW5idW5kbGVkKTtcbiAgICAgIH0gZWxzZSBpZiAoc3JjID09PSB0Z3QpIHtcbiAgICAgICAgX3RoaXMuZmluZExvb3BQb2ludHMoX2VkZ2UsIHBhc3NlZFBhaXJJbmZvLCBfaTIsIF9lZGdlSXNVbmJ1bmRsZWQpO1xuICAgICAgfSBlbHNlIGlmIChfY3VydmVTdHlsZS5lbmRzV2l0aCgnc2VnbWVudHMnKSkge1xuICAgICAgICBfdGhpcy5maW5kU2VnbWVudHNQb2ludHMoX2VkZ2UsIHBhc3NlZFBhaXJJbmZvKTtcbiAgICAgIH0gZWxzZSBpZiAoX2N1cnZlU3R5bGUuZW5kc1dpdGgoJ3RheGknKSkge1xuICAgICAgICBfdGhpcy5maW5kVGF4aVBvaW50cyhfZWRnZSwgcGFzc2VkUGFpckluZm8pO1xuICAgICAgfSBlbHNlIGlmIChfY3VydmVTdHlsZSA9PT0gJ3N0cmFpZ2h0JyB8fCAhX2VkZ2VJc1VuYnVuZGxlZCAmJiBwYWlySW5mby5lbGVzLmxlbmd0aCAlIDIgPT09IDEgJiYgX2kyID09PSBNYXRoLmZsb29yKHBhaXJJbmZvLmVsZXMubGVuZ3RoIC8gMikpIHtcbiAgICAgICAgX3RoaXMuZmluZFN0cmFpZ2h0RWRnZVBvaW50cyhfZWRnZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfdGhpcy5maW5kQmV6aWVyUG9pbnRzKF9lZGdlLCBwYXNzZWRQYWlySW5mbywgX2kyLCBfZWRnZUlzVW5idW5kbGVkLCBlZGdlSXNTd2FwcGVkKTtcbiAgICAgIH1cbiAgICAgIF90aGlzLmZpbmRFbmRwb2ludHMoX2VkZ2UpO1xuICAgICAgX3RoaXMudHJ5VG9Db3JyZWN0SW52YWxpZFBvaW50cyhfZWRnZSwgcGFzc2VkUGFpckluZm8pO1xuICAgICAgX3RoaXMuY2hlY2tGb3JJbnZhbGlkRWRnZVdhcm5pbmcoX2VkZ2UpO1xuICAgICAgX3RoaXMuc3RvcmVBbGxwdHMoX2VkZ2UpO1xuICAgICAgX3RoaXMuc3RvcmVFZGdlUHJvamVjdGlvbnMoX2VkZ2UpO1xuICAgICAgX3RoaXMuY2FsY3VsYXRlQXJyb3dBbmdsZXMoX2VkZ2UpO1xuICAgICAgX3RoaXMucmVjYWxjdWxhdGVFZGdlTGFiZWxQcm9qZWN0aW9ucyhfZWRnZSk7XG4gICAgICBfdGhpcy5jYWxjdWxhdGVMYWJlbEFuZ2xlcyhfZWRnZSk7XG4gICAgfSAvLyBmb3IgcGFpciBlZGdlc1xuICB9O1xuICBmb3IgKHZhciBwID0gMDsgcCA8IHBhaXJJZHMubGVuZ3RoOyBwKyspIHtcbiAgICBfbG9vcChwKTtcbiAgfSAvLyBmb3IgcGFpciBpZHNcblxuICAvLyBoYXlzdGFja3MgYXZvaWQgdGhlIGV4cGVuc2Ugb2YgcGFpckluZm8gc3R1ZmYgKGludGVyc2VjdGlvbnMgZXRjLilcbiAgdGhpcy5maW5kSGF5c3RhY2tQb2ludHMoaGF5c3RhY2tFZGdlcyk7XG59O1xuZnVuY3Rpb24gZ2V0UHRzKHB0cykge1xuICB2YXIgcmV0UHRzID0gW107XG4gIGlmIChwdHMgPT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHB0cy5sZW5ndGg7IGkgKz0gMikge1xuICAgIHZhciB4ID0gcHRzW2ldO1xuICAgIHZhciB5ID0gcHRzW2kgKyAxXTtcbiAgICByZXRQdHMucHVzaCh7XG4gICAgICB4OiB4LFxuICAgICAgeTogeVxuICAgIH0pO1xuICB9XG4gIHJldHVybiByZXRQdHM7XG59XG5CUnAkYy5nZXRTZWdtZW50UG9pbnRzID0gZnVuY3Rpb24gKGVkZ2UpIHtcbiAgdmFyIHJzID0gZWRnZVswXS5fcHJpdmF0ZS5yc2NyYXRjaDtcbiAgdGhpcy5yZWNhbGN1bGF0ZVJlbmRlcmVkU3R5bGUoZWRnZSk7XG4gIHZhciB0eXBlID0gcnMuZWRnZVR5cGU7XG4gIGlmICh0eXBlID09PSAnc2VnbWVudHMnKSB7XG4gICAgcmV0dXJuIGdldFB0cyhycy5zZWdwdHMpO1xuICB9XG59O1xuQlJwJGMuZ2V0Q29udHJvbFBvaW50cyA9IGZ1bmN0aW9uIChlZGdlKSB7XG4gIHZhciBycyA9IGVkZ2VbMF0uX3ByaXZhdGUucnNjcmF0Y2g7XG4gIHRoaXMucmVjYWxjdWxhdGVSZW5kZXJlZFN0eWxlKGVkZ2UpO1xuICB2YXIgdHlwZSA9IHJzLmVkZ2VUeXBlO1xuICBpZiAodHlwZSA9PT0gJ2JlemllcicgfHwgdHlwZSA9PT0gJ211bHRpYmV6aWVyJyB8fCB0eXBlID09PSAnc2VsZicgfHwgdHlwZSA9PT0gJ2NvbXBvdW5kJykge1xuICAgIHJldHVybiBnZXRQdHMocnMuY3RybHB0cyk7XG4gIH1cbn07XG5CUnAkYy5nZXRFZGdlTWlkcG9pbnQgPSBmdW5jdGlvbiAoZWRnZSkge1xuICB2YXIgcnMgPSBlZGdlWzBdLl9wcml2YXRlLnJzY3JhdGNoO1xuICB0aGlzLnJlY2FsY3VsYXRlUmVuZGVyZWRTdHlsZShlZGdlKTtcbiAgcmV0dXJuIHtcbiAgICB4OiBycy5taWRYLFxuICAgIHk6IHJzLm1pZFlcbiAgfTtcbn07XG5cbnZhciBCUnAkYiA9IHt9O1xuQlJwJGIubWFudWFsRW5kcHRUb1B4ID0gZnVuY3Rpb24gKG5vZGUsIHByb3ApIHtcbiAgdmFyIHIgPSB0aGlzO1xuICB2YXIgbnBvcyA9IG5vZGUucG9zaXRpb24oKTtcbiAgdmFyIHcgPSBub2RlLm91dGVyV2lkdGgoKTtcbiAgdmFyIGggPSBub2RlLm91dGVySGVpZ2h0KCk7XG4gIHZhciBycyA9IG5vZGUuX3ByaXZhdGUucnNjcmF0Y2g7XG4gIGlmIChwcm9wLnZhbHVlLmxlbmd0aCA9PT0gMikge1xuICAgIHZhciBwID0gW3Byb3AucGZWYWx1ZVswXSwgcHJvcC5wZlZhbHVlWzFdXTtcbiAgICBpZiAocHJvcC51bml0c1swXSA9PT0gJyUnKSB7XG4gICAgICBwWzBdID0gcFswXSAqIHc7XG4gICAgfVxuICAgIGlmIChwcm9wLnVuaXRzWzFdID09PSAnJScpIHtcbiAgICAgIHBbMV0gPSBwWzFdICogaDtcbiAgICB9XG4gICAgcFswXSArPSBucG9zLng7XG4gICAgcFsxXSArPSBucG9zLnk7XG4gICAgcmV0dXJuIHA7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGFuZ2xlID0gcHJvcC5wZlZhbHVlWzBdO1xuICAgIGFuZ2xlID0gLU1hdGguUEkgLyAyICsgYW5nbGU7IC8vIHN0YXJ0IGF0IDEyIG8nY2xvY2tcblxuICAgIHZhciBsID0gMiAqIE1hdGgubWF4KHcsIGgpO1xuICAgIHZhciBfcCA9IFtucG9zLnggKyBNYXRoLmNvcyhhbmdsZSkgKiBsLCBucG9zLnkgKyBNYXRoLnNpbihhbmdsZSkgKiBsXTtcbiAgICByZXR1cm4gci5ub2RlU2hhcGVzW3RoaXMuZ2V0Tm9kZVNoYXBlKG5vZGUpXS5pbnRlcnNlY3RMaW5lKG5wb3MueCwgbnBvcy55LCB3LCBoLCBfcFswXSwgX3BbMV0sIDAsIG5vZGUucHN0eWxlKCdjb3JuZXItcmFkaXVzJykudmFsdWUgPT09ICdhdXRvJyA/ICdhdXRvJyA6IG5vZGUucHN0eWxlKCdjb3JuZXItcmFkaXVzJykucGZWYWx1ZSwgcnMpO1xuICB9XG59O1xuQlJwJGIuZmluZEVuZHBvaW50cyA9IGZ1bmN0aW9uIChlZGdlKSB7XG4gIHZhciByID0gdGhpcztcbiAgdmFyIGludGVyc2VjdDtcbiAgdmFyIHNvdXJjZSA9IGVkZ2Uuc291cmNlKClbMF07XG4gIHZhciB0YXJnZXQgPSBlZGdlLnRhcmdldCgpWzBdO1xuICB2YXIgc3JjUG9zID0gc291cmNlLnBvc2l0aW9uKCk7XG4gIHZhciB0Z3RQb3MgPSB0YXJnZXQucG9zaXRpb24oKTtcbiAgdmFyIHRndEFyU2hhcGUgPSBlZGdlLnBzdHlsZSgndGFyZ2V0LWFycm93LXNoYXBlJykudmFsdWU7XG4gIHZhciBzcmNBclNoYXBlID0gZWRnZS5wc3R5bGUoJ3NvdXJjZS1hcnJvdy1zaGFwZScpLnZhbHVlO1xuICB2YXIgdGd0RGlzdCA9IGVkZ2UucHN0eWxlKCd0YXJnZXQtZGlzdGFuY2UtZnJvbS1ub2RlJykucGZWYWx1ZTtcbiAgdmFyIHNyY0Rpc3QgPSBlZGdlLnBzdHlsZSgnc291cmNlLWRpc3RhbmNlLWZyb20tbm9kZScpLnBmVmFsdWU7XG4gIHZhciBzcmNScyA9IHNvdXJjZS5fcHJpdmF0ZS5yc2NyYXRjaDtcbiAgdmFyIHRndFJzID0gdGFyZ2V0Ll9wcml2YXRlLnJzY3JhdGNoO1xuICB2YXIgY3VydmVTdHlsZSA9IGVkZ2UucHN0eWxlKCdjdXJ2ZS1zdHlsZScpLnZhbHVlO1xuICB2YXIgcnMgPSBlZGdlLl9wcml2YXRlLnJzY3JhdGNoO1xuICB2YXIgZXQgPSBycy5lZGdlVHlwZTtcbiAgdmFyIHRheGkgPSBjdXJ2ZVN0eWxlID09PSAndGF4aSc7XG4gIHZhciBzZWxmID0gZXQgPT09ICdzZWxmJyB8fCBldCA9PT0gJ2NvbXBvdW5kJztcbiAgdmFyIGJlemllciA9IGV0ID09PSAnYmV6aWVyJyB8fCBldCA9PT0gJ211bHRpYmV6aWVyJyB8fCBzZWxmO1xuICB2YXIgbXVsdGkgPSBldCAhPT0gJ2Jlemllcic7XG4gIHZhciBsaW5lcyA9IGV0ID09PSAnc3RyYWlnaHQnIHx8IGV0ID09PSAnc2VnbWVudHMnO1xuICB2YXIgc2VnbWVudHMgPSBldCA9PT0gJ3NlZ21lbnRzJztcbiAgdmFyIGhhc0VuZHB0cyA9IGJlemllciB8fCBtdWx0aSB8fCBsaW5lcztcbiAgdmFyIG92ZXJyaWRlRW5kcHRzID0gc2VsZiB8fCB0YXhpO1xuICB2YXIgc3JjTWFuRW5kcHQgPSBlZGdlLnBzdHlsZSgnc291cmNlLWVuZHBvaW50Jyk7XG4gIHZhciBzcmNNYW5FbmRwdFZhbCA9IG92ZXJyaWRlRW5kcHRzID8gJ291dHNpZGUtdG8tbm9kZScgOiBzcmNNYW5FbmRwdC52YWx1ZTtcbiAgdmFyIHNyY0Nvcm5lclJhZGl1cyA9IHNvdXJjZS5wc3R5bGUoJ2Nvcm5lci1yYWRpdXMnKS52YWx1ZSA9PT0gJ2F1dG8nID8gJ2F1dG8nIDogc291cmNlLnBzdHlsZSgnY29ybmVyLXJhZGl1cycpLnBmVmFsdWU7XG4gIHZhciB0Z3RNYW5FbmRwdCA9IGVkZ2UucHN0eWxlKCd0YXJnZXQtZW5kcG9pbnQnKTtcbiAgdmFyIHRndE1hbkVuZHB0VmFsID0gb3ZlcnJpZGVFbmRwdHMgPyAnb3V0c2lkZS10by1ub2RlJyA6IHRndE1hbkVuZHB0LnZhbHVlO1xuICB2YXIgdGd0Q29ybmVyUmFkaXVzID0gdGFyZ2V0LnBzdHlsZSgnY29ybmVyLXJhZGl1cycpLnZhbHVlID09PSAnYXV0bycgPyAnYXV0bycgOiB0YXJnZXQucHN0eWxlKCdjb3JuZXItcmFkaXVzJykucGZWYWx1ZTtcbiAgcnMuc3JjTWFuRW5kcHQgPSBzcmNNYW5FbmRwdDtcbiAgcnMudGd0TWFuRW5kcHQgPSB0Z3RNYW5FbmRwdDtcbiAgdmFyIHAxOyAvLyBsYXN0IGtub3duIHBvaW50IG9mIGVkZ2Ugb24gdGFyZ2V0IHNpZGVcbiAgdmFyIHAyOyAvLyBsYXN0IGtub3duIHBvaW50IG9mIGVkZ2Ugb24gc291cmNlIHNpZGVcblxuICB2YXIgcDFfaTsgLy8gcG9pbnQgdG8gaW50ZXJzZWN0IHdpdGggdGFyZ2V0IHNoYXBlXG4gIHZhciBwMl9pOyAvLyBwb2ludCB0byBpbnRlcnNlY3Qgd2l0aCBzb3VyY2Ugc2hhcGVcblxuICBpZiAoYmV6aWVyKSB7XG4gICAgdmFyIGNwU3RhcnQgPSBbcnMuY3RybHB0c1swXSwgcnMuY3RybHB0c1sxXV07XG4gICAgdmFyIGNwRW5kID0gbXVsdGkgPyBbcnMuY3RybHB0c1tycy5jdHJscHRzLmxlbmd0aCAtIDJdLCBycy5jdHJscHRzW3JzLmN0cmxwdHMubGVuZ3RoIC0gMV1dIDogY3BTdGFydDtcbiAgICBwMSA9IGNwRW5kO1xuICAgIHAyID0gY3BTdGFydDtcbiAgfSBlbHNlIGlmIChsaW5lcykge1xuICAgIHZhciBzcmNBcnJvd0Zyb21QdCA9ICFzZWdtZW50cyA/IFt0Z3RQb3MueCwgdGd0UG9zLnldIDogcnMuc2VncHRzLnNsaWNlKDAsIDIpO1xuICAgIHZhciB0Z3RBcnJvd0Zyb21QdCA9ICFzZWdtZW50cyA/IFtzcmNQb3MueCwgc3JjUG9zLnldIDogcnMuc2VncHRzLnNsaWNlKHJzLnNlZ3B0cy5sZW5ndGggLSAyKTtcbiAgICBwMSA9IHRndEFycm93RnJvbVB0O1xuICAgIHAyID0gc3JjQXJyb3dGcm9tUHQ7XG4gIH1cbiAgaWYgKHRndE1hbkVuZHB0VmFsID09PSAnaW5zaWRlLXRvLW5vZGUnKSB7XG4gICAgaW50ZXJzZWN0ID0gW3RndFBvcy54LCB0Z3RQb3MueV07XG4gIH0gZWxzZSBpZiAodGd0TWFuRW5kcHQudW5pdHMpIHtcbiAgICBpbnRlcnNlY3QgPSB0aGlzLm1hbnVhbEVuZHB0VG9QeCh0YXJnZXQsIHRndE1hbkVuZHB0KTtcbiAgfSBlbHNlIGlmICh0Z3RNYW5FbmRwdFZhbCA9PT0gJ291dHNpZGUtdG8tbGluZScpIHtcbiAgICBpbnRlcnNlY3QgPSBycy50Z3RJbnRuOyAvLyB1c2UgY2FjaGVkIHZhbHVlIGZyb20gY3RybHB0IGNhbGNcbiAgfSBlbHNlIHtcbiAgICBpZiAodGd0TWFuRW5kcHRWYWwgPT09ICdvdXRzaWRlLXRvLW5vZGUnIHx8IHRndE1hbkVuZHB0VmFsID09PSAnb3V0c2lkZS10by1ub2RlLW9yLWxhYmVsJykge1xuICAgICAgcDFfaSA9IHAxO1xuICAgIH0gZWxzZSBpZiAodGd0TWFuRW5kcHRWYWwgPT09ICdvdXRzaWRlLXRvLWxpbmUnIHx8IHRndE1hbkVuZHB0VmFsID09PSAnb3V0c2lkZS10by1saW5lLW9yLWxhYmVsJykge1xuICAgICAgcDFfaSA9IFtzcmNQb3MueCwgc3JjUG9zLnldO1xuICAgIH1cbiAgICBpbnRlcnNlY3QgPSByLm5vZGVTaGFwZXNbdGhpcy5nZXROb2RlU2hhcGUodGFyZ2V0KV0uaW50ZXJzZWN0TGluZSh0Z3RQb3MueCwgdGd0UG9zLnksIHRhcmdldC5vdXRlcldpZHRoKCksIHRhcmdldC5vdXRlckhlaWdodCgpLCBwMV9pWzBdLCBwMV9pWzFdLCAwLCB0Z3RDb3JuZXJSYWRpdXMsIHRndFJzKTtcbiAgICBpZiAodGd0TWFuRW5kcHRWYWwgPT09ICdvdXRzaWRlLXRvLW5vZGUtb3ItbGFiZWwnIHx8IHRndE1hbkVuZHB0VmFsID09PSAnb3V0c2lkZS10by1saW5lLW9yLWxhYmVsJykge1xuICAgICAgdmFyIHRycyA9IHRhcmdldC5fcHJpdmF0ZS5yc2NyYXRjaDtcbiAgICAgIHZhciBsdyA9IHRycy5sYWJlbFdpZHRoO1xuICAgICAgdmFyIGxoID0gdHJzLmxhYmVsSGVpZ2h0O1xuICAgICAgdmFyIGx4ID0gdHJzLmxhYmVsWDtcbiAgICAgIHZhciBseSA9IHRycy5sYWJlbFk7XG4gICAgICB2YXIgbHcyID0gbHcgLyAyO1xuICAgICAgdmFyIGxoMiA9IGxoIC8gMjtcbiAgICAgIHZhciB2YSA9IHRhcmdldC5wc3R5bGUoJ3RleHQtdmFsaWduJykudmFsdWU7XG4gICAgICBpZiAodmEgPT09ICd0b3AnKSB7XG4gICAgICAgIGx5IC09IGxoMjtcbiAgICAgIH0gZWxzZSBpZiAodmEgPT09ICdib3R0b20nKSB7XG4gICAgICAgIGx5ICs9IGxoMjtcbiAgICAgIH1cbiAgICAgIHZhciBoYSA9IHRhcmdldC5wc3R5bGUoJ3RleHQtaGFsaWduJykudmFsdWU7XG4gICAgICBpZiAoaGEgPT09ICdsZWZ0Jykge1xuICAgICAgICBseCAtPSBsdzI7XG4gICAgICB9IGVsc2UgaWYgKGhhID09PSAncmlnaHQnKSB7XG4gICAgICAgIGx4ICs9IGx3MjtcbiAgICAgIH1cbiAgICAgIHZhciBsYWJlbEludGVyc2VjdCA9IHBvbHlnb25JbnRlcnNlY3RMaW5lKHAxX2lbMF0sIHAxX2lbMV0sIFtseCAtIGx3MiwgbHkgLSBsaDIsIGx4ICsgbHcyLCBseSAtIGxoMiwgbHggKyBsdzIsIGx5ICsgbGgyLCBseCAtIGx3MiwgbHkgKyBsaDJdLCB0Z3RQb3MueCwgdGd0UG9zLnkpO1xuICAgICAgaWYgKGxhYmVsSW50ZXJzZWN0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgdmFyIHJlZlB0ID0gc3JjUG9zO1xuICAgICAgICB2YXIgaW50U3FkaXN0ID0gc3FkaXN0KHJlZlB0LCBhcnJheTJwb2ludChpbnRlcnNlY3QpKTtcbiAgICAgICAgdmFyIGxhYkludFNxZGlzdCA9IHNxZGlzdChyZWZQdCwgYXJyYXkycG9pbnQobGFiZWxJbnRlcnNlY3QpKTtcbiAgICAgICAgdmFyIG1pblNxRGlzdCA9IGludFNxZGlzdDtcbiAgICAgICAgaWYgKGxhYkludFNxZGlzdCA8IGludFNxZGlzdCkge1xuICAgICAgICAgIGludGVyc2VjdCA9IGxhYmVsSW50ZXJzZWN0O1xuICAgICAgICAgIG1pblNxRGlzdCA9IGxhYkludFNxZGlzdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGFiZWxJbnRlcnNlY3QubGVuZ3RoID4gMikge1xuICAgICAgICAgIHZhciBsYWJJbnQyU3FEaXN0ID0gc3FkaXN0KHJlZlB0LCB7XG4gICAgICAgICAgICB4OiBsYWJlbEludGVyc2VjdFsyXSxcbiAgICAgICAgICAgIHk6IGxhYmVsSW50ZXJzZWN0WzNdXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKGxhYkludDJTcURpc3QgPCBtaW5TcURpc3QpIHtcbiAgICAgICAgICAgIGludGVyc2VjdCA9IFtsYWJlbEludGVyc2VjdFsyXSwgbGFiZWxJbnRlcnNlY3RbM11dO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICB2YXIgYXJyb3dFbmQgPSBzaG9ydGVuSW50ZXJzZWN0aW9uKGludGVyc2VjdCwgcDEsIHIuYXJyb3dTaGFwZXNbdGd0QXJTaGFwZV0uc3BhY2luZyhlZGdlKSArIHRndERpc3QpO1xuICB2YXIgZWRnZUVuZCA9IHNob3J0ZW5JbnRlcnNlY3Rpb24oaW50ZXJzZWN0LCBwMSwgci5hcnJvd1NoYXBlc1t0Z3RBclNoYXBlXS5nYXAoZWRnZSkgKyB0Z3REaXN0KTtcbiAgcnMuZW5kWCA9IGVkZ2VFbmRbMF07XG4gIHJzLmVuZFkgPSBlZGdlRW5kWzFdO1xuICBycy5hcnJvd0VuZFggPSBhcnJvd0VuZFswXTtcbiAgcnMuYXJyb3dFbmRZID0gYXJyb3dFbmRbMV07XG4gIGlmIChzcmNNYW5FbmRwdFZhbCA9PT0gJ2luc2lkZS10by1ub2RlJykge1xuICAgIGludGVyc2VjdCA9IFtzcmNQb3MueCwgc3JjUG9zLnldO1xuICB9IGVsc2UgaWYgKHNyY01hbkVuZHB0LnVuaXRzKSB7XG4gICAgaW50ZXJzZWN0ID0gdGhpcy5tYW51YWxFbmRwdFRvUHgoc291cmNlLCBzcmNNYW5FbmRwdCk7XG4gIH0gZWxzZSBpZiAoc3JjTWFuRW5kcHRWYWwgPT09ICdvdXRzaWRlLXRvLWxpbmUnKSB7XG4gICAgaW50ZXJzZWN0ID0gcnMuc3JjSW50bjsgLy8gdXNlIGNhY2hlZCB2YWx1ZSBmcm9tIGN0cmxwdCBjYWxjXG4gIH0gZWxzZSB7XG4gICAgaWYgKHNyY01hbkVuZHB0VmFsID09PSAnb3V0c2lkZS10by1ub2RlJyB8fCBzcmNNYW5FbmRwdFZhbCA9PT0gJ291dHNpZGUtdG8tbm9kZS1vci1sYWJlbCcpIHtcbiAgICAgIHAyX2kgPSBwMjtcbiAgICB9IGVsc2UgaWYgKHNyY01hbkVuZHB0VmFsID09PSAnb3V0c2lkZS10by1saW5lJyB8fCBzcmNNYW5FbmRwdFZhbCA9PT0gJ291dHNpZGUtdG8tbGluZS1vci1sYWJlbCcpIHtcbiAgICAgIHAyX2kgPSBbdGd0UG9zLngsIHRndFBvcy55XTtcbiAgICB9XG4gICAgaW50ZXJzZWN0ID0gci5ub2RlU2hhcGVzW3RoaXMuZ2V0Tm9kZVNoYXBlKHNvdXJjZSldLmludGVyc2VjdExpbmUoc3JjUG9zLngsIHNyY1Bvcy55LCBzb3VyY2Uub3V0ZXJXaWR0aCgpLCBzb3VyY2Uub3V0ZXJIZWlnaHQoKSwgcDJfaVswXSwgcDJfaVsxXSwgMCwgc3JjQ29ybmVyUmFkaXVzLCBzcmNScyk7XG4gICAgaWYgKHNyY01hbkVuZHB0VmFsID09PSAnb3V0c2lkZS10by1ub2RlLW9yLWxhYmVsJyB8fCBzcmNNYW5FbmRwdFZhbCA9PT0gJ291dHNpZGUtdG8tbGluZS1vci1sYWJlbCcpIHtcbiAgICAgIHZhciBzcnMgPSBzb3VyY2UuX3ByaXZhdGUucnNjcmF0Y2g7XG4gICAgICB2YXIgX2x3ID0gc3JzLmxhYmVsV2lkdGg7XG4gICAgICB2YXIgX2xoID0gc3JzLmxhYmVsSGVpZ2h0O1xuICAgICAgdmFyIF9seCA9IHNycy5sYWJlbFg7XG4gICAgICB2YXIgX2x5ID0gc3JzLmxhYmVsWTtcbiAgICAgIHZhciBfbHcyID0gX2x3IC8gMjtcbiAgICAgIHZhciBfbGgyID0gX2xoIC8gMjtcbiAgICAgIHZhciBfdmEgPSBzb3VyY2UucHN0eWxlKCd0ZXh0LXZhbGlnbicpLnZhbHVlO1xuICAgICAgaWYgKF92YSA9PT0gJ3RvcCcpIHtcbiAgICAgICAgX2x5IC09IF9saDI7XG4gICAgICB9IGVsc2UgaWYgKF92YSA9PT0gJ2JvdHRvbScpIHtcbiAgICAgICAgX2x5ICs9IF9saDI7XG4gICAgICB9XG4gICAgICB2YXIgX2hhID0gc291cmNlLnBzdHlsZSgndGV4dC1oYWxpZ24nKS52YWx1ZTtcbiAgICAgIGlmIChfaGEgPT09ICdsZWZ0Jykge1xuICAgICAgICBfbHggLT0gX2x3MjtcbiAgICAgIH0gZWxzZSBpZiAoX2hhID09PSAncmlnaHQnKSB7XG4gICAgICAgIF9seCArPSBfbHcyO1xuICAgICAgfVxuICAgICAgdmFyIF9sYWJlbEludGVyc2VjdCA9IHBvbHlnb25JbnRlcnNlY3RMaW5lKHAyX2lbMF0sIHAyX2lbMV0sIFtfbHggLSBfbHcyLCBfbHkgLSBfbGgyLCBfbHggKyBfbHcyLCBfbHkgLSBfbGgyLCBfbHggKyBfbHcyLCBfbHkgKyBfbGgyLCBfbHggLSBfbHcyLCBfbHkgKyBfbGgyXSwgc3JjUG9zLngsIHNyY1Bvcy55KTtcbiAgICAgIGlmIChfbGFiZWxJbnRlcnNlY3QubGVuZ3RoID4gMCkge1xuICAgICAgICB2YXIgX3JlZlB0ID0gdGd0UG9zO1xuICAgICAgICB2YXIgX2ludFNxZGlzdCA9IHNxZGlzdChfcmVmUHQsIGFycmF5MnBvaW50KGludGVyc2VjdCkpO1xuICAgICAgICB2YXIgX2xhYkludFNxZGlzdCA9IHNxZGlzdChfcmVmUHQsIGFycmF5MnBvaW50KF9sYWJlbEludGVyc2VjdCkpO1xuICAgICAgICB2YXIgX21pblNxRGlzdCA9IF9pbnRTcWRpc3Q7XG4gICAgICAgIGlmIChfbGFiSW50U3FkaXN0IDwgX2ludFNxZGlzdCkge1xuICAgICAgICAgIGludGVyc2VjdCA9IFtfbGFiZWxJbnRlcnNlY3RbMF0sIF9sYWJlbEludGVyc2VjdFsxXV07XG4gICAgICAgICAgX21pblNxRGlzdCA9IF9sYWJJbnRTcWRpc3Q7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKF9sYWJlbEludGVyc2VjdC5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgdmFyIF9sYWJJbnQyU3FEaXN0ID0gc3FkaXN0KF9yZWZQdCwge1xuICAgICAgICAgICAgeDogX2xhYmVsSW50ZXJzZWN0WzJdLFxuICAgICAgICAgICAgeTogX2xhYmVsSW50ZXJzZWN0WzNdXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKF9sYWJJbnQyU3FEaXN0IDwgX21pblNxRGlzdCkge1xuICAgICAgICAgICAgaW50ZXJzZWN0ID0gW19sYWJlbEludGVyc2VjdFsyXSwgX2xhYmVsSW50ZXJzZWN0WzNdXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgdmFyIGFycm93U3RhcnQgPSBzaG9ydGVuSW50ZXJzZWN0aW9uKGludGVyc2VjdCwgcDIsIHIuYXJyb3dTaGFwZXNbc3JjQXJTaGFwZV0uc3BhY2luZyhlZGdlKSArIHNyY0Rpc3QpO1xuICB2YXIgZWRnZVN0YXJ0ID0gc2hvcnRlbkludGVyc2VjdGlvbihpbnRlcnNlY3QsIHAyLCByLmFycm93U2hhcGVzW3NyY0FyU2hhcGVdLmdhcChlZGdlKSArIHNyY0Rpc3QpO1xuICBycy5zdGFydFggPSBlZGdlU3RhcnRbMF07XG4gIHJzLnN0YXJ0WSA9IGVkZ2VTdGFydFsxXTtcbiAgcnMuYXJyb3dTdGFydFggPSBhcnJvd1N0YXJ0WzBdO1xuICBycy5hcnJvd1N0YXJ0WSA9IGFycm93U3RhcnRbMV07XG4gIGlmIChoYXNFbmRwdHMpIHtcbiAgICBpZiAoIW51bWJlciQxKHJzLnN0YXJ0WCkgfHwgIW51bWJlciQxKHJzLnN0YXJ0WSkgfHwgIW51bWJlciQxKHJzLmVuZFgpIHx8ICFudW1iZXIkMShycy5lbmRZKSkge1xuICAgICAgcnMuYmFkTGluZSA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJzLmJhZExpbmUgPSBmYWxzZTtcbiAgICB9XG4gIH1cbn07XG5CUnAkYi5nZXRTb3VyY2VFbmRwb2ludCA9IGZ1bmN0aW9uIChlZGdlKSB7XG4gIHZhciBycyA9IGVkZ2VbMF0uX3ByaXZhdGUucnNjcmF0Y2g7XG4gIHRoaXMucmVjYWxjdWxhdGVSZW5kZXJlZFN0eWxlKGVkZ2UpO1xuICBzd2l0Y2ggKHJzLmVkZ2VUeXBlKSB7XG4gICAgY2FzZSAnaGF5c3RhY2snOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogcnMuaGF5c3RhY2tQdHNbMF0sXG4gICAgICAgIHk6IHJzLmhheXN0YWNrUHRzWzFdXG4gICAgICB9O1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiBycy5hcnJvd1N0YXJ0WCxcbiAgICAgICAgeTogcnMuYXJyb3dTdGFydFlcbiAgICAgIH07XG4gIH1cbn07XG5CUnAkYi5nZXRUYXJnZXRFbmRwb2ludCA9IGZ1bmN0aW9uIChlZGdlKSB7XG4gIHZhciBycyA9IGVkZ2VbMF0uX3ByaXZhdGUucnNjcmF0Y2g7XG4gIHRoaXMucmVjYWxjdWxhdGVSZW5kZXJlZFN0eWxlKGVkZ2UpO1xuICBzd2l0Y2ggKHJzLmVkZ2VUeXBlKSB7XG4gICAgY2FzZSAnaGF5c3RhY2snOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogcnMuaGF5c3RhY2tQdHNbMl0sXG4gICAgICAgIHk6IHJzLmhheXN0YWNrUHRzWzNdXG4gICAgICB9O1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiBycy5hcnJvd0VuZFgsXG4gICAgICAgIHk6IHJzLmFycm93RW5kWVxuICAgICAgfTtcbiAgfVxufTtcblxudmFyIEJScCRhID0ge307XG5mdW5jdGlvbiBwdXNoQmV6aWVyUHRzKHIsIGVkZ2UsIHB0cykge1xuICB2YXIgcWJlemllckF0JDEgPSBmdW5jdGlvbiBxYmV6aWVyQXQkMShwMSwgcDIsIHAzLCB0KSB7XG4gICAgcmV0dXJuIHFiZXppZXJBdChwMSwgcDIsIHAzLCB0KTtcbiAgfTtcbiAgdmFyIF9wID0gZWRnZS5fcHJpdmF0ZTtcbiAgdmFyIGJwdHMgPSBfcC5yc3R5bGUuYmV6aWVyUHRzO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHIuYmV6aWVyUHJvalBjdHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcCA9IHIuYmV6aWVyUHJvalBjdHNbaV07XG4gICAgYnB0cy5wdXNoKHtcbiAgICAgIHg6IHFiZXppZXJBdCQxKHB0c1swXSwgcHRzWzJdLCBwdHNbNF0sIHApLFxuICAgICAgeTogcWJlemllckF0JDEocHRzWzFdLCBwdHNbM10sIHB0c1s1XSwgcClcbiAgICB9KTtcbiAgfVxufVxuQlJwJGEuc3RvcmVFZGdlUHJvamVjdGlvbnMgPSBmdW5jdGlvbiAoZWRnZSkge1xuICB2YXIgX3AgPSBlZGdlLl9wcml2YXRlO1xuICB2YXIgcnMgPSBfcC5yc2NyYXRjaDtcbiAgdmFyIGV0ID0gcnMuZWRnZVR5cGU7XG5cbiAgLy8gY2xlYXIgdGhlIGNhY2hlZCBwb2ludHMgc3RhdGVcbiAgX3AucnN0eWxlLmJlemllclB0cyA9IG51bGw7XG4gIF9wLnJzdHlsZS5saW5lUHRzID0gbnVsbDtcbiAgX3AucnN0eWxlLmhheXN0YWNrUHRzID0gbnVsbDtcbiAgaWYgKGV0ID09PSAnbXVsdGliZXppZXInIHx8IGV0ID09PSAnYmV6aWVyJyB8fCBldCA9PT0gJ3NlbGYnIHx8IGV0ID09PSAnY29tcG91bmQnKSB7XG4gICAgX3AucnN0eWxlLmJlemllclB0cyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpICsgNSA8IHJzLmFsbHB0cy5sZW5ndGg7IGkgKz0gNCkge1xuICAgICAgcHVzaEJlemllclB0cyh0aGlzLCBlZGdlLCBycy5hbGxwdHMuc2xpY2UoaSwgaSArIDYpKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZXQgPT09ICdzZWdtZW50cycpIHtcbiAgICB2YXIgbHB0cyA9IF9wLnJzdHlsZS5saW5lUHRzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgKyAxIDwgcnMuYWxscHRzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICBscHRzLnB1c2goe1xuICAgICAgICB4OiBycy5hbGxwdHNbaV0sXG4gICAgICAgIHk6IHJzLmFsbHB0c1tpICsgMV1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSBlbHNlIGlmIChldCA9PT0gJ2hheXN0YWNrJykge1xuICAgIHZhciBocHRzID0gcnMuaGF5c3RhY2tQdHM7XG4gICAgX3AucnN0eWxlLmhheXN0YWNrUHRzID0gW3tcbiAgICAgIHg6IGhwdHNbMF0sXG4gICAgICB5OiBocHRzWzFdXG4gICAgfSwge1xuICAgICAgeDogaHB0c1syXSxcbiAgICAgIHk6IGhwdHNbM11cbiAgICB9XTtcbiAgfVxuICBfcC5yc3R5bGUuYXJyb3dXaWR0aCA9IHRoaXMuZ2V0QXJyb3dXaWR0aChlZGdlLnBzdHlsZSgnd2lkdGgnKS5wZlZhbHVlLCBlZGdlLnBzdHlsZSgnYXJyb3ctc2NhbGUnKS52YWx1ZSkgKiB0aGlzLmFycm93U2hhcGVXaWR0aDtcbn07XG5CUnAkYS5yZWNhbGN1bGF0ZUVkZ2VQcm9qZWN0aW9ucyA9IGZ1bmN0aW9uIChlZGdlcykge1xuICB0aGlzLmZpbmRFZGdlQ29udHJvbFBvaW50cyhlZGdlcyk7XG59O1xuXG52YXIgQlJwJDkgPSB7fTtcbkJScCQ5LnJlY2FsY3VsYXRlTm9kZUxhYmVsUHJvamVjdGlvbiA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIHZhciBjb250ZW50ID0gbm9kZS5wc3R5bGUoJ2xhYmVsJykuc3RyVmFsdWU7XG4gIGlmIChlbXB0eVN0cmluZyhjb250ZW50KSkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgdGV4dFgsIHRleHRZO1xuICB2YXIgX3AgPSBub2RlLl9wcml2YXRlO1xuICB2YXIgbm9kZVdpZHRoID0gbm9kZS53aWR0aCgpO1xuICB2YXIgbm9kZUhlaWdodCA9IG5vZGUuaGVpZ2h0KCk7XG4gIHZhciBwYWRkaW5nID0gbm9kZS5wYWRkaW5nKCk7XG4gIHZhciBub2RlUG9zID0gbm9kZS5wb3NpdGlvbigpO1xuICB2YXIgdGV4dEhhbGlnbiA9IG5vZGUucHN0eWxlKCd0ZXh0LWhhbGlnbicpLnN0clZhbHVlO1xuICB2YXIgdGV4dFZhbGlnbiA9IG5vZGUucHN0eWxlKCd0ZXh0LXZhbGlnbicpLnN0clZhbHVlO1xuICB2YXIgcnMgPSBfcC5yc2NyYXRjaDtcbiAgdmFyIHJzdHlsZSA9IF9wLnJzdHlsZTtcbiAgc3dpdGNoICh0ZXh0SGFsaWduKSB7XG4gICAgY2FzZSAnbGVmdCc6XG4gICAgICB0ZXh0WCA9IG5vZGVQb3MueCAtIG5vZGVXaWR0aCAvIDIgLSBwYWRkaW5nO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAncmlnaHQnOlxuICAgICAgdGV4dFggPSBub2RlUG9zLnggKyBub2RlV2lkdGggLyAyICsgcGFkZGluZztcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICAvLyBlLmcuIGNlbnRlclxuICAgICAgdGV4dFggPSBub2RlUG9zLng7XG4gIH1cbiAgc3dpdGNoICh0ZXh0VmFsaWduKSB7XG4gICAgY2FzZSAndG9wJzpcbiAgICAgIHRleHRZID0gbm9kZVBvcy55IC0gbm9kZUhlaWdodCAvIDIgLSBwYWRkaW5nO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnYm90dG9tJzpcbiAgICAgIHRleHRZID0gbm9kZVBvcy55ICsgbm9kZUhlaWdodCAvIDIgKyBwYWRkaW5nO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIC8vIGUuZy4gbWlkZGxlXG4gICAgICB0ZXh0WSA9IG5vZGVQb3MueTtcbiAgfVxuICBycy5sYWJlbFggPSB0ZXh0WDtcbiAgcnMubGFiZWxZID0gdGV4dFk7XG4gIHJzdHlsZS5sYWJlbFggPSB0ZXh0WDtcbiAgcnN0eWxlLmxhYmVsWSA9IHRleHRZO1xuICB0aGlzLmNhbGN1bGF0ZUxhYmVsQW5nbGVzKG5vZGUpO1xuICB0aGlzLmFwcGx5TGFiZWxEaW1lbnNpb25zKG5vZGUpO1xufTtcbnZhciBsaW5lQW5nbGVGcm9tRGVsdGEgPSBmdW5jdGlvbiBsaW5lQW5nbGVGcm9tRGVsdGEoZHgsIGR5KSB7XG4gIHZhciBhbmdsZSA9IE1hdGguYXRhbihkeSAvIGR4KTtcbiAgaWYgKGR4ID09PSAwICYmIGFuZ2xlIDwgMCkge1xuICAgIGFuZ2xlID0gYW5nbGUgKiAtMTtcbiAgfVxuICByZXR1cm4gYW5nbGU7XG59O1xudmFyIGxpbmVBbmdsZSA9IGZ1bmN0aW9uIGxpbmVBbmdsZShwMCwgcDEpIHtcbiAgdmFyIGR4ID0gcDEueCAtIHAwLng7XG4gIHZhciBkeSA9IHAxLnkgLSBwMC55O1xuICByZXR1cm4gbGluZUFuZ2xlRnJvbURlbHRhKGR4LCBkeSk7XG59O1xudmFyIGJlemllckFuZ2xlID0gZnVuY3Rpb24gYmV6aWVyQW5nbGUocDAsIHAxLCBwMiwgdCkge1xuICB2YXIgdDAgPSBib3VuZCgwLCB0IC0gMC4wMDEsIDEpO1xuICB2YXIgdDEgPSBib3VuZCgwLCB0ICsgMC4wMDEsIDEpO1xuICB2YXIgbHAwID0gcWJlemllclB0QXQocDAsIHAxLCBwMiwgdDApO1xuICB2YXIgbHAxID0gcWJlemllclB0QXQocDAsIHAxLCBwMiwgdDEpO1xuICByZXR1cm4gbGluZUFuZ2xlKGxwMCwgbHAxKTtcbn07XG5CUnAkOS5yZWNhbGN1bGF0ZUVkZ2VMYWJlbFByb2plY3Rpb25zID0gZnVuY3Rpb24gKGVkZ2UpIHtcbiAgdmFyIHA7XG4gIHZhciBfcCA9IGVkZ2UuX3ByaXZhdGU7XG4gIHZhciBycyA9IF9wLnJzY3JhdGNoO1xuICB2YXIgciA9IHRoaXM7XG4gIHZhciBjb250ZW50ID0ge1xuICAgIG1pZDogZWRnZS5wc3R5bGUoJ2xhYmVsJykuc3RyVmFsdWUsXG4gICAgc291cmNlOiBlZGdlLnBzdHlsZSgnc291cmNlLWxhYmVsJykuc3RyVmFsdWUsXG4gICAgdGFyZ2V0OiBlZGdlLnBzdHlsZSgndGFyZ2V0LWxhYmVsJykuc3RyVmFsdWVcbiAgfTtcbiAgaWYgKGNvbnRlbnQubWlkIHx8IGNvbnRlbnQuc291cmNlIHx8IGNvbnRlbnQudGFyZ2V0KSA7IGVsc2Uge1xuICAgIHJldHVybjsgLy8gbm8gbGFiZWxzID0+IG5vIGNhbGNzXG4gIH1cblxuICAvLyBhZGQgY2VudGVyIHBvaW50IHRvIHN0eWxlIHNvIGJvdW5kaW5nIGJveCBjYWxjdWxhdGlvbnMgY2FuIHVzZSBpdFxuICAvL1xuICBwID0ge1xuICAgIHg6IHJzLm1pZFgsXG4gICAgeTogcnMubWlkWVxuICB9O1xuICB2YXIgc2V0UnMgPSBmdW5jdGlvbiBzZXRScyhwcm9wTmFtZSwgcHJlZml4LCB2YWx1ZSkge1xuICAgIHNldFByZWZpeGVkUHJvcGVydHkoX3AucnNjcmF0Y2gsIHByb3BOYW1lLCBwcmVmaXgsIHZhbHVlKTtcbiAgICBzZXRQcmVmaXhlZFByb3BlcnR5KF9wLnJzdHlsZSwgcHJvcE5hbWUsIHByZWZpeCwgdmFsdWUpO1xuICB9O1xuICBzZXRScygnbGFiZWxYJywgbnVsbCwgcC54KTtcbiAgc2V0UnMoJ2xhYmVsWScsIG51bGwsIHAueSk7XG4gIHZhciBtaWRBbmdsZSA9IGxpbmVBbmdsZUZyb21EZWx0YShycy5taWREaXNwWCwgcnMubWlkRGlzcFkpO1xuICBzZXRScygnbGFiZWxBdXRvQW5nbGUnLCBudWxsLCBtaWRBbmdsZSk7XG4gIHZhciBjcmVhdGVDb250cm9sUG9pbnRJbmZvID0gZnVuY3Rpb24gY3JlYXRlQ29udHJvbFBvaW50SW5mbygpIHtcbiAgICBpZiAoY3JlYXRlQ29udHJvbFBvaW50SW5mby5jYWNoZSkge1xuICAgICAgcmV0dXJuIGNyZWF0ZUNvbnRyb2xQb2ludEluZm8uY2FjaGU7XG4gICAgfSAvLyB1c2UgY2FjaGUgc28gb25seSAxeCBwZXIgZWRnZVxuXG4gICAgdmFyIGN0cmxwdHMgPSBbXTtcblxuICAgIC8vIHN0b3JlIGVhY2ggY3RybHB0IGluZm8gaW5pdFxuICAgIGZvciAodmFyIGkgPSAwOyBpICsgNSA8IHJzLmFsbHB0cy5sZW5ndGg7IGkgKz0gNCkge1xuICAgICAgdmFyIHAwID0ge1xuICAgICAgICB4OiBycy5hbGxwdHNbaV0sXG4gICAgICAgIHk6IHJzLmFsbHB0c1tpICsgMV1cbiAgICAgIH07XG4gICAgICB2YXIgcDEgPSB7XG4gICAgICAgIHg6IHJzLmFsbHB0c1tpICsgMl0sXG4gICAgICAgIHk6IHJzLmFsbHB0c1tpICsgM11cbiAgICAgIH07IC8vIGN0cmxwdFxuICAgICAgdmFyIHAyID0ge1xuICAgICAgICB4OiBycy5hbGxwdHNbaSArIDRdLFxuICAgICAgICB5OiBycy5hbGxwdHNbaSArIDVdXG4gICAgICB9O1xuICAgICAgY3RybHB0cy5wdXNoKHtcbiAgICAgICAgcDA6IHAwLFxuICAgICAgICBwMTogcDEsXG4gICAgICAgIHAyOiBwMixcbiAgICAgICAgc3RhcnREaXN0OiAwLFxuICAgICAgICBsZW5ndGg6IDAsXG4gICAgICAgIHNlZ21lbnRzOiBbXVxuICAgICAgfSk7XG4gICAgfVxuICAgIHZhciBicHRzID0gX3AucnN0eWxlLmJlemllclB0cztcbiAgICB2YXIgblByb2pzID0gci5iZXppZXJQcm9qUGN0cy5sZW5ndGg7XG4gICAgZnVuY3Rpb24gYWRkU2VnbWVudChjcCwgcDAsIHAxLCB0MCwgdDEpIHtcbiAgICAgIHZhciBsZW5ndGggPSBkaXN0KHAwLCBwMSk7XG4gICAgICB2YXIgcHJldlNlZ21lbnQgPSBjcC5zZWdtZW50c1tjcC5zZWdtZW50cy5sZW5ndGggLSAxXTtcbiAgICAgIHZhciBzZWdtZW50ID0ge1xuICAgICAgICBwMDogcDAsXG4gICAgICAgIHAxOiBwMSxcbiAgICAgICAgdDA6IHQwLFxuICAgICAgICB0MTogdDEsXG4gICAgICAgIHN0YXJ0RGlzdDogcHJldlNlZ21lbnQgPyBwcmV2U2VnbWVudC5zdGFydERpc3QgKyBwcmV2U2VnbWVudC5sZW5ndGggOiAwLFxuICAgICAgICBsZW5ndGg6IGxlbmd0aFxuICAgICAgfTtcbiAgICAgIGNwLnNlZ21lbnRzLnB1c2goc2VnbWVudCk7XG4gICAgICBjcC5sZW5ndGggKz0gbGVuZ3RoO1xuICAgIH1cblxuICAgIC8vIHVwZGF0ZSBlYWNoIGN0cmxwdCB3aXRoIHNlZ21lbnQgaW5mb1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBjdHJscHRzLmxlbmd0aDsgX2krKykge1xuICAgICAgdmFyIGNwID0gY3RybHB0c1tfaV07XG4gICAgICB2YXIgcHJldkNwID0gY3RybHB0c1tfaSAtIDFdO1xuICAgICAgaWYgKHByZXZDcCkge1xuICAgICAgICBjcC5zdGFydERpc3QgPSBwcmV2Q3Auc3RhcnREaXN0ICsgcHJldkNwLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIGFkZFNlZ21lbnQoY3AsIGNwLnAwLCBicHRzW19pICogblByb2pzXSwgMCwgci5iZXppZXJQcm9qUGN0c1swXSk7IC8vIGZpcnN0XG5cbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgblByb2pzIC0gMTsgaisrKSB7XG4gICAgICAgIGFkZFNlZ21lbnQoY3AsIGJwdHNbX2kgKiBuUHJvanMgKyBqXSwgYnB0c1tfaSAqIG5Qcm9qcyArIGogKyAxXSwgci5iZXppZXJQcm9qUGN0c1tqXSwgci5iZXppZXJQcm9qUGN0c1tqICsgMV0pO1xuICAgICAgfVxuICAgICAgYWRkU2VnbWVudChjcCwgYnB0c1tfaSAqIG5Qcm9qcyArIG5Qcm9qcyAtIDFdLCBjcC5wMiwgci5iZXppZXJQcm9qUGN0c1tuUHJvanMgLSAxXSwgMSk7IC8vIGxhc3RcbiAgICB9XG5cbiAgICByZXR1cm4gY3JlYXRlQ29udHJvbFBvaW50SW5mby5jYWNoZSA9IGN0cmxwdHM7XG4gIH07XG4gIHZhciBjYWxjdWxhdGVFbmRQcm9qZWN0aW9uID0gZnVuY3Rpb24gY2FsY3VsYXRlRW5kUHJvamVjdGlvbihwcmVmaXgpIHtcbiAgICB2YXIgYW5nbGU7XG4gICAgdmFyIGlzU3JjID0gcHJlZml4ID09PSAnc291cmNlJztcbiAgICBpZiAoIWNvbnRlbnRbcHJlZml4XSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgb2Zmc2V0ID0gZWRnZS5wc3R5bGUocHJlZml4ICsgJy10ZXh0LW9mZnNldCcpLnBmVmFsdWU7XG4gICAgc3dpdGNoIChycy5lZGdlVHlwZSkge1xuICAgICAgY2FzZSAnc2VsZic6XG4gICAgICBjYXNlICdjb21wb3VuZCc6XG4gICAgICBjYXNlICdiZXppZXInOlxuICAgICAgY2FzZSAnbXVsdGliZXppZXInOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGNwcyA9IGNyZWF0ZUNvbnRyb2xQb2ludEluZm8oKTtcbiAgICAgICAgICB2YXIgc2VsZWN0ZWQ7XG4gICAgICAgICAgdmFyIHN0YXJ0RGlzdCA9IDA7XG4gICAgICAgICAgdmFyIHRvdGFsRGlzdCA9IDA7XG5cbiAgICAgICAgICAvLyBmaW5kIHRoZSBzZWdtZW50IHdlJ3JlIG9uXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBfY3AgPSBjcHNbaXNTcmMgPyBpIDogY3BzLmxlbmd0aCAtIDEgLSBpXTtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgX2NwLnNlZ21lbnRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgIHZhciBfc2VnID0gX2NwLnNlZ21lbnRzW2lzU3JjID8gaiA6IF9jcC5zZWdtZW50cy5sZW5ndGggLSAxIC0gal07XG4gICAgICAgICAgICAgIHZhciBsYXN0U2VnID0gaSA9PT0gY3BzLmxlbmd0aCAtIDEgJiYgaiA9PT0gX2NwLnNlZ21lbnRzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgIHN0YXJ0RGlzdCA9IHRvdGFsRGlzdDtcbiAgICAgICAgICAgICAgdG90YWxEaXN0ICs9IF9zZWcubGVuZ3RoO1xuICAgICAgICAgICAgICBpZiAodG90YWxEaXN0ID49IG9mZnNldCB8fCBsYXN0U2VnKSB7XG4gICAgICAgICAgICAgICAgc2VsZWN0ZWQgPSB7XG4gICAgICAgICAgICAgICAgICBjcDogX2NwLFxuICAgICAgICAgICAgICAgICAgc2VnbWVudDogX3NlZ1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZWxlY3RlZCkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGNwID0gc2VsZWN0ZWQuY3A7XG4gICAgICAgICAgdmFyIHNlZyA9IHNlbGVjdGVkLnNlZ21lbnQ7XG4gICAgICAgICAgdmFyIHRTZWdtZW50ID0gKG9mZnNldCAtIHN0YXJ0RGlzdCkgLyBzZWcubGVuZ3RoO1xuICAgICAgICAgIHZhciBzZWdEdCA9IHNlZy50MSAtIHNlZy50MDtcbiAgICAgICAgICB2YXIgdCA9IGlzU3JjID8gc2VnLnQwICsgc2VnRHQgKiB0U2VnbWVudCA6IHNlZy50MSAtIHNlZ0R0ICogdFNlZ21lbnQ7XG4gICAgICAgICAgdCA9IGJvdW5kKDAsIHQsIDEpO1xuICAgICAgICAgIHAgPSBxYmV6aWVyUHRBdChjcC5wMCwgY3AucDEsIGNwLnAyLCB0KTtcbiAgICAgICAgICBhbmdsZSA9IGJlemllckFuZ2xlKGNwLnAwLCBjcC5wMSwgY3AucDIsIHQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICBjYXNlICdzdHJhaWdodCc6XG4gICAgICBjYXNlICdzZWdtZW50cyc6XG4gICAgICBjYXNlICdoYXlzdGFjayc6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgZCA9IDAsXG4gICAgICAgICAgICBkaSxcbiAgICAgICAgICAgIGQwO1xuICAgICAgICAgIHZhciBwMCwgcDE7XG4gICAgICAgICAgdmFyIGwgPSBycy5hbGxwdHMubGVuZ3RoO1xuICAgICAgICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiArIDMgPCBsOyBfaTIgKz0gMikge1xuICAgICAgICAgICAgaWYgKGlzU3JjKSB7XG4gICAgICAgICAgICAgIHAwID0ge1xuICAgICAgICAgICAgICAgIHg6IHJzLmFsbHB0c1tfaTJdLFxuICAgICAgICAgICAgICAgIHk6IHJzLmFsbHB0c1tfaTIgKyAxXVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBwMSA9IHtcbiAgICAgICAgICAgICAgICB4OiBycy5hbGxwdHNbX2kyICsgMl0sXG4gICAgICAgICAgICAgICAgeTogcnMuYWxscHRzW19pMiArIDNdXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBwMCA9IHtcbiAgICAgICAgICAgICAgICB4OiBycy5hbGxwdHNbbCAtIDIgLSBfaTJdLFxuICAgICAgICAgICAgICAgIHk6IHJzLmFsbHB0c1tsIC0gMSAtIF9pMl1cbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgcDEgPSB7XG4gICAgICAgICAgICAgICAgeDogcnMuYWxscHRzW2wgLSA0IC0gX2kyXSxcbiAgICAgICAgICAgICAgICB5OiBycy5hbGxwdHNbbCAtIDMgLSBfaTJdXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkaSA9IGRpc3QocDAsIHAxKTtcbiAgICAgICAgICAgIGQwID0gZDtcbiAgICAgICAgICAgIGQgKz0gZGk7XG4gICAgICAgICAgICBpZiAoZCA+PSBvZmZzZXQpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBwRCA9IG9mZnNldCAtIGQwO1xuICAgICAgICAgIHZhciBfdCA9IHBEIC8gZGk7XG4gICAgICAgICAgX3QgPSBib3VuZCgwLCBfdCwgMSk7XG4gICAgICAgICAgcCA9IGxpbmVBdChwMCwgcDEsIF90KTtcbiAgICAgICAgICBhbmdsZSA9IGxpbmVBbmdsZShwMCwgcDEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNldFJzKCdsYWJlbFgnLCBwcmVmaXgsIHAueCk7XG4gICAgc2V0UnMoJ2xhYmVsWScsIHByZWZpeCwgcC55KTtcbiAgICBzZXRScygnbGFiZWxBdXRvQW5nbGUnLCBwcmVmaXgsIGFuZ2xlKTtcbiAgfTtcbiAgY2FsY3VsYXRlRW5kUHJvamVjdGlvbignc291cmNlJyk7XG4gIGNhbGN1bGF0ZUVuZFByb2plY3Rpb24oJ3RhcmdldCcpO1xuICB0aGlzLmFwcGx5TGFiZWxEaW1lbnNpb25zKGVkZ2UpO1xufTtcbkJScCQ5LmFwcGx5TGFiZWxEaW1lbnNpb25zID0gZnVuY3Rpb24gKGVsZSkge1xuICB0aGlzLmFwcGx5UHJlZml4ZWRMYWJlbERpbWVuc2lvbnMoZWxlKTtcbiAgaWYgKGVsZS5pc0VkZ2UoKSkge1xuICAgIHRoaXMuYXBwbHlQcmVmaXhlZExhYmVsRGltZW5zaW9ucyhlbGUsICdzb3VyY2UnKTtcbiAgICB0aGlzLmFwcGx5UHJlZml4ZWRMYWJlbERpbWVuc2lvbnMoZWxlLCAndGFyZ2V0Jyk7XG4gIH1cbn07XG5CUnAkOS5hcHBseVByZWZpeGVkTGFiZWxEaW1lbnNpb25zID0gZnVuY3Rpb24gKGVsZSwgcHJlZml4KSB7XG4gIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgdmFyIHRleHQgPSB0aGlzLmdldExhYmVsVGV4dChlbGUsIHByZWZpeCk7XG4gIHZhciBsYWJlbERpbXMgPSB0aGlzLmNhbGN1bGF0ZUxhYmVsRGltZW5zaW9ucyhlbGUsIHRleHQpO1xuICB2YXIgbGluZUhlaWdodCA9IGVsZS5wc3R5bGUoJ2xpbmUtaGVpZ2h0JykucGZWYWx1ZTtcbiAgdmFyIHRleHRXcmFwID0gZWxlLnBzdHlsZSgndGV4dC13cmFwJykuc3RyVmFsdWU7XG4gIHZhciBsaW5lcyA9IGdldFByZWZpeGVkUHJvcGVydHkoX3AucnNjcmF0Y2gsICdsYWJlbFdyYXBDYWNoZWRMaW5lcycsIHByZWZpeCkgfHwgW107XG4gIHZhciBudW1MaW5lcyA9IHRleHRXcmFwICE9PSAnd3JhcCcgPyAxIDogTWF0aC5tYXgobGluZXMubGVuZ3RoLCAxKTtcbiAgdmFyIG5vcm1QZXJMaW5lSGVpZ2h0ID0gbGFiZWxEaW1zLmhlaWdodCAvIG51bUxpbmVzO1xuICB2YXIgbGFiZWxMaW5lSGVpZ2h0ID0gbm9ybVBlckxpbmVIZWlnaHQgKiBsaW5lSGVpZ2h0O1xuICB2YXIgd2lkdGggPSBsYWJlbERpbXMud2lkdGg7XG4gIHZhciBoZWlnaHQgPSBsYWJlbERpbXMuaGVpZ2h0ICsgKG51bUxpbmVzIC0gMSkgKiAobGluZUhlaWdodCAtIDEpICogbm9ybVBlckxpbmVIZWlnaHQ7XG4gIHNldFByZWZpeGVkUHJvcGVydHkoX3AucnN0eWxlLCAnbGFiZWxXaWR0aCcsIHByZWZpeCwgd2lkdGgpO1xuICBzZXRQcmVmaXhlZFByb3BlcnR5KF9wLnJzY3JhdGNoLCAnbGFiZWxXaWR0aCcsIHByZWZpeCwgd2lkdGgpO1xuICBzZXRQcmVmaXhlZFByb3BlcnR5KF9wLnJzdHlsZSwgJ2xhYmVsSGVpZ2h0JywgcHJlZml4LCBoZWlnaHQpO1xuICBzZXRQcmVmaXhlZFByb3BlcnR5KF9wLnJzY3JhdGNoLCAnbGFiZWxIZWlnaHQnLCBwcmVmaXgsIGhlaWdodCk7XG4gIHNldFByZWZpeGVkUHJvcGVydHkoX3AucnNjcmF0Y2gsICdsYWJlbExpbmVIZWlnaHQnLCBwcmVmaXgsIGxhYmVsTGluZUhlaWdodCk7XG59O1xuQlJwJDkuZ2V0TGFiZWxUZXh0ID0gZnVuY3Rpb24gKGVsZSwgcHJlZml4KSB7XG4gIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgdmFyIHBmZCA9IHByZWZpeCA/IHByZWZpeCArICctJyA6ICcnO1xuICB2YXIgdGV4dCA9IGVsZS5wc3R5bGUocGZkICsgJ2xhYmVsJykuc3RyVmFsdWU7XG4gIHZhciB0ZXh0VHJhbnNmb3JtID0gZWxlLnBzdHlsZSgndGV4dC10cmFuc2Zvcm0nKS52YWx1ZTtcbiAgdmFyIHJzY3JhdGNoID0gZnVuY3Rpb24gcnNjcmF0Y2gocHJvcE5hbWUsIHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICBzZXRQcmVmaXhlZFByb3BlcnR5KF9wLnJzY3JhdGNoLCBwcm9wTmFtZSwgcHJlZml4LCB2YWx1ZSk7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBnZXRQcmVmaXhlZFByb3BlcnR5KF9wLnJzY3JhdGNoLCBwcm9wTmFtZSwgcHJlZml4KTtcbiAgICB9XG4gIH07XG5cbiAgLy8gZm9yIGVtcHR5IHRleHQsIHNraXAgYWxsIHByb2Nlc3NpbmdcbiAgaWYgKCF0ZXh0KSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG4gIGlmICh0ZXh0VHJhbnNmb3JtID09ICdub25lJykgOyBlbHNlIGlmICh0ZXh0VHJhbnNmb3JtID09ICd1cHBlcmNhc2UnKSB7XG4gICAgdGV4dCA9IHRleHQudG9VcHBlckNhc2UoKTtcbiAgfSBlbHNlIGlmICh0ZXh0VHJhbnNmb3JtID09ICdsb3dlcmNhc2UnKSB7XG4gICAgdGV4dCA9IHRleHQudG9Mb3dlckNhc2UoKTtcbiAgfVxuICB2YXIgd3JhcFN0eWxlID0gZWxlLnBzdHlsZSgndGV4dC13cmFwJykudmFsdWU7XG4gIGlmICh3cmFwU3R5bGUgPT09ICd3cmFwJykge1xuICAgIHZhciBsYWJlbEtleSA9IHJzY3JhdGNoKCdsYWJlbEtleScpO1xuXG4gICAgLy8gc2F2ZSByZWNhbGMgaWYgdGhlIGxhYmVsIGlzIHRoZSBzYW1lIGFzIGJlZm9yZVxuICAgIGlmIChsYWJlbEtleSAhPSBudWxsICYmIHJzY3JhdGNoKCdsYWJlbFdyYXBLZXknKSA9PT0gbGFiZWxLZXkpIHtcbiAgICAgIHJldHVybiByc2NyYXRjaCgnbGFiZWxXcmFwQ2FjaGVkVGV4dCcpO1xuICAgIH1cbiAgICB2YXIgendzcCA9IFwiXFx1MjAwQlwiO1xuICAgIHZhciBsaW5lcyA9IHRleHQuc3BsaXQoJ1xcbicpO1xuICAgIHZhciBtYXhXID0gZWxlLnBzdHlsZSgndGV4dC1tYXgtd2lkdGgnKS5wZlZhbHVlO1xuICAgIHZhciBvdmVyZmxvdyA9IGVsZS5wc3R5bGUoJ3RleHQtb3ZlcmZsb3ctd3JhcCcpLnZhbHVlO1xuICAgIHZhciBvdmVyZmxvd0FueSA9IG92ZXJmbG93ID09PSAnYW55d2hlcmUnO1xuICAgIHZhciB3cmFwcGVkTGluZXMgPSBbXTtcbiAgICB2YXIgc2VwYXJhdG9yUmVnZXggPSAvW1xcc1xcdTIwMGJdK3wkL2c7IC8vIEluY2x1ZGUgZW5kIG9mIHN0cmluZyB0byBhZGQgbGFzdCB3b3JkXG5cbiAgICBmb3IgKHZhciBsID0gMDsgbCA8IGxpbmVzLmxlbmd0aDsgbCsrKSB7XG4gICAgICB2YXIgbGluZSA9IGxpbmVzW2xdO1xuICAgICAgdmFyIGxpbmVEaW1zID0gdGhpcy5jYWxjdWxhdGVMYWJlbERpbWVuc2lvbnMoZWxlLCBsaW5lKTtcbiAgICAgIHZhciBsaW5lVyA9IGxpbmVEaW1zLndpZHRoO1xuICAgICAgaWYgKG92ZXJmbG93QW55KSB7XG4gICAgICAgIHZhciBwcm9jZXNzZWRMaW5lID0gbGluZS5zcGxpdCgnJykuam9pbih6d3NwKTtcbiAgICAgICAgbGluZSA9IHByb2Nlc3NlZExpbmU7XG4gICAgICB9XG4gICAgICBpZiAobGluZVcgPiBtYXhXKSB7XG4gICAgICAgIC8vIGxpbmUgaXMgdG9vIGxvbmdcbiAgICAgICAgdmFyIHNlcGFyYXRvck1hdGNoZXMgPSBsaW5lLm1hdGNoQWxsKHNlcGFyYXRvclJlZ2V4KTtcbiAgICAgICAgdmFyIHN1YmxpbmUgPSAnJztcbiAgICAgICAgdmFyIHByZXZpb3VzSW5kZXggPSAwO1xuICAgICAgICAvLyBBZGQgZmFrZSBtYXRjaFxuICAgICAgICB2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIoc2VwYXJhdG9yTWF0Y2hlcyksXG4gICAgICAgICAgX3N0ZXA7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICAgIHZhciBzZXBhcmF0b3JNYXRjaCA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgICAgdmFyIHdvcmRTZXBhcmF0b3IgPSBzZXBhcmF0b3JNYXRjaFswXTtcbiAgICAgICAgICAgIHZhciB3b3JkID0gbGluZS5zdWJzdHJpbmcocHJldmlvdXNJbmRleCwgc2VwYXJhdG9yTWF0Y2guaW5kZXgpO1xuICAgICAgICAgICAgcHJldmlvdXNJbmRleCA9IHNlcGFyYXRvck1hdGNoLmluZGV4ICsgd29yZFNlcGFyYXRvci5sZW5ndGg7XG4gICAgICAgICAgICB2YXIgdGVzdExpbmUgPSBzdWJsaW5lLmxlbmd0aCA9PT0gMCA/IHdvcmQgOiBzdWJsaW5lICsgd29yZCArIHdvcmRTZXBhcmF0b3I7XG4gICAgICAgICAgICB2YXIgdGVzdERpbXMgPSB0aGlzLmNhbGN1bGF0ZUxhYmVsRGltZW5zaW9ucyhlbGUsIHRlc3RMaW5lKTtcbiAgICAgICAgICAgIHZhciB0ZXN0VyA9IHRlc3REaW1zLndpZHRoO1xuICAgICAgICAgICAgaWYgKHRlc3RXIDw9IG1heFcpIHtcbiAgICAgICAgICAgICAgLy8gd29yZCBmaXRzIG9uIGN1cnJlbnQgbGluZVxuICAgICAgICAgICAgICBzdWJsaW5lICs9IHdvcmQgKyB3b3JkU2VwYXJhdG9yO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gd29yZCBzdGFydHMgbmV3IGxpbmVcbiAgICAgICAgICAgICAgaWYgKHN1YmxpbmUpIHtcbiAgICAgICAgICAgICAgICB3cmFwcGVkTGluZXMucHVzaChzdWJsaW5lKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBzdWJsaW5lID0gd29yZCArIHdvcmRTZXBhcmF0b3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gaWYgdGhlcmUncyByZW1haW5pbmcgdGV4dCwgcHV0IGl0IGluIGEgd3JhcHBlZCBsaW5lXG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIF9pdGVyYXRvci5lKGVycik7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgX2l0ZXJhdG9yLmYoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXN1YmxpbmUubWF0Y2goL15bXFxzXFx1MjAwYl0rJC8pKSB7XG4gICAgICAgICAgd3JhcHBlZExpbmVzLnB1c2goc3VibGluZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGxpbmUgaXMgYWxyZWFkeSBzaG9ydCBlbm91Z2hcbiAgICAgICAgd3JhcHBlZExpbmVzLnB1c2gobGluZSk7XG4gICAgICB9XG4gICAgfSAvLyBmb3JcblxuICAgIHJzY3JhdGNoKCdsYWJlbFdyYXBDYWNoZWRMaW5lcycsIHdyYXBwZWRMaW5lcyk7XG4gICAgdGV4dCA9IHJzY3JhdGNoKCdsYWJlbFdyYXBDYWNoZWRUZXh0Jywgd3JhcHBlZExpbmVzLmpvaW4oJ1xcbicpKTtcbiAgICByc2NyYXRjaCgnbGFiZWxXcmFwS2V5JywgbGFiZWxLZXkpO1xuICB9IGVsc2UgaWYgKHdyYXBTdHlsZSA9PT0gJ2VsbGlwc2lzJykge1xuICAgIHZhciBfbWF4VyA9IGVsZS5wc3R5bGUoJ3RleHQtbWF4LXdpZHRoJykucGZWYWx1ZTtcbiAgICB2YXIgZWxsaXBzaXplZCA9ICcnO1xuICAgIHZhciBlbGxpcHNpcyA9IFwiXFx1MjAyNlwiO1xuICAgIHZhciBpbmNMYXN0Q2ggPSBmYWxzZTtcbiAgICBpZiAodGhpcy5jYWxjdWxhdGVMYWJlbERpbWVuc2lvbnMoZWxlLCB0ZXh0KS53aWR0aCA8IF9tYXhXKSB7XG4gICAgICAvLyB0aGUgbGFiZWwgYWxyZWFkeSBmaXRzXG4gICAgICByZXR1cm4gdGV4dDtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0ZXh0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgd2lkdGhXaXRoTmV4dENoID0gdGhpcy5jYWxjdWxhdGVMYWJlbERpbWVuc2lvbnMoZWxlLCBlbGxpcHNpemVkICsgdGV4dFtpXSArIGVsbGlwc2lzKS53aWR0aDtcbiAgICAgIGlmICh3aWR0aFdpdGhOZXh0Q2ggPiBfbWF4Vykge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGVsbGlwc2l6ZWQgKz0gdGV4dFtpXTtcbiAgICAgIGlmIChpID09PSB0ZXh0Lmxlbmd0aCAtIDEpIHtcbiAgICAgICAgaW5jTGFzdENoID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFpbmNMYXN0Q2gpIHtcbiAgICAgIGVsbGlwc2l6ZWQgKz0gZWxsaXBzaXM7XG4gICAgfVxuICAgIHJldHVybiBlbGxpcHNpemVkO1xuICB9IC8vIGlmIGVsbGlwc2l6ZVxuXG4gIHJldHVybiB0ZXh0O1xufTtcbkJScCQ5LmdldExhYmVsSnVzdGlmaWNhdGlvbiA9IGZ1bmN0aW9uIChlbGUpIHtcbiAgdmFyIGp1c3RpZmljYXRpb24gPSBlbGUucHN0eWxlKCd0ZXh0LWp1c3RpZmljYXRpb24nKS5zdHJWYWx1ZTtcbiAgdmFyIHRleHRIYWxpZ24gPSBlbGUucHN0eWxlKCd0ZXh0LWhhbGlnbicpLnN0clZhbHVlO1xuICBpZiAoanVzdGlmaWNhdGlvbiA9PT0gJ2F1dG8nKSB7XG4gICAgaWYgKGVsZS5pc05vZGUoKSkge1xuICAgICAgc3dpdGNoICh0ZXh0SGFsaWduKSB7XG4gICAgICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgICAgIHJldHVybiAncmlnaHQnO1xuICAgICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgICAgcmV0dXJuICdsZWZ0JztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gJ2NlbnRlcic7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAnY2VudGVyJztcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGp1c3RpZmljYXRpb247XG4gIH1cbn07XG5CUnAkOS5jYWxjdWxhdGVMYWJlbERpbWVuc2lvbnMgPSBmdW5jdGlvbiAoZWxlLCB0ZXh0KSB7XG4gIHZhciByID0gdGhpcztcbiAgdmFyIGNvbnRhaW5lcldpbmRvdyA9IHIuY3kud2luZG93KCk7XG4gIHZhciBkb2N1bWVudCA9IGNvbnRhaW5lcldpbmRvdy5kb2N1bWVudDtcbiAgdmFyIGNhY2hlS2V5ID0gaGFzaFN0cmluZyh0ZXh0LCBlbGUuX3ByaXZhdGUubGFiZWxEaW1zS2V5KTtcbiAgdmFyIGNhY2hlID0gci5sYWJlbERpbUNhY2hlIHx8IChyLmxhYmVsRGltQ2FjaGUgPSBbXSk7XG4gIHZhciBleGlzdGluZ1ZhbCA9IGNhY2hlW2NhY2hlS2V5XTtcbiAgaWYgKGV4aXN0aW5nVmFsICE9IG51bGwpIHtcbiAgICByZXR1cm4gZXhpc3RpbmdWYWw7XG4gIH1cbiAgdmFyIHBhZGRpbmcgPSAwOyAvLyBhZGQgcGFkZGluZyBhcm91bmQgdGV4dCBkaW1zLCBhcyB0aGUgbWVhc3VyZW1lbnQgaXNuJ3QgdGhhdCBhY2N1cmF0ZVxuICB2YXIgZlN0eWxlID0gZWxlLnBzdHlsZSgnZm9udC1zdHlsZScpLnN0clZhbHVlO1xuICB2YXIgc2l6ZSA9IGVsZS5wc3R5bGUoJ2ZvbnQtc2l6ZScpLnBmVmFsdWU7XG4gIHZhciBmYW1pbHkgPSBlbGUucHN0eWxlKCdmb250LWZhbWlseScpLnN0clZhbHVlO1xuICB2YXIgd2VpZ2h0ID0gZWxlLnBzdHlsZSgnZm9udC13ZWlnaHQnKS5zdHJWYWx1ZTtcbiAgdmFyIGNhbnZhcyA9IHRoaXMubGFiZWxDYWxjQ2FudmFzO1xuICB2YXIgYzJkID0gdGhpcy5sYWJlbENhbGNDYW52YXNDb250ZXh0O1xuICBpZiAoIWNhbnZhcykge1xuICAgIGNhbnZhcyA9IHRoaXMubGFiZWxDYWxjQ2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgYzJkID0gdGhpcy5sYWJlbENhbGNDYW52YXNDb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgdmFyIGRzID0gY2FudmFzLnN0eWxlO1xuICAgIGRzLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICBkcy5sZWZ0ID0gJy05OTk5cHgnO1xuICAgIGRzLnRvcCA9ICctOTk5OXB4JztcbiAgICBkcy56SW5kZXggPSAnLTEnO1xuICAgIGRzLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcbiAgICBkcy5wb2ludGVyRXZlbnRzID0gJ25vbmUnO1xuICB9XG4gIGMyZC5mb250ID0gXCJcIi5jb25jYXQoZlN0eWxlLCBcIiBcIikuY29uY2F0KHdlaWdodCwgXCIgXCIpLmNvbmNhdChzaXplLCBcInB4IFwiKS5jb25jYXQoZmFtaWx5KTtcbiAgdmFyIHdpZHRoID0gMDtcbiAgdmFyIGhlaWdodCA9IDA7XG4gIHZhciBsaW5lcyA9IHRleHQuc3BsaXQoJ1xcbicpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGxpbmUgPSBsaW5lc1tpXTtcbiAgICB2YXIgbWV0cmljcyA9IGMyZC5tZWFzdXJlVGV4dChsaW5lKTtcbiAgICB2YXIgdyA9IE1hdGguY2VpbChtZXRyaWNzLndpZHRoKTtcbiAgICB2YXIgaCA9IHNpemU7XG4gICAgd2lkdGggPSBNYXRoLm1heCh3LCB3aWR0aCk7XG4gICAgaGVpZ2h0ICs9IGg7XG4gIH1cbiAgd2lkdGggKz0gcGFkZGluZztcbiAgaGVpZ2h0ICs9IHBhZGRpbmc7XG4gIHJldHVybiBjYWNoZVtjYWNoZUtleV0gPSB7XG4gICAgd2lkdGg6IHdpZHRoLFxuICAgIGhlaWdodDogaGVpZ2h0XG4gIH07XG59O1xuQlJwJDkuY2FsY3VsYXRlTGFiZWxBbmdsZSA9IGZ1bmN0aW9uIChlbGUsIHByZWZpeCkge1xuICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gIHZhciBycyA9IF9wLnJzY3JhdGNoO1xuICB2YXIgaXNFZGdlID0gZWxlLmlzRWRnZSgpO1xuICB2YXIgcHJlZml4RGFzaCA9IHByZWZpeCA/IHByZWZpeCArICctJyA6ICcnO1xuICB2YXIgcm90ID0gZWxlLnBzdHlsZShwcmVmaXhEYXNoICsgJ3RleHQtcm90YXRpb24nKTtcbiAgdmFyIHJvdFN0ciA9IHJvdC5zdHJWYWx1ZTtcbiAgaWYgKHJvdFN0ciA9PT0gJ25vbmUnKSB7XG4gICAgcmV0dXJuIDA7XG4gIH0gZWxzZSBpZiAoaXNFZGdlICYmIHJvdFN0ciA9PT0gJ2F1dG9yb3RhdGUnKSB7XG4gICAgcmV0dXJuIHJzLmxhYmVsQXV0b0FuZ2xlO1xuICB9IGVsc2UgaWYgKHJvdFN0ciA9PT0gJ2F1dG9yb3RhdGUnKSB7XG4gICAgcmV0dXJuIDA7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHJvdC5wZlZhbHVlO1xuICB9XG59O1xuQlJwJDkuY2FsY3VsYXRlTGFiZWxBbmdsZXMgPSBmdW5jdGlvbiAoZWxlKSB7XG4gIHZhciByID0gdGhpcztcbiAgdmFyIGlzRWRnZSA9IGVsZS5pc0VkZ2UoKTtcbiAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuICB2YXIgcnMgPSBfcC5yc2NyYXRjaDtcbiAgcnMubGFiZWxBbmdsZSA9IHIuY2FsY3VsYXRlTGFiZWxBbmdsZShlbGUpO1xuICBpZiAoaXNFZGdlKSB7XG4gICAgcnMuc291cmNlTGFiZWxBbmdsZSA9IHIuY2FsY3VsYXRlTGFiZWxBbmdsZShlbGUsICdzb3VyY2UnKTtcbiAgICBycy50YXJnZXRMYWJlbEFuZ2xlID0gci5jYWxjdWxhdGVMYWJlbEFuZ2xlKGVsZSwgJ3RhcmdldCcpO1xuICB9XG59O1xuXG52YXIgQlJwJDggPSB7fTtcbnZhciBUT09fU01BTExfQ1VUX1JFQ1QgPSAyODtcbnZhciB3YXJuZWRDdXRSZWN0ID0gZmFsc2U7XG5CUnAkOC5nZXROb2RlU2hhcGUgPSBmdW5jdGlvbiAobm9kZSkge1xuICB2YXIgciA9IHRoaXM7XG4gIHZhciBzaGFwZSA9IG5vZGUucHN0eWxlKCdzaGFwZScpLnZhbHVlO1xuICBpZiAoc2hhcGUgPT09ICdjdXRyZWN0YW5nbGUnICYmIChub2RlLndpZHRoKCkgPCBUT09fU01BTExfQ1VUX1JFQ1QgfHwgbm9kZS5oZWlnaHQoKSA8IFRPT19TTUFMTF9DVVRfUkVDVCkpIHtcbiAgICBpZiAoIXdhcm5lZEN1dFJlY3QpIHtcbiAgICAgIHdhcm4oJ1RoZSBgY3V0cmVjdGFuZ2xlYCBub2RlIHNoYXBlIGNhbiBub3QgYmUgdXNlZCBhdCBzbWFsbCBzaXplcyBzbyBgcmVjdGFuZ2xlYCBpcyB1c2VkIGluc3RlYWQnKTtcbiAgICAgIHdhcm5lZEN1dFJlY3QgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gJ3JlY3RhbmdsZSc7XG4gIH1cbiAgaWYgKG5vZGUuaXNQYXJlbnQoKSkge1xuICAgIGlmIChzaGFwZSA9PT0gJ3JlY3RhbmdsZScgfHwgc2hhcGUgPT09ICdyb3VuZHJlY3RhbmdsZScgfHwgc2hhcGUgPT09ICdyb3VuZC1yZWN0YW5nbGUnIHx8IHNoYXBlID09PSAnY3V0cmVjdGFuZ2xlJyB8fCBzaGFwZSA9PT0gJ2N1dC1yZWN0YW5nbGUnIHx8IHNoYXBlID09PSAnYmFycmVsJykge1xuICAgICAgcmV0dXJuIHNoYXBlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gJ3JlY3RhbmdsZSc7XG4gICAgfVxuICB9XG4gIGlmIChzaGFwZSA9PT0gJ3BvbHlnb24nKSB7XG4gICAgdmFyIHBvaW50cyA9IG5vZGUucHN0eWxlKCdzaGFwZS1wb2x5Z29uLXBvaW50cycpLnZhbHVlO1xuICAgIHJldHVybiByLm5vZGVTaGFwZXMubWFrZVBvbHlnb24ocG9pbnRzKS5uYW1lO1xuICB9XG4gIHJldHVybiBzaGFwZTtcbn07XG5cbnZhciBCUnAkNyA9IHt9O1xuQlJwJDcucmVnaXN0ZXJDYWxjdWxhdGlvbkxpc3RlbmVycyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGN5ID0gdGhpcy5jeTtcbiAgdmFyIGVsZXNUb1VwZGF0ZSA9IGN5LmNvbGxlY3Rpb24oKTtcbiAgdmFyIHIgPSB0aGlzO1xuICB2YXIgZW5xdWV1ZSA9IGZ1bmN0aW9uIGVucXVldWUoZWxlcykge1xuICAgIHZhciBkaXJ0eVN0eWxlQ2FjaGVzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0cnVlO1xuICAgIGVsZXNUb1VwZGF0ZS5tZXJnZShlbGVzKTtcbiAgICBpZiAoZGlydHlTdHlsZUNhY2hlcykge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlbGUgPSBlbGVzW2ldO1xuICAgICAgICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gICAgICAgIHZhciByc3R5bGUgPSBfcC5yc3R5bGU7XG4gICAgICAgIHJzdHlsZS5jbGVhbiA9IGZhbHNlO1xuICAgICAgICByc3R5bGUuY2xlYW5Db25uZWN0ZWQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIHIuYmluZGVyKGN5KS5vbignYm91bmRzLiogZGlydHkuKicsIGZ1bmN0aW9uIG9uRGlydHlCb3VuZHMoZSkge1xuICAgIHZhciBlbGUgPSBlLnRhcmdldDtcbiAgICBlbnF1ZXVlKGVsZSk7XG4gIH0pLm9uKCdzdHlsZS4qIGJhY2tncm91bmQuKicsIGZ1bmN0aW9uIG9uRGlydHlTdHlsZShlKSB7XG4gICAgdmFyIGVsZSA9IGUudGFyZ2V0O1xuICAgIGVucXVldWUoZWxlLCBmYWxzZSk7XG4gIH0pO1xuICB2YXIgdXBkYXRlRWxlQ2FsY3MgPSBmdW5jdGlvbiB1cGRhdGVFbGVDYWxjcyh3aWxsRHJhdykge1xuICAgIGlmICh3aWxsRHJhdykge1xuICAgICAgdmFyIGZucyA9IHIub25VcGRhdGVFbGVDYWxjc0ZucztcblxuICAgICAgLy8gYmVjYXVzZSB3ZSBuZWVkIHRvIGhhdmUgdXAtdG8tZGF0ZSBzdHlsZSAoZS5nLiBzdHlsZXNoZWV0IG1hcHBlcnMpXG4gICAgICAvLyBiZWZvcmUgY2FsY3VsYXRpbmcgcmVuZGVyZWQgc3R5bGUgKGFuZCBwc3R5bGUgbWlnaHQgbm90IGJlIGNhbGxlZCB5ZXQpXG4gICAgICBlbGVzVG9VcGRhdGUuY2xlYW5TdHlsZSgpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVzVG9VcGRhdGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGVsZSA9IGVsZXNUb1VwZGF0ZVtpXTtcbiAgICAgICAgdmFyIHJzdHlsZSA9IGVsZS5fcHJpdmF0ZS5yc3R5bGU7XG4gICAgICAgIGlmIChlbGUuaXNOb2RlKCkgJiYgIXJzdHlsZS5jbGVhbkNvbm5lY3RlZCkge1xuICAgICAgICAgIGVucXVldWUoZWxlLmNvbm5lY3RlZEVkZ2VzKCkpO1xuICAgICAgICAgIHJzdHlsZS5jbGVhbkNvbm5lY3RlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChmbnMpIHtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGZucy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICB2YXIgZm4gPSBmbnNbX2ldO1xuICAgICAgICAgIGZuKHdpbGxEcmF3LCBlbGVzVG9VcGRhdGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByLnJlY2FsY3VsYXRlUmVuZGVyZWRTdHlsZShlbGVzVG9VcGRhdGUpO1xuICAgICAgZWxlc1RvVXBkYXRlID0gY3kuY29sbGVjdGlvbigpO1xuICAgIH1cbiAgfTtcbiAgci5mbHVzaFJlbmRlcmVkU3R5bGVRdWV1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB1cGRhdGVFbGVDYWxjcyh0cnVlKTtcbiAgfTtcbiAgci5iZWZvcmVSZW5kZXIodXBkYXRlRWxlQ2FsY3MsIHIuYmVmb3JlUmVuZGVyUHJpb3JpdGllcy5lbGVDYWxjcyk7XG59O1xuQlJwJDcub25VcGRhdGVFbGVDYWxjcyA9IGZ1bmN0aW9uIChmbikge1xuICB2YXIgZm5zID0gdGhpcy5vblVwZGF0ZUVsZUNhbGNzRm5zID0gdGhpcy5vblVwZGF0ZUVsZUNhbGNzRm5zIHx8IFtdO1xuICBmbnMucHVzaChmbik7XG59O1xuQlJwJDcucmVjYWxjdWxhdGVSZW5kZXJlZFN0eWxlID0gZnVuY3Rpb24gKGVsZXMsIHVzZUNhY2hlKSB7XG4gIHZhciBpc0NsZWFuQ29ubmVjdGVkID0gZnVuY3Rpb24gaXNDbGVhbkNvbm5lY3RlZChlbGUpIHtcbiAgICByZXR1cm4gZWxlLl9wcml2YXRlLnJzdHlsZS5jbGVhbkNvbm5lY3RlZDtcbiAgfTtcbiAgdmFyIGVkZ2VzID0gW107XG4gIHZhciBub2RlcyA9IFtdO1xuXG4gIC8vIHRoZSByZW5kZXJlciBjYW4ndCBiZSB1c2VkIGZvciBjYWxjcyB3aGVuIGRlc3Ryb3llZCwgZS5nLiBlbGUuYm91bmRpbmdCb3goKVxuICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyB1c2UgY2FjaGUgYnkgZGVmYXVsdCBmb3IgcGVyZlxuICBpZiAodXNlQ2FjaGUgPT09IHVuZGVmaW5lZCkge1xuICAgIHVzZUNhY2hlID0gdHJ1ZTtcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZWxlID0gZWxlc1tpXTtcbiAgICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gICAgdmFyIHJzdHlsZSA9IF9wLnJzdHlsZTtcblxuICAgIC8vIGFuIGVkZ2UgbWF5IGJlIGltcGxpY2l0bHkgZGlydHkgYi9jIG9mIG9uZSBvZiBpdHMgY29ubmVjdGVkIG5vZGVzXG4gICAgLy8gKGFuZCBhIHJlcXVlc3QgZm9yIHJlY2FsYyBtYXkgY29tZSBpbiBiZXR3ZWVuIGZyYW1lcylcbiAgICBpZiAoZWxlLmlzRWRnZSgpICYmICghaXNDbGVhbkNvbm5lY3RlZChlbGUuc291cmNlKCkpIHx8ICFpc0NsZWFuQ29ubmVjdGVkKGVsZS50YXJnZXQoKSkpKSB7XG4gICAgICByc3R5bGUuY2xlYW4gPSBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBvbmx5IHVwZGF0ZSBpZiBkaXJ0eSBhbmQgaW4gZ3JhcGhcbiAgICBpZiAodXNlQ2FjaGUgJiYgcnN0eWxlLmNsZWFuIHx8IGVsZS5yZW1vdmVkKCkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIG9ubHkgdXBkYXRlIGlmIG5vdCBkaXNwbGF5OiBub25lXG4gICAgaWYgKGVsZS5wc3R5bGUoJ2Rpc3BsYXknKS52YWx1ZSA9PT0gJ25vbmUnKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKF9wLmdyb3VwID09PSAnbm9kZXMnKSB7XG4gICAgICBub2Rlcy5wdXNoKGVsZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGVkZ2VzXG4gICAgICBlZGdlcy5wdXNoKGVsZSk7XG4gICAgfVxuICAgIHJzdHlsZS5jbGVhbiA9IHRydWU7XG4gIH1cblxuICAvLyB1cGRhdGUgbm9kZSBkYXRhIGZyb20gcHJvamVjdGlvbnNcbiAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgbm9kZXMubGVuZ3RoOyBfaTIrKykge1xuICAgIHZhciBfZWxlID0gbm9kZXNbX2kyXTtcbiAgICB2YXIgX3AyID0gX2VsZS5fcHJpdmF0ZTtcbiAgICB2YXIgX3JzdHlsZSA9IF9wMi5yc3R5bGU7XG4gICAgdmFyIHBvcyA9IF9lbGUucG9zaXRpb24oKTtcbiAgICB0aGlzLnJlY2FsY3VsYXRlTm9kZUxhYmVsUHJvamVjdGlvbihfZWxlKTtcbiAgICBfcnN0eWxlLm5vZGVYID0gcG9zLng7XG4gICAgX3JzdHlsZS5ub2RlWSA9IHBvcy55O1xuICAgIF9yc3R5bGUubm9kZVcgPSBfZWxlLnBzdHlsZSgnd2lkdGgnKS5wZlZhbHVlO1xuICAgIF9yc3R5bGUubm9kZUggPSBfZWxlLnBzdHlsZSgnaGVpZ2h0JykucGZWYWx1ZTtcbiAgfVxuICB0aGlzLnJlY2FsY3VsYXRlRWRnZVByb2plY3Rpb25zKGVkZ2VzKTtcblxuICAvLyB1cGRhdGUgZWRnZSBkYXRhIGZyb20gcHJvamVjdGlvbnNcbiAgZm9yICh2YXIgX2kzID0gMDsgX2kzIDwgZWRnZXMubGVuZ3RoOyBfaTMrKykge1xuICAgIHZhciBfZWxlMiA9IGVkZ2VzW19pM107XG4gICAgdmFyIF9wMyA9IF9lbGUyLl9wcml2YXRlO1xuICAgIHZhciBfcnN0eWxlMiA9IF9wMy5yc3R5bGU7XG4gICAgdmFyIHJzID0gX3AzLnJzY3JhdGNoO1xuXG4gICAgLy8gdXBkYXRlIHJzdHlsZSBwb3NpdGlvbnNcbiAgICBfcnN0eWxlMi5zcmNYID0gcnMuYXJyb3dTdGFydFg7XG4gICAgX3JzdHlsZTIuc3JjWSA9IHJzLmFycm93U3RhcnRZO1xuICAgIF9yc3R5bGUyLnRndFggPSBycy5hcnJvd0VuZFg7XG4gICAgX3JzdHlsZTIudGd0WSA9IHJzLmFycm93RW5kWTtcbiAgICBfcnN0eWxlMi5taWRYID0gcnMubWlkWDtcbiAgICBfcnN0eWxlMi5taWRZID0gcnMubWlkWTtcbiAgICBfcnN0eWxlMi5sYWJlbEFuZ2xlID0gcnMubGFiZWxBbmdsZTtcbiAgICBfcnN0eWxlMi5zb3VyY2VMYWJlbEFuZ2xlID0gcnMuc291cmNlTGFiZWxBbmdsZTtcbiAgICBfcnN0eWxlMi50YXJnZXRMYWJlbEFuZ2xlID0gcnMudGFyZ2V0TGFiZWxBbmdsZTtcbiAgfVxufTtcblxudmFyIEJScCQ2ID0ge307XG5CUnAkNi51cGRhdGVDYWNoZWRHcmFiYmVkRWxlcyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGVsZXMgPSB0aGlzLmNhY2hlZFpTb3J0ZWRFbGVzO1xuICBpZiAoIWVsZXMpIHtcbiAgICAvLyBqdXN0IGxldCB0aGlzIGJlIHJlY2FsY3VsYXRlZCBvbiB0aGUgbmV4dCB6IHNvcnQgdGlja1xuICAgIHJldHVybjtcbiAgfVxuICBlbGVzLmRyYWcgPSBbXTtcbiAgZWxlcy5ub25kcmFnID0gW107XG4gIHZhciBncmFiVGFyZ2V0cyA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZWxlID0gZWxlc1tpXTtcbiAgICB2YXIgcnMgPSBlbGUuX3ByaXZhdGUucnNjcmF0Y2g7XG4gICAgaWYgKGVsZS5ncmFiYmVkKCkgJiYgIWVsZS5pc1BhcmVudCgpKSB7XG4gICAgICBncmFiVGFyZ2V0cy5wdXNoKGVsZSk7XG4gICAgfSBlbHNlIGlmIChycy5pbkRyYWdMYXllcikge1xuICAgICAgZWxlcy5kcmFnLnB1c2goZWxlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWxlcy5ub25kcmFnLnB1c2goZWxlKTtcbiAgICB9XG4gIH1cblxuICAvLyBwdXQgdGhlIGdyYWIgdGFyZ2V0IG5vZGVzIGxhc3Qgc28gaXQncyBvbiB0b3Agb2YgaXRzIG5laWdoYm91cmhvb2RcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBncmFiVGFyZ2V0cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBlbGUgPSBncmFiVGFyZ2V0c1tpXTtcbiAgICBlbGVzLmRyYWcucHVzaChlbGUpO1xuICB9XG59O1xuQlJwJDYuaW52YWxpZGF0ZUNhY2hlZFpTb3J0ZWRFbGVzID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmNhY2hlZFpTb3J0ZWRFbGVzID0gbnVsbDtcbn07XG5CUnAkNi5nZXRDYWNoZWRaU29ydGVkRWxlcyA9IGZ1bmN0aW9uIChmb3JjZVJlY2FsYykge1xuICBpZiAoZm9yY2VSZWNhbGMgfHwgIXRoaXMuY2FjaGVkWlNvcnRlZEVsZXMpIHtcbiAgICB2YXIgZWxlcyA9IHRoaXMuY3kubXV0YWJsZUVsZW1lbnRzKCkudG9BcnJheSgpO1xuICAgIGVsZXMuc29ydCh6SW5kZXhTb3J0KTtcbiAgICBlbGVzLmludGVyYWN0aXZlID0gZWxlcy5maWx0ZXIoZnVuY3Rpb24gKGVsZSkge1xuICAgICAgcmV0dXJuIGVsZS5pbnRlcmFjdGl2ZSgpO1xuICAgIH0pO1xuICAgIHRoaXMuY2FjaGVkWlNvcnRlZEVsZXMgPSBlbGVzO1xuICAgIHRoaXMudXBkYXRlQ2FjaGVkR3JhYmJlZEVsZXMoKTtcbiAgfSBlbHNlIHtcbiAgICBlbGVzID0gdGhpcy5jYWNoZWRaU29ydGVkRWxlcztcbiAgfVxuICByZXR1cm4gZWxlcztcbn07XG5cbnZhciBCUnAkNSA9IHt9O1xuW0JScCRlLCBCUnAkZCwgQlJwJGMsIEJScCRiLCBCUnAkYSwgQlJwJDksIEJScCQ4LCBCUnAkNywgQlJwJDZdLmZvckVhY2goZnVuY3Rpb24gKHByb3BzKSB7XG4gIGV4dGVuZChCUnAkNSwgcHJvcHMpO1xufSk7XG5cbnZhciBCUnAkNCA9IHt9O1xuQlJwJDQuZ2V0Q2FjaGVkSW1hZ2UgPSBmdW5jdGlvbiAodXJsLCBjcm9zc09yaWdpbiwgb25Mb2FkKSB7XG4gIHZhciByID0gdGhpcztcbiAgdmFyIGltYWdlQ2FjaGUgPSByLmltYWdlQ2FjaGUgPSByLmltYWdlQ2FjaGUgfHwge307XG4gIHZhciBjYWNoZSA9IGltYWdlQ2FjaGVbdXJsXTtcbiAgaWYgKGNhY2hlKSB7XG4gICAgaWYgKCFjYWNoZS5pbWFnZS5jb21wbGV0ZSkge1xuICAgICAgY2FjaGUuaW1hZ2UuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIG9uTG9hZCk7XG4gICAgfVxuICAgIHJldHVybiBjYWNoZS5pbWFnZTtcbiAgfSBlbHNlIHtcbiAgICBjYWNoZSA9IGltYWdlQ2FjaGVbdXJsXSA9IGltYWdlQ2FjaGVbdXJsXSB8fCB7fTtcbiAgICB2YXIgaW1hZ2UgPSBjYWNoZS5pbWFnZSA9IG5ldyBJbWFnZSgpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG5cbiAgICBpbWFnZS5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgb25Mb2FkKTtcbiAgICBpbWFnZS5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGltYWdlLmVycm9yID0gdHJ1ZTtcbiAgICB9KTtcblxuICAgIC8vICMxNTgyIHNhZmFyaSBkb2Vzbid0IGxvYWQgZGF0YSB1cmlzIHdpdGggY3Jvc3NPcmlnaW4gcHJvcGVybHlcbiAgICAvLyBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTIzOTc4XG4gICAgdmFyIGRhdGFVcmlQcmVmaXggPSAnZGF0YTonO1xuICAgIHZhciBpc0RhdGFVcmkgPSB1cmwuc3Vic3RyaW5nKDAsIGRhdGFVcmlQcmVmaXgubGVuZ3RoKS50b0xvd2VyQ2FzZSgpID09PSBkYXRhVXJpUHJlZml4O1xuICAgIGlmICghaXNEYXRhVXJpKSB7XG4gICAgICAvLyBpZiBjcm9zc29yaWdpbiBpcyAnbnVsbCcoc3RyaW5naWZpZWQpLCB0aGVuIG1hbnVhbGx5IHNldCBpdCB0byBudWxsIFxuICAgICAgY3Jvc3NPcmlnaW4gPSBjcm9zc09yaWdpbiA9PT0gJ251bGwnID8gbnVsbCA6IGNyb3NzT3JpZ2luO1xuICAgICAgaW1hZ2UuY3Jvc3NPcmlnaW4gPSBjcm9zc09yaWdpbjsgLy8gcHJldmVudCB0YWludGVkIGNhbnZhc1xuICAgIH1cblxuICAgIGltYWdlLnNyYyA9IHVybDtcbiAgICByZXR1cm4gaW1hZ2U7XG4gIH1cbn07XG5cbnZhciBCUnAkMyA9IHt9O1xuXG4vKiBnbG9iYWwgZG9jdW1lbnQsIFJlc2l6ZU9ic2VydmVyLCBNdXRhdGlvbk9ic2VydmVyICovXG5cbkJScCQzLnJlZ2lzdGVyQmluZGluZyA9IGZ1bmN0aW9uICh0YXJnZXQsIGV2ZW50LCBoYW5kbGVyLCB1c2VDYXB0dXJlKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuYXBwbHkoYXJndW1lbnRzLCBbMV0pOyAvLyBjb3B5XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkodGFyZ2V0KSkge1xuICAgIHZhciByZXMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRhcmdldC5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHQgPSB0YXJnZXRbaV07XG4gICAgICBpZiAodCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciBiID0gdGhpcy5iaW5kZXIodCk7XG4gICAgICAgIHJlcy5wdXNoKGIub24uYXBwbHkoYiwgYXJncykpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzO1xuICB9XG4gIHZhciBiID0gdGhpcy5iaW5kZXIodGFyZ2V0KTtcbiAgcmV0dXJuIGIub24uYXBwbHkoYiwgYXJncyk7XG59O1xuQlJwJDMuYmluZGVyID0gZnVuY3Rpb24gKHRndCkge1xuICB2YXIgciA9IHRoaXM7XG4gIHZhciBjb250YWluZXJXaW5kb3cgPSByLmN5LndpbmRvdygpO1xuICB2YXIgdGd0SXNEb20gPSB0Z3QgPT09IGNvbnRhaW5lcldpbmRvdyB8fCB0Z3QgPT09IGNvbnRhaW5lcldpbmRvdy5kb2N1bWVudCB8fCB0Z3QgPT09IGNvbnRhaW5lcldpbmRvdy5kb2N1bWVudC5ib2R5IHx8IGRvbUVsZW1lbnQodGd0KTtcbiAgaWYgKHIuc3VwcG9ydHNQYXNzaXZlRXZlbnRzID09IG51bGwpIHtcbiAgICAvLyBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9XSUNHL0V2ZW50TGlzdGVuZXJPcHRpb25zL2Jsb2IvZ2gtcGFnZXMvZXhwbGFpbmVyLm1kI2ZlYXR1cmUtZGV0ZWN0aW9uXG4gICAgdmFyIHN1cHBvcnRzUGFzc2l2ZSA9IGZhbHNlO1xuICAgIHRyeSB7XG4gICAgICB2YXIgb3B0cyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ3Bhc3NpdmUnLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgIHN1cHBvcnRzUGFzc2l2ZSA9IHRydWU7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgY29udGFpbmVyV2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Rlc3QnLCBudWxsLCBvcHRzKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIC8vIG5vdCBzdXBwb3J0ZWRcbiAgICB9XG4gICAgci5zdXBwb3J0c1Bhc3NpdmVFdmVudHMgPSBzdXBwb3J0c1Bhc3NpdmU7XG4gIH1cbiAgdmFyIG9uID0gZnVuY3Rpb24gb24oZXZlbnQsIGhhbmRsZXIsIHVzZUNhcHR1cmUpIHtcbiAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgaWYgKHRndElzRG9tICYmIHIuc3VwcG9ydHNQYXNzaXZlRXZlbnRzKSB7XG4gICAgICAvLyByZXBsYWNlIHVzZUNhcHR1cmUgdy8gb3B0cyBvYmpcbiAgICAgIGFyZ3NbMl0gPSB7XG4gICAgICAgIGNhcHR1cmU6IHVzZUNhcHR1cmUgIT0gbnVsbCA/IHVzZUNhcHR1cmUgOiBmYWxzZSxcbiAgICAgICAgcGFzc2l2ZTogZmFsc2UsXG4gICAgICAgIG9uY2U6IGZhbHNlXG4gICAgICB9O1xuICAgIH1cbiAgICByLmJpbmRpbmdzLnB1c2goe1xuICAgICAgdGFyZ2V0OiB0Z3QsXG4gICAgICBhcmdzOiBhcmdzXG4gICAgfSk7XG4gICAgKHRndC5hZGRFdmVudExpc3RlbmVyIHx8IHRndC5vbikuYXBwbHkodGd0LCBhcmdzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICBvbjogb24sXG4gICAgYWRkRXZlbnRMaXN0ZW5lcjogb24sXG4gICAgYWRkTGlzdGVuZXI6IG9uLFxuICAgIGJpbmQ6IG9uXG4gIH07XG59O1xuQlJwJDMubm9kZUlzRHJhZ2dhYmxlID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUgJiYgbm9kZS5pc05vZGUoKSAmJiAhbm9kZS5sb2NrZWQoKSAmJiBub2RlLmdyYWJiYWJsZSgpO1xufTtcbkJScCQzLm5vZGVJc0dyYWJiYWJsZSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIHJldHVybiB0aGlzLm5vZGVJc0RyYWdnYWJsZShub2RlKSAmJiBub2RlLmludGVyYWN0aXZlKCk7XG59O1xuQlJwJDMubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHIgPSB0aGlzO1xuICB2YXIgY29udGFpbmVyV2luZG93ID0gci5jeS53aW5kb3coKTtcbiAgdmFyIGlzU2VsZWN0ZWQgPSBmdW5jdGlvbiBpc1NlbGVjdGVkKGVsZSkge1xuICAgIHJldHVybiBlbGUuc2VsZWN0ZWQoKTtcbiAgfTtcbiAgdmFyIGdldFNoYWRvd1Jvb3QgPSBmdW5jdGlvbiBnZXRTaGFkb3dSb290KGVsZW1lbnQpIHtcbiAgICB2YXIgcm9vdE5vZGUgPSBlbGVtZW50LmdldFJvb3ROb2RlKCk7XG4gICAgLy8gQ2hlY2sgaWYgdGhlIHJvb3Qgbm9kZSBpcyBhIHNoYWRvdyByb290XG4gICAgaWYgKHJvb3ROb2RlICYmIHJvb3ROb2RlLm5vZGVUeXBlID09PSAxMSAmJiByb290Tm9kZS5ob3N0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiByb290Tm9kZTtcbiAgICB9XG4gIH07XG4gIHZhciB0cmlnZ2VyRXZlbnRzID0gZnVuY3Rpb24gdHJpZ2dlckV2ZW50cyh0YXJnZXQsIG5hbWVzLCBlLCBwb3NpdGlvbikge1xuICAgIGlmICh0YXJnZXQgPT0gbnVsbCkge1xuICAgICAgdGFyZ2V0ID0gci5jeTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIG5hbWUgPSBuYW1lc1tpXTtcbiAgICAgIHRhcmdldC5lbWl0KHtcbiAgICAgICAgb3JpZ2luYWxFdmVudDogZSxcbiAgICAgICAgdHlwZTogbmFtZSxcbiAgICAgICAgcG9zaXRpb246IHBvc2l0aW9uXG4gICAgICB9KTtcbiAgICB9XG4gIH07XG4gIHZhciBpc011bHRTZWxLZXlEb3duID0gZnVuY3Rpb24gaXNNdWx0U2VsS2V5RG93bihlKSB7XG4gICAgcmV0dXJuIGUuc2hpZnRLZXkgfHwgZS5tZXRhS2V5IHx8IGUuY3RybEtleTsgLy8gbWF5YmUgZS5hbHRLZXlcbiAgfTtcblxuICB2YXIgYWxsb3dQYW5uaW5nUGFzc3Rocm91Z2ggPSBmdW5jdGlvbiBhbGxvd1Bhbm5pbmdQYXNzdGhyb3VnaChkb3duLCBkb3ducykge1xuICAgIHZhciBhbGxvd1Bhc3N0aHJvdWdoID0gdHJ1ZTtcbiAgICBpZiAoci5jeS5oYXNDb21wb3VuZE5vZGVzKCkgJiYgZG93biAmJiBkb3duLnBhbm5hYmxlKCkpIHtcbiAgICAgIC8vIGEgZ3JhYmJhYmxlIGNvbXBvdW5kIG5vZGUgYmVsb3cgdGhlIGVsZSA9PiBubyBwYXNzdGhyb3VnaCBwYW5uaW5nXG4gICAgICBmb3IgKHZhciBpID0gMDsgZG93bnMgJiYgaSA8IGRvd25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBkb3duID0gZG93bnNbaV07XG5cbiAgICAgICAgLy9pZiBhbnkgcGFyZW50IG5vZGUgaW4gZXZlbnQgaGllcmFyY2h5IGlzbid0IHBhbm5hYmxlLCByZWplY3QgcGFzc3Rocm91Z2hcbiAgICAgICAgaWYgKGRvd24uaXNOb2RlKCkgJiYgZG93bi5pc1BhcmVudCgpICYmICFkb3duLnBhbm5hYmxlKCkpIHtcbiAgICAgICAgICBhbGxvd1Bhc3N0aHJvdWdoID0gZmFsc2U7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgYWxsb3dQYXNzdGhyb3VnaCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBhbGxvd1Bhc3N0aHJvdWdoO1xuICB9O1xuICB2YXIgc2V0R3JhYmJlZCA9IGZ1bmN0aW9uIHNldEdyYWJiZWQoZWxlKSB7XG4gICAgZWxlWzBdLl9wcml2YXRlLmdyYWJiZWQgPSB0cnVlO1xuICB9O1xuICB2YXIgc2V0RnJlZWQgPSBmdW5jdGlvbiBzZXRGcmVlZChlbGUpIHtcbiAgICBlbGVbMF0uX3ByaXZhdGUuZ3JhYmJlZCA9IGZhbHNlO1xuICB9O1xuICB2YXIgc2V0SW5EcmFnTGF5ZXIgPSBmdW5jdGlvbiBzZXRJbkRyYWdMYXllcihlbGUpIHtcbiAgICBlbGVbMF0uX3ByaXZhdGUucnNjcmF0Y2guaW5EcmFnTGF5ZXIgPSB0cnVlO1xuICB9O1xuICB2YXIgc2V0T3V0RHJhZ0xheWVyID0gZnVuY3Rpb24gc2V0T3V0RHJhZ0xheWVyKGVsZSkge1xuICAgIGVsZVswXS5fcHJpdmF0ZS5yc2NyYXRjaC5pbkRyYWdMYXllciA9IGZhbHNlO1xuICB9O1xuICB2YXIgc2V0R3JhYlRhcmdldCA9IGZ1bmN0aW9uIHNldEdyYWJUYXJnZXQoZWxlKSB7XG4gICAgZWxlWzBdLl9wcml2YXRlLnJzY3JhdGNoLmlzR3JhYlRhcmdldCA9IHRydWU7XG4gIH07XG4gIHZhciByZW1vdmVHcmFiVGFyZ2V0ID0gZnVuY3Rpb24gcmVtb3ZlR3JhYlRhcmdldChlbGUpIHtcbiAgICBlbGVbMF0uX3ByaXZhdGUucnNjcmF0Y2guaXNHcmFiVGFyZ2V0ID0gZmFsc2U7XG4gIH07XG4gIHZhciBhZGRUb0RyYWdMaXN0ID0gZnVuY3Rpb24gYWRkVG9EcmFnTGlzdChlbGUsIG9wdHMpIHtcbiAgICB2YXIgbGlzdCA9IG9wdHMuYWRkVG9MaXN0O1xuICAgIHZhciBsaXN0SGFzRWxlID0gbGlzdC5oYXMoZWxlKTtcbiAgICBpZiAoIWxpc3RIYXNFbGUgJiYgZWxlLmdyYWJiYWJsZSgpICYmICFlbGUubG9ja2VkKCkpIHtcbiAgICAgIGxpc3QubWVyZ2UoZWxlKTtcbiAgICAgIHNldEdyYWJiZWQoZWxlKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gaGVscGVyIGZ1bmN0aW9uIHRvIGRldGVybWluZSB3aGljaCBjaGlsZCBub2RlcyBhbmQgaW5uZXIgZWRnZXNcbiAgLy8gb2YgYSBjb21wb3VuZCBub2RlIHRvIGJlIGRyYWdnZWQgYXMgd2VsbCBhcyB0aGUgZ3JhYmJlZCBhbmQgc2VsZWN0ZWQgbm9kZXNcbiAgdmFyIGFkZERlc2NlbmRhbnRzVG9EcmFnID0gZnVuY3Rpb24gYWRkRGVzY2VuZGFudHNUb0RyYWcobm9kZSwgb3B0cykge1xuICAgIGlmICghbm9kZS5jeSgpLmhhc0NvbXBvdW5kTm9kZXMoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAob3B0cy5pbkRyYWdMYXllciA9PSBudWxsICYmIG9wdHMuYWRkVG9MaXN0ID09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIG5vdGhpbmcgdG8gZG9cblxuICAgIHZhciBpbm5lck5vZGVzID0gbm9kZS5kZXNjZW5kYW50cygpO1xuICAgIGlmIChvcHRzLmluRHJhZ0xheWVyKSB7XG4gICAgICBpbm5lck5vZGVzLmZvckVhY2goc2V0SW5EcmFnTGF5ZXIpO1xuICAgICAgaW5uZXJOb2Rlcy5jb25uZWN0ZWRFZGdlcygpLmZvckVhY2goc2V0SW5EcmFnTGF5ZXIpO1xuICAgIH1cbiAgICBpZiAob3B0cy5hZGRUb0xpc3QpIHtcbiAgICAgIGFkZFRvRHJhZ0xpc3QoaW5uZXJOb2Rlcywgb3B0cyk7XG4gICAgfVxuICB9O1xuXG4gIC8vIGFkZHMgdGhlIGdpdmVuIG5vZGVzIGFuZCBpdHMgbmVpZ2hib3VyaG9vZCB0byB0aGUgZHJhZyBsYXllclxuICB2YXIgYWRkTm9kZXNUb0RyYWcgPSBmdW5jdGlvbiBhZGROb2Rlc1RvRHJhZyhub2Rlcywgb3B0cykge1xuICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xuICAgIHZhciBoYXNDb21wb3VuZE5vZGVzID0gbm9kZXMuY3koKS5oYXNDb21wb3VuZE5vZGVzKCk7XG4gICAgaWYgKG9wdHMuaW5EcmFnTGF5ZXIpIHtcbiAgICAgIG5vZGVzLmZvckVhY2goc2V0SW5EcmFnTGF5ZXIpO1xuICAgICAgbm9kZXMubmVpZ2hib3Job29kKCkuc3RkRmlsdGVyKGZ1bmN0aW9uIChlbGUpIHtcbiAgICAgICAgcmV0dXJuICFoYXNDb21wb3VuZE5vZGVzIHx8IGVsZS5pc0VkZ2UoKTtcbiAgICAgIH0pLmZvckVhY2goc2V0SW5EcmFnTGF5ZXIpO1xuICAgIH1cbiAgICBpZiAob3B0cy5hZGRUb0xpc3QpIHtcbiAgICAgIG5vZGVzLmZvckVhY2goZnVuY3Rpb24gKGVsZSkge1xuICAgICAgICBhZGRUb0RyYWdMaXN0KGVsZSwgb3B0cyk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgYWRkRGVzY2VuZGFudHNUb0RyYWcobm9kZXMsIG9wdHMpOyAvLyBhbHdheXMgYWRkIHRvIGRyYWdcblxuICAgIC8vIGFsc28gYWRkIG5vZGVzIGFuZCBlZGdlcyByZWxhdGVkIHRvIHRoZSB0b3Btb3N0IGFuY2VzdG9yXG4gICAgdXBkYXRlQW5jZXN0b3JzSW5EcmFnTGF5ZXIobm9kZXMsIHtcbiAgICAgIGluRHJhZ0xheWVyOiBvcHRzLmluRHJhZ0xheWVyXG4gICAgfSk7XG4gICAgci51cGRhdGVDYWNoZWRHcmFiYmVkRWxlcygpO1xuICB9O1xuICB2YXIgYWRkTm9kZVRvRHJhZyA9IGFkZE5vZGVzVG9EcmFnO1xuICB2YXIgZnJlZURyYWdnZWRFbGVtZW50cyA9IGZ1bmN0aW9uIGZyZWVEcmFnZ2VkRWxlbWVudHMoZ3JhYmJlZEVsZXMpIHtcbiAgICBpZiAoIWdyYWJiZWRFbGVzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8ganVzdCBnbyBvdmVyIGFsbCBlbGVtZW50cyByYXRoZXIgdGhhbiBkb2luZyBhIGJ1bmNoIG9mIChwb3NzaWJseSBleHBlbnNpdmUpIHRyYXZlcnNhbHNcbiAgICByLmdldENhY2hlZFpTb3J0ZWRFbGVzKCkuZm9yRWFjaChmdW5jdGlvbiAoZWxlKSB7XG4gICAgICBzZXRGcmVlZChlbGUpO1xuICAgICAgc2V0T3V0RHJhZ0xheWVyKGVsZSk7XG4gICAgICByZW1vdmVHcmFiVGFyZ2V0KGVsZSk7XG4gICAgfSk7XG4gICAgci51cGRhdGVDYWNoZWRHcmFiYmVkRWxlcygpO1xuICB9O1xuXG4gIC8vIGhlbHBlciBmdW5jdGlvbiB0byBkZXRlcm1pbmUgd2hpY2ggYW5jZXN0b3Igbm9kZXMgYW5kIGVkZ2VzIHNob3VsZCBnb1xuICAvLyB0byB0aGUgZHJhZyBsYXllciAob3Igc2hvdWxkIGJlIHJlbW92ZWQgZnJvbSBkcmFnIGxheWVyKS5cbiAgdmFyIHVwZGF0ZUFuY2VzdG9yc0luRHJhZ0xheWVyID0gZnVuY3Rpb24gdXBkYXRlQW5jZXN0b3JzSW5EcmFnTGF5ZXIobm9kZSwgb3B0cykge1xuICAgIGlmIChvcHRzLmluRHJhZ0xheWVyID09IG51bGwgJiYgb3B0cy5hZGRUb0xpc3QgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gbm90aGluZyB0byBkb1xuXG4gICAgaWYgKCFub2RlLmN5KCkuaGFzQ29tcG91bmROb2RlcygpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gZmluZCB0b3AtbGV2ZWwgcGFyZW50XG4gICAgdmFyIHBhcmVudCA9IG5vZGUuYW5jZXN0b3JzKCkub3JwaGFucygpO1xuXG4gICAgLy8gbm8gcGFyZW50IG5vZGU6IG5vIG5vZGVzIHRvIGFkZCB0byB0aGUgZHJhZyBsYXllclxuICAgIGlmIChwYXJlbnQuc2FtZShub2RlKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgbm9kZXMgPSBwYXJlbnQuZGVzY2VuZGFudHMoKS5zcGF3blNlbGYoKS5tZXJnZShwYXJlbnQpLnVubWVyZ2Uobm9kZSkudW5tZXJnZShub2RlLmRlc2NlbmRhbnRzKCkpO1xuICAgIHZhciBlZGdlcyA9IG5vZGVzLmNvbm5lY3RlZEVkZ2VzKCk7XG4gICAgaWYgKG9wdHMuaW5EcmFnTGF5ZXIpIHtcbiAgICAgIGVkZ2VzLmZvckVhY2goc2V0SW5EcmFnTGF5ZXIpO1xuICAgICAgbm9kZXMuZm9yRWFjaChzZXRJbkRyYWdMYXllcik7XG4gICAgfVxuICAgIGlmIChvcHRzLmFkZFRvTGlzdCkge1xuICAgICAgbm9kZXMuZm9yRWFjaChmdW5jdGlvbiAoZWxlKSB7XG4gICAgICAgIGFkZFRvRHJhZ0xpc3QoZWxlLCBvcHRzKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbiAgdmFyIGJsdXJBY3RpdmVEb21FbGVtZW50ID0gZnVuY3Rpb24gYmx1ckFjdGl2ZURvbUVsZW1lbnQoKSB7XG4gICAgaWYgKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgIT0gbnVsbCAmJiBkb2N1bWVudC5hY3RpdmVFbGVtZW50LmJsdXIgIT0gbnVsbCkge1xuICAgICAgZG9jdW1lbnQuYWN0aXZlRWxlbWVudC5ibHVyKCk7XG4gICAgfVxuICB9O1xuICB2YXIgaGF2ZU11dGF0aW9uc0FwaSA9IHR5cGVvZiBNdXRhdGlvbk9ic2VydmVyICE9PSAndW5kZWZpbmVkJztcbiAgdmFyIGhhdmVSZXNpemVPYnNlcnZlckFwaSA9IHR5cGVvZiBSZXNpemVPYnNlcnZlciAhPT0gJ3VuZGVmaW5lZCc7XG5cbiAgLy8gd2F0Y2ggZm9yIHdoZW4gdGhlIGN5IGNvbnRhaW5lciBpcyByZW1vdmVkIGZyb20gdGhlIGRvbVxuICBpZiAoaGF2ZU11dGF0aW9uc0FwaSkge1xuICAgIHIucmVtb3ZlT2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihmdW5jdGlvbiAobXV0bnMpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbXV0bnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG11dG4gPSBtdXRuc1tpXTtcbiAgICAgICAgdmFyIHJOb2RlcyA9IG11dG4ucmVtb3ZlZE5vZGVzO1xuICAgICAgICBpZiAock5vZGVzKSB7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCByTm9kZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIHZhciByTm9kZSA9IHJOb2Rlc1tqXTtcbiAgICAgICAgICAgIGlmIChyTm9kZSA9PT0gci5jb250YWluZXIpIHtcbiAgICAgICAgICAgICAgci5kZXN0cm95KCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChyLmNvbnRhaW5lci5wYXJlbnROb2RlKSB7XG4gICAgICByLnJlbW92ZU9ic2VydmVyLm9ic2VydmUoci5jb250YWluZXIucGFyZW50Tm9kZSwge1xuICAgICAgICBjaGlsZExpc3Q6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByLnJlZ2lzdGVyQmluZGluZyhyLmNvbnRhaW5lciwgJ0RPTU5vZGVSZW1vdmVkJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICAgIHIuZGVzdHJveSgpO1xuICAgIH0pO1xuICB9XG4gIHZhciBvblJlc2l6ZSA9IGRlYm91bmNlXzEoZnVuY3Rpb24gKCkge1xuICAgIHIuY3kucmVzaXplKCk7XG4gIH0sIDEwMCk7XG4gIGlmIChoYXZlTXV0YXRpb25zQXBpKSB7XG4gICAgci5zdHlsZU9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIob25SZXNpemUpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG5cbiAgICByLnN0eWxlT2JzZXJ2ZXIub2JzZXJ2ZShyLmNvbnRhaW5lciwge1xuICAgICAgYXR0cmlidXRlczogdHJ1ZVxuICAgIH0pO1xuICB9XG5cbiAgLy8gYXV0byByZXNpemVcbiAgci5yZWdpc3RlckJpbmRpbmcoY29udGFpbmVyV2luZG93LCAncmVzaXplJywgb25SZXNpemUpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG5cbiAgaWYgKGhhdmVSZXNpemVPYnNlcnZlckFwaSkge1xuICAgIHIucmVzaXplT2JzZXJ2ZXIgPSBuZXcgUmVzaXplT2JzZXJ2ZXIob25SZXNpemUpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG5cbiAgICByLnJlc2l6ZU9ic2VydmVyLm9ic2VydmUoci5jb250YWluZXIpO1xuICB9XG4gIHZhciBmb3JFYWNoVXAgPSBmdW5jdGlvbiBmb3JFYWNoVXAoZG9tRWxlLCBmbikge1xuICAgIHdoaWxlIChkb21FbGUgIT0gbnVsbCkge1xuICAgICAgZm4oZG9tRWxlKTtcbiAgICAgIGRvbUVsZSA9IGRvbUVsZS5wYXJlbnROb2RlO1xuICAgIH1cbiAgfTtcbiAgdmFyIGludmFsaWRhdGVDb29yZHMgPSBmdW5jdGlvbiBpbnZhbGlkYXRlQ29vcmRzKCkge1xuICAgIHIuaW52YWxpZGF0ZUNvbnRhaW5lckNsaWVudENvb3Jkc0NhY2hlKCk7XG4gIH07XG4gIGZvckVhY2hVcChyLmNvbnRhaW5lciwgZnVuY3Rpb24gKGRvbUVsZSkge1xuICAgIHIucmVnaXN0ZXJCaW5kaW5nKGRvbUVsZSwgJ3RyYW5zaXRpb25lbmQnLCBpbnZhbGlkYXRlQ29vcmRzKTtcbiAgICByLnJlZ2lzdGVyQmluZGluZyhkb21FbGUsICdhbmltYXRpb25lbmQnLCBpbnZhbGlkYXRlQ29vcmRzKTtcbiAgICByLnJlZ2lzdGVyQmluZGluZyhkb21FbGUsICdzY3JvbGwnLCBpbnZhbGlkYXRlQ29vcmRzKTtcbiAgfSk7XG5cbiAgLy8gc3RvcCByaWdodCBjbGljayBtZW51IGZyb20gYXBwZWFyaW5nIG9uIGN5XG4gIHIucmVnaXN0ZXJCaW5kaW5nKHIuY29udGFpbmVyLCAnY29udGV4dG1lbnUnLCBmdW5jdGlvbiAoZSkge1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgfSk7XG4gIHZhciBpbkJveFNlbGVjdGlvbiA9IGZ1bmN0aW9uIGluQm94U2VsZWN0aW9uKCkge1xuICAgIHJldHVybiByLnNlbGVjdGlvbls0XSAhPT0gMDtcbiAgfTtcbiAgdmFyIGV2ZW50SW5Db250YWluZXIgPSBmdW5jdGlvbiBldmVudEluQ29udGFpbmVyKGUpIHtcbiAgICAvLyBzYXZlIGN5Y2xlcyBpZiBtb3VzZSBldmVudHMgYXJlbid0IHRvIGJlIGNhcHR1cmVkXG4gICAgdmFyIGNvbnRhaW5lclBhZ2VDb29yZHMgPSByLmZpbmRDb250YWluZXJDbGllbnRDb29yZHMoKTtcbiAgICB2YXIgeCA9IGNvbnRhaW5lclBhZ2VDb29yZHNbMF07XG4gICAgdmFyIHkgPSBjb250YWluZXJQYWdlQ29vcmRzWzFdO1xuICAgIHZhciB3aWR0aCA9IGNvbnRhaW5lclBhZ2VDb29yZHNbMl07XG4gICAgdmFyIGhlaWdodCA9IGNvbnRhaW5lclBhZ2VDb29yZHNbM107XG4gICAgdmFyIHBvc2l0aW9ucyA9IGUudG91Y2hlcyA/IGUudG91Y2hlcyA6IFtlXTtcbiAgICB2YXIgYXRMZWFzdE9uZVBvc0luc2lkZSA9IGZhbHNlO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9zaXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcCA9IHBvc2l0aW9uc1tpXTtcbiAgICAgIGlmICh4IDw9IHAuY2xpZW50WCAmJiBwLmNsaWVudFggPD0geCArIHdpZHRoICYmIHkgPD0gcC5jbGllbnRZICYmIHAuY2xpZW50WSA8PSB5ICsgaGVpZ2h0KSB7XG4gICAgICAgIGF0TGVhc3RPbmVQb3NJbnNpZGUgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFhdExlYXN0T25lUG9zSW5zaWRlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHZhciBjb250YWluZXIgPSByLmNvbnRhaW5lcjtcbiAgICB2YXIgdGFyZ2V0ID0gZS50YXJnZXQ7XG4gICAgdmFyIHRQYXJlbnQgPSB0YXJnZXQucGFyZW50Tm9kZTtcbiAgICB2YXIgY29udGFpbmVySXNUYXJnZXQgPSBmYWxzZTtcbiAgICB3aGlsZSAodFBhcmVudCkge1xuICAgICAgaWYgKHRQYXJlbnQgPT09IGNvbnRhaW5lcikge1xuICAgICAgICBjb250YWluZXJJc1RhcmdldCA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgdFBhcmVudCA9IHRQYXJlbnQucGFyZW50Tm9kZTtcbiAgICB9XG4gICAgaWYgKCFjb250YWluZXJJc1RhcmdldCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gLy8gaWYgdGFyZ2V0IGlzIG91dGlzZGUgY3kgY29udGFpbmVyLCB0aGVuIHRoaXMgZXZlbnQgaXMgbm90IGZvciB1c1xuXG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgLy8gUHJpbWFyeSBrZXlcbiAgci5yZWdpc3RlckJpbmRpbmcoci5jb250YWluZXIsICdtb3VzZWRvd24nLCBmdW5jdGlvbiBtb3VzZWRvd25IYW5kbGVyKGUpIHtcbiAgICBpZiAoIWV2ZW50SW5Db250YWluZXIoZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBkdXJpbmcgbGVmdCBtb3VzZSBidXR0b24gZ2VzdHVyZXMsIGlnbm9yZSBvdGhlciBidXR0b25zXG4gICAgaWYgKHIuaG92ZXJEYXRhLndoaWNoID09PSAxICYmIGUud2hpY2ggIT09IDEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGJsdXJBY3RpdmVEb21FbGVtZW50KCk7XG4gICAgci5ob3ZlckRhdGEuY2FwdHVyZSA9IHRydWU7XG4gICAgci5ob3ZlckRhdGEud2hpY2ggPSBlLndoaWNoO1xuICAgIHZhciBjeSA9IHIuY3k7XG4gICAgdmFyIGdwb3MgPSBbZS5jbGllbnRYLCBlLmNsaWVudFldO1xuICAgIHZhciBwb3MgPSByLnByb2plY3RJbnRvVmlld3BvcnQoZ3Bvc1swXSwgZ3Bvc1sxXSk7XG4gICAgdmFyIHNlbGVjdCA9IHIuc2VsZWN0aW9uO1xuICAgIHZhciBuZWFycyA9IHIuZmluZE5lYXJlc3RFbGVtZW50cyhwb3NbMF0sIHBvc1sxXSwgdHJ1ZSwgZmFsc2UpO1xuICAgIHZhciBuZWFyID0gbmVhcnNbMF07XG4gICAgdmFyIGRyYWdnZWRFbGVtZW50cyA9IHIuZHJhZ0RhdGEucG9zc2libGVEcmFnRWxlbWVudHM7XG4gICAgci5ob3ZlckRhdGEubWRvd25Qb3MgPSBwb3M7XG4gICAgci5ob3ZlckRhdGEubWRvd25HUG9zID0gZ3BvcztcbiAgICB2YXIgY2hlY2tGb3JUYXBob2xkID0gZnVuY3Rpb24gY2hlY2tGb3JUYXBob2xkKCkge1xuICAgICAgci5ob3ZlckRhdGEudGFwaG9sZENhbmNlbGxlZCA9IGZhbHNlO1xuICAgICAgY2xlYXJUaW1lb3V0KHIuaG92ZXJEYXRhLnRhcGhvbGRUaW1lb3V0KTtcbiAgICAgIHIuaG92ZXJEYXRhLnRhcGhvbGRUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChyLmhvdmVyRGF0YS50YXBob2xkQ2FuY2VsbGVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBlbGUgPSByLmhvdmVyRGF0YS5kb3duO1xuICAgICAgICAgIGlmIChlbGUpIHtcbiAgICAgICAgICAgIGVsZS5lbWl0KHtcbiAgICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogZSxcbiAgICAgICAgICAgICAgdHlwZTogJ3RhcGhvbGQnLFxuICAgICAgICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgICAgICAgIHg6IHBvc1swXSxcbiAgICAgICAgICAgICAgICB5OiBwb3NbMV1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGN5LmVtaXQoe1xuICAgICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBlLFxuICAgICAgICAgICAgICB0eXBlOiAndGFwaG9sZCcsXG4gICAgICAgICAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgICAgICAgICAgeDogcG9zWzBdLFxuICAgICAgICAgICAgICAgIHk6IHBvc1sxXVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIHIudGFwaG9sZER1cmF0aW9uKTtcbiAgICB9O1xuXG4gICAgLy8gUmlnaHQgY2xpY2sgYnV0dG9uXG4gICAgaWYgKGUud2hpY2ggPT0gMykge1xuICAgICAgci5ob3ZlckRhdGEuY3h0U3RhcnRlZCA9IHRydWU7XG4gICAgICB2YXIgY3h0RXZ0ID0ge1xuICAgICAgICBvcmlnaW5hbEV2ZW50OiBlLFxuICAgICAgICB0eXBlOiAnY3h0dGFwc3RhcnQnLFxuICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgIHg6IHBvc1swXSxcbiAgICAgICAgICB5OiBwb3NbMV1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGlmIChuZWFyKSB7XG4gICAgICAgIG5lYXIuYWN0aXZhdGUoKTtcbiAgICAgICAgbmVhci5lbWl0KGN4dEV2dCk7XG4gICAgICAgIHIuaG92ZXJEYXRhLmRvd24gPSBuZWFyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3kuZW1pdChjeHRFdnQpO1xuICAgICAgfVxuICAgICAgci5ob3ZlckRhdGEuZG93blRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgIHIuaG92ZXJEYXRhLmN4dERyYWdnZWQgPSBmYWxzZTtcblxuICAgICAgLy8gUHJpbWFyeSBidXR0b25cbiAgICB9IGVsc2UgaWYgKGUud2hpY2ggPT0gMSkge1xuICAgICAgaWYgKG5lYXIpIHtcbiAgICAgICAgbmVhci5hY3RpdmF0ZSgpO1xuICAgICAgfVxuXG4gICAgICAvLyBFbGVtZW50IGRyYWdnaW5nXG4gICAgICB7XG4gICAgICAgIC8vIElmIHNvbWV0aGluZyBpcyB1bmRlciB0aGUgY3Vyc29yIGFuZCBpdCBpcyBkcmFnZ2FibGUsIHByZXBhcmUgdG8gZ3JhYiBpdFxuICAgICAgICBpZiAobmVhciAhPSBudWxsKSB7XG4gICAgICAgICAgaWYgKHIubm9kZUlzR3JhYmJhYmxlKG5lYXIpKSB7XG4gICAgICAgICAgICB2YXIgbWFrZUV2ZW50ID0gZnVuY3Rpb24gbWFrZUV2ZW50KHR5cGUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBlLFxuICAgICAgICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICAgICAgICAgIHg6IHBvc1swXSxcbiAgICAgICAgICAgICAgICAgIHk6IHBvc1sxXVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgdHJpZ2dlckdyYWIgPSBmdW5jdGlvbiB0cmlnZ2VyR3JhYihlbGUpIHtcbiAgICAgICAgICAgICAgZWxlLmVtaXQobWFrZUV2ZW50KCdncmFiJykpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHNldEdyYWJUYXJnZXQobmVhcik7XG4gICAgICAgICAgICBpZiAoIW5lYXIuc2VsZWN0ZWQoKSkge1xuICAgICAgICAgICAgICBkcmFnZ2VkRWxlbWVudHMgPSByLmRyYWdEYXRhLnBvc3NpYmxlRHJhZ0VsZW1lbnRzID0gY3kuY29sbGVjdGlvbigpO1xuICAgICAgICAgICAgICBhZGROb2RlVG9EcmFnKG5lYXIsIHtcbiAgICAgICAgICAgICAgICBhZGRUb0xpc3Q6IGRyYWdnZWRFbGVtZW50c1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgbmVhci5lbWl0KG1ha2VFdmVudCgnZ3JhYm9uJykpLmVtaXQobWFrZUV2ZW50KCdncmFiJykpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZHJhZ2dlZEVsZW1lbnRzID0gci5kcmFnRGF0YS5wb3NzaWJsZURyYWdFbGVtZW50cyA9IGN5LmNvbGxlY3Rpb24oKTtcbiAgICAgICAgICAgICAgdmFyIHNlbGVjdGVkTm9kZXMgPSBjeS4kKGZ1bmN0aW9uIChlbGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZWxlLmlzTm9kZSgpICYmIGVsZS5zZWxlY3RlZCgpICYmIHIubm9kZUlzR3JhYmJhYmxlKGVsZSk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBhZGROb2Rlc1RvRHJhZyhzZWxlY3RlZE5vZGVzLCB7XG4gICAgICAgICAgICAgICAgYWRkVG9MaXN0OiBkcmFnZ2VkRWxlbWVudHNcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIG5lYXIuZW1pdChtYWtlRXZlbnQoJ2dyYWJvbicpKTtcbiAgICAgICAgICAgICAgc2VsZWN0ZWROb2Rlcy5mb3JFYWNoKHRyaWdnZXJHcmFiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHIucmVkcmF3SGludCgnZWxlcycsIHRydWUpO1xuICAgICAgICAgICAgci5yZWRyYXdIaW50KCdkcmFnJywgdHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHIuaG92ZXJEYXRhLmRvd24gPSBuZWFyO1xuICAgICAgICByLmhvdmVyRGF0YS5kb3ducyA9IG5lYXJzO1xuICAgICAgICByLmhvdmVyRGF0YS5kb3duVGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgfVxuICAgICAgdHJpZ2dlckV2ZW50cyhuZWFyLCBbJ21vdXNlZG93bicsICd0YXBzdGFydCcsICd2bW91c2Vkb3duJ10sIGUsIHtcbiAgICAgICAgeDogcG9zWzBdLFxuICAgICAgICB5OiBwb3NbMV1cbiAgICAgIH0pO1xuICAgICAgaWYgKG5lYXIgPT0gbnVsbCkge1xuICAgICAgICBzZWxlY3RbNF0gPSAxO1xuICAgICAgICByLmRhdGEuYmdBY3RpdmVQb3Npc3Rpb24gPSB7XG4gICAgICAgICAgeDogcG9zWzBdLFxuICAgICAgICAgIHk6IHBvc1sxXVxuICAgICAgICB9O1xuICAgICAgICByLnJlZHJhd0hpbnQoJ3NlbGVjdCcsIHRydWUpO1xuICAgICAgICByLnJlZHJhdygpO1xuICAgICAgfSBlbHNlIGlmIChuZWFyLnBhbm5hYmxlKCkpIHtcbiAgICAgICAgc2VsZWN0WzRdID0gMTsgLy8gZm9yIGZ1dHVyZSBwYW5cbiAgICAgIH1cblxuICAgICAgY2hlY2tGb3JUYXBob2xkKCk7XG4gICAgfVxuXG4gICAgLy8gSW5pdGlhbGl6ZSBzZWxlY3Rpb24gYm94IGNvb3JkaW5hdGVzXG4gICAgc2VsZWN0WzBdID0gc2VsZWN0WzJdID0gcG9zWzBdO1xuICAgIHNlbGVjdFsxXSA9IHNlbGVjdFszXSA9IHBvc1sxXTtcbiAgfSwgZmFsc2UpO1xuICB2YXIgc2hhZG93Um9vdCA9IGdldFNoYWRvd1Jvb3Qoci5jb250YWluZXIpO1xuICByLnJlZ2lzdGVyQmluZGluZyhbY29udGFpbmVyV2luZG93LCBzaGFkb3dSb290XSwgJ21vdXNlbW92ZScsIGZ1bmN0aW9uIG1vdXNlbW92ZUhhbmRsZXIoZSkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbiAgICB2YXIgY2FwdHVyZSA9IHIuaG92ZXJEYXRhLmNhcHR1cmU7XG4gICAgaWYgKCFjYXB0dXJlICYmICFldmVudEluQ29udGFpbmVyKGUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBwcmV2ZW50RGVmYXVsdCA9IGZhbHNlO1xuICAgIHZhciBjeSA9IHIuY3k7XG4gICAgdmFyIHpvb20gPSBjeS56b29tKCk7XG4gICAgdmFyIGdwb3MgPSBbZS5jbGllbnRYLCBlLmNsaWVudFldO1xuICAgIHZhciBwb3MgPSByLnByb2plY3RJbnRvVmlld3BvcnQoZ3Bvc1swXSwgZ3Bvc1sxXSk7XG4gICAgdmFyIG1kb3duUG9zID0gci5ob3ZlckRhdGEubWRvd25Qb3M7XG4gICAgdmFyIG1kb3duR1BvcyA9IHIuaG92ZXJEYXRhLm1kb3duR1BvcztcbiAgICB2YXIgc2VsZWN0ID0gci5zZWxlY3Rpb247XG4gICAgdmFyIG5lYXIgPSBudWxsO1xuICAgIGlmICghci5ob3ZlckRhdGEuZHJhZ2dpbmdFbGVzICYmICFyLmhvdmVyRGF0YS5kcmFnZ2luZyAmJiAhci5ob3ZlckRhdGEuc2VsZWN0aW5nKSB7XG4gICAgICBuZWFyID0gci5maW5kTmVhcmVzdEVsZW1lbnQocG9zWzBdLCBwb3NbMV0sIHRydWUsIGZhbHNlKTtcbiAgICB9XG4gICAgdmFyIGxhc3QgPSByLmhvdmVyRGF0YS5sYXN0O1xuICAgIHZhciBkb3duID0gci5ob3ZlckRhdGEuZG93bjtcbiAgICB2YXIgZGlzcCA9IFtwb3NbMF0gLSBzZWxlY3RbMl0sIHBvc1sxXSAtIHNlbGVjdFszXV07XG4gICAgdmFyIGRyYWdnZWRFbGVtZW50cyA9IHIuZHJhZ0RhdGEucG9zc2libGVEcmFnRWxlbWVudHM7XG4gICAgdmFyIGlzT3ZlclRocmVzaG9sZERyYWc7XG4gICAgaWYgKG1kb3duR1Bvcykge1xuICAgICAgdmFyIGR4ID0gZ3Bvc1swXSAtIG1kb3duR1Bvc1swXTtcbiAgICAgIHZhciBkeDIgPSBkeCAqIGR4O1xuICAgICAgdmFyIGR5ID0gZ3Bvc1sxXSAtIG1kb3duR1Bvc1sxXTtcbiAgICAgIHZhciBkeTIgPSBkeSAqIGR5O1xuICAgICAgdmFyIGRpc3QyID0gZHgyICsgZHkyO1xuICAgICAgci5ob3ZlckRhdGEuaXNPdmVyVGhyZXNob2xkRHJhZyA9IGlzT3ZlclRocmVzaG9sZERyYWcgPSBkaXN0MiA+PSByLmRlc2t0b3BUYXBUaHJlc2hvbGQyO1xuICAgIH1cbiAgICB2YXIgbXVsdFNlbEtleURvd24gPSBpc011bHRTZWxLZXlEb3duKGUpO1xuICAgIGlmIChpc092ZXJUaHJlc2hvbGREcmFnKSB7XG4gICAgICByLmhvdmVyRGF0YS50YXBob2xkQ2FuY2VsbGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgdmFyIHVwZGF0ZURyYWdEZWx0YSA9IGZ1bmN0aW9uIHVwZGF0ZURyYWdEZWx0YSgpIHtcbiAgICAgIHZhciBkcmFnRGVsdGEgPSByLmhvdmVyRGF0YS5kcmFnRGVsdGEgPSByLmhvdmVyRGF0YS5kcmFnRGVsdGEgfHwgW107XG4gICAgICBpZiAoZHJhZ0RlbHRhLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBkcmFnRGVsdGEucHVzaChkaXNwWzBdKTtcbiAgICAgICAgZHJhZ0RlbHRhLnB1c2goZGlzcFsxXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkcmFnRGVsdGFbMF0gKz0gZGlzcFswXTtcbiAgICAgICAgZHJhZ0RlbHRhWzFdICs9IGRpc3BbMV07XG4gICAgICB9XG4gICAgfTtcbiAgICBwcmV2ZW50RGVmYXVsdCA9IHRydWU7XG4gICAgdHJpZ2dlckV2ZW50cyhuZWFyLCBbJ21vdXNlbW92ZScsICd2bW91c2Vtb3ZlJywgJ3RhcGRyYWcnXSwgZSwge1xuICAgICAgeDogcG9zWzBdLFxuICAgICAgeTogcG9zWzFdXG4gICAgfSk7XG4gICAgdmFyIGdvSW50b0JveE1vZGUgPSBmdW5jdGlvbiBnb0ludG9Cb3hNb2RlKCkge1xuICAgICAgci5kYXRhLmJnQWN0aXZlUG9zaXN0aW9uID0gdW5kZWZpbmVkO1xuICAgICAgaWYgKCFyLmhvdmVyRGF0YS5zZWxlY3RpbmcpIHtcbiAgICAgICAgY3kuZW1pdCh7XG4gICAgICAgICAgb3JpZ2luYWxFdmVudDogZSxcbiAgICAgICAgICB0eXBlOiAnYm94c3RhcnQnLFxuICAgICAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgICAgICB4OiBwb3NbMF0sXG4gICAgICAgICAgICB5OiBwb3NbMV1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgc2VsZWN0WzRdID0gMTtcbiAgICAgIHIuaG92ZXJEYXRhLnNlbGVjdGluZyA9IHRydWU7XG4gICAgICByLnJlZHJhd0hpbnQoJ3NlbGVjdCcsIHRydWUpO1xuICAgICAgci5yZWRyYXcoKTtcbiAgICB9O1xuXG4gICAgLy8gdHJpZ2dlciBjb250ZXh0IGRyYWcgaWYgcm1vdXNlIGRvd25cbiAgICBpZiAoci5ob3ZlckRhdGEud2hpY2ggPT09IDMpIHtcbiAgICAgIC8vIGJ1dCBvbmx5IGlmIG92ZXIgdGhyZXNob2xkXG4gICAgICBpZiAoaXNPdmVyVGhyZXNob2xkRHJhZykge1xuICAgICAgICB2YXIgY3h0RXZ0ID0ge1xuICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGUsXG4gICAgICAgICAgdHlwZTogJ2N4dGRyYWcnLFxuICAgICAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgICAgICB4OiBwb3NbMF0sXG4gICAgICAgICAgICB5OiBwb3NbMV1cbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGlmIChkb3duKSB7XG4gICAgICAgICAgZG93bi5lbWl0KGN4dEV2dCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3kuZW1pdChjeHRFdnQpO1xuICAgICAgICB9XG4gICAgICAgIHIuaG92ZXJEYXRhLmN4dERyYWdnZWQgPSB0cnVlO1xuICAgICAgICBpZiAoIXIuaG92ZXJEYXRhLmN4dE92ZXIgfHwgbmVhciAhPT0gci5ob3ZlckRhdGEuY3h0T3Zlcikge1xuICAgICAgICAgIGlmIChyLmhvdmVyRGF0YS5jeHRPdmVyKSB7XG4gICAgICAgICAgICByLmhvdmVyRGF0YS5jeHRPdmVyLmVtaXQoe1xuICAgICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBlLFxuICAgICAgICAgICAgICB0eXBlOiAnY3h0ZHJhZ291dCcsXG4gICAgICAgICAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgICAgICAgICAgeDogcG9zWzBdLFxuICAgICAgICAgICAgICAgIHk6IHBvc1sxXVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgci5ob3ZlckRhdGEuY3h0T3ZlciA9IG5lYXI7XG4gICAgICAgICAgaWYgKG5lYXIpIHtcbiAgICAgICAgICAgIG5lYXIuZW1pdCh7XG4gICAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGUsXG4gICAgICAgICAgICAgIHR5cGU6ICdjeHRkcmFnb3ZlcicsXG4gICAgICAgICAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgICAgICAgICAgeDogcG9zWzBdLFxuICAgICAgICAgICAgICAgIHk6IHBvc1sxXVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gQ2hlY2sgaWYgd2UgYXJlIGRyYWcgcGFubmluZyB0aGUgZW50aXJlIGdyYXBoXG4gICAgfSBlbHNlIGlmIChyLmhvdmVyRGF0YS5kcmFnZ2luZykge1xuICAgICAgcHJldmVudERlZmF1bHQgPSB0cnVlO1xuICAgICAgaWYgKGN5LnBhbm5pbmdFbmFibGVkKCkgJiYgY3kudXNlclBhbm5pbmdFbmFibGVkKCkpIHtcbiAgICAgICAgdmFyIGRlbHRhUDtcbiAgICAgICAgaWYgKHIuaG92ZXJEYXRhLmp1c3RTdGFydGVkUGFuKSB7XG4gICAgICAgICAgdmFyIG1kUG9zID0gci5ob3ZlckRhdGEubWRvd25Qb3M7XG4gICAgICAgICAgZGVsdGFQID0ge1xuICAgICAgICAgICAgeDogKHBvc1swXSAtIG1kUG9zWzBdKSAqIHpvb20sXG4gICAgICAgICAgICB5OiAocG9zWzFdIC0gbWRQb3NbMV0pICogem9vbVxuICAgICAgICAgIH07XG4gICAgICAgICAgci5ob3ZlckRhdGEuanVzdFN0YXJ0ZWRQYW4gPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWx0YVAgPSB7XG4gICAgICAgICAgICB4OiBkaXNwWzBdICogem9vbSxcbiAgICAgICAgICAgIHk6IGRpc3BbMV0gKiB6b29tXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjeS5wYW5CeShkZWx0YVApO1xuICAgICAgICBjeS5lbWl0KCdkcmFncGFuJyk7XG4gICAgICAgIHIuaG92ZXJEYXRhLmRyYWdnZWQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBOZWVkcyByZXByb2plY3QgZHVlIHRvIHBhbiBjaGFuZ2luZyB2aWV3cG9ydFxuICAgICAgcG9zID0gci5wcm9qZWN0SW50b1ZpZXdwb3J0KGUuY2xpZW50WCwgZS5jbGllbnRZKTtcblxuICAgICAgLy8gQ2hlY2tzIHByaW1hcnkgYnV0dG9uIGRvd24gJiBvdXQgb2YgdGltZSAmIG1vdXNlIG5vdCBtb3ZlZCBtdWNoXG4gICAgfSBlbHNlIGlmIChzZWxlY3RbNF0gPT0gMSAmJiAoZG93biA9PSBudWxsIHx8IGRvd24ucGFubmFibGUoKSkpIHtcbiAgICAgIGlmIChpc092ZXJUaHJlc2hvbGREcmFnKSB7XG4gICAgICAgIGlmICghci5ob3ZlckRhdGEuZHJhZ2dpbmcgJiYgY3kuYm94U2VsZWN0aW9uRW5hYmxlZCgpICYmIChtdWx0U2VsS2V5RG93biB8fCAhY3kucGFubmluZ0VuYWJsZWQoKSB8fCAhY3kudXNlclBhbm5pbmdFbmFibGVkKCkpKSB7XG4gICAgICAgICAgZ29JbnRvQm94TW9kZSgpO1xuICAgICAgICB9IGVsc2UgaWYgKCFyLmhvdmVyRGF0YS5zZWxlY3RpbmcgJiYgY3kucGFubmluZ0VuYWJsZWQoKSAmJiBjeS51c2VyUGFubmluZ0VuYWJsZWQoKSkge1xuICAgICAgICAgIHZhciBhbGxvd1Bhc3N0aHJvdWdoID0gYWxsb3dQYW5uaW5nUGFzc3Rocm91Z2goZG93biwgci5ob3ZlckRhdGEuZG93bnMpO1xuICAgICAgICAgIGlmIChhbGxvd1Bhc3N0aHJvdWdoKSB7XG4gICAgICAgICAgICByLmhvdmVyRGF0YS5kcmFnZ2luZyA9IHRydWU7XG4gICAgICAgICAgICByLmhvdmVyRGF0YS5qdXN0U3RhcnRlZFBhbiA9IHRydWU7XG4gICAgICAgICAgICBzZWxlY3RbNF0gPSAwO1xuICAgICAgICAgICAgci5kYXRhLmJnQWN0aXZlUG9zaXN0aW9uID0gYXJyYXkycG9pbnQobWRvd25Qb3MpO1xuICAgICAgICAgICAgci5yZWRyYXdIaW50KCdzZWxlY3QnLCB0cnVlKTtcbiAgICAgICAgICAgIHIucmVkcmF3KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChkb3duICYmIGRvd24ucGFubmFibGUoKSAmJiBkb3duLmFjdGl2ZSgpKSB7XG4gICAgICAgICAgZG93bi51bmFjdGl2YXRlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGRvd24gJiYgZG93bi5wYW5uYWJsZSgpICYmIGRvd24uYWN0aXZlKCkpIHtcbiAgICAgICAgZG93bi51bmFjdGl2YXRlKCk7XG4gICAgICB9XG4gICAgICBpZiAoKCFkb3duIHx8ICFkb3duLmdyYWJiZWQoKSkgJiYgbmVhciAhPSBsYXN0KSB7XG4gICAgICAgIGlmIChsYXN0KSB7XG4gICAgICAgICAgdHJpZ2dlckV2ZW50cyhsYXN0LCBbJ21vdXNlb3V0JywgJ3RhcGRyYWdvdXQnXSwgZSwge1xuICAgICAgICAgICAgeDogcG9zWzBdLFxuICAgICAgICAgICAgeTogcG9zWzFdXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5lYXIpIHtcbiAgICAgICAgICB0cmlnZ2VyRXZlbnRzKG5lYXIsIFsnbW91c2VvdmVyJywgJ3RhcGRyYWdvdmVyJ10sIGUsIHtcbiAgICAgICAgICAgIHg6IHBvc1swXSxcbiAgICAgICAgICAgIHk6IHBvc1sxXVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHIuaG92ZXJEYXRhLmxhc3QgPSBuZWFyO1xuICAgICAgfVxuICAgICAgaWYgKGRvd24pIHtcbiAgICAgICAgaWYgKGlzT3ZlclRocmVzaG9sZERyYWcpIHtcbiAgICAgICAgICAvLyB0aGVuIHdlIGNhbiB0YWtlIGFjdGlvblxuXG4gICAgICAgICAgaWYgKGN5LmJveFNlbGVjdGlvbkVuYWJsZWQoKSAmJiBtdWx0U2VsS2V5RG93bikge1xuICAgICAgICAgICAgLy8gdGhlbiBzZWxlY3Rpb24gb3ZlcnJpZGVzXG4gICAgICAgICAgICBpZiAoZG93biAmJiBkb3duLmdyYWJiZWQoKSkge1xuICAgICAgICAgICAgICBmcmVlRHJhZ2dlZEVsZW1lbnRzKGRyYWdnZWRFbGVtZW50cyk7XG4gICAgICAgICAgICAgIGRvd24uZW1pdCgnZnJlZW9uJyk7XG4gICAgICAgICAgICAgIGRyYWdnZWRFbGVtZW50cy5lbWl0KCdmcmVlJyk7XG4gICAgICAgICAgICAgIGlmIChyLmRyYWdEYXRhLmRpZERyYWcpIHtcbiAgICAgICAgICAgICAgICBkb3duLmVtaXQoJ2RyYWdmcmVlb24nKTtcbiAgICAgICAgICAgICAgICBkcmFnZ2VkRWxlbWVudHMuZW1pdCgnZHJhZ2ZyZWUnKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZ29JbnRvQm94TW9kZSgpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZG93biAmJiBkb3duLmdyYWJiZWQoKSAmJiByLm5vZGVJc0RyYWdnYWJsZShkb3duKSkge1xuICAgICAgICAgICAgLy8gZHJhZyBub2RlXG4gICAgICAgICAgICB2YXIganVzdFN0YXJ0ZWREcmFnID0gIXIuZHJhZ0RhdGEuZGlkRHJhZztcbiAgICAgICAgICAgIGlmIChqdXN0U3RhcnRlZERyYWcpIHtcbiAgICAgICAgICAgICAgci5yZWRyYXdIaW50KCdlbGVzJywgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByLmRyYWdEYXRhLmRpZERyYWcgPSB0cnVlOyAvLyBpbmRpY2F0ZSB0aGF0IHdlIGFjdHVhbGx5IGRpZCBkcmFnIHRoZSBub2RlXG5cbiAgICAgICAgICAgIC8vIG5vdywgYWRkIHRoZSBlbGVtZW50cyB0byB0aGUgZHJhZyBsYXllciBpZiBub3QgZG9uZSBhbHJlYWR5XG4gICAgICAgICAgICBpZiAoIXIuaG92ZXJEYXRhLmRyYWdnaW5nRWxlcykge1xuICAgICAgICAgICAgICBhZGROb2Rlc1RvRHJhZyhkcmFnZ2VkRWxlbWVudHMsIHtcbiAgICAgICAgICAgICAgICBpbkRyYWdMYXllcjogdHJ1ZVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB0b3RhbFNoaWZ0ID0ge1xuICAgICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgICB5OiAwXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKG51bWJlciQxKGRpc3BbMF0pICYmIG51bWJlciQxKGRpc3BbMV0pKSB7XG4gICAgICAgICAgICAgIHRvdGFsU2hpZnQueCArPSBkaXNwWzBdO1xuICAgICAgICAgICAgICB0b3RhbFNoaWZ0LnkgKz0gZGlzcFsxXTtcbiAgICAgICAgICAgICAgaWYgKGp1c3RTdGFydGVkRHJhZykge1xuICAgICAgICAgICAgICAgIHZhciBkcmFnRGVsdGEgPSByLmhvdmVyRGF0YS5kcmFnRGVsdGE7XG4gICAgICAgICAgICAgICAgaWYgKGRyYWdEZWx0YSAmJiBudW1iZXIkMShkcmFnRGVsdGFbMF0pICYmIG51bWJlciQxKGRyYWdEZWx0YVsxXSkpIHtcbiAgICAgICAgICAgICAgICAgIHRvdGFsU2hpZnQueCArPSBkcmFnRGVsdGFbMF07XG4gICAgICAgICAgICAgICAgICB0b3RhbFNoaWZ0LnkgKz0gZHJhZ0RlbHRhWzFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgci5ob3ZlckRhdGEuZHJhZ2dpbmdFbGVzID0gdHJ1ZTtcbiAgICAgICAgICAgIGRyYWdnZWRFbGVtZW50cy5zaWxlbnRTaGlmdCh0b3RhbFNoaWZ0KS5lbWl0KCdwb3NpdGlvbiBkcmFnJyk7XG4gICAgICAgICAgICByLnJlZHJhd0hpbnQoJ2RyYWcnLCB0cnVlKTtcbiAgICAgICAgICAgIHIucmVkcmF3KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIG90aGVyd2lzZSBzYXZlIGRyYWcgZGVsdGEgZm9yIHdoZW4gd2UgYWN0dWFsbHkgc3RhcnQgZHJhZ2dpbmcgc28gdGhlIHJlbGF0aXZlIGdyYWIgcG9zIGlzIGNvbnN0YW50XG4gICAgICAgICAgdXBkYXRlRHJhZ0RlbHRhKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gcHJldmVudCB0aGUgZHJhZ2dpbmcgZnJvbSB0cmlnZ2VyaW5nIHRleHQgc2VsZWN0aW9uIG9uIHRoZSBwYWdlXG4gICAgICBwcmV2ZW50RGVmYXVsdCA9IHRydWU7XG4gICAgfVxuICAgIHNlbGVjdFsyXSA9IHBvc1swXTtcbiAgICBzZWxlY3RbM10gPSBwb3NbMV07XG4gICAgaWYgKHByZXZlbnREZWZhdWx0KSB7XG4gICAgICBpZiAoZS5zdG9wUHJvcGFnYXRpb24pIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICBpZiAoZS5wcmV2ZW50RGVmYXVsdCkgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSwgZmFsc2UpO1xuICB2YXIgY2xpY2tUaW1lb3V0LCBkaWREb3VibGVDbGljaywgcHJldkNsaWNrVGltZVN0YW1wO1xuICByLnJlZ2lzdGVyQmluZGluZyhjb250YWluZXJXaW5kb3csICdtb3VzZXVwJywgZnVuY3Rpb24gbW91c2V1cEhhbmRsZXIoZSkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbiAgICAvLyBkdXJpbmcgbGVmdCBtb3VzZSBidXR0b24gZ2VzdHVyZXMsIGlnbm9yZSBvdGhlciBidXR0b25zXG4gICAgaWYgKHIuaG92ZXJEYXRhLndoaWNoID09PSAxICYmIGUud2hpY2ggIT09IDEgJiYgci5ob3ZlckRhdGEuY2FwdHVyZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgY2FwdHVyZSA9IHIuaG92ZXJEYXRhLmNhcHR1cmU7XG4gICAgaWYgKCFjYXB0dXJlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHIuaG92ZXJEYXRhLmNhcHR1cmUgPSBmYWxzZTtcbiAgICB2YXIgY3kgPSByLmN5O1xuICAgIHZhciBwb3MgPSByLnByb2plY3RJbnRvVmlld3BvcnQoZS5jbGllbnRYLCBlLmNsaWVudFkpO1xuICAgIHZhciBzZWxlY3QgPSByLnNlbGVjdGlvbjtcbiAgICB2YXIgbmVhciA9IHIuZmluZE5lYXJlc3RFbGVtZW50KHBvc1swXSwgcG9zWzFdLCB0cnVlLCBmYWxzZSk7XG4gICAgdmFyIGRyYWdnZWRFbGVtZW50cyA9IHIuZHJhZ0RhdGEucG9zc2libGVEcmFnRWxlbWVudHM7XG4gICAgdmFyIGRvd24gPSByLmhvdmVyRGF0YS5kb3duO1xuICAgIHZhciBtdWx0U2VsS2V5RG93biA9IGlzTXVsdFNlbEtleURvd24oZSk7XG4gICAgaWYgKHIuZGF0YS5iZ0FjdGl2ZVBvc2lzdGlvbikge1xuICAgICAgci5yZWRyYXdIaW50KCdzZWxlY3QnLCB0cnVlKTtcbiAgICAgIHIucmVkcmF3KCk7XG4gICAgfVxuICAgIHIuaG92ZXJEYXRhLnRhcGhvbGRDYW5jZWxsZWQgPSB0cnVlO1xuICAgIHIuZGF0YS5iZ0FjdGl2ZVBvc2lzdGlvbiA9IHVuZGVmaW5lZDsgLy8gbm90IGFjdGl2ZSBiZyBub3dcblxuICAgIGlmIChkb3duKSB7XG4gICAgICBkb3duLnVuYWN0aXZhdGUoKTtcbiAgICB9XG4gICAgaWYgKHIuaG92ZXJEYXRhLndoaWNoID09PSAzKSB7XG4gICAgICB2YXIgY3h0RXZ0ID0ge1xuICAgICAgICBvcmlnaW5hbEV2ZW50OiBlLFxuICAgICAgICB0eXBlOiAnY3h0dGFwZW5kJyxcbiAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICB4OiBwb3NbMF0sXG4gICAgICAgICAgeTogcG9zWzFdXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBpZiAoZG93bikge1xuICAgICAgICBkb3duLmVtaXQoY3h0RXZ0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN5LmVtaXQoY3h0RXZ0KTtcbiAgICAgIH1cbiAgICAgIGlmICghci5ob3ZlckRhdGEuY3h0RHJhZ2dlZCkge1xuICAgICAgICB2YXIgY3h0VGFwID0ge1xuICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGUsXG4gICAgICAgICAgdHlwZTogJ2N4dHRhcCcsXG4gICAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICAgIHg6IHBvc1swXSxcbiAgICAgICAgICAgIHk6IHBvc1sxXVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGRvd24pIHtcbiAgICAgICAgICBkb3duLmVtaXQoY3h0VGFwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjeS5lbWl0KGN4dFRhcCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHIuaG92ZXJEYXRhLmN4dERyYWdnZWQgPSBmYWxzZTtcbiAgICAgIHIuaG92ZXJEYXRhLndoaWNoID0gbnVsbDtcbiAgICB9IGVsc2UgaWYgKHIuaG92ZXJEYXRhLndoaWNoID09PSAxKSB7XG4gICAgICB0cmlnZ2VyRXZlbnRzKG5lYXIsIFsnbW91c2V1cCcsICd0YXBlbmQnLCAndm1vdXNldXAnXSwgZSwge1xuICAgICAgICB4OiBwb3NbMF0sXG4gICAgICAgIHk6IHBvc1sxXVxuICAgICAgfSk7XG4gICAgICBpZiAoIXIuZHJhZ0RhdGEuZGlkRHJhZyAmJlxuICAgICAgLy8gZGlkbid0IG1vdmUgYSBub2RlIGFyb3VuZFxuICAgICAgIXIuaG92ZXJEYXRhLmRyYWdnZWQgJiZcbiAgICAgIC8vIGRpZG4ndCBwYW5cbiAgICAgICFyLmhvdmVyRGF0YS5zZWxlY3RpbmcgJiZcbiAgICAgIC8vIG5vdCBib3ggc2VsZWN0aW9uXG4gICAgICAhci5ob3ZlckRhdGEuaXNPdmVyVGhyZXNob2xkRHJhZyAvLyBkaWRuJ3QgbW92ZSB0b28gbXVjaFxuICAgICAgKSB7XG4gICAgICAgIHRyaWdnZXJFdmVudHMoZG93biwgW1wiY2xpY2tcIiwgXCJ0YXBcIiwgXCJ2Y2xpY2tcIl0sIGUsIHtcbiAgICAgICAgICB4OiBwb3NbMF0sXG4gICAgICAgICAgeTogcG9zWzFdXG4gICAgICAgIH0pO1xuICAgICAgICBkaWREb3VibGVDbGljayA9IGZhbHNlO1xuICAgICAgICBpZiAoZS50aW1lU3RhbXAgLSBwcmV2Q2xpY2tUaW1lU3RhbXAgPD0gY3kubXVsdGlDbGlja0RlYm91bmNlVGltZSgpKSB7XG4gICAgICAgICAgY2xpY2tUaW1lb3V0ICYmIGNsZWFyVGltZW91dChjbGlja1RpbWVvdXQpO1xuICAgICAgICAgIGRpZERvdWJsZUNsaWNrID0gdHJ1ZTtcbiAgICAgICAgICBwcmV2Q2xpY2tUaW1lU3RhbXAgPSBudWxsO1xuICAgICAgICAgIHRyaWdnZXJFdmVudHMoZG93biwgW1wiZGJsY2xpY2tcIiwgXCJkYmx0YXBcIiwgXCJ2ZGJsY2xpY2tcIl0sIGUsIHtcbiAgICAgICAgICAgIHg6IHBvc1swXSxcbiAgICAgICAgICAgIHk6IHBvc1sxXVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNsaWNrVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGRpZERvdWJsZUNsaWNrKSByZXR1cm47XG4gICAgICAgICAgICB0cmlnZ2VyRXZlbnRzKGRvd24sIFtcIm9uZWNsaWNrXCIsIFwib25ldGFwXCIsIFwidm9uZWNsaWNrXCJdLCBlLCB7XG4gICAgICAgICAgICAgIHg6IHBvc1swXSxcbiAgICAgICAgICAgICAgeTogcG9zWzFdXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9LCBjeS5tdWx0aUNsaWNrRGVib3VuY2VUaW1lKCkpO1xuICAgICAgICAgIHByZXZDbGlja1RpbWVTdGFtcCA9IGUudGltZVN0YW1wO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIERlc2VsZWN0IGFsbCBlbGVtZW50cyBpZiBub3RoaW5nIGlzIGN1cnJlbnRseSB1bmRlciB0aGUgbW91c2UgY3Vyc29yIGFuZCB3ZSBhcmVuJ3QgZHJhZ2dpbmcgc29tZXRoaW5nXG4gICAgICBpZiAoZG93biA9PSBudWxsIC8vIG5vdCBtb3VzZWRvd24gb24gbm9kZVxuICAgICAgJiYgIXIuZHJhZ0RhdGEuZGlkRHJhZyAvLyBkaWRuJ3QgbW92ZSB0aGUgbm9kZSBhcm91bmRcbiAgICAgICYmICFyLmhvdmVyRGF0YS5zZWxlY3RpbmcgLy8gbm90IGJveCBzZWxlY3Rpb25cbiAgICAgICYmICFyLmhvdmVyRGF0YS5kcmFnZ2VkIC8vIGRpZG4ndCBwYW5cbiAgICAgICYmICFpc011bHRTZWxLZXlEb3duKGUpKSB7XG4gICAgICAgIGN5LiQoaXNTZWxlY3RlZCkudW5zZWxlY3QoWyd0YXB1bnNlbGVjdCddKTtcbiAgICAgICAgaWYgKGRyYWdnZWRFbGVtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgci5yZWRyYXdIaW50KCdlbGVzJywgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgci5kcmFnRGF0YS5wb3NzaWJsZURyYWdFbGVtZW50cyA9IGRyYWdnZWRFbGVtZW50cyA9IGN5LmNvbGxlY3Rpb24oKTtcbiAgICAgIH1cblxuICAgICAgLy8gU2luZ2xlIHNlbGVjdGlvblxuICAgICAgaWYgKG5lYXIgPT0gZG93biAmJiAhci5kcmFnRGF0YS5kaWREcmFnICYmICFyLmhvdmVyRGF0YS5zZWxlY3RpbmcpIHtcbiAgICAgICAgaWYgKG5lYXIgIT0gbnVsbCAmJiBuZWFyLl9wcml2YXRlLnNlbGVjdGFibGUpIHtcbiAgICAgICAgICBpZiAoci5ob3ZlckRhdGEuZHJhZ2dpbmcpIDsgZWxzZSBpZiAoY3kuc2VsZWN0aW9uVHlwZSgpID09PSAnYWRkaXRpdmUnIHx8IG11bHRTZWxLZXlEb3duKSB7XG4gICAgICAgICAgICBpZiAobmVhci5zZWxlY3RlZCgpKSB7XG4gICAgICAgICAgICAgIG5lYXIudW5zZWxlY3QoWyd0YXB1bnNlbGVjdCddKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG5lYXIuc2VsZWN0KFsndGFwc2VsZWN0J10pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIW11bHRTZWxLZXlEb3duKSB7XG4gICAgICAgICAgICAgIGN5LiQoaXNTZWxlY3RlZCkudW5tZXJnZShuZWFyKS51bnNlbGVjdChbJ3RhcHVuc2VsZWN0J10pO1xuICAgICAgICAgICAgICBuZWFyLnNlbGVjdChbJ3RhcHNlbGVjdCddKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgci5yZWRyYXdIaW50KCdlbGVzJywgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChyLmhvdmVyRGF0YS5zZWxlY3RpbmcpIHtcbiAgICAgICAgdmFyIGJveCA9IGN5LmNvbGxlY3Rpb24oci5nZXRBbGxJbkJveChzZWxlY3RbMF0sIHNlbGVjdFsxXSwgc2VsZWN0WzJdLCBzZWxlY3RbM10pKTtcbiAgICAgICAgci5yZWRyYXdIaW50KCdzZWxlY3QnLCB0cnVlKTtcbiAgICAgICAgaWYgKGJveC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgci5yZWRyYXdIaW50KCdlbGVzJywgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgY3kuZW1pdCh7XG4gICAgICAgICAgdHlwZTogJ2JveGVuZCcsXG4gICAgICAgICAgb3JpZ2luYWxFdmVudDogZSxcbiAgICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgICAgeDogcG9zWzBdLFxuICAgICAgICAgICAgeTogcG9zWzFdXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGVsZVdvdWxkQmVTZWxlY3RlZCA9IGZ1bmN0aW9uIGVsZVdvdWxkQmVTZWxlY3RlZChlbGUpIHtcbiAgICAgICAgICByZXR1cm4gZWxlLnNlbGVjdGFibGUoKSAmJiAhZWxlLnNlbGVjdGVkKCk7XG4gICAgICAgIH07XG4gICAgICAgIGlmIChjeS5zZWxlY3Rpb25UeXBlKCkgPT09ICdhZGRpdGl2ZScpIHtcbiAgICAgICAgICBib3guZW1pdCgnYm94Jykuc3RkRmlsdGVyKGVsZVdvdWxkQmVTZWxlY3RlZCkuc2VsZWN0KCkuZW1pdCgnYm94c2VsZWN0Jyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKCFtdWx0U2VsS2V5RG93bikge1xuICAgICAgICAgICAgY3kuJChpc1NlbGVjdGVkKS51bm1lcmdlKGJveCkudW5zZWxlY3QoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYm94LmVtaXQoJ2JveCcpLnN0ZEZpbHRlcihlbGVXb3VsZEJlU2VsZWN0ZWQpLnNlbGVjdCgpLmVtaXQoJ2JveHNlbGVjdCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYWx3YXlzIG5lZWQgcmVkcmF3IGluIGNhc2UgZWxlcyB1bnNlbGVjdGFibGVcbiAgICAgICAgci5yZWRyYXcoKTtcbiAgICAgIH1cblxuICAgICAgLy8gQ2FuY2VsIGRyYWcgcGFuXG4gICAgICBpZiAoci5ob3ZlckRhdGEuZHJhZ2dpbmcpIHtcbiAgICAgICAgci5ob3ZlckRhdGEuZHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgci5yZWRyYXdIaW50KCdzZWxlY3QnLCB0cnVlKTtcbiAgICAgICAgci5yZWRyYXdIaW50KCdlbGVzJywgdHJ1ZSk7XG4gICAgICAgIHIucmVkcmF3KCk7XG4gICAgICB9XG4gICAgICBpZiAoIXNlbGVjdFs0XSkge1xuICAgICAgICByLnJlZHJhd0hpbnQoJ2RyYWcnLCB0cnVlKTtcbiAgICAgICAgci5yZWRyYXdIaW50KCdlbGVzJywgdHJ1ZSk7XG4gICAgICAgIHZhciBkb3duV2FzR3JhYmJlZCA9IGRvd24gJiYgZG93bi5ncmFiYmVkKCk7XG4gICAgICAgIGZyZWVEcmFnZ2VkRWxlbWVudHMoZHJhZ2dlZEVsZW1lbnRzKTtcbiAgICAgICAgaWYgKGRvd25XYXNHcmFiYmVkKSB7XG4gICAgICAgICAgZG93bi5lbWl0KCdmcmVlb24nKTtcbiAgICAgICAgICBkcmFnZ2VkRWxlbWVudHMuZW1pdCgnZnJlZScpO1xuICAgICAgICAgIGlmIChyLmRyYWdEYXRhLmRpZERyYWcpIHtcbiAgICAgICAgICAgIGRvd24uZW1pdCgnZHJhZ2ZyZWVvbicpO1xuICAgICAgICAgICAgZHJhZ2dlZEVsZW1lbnRzLmVtaXQoJ2RyYWdmcmVlJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSAvLyBlbHNlIG5vdCByaWdodCBtb3VzZVxuXG4gICAgc2VsZWN0WzRdID0gMDtcbiAgICByLmhvdmVyRGF0YS5kb3duID0gbnVsbDtcbiAgICByLmhvdmVyRGF0YS5jeHRTdGFydGVkID0gZmFsc2U7XG4gICAgci5ob3ZlckRhdGEuZHJhZ2dpbmdFbGVzID0gZmFsc2U7XG4gICAgci5ob3ZlckRhdGEuc2VsZWN0aW5nID0gZmFsc2U7XG4gICAgci5ob3ZlckRhdGEuaXNPdmVyVGhyZXNob2xkRHJhZyA9IGZhbHNlO1xuICAgIHIuZHJhZ0RhdGEuZGlkRHJhZyA9IGZhbHNlO1xuICAgIHIuaG92ZXJEYXRhLmRyYWdnZWQgPSBmYWxzZTtcbiAgICByLmhvdmVyRGF0YS5kcmFnRGVsdGEgPSBbXTtcbiAgICByLmhvdmVyRGF0YS5tZG93blBvcyA9IG51bGw7XG4gICAgci5ob3ZlckRhdGEubWRvd25HUG9zID0gbnVsbDtcbiAgICByLmhvdmVyRGF0YS53aGljaCA9IG51bGw7XG4gIH0sIGZhbHNlKTtcbiAgdmFyIHdoZWVsSGFuZGxlciA9IGZ1bmN0aW9uIHdoZWVsSGFuZGxlcihlKSB7XG4gICAgaWYgKHIuc2Nyb2xsaW5nUGFnZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gd2hpbGUgc2Nyb2xsaW5nLCBpZ25vcmUgd2hlZWwtdG8tem9vbVxuXG4gICAgdmFyIGN5ID0gci5jeTtcbiAgICB2YXIgem9vbSA9IGN5Lnpvb20oKTtcbiAgICB2YXIgcGFuID0gY3kucGFuKCk7XG4gICAgdmFyIHBvcyA9IHIucHJvamVjdEludG9WaWV3cG9ydChlLmNsaWVudFgsIGUuY2xpZW50WSk7XG4gICAgdmFyIHJwb3MgPSBbcG9zWzBdICogem9vbSArIHBhbi54LCBwb3NbMV0gKiB6b29tICsgcGFuLnldO1xuICAgIGlmIChyLmhvdmVyRGF0YS5kcmFnZ2luZ0VsZXMgfHwgci5ob3ZlckRhdGEuZHJhZ2dpbmcgfHwgci5ob3ZlckRhdGEuY3h0U3RhcnRlZCB8fCBpbkJveFNlbGVjdGlvbigpKSB7XG4gICAgICAvLyBpZiBwYW4gZHJhZ2dpbmcgb3IgY3h0IGRyYWdnaW5nLCB3aGVlbCBtb3ZlbWVudHMgbWFrZSBubyB6b29tXG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChjeS5wYW5uaW5nRW5hYmxlZCgpICYmIGN5LnVzZXJQYW5uaW5nRW5hYmxlZCgpICYmIGN5Lnpvb21pbmdFbmFibGVkKCkgJiYgY3kudXNlclpvb21pbmdFbmFibGVkKCkpIHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHIuZGF0YS53aGVlbFpvb21pbmcgPSB0cnVlO1xuICAgICAgY2xlYXJUaW1lb3V0KHIuZGF0YS53aGVlbFRpbWVvdXQpO1xuICAgICAgci5kYXRhLndoZWVsVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICByLmRhdGEud2hlZWxab29taW5nID0gZmFsc2U7XG4gICAgICAgIHIucmVkcmF3SGludCgnZWxlcycsIHRydWUpO1xuICAgICAgICByLnJlZHJhdygpO1xuICAgICAgfSwgMTUwKTtcbiAgICAgIHZhciBkaWZmO1xuICAgICAgaWYgKGUuZGVsdGFZICE9IG51bGwpIHtcbiAgICAgICAgZGlmZiA9IGUuZGVsdGFZIC8gLTI1MDtcbiAgICAgIH0gZWxzZSBpZiAoZS53aGVlbERlbHRhWSAhPSBudWxsKSB7XG4gICAgICAgIGRpZmYgPSBlLndoZWVsRGVsdGFZIC8gMTAwMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRpZmYgPSBlLndoZWVsRGVsdGEgLyAxMDAwO1xuICAgICAgfVxuICAgICAgZGlmZiA9IGRpZmYgKiByLndoZWVsU2Vuc2l0aXZpdHk7XG4gICAgICB2YXIgbmVlZHNXaGVlbEZpeCA9IGUuZGVsdGFNb2RlID09PSAxO1xuICAgICAgaWYgKG5lZWRzV2hlZWxGaXgpIHtcbiAgICAgICAgLy8gZml4ZXMgc2xvdyB3aGVlbCBldmVudHMgb24gZmYvbGludXggYW5kIGZmL3dpbmRvd3NcbiAgICAgICAgZGlmZiAqPSAzMztcbiAgICAgIH1cbiAgICAgIHZhciBuZXdab29tID0gY3kuem9vbSgpICogTWF0aC5wb3coMTAsIGRpZmYpO1xuICAgICAgaWYgKGUudHlwZSA9PT0gJ2dlc3R1cmVjaGFuZ2UnKSB7XG4gICAgICAgIG5ld1pvb20gPSByLmdlc3R1cmVTdGFydFpvb20gKiBlLnNjYWxlO1xuICAgICAgfVxuICAgICAgY3kuem9vbSh7XG4gICAgICAgIGxldmVsOiBuZXdab29tLFxuICAgICAgICByZW5kZXJlZFBvc2l0aW9uOiB7XG4gICAgICAgICAgeDogcnBvc1swXSxcbiAgICAgICAgICB5OiBycG9zWzFdXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgY3kuZW1pdChlLnR5cGUgPT09ICdnZXN0dXJlY2hhbmdlJyA/ICdwaW5jaHpvb20nIDogJ3Njcm9sbHpvb20nKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gRnVuY3Rpb25zIHRvIGhlbHAgd2l0aCB3aGV0aGVyIG1vdXNlIHdoZWVsIHNob3VsZCB0cmlnZ2VyIHpvb21pbmdcbiAgLy8gLS1cbiAgci5yZWdpc3RlckJpbmRpbmcoci5jb250YWluZXIsICd3aGVlbCcsIHdoZWVsSGFuZGxlciwgdHJ1ZSk7XG5cbiAgLy8gZGlzYWJsZSBub25zdGFuZGFyZCB3aGVlbCBldmVudHNcbiAgLy8gci5yZWdpc3RlckJpbmRpbmcoci5jb250YWluZXIsICdtb3VzZXdoZWVsJywgd2hlZWxIYW5kbGVyLCB0cnVlKTtcbiAgLy8gci5yZWdpc3RlckJpbmRpbmcoci5jb250YWluZXIsICdET01Nb3VzZVNjcm9sbCcsIHdoZWVsSGFuZGxlciwgdHJ1ZSk7XG4gIC8vIHIucmVnaXN0ZXJCaW5kaW5nKHIuY29udGFpbmVyLCAnTW96TW91c2VQaXhlbFNjcm9sbCcsIHdoZWVsSGFuZGxlciwgdHJ1ZSk7IC8vIG9sZGVyIGZpcmVmb3hcblxuICByLnJlZ2lzdGVyQmluZGluZyhjb250YWluZXJXaW5kb3csICdzY3JvbGwnLCBmdW5jdGlvbiBzY3JvbGxIYW5kbGVyKGUpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgci5zY3JvbGxpbmdQYWdlID0gdHJ1ZTtcbiAgICBjbGVhclRpbWVvdXQoci5zY3JvbGxpbmdQYWdlVGltZW91dCk7XG4gICAgci5zY3JvbGxpbmdQYWdlVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgci5zY3JvbGxpbmdQYWdlID0gZmFsc2U7XG4gICAgfSwgMjUwKTtcbiAgfSwgdHJ1ZSk7XG5cbiAgLy8gZGVza3RvcCBzYWZhcmkgcGluY2ggdG8gem9vbSBzdGFydFxuICByLnJlZ2lzdGVyQmluZGluZyhyLmNvbnRhaW5lciwgJ2dlc3R1cmVzdGFydCcsIGZ1bmN0aW9uIGdlc3R1cmVTdGFydEhhbmRsZXIoZSkge1xuICAgIHIuZ2VzdHVyZVN0YXJ0Wm9vbSA9IHIuY3kuem9vbSgpO1xuICAgIGlmICghci5oYXNUb3VjaFN0YXJ0ZWQpIHtcbiAgICAgIC8vIGRvbid0IGFmZmVjdCB0b3VjaCBkZXZpY2VzIGxpa2UgaXBob25lXG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICB9LCB0cnVlKTtcbiAgci5yZWdpc3RlckJpbmRpbmcoci5jb250YWluZXIsICdnZXN0dXJlY2hhbmdlJywgZnVuY3Rpb24gKGUpIHtcbiAgICBpZiAoIXIuaGFzVG91Y2hTdGFydGVkKSB7XG4gICAgICAvLyBkb24ndCBhZmZlY3QgdG91Y2ggZGV2aWNlcyBsaWtlIGlwaG9uZVxuICAgICAgd2hlZWxIYW5kbGVyKGUpO1xuICAgIH1cbiAgfSwgdHJ1ZSk7XG5cbiAgLy8gRnVuY3Rpb25zIHRvIGhlbHAgd2l0aCBoYW5kbGluZyBtb3VzZW91dC9tb3VzZW92ZXIgb24gdGhlIEN5dG9zY2FwZSBjb250YWluZXJcbiAgLy8gSGFuZGxlIG1vdXNlb3V0IG9uIEN5dG9zY2FwZSBjb250YWluZXJcbiAgci5yZWdpc3RlckJpbmRpbmcoci5jb250YWluZXIsICdtb3VzZW91dCcsIGZ1bmN0aW9uIG1vdXNlT3V0SGFuZGxlcihlKSB7XG4gICAgdmFyIHBvcyA9IHIucHJvamVjdEludG9WaWV3cG9ydChlLmNsaWVudFgsIGUuY2xpZW50WSk7XG4gICAgci5jeS5lbWl0KHtcbiAgICAgIG9yaWdpbmFsRXZlbnQ6IGUsXG4gICAgICB0eXBlOiAnbW91c2VvdXQnLFxuICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgeDogcG9zWzBdLFxuICAgICAgICB5OiBwb3NbMV1cbiAgICAgIH1cbiAgICB9KTtcbiAgfSwgZmFsc2UpO1xuICByLnJlZ2lzdGVyQmluZGluZyhyLmNvbnRhaW5lciwgJ21vdXNlb3ZlcicsIGZ1bmN0aW9uIG1vdXNlT3ZlckhhbmRsZXIoZSkge1xuICAgIHZhciBwb3MgPSByLnByb2plY3RJbnRvVmlld3BvcnQoZS5jbGllbnRYLCBlLmNsaWVudFkpO1xuICAgIHIuY3kuZW1pdCh7XG4gICAgICBvcmlnaW5hbEV2ZW50OiBlLFxuICAgICAgdHlwZTogJ21vdXNlb3ZlcicsXG4gICAgICBwb3NpdGlvbjoge1xuICAgICAgICB4OiBwb3NbMF0sXG4gICAgICAgIHk6IHBvc1sxXVxuICAgICAgfVxuICAgIH0pO1xuICB9LCBmYWxzZSk7XG4gIHZhciBmMXgxLCBmMXkxLCBmMngxLCBmMnkxOyAvLyBzdGFydGluZyBwb2ludHMgZm9yIHBpbmNoLXRvLXpvb21cbiAgdmFyIGRpc3RhbmNlMSwgZGlzdGFuY2UxU3E7IC8vIGluaXRpYWwgZGlzdGFuY2UgYmV0d2VlbiBmaW5nZXIgMSBhbmQgZmluZ2VyIDIgZm9yIHBpbmNoLXRvLXpvb21cbiAgdmFyIGNlbnRlcjEsIG1vZGVsQ2VudGVyMTsgLy8gY2VudGVyIHBvaW50IG9uIHN0YXJ0IHBpbmNoIHRvIHpvb21cbiAgdmFyIG9mZnNldExlZnQsIG9mZnNldFRvcDtcbiAgdmFyIGNvbnRhaW5lcldpZHRoLCBjb250YWluZXJIZWlnaHQ7XG4gIHZhciB0d29GaW5nZXJzU3RhcnRJbnNpZGU7XG4gIHZhciBkaXN0YW5jZSA9IGZ1bmN0aW9uIGRpc3RhbmNlKHgxLCB5MSwgeDIsIHkyKSB7XG4gICAgcmV0dXJuIE1hdGguc3FydCgoeDIgLSB4MSkgKiAoeDIgLSB4MSkgKyAoeTIgLSB5MSkgKiAoeTIgLSB5MSkpO1xuICB9O1xuICB2YXIgZGlzdGFuY2VTcSA9IGZ1bmN0aW9uIGRpc3RhbmNlU3EoeDEsIHkxLCB4MiwgeTIpIHtcbiAgICByZXR1cm4gKHgyIC0geDEpICogKHgyIC0geDEpICsgKHkyIC0geTEpICogKHkyIC0geTEpO1xuICB9O1xuICB2YXIgdG91Y2hzdGFydEhhbmRsZXI7XG4gIHIucmVnaXN0ZXJCaW5kaW5nKHIuY29udGFpbmVyLCAndG91Y2hzdGFydCcsIHRvdWNoc3RhcnRIYW5kbGVyID0gZnVuY3Rpb24gdG91Y2hzdGFydEhhbmRsZXIoZSkge1xuICAgIHIuaGFzVG91Y2hTdGFydGVkID0gdHJ1ZTtcbiAgICBpZiAoIWV2ZW50SW5Db250YWluZXIoZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgYmx1ckFjdGl2ZURvbUVsZW1lbnQoKTtcbiAgICByLnRvdWNoRGF0YS5jYXB0dXJlID0gdHJ1ZTtcbiAgICByLmRhdGEuYmdBY3RpdmVQb3Npc3Rpb24gPSB1bmRlZmluZWQ7XG4gICAgdmFyIGN5ID0gci5jeTtcbiAgICB2YXIgbm93ID0gci50b3VjaERhdGEubm93O1xuICAgIHZhciBlYXJsaWVyID0gci50b3VjaERhdGEuZWFybGllcjtcbiAgICBpZiAoZS50b3VjaGVzWzBdKSB7XG4gICAgICB2YXIgcG9zID0gci5wcm9qZWN0SW50b1ZpZXdwb3J0KGUudG91Y2hlc1swXS5jbGllbnRYLCBlLnRvdWNoZXNbMF0uY2xpZW50WSk7XG4gICAgICBub3dbMF0gPSBwb3NbMF07XG4gICAgICBub3dbMV0gPSBwb3NbMV07XG4gICAgfVxuICAgIGlmIChlLnRvdWNoZXNbMV0pIHtcbiAgICAgIHZhciBwb3MgPSByLnByb2plY3RJbnRvVmlld3BvcnQoZS50b3VjaGVzWzFdLmNsaWVudFgsIGUudG91Y2hlc1sxXS5jbGllbnRZKTtcbiAgICAgIG5vd1syXSA9IHBvc1swXTtcbiAgICAgIG5vd1szXSA9IHBvc1sxXTtcbiAgICB9XG4gICAgaWYgKGUudG91Y2hlc1syXSkge1xuICAgICAgdmFyIHBvcyA9IHIucHJvamVjdEludG9WaWV3cG9ydChlLnRvdWNoZXNbMl0uY2xpZW50WCwgZS50b3VjaGVzWzJdLmNsaWVudFkpO1xuICAgICAgbm93WzRdID0gcG9zWzBdO1xuICAgICAgbm93WzVdID0gcG9zWzFdO1xuICAgIH1cblxuICAgIC8vIHJlY29yZCBzdGFydGluZyBwb2ludHMgZm9yIHBpbmNoLXRvLXpvb21cbiAgICBpZiAoZS50b3VjaGVzWzFdKSB7XG4gICAgICByLnRvdWNoRGF0YS5zaW5nbGVUb3VjaE1vdmVkID0gdHJ1ZTtcbiAgICAgIGZyZWVEcmFnZ2VkRWxlbWVudHMoci5kcmFnRGF0YS50b3VjaERyYWdFbGVzKTtcbiAgICAgIHZhciBvZmZzZXRzID0gci5maW5kQ29udGFpbmVyQ2xpZW50Q29vcmRzKCk7XG4gICAgICBvZmZzZXRMZWZ0ID0gb2Zmc2V0c1swXTtcbiAgICAgIG9mZnNldFRvcCA9IG9mZnNldHNbMV07XG4gICAgICBjb250YWluZXJXaWR0aCA9IG9mZnNldHNbMl07XG4gICAgICBjb250YWluZXJIZWlnaHQgPSBvZmZzZXRzWzNdO1xuICAgICAgZjF4MSA9IGUudG91Y2hlc1swXS5jbGllbnRYIC0gb2Zmc2V0TGVmdDtcbiAgICAgIGYxeTEgPSBlLnRvdWNoZXNbMF0uY2xpZW50WSAtIG9mZnNldFRvcDtcbiAgICAgIGYyeDEgPSBlLnRvdWNoZXNbMV0uY2xpZW50WCAtIG9mZnNldExlZnQ7XG4gICAgICBmMnkxID0gZS50b3VjaGVzWzFdLmNsaWVudFkgLSBvZmZzZXRUb3A7XG4gICAgICB0d29GaW5nZXJzU3RhcnRJbnNpZGUgPSAwIDw9IGYxeDEgJiYgZjF4MSA8PSBjb250YWluZXJXaWR0aCAmJiAwIDw9IGYyeDEgJiYgZjJ4MSA8PSBjb250YWluZXJXaWR0aCAmJiAwIDw9IGYxeTEgJiYgZjF5MSA8PSBjb250YWluZXJIZWlnaHQgJiYgMCA8PSBmMnkxICYmIGYyeTEgPD0gY29udGFpbmVySGVpZ2h0O1xuICAgICAgdmFyIHBhbiA9IGN5LnBhbigpO1xuICAgICAgdmFyIHpvb20gPSBjeS56b29tKCk7XG4gICAgICBkaXN0YW5jZTEgPSBkaXN0YW5jZShmMXgxLCBmMXkxLCBmMngxLCBmMnkxKTtcbiAgICAgIGRpc3RhbmNlMVNxID0gZGlzdGFuY2VTcShmMXgxLCBmMXkxLCBmMngxLCBmMnkxKTtcbiAgICAgIGNlbnRlcjEgPSBbKGYxeDEgKyBmMngxKSAvIDIsIChmMXkxICsgZjJ5MSkgLyAyXTtcbiAgICAgIG1vZGVsQ2VudGVyMSA9IFsoY2VudGVyMVswXSAtIHBhbi54KSAvIHpvb20sIChjZW50ZXIxWzFdIC0gcGFuLnkpIC8gem9vbV07XG5cbiAgICAgIC8vIGNvbnNpZGVyIGNvbnRleHQgdGFwXG4gICAgICB2YXIgY3h0RGlzdFRocmVzaG9sZCA9IDIwMDtcbiAgICAgIHZhciBjeHREaXN0VGhyZXNob2xkU3EgPSBjeHREaXN0VGhyZXNob2xkICogY3h0RGlzdFRocmVzaG9sZDtcbiAgICAgIGlmIChkaXN0YW5jZTFTcSA8IGN4dERpc3RUaHJlc2hvbGRTcSAmJiAhZS50b3VjaGVzWzJdKSB7XG4gICAgICAgIHZhciBuZWFyMSA9IHIuZmluZE5lYXJlc3RFbGVtZW50KG5vd1swXSwgbm93WzFdLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgdmFyIG5lYXIyID0gci5maW5kTmVhcmVzdEVsZW1lbnQobm93WzJdLCBub3dbM10sIHRydWUsIHRydWUpO1xuICAgICAgICBpZiAobmVhcjEgJiYgbmVhcjEuaXNOb2RlKCkpIHtcbiAgICAgICAgICBuZWFyMS5hY3RpdmF0ZSgpLmVtaXQoe1xuICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogZSxcbiAgICAgICAgICAgIHR5cGU6ICdjeHR0YXBzdGFydCcsXG4gICAgICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgICAgICB4OiBub3dbMF0sXG4gICAgICAgICAgICAgIHk6IG5vd1sxXVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHIudG91Y2hEYXRhLnN0YXJ0ID0gbmVhcjE7XG4gICAgICAgIH0gZWxzZSBpZiAobmVhcjIgJiYgbmVhcjIuaXNOb2RlKCkpIHtcbiAgICAgICAgICBuZWFyMi5hY3RpdmF0ZSgpLmVtaXQoe1xuICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogZSxcbiAgICAgICAgICAgIHR5cGU6ICdjeHR0YXBzdGFydCcsXG4gICAgICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgICAgICB4OiBub3dbMF0sXG4gICAgICAgICAgICAgIHk6IG5vd1sxXVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHIudG91Y2hEYXRhLnN0YXJ0ID0gbmVhcjI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3kuZW1pdCh7XG4gICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBlLFxuICAgICAgICAgICAgdHlwZTogJ2N4dHRhcHN0YXJ0JyxcbiAgICAgICAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgICAgICAgIHg6IG5vd1swXSxcbiAgICAgICAgICAgICAgeTogbm93WzFdXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHIudG91Y2hEYXRhLnN0YXJ0KSB7XG4gICAgICAgICAgci50b3VjaERhdGEuc3RhcnQuX3ByaXZhdGUuZ3JhYmJlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHIudG91Y2hEYXRhLmN4dCA9IHRydWU7XG4gICAgICAgIHIudG91Y2hEYXRhLmN4dERyYWdnZWQgPSBmYWxzZTtcbiAgICAgICAgci5kYXRhLmJnQWN0aXZlUG9zaXN0aW9uID0gdW5kZWZpbmVkO1xuICAgICAgICByLnJlZHJhdygpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChlLnRvdWNoZXNbMl0pIHtcbiAgICAgIC8vIGlnbm9yZVxuXG4gICAgICAvLyBzYWZhcmkgb24gaW9zIHBhbnMgdGhlIHBhZ2Ugb3RoZXJ3aXNlIChub3JtYWxseSB5b3Ugc2hvdWxkIGJlIGFibGUgdG8gcHJldmVudGRlZmF1bHQgb24gdG91Y2htb3ZlLi4uKVxuICAgICAgaWYgKGN5LmJveFNlbGVjdGlvbkVuYWJsZWQoKSkge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChlLnRvdWNoZXNbMV0pIDsgZWxzZSBpZiAoZS50b3VjaGVzWzBdKSB7XG4gICAgICB2YXIgbmVhcnMgPSByLmZpbmROZWFyZXN0RWxlbWVudHMobm93WzBdLCBub3dbMV0sIHRydWUsIHRydWUpO1xuICAgICAgdmFyIG5lYXIgPSBuZWFyc1swXTtcbiAgICAgIGlmIChuZWFyICE9IG51bGwpIHtcbiAgICAgICAgbmVhci5hY3RpdmF0ZSgpO1xuICAgICAgICByLnRvdWNoRGF0YS5zdGFydCA9IG5lYXI7XG4gICAgICAgIHIudG91Y2hEYXRhLnN0YXJ0cyA9IG5lYXJzO1xuICAgICAgICBpZiAoci5ub2RlSXNHcmFiYmFibGUobmVhcikpIHtcbiAgICAgICAgICB2YXIgZHJhZ2dlZEVsZXMgPSByLmRyYWdEYXRhLnRvdWNoRHJhZ0VsZXMgPSBjeS5jb2xsZWN0aW9uKCk7XG4gICAgICAgICAgdmFyIHNlbGVjdGVkTm9kZXMgPSBudWxsO1xuICAgICAgICAgIHIucmVkcmF3SGludCgnZWxlcycsIHRydWUpO1xuICAgICAgICAgIHIucmVkcmF3SGludCgnZHJhZycsIHRydWUpO1xuICAgICAgICAgIGlmIChuZWFyLnNlbGVjdGVkKCkpIHtcbiAgICAgICAgICAgIC8vIHJlc2V0IGRyYWcgZWxlbWVudHMsIHNpbmNlIG5lYXIgd2lsbCBiZSBhZGRlZCBhZ2FpblxuXG4gICAgICAgICAgICBzZWxlY3RlZE5vZGVzID0gY3kuJChmdW5jdGlvbiAoZWxlKSB7XG4gICAgICAgICAgICAgIHJldHVybiBlbGUuc2VsZWN0ZWQoKSAmJiByLm5vZGVJc0dyYWJiYWJsZShlbGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhZGROb2Rlc1RvRHJhZyhzZWxlY3RlZE5vZGVzLCB7XG4gICAgICAgICAgICAgIGFkZFRvTGlzdDogZHJhZ2dlZEVsZXNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhZGROb2RlVG9EcmFnKG5lYXIsIHtcbiAgICAgICAgICAgICAgYWRkVG9MaXN0OiBkcmFnZ2VkRWxlc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNldEdyYWJUYXJnZXQobmVhcik7XG4gICAgICAgICAgdmFyIG1ha2VFdmVudCA9IGZ1bmN0aW9uIG1ha2VFdmVudCh0eXBlKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBlLFxuICAgICAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgICAgICAgIHg6IG5vd1swXSxcbiAgICAgICAgICAgICAgICB5OiBub3dbMV1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIG5lYXIuZW1pdChtYWtlRXZlbnQoJ2dyYWJvbicpKTtcbiAgICAgICAgICBpZiAoc2VsZWN0ZWROb2Rlcykge1xuICAgICAgICAgICAgc2VsZWN0ZWROb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChuKSB7XG4gICAgICAgICAgICAgIG4uZW1pdChtYWtlRXZlbnQoJ2dyYWInKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmVhci5lbWl0KG1ha2VFdmVudCgnZ3JhYicpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRyaWdnZXJFdmVudHMobmVhciwgWyd0b3VjaHN0YXJ0JywgJ3RhcHN0YXJ0JywgJ3Ztb3VzZWRvd24nXSwgZSwge1xuICAgICAgICB4OiBub3dbMF0sXG4gICAgICAgIHk6IG5vd1sxXVxuICAgICAgfSk7XG4gICAgICBpZiAobmVhciA9PSBudWxsKSB7XG4gICAgICAgIHIuZGF0YS5iZ0FjdGl2ZVBvc2lzdGlvbiA9IHtcbiAgICAgICAgICB4OiBwb3NbMF0sXG4gICAgICAgICAgeTogcG9zWzFdXG4gICAgICAgIH07XG4gICAgICAgIHIucmVkcmF3SGludCgnc2VsZWN0JywgdHJ1ZSk7XG4gICAgICAgIHIucmVkcmF3KCk7XG4gICAgICB9XG5cbiAgICAgIC8vIFRhcCwgdGFwaG9sZFxuICAgICAgLy8gLS0tLS1cblxuICAgICAgci50b3VjaERhdGEuc2luZ2xlVG91Y2hNb3ZlZCA9IGZhbHNlO1xuICAgICAgci50b3VjaERhdGEuc2luZ2xlVG91Y2hTdGFydFRpbWUgPSArbmV3IERhdGUoKTtcbiAgICAgIGNsZWFyVGltZW91dChyLnRvdWNoRGF0YS50YXBob2xkVGltZW91dCk7XG4gICAgICByLnRvdWNoRGF0YS50YXBob2xkVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoci50b3VjaERhdGEuc2luZ2xlVG91Y2hNb3ZlZCA9PT0gZmFsc2UgJiYgIXIucGluY2hpbmcgLy8gaWYgcGluY2hpbmcsIHRoZW4gdGFwaG9sZCB1bnNlbGVjdCBzaG91bGRuJ3QgdGFrZSBlZmZlY3RcbiAgICAgICAgJiYgIXIudG91Y2hEYXRhLnNlbGVjdGluZyAvLyBib3ggc2VsZWN0aW9uIHNob3VsZG4ndCBhbGxvdyB0YXBob2xkIHRocm91Z2hcbiAgICAgICAgKSB7XG4gICAgICAgICAgdHJpZ2dlckV2ZW50cyhyLnRvdWNoRGF0YS5zdGFydCwgWyd0YXBob2xkJ10sIGUsIHtcbiAgICAgICAgICAgIHg6IG5vd1swXSxcbiAgICAgICAgICAgIHk6IG5vd1sxXVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9LCByLnRhcGhvbGREdXJhdGlvbik7XG4gICAgfVxuICAgIGlmIChlLnRvdWNoZXMubGVuZ3RoID49IDEpIHtcbiAgICAgIHZhciBzUG9zID0gci50b3VjaERhdGEuc3RhcnRQb3NpdGlvbiA9IFtudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm93Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHNQb3NbaV0gPSBlYXJsaWVyW2ldID0gbm93W2ldO1xuICAgICAgfVxuICAgICAgdmFyIHRvdWNoMCA9IGUudG91Y2hlc1swXTtcbiAgICAgIHIudG91Y2hEYXRhLnN0YXJ0R1Bvc2l0aW9uID0gW3RvdWNoMC5jbGllbnRYLCB0b3VjaDAuY2xpZW50WV07XG4gICAgfVxuICB9LCBmYWxzZSk7XG4gIHZhciB0b3VjaG1vdmVIYW5kbGVyO1xuICByLnJlZ2lzdGVyQmluZGluZyhjb250YWluZXJXaW5kb3csICd0b3VjaG1vdmUnLCB0b3VjaG1vdmVIYW5kbGVyID0gZnVuY3Rpb24gdG91Y2htb3ZlSGFuZGxlcihlKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuICAgIHZhciBjYXB0dXJlID0gci50b3VjaERhdGEuY2FwdHVyZTtcbiAgICBpZiAoIWNhcHR1cmUgJiYgIWV2ZW50SW5Db250YWluZXIoZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHNlbGVjdCA9IHIuc2VsZWN0aW9uO1xuICAgIHZhciBjeSA9IHIuY3k7XG4gICAgdmFyIG5vdyA9IHIudG91Y2hEYXRhLm5vdztcbiAgICB2YXIgZWFybGllciA9IHIudG91Y2hEYXRhLmVhcmxpZXI7XG4gICAgdmFyIHpvb20gPSBjeS56b29tKCk7XG4gICAgaWYgKGUudG91Y2hlc1swXSkge1xuICAgICAgdmFyIHBvcyA9IHIucHJvamVjdEludG9WaWV3cG9ydChlLnRvdWNoZXNbMF0uY2xpZW50WCwgZS50b3VjaGVzWzBdLmNsaWVudFkpO1xuICAgICAgbm93WzBdID0gcG9zWzBdO1xuICAgICAgbm93WzFdID0gcG9zWzFdO1xuICAgIH1cbiAgICBpZiAoZS50b3VjaGVzWzFdKSB7XG4gICAgICB2YXIgcG9zID0gci5wcm9qZWN0SW50b1ZpZXdwb3J0KGUudG91Y2hlc1sxXS5jbGllbnRYLCBlLnRvdWNoZXNbMV0uY2xpZW50WSk7XG4gICAgICBub3dbMl0gPSBwb3NbMF07XG4gICAgICBub3dbM10gPSBwb3NbMV07XG4gICAgfVxuICAgIGlmIChlLnRvdWNoZXNbMl0pIHtcbiAgICAgIHZhciBwb3MgPSByLnByb2plY3RJbnRvVmlld3BvcnQoZS50b3VjaGVzWzJdLmNsaWVudFgsIGUudG91Y2hlc1syXS5jbGllbnRZKTtcbiAgICAgIG5vd1s0XSA9IHBvc1swXTtcbiAgICAgIG5vd1s1XSA9IHBvc1sxXTtcbiAgICB9XG4gICAgdmFyIHN0YXJ0R1BvcyA9IHIudG91Y2hEYXRhLnN0YXJ0R1Bvc2l0aW9uO1xuICAgIHZhciBpc092ZXJUaHJlc2hvbGREcmFnO1xuICAgIGlmIChjYXB0dXJlICYmIGUudG91Y2hlc1swXSAmJiBzdGFydEdQb3MpIHtcbiAgICAgIHZhciBkaXNwID0gW107XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG5vdy5sZW5ndGg7IGorKykge1xuICAgICAgICBkaXNwW2pdID0gbm93W2pdIC0gZWFybGllcltqXTtcbiAgICAgIH1cbiAgICAgIHZhciBkeCA9IGUudG91Y2hlc1swXS5jbGllbnRYIC0gc3RhcnRHUG9zWzBdO1xuICAgICAgdmFyIGR4MiA9IGR4ICogZHg7XG4gICAgICB2YXIgZHkgPSBlLnRvdWNoZXNbMF0uY2xpZW50WSAtIHN0YXJ0R1Bvc1sxXTtcbiAgICAgIHZhciBkeTIgPSBkeSAqIGR5O1xuICAgICAgdmFyIGRpc3QyID0gZHgyICsgZHkyO1xuICAgICAgaXNPdmVyVGhyZXNob2xkRHJhZyA9IGRpc3QyID49IHIudG91Y2hUYXBUaHJlc2hvbGQyO1xuICAgIH1cblxuICAgIC8vIGNvbnRleHQgc3dpcGUgY2FuY2VsbGluZ1xuICAgIGlmIChjYXB0dXJlICYmIHIudG91Y2hEYXRhLmN4dCkge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgdmFyIGYxeDIgPSBlLnRvdWNoZXNbMF0uY2xpZW50WCAtIG9mZnNldExlZnQsXG4gICAgICAgIGYxeTIgPSBlLnRvdWNoZXNbMF0uY2xpZW50WSAtIG9mZnNldFRvcDtcbiAgICAgIHZhciBmMngyID0gZS50b3VjaGVzWzFdLmNsaWVudFggLSBvZmZzZXRMZWZ0LFxuICAgICAgICBmMnkyID0gZS50b3VjaGVzWzFdLmNsaWVudFkgLSBvZmZzZXRUb3A7XG4gICAgICAvLyB2YXIgZGlzdGFuY2UyID0gZGlzdGFuY2UoIGYxeDIsIGYxeTIsIGYyeDIsIGYyeTIgKTtcbiAgICAgIHZhciBkaXN0YW5jZTJTcSA9IGRpc3RhbmNlU3EoZjF4MiwgZjF5MiwgZjJ4MiwgZjJ5Mik7XG4gICAgICB2YXIgZmFjdG9yU3EgPSBkaXN0YW5jZTJTcSAvIGRpc3RhbmNlMVNxO1xuICAgICAgdmFyIGRpc3RUaHJlc2hvbGQgPSAxNTA7XG4gICAgICB2YXIgZGlzdFRocmVzaG9sZFNxID0gZGlzdFRocmVzaG9sZCAqIGRpc3RUaHJlc2hvbGQ7XG4gICAgICB2YXIgZmFjdG9yVGhyZXNob2xkID0gMS41O1xuICAgICAgdmFyIGZhY3RvclRocmVzaG9sZFNxID0gZmFjdG9yVGhyZXNob2xkICogZmFjdG9yVGhyZXNob2xkO1xuXG4gICAgICAvLyBjYW5jZWwgY3R4IGdlc3R1cmVzIGlmIHRoZSBkaXN0YW5jZSBiL3QgdGhlIGZpbmdlcnMgaW5jcmVhc2VzXG4gICAgICBpZiAoZmFjdG9yU3EgPj0gZmFjdG9yVGhyZXNob2xkU3EgfHwgZGlzdGFuY2UyU3EgPj0gZGlzdFRocmVzaG9sZFNxKSB7XG4gICAgICAgIHIudG91Y2hEYXRhLmN4dCA9IGZhbHNlO1xuICAgICAgICByLmRhdGEuYmdBY3RpdmVQb3Npc3Rpb24gPSB1bmRlZmluZWQ7XG4gICAgICAgIHIucmVkcmF3SGludCgnc2VsZWN0JywgdHJ1ZSk7XG4gICAgICAgIHZhciBjeHRFdnQgPSB7XG4gICAgICAgICAgb3JpZ2luYWxFdmVudDogZSxcbiAgICAgICAgICB0eXBlOiAnY3h0dGFwZW5kJyxcbiAgICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgICAgeDogbm93WzBdLFxuICAgICAgICAgICAgeTogbm93WzFdXG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBpZiAoci50b3VjaERhdGEuc3RhcnQpIHtcbiAgICAgICAgICByLnRvdWNoRGF0YS5zdGFydC51bmFjdGl2YXRlKCkuZW1pdChjeHRFdnQpO1xuICAgICAgICAgIHIudG91Y2hEYXRhLnN0YXJ0ID0gbnVsbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjeS5lbWl0KGN4dEV2dCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBjb250ZXh0IHN3aXBlXG4gICAgaWYgKGNhcHR1cmUgJiYgci50b3VjaERhdGEuY3h0KSB7XG4gICAgICB2YXIgY3h0RXZ0ID0ge1xuICAgICAgICBvcmlnaW5hbEV2ZW50OiBlLFxuICAgICAgICB0eXBlOiAnY3h0ZHJhZycsXG4gICAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgICAgeDogbm93WzBdLFxuICAgICAgICAgIHk6IG5vd1sxXVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgci5kYXRhLmJnQWN0aXZlUG9zaXN0aW9uID0gdW5kZWZpbmVkO1xuICAgICAgci5yZWRyYXdIaW50KCdzZWxlY3QnLCB0cnVlKTtcbiAgICAgIGlmIChyLnRvdWNoRGF0YS5zdGFydCkge1xuICAgICAgICByLnRvdWNoRGF0YS5zdGFydC5lbWl0KGN4dEV2dCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjeS5lbWl0KGN4dEV2dCk7XG4gICAgICB9XG4gICAgICBpZiAoci50b3VjaERhdGEuc3RhcnQpIHtcbiAgICAgICAgci50b3VjaERhdGEuc3RhcnQuX3ByaXZhdGUuZ3JhYmJlZCA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgci50b3VjaERhdGEuY3h0RHJhZ2dlZCA9IHRydWU7XG4gICAgICB2YXIgbmVhciA9IHIuZmluZE5lYXJlc3RFbGVtZW50KG5vd1swXSwgbm93WzFdLCB0cnVlLCB0cnVlKTtcbiAgICAgIGlmICghci50b3VjaERhdGEuY3h0T3ZlciB8fCBuZWFyICE9PSByLnRvdWNoRGF0YS5jeHRPdmVyKSB7XG4gICAgICAgIGlmIChyLnRvdWNoRGF0YS5jeHRPdmVyKSB7XG4gICAgICAgICAgci50b3VjaERhdGEuY3h0T3Zlci5lbWl0KHtcbiAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGUsXG4gICAgICAgICAgICB0eXBlOiAnY3h0ZHJhZ291dCcsXG4gICAgICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgICAgICB4OiBub3dbMF0sXG4gICAgICAgICAgICAgIHk6IG5vd1sxXVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHIudG91Y2hEYXRhLmN4dE92ZXIgPSBuZWFyO1xuICAgICAgICBpZiAobmVhcikge1xuICAgICAgICAgIG5lYXIuZW1pdCh7XG4gICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBlLFxuICAgICAgICAgICAgdHlwZTogJ2N4dGRyYWdvdmVyJyxcbiAgICAgICAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgICAgICAgIHg6IG5vd1swXSxcbiAgICAgICAgICAgICAgeTogbm93WzFdXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gYm94IHNlbGVjdGlvblxuICAgIH0gZWxzZSBpZiAoY2FwdHVyZSAmJiBlLnRvdWNoZXNbMl0gJiYgY3kuYm94U2VsZWN0aW9uRW5hYmxlZCgpKSB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICByLmRhdGEuYmdBY3RpdmVQb3Npc3Rpb24gPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLmxhc3RUaHJlZVRvdWNoID0gK25ldyBEYXRlKCk7XG4gICAgICBpZiAoIXIudG91Y2hEYXRhLnNlbGVjdGluZykge1xuICAgICAgICBjeS5lbWl0KHtcbiAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBlLFxuICAgICAgICAgIHR5cGU6ICdib3hzdGFydCcsXG4gICAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICAgIHg6IG5vd1swXSxcbiAgICAgICAgICAgIHk6IG5vd1sxXVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByLnRvdWNoRGF0YS5zZWxlY3RpbmcgPSB0cnVlO1xuICAgICAgci50b3VjaERhdGEuZGlkU2VsZWN0ID0gdHJ1ZTtcbiAgICAgIHNlbGVjdFs0XSA9IDE7XG4gICAgICBpZiAoIXNlbGVjdCB8fCBzZWxlY3QubGVuZ3RoID09PSAwIHx8IHNlbGVjdFswXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHNlbGVjdFswXSA9IChub3dbMF0gKyBub3dbMl0gKyBub3dbNF0pIC8gMztcbiAgICAgICAgc2VsZWN0WzFdID0gKG5vd1sxXSArIG5vd1szXSArIG5vd1s1XSkgLyAzO1xuICAgICAgICBzZWxlY3RbMl0gPSAobm93WzBdICsgbm93WzJdICsgbm93WzRdKSAvIDMgKyAxO1xuICAgICAgICBzZWxlY3RbM10gPSAobm93WzFdICsgbm93WzNdICsgbm93WzVdKSAvIDMgKyAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VsZWN0WzJdID0gKG5vd1swXSArIG5vd1syXSArIG5vd1s0XSkgLyAzO1xuICAgICAgICBzZWxlY3RbM10gPSAobm93WzFdICsgbm93WzNdICsgbm93WzVdKSAvIDM7XG4gICAgICB9XG4gICAgICByLnJlZHJhd0hpbnQoJ3NlbGVjdCcsIHRydWUpO1xuICAgICAgci5yZWRyYXcoKTtcblxuICAgICAgLy8gcGluY2ggdG8gem9vbVxuICAgIH0gZWxzZSBpZiAoY2FwdHVyZSAmJiBlLnRvdWNoZXNbMV0gJiYgIXIudG91Y2hEYXRhLmRpZFNlbGVjdCAvLyBkb24ndCBhbGxvdyBib3ggc2VsZWN0aW9uIHRvIGRlZ3JhZGUgdG8gcGluY2gtdG8tem9vbVxuICAgICYmIGN5Lnpvb21pbmdFbmFibGVkKCkgJiYgY3kucGFubmluZ0VuYWJsZWQoKSAmJiBjeS51c2VyWm9vbWluZ0VuYWJsZWQoKSAmJiBjeS51c2VyUGFubmluZ0VuYWJsZWQoKSkge1xuICAgICAgLy8gdHdvIGZpbmdlcnMgPT4gcGluY2ggdG8gem9vbVxuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgci5kYXRhLmJnQWN0aXZlUG9zaXN0aW9uID0gdW5kZWZpbmVkO1xuICAgICAgci5yZWRyYXdIaW50KCdzZWxlY3QnLCB0cnVlKTtcbiAgICAgIHZhciBkcmFnZ2VkRWxlcyA9IHIuZHJhZ0RhdGEudG91Y2hEcmFnRWxlcztcbiAgICAgIGlmIChkcmFnZ2VkRWxlcykge1xuICAgICAgICByLnJlZHJhd0hpbnQoJ2RyYWcnLCB0cnVlKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkcmFnZ2VkRWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBkZV9wID0gZHJhZ2dlZEVsZXNbaV0uX3ByaXZhdGU7XG4gICAgICAgICAgZGVfcC5ncmFiYmVkID0gZmFsc2U7XG4gICAgICAgICAgZGVfcC5yc2NyYXRjaC5pbkRyYWdMYXllciA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgX3N0YXJ0ID0gci50b3VjaERhdGEuc3RhcnQ7XG5cbiAgICAgIC8vICh4MiwgeTIpIGZvciBmaW5nZXJzIDEgYW5kIDJcbiAgICAgIHZhciBmMXgyID0gZS50b3VjaGVzWzBdLmNsaWVudFggLSBvZmZzZXRMZWZ0LFxuICAgICAgICBmMXkyID0gZS50b3VjaGVzWzBdLmNsaWVudFkgLSBvZmZzZXRUb3A7XG4gICAgICB2YXIgZjJ4MiA9IGUudG91Y2hlc1sxXS5jbGllbnRYIC0gb2Zmc2V0TGVmdCxcbiAgICAgICAgZjJ5MiA9IGUudG91Y2hlc1sxXS5jbGllbnRZIC0gb2Zmc2V0VG9wO1xuICAgICAgdmFyIGRpc3RhbmNlMiA9IGRpc3RhbmNlKGYxeDIsIGYxeTIsIGYyeDIsIGYyeTIpO1xuICAgICAgLy8gdmFyIGRpc3RhbmNlMlNxID0gZGlzdGFuY2VTcSggZjF4MiwgZjF5MiwgZjJ4MiwgZjJ5MiApO1xuICAgICAgLy8gdmFyIGZhY3RvciA9IE1hdGguc3FydCggZGlzdGFuY2UyU3EgKSAvIE1hdGguc3FydCggZGlzdGFuY2UxU3EgKTtcbiAgICAgIHZhciBmYWN0b3IgPSBkaXN0YW5jZTIgLyBkaXN0YW5jZTE7XG4gICAgICBpZiAodHdvRmluZ2Vyc1N0YXJ0SW5zaWRlKSB7XG4gICAgICAgIC8vIGRlbHRhIGZpbmdlcjFcbiAgICAgICAgdmFyIGRmMXggPSBmMXgyIC0gZjF4MTtcbiAgICAgICAgdmFyIGRmMXkgPSBmMXkyIC0gZjF5MTtcblxuICAgICAgICAvLyBkZWx0YSBmaW5nZXIgMlxuICAgICAgICB2YXIgZGYyeCA9IGYyeDIgLSBmMngxO1xuICAgICAgICB2YXIgZGYyeSA9IGYyeTIgLSBmMnkxO1xuXG4gICAgICAgIC8vIHRyYW5zbGF0aW9uIGlzIHRoZSBub3JtYWxpc2VkIHZlY3RvciBvZiB0aGUgdHdvIGZpbmdlcnMgbW92ZW1lbnRcbiAgICAgICAgLy8gaS5lLiBzbyBwaW5jaGluZyBjYW5jZWxzIG91dCBhbmQgbW92aW5nIHRvZ2V0aGVyIHBhbnNcbiAgICAgICAgdmFyIHR4ID0gKGRmMXggKyBkZjJ4KSAvIDI7XG4gICAgICAgIHZhciB0eSA9IChkZjF5ICsgZGYyeSkgLyAyO1xuXG4gICAgICAgIC8vIG5vdyBjYWxjdWxhdGUgdGhlIHpvb21cbiAgICAgICAgdmFyIHpvb20xID0gY3kuem9vbSgpO1xuICAgICAgICB2YXIgem9vbTIgPSB6b29tMSAqIGZhY3RvcjtcbiAgICAgICAgdmFyIHBhbjEgPSBjeS5wYW4oKTtcblxuICAgICAgICAvLyB0aGUgbW9kZWwgY2VudGVyIHBvaW50IGNvbnZlcnRlZCB0byB0aGUgY3VycmVudCByZW5kZXJlZCBwb3NcbiAgICAgICAgdmFyIGN0cnggPSBtb2RlbENlbnRlcjFbMF0gKiB6b29tMSArIHBhbjEueDtcbiAgICAgICAgdmFyIGN0cnkgPSBtb2RlbENlbnRlcjFbMV0gKiB6b29tMSArIHBhbjEueTtcbiAgICAgICAgdmFyIHBhbjIgPSB7XG4gICAgICAgICAgeDogLXpvb20yIC8gem9vbTEgKiAoY3RyeCAtIHBhbjEueCAtIHR4KSArIGN0cngsXG4gICAgICAgICAgeTogLXpvb20yIC8gem9vbTEgKiAoY3RyeSAtIHBhbjEueSAtIHR5KSArIGN0cnlcbiAgICAgICAgfTtcblxuICAgICAgICAvLyByZW1vdmUgZHJhZ2dlZCBlbGVzXG4gICAgICAgIGlmIChfc3RhcnQgJiYgX3N0YXJ0LmFjdGl2ZSgpKSB7XG4gICAgICAgICAgdmFyIGRyYWdnZWRFbGVzID0gci5kcmFnRGF0YS50b3VjaERyYWdFbGVzO1xuICAgICAgICAgIGZyZWVEcmFnZ2VkRWxlbWVudHMoZHJhZ2dlZEVsZXMpO1xuICAgICAgICAgIHIucmVkcmF3SGludCgnZHJhZycsIHRydWUpO1xuICAgICAgICAgIHIucmVkcmF3SGludCgnZWxlcycsIHRydWUpO1xuICAgICAgICAgIF9zdGFydC51bmFjdGl2YXRlKCkuZW1pdCgnZnJlZW9uJyk7XG4gICAgICAgICAgZHJhZ2dlZEVsZXMuZW1pdCgnZnJlZScpO1xuICAgICAgICAgIGlmIChyLmRyYWdEYXRhLmRpZERyYWcpIHtcbiAgICAgICAgICAgIF9zdGFydC5lbWl0KCdkcmFnZnJlZW9uJyk7XG4gICAgICAgICAgICBkcmFnZ2VkRWxlcy5lbWl0KCdkcmFnZnJlZScpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjeS52aWV3cG9ydCh7XG4gICAgICAgICAgem9vbTogem9vbTIsXG4gICAgICAgICAgcGFuOiBwYW4yLFxuICAgICAgICAgIGNhbmNlbE9uRmFpbGVkWm9vbTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgY3kuZW1pdCgncGluY2h6b29tJyk7XG4gICAgICAgIGRpc3RhbmNlMSA9IGRpc3RhbmNlMjtcbiAgICAgICAgZjF4MSA9IGYxeDI7XG4gICAgICAgIGYxeTEgPSBmMXkyO1xuICAgICAgICBmMngxID0gZjJ4MjtcbiAgICAgICAgZjJ5MSA9IGYyeTI7XG4gICAgICAgIHIucGluY2hpbmcgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBSZS1wcm9qZWN0XG4gICAgICBpZiAoZS50b3VjaGVzWzBdKSB7XG4gICAgICAgIHZhciBwb3MgPSByLnByb2plY3RJbnRvVmlld3BvcnQoZS50b3VjaGVzWzBdLmNsaWVudFgsIGUudG91Y2hlc1swXS5jbGllbnRZKTtcbiAgICAgICAgbm93WzBdID0gcG9zWzBdO1xuICAgICAgICBub3dbMV0gPSBwb3NbMV07XG4gICAgICB9XG4gICAgICBpZiAoZS50b3VjaGVzWzFdKSB7XG4gICAgICAgIHZhciBwb3MgPSByLnByb2plY3RJbnRvVmlld3BvcnQoZS50b3VjaGVzWzFdLmNsaWVudFgsIGUudG91Y2hlc1sxXS5jbGllbnRZKTtcbiAgICAgICAgbm93WzJdID0gcG9zWzBdO1xuICAgICAgICBub3dbM10gPSBwb3NbMV07XG4gICAgICB9XG4gICAgICBpZiAoZS50b3VjaGVzWzJdKSB7XG4gICAgICAgIHZhciBwb3MgPSByLnByb2plY3RJbnRvVmlld3BvcnQoZS50b3VjaGVzWzJdLmNsaWVudFgsIGUudG91Y2hlc1syXS5jbGllbnRZKTtcbiAgICAgICAgbm93WzRdID0gcG9zWzBdO1xuICAgICAgICBub3dbNV0gPSBwb3NbMV07XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChlLnRvdWNoZXNbMF0gJiYgIXIudG91Y2hEYXRhLmRpZFNlbGVjdCAvLyBkb24ndCBhbGxvdyBib3ggc2VsZWN0aW9uIHRvIGRlZ3JhZGUgdG8gc2luZ2xlIGZpbmdlciBldmVudHMgbGlrZSBwYW5uaW5nXG4gICAgKSB7XG4gICAgICB2YXIgc3RhcnQgPSByLnRvdWNoRGF0YS5zdGFydDtcbiAgICAgIHZhciBsYXN0ID0gci50b3VjaERhdGEubGFzdDtcbiAgICAgIHZhciBuZWFyO1xuICAgICAgaWYgKCFyLmhvdmVyRGF0YS5kcmFnZ2luZ0VsZXMgJiYgIXIuc3dpcGVQYW5uaW5nKSB7XG4gICAgICAgIG5lYXIgPSByLmZpbmROZWFyZXN0RWxlbWVudChub3dbMF0sIG5vd1sxXSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICB9XG4gICAgICBpZiAoY2FwdHVyZSAmJiBzdGFydCAhPSBudWxsKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH1cblxuICAgICAgLy8gZHJhZ2dpbmcgbm9kZXNcbiAgICAgIGlmIChjYXB0dXJlICYmIHN0YXJ0ICE9IG51bGwgJiYgci5ub2RlSXNEcmFnZ2FibGUoc3RhcnQpKSB7XG4gICAgICAgIGlmIChpc092ZXJUaHJlc2hvbGREcmFnKSB7XG4gICAgICAgICAgLy8gdGhlbiBkcmFnZ2luZyBjYW4gaGFwcGVuXG4gICAgICAgICAgdmFyIGRyYWdnZWRFbGVzID0gci5kcmFnRGF0YS50b3VjaERyYWdFbGVzO1xuICAgICAgICAgIHZhciBqdXN0U3RhcnRlZERyYWcgPSAhci5kcmFnRGF0YS5kaWREcmFnO1xuICAgICAgICAgIGlmIChqdXN0U3RhcnRlZERyYWcpIHtcbiAgICAgICAgICAgIGFkZE5vZGVzVG9EcmFnKGRyYWdnZWRFbGVzLCB7XG4gICAgICAgICAgICAgIGluRHJhZ0xheWVyOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgci5kcmFnRGF0YS5kaWREcmFnID0gdHJ1ZTtcbiAgICAgICAgICB2YXIgdG90YWxTaGlmdCA9IHtcbiAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICB5OiAwXG4gICAgICAgICAgfTtcbiAgICAgICAgICBpZiAobnVtYmVyJDEoZGlzcFswXSkgJiYgbnVtYmVyJDEoZGlzcFsxXSkpIHtcbiAgICAgICAgICAgIHRvdGFsU2hpZnQueCArPSBkaXNwWzBdO1xuICAgICAgICAgICAgdG90YWxTaGlmdC55ICs9IGRpc3BbMV07XG4gICAgICAgICAgICBpZiAoanVzdFN0YXJ0ZWREcmFnKSB7XG4gICAgICAgICAgICAgIHIucmVkcmF3SGludCgnZWxlcycsIHRydWUpO1xuICAgICAgICAgICAgICB2YXIgZHJhZ0RlbHRhID0gci50b3VjaERhdGEuZHJhZ0RlbHRhO1xuICAgICAgICAgICAgICBpZiAoZHJhZ0RlbHRhICYmIG51bWJlciQxKGRyYWdEZWx0YVswXSkgJiYgbnVtYmVyJDEoZHJhZ0RlbHRhWzFdKSkge1xuICAgICAgICAgICAgICAgIHRvdGFsU2hpZnQueCArPSBkcmFnRGVsdGFbMF07XG4gICAgICAgICAgICAgICAgdG90YWxTaGlmdC55ICs9IGRyYWdEZWx0YVsxXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByLmhvdmVyRGF0YS5kcmFnZ2luZ0VsZXMgPSB0cnVlO1xuICAgICAgICAgIGRyYWdnZWRFbGVzLnNpbGVudFNoaWZ0KHRvdGFsU2hpZnQpLmVtaXQoJ3Bvc2l0aW9uIGRyYWcnKTtcbiAgICAgICAgICByLnJlZHJhd0hpbnQoJ2RyYWcnLCB0cnVlKTtcbiAgICAgICAgICBpZiAoci50b3VjaERhdGEuc3RhcnRQb3NpdGlvblswXSA9PSBlYXJsaWVyWzBdICYmIHIudG91Y2hEYXRhLnN0YXJ0UG9zaXRpb25bMV0gPT0gZWFybGllclsxXSkge1xuICAgICAgICAgICAgci5yZWRyYXdIaW50KCdlbGVzJywgdHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHIucmVkcmF3KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gb3RoZXJ3aXNlIGtlZXAgdHJhY2sgb2YgZHJhZyBkZWx0YSBmb3IgbGF0ZXJcbiAgICAgICAgICB2YXIgZHJhZ0RlbHRhID0gci50b3VjaERhdGEuZHJhZ0RlbHRhID0gci50b3VjaERhdGEuZHJhZ0RlbHRhIHx8IFtdO1xuICAgICAgICAgIGlmIChkcmFnRGVsdGEubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBkcmFnRGVsdGEucHVzaChkaXNwWzBdKTtcbiAgICAgICAgICAgIGRyYWdEZWx0YS5wdXNoKGRpc3BbMV0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkcmFnRGVsdGFbMF0gKz0gZGlzcFswXTtcbiAgICAgICAgICAgIGRyYWdEZWx0YVsxXSArPSBkaXNwWzFdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyB0b3VjaG1vdmVcbiAgICAgIHtcbiAgICAgICAgdHJpZ2dlckV2ZW50cyhzdGFydCB8fCBuZWFyLCBbJ3RvdWNobW92ZScsICd0YXBkcmFnJywgJ3Ztb3VzZW1vdmUnXSwgZSwge1xuICAgICAgICAgIHg6IG5vd1swXSxcbiAgICAgICAgICB5OiBub3dbMV1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmICgoIXN0YXJ0IHx8ICFzdGFydC5ncmFiYmVkKCkpICYmIG5lYXIgIT0gbGFzdCkge1xuICAgICAgICAgIGlmIChsYXN0KSB7XG4gICAgICAgICAgICBsYXN0LmVtaXQoe1xuICAgICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBlLFxuICAgICAgICAgICAgICB0eXBlOiAndGFwZHJhZ291dCcsXG4gICAgICAgICAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgICAgICAgICAgeDogbm93WzBdLFxuICAgICAgICAgICAgICAgIHk6IG5vd1sxXVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG5lYXIpIHtcbiAgICAgICAgICAgIG5lYXIuZW1pdCh7XG4gICAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGUsXG4gICAgICAgICAgICAgIHR5cGU6ICd0YXBkcmFnb3ZlcicsXG4gICAgICAgICAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgICAgICAgICAgeDogbm93WzBdLFxuICAgICAgICAgICAgICAgIHk6IG5vd1sxXVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgci50b3VjaERhdGEubGFzdCA9IG5lYXI7XG4gICAgICB9XG5cbiAgICAgIC8vIGNoZWNrIHRvIGNhbmNlbCB0YXBob2xkXG4gICAgICBpZiAoY2FwdHVyZSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vdy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChub3dbaV0gJiYgci50b3VjaERhdGEuc3RhcnRQb3NpdGlvbltpXSAmJiBpc092ZXJUaHJlc2hvbGREcmFnKSB7XG4gICAgICAgICAgICByLnRvdWNoRGF0YS5zaW5nbGVUb3VjaE1vdmVkID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gcGFubmluZ1xuICAgICAgaWYgKGNhcHR1cmUgJiYgKHN0YXJ0ID09IG51bGwgfHwgc3RhcnQucGFubmFibGUoKSkgJiYgY3kucGFubmluZ0VuYWJsZWQoKSAmJiBjeS51c2VyUGFubmluZ0VuYWJsZWQoKSkge1xuICAgICAgICB2YXIgYWxsb3dQYXNzdGhyb3VnaCA9IGFsbG93UGFubmluZ1Bhc3N0aHJvdWdoKHN0YXJ0LCByLnRvdWNoRGF0YS5zdGFydHMpO1xuICAgICAgICBpZiAoYWxsb3dQYXNzdGhyb3VnaCkge1xuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICBpZiAoIXIuZGF0YS5iZ0FjdGl2ZVBvc2lzdGlvbikge1xuICAgICAgICAgICAgci5kYXRhLmJnQWN0aXZlUG9zaXN0aW9uID0gYXJyYXkycG9pbnQoci50b3VjaERhdGEuc3RhcnRQb3NpdGlvbik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyLnN3aXBlUGFubmluZykge1xuICAgICAgICAgICAgY3kucGFuQnkoe1xuICAgICAgICAgICAgICB4OiBkaXNwWzBdICogem9vbSxcbiAgICAgICAgICAgICAgeTogZGlzcFsxXSAqIHpvb21cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY3kuZW1pdCgnZHJhZ3BhbicpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaXNPdmVyVGhyZXNob2xkRHJhZykge1xuICAgICAgICAgICAgci5zd2lwZVBhbm5pbmcgPSB0cnVlO1xuICAgICAgICAgICAgY3kucGFuQnkoe1xuICAgICAgICAgICAgICB4OiBkeCAqIHpvb20sXG4gICAgICAgICAgICAgIHk6IGR5ICogem9vbVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjeS5lbWl0KCdkcmFncGFuJyk7XG4gICAgICAgICAgICBpZiAoc3RhcnQpIHtcbiAgICAgICAgICAgICAgc3RhcnQudW5hY3RpdmF0ZSgpO1xuICAgICAgICAgICAgICByLnJlZHJhd0hpbnQoJ3NlbGVjdCcsIHRydWUpO1xuICAgICAgICAgICAgICByLnRvdWNoRGF0YS5zdGFydCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmUtcHJvamVjdFxuICAgICAgICB2YXIgcG9zID0gci5wcm9qZWN0SW50b1ZpZXdwb3J0KGUudG91Y2hlc1swXS5jbGllbnRYLCBlLnRvdWNoZXNbMF0uY2xpZW50WSk7XG4gICAgICAgIG5vd1swXSA9IHBvc1swXTtcbiAgICAgICAgbm93WzFdID0gcG9zWzFdO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IG5vdy5sZW5ndGg7IGorKykge1xuICAgICAgZWFybGllcltqXSA9IG5vd1tqXTtcbiAgICB9XG5cbiAgICAvLyB0aGUgYWN0aXZlIGJnIGluZGljYXRvciBzaG91bGQgYmUgcmVtb3ZlZCB3aGVuIG1ha2luZyBhIHN3aXBlIHRoYXQgaXMgbmVpdGhlciBmb3IgZHJhZ2dpbmcgbm9kZXMgb3IgcGFubmluZ1xuICAgIGlmIChjYXB0dXJlICYmIGUudG91Y2hlcy5sZW5ndGggPiAwICYmICFyLmhvdmVyRGF0YS5kcmFnZ2luZ0VsZXMgJiYgIXIuc3dpcGVQYW5uaW5nICYmIHIuZGF0YS5iZ0FjdGl2ZVBvc2lzdGlvbiAhPSBudWxsKSB7XG4gICAgICByLmRhdGEuYmdBY3RpdmVQb3Npc3Rpb24gPSB1bmRlZmluZWQ7XG4gICAgICByLnJlZHJhd0hpbnQoJ3NlbGVjdCcsIHRydWUpO1xuICAgICAgci5yZWRyYXcoKTtcbiAgICB9XG4gIH0sIGZhbHNlKTtcbiAgdmFyIHRvdWNoY2FuY2VsSGFuZGxlcjtcbiAgci5yZWdpc3RlckJpbmRpbmcoY29udGFpbmVyV2luZG93LCAndG91Y2hjYW5jZWwnLCB0b3VjaGNhbmNlbEhhbmRsZXIgPSBmdW5jdGlvbiB0b3VjaGNhbmNlbEhhbmRsZXIoZSkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICB2YXIgc3RhcnQgPSByLnRvdWNoRGF0YS5zdGFydDtcbiAgICByLnRvdWNoRGF0YS5jYXB0dXJlID0gZmFsc2U7XG4gICAgaWYgKHN0YXJ0KSB7XG4gICAgICBzdGFydC51bmFjdGl2YXRlKCk7XG4gICAgfVxuICB9KTtcbiAgdmFyIHRvdWNoZW5kSGFuZGxlciwgZGlkRG91YmxlVG91Y2gsIHRvdWNoVGltZW91dCwgcHJldlRvdWNoVGltZVN0YW1wO1xuICByLnJlZ2lzdGVyQmluZGluZyhjb250YWluZXJXaW5kb3csICd0b3VjaGVuZCcsIHRvdWNoZW5kSGFuZGxlciA9IGZ1bmN0aW9uIHRvdWNoZW5kSGFuZGxlcihlKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgIHZhciBzdGFydCA9IHIudG91Y2hEYXRhLnN0YXJ0O1xuICAgIHZhciBjYXB0dXJlID0gci50b3VjaERhdGEuY2FwdHVyZTtcbiAgICBpZiAoY2FwdHVyZSkge1xuICAgICAgaWYgKGUudG91Y2hlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgci50b3VjaERhdGEuY2FwdHVyZSA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBzZWxlY3QgPSByLnNlbGVjdGlvbjtcbiAgICByLnN3aXBlUGFubmluZyA9IGZhbHNlO1xuICAgIHIuaG92ZXJEYXRhLmRyYWdnaW5nRWxlcyA9IGZhbHNlO1xuICAgIHZhciBjeSA9IHIuY3k7XG4gICAgdmFyIHpvb20gPSBjeS56b29tKCk7XG4gICAgdmFyIG5vdyA9IHIudG91Y2hEYXRhLm5vdztcbiAgICB2YXIgZWFybGllciA9IHIudG91Y2hEYXRhLmVhcmxpZXI7XG4gICAgaWYgKGUudG91Y2hlc1swXSkge1xuICAgICAgdmFyIHBvcyA9IHIucHJvamVjdEludG9WaWV3cG9ydChlLnRvdWNoZXNbMF0uY2xpZW50WCwgZS50b3VjaGVzWzBdLmNsaWVudFkpO1xuICAgICAgbm93WzBdID0gcG9zWzBdO1xuICAgICAgbm93WzFdID0gcG9zWzFdO1xuICAgIH1cbiAgICBpZiAoZS50b3VjaGVzWzFdKSB7XG4gICAgICB2YXIgcG9zID0gci5wcm9qZWN0SW50b1ZpZXdwb3J0KGUudG91Y2hlc1sxXS5jbGllbnRYLCBlLnRvdWNoZXNbMV0uY2xpZW50WSk7XG4gICAgICBub3dbMl0gPSBwb3NbMF07XG4gICAgICBub3dbM10gPSBwb3NbMV07XG4gICAgfVxuICAgIGlmIChlLnRvdWNoZXNbMl0pIHtcbiAgICAgIHZhciBwb3MgPSByLnByb2plY3RJbnRvVmlld3BvcnQoZS50b3VjaGVzWzJdLmNsaWVudFgsIGUudG91Y2hlc1syXS5jbGllbnRZKTtcbiAgICAgIG5vd1s0XSA9IHBvc1swXTtcbiAgICAgIG5vd1s1XSA9IHBvc1sxXTtcbiAgICB9XG4gICAgaWYgKHN0YXJ0KSB7XG4gICAgICBzdGFydC51bmFjdGl2YXRlKCk7XG4gICAgfVxuICAgIHZhciBjdHhUYXBlbmQ7XG4gICAgaWYgKHIudG91Y2hEYXRhLmN4dCkge1xuICAgICAgY3R4VGFwZW5kID0ge1xuICAgICAgICBvcmlnaW5hbEV2ZW50OiBlLFxuICAgICAgICB0eXBlOiAnY3h0dGFwZW5kJyxcbiAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICB4OiBub3dbMF0sXG4gICAgICAgICAgeTogbm93WzFdXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBpZiAoc3RhcnQpIHtcbiAgICAgICAgc3RhcnQuZW1pdChjdHhUYXBlbmQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3kuZW1pdChjdHhUYXBlbmQpO1xuICAgICAgfVxuICAgICAgaWYgKCFyLnRvdWNoRGF0YS5jeHREcmFnZ2VkKSB7XG4gICAgICAgIHZhciBjdHhUYXAgPSB7XG4gICAgICAgICAgb3JpZ2luYWxFdmVudDogZSxcbiAgICAgICAgICB0eXBlOiAnY3h0dGFwJyxcbiAgICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgICAgeDogbm93WzBdLFxuICAgICAgICAgICAgeTogbm93WzFdXG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBpZiAoc3RhcnQpIHtcbiAgICAgICAgICBzdGFydC5lbWl0KGN0eFRhcCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3kuZW1pdChjdHhUYXApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoci50b3VjaERhdGEuc3RhcnQpIHtcbiAgICAgICAgci50b3VjaERhdGEuc3RhcnQuX3ByaXZhdGUuZ3JhYmJlZCA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgci50b3VjaERhdGEuY3h0ID0gZmFsc2U7XG4gICAgICByLnRvdWNoRGF0YS5zdGFydCA9IG51bGw7XG4gICAgICByLnJlZHJhdygpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIG5vIG1vcmUgYm94IHNlbGVjdGlvbiBpZiB3ZSBkb24ndCBoYXZlIHRocmVlIGZpbmdlcnNcbiAgICBpZiAoIWUudG91Y2hlc1syXSAmJiBjeS5ib3hTZWxlY3Rpb25FbmFibGVkKCkgJiYgci50b3VjaERhdGEuc2VsZWN0aW5nKSB7XG4gICAgICByLnRvdWNoRGF0YS5zZWxlY3RpbmcgPSBmYWxzZTtcbiAgICAgIHZhciBib3ggPSBjeS5jb2xsZWN0aW9uKHIuZ2V0QWxsSW5Cb3goc2VsZWN0WzBdLCBzZWxlY3RbMV0sIHNlbGVjdFsyXSwgc2VsZWN0WzNdKSk7XG4gICAgICBzZWxlY3RbMF0gPSB1bmRlZmluZWQ7XG4gICAgICBzZWxlY3RbMV0gPSB1bmRlZmluZWQ7XG4gICAgICBzZWxlY3RbMl0gPSB1bmRlZmluZWQ7XG4gICAgICBzZWxlY3RbM10gPSB1bmRlZmluZWQ7XG4gICAgICBzZWxlY3RbNF0gPSAwO1xuICAgICAgci5yZWRyYXdIaW50KCdzZWxlY3QnLCB0cnVlKTtcbiAgICAgIGN5LmVtaXQoe1xuICAgICAgICB0eXBlOiAnYm94ZW5kJyxcbiAgICAgICAgb3JpZ2luYWxFdmVudDogZSxcbiAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICB4OiBub3dbMF0sXG4gICAgICAgICAgeTogbm93WzFdXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdmFyIGVsZVdvdWxkQmVTZWxlY3RlZCA9IGZ1bmN0aW9uIGVsZVdvdWxkQmVTZWxlY3RlZChlbGUpIHtcbiAgICAgICAgcmV0dXJuIGVsZS5zZWxlY3RhYmxlKCkgJiYgIWVsZS5zZWxlY3RlZCgpO1xuICAgICAgfTtcbiAgICAgIGJveC5lbWl0KCdib3gnKS5zdGRGaWx0ZXIoZWxlV291bGRCZVNlbGVjdGVkKS5zZWxlY3QoKS5lbWl0KCdib3hzZWxlY3QnKTtcbiAgICAgIGlmIChib3gubm9uZW1wdHkoKSkge1xuICAgICAgICByLnJlZHJhd0hpbnQoJ2VsZXMnLCB0cnVlKTtcbiAgICAgIH1cbiAgICAgIHIucmVkcmF3KCk7XG4gICAgfVxuICAgIGlmIChzdGFydCAhPSBudWxsKSB7XG4gICAgICBzdGFydC51bmFjdGl2YXRlKCk7XG4gICAgfVxuICAgIGlmIChlLnRvdWNoZXNbMl0pIHtcbiAgICAgIHIuZGF0YS5iZ0FjdGl2ZVBvc2lzdGlvbiA9IHVuZGVmaW5lZDtcbiAgICAgIHIucmVkcmF3SGludCgnc2VsZWN0JywgdHJ1ZSk7XG4gICAgfSBlbHNlIGlmIChlLnRvdWNoZXNbMV0pIDsgZWxzZSBpZiAoZS50b3VjaGVzWzBdKSA7IGVsc2UgaWYgKCFlLnRvdWNoZXNbMF0pIHtcbiAgICAgIHIuZGF0YS5iZ0FjdGl2ZVBvc2lzdGlvbiA9IHVuZGVmaW5lZDtcbiAgICAgIHIucmVkcmF3SGludCgnc2VsZWN0JywgdHJ1ZSk7XG4gICAgICB2YXIgZHJhZ2dlZEVsZXMgPSByLmRyYWdEYXRhLnRvdWNoRHJhZ0VsZXM7XG4gICAgICBpZiAoc3RhcnQgIT0gbnVsbCkge1xuICAgICAgICB2YXIgc3RhcnRXYXNHcmFiYmVkID0gc3RhcnQuX3ByaXZhdGUuZ3JhYmJlZDtcbiAgICAgICAgZnJlZURyYWdnZWRFbGVtZW50cyhkcmFnZ2VkRWxlcyk7XG4gICAgICAgIHIucmVkcmF3SGludCgnZHJhZycsIHRydWUpO1xuICAgICAgICByLnJlZHJhd0hpbnQoJ2VsZXMnLCB0cnVlKTtcbiAgICAgICAgaWYgKHN0YXJ0V2FzR3JhYmJlZCkge1xuICAgICAgICAgIHN0YXJ0LmVtaXQoJ2ZyZWVvbicpO1xuICAgICAgICAgIGRyYWdnZWRFbGVzLmVtaXQoJ2ZyZWUnKTtcbiAgICAgICAgICBpZiAoci5kcmFnRGF0YS5kaWREcmFnKSB7XG4gICAgICAgICAgICBzdGFydC5lbWl0KCdkcmFnZnJlZW9uJyk7XG4gICAgICAgICAgICBkcmFnZ2VkRWxlcy5lbWl0KCdkcmFnZnJlZScpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0cmlnZ2VyRXZlbnRzKHN0YXJ0LCBbJ3RvdWNoZW5kJywgJ3RhcGVuZCcsICd2bW91c2V1cCcsICd0YXBkcmFnb3V0J10sIGUsIHtcbiAgICAgICAgICB4OiBub3dbMF0sXG4gICAgICAgICAgeTogbm93WzFdXG4gICAgICAgIH0pO1xuICAgICAgICBzdGFydC51bmFjdGl2YXRlKCk7XG4gICAgICAgIHIudG91Y2hEYXRhLnN0YXJ0ID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBuZWFyID0gci5maW5kTmVhcmVzdEVsZW1lbnQobm93WzBdLCBub3dbMV0sIHRydWUsIHRydWUpO1xuICAgICAgICB0cmlnZ2VyRXZlbnRzKG5lYXIsIFsndG91Y2hlbmQnLCAndGFwZW5kJywgJ3Ztb3VzZXVwJywgJ3RhcGRyYWdvdXQnXSwgZSwge1xuICAgICAgICAgIHg6IG5vd1swXSxcbiAgICAgICAgICB5OiBub3dbMV1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICB2YXIgZHggPSByLnRvdWNoRGF0YS5zdGFydFBvc2l0aW9uWzBdIC0gbm93WzBdO1xuICAgICAgdmFyIGR4MiA9IGR4ICogZHg7XG4gICAgICB2YXIgZHkgPSByLnRvdWNoRGF0YS5zdGFydFBvc2l0aW9uWzFdIC0gbm93WzFdO1xuICAgICAgdmFyIGR5MiA9IGR5ICogZHk7XG4gICAgICB2YXIgZGlzdDIgPSBkeDIgKyBkeTI7XG4gICAgICB2YXIgcmRpc3QyID0gZGlzdDIgKiB6b29tICogem9vbTtcblxuICAgICAgLy8gVGFwIGV2ZW50LCByb3VnaGx5IHNhbWUgYXMgbW91c2UgY2xpY2sgZXZlbnQgZm9yIHRvdWNoXG4gICAgICBpZiAoIXIudG91Y2hEYXRhLnNpbmdsZVRvdWNoTW92ZWQpIHtcbiAgICAgICAgaWYgKCFzdGFydCkge1xuICAgICAgICAgIGN5LiQoJzpzZWxlY3RlZCcpLnVuc2VsZWN0KFsndGFwdW5zZWxlY3QnXSk7XG4gICAgICAgIH1cbiAgICAgICAgdHJpZ2dlckV2ZW50cyhzdGFydCwgWyd0YXAnLCAndmNsaWNrJ10sIGUsIHtcbiAgICAgICAgICB4OiBub3dbMF0sXG4gICAgICAgICAgeTogbm93WzFdXG4gICAgICAgIH0pO1xuICAgICAgICBkaWREb3VibGVUb3VjaCA9IGZhbHNlO1xuICAgICAgICBpZiAoZS50aW1lU3RhbXAgLSBwcmV2VG91Y2hUaW1lU3RhbXAgPD0gY3kubXVsdGlDbGlja0RlYm91bmNlVGltZSgpKSB7XG4gICAgICAgICAgdG91Y2hUaW1lb3V0ICYmIGNsZWFyVGltZW91dCh0b3VjaFRpbWVvdXQpO1xuICAgICAgICAgIGRpZERvdWJsZVRvdWNoID0gdHJ1ZTtcbiAgICAgICAgICBwcmV2VG91Y2hUaW1lU3RhbXAgPSBudWxsO1xuICAgICAgICAgIHRyaWdnZXJFdmVudHMoc3RhcnQsIFsnZGJsdGFwJywgJ3ZkYmxjbGljayddLCBlLCB7XG4gICAgICAgICAgICB4OiBub3dbMF0sXG4gICAgICAgICAgICB5OiBub3dbMV1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0b3VjaFRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChkaWREb3VibGVUb3VjaCkgcmV0dXJuO1xuICAgICAgICAgICAgdHJpZ2dlckV2ZW50cyhzdGFydCwgWydvbmV0YXAnLCAndm9uZWNsaWNrJ10sIGUsIHtcbiAgICAgICAgICAgICAgeDogbm93WzBdLFxuICAgICAgICAgICAgICB5OiBub3dbMV1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0sIGN5Lm11bHRpQ2xpY2tEZWJvdW5jZVRpbWUoKSk7XG4gICAgICAgICAgcHJldlRvdWNoVGltZVN0YW1wID0gZS50aW1lU3RhbXA7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gUHJlcGFyZSB0byBzZWxlY3QgdGhlIGN1cnJlbnRseSB0b3VjaGVkIG5vZGUsIG9ubHkgaWYgaXQgaGFzbid0IGJlZW4gZHJhZ2dlZCBwYXN0IGEgY2VydGFpbiBkaXN0YW5jZVxuICAgICAgaWYgKHN0YXJ0ICE9IG51bGwgJiYgIXIuZHJhZ0RhdGEuZGlkRHJhZyAvLyBkaWRuJ3QgZHJhZyBub2RlcyBhcm91bmRcbiAgICAgICYmIHN0YXJ0Ll9wcml2YXRlLnNlbGVjdGFibGUgJiYgcmRpc3QyIDwgci50b3VjaFRhcFRocmVzaG9sZDIgJiYgIXIucGluY2hpbmcgLy8gcGluY2ggdG8gem9vbSBzaG91bGQgbm90IGFmZmVjdCBzZWxlY3Rpb25cbiAgICAgICkge1xuICAgICAgICBpZiAoY3kuc2VsZWN0aW9uVHlwZSgpID09PSAnc2luZ2xlJykge1xuICAgICAgICAgIGN5LiQoaXNTZWxlY3RlZCkudW5tZXJnZShzdGFydCkudW5zZWxlY3QoWyd0YXB1bnNlbGVjdCddKTtcbiAgICAgICAgICBzdGFydC5zZWxlY3QoWyd0YXBzZWxlY3QnXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHN0YXJ0LnNlbGVjdGVkKCkpIHtcbiAgICAgICAgICAgIHN0YXJ0LnVuc2VsZWN0KFsndGFwdW5zZWxlY3QnXSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0YXJ0LnNlbGVjdChbJ3RhcHNlbGVjdCddKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgci5yZWRyYXdIaW50KCdlbGVzJywgdHJ1ZSk7XG4gICAgICB9XG4gICAgICByLnRvdWNoRGF0YS5zaW5nbGVUb3VjaE1vdmVkID0gdHJ1ZTtcbiAgICB9XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBub3cubGVuZ3RoOyBqKyspIHtcbiAgICAgIGVhcmxpZXJbal0gPSBub3dbal07XG4gICAgfVxuICAgIHIuZHJhZ0RhdGEuZGlkRHJhZyA9IGZhbHNlOyAvLyByZXNldCBmb3IgbmV4dCB0b3VjaHN0YXJ0XG5cbiAgICBpZiAoZS50b3VjaGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgci50b3VjaERhdGEuZHJhZ0RlbHRhID0gW107XG4gICAgICByLnRvdWNoRGF0YS5zdGFydFBvc2l0aW9uID0gW251bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGxdO1xuICAgICAgci50b3VjaERhdGEuc3RhcnRHUG9zaXRpb24gPSBudWxsO1xuICAgICAgci50b3VjaERhdGEuZGlkU2VsZWN0ID0gZmFsc2U7XG4gICAgfVxuICAgIGlmIChlLnRvdWNoZXMubGVuZ3RoIDwgMikge1xuICAgICAgaWYgKGUudG91Y2hlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgLy8gdGhlIG9sZCBzdGFydCBnbG9iYWwgcG9zJ24gbWF5IG5vdCBiZSB0aGUgc2FtZSBmaW5nZXIgdGhhdCByZW1haW5zXG4gICAgICAgIHIudG91Y2hEYXRhLnN0YXJ0R1Bvc2l0aW9uID0gW2UudG91Y2hlc1swXS5jbGllbnRYLCBlLnRvdWNoZXNbMF0uY2xpZW50WV07XG4gICAgICB9XG4gICAgICByLnBpbmNoaW5nID0gZmFsc2U7XG4gICAgICByLnJlZHJhd0hpbnQoJ2VsZXMnLCB0cnVlKTtcbiAgICAgIHIucmVkcmF3KCk7XG4gICAgfVxuXG4gICAgLy9yLnJlZHJhdygpO1xuICB9LCBmYWxzZSk7XG5cbiAgLy8gZmFsbGJhY2sgY29tcGF0aWJpbGl0eSBsYXllciBmb3IgbXMgcG9pbnRlciBldmVudHNcbiAgaWYgKHR5cGVvZiBUb3VjaEV2ZW50ID09PSAndW5kZWZpbmVkJykge1xuICAgIHZhciBwb2ludGVycyA9IFtdO1xuICAgIHZhciBtYWtlVG91Y2ggPSBmdW5jdGlvbiBtYWtlVG91Y2goZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY2xpZW50WDogZS5jbGllbnRYLFxuICAgICAgICBjbGllbnRZOiBlLmNsaWVudFksXG4gICAgICAgIGZvcmNlOiAxLFxuICAgICAgICBpZGVudGlmaWVyOiBlLnBvaW50ZXJJZCxcbiAgICAgICAgcGFnZVg6IGUucGFnZVgsXG4gICAgICAgIHBhZ2VZOiBlLnBhZ2VZLFxuICAgICAgICByYWRpdXNYOiBlLndpZHRoIC8gMixcbiAgICAgICAgcmFkaXVzWTogZS5oZWlnaHQgLyAyLFxuICAgICAgICBzY3JlZW5YOiBlLnNjcmVlblgsXG4gICAgICAgIHNjcmVlblk6IGUuc2NyZWVuWSxcbiAgICAgICAgdGFyZ2V0OiBlLnRhcmdldFxuICAgICAgfTtcbiAgICB9O1xuICAgIHZhciBtYWtlUG9pbnRlciA9IGZ1bmN0aW9uIG1ha2VQb2ludGVyKGUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGV2ZW50OiBlLFxuICAgICAgICB0b3VjaDogbWFrZVRvdWNoKGUpXG4gICAgICB9O1xuICAgIH07XG4gICAgdmFyIGFkZFBvaW50ZXIgPSBmdW5jdGlvbiBhZGRQb2ludGVyKGUpIHtcbiAgICAgIHBvaW50ZXJzLnB1c2gobWFrZVBvaW50ZXIoZSkpO1xuICAgIH07XG4gICAgdmFyIHJlbW92ZVBvaW50ZXIgPSBmdW5jdGlvbiByZW1vdmVQb2ludGVyKGUpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9pbnRlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHAgPSBwb2ludGVyc1tpXTtcbiAgICAgICAgaWYgKHAuZXZlbnQucG9pbnRlcklkID09PSBlLnBvaW50ZXJJZCkge1xuICAgICAgICAgIHBvaW50ZXJzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciB1cGRhdGVQb2ludGVyID0gZnVuY3Rpb24gdXBkYXRlUG9pbnRlcihlKSB7XG4gICAgICB2YXIgcCA9IHBvaW50ZXJzLmZpbHRlcihmdW5jdGlvbiAocCkge1xuICAgICAgICByZXR1cm4gcC5ldmVudC5wb2ludGVySWQgPT09IGUucG9pbnRlcklkO1xuICAgICAgfSlbMF07XG4gICAgICBwLmV2ZW50ID0gZTtcbiAgICAgIHAudG91Y2ggPSBtYWtlVG91Y2goZSk7XG4gICAgfTtcbiAgICB2YXIgYWRkVG91Y2hlc1RvRXZlbnQgPSBmdW5jdGlvbiBhZGRUb3VjaGVzVG9FdmVudChlKSB7XG4gICAgICBlLnRvdWNoZXMgPSBwb2ludGVycy5tYXAoZnVuY3Rpb24gKHApIHtcbiAgICAgICAgcmV0dXJuIHAudG91Y2g7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIHZhciBwb2ludGVySXNNb3VzZSA9IGZ1bmN0aW9uIHBvaW50ZXJJc01vdXNlKGUpIHtcbiAgICAgIHJldHVybiBlLnBvaW50ZXJUeXBlID09PSAnbW91c2UnIHx8IGUucG9pbnRlclR5cGUgPT09IDQ7XG4gICAgfTtcbiAgICByLnJlZ2lzdGVyQmluZGluZyhyLmNvbnRhaW5lciwgJ3BvaW50ZXJkb3duJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgIGlmIChwb2ludGVySXNNb3VzZShlKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIG1vdXNlIGFscmVhZHkgaGFuZGxlZFxuXG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBhZGRQb2ludGVyKGUpO1xuICAgICAgYWRkVG91Y2hlc1RvRXZlbnQoZSk7XG4gICAgICB0b3VjaHN0YXJ0SGFuZGxlcihlKTtcbiAgICB9KTtcbiAgICByLnJlZ2lzdGVyQmluZGluZyhyLmNvbnRhaW5lciwgJ3BvaW50ZXJ1cCcsIGZ1bmN0aW9uIChlKSB7XG4gICAgICBpZiAocG9pbnRlcklzTW91c2UoZSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBtb3VzZSBhbHJlYWR5IGhhbmRsZWRcblxuICAgICAgcmVtb3ZlUG9pbnRlcihlKTtcbiAgICAgIGFkZFRvdWNoZXNUb0V2ZW50KGUpO1xuICAgICAgdG91Y2hlbmRIYW5kbGVyKGUpO1xuICAgIH0pO1xuICAgIHIucmVnaXN0ZXJCaW5kaW5nKHIuY29udGFpbmVyLCAncG9pbnRlcmNhbmNlbCcsIGZ1bmN0aW9uIChlKSB7XG4gICAgICBpZiAocG9pbnRlcklzTW91c2UoZSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBtb3VzZSBhbHJlYWR5IGhhbmRsZWRcblxuICAgICAgcmVtb3ZlUG9pbnRlcihlKTtcbiAgICAgIGFkZFRvdWNoZXNUb0V2ZW50KGUpO1xuICAgICAgdG91Y2hjYW5jZWxIYW5kbGVyKGUpO1xuICAgIH0pO1xuICAgIHIucmVnaXN0ZXJCaW5kaW5nKHIuY29udGFpbmVyLCAncG9pbnRlcm1vdmUnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgaWYgKHBvaW50ZXJJc01vdXNlKGUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gbW91c2UgYWxyZWFkeSBoYW5kbGVkXG5cbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHVwZGF0ZVBvaW50ZXIoZSk7XG4gICAgICBhZGRUb3VjaGVzVG9FdmVudChlKTtcbiAgICAgIHRvdWNobW92ZUhhbmRsZXIoZSk7XG4gICAgfSk7XG4gIH1cbn07XG5cbnZhciBCUnAkMiA9IHt9O1xuQlJwJDIuZ2VuZXJhdGVQb2x5Z29uID0gZnVuY3Rpb24gKG5hbWUsIHBvaW50cykge1xuICByZXR1cm4gdGhpcy5ub2RlU2hhcGVzW25hbWVdID0ge1xuICAgIHJlbmRlcmVyOiB0aGlzLFxuICAgIG5hbWU6IG5hbWUsXG4gICAgcG9pbnRzOiBwb2ludHMsXG4gICAgZHJhdzogZnVuY3Rpb24gZHJhdyhjb250ZXh0LCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0LCBjb3JuZXJSYWRpdXMpIHtcbiAgICAgIHRoaXMucmVuZGVyZXIubm9kZVNoYXBlSW1wbCgncG9seWdvbicsIGNvbnRleHQsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQsIHRoaXMucG9pbnRzKTtcbiAgICB9LFxuICAgIGludGVyc2VjdExpbmU6IGZ1bmN0aW9uIGludGVyc2VjdExpbmUobm9kZVgsIG5vZGVZLCB3aWR0aCwgaGVpZ2h0LCB4LCB5LCBwYWRkaW5nLCBjb3JuZXJSYWRpdXMpIHtcbiAgICAgIHJldHVybiBwb2x5Z29uSW50ZXJzZWN0TGluZSh4LCB5LCB0aGlzLnBvaW50cywgbm9kZVgsIG5vZGVZLCB3aWR0aCAvIDIsIGhlaWdodCAvIDIsIHBhZGRpbmcpO1xuICAgIH0sXG4gICAgY2hlY2tQb2ludDogZnVuY3Rpb24gY2hlY2tQb2ludCh4LCB5LCBwYWRkaW5nLCB3aWR0aCwgaGVpZ2h0LCBjZW50ZXJYLCBjZW50ZXJZLCBjb3JuZXJSYWRpdXMpIHtcbiAgICAgIHJldHVybiBwb2ludEluc2lkZVBvbHlnb24oeCwgeSwgdGhpcy5wb2ludHMsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQsIFswLCAtMV0sIHBhZGRpbmcpO1xuICAgIH1cbiAgfTtcbn07XG5CUnAkMi5nZW5lcmF0ZUVsbGlwc2UgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLm5vZGVTaGFwZXNbJ2VsbGlwc2UnXSA9IHtcbiAgICByZW5kZXJlcjogdGhpcyxcbiAgICBuYW1lOiAnZWxsaXBzZScsXG4gICAgZHJhdzogZnVuY3Rpb24gZHJhdyhjb250ZXh0LCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0LCBjb3JuZXJSYWRpdXMpIHtcbiAgICAgIHRoaXMucmVuZGVyZXIubm9kZVNoYXBlSW1wbCh0aGlzLm5hbWUsIGNvbnRleHQsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQpO1xuICAgIH0sXG4gICAgaW50ZXJzZWN0TGluZTogZnVuY3Rpb24gaW50ZXJzZWN0TGluZShub2RlWCwgbm9kZVksIHdpZHRoLCBoZWlnaHQsIHgsIHksIHBhZGRpbmcsIGNvcm5lclJhZGl1cykge1xuICAgICAgcmV0dXJuIGludGVyc2VjdExpbmVFbGxpcHNlKHgsIHksIG5vZGVYLCBub2RlWSwgd2lkdGggLyAyICsgcGFkZGluZywgaGVpZ2h0IC8gMiArIHBhZGRpbmcpO1xuICAgIH0sXG4gICAgY2hlY2tQb2ludDogZnVuY3Rpb24gY2hlY2tQb2ludCh4LCB5LCBwYWRkaW5nLCB3aWR0aCwgaGVpZ2h0LCBjZW50ZXJYLCBjZW50ZXJZLCBjb3JuZXJSYWRpdXMpIHtcbiAgICAgIHJldHVybiBjaGVja0luRWxsaXBzZSh4LCB5LCB3aWR0aCwgaGVpZ2h0LCBjZW50ZXJYLCBjZW50ZXJZLCBwYWRkaW5nKTtcbiAgICB9XG4gIH07XG59O1xuQlJwJDIuZ2VuZXJhdGVSb3VuZFBvbHlnb24gPSBmdW5jdGlvbiAobmFtZSwgcG9pbnRzKSB7XG4gIHJldHVybiB0aGlzLm5vZGVTaGFwZXNbbmFtZV0gPSB7XG4gICAgcmVuZGVyZXI6IHRoaXMsXG4gICAgbmFtZTogbmFtZSxcbiAgICBwb2ludHM6IHBvaW50cyxcbiAgICBnZXRPckNyZWF0ZUNvcm5lcnM6IGZ1bmN0aW9uIGdldE9yQ3JlYXRlQ29ybmVycyhjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0LCBjb3JuZXJSYWRpdXMsIHJzLCBmaWVsZCkge1xuICAgICAgaWYgKHJzW2ZpZWxkXSAhPT0gdW5kZWZpbmVkICYmIHJzW2ZpZWxkICsgJy1jeCddID09PSBjZW50ZXJYICYmIHJzW2ZpZWxkICsgJy1jeSddID09PSBjZW50ZXJZKSB7XG4gICAgICAgIHJldHVybiByc1tmaWVsZF07XG4gICAgICB9XG4gICAgICByc1tmaWVsZF0gPSBuZXcgQXJyYXkocG9pbnRzLmxlbmd0aCAvIDIpO1xuICAgICAgcnNbZmllbGQgKyAnLWN4J10gPSBjZW50ZXJYO1xuICAgICAgcnNbZmllbGQgKyAnLWN5J10gPSBjZW50ZXJZO1xuICAgICAgdmFyIGhhbGZXID0gd2lkdGggLyAyO1xuICAgICAgdmFyIGhhbGZIID0gaGVpZ2h0IC8gMjtcbiAgICAgIGNvcm5lclJhZGl1cyA9IGNvcm5lclJhZGl1cyA9PT0gJ2F1dG8nID8gZ2V0Um91bmRQb2x5Z29uUmFkaXVzKHdpZHRoLCBoZWlnaHQpIDogY29ybmVyUmFkaXVzO1xuICAgICAgdmFyIHAgPSBuZXcgQXJyYXkocG9pbnRzLmxlbmd0aCAvIDIpO1xuICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IHBvaW50cy5sZW5ndGggLyAyOyBfaSsrKSB7XG4gICAgICAgIHBbX2ldID0ge1xuICAgICAgICAgIHg6IGNlbnRlclggKyBoYWxmVyAqIHBvaW50c1tfaSAqIDJdLFxuICAgICAgICAgIHk6IGNlbnRlclkgKyBoYWxmSCAqIHBvaW50c1tfaSAqIDIgKyAxXVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgdmFyIGksXG4gICAgICAgIHAxLFxuICAgICAgICBwMixcbiAgICAgICAgcDMsXG4gICAgICAgIGxlbiA9IHAubGVuZ3RoO1xuICAgICAgcDEgPSBwW2xlbiAtIDFdO1xuICAgICAgLy8gZm9yIGVhY2ggcG9pbnRcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBwMiA9IHBbaSAlIGxlbl07XG4gICAgICAgIHAzID0gcFsoaSArIDEpICUgbGVuXTtcbiAgICAgICAgcnNbZmllbGRdW2ldID0gZ2V0Um91bmRDb3JuZXIocDEsIHAyLCBwMywgY29ybmVyUmFkaXVzKTtcbiAgICAgICAgcDEgPSBwMjtcbiAgICAgICAgcDIgPSBwMztcbiAgICAgIH1cbiAgICAgIHJldHVybiByc1tmaWVsZF07XG4gICAgfSxcbiAgICBkcmF3OiBmdW5jdGlvbiBkcmF3KGNvbnRleHQsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQsIGNvcm5lclJhZGl1cywgcnMpIHtcbiAgICAgIHRoaXMucmVuZGVyZXIubm9kZVNoYXBlSW1wbCgncm91bmQtcG9seWdvbicsIGNvbnRleHQsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQsIHRoaXMucG9pbnRzLCB0aGlzLmdldE9yQ3JlYXRlQ29ybmVycyhjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0LCBjb3JuZXJSYWRpdXMsIHJzLCAnZHJhd0Nvcm5lcnMnKSk7XG4gICAgfSxcbiAgICBpbnRlcnNlY3RMaW5lOiBmdW5jdGlvbiBpbnRlcnNlY3RMaW5lKG5vZGVYLCBub2RlWSwgd2lkdGgsIGhlaWdodCwgeCwgeSwgcGFkZGluZywgY29ybmVyUmFkaXVzLCBycykge1xuICAgICAgcmV0dXJuIHJvdW5kUG9seWdvbkludGVyc2VjdExpbmUoeCwgeSwgdGhpcy5wb2ludHMsIG5vZGVYLCBub2RlWSwgd2lkdGgsIGhlaWdodCwgcGFkZGluZywgdGhpcy5nZXRPckNyZWF0ZUNvcm5lcnMobm9kZVgsIG5vZGVZLCB3aWR0aCwgaGVpZ2h0LCBjb3JuZXJSYWRpdXMsIHJzLCAnY29ybmVycycpKTtcbiAgICB9LFxuICAgIGNoZWNrUG9pbnQ6IGZ1bmN0aW9uIGNoZWNrUG9pbnQoeCwgeSwgcGFkZGluZywgd2lkdGgsIGhlaWdodCwgY2VudGVyWCwgY2VudGVyWSwgY29ybmVyUmFkaXVzLCBycykge1xuICAgICAgcmV0dXJuIHBvaW50SW5zaWRlUm91bmRQb2x5Z29uKHgsIHksIHRoaXMucG9pbnRzLCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0LCB0aGlzLmdldE9yQ3JlYXRlQ29ybmVycyhjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0LCBjb3JuZXJSYWRpdXMsIHJzLCAnY29ybmVycycpKTtcbiAgICB9XG4gIH07XG59O1xuQlJwJDIuZ2VuZXJhdGVSb3VuZFJlY3RhbmdsZSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMubm9kZVNoYXBlc1sncm91bmQtcmVjdGFuZ2xlJ10gPSB0aGlzLm5vZGVTaGFwZXNbJ3JvdW5kcmVjdGFuZ2xlJ10gPSB7XG4gICAgcmVuZGVyZXI6IHRoaXMsXG4gICAgbmFtZTogJ3JvdW5kLXJlY3RhbmdsZScsXG4gICAgcG9pbnRzOiBnZW5lcmF0ZVVuaXROZ29uUG9pbnRzRml0VG9TcXVhcmUoNCwgMCksXG4gICAgZHJhdzogZnVuY3Rpb24gZHJhdyhjb250ZXh0LCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0LCBjb3JuZXJSYWRpdXMpIHtcbiAgICAgIHRoaXMucmVuZGVyZXIubm9kZVNoYXBlSW1wbCh0aGlzLm5hbWUsIGNvbnRleHQsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQsIHRoaXMucG9pbnRzLCBjb3JuZXJSYWRpdXMpO1xuICAgIH0sXG4gICAgaW50ZXJzZWN0TGluZTogZnVuY3Rpb24gaW50ZXJzZWN0TGluZShub2RlWCwgbm9kZVksIHdpZHRoLCBoZWlnaHQsIHgsIHksIHBhZGRpbmcsIGNvcm5lclJhZGl1cykge1xuICAgICAgcmV0dXJuIHJvdW5kUmVjdGFuZ2xlSW50ZXJzZWN0TGluZSh4LCB5LCBub2RlWCwgbm9kZVksIHdpZHRoLCBoZWlnaHQsIHBhZGRpbmcsIGNvcm5lclJhZGl1cyk7XG4gICAgfSxcbiAgICBjaGVja1BvaW50OiBmdW5jdGlvbiBjaGVja1BvaW50KHgsIHksIHBhZGRpbmcsIHdpZHRoLCBoZWlnaHQsIGNlbnRlclgsIGNlbnRlclksIGNvcm5lclJhZGl1cykge1xuICAgICAgdmFyIGhhbGZXaWR0aCA9IHdpZHRoIC8gMjtcbiAgICAgIHZhciBoYWxmSGVpZ2h0ID0gaGVpZ2h0IC8gMjtcbiAgICAgIGNvcm5lclJhZGl1cyA9IGNvcm5lclJhZGl1cyA9PT0gJ2F1dG8nID8gZ2V0Um91bmRSZWN0YW5nbGVSYWRpdXMod2lkdGgsIGhlaWdodCkgOiBjb3JuZXJSYWRpdXM7XG4gICAgICBjb3JuZXJSYWRpdXMgPSBNYXRoLm1pbihoYWxmV2lkdGgsIGhhbGZIZWlnaHQsIGNvcm5lclJhZGl1cyk7XG4gICAgICB2YXIgZGlhbSA9IGNvcm5lclJhZGl1cyAqIDI7XG5cbiAgICAgIC8vIENoZWNrIGhCb3hcbiAgICAgIGlmIChwb2ludEluc2lkZVBvbHlnb24oeCwgeSwgdGhpcy5wb2ludHMsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQgLSBkaWFtLCBbMCwgLTFdLCBwYWRkaW5nKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLy8gQ2hlY2sgdkJveFxuICAgICAgaWYgKHBvaW50SW5zaWRlUG9seWdvbih4LCB5LCB0aGlzLnBvaW50cywgY2VudGVyWCwgY2VudGVyWSwgd2lkdGggLSBkaWFtLCBoZWlnaHQsIFswLCAtMV0sIHBhZGRpbmcpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBDaGVjayB0b3AgbGVmdCBxdWFydGVyIGNpcmNsZVxuICAgICAgaWYgKGNoZWNrSW5FbGxpcHNlKHgsIHksIGRpYW0sIGRpYW0sIGNlbnRlclggLSBoYWxmV2lkdGggKyBjb3JuZXJSYWRpdXMsIGNlbnRlclkgLSBoYWxmSGVpZ2h0ICsgY29ybmVyUmFkaXVzLCBwYWRkaW5nKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLy8gQ2hlY2sgdG9wIHJpZ2h0IHF1YXJ0ZXIgY2lyY2xlXG4gICAgICBpZiAoY2hlY2tJbkVsbGlwc2UoeCwgeSwgZGlhbSwgZGlhbSwgY2VudGVyWCArIGhhbGZXaWR0aCAtIGNvcm5lclJhZGl1cywgY2VudGVyWSAtIGhhbGZIZWlnaHQgKyBjb3JuZXJSYWRpdXMsIHBhZGRpbmcpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBDaGVjayBib3R0b20gcmlnaHQgcXVhcnRlciBjaXJjbGVcbiAgICAgIGlmIChjaGVja0luRWxsaXBzZSh4LCB5LCBkaWFtLCBkaWFtLCBjZW50ZXJYICsgaGFsZldpZHRoIC0gY29ybmVyUmFkaXVzLCBjZW50ZXJZICsgaGFsZkhlaWdodCAtIGNvcm5lclJhZGl1cywgcGFkZGluZykpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIC8vIENoZWNrIGJvdHRvbSBsZWZ0IHF1YXJ0ZXIgY2lyY2xlXG4gICAgICBpZiAoY2hlY2tJbkVsbGlwc2UoeCwgeSwgZGlhbSwgZGlhbSwgY2VudGVyWCAtIGhhbGZXaWR0aCArIGNvcm5lclJhZGl1cywgY2VudGVyWSArIGhhbGZIZWlnaHQgLSBjb3JuZXJSYWRpdXMsIHBhZGRpbmcpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfTtcbn07XG5CUnAkMi5nZW5lcmF0ZUN1dFJlY3RhbmdsZSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMubm9kZVNoYXBlc1snY3V0LXJlY3RhbmdsZSddID0gdGhpcy5ub2RlU2hhcGVzWydjdXRyZWN0YW5nbGUnXSA9IHtcbiAgICByZW5kZXJlcjogdGhpcyxcbiAgICBuYW1lOiAnY3V0LXJlY3RhbmdsZScsXG4gICAgY29ybmVyTGVuZ3RoOiBnZXRDdXRSZWN0YW5nbGVDb3JuZXJMZW5ndGgoKSxcbiAgICBwb2ludHM6IGdlbmVyYXRlVW5pdE5nb25Qb2ludHNGaXRUb1NxdWFyZSg0LCAwKSxcbiAgICBkcmF3OiBmdW5jdGlvbiBkcmF3KGNvbnRleHQsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQsIGNvcm5lclJhZGl1cykge1xuICAgICAgdGhpcy5yZW5kZXJlci5ub2RlU2hhcGVJbXBsKHRoaXMubmFtZSwgY29udGV4dCwgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCwgbnVsbCwgY29ybmVyUmFkaXVzKTtcbiAgICB9LFxuICAgIGdlbmVyYXRlQ3V0VHJpYW5nbGVQdHM6IGZ1bmN0aW9uIGdlbmVyYXRlQ3V0VHJpYW5nbGVQdHMod2lkdGgsIGhlaWdodCwgY2VudGVyWCwgY2VudGVyWSwgY29ybmVyUmFkaXVzKSB7XG4gICAgICB2YXIgY2wgPSBjb3JuZXJSYWRpdXMgPT09ICdhdXRvJyA/IHRoaXMuY29ybmVyTGVuZ3RoIDogY29ybmVyUmFkaXVzO1xuICAgICAgdmFyIGhoID0gaGVpZ2h0IC8gMjtcbiAgICAgIHZhciBodyA9IHdpZHRoIC8gMjtcbiAgICAgIHZhciB4QmVnaW4gPSBjZW50ZXJYIC0gaHc7XG4gICAgICB2YXIgeEVuZCA9IGNlbnRlclggKyBodztcbiAgICAgIHZhciB5QmVnaW4gPSBjZW50ZXJZIC0gaGg7XG4gICAgICB2YXIgeUVuZCA9IGNlbnRlclkgKyBoaDtcblxuICAgICAgLy8gcG9pbnRzIGFyZSBpbiBjbG9ja3dpc2Ugb3JkZXIsIGlubmVyIChpbWFnaW5hcnkpIHRyaWFuZ2xlIHB0IG9uIFs0LCA1XVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdG9wTGVmdDogW3hCZWdpbiwgeUJlZ2luICsgY2wsIHhCZWdpbiArIGNsLCB5QmVnaW4sIHhCZWdpbiArIGNsLCB5QmVnaW4gKyBjbF0sXG4gICAgICAgIHRvcFJpZ2h0OiBbeEVuZCAtIGNsLCB5QmVnaW4sIHhFbmQsIHlCZWdpbiArIGNsLCB4RW5kIC0gY2wsIHlCZWdpbiArIGNsXSxcbiAgICAgICAgYm90dG9tUmlnaHQ6IFt4RW5kLCB5RW5kIC0gY2wsIHhFbmQgLSBjbCwgeUVuZCwgeEVuZCAtIGNsLCB5RW5kIC0gY2xdLFxuICAgICAgICBib3R0b21MZWZ0OiBbeEJlZ2luICsgY2wsIHlFbmQsIHhCZWdpbiwgeUVuZCAtIGNsLCB4QmVnaW4gKyBjbCwgeUVuZCAtIGNsXVxuICAgICAgfTtcbiAgICB9LFxuICAgIGludGVyc2VjdExpbmU6IGZ1bmN0aW9uIGludGVyc2VjdExpbmUobm9kZVgsIG5vZGVZLCB3aWR0aCwgaGVpZ2h0LCB4LCB5LCBwYWRkaW5nLCBjb3JuZXJSYWRpdXMpIHtcbiAgICAgIHZhciBjUHRzID0gdGhpcy5nZW5lcmF0ZUN1dFRyaWFuZ2xlUHRzKHdpZHRoICsgMiAqIHBhZGRpbmcsIGhlaWdodCArIDIgKiBwYWRkaW5nLCBub2RlWCwgbm9kZVksIGNvcm5lclJhZGl1cyk7XG4gICAgICB2YXIgcHRzID0gW10uY29uY2F0LmFwcGx5KFtdLCBbY1B0cy50b3BMZWZ0LnNwbGljZSgwLCA0KSwgY1B0cy50b3BSaWdodC5zcGxpY2UoMCwgNCksIGNQdHMuYm90dG9tUmlnaHQuc3BsaWNlKDAsIDQpLCBjUHRzLmJvdHRvbUxlZnQuc3BsaWNlKDAsIDQpXSk7XG4gICAgICByZXR1cm4gcG9seWdvbkludGVyc2VjdExpbmUoeCwgeSwgcHRzLCBub2RlWCwgbm9kZVkpO1xuICAgIH0sXG4gICAgY2hlY2tQb2ludDogZnVuY3Rpb24gY2hlY2tQb2ludCh4LCB5LCBwYWRkaW5nLCB3aWR0aCwgaGVpZ2h0LCBjZW50ZXJYLCBjZW50ZXJZLCBjb3JuZXJSYWRpdXMpIHtcbiAgICAgIHZhciBjbCA9IGNvcm5lclJhZGl1cyA9PT0gJ2F1dG8nID8gdGhpcy5jb3JuZXJMZW5ndGggOiBjb3JuZXJSYWRpdXM7XG4gICAgICAvLyBDaGVjayBoQm94XG4gICAgICBpZiAocG9pbnRJbnNpZGVQb2x5Z29uKHgsIHksIHRoaXMucG9pbnRzLCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0IC0gMiAqIGNsLCBbMCwgLTFdLCBwYWRkaW5nKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLy8gQ2hlY2sgdkJveFxuICAgICAgaWYgKHBvaW50SW5zaWRlUG9seWdvbih4LCB5LCB0aGlzLnBvaW50cywgY2VudGVyWCwgY2VudGVyWSwgd2lkdGggLSAyICogY2wsIGhlaWdodCwgWzAsIC0xXSwgcGFkZGluZykpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICB2YXIgY3V0VHJpYW5nbGVQdHMgPSB0aGlzLmdlbmVyYXRlQ3V0VHJpYW5nbGVQdHMod2lkdGgsIGhlaWdodCwgY2VudGVyWCwgY2VudGVyWSk7XG4gICAgICByZXR1cm4gcG9pbnRJbnNpZGVQb2x5Z29uUG9pbnRzKHgsIHksIGN1dFRyaWFuZ2xlUHRzLnRvcExlZnQpIHx8IHBvaW50SW5zaWRlUG9seWdvblBvaW50cyh4LCB5LCBjdXRUcmlhbmdsZVB0cy50b3BSaWdodCkgfHwgcG9pbnRJbnNpZGVQb2x5Z29uUG9pbnRzKHgsIHksIGN1dFRyaWFuZ2xlUHRzLmJvdHRvbVJpZ2h0KSB8fCBwb2ludEluc2lkZVBvbHlnb25Qb2ludHMoeCwgeSwgY3V0VHJpYW5nbGVQdHMuYm90dG9tTGVmdCk7XG4gICAgfVxuICB9O1xufTtcbkJScCQyLmdlbmVyYXRlQmFycmVsID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5ub2RlU2hhcGVzWydiYXJyZWwnXSA9IHtcbiAgICByZW5kZXJlcjogdGhpcyxcbiAgICBuYW1lOiAnYmFycmVsJyxcbiAgICBwb2ludHM6IGdlbmVyYXRlVW5pdE5nb25Qb2ludHNGaXRUb1NxdWFyZSg0LCAwKSxcbiAgICBkcmF3OiBmdW5jdGlvbiBkcmF3KGNvbnRleHQsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQsIGNvcm5lclJhZGl1cykge1xuICAgICAgdGhpcy5yZW5kZXJlci5ub2RlU2hhcGVJbXBsKHRoaXMubmFtZSwgY29udGV4dCwgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCk7XG4gICAgfSxcbiAgICBpbnRlcnNlY3RMaW5lOiBmdW5jdGlvbiBpbnRlcnNlY3RMaW5lKG5vZGVYLCBub2RlWSwgd2lkdGgsIGhlaWdodCwgeCwgeSwgcGFkZGluZywgY29ybmVyUmFkaXVzKSB7XG4gICAgICAvLyB1c2UgdHdvIGZpeGVkIHQgdmFsdWVzIGZvciB0aGUgYmV6aWVyIGN1cnZlIGFwcHJveGltYXRpb25cblxuICAgICAgdmFyIHQwID0gMC4xNTtcbiAgICAgIHZhciB0MSA9IDAuNTtcbiAgICAgIHZhciB0MiA9IDAuODU7XG4gICAgICB2YXIgYlB0cyA9IHRoaXMuZ2VuZXJhdGVCYXJyZWxCZXppZXJQdHMod2lkdGggKyAyICogcGFkZGluZywgaGVpZ2h0ICsgMiAqIHBhZGRpbmcsIG5vZGVYLCBub2RlWSk7XG4gICAgICB2YXIgYXBwcm94aW1hdGVCYXJyZWxDdXJ2ZVB0cyA9IGZ1bmN0aW9uIGFwcHJveGltYXRlQmFycmVsQ3VydmVQdHMocHRzKSB7XG4gICAgICAgIC8vIGFwcHJveGltYXRlIGN1cnZlIHB0cyBiYXNlZCBvbiB0aGUgdHdvIHQgdmFsdWVzXG4gICAgICAgIHZhciBtMCA9IHFiZXppZXJQdEF0KHtcbiAgICAgICAgICB4OiBwdHNbMF0sXG4gICAgICAgICAgeTogcHRzWzFdXG4gICAgICAgIH0sIHtcbiAgICAgICAgICB4OiBwdHNbMl0sXG4gICAgICAgICAgeTogcHRzWzNdXG4gICAgICAgIH0sIHtcbiAgICAgICAgICB4OiBwdHNbNF0sXG4gICAgICAgICAgeTogcHRzWzVdXG4gICAgICAgIH0sIHQwKTtcbiAgICAgICAgdmFyIG0xID0gcWJlemllclB0QXQoe1xuICAgICAgICAgIHg6IHB0c1swXSxcbiAgICAgICAgICB5OiBwdHNbMV1cbiAgICAgICAgfSwge1xuICAgICAgICAgIHg6IHB0c1syXSxcbiAgICAgICAgICB5OiBwdHNbM11cbiAgICAgICAgfSwge1xuICAgICAgICAgIHg6IHB0c1s0XSxcbiAgICAgICAgICB5OiBwdHNbNV1cbiAgICAgICAgfSwgdDEpO1xuICAgICAgICB2YXIgbTIgPSBxYmV6aWVyUHRBdCh7XG4gICAgICAgICAgeDogcHRzWzBdLFxuICAgICAgICAgIHk6IHB0c1sxXVxuICAgICAgICB9LCB7XG4gICAgICAgICAgeDogcHRzWzJdLFxuICAgICAgICAgIHk6IHB0c1szXVxuICAgICAgICB9LCB7XG4gICAgICAgICAgeDogcHRzWzRdLFxuICAgICAgICAgIHk6IHB0c1s1XVxuICAgICAgICB9LCB0Mik7XG4gICAgICAgIHJldHVybiBbcHRzWzBdLCBwdHNbMV0sIG0wLngsIG0wLnksIG0xLngsIG0xLnksIG0yLngsIG0yLnksIHB0c1s0XSwgcHRzWzVdXTtcbiAgICAgIH07XG4gICAgICB2YXIgcHRzID0gW10uY29uY2F0KGFwcHJveGltYXRlQmFycmVsQ3VydmVQdHMoYlB0cy50b3BMZWZ0KSwgYXBwcm94aW1hdGVCYXJyZWxDdXJ2ZVB0cyhiUHRzLnRvcFJpZ2h0KSwgYXBwcm94aW1hdGVCYXJyZWxDdXJ2ZVB0cyhiUHRzLmJvdHRvbVJpZ2h0KSwgYXBwcm94aW1hdGVCYXJyZWxDdXJ2ZVB0cyhiUHRzLmJvdHRvbUxlZnQpKTtcbiAgICAgIHJldHVybiBwb2x5Z29uSW50ZXJzZWN0TGluZSh4LCB5LCBwdHMsIG5vZGVYLCBub2RlWSk7XG4gICAgfSxcbiAgICBnZW5lcmF0ZUJhcnJlbEJlemllclB0czogZnVuY3Rpb24gZ2VuZXJhdGVCYXJyZWxCZXppZXJQdHMod2lkdGgsIGhlaWdodCwgY2VudGVyWCwgY2VudGVyWSkge1xuICAgICAgdmFyIGhoID0gaGVpZ2h0IC8gMjtcbiAgICAgIHZhciBodyA9IHdpZHRoIC8gMjtcbiAgICAgIHZhciB4QmVnaW4gPSBjZW50ZXJYIC0gaHc7XG4gICAgICB2YXIgeEVuZCA9IGNlbnRlclggKyBodztcbiAgICAgIHZhciB5QmVnaW4gPSBjZW50ZXJZIC0gaGg7XG4gICAgICB2YXIgeUVuZCA9IGNlbnRlclkgKyBoaDtcbiAgICAgIHZhciBjdXJ2ZUNvbnN0YW50cyA9IGdldEJhcnJlbEN1cnZlQ29uc3RhbnRzKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgdmFyIGhPZmZzZXQgPSBjdXJ2ZUNvbnN0YW50cy5oZWlnaHRPZmZzZXQ7XG4gICAgICB2YXIgd09mZnNldCA9IGN1cnZlQ29uc3RhbnRzLndpZHRoT2Zmc2V0O1xuICAgICAgdmFyIGN0cmxQdFhPZmZzZXQgPSBjdXJ2ZUNvbnN0YW50cy5jdHJsUHRPZmZzZXRQY3QgKiB3aWR0aDtcblxuICAgICAgLy8gcG9pbnRzIGFyZSBpbiBjbG9ja3dpc2Ugb3JkZXIsIGlubmVyIChpbWFnaW5hcnkpIGNvbnRyb2wgcHQgb24gWzQsIDVdXG4gICAgICB2YXIgcHRzID0ge1xuICAgICAgICB0b3BMZWZ0OiBbeEJlZ2luLCB5QmVnaW4gKyBoT2Zmc2V0LCB4QmVnaW4gKyBjdHJsUHRYT2Zmc2V0LCB5QmVnaW4sIHhCZWdpbiArIHdPZmZzZXQsIHlCZWdpbl0sXG4gICAgICAgIHRvcFJpZ2h0OiBbeEVuZCAtIHdPZmZzZXQsIHlCZWdpbiwgeEVuZCAtIGN0cmxQdFhPZmZzZXQsIHlCZWdpbiwgeEVuZCwgeUJlZ2luICsgaE9mZnNldF0sXG4gICAgICAgIGJvdHRvbVJpZ2h0OiBbeEVuZCwgeUVuZCAtIGhPZmZzZXQsIHhFbmQgLSBjdHJsUHRYT2Zmc2V0LCB5RW5kLCB4RW5kIC0gd09mZnNldCwgeUVuZF0sXG4gICAgICAgIGJvdHRvbUxlZnQ6IFt4QmVnaW4gKyB3T2Zmc2V0LCB5RW5kLCB4QmVnaW4gKyBjdHJsUHRYT2Zmc2V0LCB5RW5kLCB4QmVnaW4sIHlFbmQgLSBoT2Zmc2V0XVxuICAgICAgfTtcbiAgICAgIHB0cy50b3BMZWZ0LmlzVG9wID0gdHJ1ZTtcbiAgICAgIHB0cy50b3BSaWdodC5pc1RvcCA9IHRydWU7XG4gICAgICBwdHMuYm90dG9tTGVmdC5pc0JvdHRvbSA9IHRydWU7XG4gICAgICBwdHMuYm90dG9tUmlnaHQuaXNCb3R0b20gPSB0cnVlO1xuICAgICAgcmV0dXJuIHB0cztcbiAgICB9LFxuICAgIGNoZWNrUG9pbnQ6IGZ1bmN0aW9uIGNoZWNrUG9pbnQoeCwgeSwgcGFkZGluZywgd2lkdGgsIGhlaWdodCwgY2VudGVyWCwgY2VudGVyWSwgY29ybmVyUmFkaXVzKSB7XG4gICAgICB2YXIgY3VydmVDb25zdGFudHMgPSBnZXRCYXJyZWxDdXJ2ZUNvbnN0YW50cyh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIHZhciBoT2Zmc2V0ID0gY3VydmVDb25zdGFudHMuaGVpZ2h0T2Zmc2V0O1xuICAgICAgdmFyIHdPZmZzZXQgPSBjdXJ2ZUNvbnN0YW50cy53aWR0aE9mZnNldDtcblxuICAgICAgLy8gQ2hlY2sgaEJveFxuICAgICAgaWYgKHBvaW50SW5zaWRlUG9seWdvbih4LCB5LCB0aGlzLnBvaW50cywgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCAtIDIgKiBoT2Zmc2V0LCBbMCwgLTFdLCBwYWRkaW5nKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLy8gQ2hlY2sgdkJveFxuICAgICAgaWYgKHBvaW50SW5zaWRlUG9seWdvbih4LCB5LCB0aGlzLnBvaW50cywgY2VudGVyWCwgY2VudGVyWSwgd2lkdGggLSAyICogd09mZnNldCwgaGVpZ2h0LCBbMCwgLTFdLCBwYWRkaW5nKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHZhciBiYXJyZWxDdXJ2ZVB0cyA9IHRoaXMuZ2VuZXJhdGVCYXJyZWxCZXppZXJQdHMod2lkdGgsIGhlaWdodCwgY2VudGVyWCwgY2VudGVyWSk7XG4gICAgICB2YXIgZ2V0Q3VydmVUID0gZnVuY3Rpb24gZ2V0Q3VydmVUKHgsIHksIGN1cnZlUHRzKSB7XG4gICAgICAgIHZhciB4MCA9IGN1cnZlUHRzWzRdO1xuICAgICAgICB2YXIgeDEgPSBjdXJ2ZVB0c1syXTtcbiAgICAgICAgdmFyIHgyID0gY3VydmVQdHNbMF07XG4gICAgICAgIHZhciB5MCA9IGN1cnZlUHRzWzVdO1xuICAgICAgICAvLyB2YXIgeTEgPSBjdXJ2ZVB0c1sgMyBdO1xuICAgICAgICB2YXIgeTIgPSBjdXJ2ZVB0c1sxXTtcbiAgICAgICAgdmFyIHhNaW4gPSBNYXRoLm1pbih4MCwgeDIpO1xuICAgICAgICB2YXIgeE1heCA9IE1hdGgubWF4KHgwLCB4Mik7XG4gICAgICAgIHZhciB5TWluID0gTWF0aC5taW4oeTAsIHkyKTtcbiAgICAgICAgdmFyIHlNYXggPSBNYXRoLm1heCh5MCwgeTIpO1xuICAgICAgICBpZiAoeE1pbiA8PSB4ICYmIHggPD0geE1heCAmJiB5TWluIDw9IHkgJiYgeSA8PSB5TWF4KSB7XG4gICAgICAgICAgdmFyIGNvZWZmID0gYmV6aWVyUHRzVG9RdWFkQ29lZmYoeDAsIHgxLCB4Mik7XG4gICAgICAgICAgdmFyIHJvb3RzID0gc29sdmVRdWFkcmF0aWMoY29lZmZbMF0sIGNvZWZmWzFdLCBjb2VmZlsyXSwgeCk7XG4gICAgICAgICAgdmFyIHZhbGlkUm9vdHMgPSByb290cy5maWx0ZXIoZnVuY3Rpb24gKHIpIHtcbiAgICAgICAgICAgIHJldHVybiAwIDw9IHIgJiYgciA8PSAxO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmICh2YWxpZFJvb3RzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiB2YWxpZFJvb3RzWzBdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH07XG4gICAgICB2YXIgY3VydmVSZWdpb25zID0gT2JqZWN0LmtleXMoYmFycmVsQ3VydmVQdHMpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjdXJ2ZVJlZ2lvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNvcm5lciA9IGN1cnZlUmVnaW9uc1tpXTtcbiAgICAgICAgdmFyIGNvcm5lclB0cyA9IGJhcnJlbEN1cnZlUHRzW2Nvcm5lcl07XG4gICAgICAgIHZhciB0ID0gZ2V0Q3VydmVUKHgsIHksIGNvcm5lclB0cyk7XG4gICAgICAgIGlmICh0ID09IG51bGwpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgeTAgPSBjb3JuZXJQdHNbNV07XG4gICAgICAgIHZhciB5MSA9IGNvcm5lclB0c1szXTtcbiAgICAgICAgdmFyIHkyID0gY29ybmVyUHRzWzFdO1xuICAgICAgICB2YXIgYmV6WSA9IHFiZXppZXJBdCh5MCwgeTEsIHkyLCB0KTtcbiAgICAgICAgaWYgKGNvcm5lclB0cy5pc1RvcCAmJiBiZXpZIDw9IHkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29ybmVyUHRzLmlzQm90dG9tICYmIHkgPD0gYmV6WSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9O1xufTtcbkJScCQyLmdlbmVyYXRlQm90dG9tUm91bmRyZWN0YW5nbGUgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLm5vZGVTaGFwZXNbJ2JvdHRvbS1yb3VuZC1yZWN0YW5nbGUnXSA9IHRoaXMubm9kZVNoYXBlc1snYm90dG9tcm91bmRyZWN0YW5nbGUnXSA9IHtcbiAgICByZW5kZXJlcjogdGhpcyxcbiAgICBuYW1lOiAnYm90dG9tLXJvdW5kLXJlY3RhbmdsZScsXG4gICAgcG9pbnRzOiBnZW5lcmF0ZVVuaXROZ29uUG9pbnRzRml0VG9TcXVhcmUoNCwgMCksXG4gICAgZHJhdzogZnVuY3Rpb24gZHJhdyhjb250ZXh0LCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0LCBjb3JuZXJSYWRpdXMpIHtcbiAgICAgIHRoaXMucmVuZGVyZXIubm9kZVNoYXBlSW1wbCh0aGlzLm5hbWUsIGNvbnRleHQsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQsIHRoaXMucG9pbnRzLCBjb3JuZXJSYWRpdXMpO1xuICAgIH0sXG4gICAgaW50ZXJzZWN0TGluZTogZnVuY3Rpb24gaW50ZXJzZWN0TGluZShub2RlWCwgbm9kZVksIHdpZHRoLCBoZWlnaHQsIHgsIHksIHBhZGRpbmcsIGNvcm5lclJhZGl1cykge1xuICAgICAgdmFyIHRvcFN0YXJ0WCA9IG5vZGVYIC0gKHdpZHRoIC8gMiArIHBhZGRpbmcpO1xuICAgICAgdmFyIHRvcFN0YXJ0WSA9IG5vZGVZIC0gKGhlaWdodCAvIDIgKyBwYWRkaW5nKTtcbiAgICAgIHZhciB0b3BFbmRZID0gdG9wU3RhcnRZO1xuICAgICAgdmFyIHRvcEVuZFggPSBub2RlWCArICh3aWR0aCAvIDIgKyBwYWRkaW5nKTtcbiAgICAgIHZhciB0b3BJbnRlcnNlY3Rpb25zID0gZmluaXRlTGluZXNJbnRlcnNlY3QoeCwgeSwgbm9kZVgsIG5vZGVZLCB0b3BTdGFydFgsIHRvcFN0YXJ0WSwgdG9wRW5kWCwgdG9wRW5kWSwgZmFsc2UpO1xuICAgICAgaWYgKHRvcEludGVyc2VjdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgICByZXR1cm4gdG9wSW50ZXJzZWN0aW9ucztcbiAgICAgIH1cbiAgICAgIHJldHVybiByb3VuZFJlY3RhbmdsZUludGVyc2VjdExpbmUoeCwgeSwgbm9kZVgsIG5vZGVZLCB3aWR0aCwgaGVpZ2h0LCBwYWRkaW5nLCBjb3JuZXJSYWRpdXMpO1xuICAgIH0sXG4gICAgY2hlY2tQb2ludDogZnVuY3Rpb24gY2hlY2tQb2ludCh4LCB5LCBwYWRkaW5nLCB3aWR0aCwgaGVpZ2h0LCBjZW50ZXJYLCBjZW50ZXJZLCBjb3JuZXJSYWRpdXMpIHtcbiAgICAgIGNvcm5lclJhZGl1cyA9IGNvcm5lclJhZGl1cyA9PT0gJ2F1dG8nID8gZ2V0Um91bmRSZWN0YW5nbGVSYWRpdXMod2lkdGgsIGhlaWdodCkgOiBjb3JuZXJSYWRpdXM7XG4gICAgICB2YXIgZGlhbSA9IDIgKiBjb3JuZXJSYWRpdXM7XG5cbiAgICAgIC8vIENoZWNrIGhCb3hcbiAgICAgIGlmIChwb2ludEluc2lkZVBvbHlnb24oeCwgeSwgdGhpcy5wb2ludHMsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQgLSBkaWFtLCBbMCwgLTFdLCBwYWRkaW5nKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLy8gQ2hlY2sgdkJveFxuICAgICAgaWYgKHBvaW50SW5zaWRlUG9seWdvbih4LCB5LCB0aGlzLnBvaW50cywgY2VudGVyWCwgY2VudGVyWSwgd2lkdGggLSBkaWFtLCBoZWlnaHQsIFswLCAtMV0sIHBhZGRpbmcpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBjaGVjayBub24tcm91bmRlZCB0b3Agc2lkZVxuICAgICAgdmFyIG91dGVyV2lkdGggPSB3aWR0aCAvIDIgKyAyICogcGFkZGluZztcbiAgICAgIHZhciBvdXRlckhlaWdodCA9IGhlaWdodCAvIDIgKyAyICogcGFkZGluZztcbiAgICAgIHZhciBwb2ludHMgPSBbY2VudGVyWCAtIG91dGVyV2lkdGgsIGNlbnRlclkgLSBvdXRlckhlaWdodCwgY2VudGVyWCAtIG91dGVyV2lkdGgsIGNlbnRlclksIGNlbnRlclggKyBvdXRlcldpZHRoLCBjZW50ZXJZLCBjZW50ZXJYICsgb3V0ZXJXaWR0aCwgY2VudGVyWSAtIG91dGVySGVpZ2h0XTtcbiAgICAgIGlmIChwb2ludEluc2lkZVBvbHlnb25Qb2ludHMoeCwgeSwgcG9pbnRzKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLy8gQ2hlY2sgYm90dG9tIHJpZ2h0IHF1YXJ0ZXIgY2lyY2xlXG4gICAgICBpZiAoY2hlY2tJbkVsbGlwc2UoeCwgeSwgZGlhbSwgZGlhbSwgY2VudGVyWCArIHdpZHRoIC8gMiAtIGNvcm5lclJhZGl1cywgY2VudGVyWSArIGhlaWdodCAvIDIgLSBjb3JuZXJSYWRpdXMsIHBhZGRpbmcpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBDaGVjayBib3R0b20gbGVmdCBxdWFydGVyIGNpcmNsZVxuICAgICAgaWYgKGNoZWNrSW5FbGxpcHNlKHgsIHksIGRpYW0sIGRpYW0sIGNlbnRlclggLSB3aWR0aCAvIDIgKyBjb3JuZXJSYWRpdXMsIGNlbnRlclkgKyBoZWlnaHQgLyAyIC0gY29ybmVyUmFkaXVzLCBwYWRkaW5nKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH07XG59O1xuQlJwJDIucmVnaXN0ZXJOb2RlU2hhcGVzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbm9kZVNoYXBlcyA9IHRoaXMubm9kZVNoYXBlcyA9IHt9O1xuICB2YXIgcmVuZGVyZXIgPSB0aGlzO1xuICB0aGlzLmdlbmVyYXRlRWxsaXBzZSgpO1xuICB0aGlzLmdlbmVyYXRlUG9seWdvbigndHJpYW5nbGUnLCBnZW5lcmF0ZVVuaXROZ29uUG9pbnRzRml0VG9TcXVhcmUoMywgMCkpO1xuICB0aGlzLmdlbmVyYXRlUm91bmRQb2x5Z29uKCdyb3VuZC10cmlhbmdsZScsIGdlbmVyYXRlVW5pdE5nb25Qb2ludHNGaXRUb1NxdWFyZSgzLCAwKSk7XG4gIHRoaXMuZ2VuZXJhdGVQb2x5Z29uKCdyZWN0YW5nbGUnLCBnZW5lcmF0ZVVuaXROZ29uUG9pbnRzRml0VG9TcXVhcmUoNCwgMCkpO1xuICBub2RlU2hhcGVzWydzcXVhcmUnXSA9IG5vZGVTaGFwZXNbJ3JlY3RhbmdsZSddO1xuICB0aGlzLmdlbmVyYXRlUm91bmRSZWN0YW5nbGUoKTtcbiAgdGhpcy5nZW5lcmF0ZUN1dFJlY3RhbmdsZSgpO1xuICB0aGlzLmdlbmVyYXRlQmFycmVsKCk7XG4gIHRoaXMuZ2VuZXJhdGVCb3R0b21Sb3VuZHJlY3RhbmdsZSgpO1xuICB7XG4gICAgdmFyIGRpYW1vbmRQb2ludHMgPSBbMCwgMSwgMSwgMCwgMCwgLTEsIC0xLCAwXTtcbiAgICB0aGlzLmdlbmVyYXRlUG9seWdvbignZGlhbW9uZCcsIGRpYW1vbmRQb2ludHMpO1xuICAgIHRoaXMuZ2VuZXJhdGVSb3VuZFBvbHlnb24oJ3JvdW5kLWRpYW1vbmQnLCBkaWFtb25kUG9pbnRzKTtcbiAgfVxuICB0aGlzLmdlbmVyYXRlUG9seWdvbigncGVudGFnb24nLCBnZW5lcmF0ZVVuaXROZ29uUG9pbnRzRml0VG9TcXVhcmUoNSwgMCkpO1xuICB0aGlzLmdlbmVyYXRlUm91bmRQb2x5Z29uKCdyb3VuZC1wZW50YWdvbicsIGdlbmVyYXRlVW5pdE5nb25Qb2ludHNGaXRUb1NxdWFyZSg1LCAwKSk7XG4gIHRoaXMuZ2VuZXJhdGVQb2x5Z29uKCdoZXhhZ29uJywgZ2VuZXJhdGVVbml0TmdvblBvaW50c0ZpdFRvU3F1YXJlKDYsIDApKTtcbiAgdGhpcy5nZW5lcmF0ZVJvdW5kUG9seWdvbigncm91bmQtaGV4YWdvbicsIGdlbmVyYXRlVW5pdE5nb25Qb2ludHNGaXRUb1NxdWFyZSg2LCAwKSk7XG4gIHRoaXMuZ2VuZXJhdGVQb2x5Z29uKCdoZXB0YWdvbicsIGdlbmVyYXRlVW5pdE5nb25Qb2ludHNGaXRUb1NxdWFyZSg3LCAwKSk7XG4gIHRoaXMuZ2VuZXJhdGVSb3VuZFBvbHlnb24oJ3JvdW5kLWhlcHRhZ29uJywgZ2VuZXJhdGVVbml0TmdvblBvaW50c0ZpdFRvU3F1YXJlKDcsIDApKTtcbiAgdGhpcy5nZW5lcmF0ZVBvbHlnb24oJ29jdGFnb24nLCBnZW5lcmF0ZVVuaXROZ29uUG9pbnRzRml0VG9TcXVhcmUoOCwgMCkpO1xuICB0aGlzLmdlbmVyYXRlUm91bmRQb2x5Z29uKCdyb3VuZC1vY3RhZ29uJywgZ2VuZXJhdGVVbml0TmdvblBvaW50c0ZpdFRvU3F1YXJlKDgsIDApKTtcbiAgdmFyIHN0YXI1UG9pbnRzID0gbmV3IEFycmF5KDIwKTtcbiAge1xuICAgIHZhciBvdXRlclBvaW50cyA9IGdlbmVyYXRlVW5pdE5nb25Qb2ludHMoNSwgMCk7XG4gICAgdmFyIGlubmVyUG9pbnRzID0gZ2VuZXJhdGVVbml0TmdvblBvaW50cyg1LCBNYXRoLlBJIC8gNSk7XG5cbiAgICAvLyBPdXRlciByYWRpdXMgaXMgMTsgaW5uZXIgcmFkaXVzIG9mIHN0YXIgaXMgc21hbGxlclxuICAgIHZhciBpbm5lclJhZGl1cyA9IDAuNSAqICgzIC0gTWF0aC5zcXJ0KDUpKTtcbiAgICBpbm5lclJhZGl1cyAqPSAxLjU3O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5uZXJQb2ludHMubGVuZ3RoIC8gMjsgaSsrKSB7XG4gICAgICBpbm5lclBvaW50c1tpICogMl0gKj0gaW5uZXJSYWRpdXM7XG4gICAgICBpbm5lclBvaW50c1tpICogMiArIDFdICo9IGlubmVyUmFkaXVzO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDIwIC8gNDsgaSsrKSB7XG4gICAgICBzdGFyNVBvaW50c1tpICogNF0gPSBvdXRlclBvaW50c1tpICogMl07XG4gICAgICBzdGFyNVBvaW50c1tpICogNCArIDFdID0gb3V0ZXJQb2ludHNbaSAqIDIgKyAxXTtcbiAgICAgIHN0YXI1UG9pbnRzW2kgKiA0ICsgMl0gPSBpbm5lclBvaW50c1tpICogMl07XG4gICAgICBzdGFyNVBvaW50c1tpICogNCArIDNdID0gaW5uZXJQb2ludHNbaSAqIDIgKyAxXTtcbiAgICB9XG4gIH1cbiAgc3RhcjVQb2ludHMgPSBmaXRQb2x5Z29uVG9TcXVhcmUoc3RhcjVQb2ludHMpO1xuICB0aGlzLmdlbmVyYXRlUG9seWdvbignc3RhcicsIHN0YXI1UG9pbnRzKTtcbiAgdGhpcy5nZW5lcmF0ZVBvbHlnb24oJ3ZlZScsIFstMSwgLTEsIDAsIC0wLjMzMywgMSwgLTEsIDAsIDFdKTtcbiAgdGhpcy5nZW5lcmF0ZVBvbHlnb24oJ3Job21ib2lkJywgWy0xLCAtMSwgMC4zMzMsIC0xLCAxLCAxLCAtMC4zMzMsIDFdKTtcbiAgdGhpcy5nZW5lcmF0ZVBvbHlnb24oJ3JpZ2h0LXJob21ib2lkJywgWy0wLjMzMywgLTEsIDEsIC0xLCAwLjMzMywgMSwgLTEsIDFdKTtcbiAgdGhpcy5ub2RlU2hhcGVzWydjb25jYXZlaGV4YWdvbiddID0gdGhpcy5nZW5lcmF0ZVBvbHlnb24oJ2NvbmNhdmUtaGV4YWdvbicsIFstMSwgLTAuOTUsIC0wLjc1LCAwLCAtMSwgMC45NSwgMSwgMC45NSwgMC43NSwgMCwgMSwgLTAuOTVdKTtcbiAge1xuICAgIHZhciB0YWdQb2ludHMgPSBbLTEsIC0xLCAwLjI1LCAtMSwgMSwgMCwgMC4yNSwgMSwgLTEsIDFdO1xuICAgIHRoaXMuZ2VuZXJhdGVQb2x5Z29uKCd0YWcnLCB0YWdQb2ludHMpO1xuICAgIHRoaXMuZ2VuZXJhdGVSb3VuZFBvbHlnb24oJ3JvdW5kLXRhZycsIHRhZ1BvaW50cyk7XG4gIH1cbiAgbm9kZVNoYXBlcy5tYWtlUG9seWdvbiA9IGZ1bmN0aW9uIChwb2ludHMpIHtcbiAgICAvLyB1c2UgY2FjaGluZyBvbiB1c2VyLXNwZWNpZmllZCBwb2x5Z29ucyBzbyB0aGV5IGFyZSBhcyBmYXN0IGFzIG5hdGl2ZSBzaGFwZXNcblxuICAgIHZhciBrZXkgPSBwb2ludHMuam9pbignJCcpO1xuICAgIHZhciBuYW1lID0gJ3BvbHlnb24tJyArIGtleTtcbiAgICB2YXIgc2hhcGU7XG4gICAgaWYgKHNoYXBlID0gdGhpc1tuYW1lXSkge1xuICAgICAgLy8gZ290IGNhY2hlZCBzaGFwZVxuICAgICAgcmV0dXJuIHNoYXBlO1xuICAgIH1cblxuICAgIC8vIGNyZWF0ZSBhbmQgY2FjaGUgbmV3IHNoYXBlXG4gICAgcmV0dXJuIHJlbmRlcmVyLmdlbmVyYXRlUG9seWdvbihuYW1lLCBwb2ludHMpO1xuICB9O1xufTtcblxudmFyIEJScCQxID0ge307XG5CUnAkMS50aW1lVG9SZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnJlZHJhd1RvdGFsVGltZSAvIHRoaXMucmVkcmF3Q291bnQ7XG59O1xuQlJwJDEucmVkcmF3ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgc3RhdGljRW1wdHlPYmplY3QoKTtcbiAgdmFyIHIgPSB0aGlzO1xuICBpZiAoci5hdmVyYWdlUmVkcmF3VGltZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgci5hdmVyYWdlUmVkcmF3VGltZSA9IDA7XG4gIH1cbiAgaWYgKHIubGFzdFJlZHJhd1RpbWUgPT09IHVuZGVmaW5lZCkge1xuICAgIHIubGFzdFJlZHJhd1RpbWUgPSAwO1xuICB9XG4gIGlmIChyLmxhc3REcmF3VGltZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgci5sYXN0RHJhd1RpbWUgPSAwO1xuICB9XG4gIHIucmVxdWVzdGVkRnJhbWUgPSB0cnVlO1xuICByLnJlbmRlck9wdGlvbnMgPSBvcHRpb25zO1xufTtcbkJScCQxLmJlZm9yZVJlbmRlciA9IGZ1bmN0aW9uIChmbiwgcHJpb3JpdHkpIHtcbiAgLy8gdGhlIHJlbmRlcmVyIGNhbid0IGFkZCB0aWNrIGNhbGxiYWNrcyB3aGVuIGRlc3Ryb3llZFxuICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHByaW9yaXR5ID09IG51bGwpIHtcbiAgICBlcnJvcignUHJpb3JpdHkgaXMgbm90IG9wdGlvbmFsIGZvciBiZWZvcmVSZW5kZXInKTtcbiAgfVxuICB2YXIgY2JzID0gdGhpcy5iZWZvcmVSZW5kZXJDYWxsYmFja3M7XG4gIGNicy5wdXNoKHtcbiAgICBmbjogZm4sXG4gICAgcHJpb3JpdHk6IHByaW9yaXR5XG4gIH0pO1xuXG4gIC8vIGhpZ2hlciBwcmlvcml0eSBjYWxsYmFja3MgZXhlY3V0ZWQgZmlyc3RcbiAgY2JzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gYi5wcmlvcml0eSAtIGEucHJpb3JpdHk7XG4gIH0pO1xufTtcbnZhciBiZWZvcmVSZW5kZXJDYWxsYmFja3MgPSBmdW5jdGlvbiBiZWZvcmVSZW5kZXJDYWxsYmFja3Mociwgd2lsbERyYXcsIHN0YXJ0VGltZSkge1xuICB2YXIgY2JzID0gci5iZWZvcmVSZW5kZXJDYWxsYmFja3M7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2JzLmxlbmd0aDsgaSsrKSB7XG4gICAgY2JzW2ldLmZuKHdpbGxEcmF3LCBzdGFydFRpbWUpO1xuICB9XG59O1xuQlJwJDEuc3RhcnRSZW5kZXJMb29wID0gZnVuY3Rpb24gKCkge1xuICB2YXIgciA9IHRoaXM7XG4gIHZhciBjeSA9IHIuY3k7XG4gIGlmIChyLnJlbmRlckxvb3BTdGFydGVkKSB7XG4gICAgcmV0dXJuO1xuICB9IGVsc2Uge1xuICAgIHIucmVuZGVyTG9vcFN0YXJ0ZWQgPSB0cnVlO1xuICB9XG4gIHZhciByZW5kZXJGbiA9IGZ1bmN0aW9uIHJlbmRlckZuKHJlcXVlc3RUaW1lKSB7XG4gICAgaWYgKHIuZGVzdHJveWVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChjeS5iYXRjaGluZygpKSA7IGVsc2UgaWYgKHIucmVxdWVzdGVkRnJhbWUgJiYgIXIuc2tpcEZyYW1lKSB7XG4gICAgICBiZWZvcmVSZW5kZXJDYWxsYmFja3MociwgdHJ1ZSwgcmVxdWVzdFRpbWUpO1xuICAgICAgdmFyIHN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlTm93KCk7XG4gICAgICByLnJlbmRlcihyLnJlbmRlck9wdGlvbnMpO1xuICAgICAgdmFyIGVuZFRpbWUgPSByLmxhc3REcmF3VGltZSA9IHBlcmZvcm1hbmNlTm93KCk7XG4gICAgICBpZiAoci5hdmVyYWdlUmVkcmF3VGltZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHIuYXZlcmFnZVJlZHJhd1RpbWUgPSBlbmRUaW1lIC0gc3RhcnRUaW1lO1xuICAgICAgfVxuICAgICAgaWYgKHIucmVkcmF3Q291bnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByLnJlZHJhd0NvdW50ID0gMDtcbiAgICAgIH1cbiAgICAgIHIucmVkcmF3Q291bnQrKztcbiAgICAgIGlmIChyLnJlZHJhd1RvdGFsVGltZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHIucmVkcmF3VG90YWxUaW1lID0gMDtcbiAgICAgIH1cbiAgICAgIHZhciBkdXJhdGlvbiA9IGVuZFRpbWUgLSBzdGFydFRpbWU7XG4gICAgICByLnJlZHJhd1RvdGFsVGltZSArPSBkdXJhdGlvbjtcbiAgICAgIHIubGFzdFJlZHJhd1RpbWUgPSBkdXJhdGlvbjtcblxuICAgICAgLy8gdXNlIGEgd2VpZ2h0ZWQgYXZlcmFnZSB3aXRoIGEgYmlhcyBmcm9tIHRoZSBwcmV2aW91cyBhdmVyYWdlIHNvIHdlIGRvbid0IHNwaWtlIHNvIGVhc2lseVxuICAgICAgci5hdmVyYWdlUmVkcmF3VGltZSA9IHIuYXZlcmFnZVJlZHJhd1RpbWUgLyAyICsgZHVyYXRpb24gLyAyO1xuICAgICAgci5yZXF1ZXN0ZWRGcmFtZSA9IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICBiZWZvcmVSZW5kZXJDYWxsYmFja3MociwgZmFsc2UsIHJlcXVlc3RUaW1lKTtcbiAgICB9XG4gICAgci5za2lwRnJhbWUgPSBmYWxzZTtcbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUocmVuZGVyRm4pO1xuICB9O1xuICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUocmVuZGVyRm4pO1xufTtcblxudmFyIEJhc2VSZW5kZXJlciA9IGZ1bmN0aW9uIEJhc2VSZW5kZXJlcihvcHRpb25zKSB7XG4gIHRoaXMuaW5pdChvcHRpb25zKTtcbn07XG52YXIgQlIgPSBCYXNlUmVuZGVyZXI7XG52YXIgQlJwID0gQlIucHJvdG90eXBlO1xuQlJwLmNsaWVudEZ1bmN0aW9ucyA9IFsncmVkcmF3SGludCcsICdyZW5kZXInLCAncmVuZGVyVG8nLCAnbWF0Y2hDYW52YXNTaXplJywgJ25vZGVTaGFwZUltcGwnLCAnYXJyb3dTaGFwZUltcGwnXTtcbkJScC5pbml0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgdmFyIHIgPSB0aGlzO1xuICByLm9wdGlvbnMgPSBvcHRpb25zO1xuICByLmN5ID0gb3B0aW9ucy5jeTtcbiAgdmFyIGN0ciA9IHIuY29udGFpbmVyID0gb3B0aW9ucy5jeS5jb250YWluZXIoKTtcbiAgdmFyIGNvbnRhaW5lcldpbmRvdyA9IHIuY3kud2luZG93KCk7XG5cbiAgLy8gcHJlcGVuZCBhIHN0eWxlc2hlZXQgaW4gdGhlIGhlYWQgc3VjaCB0aGF0XG4gIGlmIChjb250YWluZXJXaW5kb3cpIHtcbiAgICB2YXIgZG9jdW1lbnQgPSBjb250YWluZXJXaW5kb3cuZG9jdW1lbnQ7XG4gICAgdmFyIGhlYWQgPSBkb2N1bWVudC5oZWFkO1xuICAgIHZhciBzdHlsZXNoZWV0SWQgPSAnX19fX19fX19fX2N5dG9zY2FwZV9zdHlsZXNoZWV0JztcbiAgICB2YXIgY2xhc3NOYW1lID0gJ19fX19fX19fX19jeXRvc2NhcGVfY29udGFpbmVyJztcbiAgICB2YXIgc3R5bGVzaGVldEFscmVhZHlFeGlzdHMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChzdHlsZXNoZWV0SWQpICE9IG51bGw7XG4gICAgaWYgKGN0ci5jbGFzc05hbWUuaW5kZXhPZihjbGFzc05hbWUpIDwgMCkge1xuICAgICAgY3RyLmNsYXNzTmFtZSA9IChjdHIuY2xhc3NOYW1lIHx8ICcnKSArICcgJyArIGNsYXNzTmFtZTtcbiAgICB9XG4gICAgaWYgKCFzdHlsZXNoZWV0QWxyZWFkeUV4aXN0cykge1xuICAgICAgdmFyIHN0eWxlc2hlZXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICAgICAgc3R5bGVzaGVldC5pZCA9IHN0eWxlc2hlZXRJZDtcbiAgICAgIHN0eWxlc2hlZXQudGV4dENvbnRlbnQgPSAnLicgKyBjbGFzc05hbWUgKyAnIHsgcG9zaXRpb246IHJlbGF0aXZlOyB9JztcbiAgICAgIGhlYWQuaW5zZXJ0QmVmb3JlKHN0eWxlc2hlZXQsIGhlYWQuY2hpbGRyZW5bMF0pOyAvLyBmaXJzdCBzbyBsb3dlc3QgcHJpb3JpdHlcbiAgICB9XG5cbiAgICB2YXIgY29tcHV0ZWRTdHlsZSA9IGNvbnRhaW5lcldpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGN0cik7XG4gICAgdmFyIHBvc2l0aW9uID0gY29tcHV0ZWRTdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKCdwb3NpdGlvbicpO1xuICAgIGlmIChwb3NpdGlvbiA9PT0gJ3N0YXRpYycpIHtcbiAgICAgIHdhcm4oJ0EgQ3l0b3NjYXBlIGNvbnRhaW5lciBoYXMgc3R5bGUgcG9zaXRpb246c3RhdGljIGFuZCBzbyBjYW4gbm90IHVzZSBVSSBleHRlbnNpb25zIHByb3Blcmx5Jyk7XG4gICAgfVxuICB9XG4gIHIuc2VsZWN0aW9uID0gW3VuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgMF07IC8vIENvb3JkaW5hdGVzIGZvciBzZWxlY3Rpb24gYm94LCBwbHVzIGVuYWJsZWQgZmxhZ1xuXG4gIHIuYmV6aWVyUHJvalBjdHMgPSBbMC4wNSwgMC4yMjUsIDAuNCwgMC41LCAwLjYsIDAuNzc1LCAwLjk1XTtcblxuICAvLy0tUG9pbnRlci1yZWxhdGVkIGRhdGFcbiAgci5ob3ZlckRhdGEgPSB7XG4gICAgZG93bjogbnVsbCxcbiAgICBsYXN0OiBudWxsLFxuICAgIGRvd25UaW1lOiBudWxsLFxuICAgIHRyaWdnZXJNb2RlOiBudWxsLFxuICAgIGRyYWdnaW5nOiBmYWxzZSxcbiAgICBpbml0aWFsUGFuOiBbbnVsbCwgbnVsbF0sXG4gICAgY2FwdHVyZTogZmFsc2VcbiAgfTtcbiAgci5kcmFnRGF0YSA9IHtcbiAgICBwb3NzaWJsZURyYWdFbGVtZW50czogW11cbiAgfTtcbiAgci50b3VjaERhdGEgPSB7XG4gICAgc3RhcnQ6IG51bGwsXG4gICAgY2FwdHVyZTogZmFsc2UsXG4gICAgLy8gVGhlc2UgMyBmaWVsZHMgcmVsYXRlZCB0byB0YXAsIHRhcGhvbGQgZXZlbnRzXG4gICAgc3RhcnRQb3NpdGlvbjogW251bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGxdLFxuICAgIHNpbmdsZVRvdWNoU3RhcnRUaW1lOiBudWxsLFxuICAgIHNpbmdsZVRvdWNoTW92ZWQ6IHRydWUsXG4gICAgbm93OiBbbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbF0sXG4gICAgZWFybGllcjogW251bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGxdXG4gIH07XG4gIHIucmVkcmF3cyA9IDA7XG4gIHIuc2hvd0ZwcyA9IG9wdGlvbnMuc2hvd0ZwcztcbiAgci5kZWJ1ZyA9IG9wdGlvbnMuZGVidWc7XG4gIHIuaGlkZUVkZ2VzT25WaWV3cG9ydCA9IG9wdGlvbnMuaGlkZUVkZ2VzT25WaWV3cG9ydDtcbiAgci50ZXh0dXJlT25WaWV3cG9ydCA9IG9wdGlvbnMudGV4dHVyZU9uVmlld3BvcnQ7XG4gIHIud2hlZWxTZW5zaXRpdml0eSA9IG9wdGlvbnMud2hlZWxTZW5zaXRpdml0eTtcbiAgci5tb3Rpb25CbHVyRW5hYmxlZCA9IG9wdGlvbnMubW90aW9uQmx1cjsgLy8gb24gYnkgZGVmYXVsdFxuICByLmZvcmNlZFBpeGVsUmF0aW8gPSBudW1iZXIkMShvcHRpb25zLnBpeGVsUmF0aW8pID8gb3B0aW9ucy5waXhlbFJhdGlvIDogbnVsbDtcbiAgci5tb3Rpb25CbHVyID0gb3B0aW9ucy5tb3Rpb25CbHVyOyAvLyBmb3IgaW5pdGlhbCBraWNrIG9mZlxuICByLm1vdGlvbkJsdXJPcGFjaXR5ID0gb3B0aW9ucy5tb3Rpb25CbHVyT3BhY2l0eTtcbiAgci5tb3Rpb25CbHVyVHJhbnNwYXJlbmN5ID0gMSAtIHIubW90aW9uQmx1ck9wYWNpdHk7XG4gIHIubW90aW9uQmx1clB4UmF0aW8gPSAxO1xuICByLm1iUHhSQmx1cnJ5ID0gMTsgLy8wLjg7XG4gIHIubWluTWJMb3dRdWFsRnJhbWVzID0gNDtcbiAgci5mdWxsUXVhbGl0eU1iID0gZmFsc2U7XG4gIHIuY2xlYXJlZEZvck1vdGlvbkJsdXIgPSBbXTtcbiAgci5kZXNrdG9wVGFwVGhyZXNob2xkID0gb3B0aW9ucy5kZXNrdG9wVGFwVGhyZXNob2xkO1xuICByLmRlc2t0b3BUYXBUaHJlc2hvbGQyID0gb3B0aW9ucy5kZXNrdG9wVGFwVGhyZXNob2xkICogb3B0aW9ucy5kZXNrdG9wVGFwVGhyZXNob2xkO1xuICByLnRvdWNoVGFwVGhyZXNob2xkID0gb3B0aW9ucy50b3VjaFRhcFRocmVzaG9sZDtcbiAgci50b3VjaFRhcFRocmVzaG9sZDIgPSBvcHRpb25zLnRvdWNoVGFwVGhyZXNob2xkICogb3B0aW9ucy50b3VjaFRhcFRocmVzaG9sZDtcbiAgci50YXBob2xkRHVyYXRpb24gPSA1MDA7XG4gIHIuYmluZGluZ3MgPSBbXTtcbiAgci5iZWZvcmVSZW5kZXJDYWxsYmFja3MgPSBbXTtcbiAgci5iZWZvcmVSZW5kZXJQcmlvcml0aWVzID0ge1xuICAgIC8vIGhpZ2hlciBwcmlvcml0eSBleGVjcyBiZWZvcmUgbG93ZXIgb25lXG4gICAgYW5pbWF0aW9uczogNDAwLFxuICAgIGVsZUNhbGNzOiAzMDAsXG4gICAgZWxlVHhyRGVxOiAyMDAsXG4gICAgbHlyVHhyRGVxOiAxNTAsXG4gICAgbHlyVHhyU2tpcDogMTAwXG4gIH07XG4gIHIucmVnaXN0ZXJOb2RlU2hhcGVzKCk7XG4gIHIucmVnaXN0ZXJBcnJvd1NoYXBlcygpO1xuICByLnJlZ2lzdGVyQ2FsY3VsYXRpb25MaXN0ZW5lcnMoKTtcbn07XG5CUnAubm90aWZ5ID0gZnVuY3Rpb24gKGV2ZW50TmFtZSwgZWxlcykge1xuICB2YXIgciA9IHRoaXM7XG4gIHZhciBjeSA9IHIuY3k7XG5cbiAgLy8gdGhlIHJlbmRlcmVyIGNhbid0IGJlIG5vdGlmaWVkIGFmdGVyIGl0J3MgZGVzdHJveWVkXG4gIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoZXZlbnROYW1lID09PSAnaW5pdCcpIHtcbiAgICByLmxvYWQoKTtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGV2ZW50TmFtZSA9PT0gJ2Rlc3Ryb3knKSB7XG4gICAgci5kZXN0cm95KCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChldmVudE5hbWUgPT09ICdhZGQnIHx8IGV2ZW50TmFtZSA9PT0gJ3JlbW92ZScgfHwgZXZlbnROYW1lID09PSAnbW92ZScgJiYgY3kuaGFzQ29tcG91bmROb2RlcygpIHx8IGV2ZW50TmFtZSA9PT0gJ2xvYWQnIHx8IGV2ZW50TmFtZSA9PT0gJ3pvcmRlcicgfHwgZXZlbnROYW1lID09PSAnbW91bnQnKSB7XG4gICAgci5pbnZhbGlkYXRlQ2FjaGVkWlNvcnRlZEVsZXMoKTtcbiAgfVxuICBpZiAoZXZlbnROYW1lID09PSAndmlld3BvcnQnKSB7XG4gICAgci5yZWRyYXdIaW50KCdzZWxlY3QnLCB0cnVlKTtcbiAgfVxuICBpZiAoZXZlbnROYW1lID09PSAnbG9hZCcgfHwgZXZlbnROYW1lID09PSAncmVzaXplJyB8fCBldmVudE5hbWUgPT09ICdtb3VudCcpIHtcbiAgICByLmludmFsaWRhdGVDb250YWluZXJDbGllbnRDb29yZHNDYWNoZSgpO1xuICAgIHIubWF0Y2hDYW52YXNTaXplKHIuY29udGFpbmVyKTtcbiAgfVxuICByLnJlZHJhd0hpbnQoJ2VsZXMnLCB0cnVlKTtcbiAgci5yZWRyYXdIaW50KCdkcmFnJywgdHJ1ZSk7XG4gIHRoaXMuc3RhcnRSZW5kZXJMb29wKCk7XG4gIHRoaXMucmVkcmF3KCk7XG59O1xuQlJwLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciByID0gdGhpcztcbiAgci5kZXN0cm95ZWQgPSB0cnVlO1xuICByLmN5LnN0b3BBbmltYXRpb25Mb29wKCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgci5iaW5kaW5ncy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBiaW5kaW5nID0gci5iaW5kaW5nc1tpXTtcbiAgICB2YXIgYiA9IGJpbmRpbmc7XG4gICAgdmFyIHRndCA9IGIudGFyZ2V0O1xuICAgICh0Z3Qub2ZmIHx8IHRndC5yZW1vdmVFdmVudExpc3RlbmVyKS5hcHBseSh0Z3QsIGIuYXJncyk7XG4gIH1cbiAgci5iaW5kaW5ncyA9IFtdO1xuICByLmJlZm9yZVJlbmRlckNhbGxiYWNrcyA9IFtdO1xuICByLm9uVXBkYXRlRWxlQ2FsY3NGbnMgPSBbXTtcbiAgaWYgKHIucmVtb3ZlT2JzZXJ2ZXIpIHtcbiAgICByLnJlbW92ZU9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgfVxuICBpZiAoci5zdHlsZU9ic2VydmVyKSB7XG4gICAgci5zdHlsZU9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgfVxuICBpZiAoci5yZXNpemVPYnNlcnZlcikge1xuICAgIHIucmVzaXplT2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICB9XG4gIGlmIChyLmxhYmVsQ2FsY0Rpdikge1xuICAgIHRyeSB7XG4gICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKHIubGFiZWxDYWxjRGl2KTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIGllMTAgaXNzdWUgIzEwMTRcbiAgICB9XG4gIH1cbn07XG5CUnAuaXNIZWFkbGVzcyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGZhbHNlO1xufTtcbltCUnAkZiwgQlJwJDUsIEJScCQ0LCBCUnAkMywgQlJwJDIsIEJScCQxXS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wcykge1xuICBleHRlbmQoQlJwLCBwcm9wcyk7XG59KTtcblxudmFyIGZ1bGxGcHNUaW1lID0gMTAwMCAvIDYwOyAvLyBhc3N1bWUgNjAgZnJhbWVzIHBlciBzZWNvbmRcblxudmFyIGRlZnMgPSB7XG4gIHNldHVwRGVxdWV1ZWluZzogZnVuY3Rpb24gc2V0dXBEZXF1ZXVlaW5nKG9wdHMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gc2V0dXBEZXF1ZXVlaW5nSW1wbCgpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciByID0gdGhpcy5yZW5kZXJlcjtcbiAgICAgIGlmIChzZWxmLmRlcXVldWVpbmdTZXR1cCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWxmLmRlcXVldWVpbmdTZXR1cCA9IHRydWU7XG4gICAgICB9XG4gICAgICB2YXIgcXVldWVSZWRyYXcgPSBkZWJvdW5jZV8xKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgci5yZWRyYXdIaW50KCdlbGVzJywgdHJ1ZSk7XG4gICAgICAgIHIucmVkcmF3SGludCgnZHJhZycsIHRydWUpO1xuICAgICAgICByLnJlZHJhdygpO1xuICAgICAgfSwgb3B0cy5kZXFSZWRyYXdUaHJlc2hvbGQpO1xuICAgICAgdmFyIGRlcXVldWUgPSBmdW5jdGlvbiBkZXF1ZXVlKHdpbGxEcmF3LCBmcmFtZVN0YXJ0VGltZSkge1xuICAgICAgICB2YXIgc3RhcnRUaW1lID0gcGVyZm9ybWFuY2VOb3coKTtcbiAgICAgICAgdmFyIGF2Z1JlbmRlclRpbWUgPSByLmF2ZXJhZ2VSZWRyYXdUaW1lO1xuICAgICAgICB2YXIgcmVuZGVyVGltZSA9IHIubGFzdFJlZHJhd1RpbWU7XG4gICAgICAgIHZhciBkZXFkID0gW107XG4gICAgICAgIHZhciBleHRlbnQgPSByLmN5LmV4dGVudCgpO1xuICAgICAgICB2YXIgcGl4ZWxSYXRpbyA9IHIuZ2V0UGl4ZWxSYXRpbygpO1xuXG4gICAgICAgIC8vIGlmIHdlIGFyZW4ndCBpbiBhIHRpY2sgdGhhdCBjYXVzZXMgYSBkcmF3LCB0aGVuIHRoZSByZW5kZXJlZCBzdHlsZVxuICAgICAgICAvLyBxdWV1ZSB3b24ndCBhdXRvbWF0aWNhbGx5IGJlIGZsdXNoZWQgYmVmb3JlIGRlcXVldWVpbmcgc3RhcnRzXG4gICAgICAgIGlmICghd2lsbERyYXcpIHtcbiAgICAgICAgICByLmZsdXNoUmVuZGVyZWRTdHlsZVF1ZXVlKCk7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnN0YW50LWNvbmRpdGlvblxuICAgICAgICAgIHZhciBub3cgPSBwZXJmb3JtYW5jZU5vdygpO1xuICAgICAgICAgIHZhciBkdXJhdGlvbiA9IG5vdyAtIHN0YXJ0VGltZTtcbiAgICAgICAgICB2YXIgZnJhbWVEdXJhdGlvbiA9IG5vdyAtIGZyYW1lU3RhcnRUaW1lO1xuICAgICAgICAgIGlmIChyZW5kZXJUaW1lIDwgZnVsbEZwc1RpbWUpIHtcbiAgICAgICAgICAgIC8vIGlmIHdlJ3JlIHJlbmRlcmluZyBmYXN0ZXIgdGhhbiB0aGUgaWRlYWwgZnBzLCB0aGVuIGRvIGRlcXVldWVpbmdcbiAgICAgICAgICAgIC8vIGR1cmluZyBhbGwgb2YgdGhlIHJlbWFpbmluZyBmcmFtZSB0aW1lXG5cbiAgICAgICAgICAgIHZhciB0aW1lQXZhaWxhYmxlID0gZnVsbEZwc1RpbWUgLSAod2lsbERyYXcgPyBhdmdSZW5kZXJUaW1lIDogMCk7XG4gICAgICAgICAgICBpZiAoZnJhbWVEdXJhdGlvbiA+PSBvcHRzLmRlcUZhc3RDb3N0ICogdGltZUF2YWlsYWJsZSkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHdpbGxEcmF3KSB7XG4gICAgICAgICAgICAgIGlmIChkdXJhdGlvbiA+PSBvcHRzLmRlcUNvc3QgKiByZW5kZXJUaW1lIHx8IGR1cmF0aW9uID49IG9wdHMuZGVxQXZnQ29zdCAqIGF2Z1JlbmRlclRpbWUpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChmcmFtZUR1cmF0aW9uID49IG9wdHMuZGVxTm9EcmF3Q29zdCAqIGZ1bGxGcHNUaW1lKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgdGhpc0RlcWQgPSBvcHRzLmRlcShzZWxmLCBwaXhlbFJhdGlvLCBleHRlbnQpO1xuICAgICAgICAgIGlmICh0aGlzRGVxZC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXNEZXFkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIGRlcWQucHVzaCh0aGlzRGVxZFtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNhbGxiYWNrcyBvbiBkZXF1ZXVlXG4gICAgICAgIGlmIChkZXFkLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBvcHRzLm9uRGVxZChzZWxmLCBkZXFkKTtcbiAgICAgICAgICBpZiAoIXdpbGxEcmF3ICYmIG9wdHMuc2hvdWxkUmVkcmF3KHNlbGYsIGRlcWQsIHBpeGVsUmF0aW8sIGV4dGVudCkpIHtcbiAgICAgICAgICAgIHF1ZXVlUmVkcmF3KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgdmFyIHByaW9yaXR5ID0gb3B0cy5wcmlvcml0eSB8fCBub29wJDE7XG4gICAgICByLmJlZm9yZVJlbmRlcihkZXF1ZXVlLCBwcmlvcml0eShzZWxmKSk7XG4gICAgfTtcbiAgfVxufTtcblxuLy8gQWxsb3dzIGxvb2t1cHMgZm9yIChlbGUsIGx2bCkgPT4gY2FjaGUuXG4vLyBVc2VzIGtleXMgc28gZWxlbWVudHMgbWF5IHNoYXJlIHRoZSBzYW1lIGNhY2hlLlxudmFyIEVsZW1lbnRUZXh0dXJlQ2FjaGVMb29rdXAgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBFbGVtZW50VGV4dHVyZUNhY2hlTG9va3VwKGdldEtleSkge1xuICAgIHZhciBkb2VzRWxlSW52YWxpZGF0ZUtleSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZmFsc2lmeTtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRWxlbWVudFRleHR1cmVDYWNoZUxvb2t1cCk7XG4gICAgdGhpcy5pZHNCeUtleSA9IG5ldyBNYXAkMigpO1xuICAgIHRoaXMua2V5Rm9ySWQgPSBuZXcgTWFwJDIoKTtcbiAgICB0aGlzLmNhY2hlc0J5THZsID0gbmV3IE1hcCQyKCk7XG4gICAgdGhpcy5sdmxzID0gW107XG4gICAgdGhpcy5nZXRLZXkgPSBnZXRLZXk7XG4gICAgdGhpcy5kb2VzRWxlSW52YWxpZGF0ZUtleSA9IGRvZXNFbGVJbnZhbGlkYXRlS2V5O1xuICB9XG4gIF9jcmVhdGVDbGFzcyhFbGVtZW50VGV4dHVyZUNhY2hlTG9va3VwLCBbe1xuICAgIGtleTogXCJnZXRJZHNGb3JcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0SWRzRm9yKGtleSkge1xuICAgICAgaWYgKGtleSA9PSBudWxsKSB7XG4gICAgICAgIGVycm9yKFwiQ2FuIG5vdCBnZXQgaWQgbGlzdCBmb3IgbnVsbCBrZXlcIik7XG4gICAgICB9XG4gICAgICB2YXIgaWRzQnlLZXkgPSB0aGlzLmlkc0J5S2V5O1xuICAgICAgdmFyIGlkcyA9IHRoaXMuaWRzQnlLZXkuZ2V0KGtleSk7XG4gICAgICBpZiAoIWlkcykge1xuICAgICAgICBpZHMgPSBuZXcgU2V0JDEoKTtcbiAgICAgICAgaWRzQnlLZXkuc2V0KGtleSwgaWRzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpZHM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFkZElkRm9yS2V5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZElkRm9yS2V5KGtleSwgaWQpIHtcbiAgICAgIGlmIChrZXkgIT0gbnVsbCkge1xuICAgICAgICB0aGlzLmdldElkc0ZvcihrZXkpLmFkZChpZCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRlbGV0ZUlkRm9yS2V5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlbGV0ZUlkRm9yS2V5KGtleSwgaWQpIHtcbiAgICAgIGlmIChrZXkgIT0gbnVsbCkge1xuICAgICAgICB0aGlzLmdldElkc0ZvcihrZXkpW1wiZGVsZXRlXCJdKGlkKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0TnVtYmVyT2ZJZHNGb3JLZXlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TnVtYmVyT2ZJZHNGb3JLZXkoa2V5KSB7XG4gICAgICBpZiAoa2V5ID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRJZHNGb3Ioa2V5KS5zaXplO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVLZXlNYXBwaW5nRm9yXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZUtleU1hcHBpbmdGb3IoZWxlKSB7XG4gICAgICB2YXIgaWQgPSBlbGUuaWQoKTtcbiAgICAgIHZhciBwcmV2S2V5ID0gdGhpcy5rZXlGb3JJZC5nZXQoaWQpO1xuICAgICAgdmFyIGN1cnJLZXkgPSB0aGlzLmdldEtleShlbGUpO1xuICAgICAgdGhpcy5kZWxldGVJZEZvcktleShwcmV2S2V5LCBpZCk7XG4gICAgICB0aGlzLmFkZElkRm9yS2V5KGN1cnJLZXksIGlkKTtcbiAgICAgIHRoaXMua2V5Rm9ySWQuc2V0KGlkLCBjdXJyS2V5KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGVsZXRlS2V5TWFwcGluZ0ZvclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZWxldGVLZXlNYXBwaW5nRm9yKGVsZSkge1xuICAgICAgdmFyIGlkID0gZWxlLmlkKCk7XG4gICAgICB2YXIgcHJldktleSA9IHRoaXMua2V5Rm9ySWQuZ2V0KGlkKTtcbiAgICAgIHRoaXMuZGVsZXRlSWRGb3JLZXkocHJldktleSwgaWQpO1xuICAgICAgdGhpcy5rZXlGb3JJZFtcImRlbGV0ZVwiXShpZCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImtleUhhc0NoYW5nZWRGb3JcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24ga2V5SGFzQ2hhbmdlZEZvcihlbGUpIHtcbiAgICAgIHZhciBpZCA9IGVsZS5pZCgpO1xuICAgICAgdmFyIHByZXZLZXkgPSB0aGlzLmtleUZvcklkLmdldChpZCk7XG4gICAgICB2YXIgbmV3S2V5ID0gdGhpcy5nZXRLZXkoZWxlKTtcbiAgICAgIHJldHVybiBwcmV2S2V5ICE9PSBuZXdLZXk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImlzSW52YWxpZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc0ludmFsaWQoZWxlKSB7XG4gICAgICByZXR1cm4gdGhpcy5rZXlIYXNDaGFuZ2VkRm9yKGVsZSkgfHwgdGhpcy5kb2VzRWxlSW52YWxpZGF0ZUtleShlbGUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRDYWNoZXNBdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDYWNoZXNBdChsdmwpIHtcbiAgICAgIHZhciBjYWNoZXNCeUx2bCA9IHRoaXMuY2FjaGVzQnlMdmwsXG4gICAgICAgIGx2bHMgPSB0aGlzLmx2bHM7XG4gICAgICB2YXIgY2FjaGVzID0gY2FjaGVzQnlMdmwuZ2V0KGx2bCk7XG4gICAgICBpZiAoIWNhY2hlcykge1xuICAgICAgICBjYWNoZXMgPSBuZXcgTWFwJDIoKTtcbiAgICAgICAgY2FjaGVzQnlMdmwuc2V0KGx2bCwgY2FjaGVzKTtcbiAgICAgICAgbHZscy5wdXNoKGx2bCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY2FjaGVzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRDYWNoZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDYWNoZShrZXksIGx2bCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0Q2FjaGVzQXQobHZsKS5nZXQoa2V5KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldChlbGUsIGx2bCkge1xuICAgICAgdmFyIGtleSA9IHRoaXMuZ2V0S2V5KGVsZSk7XG4gICAgICB2YXIgY2FjaGUgPSB0aGlzLmdldENhY2hlKGtleSwgbHZsKTtcblxuICAgICAgLy8gZ2V0dGluZyBmb3IgYW4gZWxlbWVudCBtYXkgbmVlZCB0byBhZGQgdG8gdGhlIGlkIGxpc3QgYi9jIGVsZXMgY2FuIHNoYXJlIGtleXNcbiAgICAgIGlmIChjYWNoZSAhPSBudWxsKSB7XG4gICAgICAgIHRoaXMudXBkYXRlS2V5TWFwcGluZ0ZvcihlbGUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNhY2hlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRGb3JDYWNoZWRLZXlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Rm9yQ2FjaGVkS2V5KGVsZSwgbHZsKSB7XG4gICAgICB2YXIga2V5ID0gdGhpcy5rZXlGb3JJZC5nZXQoZWxlLmlkKCkpOyAvLyBuLmIuIHVzZSBjYWNoZWQga2V5LCBub3QgbmV3bHkgY29tcHV0ZWQga2V5XG4gICAgICB2YXIgY2FjaGUgPSB0aGlzLmdldENhY2hlKGtleSwgbHZsKTtcbiAgICAgIHJldHVybiBjYWNoZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaGFzQ2FjaGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFzQ2FjaGUoa2V5LCBsdmwpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldENhY2hlc0F0KGx2bCkuaGFzKGtleSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImhhc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYXMoZWxlLCBsdmwpIHtcbiAgICAgIHZhciBrZXkgPSB0aGlzLmdldEtleShlbGUpO1xuICAgICAgcmV0dXJuIHRoaXMuaGFzQ2FjaGUoa2V5LCBsdmwpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRDYWNoZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRDYWNoZShrZXksIGx2bCwgY2FjaGUpIHtcbiAgICAgIGNhY2hlLmtleSA9IGtleTtcbiAgICAgIHRoaXMuZ2V0Q2FjaGVzQXQobHZsKS5zZXQoa2V5LCBjYWNoZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXQoZWxlLCBsdmwsIGNhY2hlKSB7XG4gICAgICB2YXIga2V5ID0gdGhpcy5nZXRLZXkoZWxlKTtcbiAgICAgIHRoaXMuc2V0Q2FjaGUoa2V5LCBsdmwsIGNhY2hlKTtcbiAgICAgIHRoaXMudXBkYXRlS2V5TWFwcGluZ0ZvcihlbGUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkZWxldGVDYWNoZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZWxldGVDYWNoZShrZXksIGx2bCkge1xuICAgICAgdGhpcy5nZXRDYWNoZXNBdChsdmwpW1wiZGVsZXRlXCJdKGtleSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRlbGV0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZGVsZXRlKGVsZSwgbHZsKSB7XG4gICAgICB2YXIga2V5ID0gdGhpcy5nZXRLZXkoZWxlKTtcbiAgICAgIHRoaXMuZGVsZXRlQ2FjaGUoa2V5LCBsdmwpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpbnZhbGlkYXRlS2V5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGludmFsaWRhdGVLZXkoa2V5KSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgdGhpcy5sdmxzLmZvckVhY2goZnVuY3Rpb24gKGx2bCkge1xuICAgICAgICByZXR1cm4gX3RoaXMuZGVsZXRlQ2FjaGUoa2V5LCBsdmwpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gcmV0dXJucyB0cnVlIGlmIG5vIG90aGVyIGVsZXMgcmVmZXJlbmNlIHRoZSBpbnZhbGlkYXRlZCBjYWNoZSAobi5iLiBvdGhlciBlbGVzIG1heSBuZWVkIHRoZSBjYWNoZSB3aXRoIHRoZSBzYW1lIGtleSlcbiAgfSwge1xuICAgIGtleTogXCJpbnZhbGlkYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGludmFsaWRhdGUoZWxlKSB7XG4gICAgICB2YXIgaWQgPSBlbGUuaWQoKTtcbiAgICAgIHZhciBrZXkgPSB0aGlzLmtleUZvcklkLmdldChpZCk7IC8vIG4uYi4gdXNlIHN0b3JlZCBrZXkgcmF0aGVyIHRoYW4gY3VycmVudCAocG90ZW50aWFsIGtleSlcblxuICAgICAgdGhpcy5kZWxldGVLZXlNYXBwaW5nRm9yKGVsZSk7XG4gICAgICB2YXIgZW50aXJlS2V5SW52YWxpZGF0ZWQgPSB0aGlzLmRvZXNFbGVJbnZhbGlkYXRlS2V5KGVsZSk7XG4gICAgICBpZiAoZW50aXJlS2V5SW52YWxpZGF0ZWQpIHtcbiAgICAgICAgLy8gY2xlYXIgbWFwcGluZyBmb3IgY3VycmVudCBrZXlcbiAgICAgICAgdGhpcy5pbnZhbGlkYXRlS2V5KGtleSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZW50aXJlS2V5SW52YWxpZGF0ZWQgfHwgdGhpcy5nZXROdW1iZXJPZklkc0ZvcktleShrZXkpID09PSAwO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gRWxlbWVudFRleHR1cmVDYWNoZUxvb2t1cDtcbn0oKTtcblxudmFyIG1pblR4ckggPSAyNTsgLy8gdGhlIHNpemUgb2YgdGhlIHRleHR1cmUgY2FjaGUgZm9yIHNtYWxsIGhlaWdodCBlbGVzIChzcGVjaWFsIGNhc2UpXG52YXIgdHhyU3RlcEggPSA1MDsgLy8gdGhlIG1pbiBzaXplIG9mIHRoZSByZWd1bGFyIGNhY2hlLCBhbmQgdGhlIHNpemUgaXQgaW5jcmVhc2VzIHdpdGggZWFjaCBzdGVwIHVwXG52YXIgbWluTHZsJDEgPSAtNDsgLy8gd2hlbiBzY2FsaW5nIHNtYWxsZXIgdGhhbiB0aGF0IHdlIGRvbid0IG5lZWQgdG8gcmUtcmVuZGVyXG52YXIgbWF4THZsJDEgPSAzOyAvLyB3aGVuIGxhcmdlciB0aGFuIHRoaXMgc2NhbGUganVzdCByZW5kZXIgZGlyZWN0bHkgKGNhY2hpbmcgaXMgbm90IGhlbHBmdWwpXG52YXIgbWF4Wm9vbSQxID0gNy45OTsgLy8gYmV5b25kIHRoaXMgem9vbSBsZXZlbCwgbGF5ZXJlZCB0ZXh0dXJlcyBhcmUgbm90IHVzZWRcbnZhciBlbGVUeHJTcGFjaW5nID0gODsgLy8gc3BhY2luZyBiZXR3ZWVuIGVsZW1lbnRzIG9uIHRleHR1cmVzIHRvIGF2b2lkIGJsaXR0aW5nIG92ZXJsYXBzXG52YXIgZGVmVHhyV2lkdGggPSAxMDI0OyAvLyBkZWZhdWx0L21pbmltdW0gdGV4dHVyZSB3aWR0aFxudmFyIG1heFR4clcgPSAxMDI0OyAvLyB0aGUgbWF4aW11bSB3aWR0aCBvZiBhIHRleHR1cmVcbnZhciBtYXhUeHJIID0gMTAyNDsgLy8gdGhlIG1heGltdW0gaGVpZ2h0IG9mIGEgdGV4dHVyZVxudmFyIG1pblV0aWxpdHkgPSAwLjI7IC8vIGlmIHVzYWdlIG9mIHRleHR1cmUgaXMgbGVzcyB0aGFuIHRoaXMsIGl0IGlzIHJldGlyZWRcbnZhciBtYXhGdWxsbmVzcyA9IDAuODsgLy8gZnVsbG5lc3Mgb2YgdGV4dHVyZSBhZnRlciB3aGljaCBxdWV1ZSByZW1vdmFsIGlzIGNoZWNrZWRcbnZhciBtYXhGdWxsbmVzc0NoZWNrcyA9IDEwOyAvLyBkZXF1ZXVlZCBhZnRlciB0aGlzIG1hbnkgY2hlY2tzXG52YXIgZGVxQ29zdCQxID0gMC4xNTsgLy8gJSBvZiBhZGQnbCByZW5kZXJpbmcgY29zdCBhbGxvd2VkIGZvciBkZXF1ZXVpbmcgZWxlIGNhY2hlcyBlYWNoIGZyYW1lXG52YXIgZGVxQXZnQ29zdCQxID0gMC4xOyAvLyAlIG9mIGFkZCdsIHJlbmRlcmluZyBjb3N0IGNvbXBhcmVkIHRvIGF2ZXJhZ2Ugb3ZlcmFsbCByZWRyYXcgdGltZVxudmFyIGRlcU5vRHJhd0Nvc3QkMSA9IDAuOTsgLy8gJSBvZiBhdmcgZnJhbWUgdGltZSB0aGF0IGNhbiBiZSB1c2VkIGZvciBkZXF1ZXVlaW5nIHdoZW4gbm90IGRyYXdpbmdcbnZhciBkZXFGYXN0Q29zdCQxID0gMC45OyAvLyAlIG9mIGZyYW1lIHRpbWUgdG8gYmUgdXNlZCB3aGVuID42MGZwc1xudmFyIGRlcVJlZHJhd1RocmVzaG9sZCQxID0gMTAwOyAvLyB0aW1lIHRvIGJhdGNoIHJlZHJhd3MgdG9nZXRoZXIgZnJvbSBkZXF1ZXVlaW5nIHRvIGFsbG93IG1vcmUgZGVxdWV1ZWluZyBjYWxjcyB0byBoYXBwZW4gaW4gdGhlIG1lYW53aGlsZVxudmFyIG1heERlcVNpemUkMSA9IDE7IC8vIG51bWJlciBvZiBlbGVzIHRvIGRlcXVldWUgYW5kIHJlbmRlciBhdCBoaWdoZXIgdGV4dHVyZSBpbiBlYWNoIGJhdGNoXG5cbnZhciBnZXRUeHJSZWFzb25zID0ge1xuICBkZXF1ZXVlOiAnZGVxdWV1ZScsXG4gIGRvd25zY2FsZTogJ2Rvd25zY2FsZScsXG4gIGhpZ2hRdWFsaXR5OiAnaGlnaFF1YWxpdHknXG59O1xudmFyIGluaXREZWZhdWx0cyA9IGRlZmF1bHRzJGcoe1xuICBnZXRLZXk6IG51bGwsXG4gIGRvZXNFbGVJbnZhbGlkYXRlS2V5OiBmYWxzaWZ5LFxuICBkcmF3RWxlbWVudDogbnVsbCxcbiAgZ2V0Qm91bmRpbmdCb3g6IG51bGwsXG4gIGdldFJvdGF0aW9uUG9pbnQ6IG51bGwsXG4gIGdldFJvdGF0aW9uT2Zmc2V0OiBudWxsLFxuICBpc1Zpc2libGU6IHRydWVpZnksXG4gIGFsbG93RWRnZVR4ckNhY2hpbmc6IHRydWUsXG4gIGFsbG93UGFyZW50VHhyQ2FjaGluZzogdHJ1ZVxufSk7XG52YXIgRWxlbWVudFRleHR1cmVDYWNoZSA9IGZ1bmN0aW9uIEVsZW1lbnRUZXh0dXJlQ2FjaGUocmVuZGVyZXIsIGluaXRPcHRpb25zKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgc2VsZi5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICBzZWxmLm9uRGVxdWV1ZXMgPSBbXTtcbiAgdmFyIG9wdHMgPSBpbml0RGVmYXVsdHMoaW5pdE9wdGlvbnMpO1xuICBleHRlbmQoc2VsZiwgb3B0cyk7XG4gIHNlbGYubG9va3VwID0gbmV3IEVsZW1lbnRUZXh0dXJlQ2FjaGVMb29rdXAob3B0cy5nZXRLZXksIG9wdHMuZG9lc0VsZUludmFsaWRhdGVLZXkpO1xuICBzZWxmLnNldHVwRGVxdWV1ZWluZygpO1xufTtcbnZhciBFVENwID0gRWxlbWVudFRleHR1cmVDYWNoZS5wcm90b3R5cGU7XG5FVENwLnJlYXNvbnMgPSBnZXRUeHJSZWFzb25zO1xuXG4vLyB0aGUgbGlzdCBvZiB0ZXh0dXJlcyBpbiB3aGljaCBuZXcgc3VidGV4dHVyZXMgZm9yIGVsZW1lbnRzIGNhbiBiZSBwbGFjZWRcbkVUQ3AuZ2V0VGV4dHVyZVF1ZXVlID0gZnVuY3Rpb24gKHR4ckgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBzZWxmLmVsZUltZ0NhY2hlcyA9IHNlbGYuZWxlSW1nQ2FjaGVzIHx8IHt9O1xuICByZXR1cm4gc2VsZi5lbGVJbWdDYWNoZXNbdHhySF0gPSBzZWxmLmVsZUltZ0NhY2hlc1t0eHJIXSB8fCBbXTtcbn07XG5cbi8vIHRoZSBsaXN0IG9mIHVzdXNlZCB0ZXh0dXJlcyB3aGljaCBjYW4gYmUgcmVjeWNsZWQgKGluIHVzZSBpbiB0ZXh0dXJlIHF1ZXVlKVxuRVRDcC5nZXRSZXRpcmVkVGV4dHVyZVF1ZXVlID0gZnVuY3Rpb24gKHR4ckgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgcnR4dHJRcyA9IHNlbGYuZWxlSW1nQ2FjaGVzLnJldGlyZWQgPSBzZWxmLmVsZUltZ0NhY2hlcy5yZXRpcmVkIHx8IHt9O1xuICB2YXIgcnR4dHJRID0gcnR4dHJRc1t0eHJIXSA9IHJ0eHRyUXNbdHhySF0gfHwgW107XG4gIHJldHVybiBydHh0clE7XG59O1xuXG4vLyBxdWV1ZSBvZiBlbGVtZW50IGRyYXcgcmVxdWVzdHMgYXQgZGlmZmVyZW50IHNjYWxlIGxldmVsc1xuRVRDcC5nZXRFbGVtZW50UXVldWUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHEgPSBzZWxmLmVsZUNhY2hlUXVldWUgPSBzZWxmLmVsZUNhY2hlUXVldWUgfHwgbmV3IGhlYXAoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gYi5yZXFzIC0gYS5yZXFzO1xuICB9KTtcbiAgcmV0dXJuIHE7XG59O1xuXG4vLyBxdWV1ZSBvZiBlbGVtZW50IGRyYXcgcmVxdWVzdHMgYXQgZGlmZmVyZW50IHNjYWxlIGxldmVscyAoZWxlbWVudCBpZCBsb29rdXApXG5FVENwLmdldEVsZW1lbnRLZXlUb1F1ZXVlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBrMnEgPSBzZWxmLmVsZUtleVRvQ2FjaGVRdWV1ZSA9IHNlbGYuZWxlS2V5VG9DYWNoZVF1ZXVlIHx8IHt9O1xuICByZXR1cm4gazJxO1xufTtcbkVUQ3AuZ2V0RWxlbWVudCA9IGZ1bmN0aW9uIChlbGUsIGJiLCBweFJhdGlvLCBsdmwsIHJlYXNvbikge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciByID0gdGhpcy5yZW5kZXJlcjtcbiAgdmFyIHpvb20gPSByLmN5Lnpvb20oKTtcbiAgdmFyIGxvb2t1cCA9IHRoaXMubG9va3VwO1xuICBpZiAoIWJiIHx8IGJiLncgPT09IDAgfHwgYmIuaCA9PT0gMCB8fCBpc05hTihiYi53KSB8fCBpc05hTihiYi5oKSB8fCAhZWxlLnZpc2libGUoKSB8fCBlbGUucmVtb3ZlZCgpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKCFzZWxmLmFsbG93RWRnZVR4ckNhY2hpbmcgJiYgZWxlLmlzRWRnZSgpIHx8ICFzZWxmLmFsbG93UGFyZW50VHhyQ2FjaGluZyAmJiBlbGUuaXNQYXJlbnQoKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmIChsdmwgPT0gbnVsbCkge1xuICAgIGx2bCA9IE1hdGguY2VpbChsb2cyKHpvb20gKiBweFJhdGlvKSk7XG4gIH1cbiAgaWYgKGx2bCA8IG1pbkx2bCQxKSB7XG4gICAgbHZsID0gbWluTHZsJDE7XG4gIH0gZWxzZSBpZiAoem9vbSA+PSBtYXhab29tJDEgfHwgbHZsID4gbWF4THZsJDEpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB2YXIgc2NhbGUgPSBNYXRoLnBvdygyLCBsdmwpO1xuICB2YXIgZWxlU2NhbGVkSCA9IGJiLmggKiBzY2FsZTtcbiAgdmFyIGVsZVNjYWxlZFcgPSBiYi53ICogc2NhbGU7XG4gIHZhciBzY2FsZWRMYWJlbFNob3duID0gci5lbGVUZXh0QmlnZ2VyVGhhbk1pbihlbGUsIHNjYWxlKTtcbiAgaWYgKCF0aGlzLmlzVmlzaWJsZShlbGUsIHNjYWxlZExhYmVsU2hvd24pKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdmFyIGVsZUNhY2hlID0gbG9va3VwLmdldChlbGUsIGx2bCk7XG5cbiAgLy8gaWYgdGhpcyBnZXQgd2FzIG9uIGFuIHVudXNlZC9pbnZhbGlkYXRlZCBjYWNoZSwgdGhlbiByZXN0b3JlIHRoZSB0ZXh0dXJlIHVzYWdlIG1ldHJpY1xuICBpZiAoZWxlQ2FjaGUgJiYgZWxlQ2FjaGUuaW52YWxpZGF0ZWQpIHtcbiAgICBlbGVDYWNoZS5pbnZhbGlkYXRlZCA9IGZhbHNlO1xuICAgIGVsZUNhY2hlLnRleHR1cmUuaW52YWxpZGF0ZWRXaWR0aCAtPSBlbGVDYWNoZS53aWR0aDtcbiAgfVxuICBpZiAoZWxlQ2FjaGUpIHtcbiAgICByZXR1cm4gZWxlQ2FjaGU7XG4gIH1cbiAgdmFyIHR4ckg7IC8vIHdoaWNoIHRleHR1cmUgaGVpZ2h0IHRoaXMgZWxlIGJlbG9uZ3MgdG9cblxuICBpZiAoZWxlU2NhbGVkSCA8PSBtaW5UeHJIKSB7XG4gICAgdHhySCA9IG1pblR4ckg7XG4gIH0gZWxzZSBpZiAoZWxlU2NhbGVkSCA8PSB0eHJTdGVwSCkge1xuICAgIHR4ckggPSB0eHJTdGVwSDtcbiAgfSBlbHNlIHtcbiAgICB0eHJIID0gTWF0aC5jZWlsKGVsZVNjYWxlZEggLyB0eHJTdGVwSCkgKiB0eHJTdGVwSDtcbiAgfVxuICBpZiAoZWxlU2NhbGVkSCA+IG1heFR4ckggfHwgZWxlU2NhbGVkVyA+IG1heFR4clcpIHtcbiAgICByZXR1cm4gbnVsbDsgLy8gY2FjaGluZyBsYXJnZSBlbGVtZW50cyBpcyBub3QgZWZmaWNpZW50XG4gIH1cblxuICB2YXIgdHhyUSA9IHNlbGYuZ2V0VGV4dHVyZVF1ZXVlKHR4ckgpO1xuXG4gIC8vIGZpcnN0IHRyeSB0aGUgc2Vjb25kIGxhc3Qgb25lIGluIGNhc2UgaXQgaGFzIHNwYWNlIGF0IHRoZSBlbmRcbiAgdmFyIHR4ciA9IHR4clFbdHhyUS5sZW5ndGggLSAyXTtcbiAgdmFyIGFkZE5ld1R4ciA9IGZ1bmN0aW9uIGFkZE5ld1R4cigpIHtcbiAgICByZXR1cm4gc2VsZi5yZWN5Y2xlVGV4dHVyZSh0eHJILCBlbGVTY2FsZWRXKSB8fCBzZWxmLmFkZFRleHR1cmUodHhySCwgZWxlU2NhbGVkVyk7XG4gIH07XG5cbiAgLy8gdHJ5IHRoZSBsYXN0IG9uZSBpZiB0aGVyZSBpcyBubyBzZWNvbmQgbGFzdCBvbmVcbiAgaWYgKCF0eHIpIHtcbiAgICB0eHIgPSB0eHJRW3R4clEubGVuZ3RoIC0gMV07XG4gIH1cblxuICAvLyBpZiB0aGUgbGFzdCBvbmUgZG9lc24ndCBleGlzdCwgd2UgbmVlZCBhIGZpcnN0IG9uZVxuICBpZiAoIXR4cikge1xuICAgIHR4ciA9IGFkZE5ld1R4cigpO1xuICB9XG5cbiAgLy8gaWYgdGhlcmUncyBubyByb29tIGluIHRoZSBjdXJyZW50IHRleHR1cmUsIHdlIG5lZWQgYSBuZXcgb25lXG4gIGlmICh0eHIud2lkdGggLSB0eHIudXNlZFdpZHRoIDwgZWxlU2NhbGVkVykge1xuICAgIHR4ciA9IGFkZE5ld1R4cigpO1xuICB9XG4gIHZhciBzY2FsYWJsZUZyb20gPSBmdW5jdGlvbiBzY2FsYWJsZUZyb20ob3RoZXJDYWNoZSkge1xuICAgIHJldHVybiBvdGhlckNhY2hlICYmIG90aGVyQ2FjaGUuc2NhbGVkTGFiZWxTaG93biA9PT0gc2NhbGVkTGFiZWxTaG93bjtcbiAgfTtcbiAgdmFyIGRlcWluZyA9IHJlYXNvbiAmJiByZWFzb24gPT09IGdldFR4clJlYXNvbnMuZGVxdWV1ZTtcbiAgdmFyIGhpZ2hRdWFsaXR5UmVxID0gcmVhc29uICYmIHJlYXNvbiA9PT0gZ2V0VHhyUmVhc29ucy5oaWdoUXVhbGl0eTtcbiAgdmFyIGRvd25zY2FsZVJlcSA9IHJlYXNvbiAmJiByZWFzb24gPT09IGdldFR4clJlYXNvbnMuZG93bnNjYWxlO1xuICB2YXIgaGlnaGVyQ2FjaGU7IC8vIHRoZSBuZWFyZXN0IGNhY2hlIHdpdGggYSBoaWdoZXIgbGV2ZWxcbiAgZm9yICh2YXIgbCA9IGx2bCArIDE7IGwgPD0gbWF4THZsJDE7IGwrKykge1xuICAgIHZhciBjID0gbG9va3VwLmdldChlbGUsIGwpO1xuICAgIGlmIChjKSB7XG4gICAgICBoaWdoZXJDYWNoZSA9IGM7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgdmFyIG9uZVVwQ2FjaGUgPSBoaWdoZXJDYWNoZSAmJiBoaWdoZXJDYWNoZS5sZXZlbCA9PT0gbHZsICsgMSA/IGhpZ2hlckNhY2hlIDogbnVsbDtcbiAgdmFyIGRvd25zY2FsZSA9IGZ1bmN0aW9uIGRvd25zY2FsZSgpIHtcbiAgICB0eHIuY29udGV4dC5kcmF3SW1hZ2Uob25lVXBDYWNoZS50ZXh0dXJlLmNhbnZhcywgb25lVXBDYWNoZS54LCAwLCBvbmVVcENhY2hlLndpZHRoLCBvbmVVcENhY2hlLmhlaWdodCwgdHhyLnVzZWRXaWR0aCwgMCwgZWxlU2NhbGVkVywgZWxlU2NhbGVkSCk7XG4gIH07XG5cbiAgLy8gcmVzZXQgZWxlIGFyZWEgaW4gdGV4dHVyZVxuICB0eHIuY29udGV4dC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG4gIHR4ci5jb250ZXh0LmNsZWFyUmVjdCh0eHIudXNlZFdpZHRoLCAwLCBlbGVTY2FsZWRXLCB0eHJIKTtcbiAgaWYgKHNjYWxhYmxlRnJvbShvbmVVcENhY2hlKSkge1xuICAgIC8vIHRoZW4gd2UgY2FuIHJlbGF0aXZlbHkgY2hlYXBseSByZXNjYWxlIHRoZSBleGlzdGluZyBpbWFnZSB3L28gcmVyZW5kZXJpbmdcbiAgICBkb3duc2NhbGUoKTtcbiAgfSBlbHNlIGlmIChzY2FsYWJsZUZyb20oaGlnaGVyQ2FjaGUpKSB7XG4gICAgLy8gdGhlbiB1c2UgdGhlIGhpZ2hlciBjYWNoZSBmb3Igbm93IGFuZCBxdWV1ZSB0aGUgbmV4dCBsZXZlbCBkb3duXG4gICAgLy8gdG8gY2hlYXBseSBzY2FsZSB0b3dhcmRzIHRoZSBzbWFsbGVyIGxldmVsXG5cbiAgICBpZiAoaGlnaFF1YWxpdHlSZXEpIHtcbiAgICAgIGZvciAodmFyIF9sID0gaGlnaGVyQ2FjaGUubGV2ZWw7IF9sID4gbHZsOyBfbC0tKSB7XG4gICAgICAgIG9uZVVwQ2FjaGUgPSBzZWxmLmdldEVsZW1lbnQoZWxlLCBiYiwgcHhSYXRpbywgX2wsIGdldFR4clJlYXNvbnMuZG93bnNjYWxlKTtcbiAgICAgIH1cbiAgICAgIGRvd25zY2FsZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZWxmLnF1ZXVlRWxlbWVudChlbGUsIGhpZ2hlckNhY2hlLmxldmVsIC0gMSk7XG4gICAgICByZXR1cm4gaGlnaGVyQ2FjaGU7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBsb3dlckNhY2hlOyAvLyB0aGUgbmVhcmVzdCBjYWNoZSB3aXRoIGEgbG93ZXIgbGV2ZWxcbiAgICBpZiAoIWRlcWluZyAmJiAhaGlnaFF1YWxpdHlSZXEgJiYgIWRvd25zY2FsZVJlcSkge1xuICAgICAgZm9yICh2YXIgX2wyID0gbHZsIC0gMTsgX2wyID49IG1pbkx2bCQxOyBfbDItLSkge1xuICAgICAgICB2YXIgX2MgPSBsb29rdXAuZ2V0KGVsZSwgX2wyKTtcbiAgICAgICAgaWYgKF9jKSB7XG4gICAgICAgICAgbG93ZXJDYWNoZSA9IF9jO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChzY2FsYWJsZUZyb20obG93ZXJDYWNoZSkpIHtcbiAgICAgIC8vIHRoZW4gdXNlIHRoZSBsb3dlciBxdWFsaXR5IGNhY2hlIGZvciBub3cgYW5kIHF1ZXVlIHRoZSBiZXR0ZXIgb25lIGZvciBsYXRlclxuXG4gICAgICBzZWxmLnF1ZXVlRWxlbWVudChlbGUsIGx2bCk7XG4gICAgICByZXR1cm4gbG93ZXJDYWNoZTtcbiAgICB9XG4gICAgdHhyLmNvbnRleHQudHJhbnNsYXRlKHR4ci51c2VkV2lkdGgsIDApO1xuICAgIHR4ci5jb250ZXh0LnNjYWxlKHNjYWxlLCBzY2FsZSk7XG4gICAgdGhpcy5kcmF3RWxlbWVudCh0eHIuY29udGV4dCwgZWxlLCBiYiwgc2NhbGVkTGFiZWxTaG93biwgZmFsc2UpO1xuICAgIHR4ci5jb250ZXh0LnNjYWxlKDEgLyBzY2FsZSwgMSAvIHNjYWxlKTtcbiAgICB0eHIuY29udGV4dC50cmFuc2xhdGUoLXR4ci51c2VkV2lkdGgsIDApO1xuICB9XG4gIGVsZUNhY2hlID0ge1xuICAgIHg6IHR4ci51c2VkV2lkdGgsXG4gICAgdGV4dHVyZTogdHhyLFxuICAgIGxldmVsOiBsdmwsXG4gICAgc2NhbGU6IHNjYWxlLFxuICAgIHdpZHRoOiBlbGVTY2FsZWRXLFxuICAgIGhlaWdodDogZWxlU2NhbGVkSCxcbiAgICBzY2FsZWRMYWJlbFNob3duOiBzY2FsZWRMYWJlbFNob3duXG4gIH07XG4gIHR4ci51c2VkV2lkdGggKz0gTWF0aC5jZWlsKGVsZVNjYWxlZFcgKyBlbGVUeHJTcGFjaW5nKTtcbiAgdHhyLmVsZUNhY2hlcy5wdXNoKGVsZUNhY2hlKTtcbiAgbG9va3VwLnNldChlbGUsIGx2bCwgZWxlQ2FjaGUpO1xuICBzZWxmLmNoZWNrVGV4dHVyZUZ1bGxuZXNzKHR4cik7XG4gIHJldHVybiBlbGVDYWNoZTtcbn07XG5FVENwLmludmFsaWRhdGVFbGVtZW50cyA9IGZ1bmN0aW9uIChlbGVzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKykge1xuICAgIHRoaXMuaW52YWxpZGF0ZUVsZW1lbnQoZWxlc1tpXSk7XG4gIH1cbn07XG5FVENwLmludmFsaWRhdGVFbGVtZW50ID0gZnVuY3Rpb24gKGVsZSkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBsb29rdXAgPSBzZWxmLmxvb2t1cDtcbiAgdmFyIGNhY2hlcyA9IFtdO1xuICB2YXIgaW52YWxpZCA9IGxvb2t1cC5pc0ludmFsaWQoZWxlKTtcbiAgaWYgKCFpbnZhbGlkKSB7XG4gICAgcmV0dXJuOyAvLyBvdmVycmlkZSB0aGUgaW52YWxpZGF0aW9uIHJlcXVlc3QgaWYgdGhlIGVsZW1lbnQga2V5IGhhcyBub3QgY2hhbmdlZFxuICB9XG5cbiAgZm9yICh2YXIgbHZsID0gbWluTHZsJDE7IGx2bCA8PSBtYXhMdmwkMTsgbHZsKyspIHtcbiAgICB2YXIgY2FjaGUgPSBsb29rdXAuZ2V0Rm9yQ2FjaGVkS2V5KGVsZSwgbHZsKTtcbiAgICBpZiAoY2FjaGUpIHtcbiAgICAgIGNhY2hlcy5wdXNoKGNhY2hlKTtcbiAgICB9XG4gIH1cbiAgdmFyIG5vT3RoZXJFbGVzVXNlQ2FjaGUgPSBsb29rdXAuaW52YWxpZGF0ZShlbGUpO1xuICBpZiAobm9PdGhlckVsZXNVc2VDYWNoZSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2FjaGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgX2NhY2hlID0gY2FjaGVzW2ldO1xuICAgICAgdmFyIHR4ciA9IF9jYWNoZS50ZXh0dXJlO1xuXG4gICAgICAvLyByZW1vdmUgc3BhY2UgZnJvbSB0aGUgdGV4dHVyZSBpdCBiZWxvbmdzIHRvXG4gICAgICB0eHIuaW52YWxpZGF0ZWRXaWR0aCArPSBfY2FjaGUud2lkdGg7XG5cbiAgICAgIC8vIG1hcmsgdGhlIGNhY2hlIGFzIGludmFsaWRhdGVkXG4gICAgICBfY2FjaGUuaW52YWxpZGF0ZWQgPSB0cnVlO1xuXG4gICAgICAvLyByZXRpcmUgdGhlIHRleHR1cmUgaWYgaXRzIHV0aWxpdHkgaXMgbG93XG4gICAgICBzZWxmLmNoZWNrVGV4dHVyZVV0aWxpdHkodHhyKTtcbiAgICB9XG4gIH1cblxuICAvLyByZW1vdmUgZnJvbSBxdWV1ZSBzaW5jZSB0aGUgb2xkIHJlcSB3YXMgZm9yIHRoZSBvbGQgc3RhdGVcbiAgc2VsZi5yZW1vdmVGcm9tUXVldWUoZWxlKTtcbn07XG5FVENwLmNoZWNrVGV4dHVyZVV0aWxpdHkgPSBmdW5jdGlvbiAodHhyKSB7XG4gIC8vIGludmFsaWRhdGUgYWxsIGVudHJpZXMgaW4gdGhlIGNhY2hlIGlmIHRoZSBjYWNoZSBzaXplIGlzIHNtYWxsXG4gIGlmICh0eHIuaW52YWxpZGF0ZWRXaWR0aCA+PSBtaW5VdGlsaXR5ICogdHhyLndpZHRoKSB7XG4gICAgdGhpcy5yZXRpcmVUZXh0dXJlKHR4cik7XG4gIH1cbn07XG5FVENwLmNoZWNrVGV4dHVyZUZ1bGxuZXNzID0gZnVuY3Rpb24gKHR4cikge1xuICAvLyBpZiB0ZXh0dXJlIGhhcyBiZWVuIG1vc3RseSBmaWxsZWQgYW5kIHBhc3NlZCBvdmVyIHNldmVyYWwgdGltZXMsIHJlbW92ZVxuICAvLyBpdCBmcm9tIHRoZSBxdWV1ZSBzbyB3ZSBkb24ndCBuZWVkIHRvIHdhc3RlIHRpbWUgbG9va2luZyBhdCBpdCB0byBwdXQgbmV3IHRoaW5nc1xuXG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHR4clEgPSBzZWxmLmdldFRleHR1cmVRdWV1ZSh0eHIuaGVpZ2h0KTtcbiAgaWYgKHR4ci51c2VkV2lkdGggLyB0eHIud2lkdGggPiBtYXhGdWxsbmVzcyAmJiB0eHIuZnVsbG5lc3NDaGVja3MgPj0gbWF4RnVsbG5lc3NDaGVja3MpIHtcbiAgICByZW1vdmVGcm9tQXJyYXkodHhyUSwgdHhyKTtcbiAgfSBlbHNlIHtcbiAgICB0eHIuZnVsbG5lc3NDaGVja3MrKztcbiAgfVxufTtcbkVUQ3AucmV0aXJlVGV4dHVyZSA9IGZ1bmN0aW9uICh0eHIpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgdHhySCA9IHR4ci5oZWlnaHQ7XG4gIHZhciB0eHJRID0gc2VsZi5nZXRUZXh0dXJlUXVldWUodHhySCk7XG4gIHZhciBsb29rdXAgPSB0aGlzLmxvb2t1cDtcblxuICAvLyByZXRpcmUgdGhlIHRleHR1cmUgZnJvbSB0aGUgYWN0aXZlIC8gc2VhcmNoYWJsZSBxdWV1ZTpcblxuICByZW1vdmVGcm9tQXJyYXkodHhyUSwgdHhyKTtcbiAgdHhyLnJldGlyZWQgPSB0cnVlO1xuXG4gIC8vIHJlbW92ZSB0aGUgcmVmcyBmcm9tIHRoZSBlbGVzIHRvIHRoZSBjYWNoZXM6XG5cbiAgdmFyIGVsZUNhY2hlcyA9IHR4ci5lbGVDYWNoZXM7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlQ2FjaGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGVsZUNhY2hlID0gZWxlQ2FjaGVzW2ldO1xuICAgIGxvb2t1cC5kZWxldGVDYWNoZShlbGVDYWNoZS5rZXksIGVsZUNhY2hlLmxldmVsKTtcbiAgfVxuICBjbGVhckFycmF5KGVsZUNhY2hlcyk7XG5cbiAgLy8gYWRkIHRoZSB0ZXh0dXJlIHRvIGEgcmV0aXJlZCBxdWV1ZSBzbyBpdCBjYW4gYmUgcmVjeWNsZWQgaW4gZnV0dXJlOlxuXG4gIHZhciBydHh0clEgPSBzZWxmLmdldFJldGlyZWRUZXh0dXJlUXVldWUodHhySCk7XG4gIHJ0eHRyUS5wdXNoKHR4cik7XG59O1xuRVRDcC5hZGRUZXh0dXJlID0gZnVuY3Rpb24gKHR4ckgsIG1pblcpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgdHhyUSA9IHNlbGYuZ2V0VGV4dHVyZVF1ZXVlKHR4ckgpO1xuICB2YXIgdHhyID0ge307XG4gIHR4clEucHVzaCh0eHIpO1xuICB0eHIuZWxlQ2FjaGVzID0gW107XG4gIHR4ci5oZWlnaHQgPSB0eHJIO1xuICB0eHIud2lkdGggPSBNYXRoLm1heChkZWZUeHJXaWR0aCwgbWluVyk7XG4gIHR4ci51c2VkV2lkdGggPSAwO1xuICB0eHIuaW52YWxpZGF0ZWRXaWR0aCA9IDA7XG4gIHR4ci5mdWxsbmVzc0NoZWNrcyA9IDA7XG4gIHR4ci5jYW52YXMgPSBzZWxmLnJlbmRlcmVyLm1ha2VPZmZzY3JlZW5DYW52YXModHhyLndpZHRoLCB0eHIuaGVpZ2h0KTtcbiAgdHhyLmNvbnRleHQgPSB0eHIuY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gIHJldHVybiB0eHI7XG59O1xuRVRDcC5yZWN5Y2xlVGV4dHVyZSA9IGZ1bmN0aW9uICh0eHJILCBtaW5XKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHR4clEgPSBzZWxmLmdldFRleHR1cmVRdWV1ZSh0eHJIKTtcbiAgdmFyIHJ0eHRyUSA9IHNlbGYuZ2V0UmV0aXJlZFRleHR1cmVRdWV1ZSh0eHJIKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBydHh0clEubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgdHhyID0gcnR4dHJRW2ldO1xuICAgIGlmICh0eHIud2lkdGggPj0gbWluVykge1xuICAgICAgdHhyLnJldGlyZWQgPSBmYWxzZTtcbiAgICAgIHR4ci51c2VkV2lkdGggPSAwO1xuICAgICAgdHhyLmludmFsaWRhdGVkV2lkdGggPSAwO1xuICAgICAgdHhyLmZ1bGxuZXNzQ2hlY2tzID0gMDtcbiAgICAgIGNsZWFyQXJyYXkodHhyLmVsZUNhY2hlcyk7XG4gICAgICB0eHIuY29udGV4dC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG4gICAgICB0eHIuY29udGV4dC5jbGVhclJlY3QoMCwgMCwgdHhyLndpZHRoLCB0eHIuaGVpZ2h0KTtcbiAgICAgIHJlbW92ZUZyb21BcnJheShydHh0clEsIHR4cik7XG4gICAgICB0eHJRLnB1c2godHhyKTtcbiAgICAgIHJldHVybiB0eHI7XG4gICAgfVxuICB9XG59O1xuRVRDcC5xdWV1ZUVsZW1lbnQgPSBmdW5jdGlvbiAoZWxlLCBsdmwpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgcSA9IHNlbGYuZ2V0RWxlbWVudFF1ZXVlKCk7XG4gIHZhciBrMnEgPSBzZWxmLmdldEVsZW1lbnRLZXlUb1F1ZXVlKCk7XG4gIHZhciBrZXkgPSB0aGlzLmdldEtleShlbGUpO1xuICB2YXIgZXhpc3RpbmdSZXEgPSBrMnFba2V5XTtcbiAgaWYgKGV4aXN0aW5nUmVxKSB7XG4gICAgLy8gdXNlIHRoZSBtYXggbHZsIGIvYyBpbiBiZXR3ZWVuIGx2bHMgYXJlIGNoZWFwIHRvIG1ha2VcbiAgICBleGlzdGluZ1JlcS5sZXZlbCA9IE1hdGgubWF4KGV4aXN0aW5nUmVxLmxldmVsLCBsdmwpO1xuICAgIGV4aXN0aW5nUmVxLmVsZXMubWVyZ2UoZWxlKTtcbiAgICBleGlzdGluZ1JlcS5yZXFzKys7XG4gICAgcS51cGRhdGVJdGVtKGV4aXN0aW5nUmVxKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgcmVxID0ge1xuICAgICAgZWxlczogZWxlLnNwYXduKCkubWVyZ2UoZWxlKSxcbiAgICAgIGxldmVsOiBsdmwsXG4gICAgICByZXFzOiAxLFxuICAgICAga2V5OiBrZXlcbiAgICB9O1xuICAgIHEucHVzaChyZXEpO1xuICAgIGsycVtrZXldID0gcmVxO1xuICB9XG59O1xuRVRDcC5kZXF1ZXVlID0gZnVuY3Rpb24gKHB4UmF0aW8gLyosIGV4dGVudCovKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHEgPSBzZWxmLmdldEVsZW1lbnRRdWV1ZSgpO1xuICB2YXIgazJxID0gc2VsZi5nZXRFbGVtZW50S2V5VG9RdWV1ZSgpO1xuICB2YXIgZGVxdWV1ZWQgPSBbXTtcbiAgdmFyIGxvb2t1cCA9IHNlbGYubG9va3VwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG1heERlcVNpemUkMTsgaSsrKSB7XG4gICAgaWYgKHEuc2l6ZSgpID4gMCkge1xuICAgICAgdmFyIHJlcSA9IHEucG9wKCk7XG4gICAgICB2YXIga2V5ID0gcmVxLmtleTtcbiAgICAgIHZhciBlbGUgPSByZXEuZWxlc1swXTsgLy8gYWxsIGVsZXMgaGF2ZSB0aGUgc2FtZSBrZXlcbiAgICAgIHZhciBjYWNoZUV4aXN0cyA9IGxvb2t1cC5oYXNDYWNoZShlbGUsIHJlcS5sZXZlbCk7XG5cbiAgICAgIC8vIGNsZWFyIG91dCB0aGUga2V5IHRvIHJlcSBsb29rdXBcbiAgICAgIGsycVtrZXldID0gbnVsbDtcblxuICAgICAgLy8gZGVxdWV1ZWluZyBpc24ndCBuZWNlc3Nhcnkgd2l0aCBhbiBleGlzdGluZyBjYWNoZVxuICAgICAgaWYgKGNhY2hlRXhpc3RzKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgZGVxdWV1ZWQucHVzaChyZXEpO1xuICAgICAgdmFyIGJiID0gc2VsZi5nZXRCb3VuZGluZ0JveChlbGUpO1xuICAgICAgc2VsZi5nZXRFbGVtZW50KGVsZSwgYmIsIHB4UmF0aW8sIHJlcS5sZXZlbCwgZ2V0VHhyUmVhc29ucy5kZXF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBkZXF1ZXVlZDtcbn07XG5FVENwLnJlbW92ZUZyb21RdWV1ZSA9IGZ1bmN0aW9uIChlbGUpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgcSA9IHNlbGYuZ2V0RWxlbWVudFF1ZXVlKCk7XG4gIHZhciBrMnEgPSBzZWxmLmdldEVsZW1lbnRLZXlUb1F1ZXVlKCk7XG4gIHZhciBrZXkgPSB0aGlzLmdldEtleShlbGUpO1xuICB2YXIgcmVxID0gazJxW2tleV07XG4gIGlmIChyZXEgIT0gbnVsbCkge1xuICAgIGlmIChyZXEuZWxlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgIC8vIHJlbW92ZSBpZiBsYXN0IGVsZSBpbiB0aGUgcmVxXG4gICAgICAvLyBicmluZyB0byBmcm9udCBvZiBxdWV1ZVxuICAgICAgcmVxLnJlcXMgPSBNQVhfSU5UJDE7XG4gICAgICBxLnVwZGF0ZUl0ZW0ocmVxKTtcbiAgICAgIHEucG9wKCk7IC8vIHJlbW92ZSBmcm9tIHF1ZXVlXG5cbiAgICAgIGsycVtrZXldID0gbnVsbDsgLy8gcmVtb3ZlIGZyb20gbG9va3VwIG1hcFxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBvdGhlcndpc2UganVzdCByZW1vdmUgZWxlIGZyb20gcmVxXG4gICAgICByZXEuZWxlcy51bm1lcmdlKGVsZSk7XG4gICAgfVxuICB9XG59O1xuRVRDcC5vbkRlcXVldWUgPSBmdW5jdGlvbiAoZm4pIHtcbiAgdGhpcy5vbkRlcXVldWVzLnB1c2goZm4pO1xufTtcbkVUQ3Aub2ZmRGVxdWV1ZSA9IGZ1bmN0aW9uIChmbikge1xuICByZW1vdmVGcm9tQXJyYXkodGhpcy5vbkRlcXVldWVzLCBmbik7XG59O1xuRVRDcC5zZXR1cERlcXVldWVpbmcgPSBkZWZzLnNldHVwRGVxdWV1ZWluZyh7XG4gIGRlcVJlZHJhd1RocmVzaG9sZDogZGVxUmVkcmF3VGhyZXNob2xkJDEsXG4gIGRlcUNvc3Q6IGRlcUNvc3QkMSxcbiAgZGVxQXZnQ29zdDogZGVxQXZnQ29zdCQxLFxuICBkZXFOb0RyYXdDb3N0OiBkZXFOb0RyYXdDb3N0JDEsXG4gIGRlcUZhc3RDb3N0OiBkZXFGYXN0Q29zdCQxLFxuICBkZXE6IGZ1bmN0aW9uIGRlcShzZWxmLCBweFJhdGlvLCBleHRlbnQpIHtcbiAgICByZXR1cm4gc2VsZi5kZXF1ZXVlKHB4UmF0aW8sIGV4dGVudCk7XG4gIH0sXG4gIG9uRGVxZDogZnVuY3Rpb24gb25EZXFkKHNlbGYsIGRlcWQpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbGYub25EZXF1ZXVlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGZuID0gc2VsZi5vbkRlcXVldWVzW2ldO1xuICAgICAgZm4oZGVxZCk7XG4gICAgfVxuICB9LFxuICBzaG91bGRSZWRyYXc6IGZ1bmN0aW9uIHNob3VsZFJlZHJhdyhzZWxmLCBkZXFkLCBweFJhdGlvLCBleHRlbnQpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRlcWQubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBlbGVzID0gZGVxZFtpXS5lbGVzO1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBlbGVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHZhciBiYiA9IGVsZXNbal0uYm91bmRpbmdCb3goKTtcbiAgICAgICAgaWYgKGJvdW5kaW5nQm94ZXNJbnRlcnNlY3QoYmIsIGV4dGVudCkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sXG4gIHByaW9yaXR5OiBmdW5jdGlvbiBwcmlvcml0eShzZWxmKSB7XG4gICAgcmV0dXJuIHNlbGYucmVuZGVyZXIuYmVmb3JlUmVuZGVyUHJpb3JpdGllcy5lbGVUeHJEZXE7XG4gIH1cbn0pO1xuXG52YXIgZGVmTnVtTGF5ZXJzID0gMTsgLy8gZGVmYXVsdCBudW1iZXIgb2YgbGF5ZXJzIHRvIHVzZVxudmFyIG1pbkx2bCA9IC00OyAvLyB3aGVuIHNjYWxpbmcgc21hbGxlciB0aGFuIHRoYXQgd2UgZG9uJ3QgbmVlZCB0byByZS1yZW5kZXJcbnZhciBtYXhMdmwgPSAyOyAvLyB3aGVuIGxhcmdlciB0aGFuIHRoaXMgc2NhbGUganVzdCByZW5kZXIgZGlyZWN0bHkgKGNhY2hpbmcgaXMgbm90IGhlbHBmdWwpXG52YXIgbWF4Wm9vbSA9IDMuOTk7IC8vIGJleW9uZCB0aGlzIHpvb20gbGV2ZWwsIGxheWVyZWQgdGV4dHVyZXMgYXJlIG5vdCB1c2VkXG52YXIgZGVxUmVkcmF3VGhyZXNob2xkID0gNTA7IC8vIHRpbWUgdG8gYmF0Y2ggcmVkcmF3cyB0b2dldGhlciBmcm9tIGRlcXVldWVpbmcgdG8gYWxsb3cgbW9yZSBkZXF1ZXVlaW5nIGNhbGNzIHRvIGhhcHBlbiBpbiB0aGUgbWVhbndoaWxlXG52YXIgcmVmaW5lRWxlRGVib3VuY2VUaW1lID0gNTA7IC8vIHRpbWUgdG8gZGVib3VuY2Ugc2hhcnBlciBlbGUgdGV4dHVyZSB1cGRhdGVzXG52YXIgZGVxQ29zdCA9IDAuMTU7IC8vICUgb2YgYWRkJ2wgcmVuZGVyaW5nIGNvc3QgYWxsb3dlZCBmb3IgZGVxdWV1aW5nIGVsZSBjYWNoZXMgZWFjaCBmcmFtZVxudmFyIGRlcUF2Z0Nvc3QgPSAwLjE7IC8vICUgb2YgYWRkJ2wgcmVuZGVyaW5nIGNvc3QgY29tcGFyZWQgdG8gYXZlcmFnZSBvdmVyYWxsIHJlZHJhdyB0aW1lXG52YXIgZGVxTm9EcmF3Q29zdCA9IDAuOTsgLy8gJSBvZiBhdmcgZnJhbWUgdGltZSB0aGF0IGNhbiBiZSB1c2VkIGZvciBkZXF1ZXVlaW5nIHdoZW4gbm90IGRyYXdpbmdcbnZhciBkZXFGYXN0Q29zdCA9IDAuOTsgLy8gJSBvZiBmcmFtZSB0aW1lIHRvIGJlIHVzZWQgd2hlbiA+NjBmcHNcbnZhciBtYXhEZXFTaXplID0gMTsgLy8gbnVtYmVyIG9mIGVsZXMgdG8gZGVxdWV1ZSBhbmQgcmVuZGVyIGF0IGhpZ2hlciB0ZXh0dXJlIGluIGVhY2ggYmF0Y2hcbnZhciBpbnZhbGlkVGhyZXNob2xkID0gMjUwOyAvLyB0aW1lIHRocmVzaG9sZCBmb3IgZGlzYWJsaW5nIGIvYyBvZiBpbnZhbGlkYXRpb25zXG52YXIgbWF4TGF5ZXJBcmVhID0gNDAwMCAqIDQwMDA7IC8vIGxheWVycyBjYW4ndCBiZSBiaWdnZXIgdGhhbiB0aGlzXG52YXIgbWF4TGF5ZXJEaW0gPSAzMjc2NzsgLy8gbWF4aW11bSBzaXplIGZvciB0aGUgd2lkdGgvaGVpZ2h0IG9mIGxheWVyIGNhbnZhc2VzXG52YXIgdXNlSGlnaFF1YWxpdHlFbGVUeHJSZXFzID0gdHJ1ZTsgLy8gd2hldGhlciB0byB1c2UgaGlnaCBxdWFsaXR5IGVsZSB0eHIgcmVxdWVzdHMgKGdlbmVyYWxseSBmYXN0ZXIgYW5kIGNoZWFwZXIgaW4gdGhlIGxvbmd0ZXJtKVxuXG4vLyB2YXIgbG9nID0gZnVuY3Rpb24oKXsgY29uc29sZS5sb2cuYXBwbHkoIGNvbnNvbGUsIGFyZ3VtZW50cyApOyB9O1xuXG52YXIgTGF5ZXJlZFRleHR1cmVDYWNoZSA9IGZ1bmN0aW9uIExheWVyZWRUZXh0dXJlQ2FjaGUocmVuZGVyZXIpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgciA9IHNlbGYucmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgdmFyIGN5ID0gci5jeTtcbiAgc2VsZi5sYXllcnNCeUxldmVsID0ge307IC8vIGUuZy4gMiA9PiBbIGxheWVyMSwgbGF5ZXIyLCAuLi4sIGxheWVyTiBdXG5cbiAgc2VsZi5maXJzdEdldCA9IHRydWU7XG4gIHNlbGYubGFzdEludmFsaWRhdGlvblRpbWUgPSBwZXJmb3JtYW5jZU5vdygpIC0gMiAqIGludmFsaWRUaHJlc2hvbGQ7XG4gIHNlbGYuc2tpcHBpbmcgPSBmYWxzZTtcbiAgc2VsZi5lbGVUeHJEZXFzID0gY3kuY29sbGVjdGlvbigpO1xuICBzZWxmLnNjaGVkdWxlRWxlbWVudFJlZmluZW1lbnQgPSBkZWJvdW5jZV8xKGZ1bmN0aW9uICgpIHtcbiAgICBzZWxmLnJlZmluZUVsZW1lbnRUZXh0dXJlcyhzZWxmLmVsZVR4ckRlcXMpO1xuICAgIHNlbGYuZWxlVHhyRGVxcy51bm1lcmdlKHNlbGYuZWxlVHhyRGVxcyk7XG4gIH0sIHJlZmluZUVsZURlYm91bmNlVGltZSk7XG4gIHIuYmVmb3JlUmVuZGVyKGZ1bmN0aW9uICh3aWxsRHJhdywgbm93KSB7XG4gICAgaWYgKG5vdyAtIHNlbGYubGFzdEludmFsaWRhdGlvblRpbWUgPD0gaW52YWxpZFRocmVzaG9sZCkge1xuICAgICAgc2VsZi5za2lwcGluZyA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNlbGYuc2tpcHBpbmcgPSBmYWxzZTtcbiAgICB9XG4gIH0sIHIuYmVmb3JlUmVuZGVyUHJpb3JpdGllcy5seXJUeHJTa2lwKTtcbiAgdmFyIHFTb3J0ID0gZnVuY3Rpb24gcVNvcnQoYSwgYikge1xuICAgIHJldHVybiBiLnJlcXMgLSBhLnJlcXM7XG4gIH07XG4gIHNlbGYubGF5ZXJzUXVldWUgPSBuZXcgaGVhcChxU29ydCk7XG4gIHNlbGYuc2V0dXBEZXF1ZXVlaW5nKCk7XG59O1xudmFyIExUQ3AgPSBMYXllcmVkVGV4dHVyZUNhY2hlLnByb3RvdHlwZTtcbnZhciBsYXllcklkUG9vbCA9IDA7XG52YXIgTUFYX0lOVCA9IE1hdGgucG93KDIsIDUzKSAtIDE7XG5MVENwLm1ha2VMYXllciA9IGZ1bmN0aW9uIChiYiwgbHZsKSB7XG4gIHZhciBzY2FsZSA9IE1hdGgucG93KDIsIGx2bCk7XG4gIHZhciB3ID0gTWF0aC5jZWlsKGJiLncgKiBzY2FsZSk7XG4gIHZhciBoID0gTWF0aC5jZWlsKGJiLmggKiBzY2FsZSk7XG4gIHZhciBjYW52YXMgPSB0aGlzLnJlbmRlcmVyLm1ha2VPZmZzY3JlZW5DYW52YXModywgaCk7XG4gIHZhciBsYXllciA9IHtcbiAgICBpZDogbGF5ZXJJZFBvb2wgPSArK2xheWVySWRQb29sICUgTUFYX0lOVCxcbiAgICBiYjogYmIsXG4gICAgbGV2ZWw6IGx2bCxcbiAgICB3aWR0aDogdyxcbiAgICBoZWlnaHQ6IGgsXG4gICAgY2FudmFzOiBjYW52YXMsXG4gICAgY29udGV4dDogY2FudmFzLmdldENvbnRleHQoJzJkJyksXG4gICAgZWxlczogW10sXG4gICAgZWxlc1F1ZXVlOiBbXSxcbiAgICByZXFzOiAwXG4gIH07XG5cbiAgLy8gbG9nKCdtYWtlIGxheWVyICVzIHdpdGggdyAlcyBhbmQgaCAlcyBhbmQgbHZsICVzJywgbGF5ZXIuaWQsIGxheWVyLndpZHRoLCBsYXllci5oZWlnaHQsIGxheWVyLmxldmVsKTtcblxuICB2YXIgY3h0ID0gbGF5ZXIuY29udGV4dDtcbiAgdmFyIGR4ID0gLWxheWVyLmJiLngxO1xuICB2YXIgZHkgPSAtbGF5ZXIuYmIueTE7XG5cbiAgLy8gZG8gdGhlIHRyYW5zZm9ybSBvbiBjcmVhdGlvbiB0byBzYXZlIGN5Y2xlcyAoaXQncyB0aGUgc2FtZSBmb3IgYWxsIGVsZXMpXG4gIGN4dC5zY2FsZShzY2FsZSwgc2NhbGUpO1xuICBjeHQudHJhbnNsYXRlKGR4LCBkeSk7XG4gIHJldHVybiBsYXllcjtcbn07XG5MVENwLmdldExheWVycyA9IGZ1bmN0aW9uIChlbGVzLCBweFJhdGlvLCBsdmwpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgciA9IHNlbGYucmVuZGVyZXI7XG4gIHZhciBjeSA9IHIuY3k7XG4gIHZhciB6b29tID0gY3kuem9vbSgpO1xuICB2YXIgZmlyc3RHZXQgPSBzZWxmLmZpcnN0R2V0O1xuICBzZWxmLmZpcnN0R2V0ID0gZmFsc2U7XG5cbiAgLy8gbG9nKCctLVxcbmdldCBsYXllcnMgd2l0aCAlcyBlbGVzJywgZWxlcy5sZW5ndGgpO1xuICAvL2xvZyBlbGVzLm1hcChmdW5jdGlvbihlbGUpeyByZXR1cm4gZWxlLmlkKCkgfSkgKTtcblxuICBpZiAobHZsID09IG51bGwpIHtcbiAgICBsdmwgPSBNYXRoLmNlaWwobG9nMih6b29tICogcHhSYXRpbykpO1xuICAgIGlmIChsdmwgPCBtaW5MdmwpIHtcbiAgICAgIGx2bCA9IG1pbkx2bDtcbiAgICB9IGVsc2UgaWYgKHpvb20gPj0gbWF4Wm9vbSB8fCBsdmwgPiBtYXhMdmwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuICBzZWxmLnZhbGlkYXRlTGF5ZXJzRWxlc09yZGVyaW5nKGx2bCwgZWxlcyk7XG4gIHZhciBsYXllcnNCeUx2bCA9IHNlbGYubGF5ZXJzQnlMZXZlbDtcbiAgdmFyIHNjYWxlID0gTWF0aC5wb3coMiwgbHZsKTtcbiAgdmFyIGxheWVycyA9IGxheWVyc0J5THZsW2x2bF0gPSBsYXllcnNCeUx2bFtsdmxdIHx8IFtdO1xuICB2YXIgYmI7XG4gIHZhciBsdmxDb21wbGV0ZSA9IHNlbGYubGV2ZWxJc0NvbXBsZXRlKGx2bCwgZWxlcyk7XG4gIHZhciB0bXBMYXllcnM7XG4gIHZhciBjaGVja1RlbXBMZXZlbHMgPSBmdW5jdGlvbiBjaGVja1RlbXBMZXZlbHMoKSB7XG4gICAgdmFyIGNhblVzZUFzVG1wTHZsID0gZnVuY3Rpb24gY2FuVXNlQXNUbXBMdmwobCkge1xuICAgICAgc2VsZi52YWxpZGF0ZUxheWVyc0VsZXNPcmRlcmluZyhsLCBlbGVzKTtcbiAgICAgIGlmIChzZWxmLmxldmVsSXNDb21wbGV0ZShsLCBlbGVzKSkge1xuICAgICAgICB0bXBMYXllcnMgPSBsYXllcnNCeUx2bFtsXTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfTtcbiAgICB2YXIgY2hlY2tMdmxzID0gZnVuY3Rpb24gY2hlY2tMdmxzKGRpcikge1xuICAgICAgaWYgKHRtcExheWVycykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBsID0gbHZsICsgZGlyOyBtaW5MdmwgPD0gbCAmJiBsIDw9IG1heEx2bDsgbCArPSBkaXIpIHtcbiAgICAgICAgaWYgKGNhblVzZUFzVG1wTHZsKGwpKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIGNoZWNrTHZscygrMSk7XG4gICAgY2hlY2tMdmxzKC0xKTtcblxuICAgIC8vIHJlbW92ZSB0aGUgaW52YWxpZCBsYXllcnM7IHRoZXkgd2lsbCBiZSByZXBsYWNlZCBhcyBuZWVkZWQgbGF0ZXIgaW4gdGhpcyBmdW5jdGlvblxuICAgIGZvciAodmFyIGkgPSBsYXllcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciBsYXllciA9IGxheWVyc1tpXTtcbiAgICAgIGlmIChsYXllci5pbnZhbGlkKSB7XG4gICAgICAgIHJlbW92ZUZyb21BcnJheShsYXllcnMsIGxheWVyKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIGlmICghbHZsQ29tcGxldGUpIHtcbiAgICAvLyBpZiB0aGUgY3VycmVudCBsZXZlbCBpcyBpbmNvbXBsZXRlLCB0aGVuIHVzZSB0aGUgY2xvc2VzdCwgYmVzdCBxdWFsaXR5IGxheWVyc2V0IHRlbXBvcmFyaWx5XG4gICAgLy8gYW5kIGxhdGVyIHF1ZXVlIHRoZSBjdXJyZW50IGxheWVyc2V0IHNvIHdlIGNhbiBnZXQgdGhlIHByb3BlciBxdWFsaXR5IGxldmVsIHNvb25cblxuICAgIGNoZWNrVGVtcExldmVscygpO1xuICB9IGVsc2Uge1xuICAgIC8vIGxvZygnbGV2ZWwgY29tcGxldGUsIHVzaW5nIGV4aXN0aW5nIGxheWVyc1xcbi0tJyk7XG4gICAgcmV0dXJuIGxheWVycztcbiAgfVxuICB2YXIgZ2V0QmIgPSBmdW5jdGlvbiBnZXRCYigpIHtcbiAgICBpZiAoIWJiKSB7XG4gICAgICBiYiA9IG1ha2VCb3VuZGluZ0JveCgpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHVwZGF0ZUJvdW5kaW5nQm94KGJiLCBlbGVzW2ldLmJvdW5kaW5nQm94KCkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYmI7XG4gIH07XG4gIHZhciBtYWtlTGF5ZXIgPSBmdW5jdGlvbiBtYWtlTGF5ZXIob3B0cykge1xuICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xuICAgIHZhciBhZnRlciA9IG9wdHMuYWZ0ZXI7XG4gICAgZ2V0QmIoKTtcbiAgICB2YXIgdyA9IE1hdGguY2VpbChiYi53ICogc2NhbGUpO1xuICAgIHZhciBoID0gTWF0aC5jZWlsKGJiLmggKiBzY2FsZSk7XG4gICAgaWYgKHcgPiBtYXhMYXllckRpbSB8fCBoID4gbWF4TGF5ZXJEaW0pIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgYXJlYSA9IHcgKiBoO1xuICAgIGlmIChhcmVhID4gbWF4TGF5ZXJBcmVhKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIGxheWVyID0gc2VsZi5tYWtlTGF5ZXIoYmIsIGx2bCk7XG4gICAgaWYgKGFmdGVyICE9IG51bGwpIHtcbiAgICAgIHZhciBpbmRleCA9IGxheWVycy5pbmRleE9mKGFmdGVyKSArIDE7XG4gICAgICBsYXllcnMuc3BsaWNlKGluZGV4LCAwLCBsYXllcik7XG4gICAgfSBlbHNlIGlmIChvcHRzLmluc2VydCA9PT0gdW5kZWZpbmVkIHx8IG9wdHMuaW5zZXJ0KSB7XG4gICAgICAvLyBubyBhZnRlciBzcGVjaWZpZWQgPT4gZmlyc3QgbGF5ZXIgbWFkZSBzbyBwdXQgYXQgc3RhcnRcbiAgICAgIGxheWVycy51bnNoaWZ0KGxheWVyKTtcbiAgICB9XG5cbiAgICAvLyBpZiggdG1wTGF5ZXJzICl7XG4gICAgLy9zZWxmLnF1ZXVlTGF5ZXIoIGxheWVyICk7XG4gICAgLy8gfVxuXG4gICAgcmV0dXJuIGxheWVyO1xuICB9O1xuICBpZiAoc2VsZi5za2lwcGluZyAmJiAhZmlyc3RHZXQpIHtcbiAgICAvLyBsb2coJ3NraXAgbGF5ZXJzJyk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBsb2coJ2RvIGxheWVycycpO1xuXG4gIHZhciBsYXllciA9IG51bGw7XG4gIHZhciBtYXhFbGVzUGVyTGF5ZXIgPSBlbGVzLmxlbmd0aCAvIGRlZk51bUxheWVycztcbiAgdmFyIGFsbG93TGF6eVF1ZXVlaW5nID0gIWZpcnN0R2V0O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZWxlID0gZWxlc1tpXTtcbiAgICB2YXIgcnMgPSBlbGUuX3ByaXZhdGUucnNjcmF0Y2g7XG4gICAgdmFyIGNhY2hlcyA9IHJzLmltZ0xheWVyQ2FjaGVzID0gcnMuaW1nTGF5ZXJDYWNoZXMgfHwge307XG5cbiAgICAvLyBsb2coJ2xvb2sgYXQgZWxlJywgZWxlLmlkKCkpO1xuXG4gICAgdmFyIGV4aXN0aW5nTGF5ZXIgPSBjYWNoZXNbbHZsXTtcbiAgICBpZiAoZXhpc3RpbmdMYXllcikge1xuICAgICAgLy8gcmV1c2UgbGF5ZXIgZm9yIGxhdGVyIGVsZXNcbiAgICAgIC8vIGxvZygncmV1c2UgbGF5ZXIgZm9yJywgZWxlLmlkKCkpO1xuICAgICAgbGF5ZXIgPSBleGlzdGluZ0xheWVyO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmICghbGF5ZXIgfHwgbGF5ZXIuZWxlcy5sZW5ndGggPj0gbWF4RWxlc1BlckxheWVyIHx8ICFib3VuZGluZ0JveEluQm91bmRpbmdCb3gobGF5ZXIuYmIsIGVsZS5ib3VuZGluZ0JveCgpKSkge1xuICAgICAgLy8gbG9nKCdtYWtlIG5ldyBsYXllciBmb3IgZWxlICVzJywgZWxlLmlkKCkpO1xuXG4gICAgICBsYXllciA9IG1ha2VMYXllcih7XG4gICAgICAgIGluc2VydDogdHJ1ZSxcbiAgICAgICAgYWZ0ZXI6IGxheWVyXG4gICAgICB9KTtcblxuICAgICAgLy8gaWYgbm93IGxheWVyIGNhbiBiZSBidWlsdCB0aGVuIHdlIGNhbid0IHVzZSBsYXllcnMgYXQgdGhpcyBsZXZlbFxuICAgICAgaWYgKCFsYXllcikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgLy8gbG9nKCduZXcgbGF5ZXIgd2l0aCBpZCAlcycsIGxheWVyLmlkKTtcbiAgICB9XG5cbiAgICBpZiAodG1wTGF5ZXJzIHx8IGFsbG93TGF6eVF1ZXVlaW5nKSB7XG4gICAgICAvLyBsb2coJ3F1ZXVlIGVsZSAlcyBpbiBsYXllciAlcycsIGVsZS5pZCgpLCBsYXllci5pZCk7XG4gICAgICBzZWxmLnF1ZXVlTGF5ZXIobGF5ZXIsIGVsZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGxvZygnZHJhdyBlbGUgJXMgaW4gbGF5ZXIgJXMnLCBlbGUuaWQoKSwgbGF5ZXIuaWQpO1xuICAgICAgc2VsZi5kcmF3RWxlSW5MYXllcihsYXllciwgZWxlLCBsdmwsIHB4UmF0aW8pO1xuICAgIH1cbiAgICBsYXllci5lbGVzLnB1c2goZWxlKTtcbiAgICBjYWNoZXNbbHZsXSA9IGxheWVyO1xuICB9XG5cbiAgLy8gbG9nKCctLScpO1xuXG4gIGlmICh0bXBMYXllcnMpIHtcbiAgICAvLyB0aGVuIHdlIG9ubHkgcXVldWVkIHRoZSBjdXJyZW50IGxheWVyc2V0IGFuZCBjYW4ndCBkcmF3IGl0IHlldFxuICAgIHJldHVybiB0bXBMYXllcnM7XG4gIH1cbiAgaWYgKGFsbG93TGF6eVF1ZXVlaW5nKSB7XG4gICAgLy8gbG9nKCdsYXp5IHF1ZXVlIGxldmVsJywgbHZsKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gbGF5ZXJzO1xufTtcblxuLy8gYSBsYXllciBtYXkgd2FudCB0byB1c2UgYW4gZWxlIGNhY2hlIG9mIGEgaGlnaGVyIGxldmVsIHRvIGF2b2lkIGJsdXJyaW5lc3Ncbi8vIHNvIHRoZSBsYXllciBsZXZlbCBtaWdodCBub3QgZXF1YWwgdGhlIGVsZSBsZXZlbFxuTFRDcC5nZXRFbGVMZXZlbEZvckxheWVyTGV2ZWwgPSBmdW5jdGlvbiAobHZsLCBweFJhdGlvKSB7XG4gIHJldHVybiBsdmw7XG59O1xuTFRDcC5kcmF3RWxlSW5MYXllciA9IGZ1bmN0aW9uIChsYXllciwgZWxlLCBsdmwsIHB4UmF0aW8pIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgciA9IHRoaXMucmVuZGVyZXI7XG4gIHZhciBjb250ZXh0ID0gbGF5ZXIuY29udGV4dDtcbiAgdmFyIGJiID0gZWxlLmJvdW5kaW5nQm94KCk7XG4gIGlmIChiYi53ID09PSAwIHx8IGJiLmggPT09IDAgfHwgIWVsZS52aXNpYmxlKCkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgbHZsID0gc2VsZi5nZXRFbGVMZXZlbEZvckxheWVyTGV2ZWwobHZsLCBweFJhdGlvKTtcbiAge1xuICAgIHIuc2V0SW1nU21vb3RoaW5nKGNvbnRleHQsIGZhbHNlKTtcbiAgfVxuICB7XG4gICAgci5kcmF3Q2FjaGVkRWxlbWVudChjb250ZXh0LCBlbGUsIG51bGwsIG51bGwsIGx2bCwgdXNlSGlnaFF1YWxpdHlFbGVUeHJSZXFzKTtcbiAgfVxuICB7XG4gICAgci5zZXRJbWdTbW9vdGhpbmcoY29udGV4dCwgdHJ1ZSk7XG4gIH1cbn07XG5MVENwLmxldmVsSXNDb21wbGV0ZSA9IGZ1bmN0aW9uIChsdmwsIGVsZXMpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgbGF5ZXJzID0gc2VsZi5sYXllcnNCeUxldmVsW2x2bF07XG4gIGlmICghbGF5ZXJzIHx8IGxheWVycy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIG51bUVsZXNJbkxheWVycyA9IDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGF5ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGxheWVyID0gbGF5ZXJzW2ldO1xuXG4gICAgLy8gaWYgdGhlcmUgYXJlIGFueSBlbGVzIG5lZWRlZCB0byBiZSBkcmF3biB5ZXQsIHRoZSBsZXZlbCBpcyBub3QgY29tcGxldGVcbiAgICBpZiAobGF5ZXIucmVxcyA+IDApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBpZiB0aGUgbGF5ZXIgaXMgaW52YWxpZCwgdGhlIGxldmVsIGlzIG5vdCBjb21wbGV0ZVxuICAgIGlmIChsYXllci5pbnZhbGlkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIG51bUVsZXNJbkxheWVycyArPSBsYXllci5lbGVzLmxlbmd0aDtcbiAgfVxuXG4gIC8vIHdlIHNob3VsZCBoYXZlIGV4YWN0bHkgdGhlIG51bWJlciBvZiBlbGVzIHBhc3NlZCBpbiB0byBiZSBjb21wbGV0ZVxuICBpZiAobnVtRWxlc0luTGF5ZXJzICE9PSBlbGVzLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn07XG5MVENwLnZhbGlkYXRlTGF5ZXJzRWxlc09yZGVyaW5nID0gZnVuY3Rpb24gKGx2bCwgZWxlcykge1xuICB2YXIgbGF5ZXJzID0gdGhpcy5sYXllcnNCeUxldmVsW2x2bF07XG4gIGlmICghbGF5ZXJzKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gaWYgaW4gYSBsYXllciB0aGUgZWxlcyBhcmUgbm90IGluIHRoZSBzYW1lIG9yZGVyLCB0aGVuIHRoZSBsYXllciBpcyBpbnZhbGlkXG4gIC8vIChpLmUuIHRoZXJlIGlzIGFuIGVsZSBpbiBiZXR3ZWVuIHRoZSBlbGVzIGluIHRoZSBsYXllcilcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxheWVycy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBsYXllciA9IGxheWVyc1tpXTtcbiAgICB2YXIgb2Zmc2V0ID0gLTE7XG5cbiAgICAvLyBmaW5kIHRoZSBvZmZzZXRcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IGVsZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgIGlmIChsYXllci5lbGVzWzBdID09PSBlbGVzW2pdKSB7XG4gICAgICAgIG9mZnNldCA9IGo7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAob2Zmc2V0IDwgMCkge1xuICAgICAgLy8gdGhlbiB0aGUgbGF5ZXIgaGFzIG5vbmV4aXN0ZW50IGVsZW1lbnRzIGFuZCBpcyBpbnZhbGlkXG4gICAgICB0aGlzLmludmFsaWRhdGVMYXllcihsYXllcik7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyB0aGUgZWxlcyBpbiB0aGUgbGF5ZXIgbXVzdCBiZSBpbiB0aGUgc2FtZSBjb250aW51b3VzIG9yZGVyLCBlbHNlIHRoZSBsYXllciBpcyBpbnZhbGlkXG5cbiAgICB2YXIgbyA9IG9mZnNldDtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IGxheWVyLmVsZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgIGlmIChsYXllci5lbGVzW2pdICE9PSBlbGVzW28gKyBqXSkge1xuICAgICAgICAvLyBsb2coJ2ludmFsaWRhdGUgYmFzZWQgb24gb3JkZXJpbmcnLCBsYXllci5pZCk7XG5cbiAgICAgICAgdGhpcy5pbnZhbGlkYXRlTGF5ZXIobGF5ZXIpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5MVENwLnVwZGF0ZUVsZW1lbnRzSW5MYXllcnMgPSBmdW5jdGlvbiAoZWxlcywgdXBkYXRlKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIGlzRWxlcyA9IGVsZW1lbnQoZWxlc1swXSk7XG5cbiAgLy8gY29sbGVjdCB1ZHBhdGVkIGVsZW1lbnRzIChjYXNjYWRlZCBmcm9tIHRoZSBsYXllcnMpIGFuZCB1cGRhdGUgZWFjaFxuICAvLyBsYXllciBpdHNlbGYgYWxvbmcgdGhlIHdheVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcmVxID0gaXNFbGVzID8gbnVsbCA6IGVsZXNbaV07XG4gICAgdmFyIGVsZSA9IGlzRWxlcyA/IGVsZXNbaV0gOiBlbGVzW2ldLmVsZTtcbiAgICB2YXIgcnMgPSBlbGUuX3ByaXZhdGUucnNjcmF0Y2g7XG4gICAgdmFyIGNhY2hlcyA9IHJzLmltZ0xheWVyQ2FjaGVzID0gcnMuaW1nTGF5ZXJDYWNoZXMgfHwge307XG4gICAgZm9yICh2YXIgbCA9IG1pbkx2bDsgbCA8PSBtYXhMdmw7IGwrKykge1xuICAgICAgdmFyIGxheWVyID0gY2FjaGVzW2xdO1xuICAgICAgaWYgKCFsYXllcikge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gaWYgdXBkYXRlIGlzIGEgcmVxdWVzdCBmcm9tIHRoZSBlbGUgY2FjaGUsIHRoZW4gaXQgYWZmZWN0cyBvbmx5XG4gICAgICAvLyB0aGUgbWF0Y2hpbmcgbGV2ZWxcbiAgICAgIGlmIChyZXEgJiYgc2VsZi5nZXRFbGVMZXZlbEZvckxheWVyTGV2ZWwobGF5ZXIubGV2ZWwpICE9PSByZXEubGV2ZWwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB1cGRhdGUobGF5ZXIsIGVsZSwgcmVxKTtcbiAgICB9XG4gIH1cbn07XG5MVENwLmhhdmVMYXllcnMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIGhhdmVMYXllcnMgPSBmYWxzZTtcbiAgZm9yICh2YXIgbCA9IG1pbkx2bDsgbCA8PSBtYXhMdmw7IGwrKykge1xuICAgIHZhciBsYXllcnMgPSBzZWxmLmxheWVyc0J5TGV2ZWxbbF07XG4gICAgaWYgKGxheWVycyAmJiBsYXllcnMubGVuZ3RoID4gMCkge1xuICAgICAgaGF2ZUxheWVycyA9IHRydWU7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGhhdmVMYXllcnM7XG59O1xuTFRDcC5pbnZhbGlkYXRlRWxlbWVudHMgPSBmdW5jdGlvbiAoZWxlcykge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIGlmIChlbGVzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybjtcbiAgfVxuICBzZWxmLmxhc3RJbnZhbGlkYXRpb25UaW1lID0gcGVyZm9ybWFuY2VOb3coKTtcblxuICAvLyBsb2coJ3VwZGF0ZSBpbnZhbGlkYXRlIGxheWVyIHRpbWUgZnJvbSBlbGVzJyk7XG5cbiAgaWYgKGVsZXMubGVuZ3RoID09PSAwIHx8ICFzZWxmLmhhdmVMYXllcnMoKSkge1xuICAgIHJldHVybjtcbiAgfVxuICBzZWxmLnVwZGF0ZUVsZW1lbnRzSW5MYXllcnMoZWxlcywgZnVuY3Rpb24gaW52YWxBc3NvY0xheWVycyhsYXllciwgZWxlLCByZXEpIHtcbiAgICBzZWxmLmludmFsaWRhdGVMYXllcihsYXllcik7XG4gIH0pO1xufTtcbkxUQ3AuaW52YWxpZGF0ZUxheWVyID0gZnVuY3Rpb24gKGxheWVyKSB7XG4gIC8vIGxvZygndXBkYXRlIGludmFsaWRhdGUgbGF5ZXIgdGltZScpO1xuXG4gIHRoaXMubGFzdEludmFsaWRhdGlvblRpbWUgPSBwZXJmb3JtYW5jZU5vdygpO1xuICBpZiAobGF5ZXIuaW52YWxpZCkge1xuICAgIHJldHVybjtcbiAgfSAvLyBzYXZlIGN5Y2xlc1xuXG4gIHZhciBsdmwgPSBsYXllci5sZXZlbDtcbiAgdmFyIGVsZXMgPSBsYXllci5lbGVzO1xuICB2YXIgbGF5ZXJzID0gdGhpcy5sYXllcnNCeUxldmVsW2x2bF07XG5cbiAgLy8gbG9nKCdpbnZhbGlkYXRlIGxheWVyJywgbGF5ZXIuaWQgKTtcblxuICByZW1vdmVGcm9tQXJyYXkobGF5ZXJzLCBsYXllcik7XG4gIC8vIGxheWVyLmVsZXMgPSBbXTtcblxuICBsYXllci5lbGVzUXVldWUgPSBbXTtcbiAgbGF5ZXIuaW52YWxpZCA9IHRydWU7XG4gIGlmIChsYXllci5yZXBsYWNlbWVudCkge1xuICAgIGxheWVyLnJlcGxhY2VtZW50LmludmFsaWQgPSB0cnVlO1xuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBjYWNoZXMgPSBlbGVzW2ldLl9wcml2YXRlLnJzY3JhdGNoLmltZ0xheWVyQ2FjaGVzO1xuICAgIGlmIChjYWNoZXMpIHtcbiAgICAgIGNhY2hlc1tsdmxdID0gbnVsbDtcbiAgICB9XG4gIH1cbn07XG5MVENwLnJlZmluZUVsZW1lbnRUZXh0dXJlcyA9IGZ1bmN0aW9uIChlbGVzKSB7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICAvLyBsb2coJ3JlZmluZScsIGVsZXMubGVuZ3RoKTtcblxuICBzZWxmLnVwZGF0ZUVsZW1lbnRzSW5MYXllcnMoZWxlcywgZnVuY3Rpb24gcmVmaW5lRWFjaEVsZShsYXllciwgZWxlLCByZXEpIHtcbiAgICB2YXIgckx5ciA9IGxheWVyLnJlcGxhY2VtZW50O1xuICAgIGlmICghckx5cikge1xuICAgICAgckx5ciA9IGxheWVyLnJlcGxhY2VtZW50ID0gc2VsZi5tYWtlTGF5ZXIobGF5ZXIuYmIsIGxheWVyLmxldmVsKTtcbiAgICAgIHJMeXIucmVwbGFjZXMgPSBsYXllcjtcbiAgICAgIHJMeXIuZWxlcyA9IGxheWVyLmVsZXM7XG5cbiAgICAgIC8vIGxvZygnbWFrZSByZXBsYWNlbWVudCBsYXllciAlcyBmb3IgJXMgd2l0aCBsZXZlbCAlcycsIHJMeXIuaWQsIGxheWVyLmlkLCByTHlyLmxldmVsKTtcbiAgICB9XG5cbiAgICBpZiAoIXJMeXIucmVxcykge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByTHlyLmVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgc2VsZi5xdWV1ZUxheWVyKHJMeXIsIHJMeXIuZWxlc1tpXSk7XG4gICAgICB9XG5cbiAgICAgIC8vIGxvZygncXVldWUgcmVwbGFjZW1lbnQgbGF5ZXIgcmVmaW5lbWVudCcsIHJMeXIuaWQpO1xuICAgIH1cbiAgfSk7XG59O1xuXG5MVENwLmVucXVldWVFbGVtZW50UmVmaW5lbWVudCA9IGZ1bmN0aW9uIChlbGUpIHtcbiAgdGhpcy5lbGVUeHJEZXFzLm1lcmdlKGVsZSk7XG4gIHRoaXMuc2NoZWR1bGVFbGVtZW50UmVmaW5lbWVudCgpO1xufTtcbkxUQ3AucXVldWVMYXllciA9IGZ1bmN0aW9uIChsYXllciwgZWxlKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHEgPSBzZWxmLmxheWVyc1F1ZXVlO1xuICB2YXIgZWxlc1EgPSBsYXllci5lbGVzUXVldWU7XG4gIHZhciBoYXNJZCA9IGVsZXNRLmhhc0lkID0gZWxlc1EuaGFzSWQgfHwge307XG5cbiAgLy8gaWYgYSBsYXllciBpcyBnb2luZyB0byBiZSByZXBsYWNlZCwgcXVldWluZyBpcyBhIHdhc3RlIG9mIHRpbWVcbiAgaWYgKGxheWVyLnJlcGxhY2VtZW50KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChlbGUpIHtcbiAgICBpZiAoaGFzSWRbZWxlLmlkKCldKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGVsZXNRLnB1c2goZWxlKTtcbiAgICBoYXNJZFtlbGUuaWQoKV0gPSB0cnVlO1xuICB9XG4gIGlmIChsYXllci5yZXFzKSB7XG4gICAgbGF5ZXIucmVxcysrO1xuICAgIHEudXBkYXRlSXRlbShsYXllcik7XG4gIH0gZWxzZSB7XG4gICAgbGF5ZXIucmVxcyA9IDE7XG4gICAgcS5wdXNoKGxheWVyKTtcbiAgfVxufTtcbkxUQ3AuZGVxdWV1ZSA9IGZ1bmN0aW9uIChweFJhdGlvKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHEgPSBzZWxmLmxheWVyc1F1ZXVlO1xuICB2YXIgZGVxZCA9IFtdO1xuICB2YXIgZWxlRGVxcyA9IDA7XG4gIHdoaWxlIChlbGVEZXFzIDwgbWF4RGVxU2l6ZSkge1xuICAgIGlmIChxLnNpemUoKSA9PT0gMCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHZhciBsYXllciA9IHEucGVlaygpO1xuXG4gICAgLy8gaWYgYSBsYXllciBoYXMgYmVlbiBvciB3aWxsIGJlIHJlcGxhY2VkLCB0aGVuIGRvbid0IHdhc3RlIHRpbWUgd2l0aCBpdFxuICAgIGlmIChsYXllci5yZXBsYWNlbWVudCkge1xuICAgICAgLy8gbG9nKCdsYXllciAlcyBpbiBxdWV1ZSBza2lwcGVkIGIvYyBpdCBhbHJlYWR5IGhhcyBhIHJlcGxhY2VtZW50JywgbGF5ZXIuaWQpO1xuICAgICAgcS5wb3AoKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIGlmIHRoaXMgaXMgYSByZXBsYWNlbWVudCBsYXllciB0aGF0IGhhcyBiZWVuIHN1cGVyY2VkZWQsIHRoZW4gZm9yZ2V0IGl0XG4gICAgaWYgKGxheWVyLnJlcGxhY2VzICYmIGxheWVyICE9PSBsYXllci5yZXBsYWNlcy5yZXBsYWNlbWVudCkge1xuICAgICAgLy8gbG9nKCdsYXllciBpcyBubyBsb25nZXIgdGhlIG1vc3QgdXB0b2RhdGUgcmVwbGFjZW1lbnQ7IGRlcXVldWVkJywgbGF5ZXIuaWQpXG4gICAgICBxLnBvcCgpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChsYXllci5pbnZhbGlkKSB7XG4gICAgICAvLyBsb2coJ3JlcGxhY2VtZW50IGxheWVyICVzIGlzIGludmFsaWQ7IGRlcXVldWVkJywgbGF5ZXIuaWQpO1xuICAgICAgcS5wb3AoKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB2YXIgZWxlID0gbGF5ZXIuZWxlc1F1ZXVlLnNoaWZ0KCk7XG4gICAgaWYgKGVsZSkge1xuICAgICAgLy8gbG9nKCdkZXF1ZXVlIGxheWVyICVzJywgbGF5ZXIuaWQpO1xuXG4gICAgICBzZWxmLmRyYXdFbGVJbkxheWVyKGxheWVyLCBlbGUsIGxheWVyLmxldmVsLCBweFJhdGlvKTtcbiAgICAgIGVsZURlcXMrKztcbiAgICB9XG4gICAgaWYgKGRlcWQubGVuZ3RoID09PSAwKSB7XG4gICAgICAvLyB3ZSBuZWVkIG9ubHkgb25lIGVudHJ5IGluIGRlcWQgdG8gcXVldWUgcmVkcmF3aW5nIGV0Y1xuICAgICAgZGVxZC5wdXNoKHRydWUpO1xuICAgIH1cblxuICAgIC8vIGlmIHRoZSBsYXllciBoYXMgYWxsIGl0cyBlbGVzIGRvbmUsIHRoZW4gcmVtb3ZlIGZyb20gdGhlIHF1ZXVlXG4gICAgaWYgKGxheWVyLmVsZXNRdWV1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgIHEucG9wKCk7XG4gICAgICBsYXllci5yZXFzID0gMDtcblxuICAgICAgLy8gbG9nKCdkZXF1ZXVlIG9mIGxheWVyICVzIGNvbXBsZXRlJywgbGF5ZXIuaWQpO1xuXG4gICAgICAvLyB3aGVuIGEgcmVwbGFjZW1lbnQgbGF5ZXIgaXMgZGVxdWV1ZWQsIGl0IHJlcGxhY2VzIHRoZSBvbGQgbGF5ZXIgaW4gdGhlIGxldmVsXG4gICAgICBpZiAobGF5ZXIucmVwbGFjZXMpIHtcbiAgICAgICAgc2VsZi5hcHBseUxheWVyUmVwbGFjZW1lbnQobGF5ZXIpO1xuICAgICAgfVxuICAgICAgc2VsZi5yZXF1ZXN0UmVkcmF3KCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBkZXFkO1xufTtcbkxUQ3AuYXBwbHlMYXllclJlcGxhY2VtZW50ID0gZnVuY3Rpb24gKGxheWVyKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIGxheWVyc0luTGV2ZWwgPSBzZWxmLmxheWVyc0J5TGV2ZWxbbGF5ZXIubGV2ZWxdO1xuICB2YXIgcmVwbGFjZWQgPSBsYXllci5yZXBsYWNlcztcbiAgdmFyIGluZGV4ID0gbGF5ZXJzSW5MZXZlbC5pbmRleE9mKHJlcGxhY2VkKTtcblxuICAvLyBpZiB0aGUgcmVwbGFjZWQgbGF5ZXIgaXMgbm90IGluIHRoZSBhY3RpdmUgbGlzdCBmb3IgdGhlIGxldmVsLCB0aGVuIHJlcGxhY2luZ1xuICAvLyByZWZzIHdvdWxkIGJlIGEgbWlzdGFrZSAoaS5lLiBvdmVyd3JpdGluZyB0aGUgdHJ1ZSBhY3RpdmUgbGF5ZXIpXG4gIGlmIChpbmRleCA8IDAgfHwgcmVwbGFjZWQuaW52YWxpZCkge1xuICAgIC8vIGxvZygncmVwbGFjZW1lbnQgbGF5ZXIgd291bGQgaGF2ZSBubyBlZmZlY3QnLCBsYXllci5pZCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGxheWVyc0luTGV2ZWxbaW5kZXhdID0gbGF5ZXI7IC8vIHJlcGxhY2UgbGV2ZWwgcmVmXG5cbiAgLy8gcmVwbGFjZSByZWZzIGluIGVsZXNcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXllci5lbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIF9wID0gbGF5ZXIuZWxlc1tpXS5fcHJpdmF0ZTtcbiAgICB2YXIgY2FjaGUgPSBfcC5pbWdMYXllckNhY2hlcyA9IF9wLmltZ0xheWVyQ2FjaGVzIHx8IHt9O1xuICAgIGlmIChjYWNoZSkge1xuICAgICAgY2FjaGVbbGF5ZXIubGV2ZWxdID0gbGF5ZXI7XG4gICAgfVxuICB9XG5cbiAgLy8gbG9nKCdhcHBseSByZXBsYWNlbWVudCBsYXllciAlcyBvdmVyICVzJywgbGF5ZXIuaWQsIHJlcGxhY2VkLmlkKTtcblxuICBzZWxmLnJlcXVlc3RSZWRyYXcoKTtcbn07XG5MVENwLnJlcXVlc3RSZWRyYXcgPSBkZWJvdW5jZV8xKGZ1bmN0aW9uICgpIHtcbiAgdmFyIHIgPSB0aGlzLnJlbmRlcmVyO1xuICByLnJlZHJhd0hpbnQoJ2VsZXMnLCB0cnVlKTtcbiAgci5yZWRyYXdIaW50KCdkcmFnJywgdHJ1ZSk7XG4gIHIucmVkcmF3KCk7XG59LCAxMDApO1xuTFRDcC5zZXR1cERlcXVldWVpbmcgPSBkZWZzLnNldHVwRGVxdWV1ZWluZyh7XG4gIGRlcVJlZHJhd1RocmVzaG9sZDogZGVxUmVkcmF3VGhyZXNob2xkLFxuICBkZXFDb3N0OiBkZXFDb3N0LFxuICBkZXFBdmdDb3N0OiBkZXFBdmdDb3N0LFxuICBkZXFOb0RyYXdDb3N0OiBkZXFOb0RyYXdDb3N0LFxuICBkZXFGYXN0Q29zdDogZGVxRmFzdENvc3QsXG4gIGRlcTogZnVuY3Rpb24gZGVxKHNlbGYsIHB4UmF0aW8pIHtcbiAgICByZXR1cm4gc2VsZi5kZXF1ZXVlKHB4UmF0aW8pO1xuICB9LFxuICBvbkRlcWQ6IG5vb3AkMSxcbiAgc2hvdWxkUmVkcmF3OiB0cnVlaWZ5LFxuICBwcmlvcml0eTogZnVuY3Rpb24gcHJpb3JpdHkoc2VsZikge1xuICAgIHJldHVybiBzZWxmLnJlbmRlcmVyLmJlZm9yZVJlbmRlclByaW9yaXRpZXMubHlyVHhyRGVxO1xuICB9XG59KTtcblxudmFyIENScCRhID0ge307XG52YXIgaW1wbDtcbmZ1bmN0aW9uIHBvbHlnb24oY29udGV4dCwgcG9pbnRzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHB0ID0gcG9pbnRzW2ldO1xuICAgIGNvbnRleHQubGluZVRvKHB0LngsIHB0LnkpO1xuICB9XG59XG5mdW5jdGlvbiB0cmlhbmdsZUJhY2tjdXJ2ZShjb250ZXh0LCBwb2ludHMsIGNvbnRyb2xQb2ludCkge1xuICB2YXIgZmlyc3RQdDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcHQgPSBwb2ludHNbaV07XG4gICAgaWYgKGkgPT09IDApIHtcbiAgICAgIGZpcnN0UHQgPSBwdDtcbiAgICB9XG4gICAgY29udGV4dC5saW5lVG8ocHQueCwgcHQueSk7XG4gIH1cbiAgY29udGV4dC5xdWFkcmF0aWNDdXJ2ZVRvKGNvbnRyb2xQb2ludC54LCBjb250cm9sUG9pbnQueSwgZmlyc3RQdC54LCBmaXJzdFB0LnkpO1xufVxuZnVuY3Rpb24gdHJpYW5nbGVUZWUoY29udGV4dCwgdHJpYW5nbGVQb2ludHMsIHRlZVBvaW50cykge1xuICBpZiAoY29udGV4dC5iZWdpblBhdGgpIHtcbiAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICB9XG4gIHZhciB0cmlQdHMgPSB0cmlhbmdsZVBvaW50cztcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmlQdHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcHQgPSB0cmlQdHNbaV07XG4gICAgY29udGV4dC5saW5lVG8ocHQueCwgcHQueSk7XG4gIH1cbiAgdmFyIHRlZVB0cyA9IHRlZVBvaW50cztcbiAgdmFyIGZpcnN0VGVlUHQgPSB0ZWVQb2ludHNbMF07XG4gIGNvbnRleHQubW92ZVRvKGZpcnN0VGVlUHQueCwgZmlyc3RUZWVQdC55KTtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCB0ZWVQdHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcHQgPSB0ZWVQdHNbaV07XG4gICAgY29udGV4dC5saW5lVG8ocHQueCwgcHQueSk7XG4gIH1cbiAgaWYgKGNvbnRleHQuY2xvc2VQYXRoKSB7XG4gICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgfVxufVxuZnVuY3Rpb24gY2lyY2xlVHJpYW5nbGUoY29udGV4dCwgdHJpYW5nbGVQb2ludHMsIHJ4LCByeSwgcikge1xuICBpZiAoY29udGV4dC5iZWdpblBhdGgpIHtcbiAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICB9XG4gIGNvbnRleHQuYXJjKHJ4LCByeSwgciwgMCwgTWF0aC5QSSAqIDIsIGZhbHNlKTtcbiAgdmFyIHRyaVB0cyA9IHRyaWFuZ2xlUG9pbnRzO1xuICB2YXIgZmlyc3RUclB0ID0gdHJpUHRzWzBdO1xuICBjb250ZXh0Lm1vdmVUbyhmaXJzdFRyUHQueCwgZmlyc3RUclB0LnkpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRyaVB0cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBwdCA9IHRyaVB0c1tpXTtcbiAgICBjb250ZXh0LmxpbmVUbyhwdC54LCBwdC55KTtcbiAgfVxuICBpZiAoY29udGV4dC5jbG9zZVBhdGgpIHtcbiAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICB9XG59XG5mdW5jdGlvbiBjaXJjbGUoY29udGV4dCwgcngsIHJ5LCByKSB7XG4gIGNvbnRleHQuYXJjKHJ4LCByeSwgciwgMCwgTWF0aC5QSSAqIDIsIGZhbHNlKTtcbn1cbkNScCRhLmFycm93U2hhcGVJbXBsID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgcmV0dXJuIChpbXBsIHx8IChpbXBsID0ge1xuICAgICdwb2x5Z29uJzogcG9seWdvbixcbiAgICAndHJpYW5nbGUtYmFja2N1cnZlJzogdHJpYW5nbGVCYWNrY3VydmUsXG4gICAgJ3RyaWFuZ2xlLXRlZSc6IHRyaWFuZ2xlVGVlLFxuICAgICdjaXJjbGUtdHJpYW5nbGUnOiBjaXJjbGVUcmlhbmdsZSxcbiAgICAndHJpYW5nbGUtY3Jvc3MnOiB0cmlhbmdsZVRlZSxcbiAgICAnY2lyY2xlJzogY2lyY2xlXG4gIH0pKVtuYW1lXTtcbn07XG5cbnZhciBDUnAkOSA9IHt9O1xuQ1JwJDkuZHJhd0VsZW1lbnQgPSBmdW5jdGlvbiAoY29udGV4dCwgZWxlLCBzaGlmdFRvT3JpZ2luV2l0aEJiLCBzaG93TGFiZWwsIHNob3dPdmVybGF5LCBzaG93T3BhY2l0eSkge1xuICB2YXIgciA9IHRoaXM7XG4gIGlmIChlbGUuaXNOb2RlKCkpIHtcbiAgICByLmRyYXdOb2RlKGNvbnRleHQsIGVsZSwgc2hpZnRUb09yaWdpbldpdGhCYiwgc2hvd0xhYmVsLCBzaG93T3ZlcmxheSwgc2hvd09wYWNpdHkpO1xuICB9IGVsc2Uge1xuICAgIHIuZHJhd0VkZ2UoY29udGV4dCwgZWxlLCBzaGlmdFRvT3JpZ2luV2l0aEJiLCBzaG93TGFiZWwsIHNob3dPdmVybGF5LCBzaG93T3BhY2l0eSk7XG4gIH1cbn07XG5DUnAkOS5kcmF3RWxlbWVudE92ZXJsYXkgPSBmdW5jdGlvbiAoY29udGV4dCwgZWxlKSB7XG4gIHZhciByID0gdGhpcztcbiAgaWYgKGVsZS5pc05vZGUoKSkge1xuICAgIHIuZHJhd05vZGVPdmVybGF5KGNvbnRleHQsIGVsZSk7XG4gIH0gZWxzZSB7XG4gICAgci5kcmF3RWRnZU92ZXJsYXkoY29udGV4dCwgZWxlKTtcbiAgfVxufTtcbkNScCQ5LmRyYXdFbGVtZW50VW5kZXJsYXkgPSBmdW5jdGlvbiAoY29udGV4dCwgZWxlKSB7XG4gIHZhciByID0gdGhpcztcbiAgaWYgKGVsZS5pc05vZGUoKSkge1xuICAgIHIuZHJhd05vZGVVbmRlcmxheShjb250ZXh0LCBlbGUpO1xuICB9IGVsc2Uge1xuICAgIHIuZHJhd0VkZ2VVbmRlcmxheShjb250ZXh0LCBlbGUpO1xuICB9XG59O1xuQ1JwJDkuZHJhd0NhY2hlZEVsZW1lbnRQb3J0aW9uID0gZnVuY3Rpb24gKGNvbnRleHQsIGVsZSwgZWxlVHhyQ2FjaGUsIHB4UmF0aW8sIGx2bCwgcmVhc29uLCBnZXRSb3RhdGlvbiwgZ2V0T3BhY2l0eSkge1xuICB2YXIgciA9IHRoaXM7XG4gIHZhciBiYiA9IGVsZVR4ckNhY2hlLmdldEJvdW5kaW5nQm94KGVsZSk7XG4gIGlmIChiYi53ID09PSAwIHx8IGJiLmggPT09IDApIHtcbiAgICByZXR1cm47XG4gIH0gLy8gaWdub3JlIHplcm8gc2l6ZSBjYXNlXG5cbiAgdmFyIGVsZUNhY2hlID0gZWxlVHhyQ2FjaGUuZ2V0RWxlbWVudChlbGUsIGJiLCBweFJhdGlvLCBsdmwsIHJlYXNvbik7XG4gIGlmIChlbGVDYWNoZSAhPSBudWxsKSB7XG4gICAgdmFyIG9wYWNpdHkgPSBnZXRPcGFjaXR5KHIsIGVsZSk7XG4gICAgaWYgKG9wYWNpdHkgPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRoZXRhID0gZ2V0Um90YXRpb24ociwgZWxlKTtcbiAgICB2YXIgeDEgPSBiYi54MSxcbiAgICAgIHkxID0gYmIueTEsXG4gICAgICB3ID0gYmIudyxcbiAgICAgIGggPSBiYi5oO1xuICAgIHZhciB4LCB5LCBzeCwgc3ksIHNtb290aDtcbiAgICBpZiAodGhldGEgIT09IDApIHtcbiAgICAgIHZhciByb3RQdCA9IGVsZVR4ckNhY2hlLmdldFJvdGF0aW9uUG9pbnQoZWxlKTtcbiAgICAgIHN4ID0gcm90UHQueDtcbiAgICAgIHN5ID0gcm90UHQueTtcbiAgICAgIGNvbnRleHQudHJhbnNsYXRlKHN4LCBzeSk7XG4gICAgICBjb250ZXh0LnJvdGF0ZSh0aGV0YSk7XG4gICAgICBzbW9vdGggPSByLmdldEltZ1Ntb290aGluZyhjb250ZXh0KTtcbiAgICAgIGlmICghc21vb3RoKSB7XG4gICAgICAgIHIuc2V0SW1nU21vb3RoaW5nKGNvbnRleHQsIHRydWUpO1xuICAgICAgfVxuICAgICAgdmFyIG9mZiA9IGVsZVR4ckNhY2hlLmdldFJvdGF0aW9uT2Zmc2V0KGVsZSk7XG4gICAgICB4ID0gb2ZmLng7XG4gICAgICB5ID0gb2ZmLnk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHggPSB4MTtcbiAgICAgIHkgPSB5MTtcbiAgICB9XG4gICAgdmFyIG9sZEdsb2JhbEFscGhhO1xuICAgIGlmIChvcGFjaXR5ICE9PSAxKSB7XG4gICAgICBvbGRHbG9iYWxBbHBoYSA9IGNvbnRleHQuZ2xvYmFsQWxwaGE7XG4gICAgICBjb250ZXh0Lmdsb2JhbEFscGhhID0gb2xkR2xvYmFsQWxwaGEgKiBvcGFjaXR5O1xuICAgIH1cbiAgICBjb250ZXh0LmRyYXdJbWFnZShlbGVDYWNoZS50ZXh0dXJlLmNhbnZhcywgZWxlQ2FjaGUueCwgMCwgZWxlQ2FjaGUud2lkdGgsIGVsZUNhY2hlLmhlaWdodCwgeCwgeSwgdywgaCk7XG4gICAgaWYgKG9wYWNpdHkgIT09IDEpIHtcbiAgICAgIGNvbnRleHQuZ2xvYmFsQWxwaGEgPSBvbGRHbG9iYWxBbHBoYTtcbiAgICB9XG4gICAgaWYgKHRoZXRhICE9PSAwKSB7XG4gICAgICBjb250ZXh0LnJvdGF0ZSgtdGhldGEpO1xuICAgICAgY29udGV4dC50cmFuc2xhdGUoLXN4LCAtc3kpO1xuICAgICAgaWYgKCFzbW9vdGgpIHtcbiAgICAgICAgci5zZXRJbWdTbW9vdGhpbmcoY29udGV4dCwgZmFsc2UpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBlbGVUeHJDYWNoZS5kcmF3RWxlbWVudChjb250ZXh0LCBlbGUpOyAvLyBkaXJlY3QgZHJhdyBmYWxsYmFja1xuICB9XG59O1xuXG52YXIgZ2V0WmVyb1JvdGF0aW9uID0gZnVuY3Rpb24gZ2V0WmVyb1JvdGF0aW9uKCkge1xuICByZXR1cm4gMDtcbn07XG52YXIgZ2V0TGFiZWxSb3RhdGlvbiA9IGZ1bmN0aW9uIGdldExhYmVsUm90YXRpb24ociwgZWxlKSB7XG4gIHJldHVybiByLmdldFRleHRBbmdsZShlbGUsIG51bGwpO1xufTtcbnZhciBnZXRTb3VyY2VMYWJlbFJvdGF0aW9uID0gZnVuY3Rpb24gZ2V0U291cmNlTGFiZWxSb3RhdGlvbihyLCBlbGUpIHtcbiAgcmV0dXJuIHIuZ2V0VGV4dEFuZ2xlKGVsZSwgJ3NvdXJjZScpO1xufTtcbnZhciBnZXRUYXJnZXRMYWJlbFJvdGF0aW9uID0gZnVuY3Rpb24gZ2V0VGFyZ2V0TGFiZWxSb3RhdGlvbihyLCBlbGUpIHtcbiAgcmV0dXJuIHIuZ2V0VGV4dEFuZ2xlKGVsZSwgJ3RhcmdldCcpO1xufTtcbnZhciBnZXRPcGFjaXR5ID0gZnVuY3Rpb24gZ2V0T3BhY2l0eShyLCBlbGUpIHtcbiAgcmV0dXJuIGVsZS5lZmZlY3RpdmVPcGFjaXR5KCk7XG59O1xudmFyIGdldFRleHRPcGFjaXR5ID0gZnVuY3Rpb24gZ2V0VGV4dE9wYWNpdHkoZSwgZWxlKSB7XG4gIHJldHVybiBlbGUucHN0eWxlKCd0ZXh0LW9wYWNpdHknKS5wZlZhbHVlICogZWxlLmVmZmVjdGl2ZU9wYWNpdHkoKTtcbn07XG5DUnAkOS5kcmF3Q2FjaGVkRWxlbWVudCA9IGZ1bmN0aW9uIChjb250ZXh0LCBlbGUsIHB4UmF0aW8sIGV4dGVudCwgbHZsLCByZXF1ZXN0SGlnaFF1YWxpdHkpIHtcbiAgdmFyIHIgPSB0aGlzO1xuICB2YXIgX3IkZGF0YSA9IHIuZGF0YSxcbiAgICBlbGVUeHJDYWNoZSA9IF9yJGRhdGEuZWxlVHhyQ2FjaGUsXG4gICAgbGJsVHhyQ2FjaGUgPSBfciRkYXRhLmxibFR4ckNhY2hlLFxuICAgIHNsYlR4ckNhY2hlID0gX3IkZGF0YS5zbGJUeHJDYWNoZSxcbiAgICB0bGJUeHJDYWNoZSA9IF9yJGRhdGEudGxiVHhyQ2FjaGU7XG4gIHZhciBiYiA9IGVsZS5ib3VuZGluZ0JveCgpO1xuICB2YXIgcmVhc29uID0gcmVxdWVzdEhpZ2hRdWFsaXR5ID09PSB0cnVlID8gZWxlVHhyQ2FjaGUucmVhc29ucy5oaWdoUXVhbGl0eSA6IG51bGw7XG4gIGlmIChiYi53ID09PSAwIHx8IGJiLmggPT09IDAgfHwgIWVsZS52aXNpYmxlKCkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKCFleHRlbnQgfHwgYm91bmRpbmdCb3hlc0ludGVyc2VjdChiYiwgZXh0ZW50KSkge1xuICAgIHZhciBpc0VkZ2UgPSBlbGUuaXNFZGdlKCk7XG4gICAgdmFyIGJhZExpbmUgPSBlbGUuZWxlbWVudCgpLl9wcml2YXRlLnJzY3JhdGNoLmJhZExpbmU7XG4gICAgci5kcmF3RWxlbWVudFVuZGVybGF5KGNvbnRleHQsIGVsZSk7XG4gICAgci5kcmF3Q2FjaGVkRWxlbWVudFBvcnRpb24oY29udGV4dCwgZWxlLCBlbGVUeHJDYWNoZSwgcHhSYXRpbywgbHZsLCByZWFzb24sIGdldFplcm9Sb3RhdGlvbiwgZ2V0T3BhY2l0eSk7XG4gICAgaWYgKCFpc0VkZ2UgfHwgIWJhZExpbmUpIHtcbiAgICAgIHIuZHJhd0NhY2hlZEVsZW1lbnRQb3J0aW9uKGNvbnRleHQsIGVsZSwgbGJsVHhyQ2FjaGUsIHB4UmF0aW8sIGx2bCwgcmVhc29uLCBnZXRMYWJlbFJvdGF0aW9uLCBnZXRUZXh0T3BhY2l0eSk7XG4gICAgfVxuICAgIGlmIChpc0VkZ2UgJiYgIWJhZExpbmUpIHtcbiAgICAgIHIuZHJhd0NhY2hlZEVsZW1lbnRQb3J0aW9uKGNvbnRleHQsIGVsZSwgc2xiVHhyQ2FjaGUsIHB4UmF0aW8sIGx2bCwgcmVhc29uLCBnZXRTb3VyY2VMYWJlbFJvdGF0aW9uLCBnZXRUZXh0T3BhY2l0eSk7XG4gICAgICByLmRyYXdDYWNoZWRFbGVtZW50UG9ydGlvbihjb250ZXh0LCBlbGUsIHRsYlR4ckNhY2hlLCBweFJhdGlvLCBsdmwsIHJlYXNvbiwgZ2V0VGFyZ2V0TGFiZWxSb3RhdGlvbiwgZ2V0VGV4dE9wYWNpdHkpO1xuICAgIH1cbiAgICByLmRyYXdFbGVtZW50T3ZlcmxheShjb250ZXh0LCBlbGUpO1xuICB9XG59O1xuQ1JwJDkuZHJhd0VsZW1lbnRzID0gZnVuY3Rpb24gKGNvbnRleHQsIGVsZXMpIHtcbiAgdmFyIHIgPSB0aGlzO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZWxlID0gZWxlc1tpXTtcbiAgICByLmRyYXdFbGVtZW50KGNvbnRleHQsIGVsZSk7XG4gIH1cbn07XG5DUnAkOS5kcmF3Q2FjaGVkRWxlbWVudHMgPSBmdW5jdGlvbiAoY29udGV4dCwgZWxlcywgcHhSYXRpbywgZXh0ZW50KSB7XG4gIHZhciByID0gdGhpcztcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGVsZSA9IGVsZXNbaV07XG4gICAgci5kcmF3Q2FjaGVkRWxlbWVudChjb250ZXh0LCBlbGUsIHB4UmF0aW8sIGV4dGVudCk7XG4gIH1cbn07XG5DUnAkOS5kcmF3Q2FjaGVkTm9kZXMgPSBmdW5jdGlvbiAoY29udGV4dCwgZWxlcywgcHhSYXRpbywgZXh0ZW50KSB7XG4gIHZhciByID0gdGhpcztcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGVsZSA9IGVsZXNbaV07XG4gICAgaWYgKCFlbGUuaXNOb2RlKCkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICByLmRyYXdDYWNoZWRFbGVtZW50KGNvbnRleHQsIGVsZSwgcHhSYXRpbywgZXh0ZW50KTtcbiAgfVxufTtcbkNScCQ5LmRyYXdMYXllcmVkRWxlbWVudHMgPSBmdW5jdGlvbiAoY29udGV4dCwgZWxlcywgcHhSYXRpbywgZXh0ZW50KSB7XG4gIHZhciByID0gdGhpcztcbiAgdmFyIGxheWVycyA9IHIuZGF0YS5seXJUeHJDYWNoZS5nZXRMYXllcnMoZWxlcywgcHhSYXRpbyk7XG4gIGlmIChsYXllcnMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxheWVycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGxheWVyID0gbGF5ZXJzW2ldO1xuICAgICAgdmFyIGJiID0gbGF5ZXIuYmI7XG4gICAgICBpZiAoYmIudyA9PT0gMCB8fCBiYi5oID09PSAwKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29udGV4dC5kcmF3SW1hZ2UobGF5ZXIuY2FudmFzLCBiYi54MSwgYmIueTEsIGJiLncsIGJiLmgpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBmYWxsIGJhY2sgb24gcGxhaW4gY2FjaGluZyBpZiBubyBsYXllcnNcbiAgICByLmRyYXdDYWNoZWRFbGVtZW50cyhjb250ZXh0LCBlbGVzLCBweFJhdGlvLCBleHRlbnQpO1xuICB9XG59O1xuXG52YXIgQ1JwJDggPSB7fTtcbkNScCQ4LmRyYXdFZGdlID0gZnVuY3Rpb24gKGNvbnRleHQsIGVkZ2UsIHNoaWZ0VG9PcmlnaW5XaXRoQmIpIHtcbiAgdmFyIGRyYXdMYWJlbCA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogdHJ1ZTtcbiAgdmFyIHNob3VsZERyYXdPdmVybGF5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgJiYgYXJndW1lbnRzWzRdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNF0gOiB0cnVlO1xuICB2YXIgc2hvdWxkRHJhd09wYWNpdHkgPSBhcmd1bWVudHMubGVuZ3RoID4gNSAmJiBhcmd1bWVudHNbNV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s1XSA6IHRydWU7XG4gIHZhciByID0gdGhpcztcbiAgdmFyIHJzID0gZWRnZS5fcHJpdmF0ZS5yc2NyYXRjaDtcbiAgaWYgKHNob3VsZERyYXdPcGFjaXR5ICYmICFlZGdlLnZpc2libGUoKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIGlmIGJlemllciBjdHJsIHB0cyBjYW4gbm90IGJlIGNhbGN1bGF0ZWQsIHRoZW4gZGllXG4gIGlmIChycy5iYWRMaW5lIHx8IHJzLmFsbHB0cyA9PSBudWxsIHx8IGlzTmFOKHJzLmFsbHB0c1swXSkpIHtcbiAgICAvLyBpc05hTiBpbiBjYXNlIGVkZ2UgaXMgaW1wb3NzaWJsZSBhbmQgYnJvd3NlciBidWdzIChlLmcuIHNhZmFyaSlcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIGJiO1xuICBpZiAoc2hpZnRUb09yaWdpbldpdGhCYikge1xuICAgIGJiID0gc2hpZnRUb09yaWdpbldpdGhCYjtcbiAgICBjb250ZXh0LnRyYW5zbGF0ZSgtYmIueDEsIC1iYi55MSk7XG4gIH1cbiAgdmFyIG9wYWNpdHkgPSBzaG91bGREcmF3T3BhY2l0eSA/IGVkZ2UucHN0eWxlKCdvcGFjaXR5JykudmFsdWUgOiAxO1xuICB2YXIgbGluZU9wYWNpdHkgPSBzaG91bGREcmF3T3BhY2l0eSA/IGVkZ2UucHN0eWxlKCdsaW5lLW9wYWNpdHknKS52YWx1ZSA6IDE7XG4gIHZhciBjdXJ2ZVN0eWxlID0gZWRnZS5wc3R5bGUoJ2N1cnZlLXN0eWxlJykudmFsdWU7XG4gIHZhciBsaW5lU3R5bGUgPSBlZGdlLnBzdHlsZSgnbGluZS1zdHlsZScpLnZhbHVlO1xuICB2YXIgZWRnZVdpZHRoID0gZWRnZS5wc3R5bGUoJ3dpZHRoJykucGZWYWx1ZTtcbiAgdmFyIGxpbmVDYXAgPSBlZGdlLnBzdHlsZSgnbGluZS1jYXAnKS52YWx1ZTtcbiAgdmFyIGxpbmVPdXRsaW5lV2lkdGggPSBlZGdlLnBzdHlsZSgnbGluZS1vdXRsaW5lLXdpZHRoJykudmFsdWU7XG4gIHZhciBsaW5lT3V0bGluZUNvbG9yID0gZWRnZS5wc3R5bGUoJ2xpbmUtb3V0bGluZS1jb2xvcicpLnZhbHVlO1xuICB2YXIgZWZmZWN0aXZlTGluZU9wYWNpdHkgPSBvcGFjaXR5ICogbGluZU9wYWNpdHk7XG4gIC8vIHNlcGFyYXRlIGFycm93IG9wYWNpdHkgd291bGQgcmVxdWlyZSBhcnJvdy1vcGFjaXR5IHByb3BlcnR5XG4gIHZhciBlZmZlY3RpdmVBcnJvd09wYWNpdHkgPSBvcGFjaXR5ICogbGluZU9wYWNpdHk7XG4gIHZhciBkcmF3TGluZSA9IGZ1bmN0aW9uIGRyYXdMaW5lKCkge1xuICAgIHZhciBzdHJva2VPcGFjaXR5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBlZmZlY3RpdmVMaW5lT3BhY2l0eTtcbiAgICBpZiAoY3VydmVTdHlsZSA9PT0gJ3N0cmFpZ2h0LXRyaWFuZ2xlJykge1xuICAgICAgci5lbGVTdHJva2VTdHlsZShjb250ZXh0LCBlZGdlLCBzdHJva2VPcGFjaXR5KTtcbiAgICAgIHIuZHJhd0VkZ2VUcmlhbmdsZVBhdGgoZWRnZSwgY29udGV4dCwgcnMuYWxscHRzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGV4dC5saW5lV2lkdGggPSBlZGdlV2lkdGg7XG4gICAgICBjb250ZXh0LmxpbmVDYXAgPSBsaW5lQ2FwO1xuICAgICAgci5lbGVTdHJva2VTdHlsZShjb250ZXh0LCBlZGdlLCBzdHJva2VPcGFjaXR5KTtcbiAgICAgIHIuZHJhd0VkZ2VQYXRoKGVkZ2UsIGNvbnRleHQsIHJzLmFsbHB0cywgbGluZVN0eWxlKTtcbiAgICAgIGNvbnRleHQubGluZUNhcCA9ICdidXR0JzsgLy8gcmVzZXQgZm9yIG90aGVyIGRyYXdpbmcgZnVuY3Rpb25zXG4gICAgfVxuICB9O1xuXG4gIHZhciBkcmF3TGluZU91dGxpbmUgPSBmdW5jdGlvbiBkcmF3TGluZU91dGxpbmUoKSB7XG4gICAgdmFyIHN0cm9rZU9wYWNpdHkgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IGVmZmVjdGl2ZUxpbmVPcGFjaXR5O1xuICAgIGNvbnRleHQubGluZVdpZHRoID0gZWRnZVdpZHRoICsgbGluZU91dGxpbmVXaWR0aDtcbiAgICBjb250ZXh0LmxpbmVDYXAgPSBsaW5lQ2FwO1xuICAgIGlmIChsaW5lT3V0bGluZVdpZHRoID4gMCkge1xuICAgICAgci5jb2xvclN0cm9rZVN0eWxlKGNvbnRleHQsIGxpbmVPdXRsaW5lQ29sb3JbMF0sIGxpbmVPdXRsaW5lQ29sb3JbMV0sIGxpbmVPdXRsaW5lQ29sb3JbMl0sIHN0cm9rZU9wYWNpdHkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBkbyBub3QgZHJhdyBhbnkgbGluZU91dGxpbmVcbiAgICAgIGNvbnRleHQubGluZUNhcCA9ICdidXR0JzsgLy8gcmVzZXQgZm9yIG90aGVyIGRyYXdpbmcgZnVuY3Rpb25zXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChjdXJ2ZVN0eWxlID09PSAnc3RyYWlnaHQtdHJpYW5nbGUnKSB7XG4gICAgICByLmRyYXdFZGdlVHJpYW5nbGVQYXRoKGVkZ2UsIGNvbnRleHQsIHJzLmFsbHB0cyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHIuZHJhd0VkZ2VQYXRoKGVkZ2UsIGNvbnRleHQsIHJzLmFsbHB0cywgbGluZVN0eWxlKTtcbiAgICAgIGNvbnRleHQubGluZUNhcCA9ICdidXR0JzsgLy8gcmVzZXQgZm9yIG90aGVyIGRyYXdpbmcgZnVuY3Rpb25zXG4gICAgfVxuICB9O1xuXG4gIHZhciBkcmF3T3ZlcmxheSA9IGZ1bmN0aW9uIGRyYXdPdmVybGF5KCkge1xuICAgIGlmICghc2hvdWxkRHJhd092ZXJsYXkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgci5kcmF3RWRnZU92ZXJsYXkoY29udGV4dCwgZWRnZSk7XG4gIH07XG4gIHZhciBkcmF3VW5kZXJsYXkgPSBmdW5jdGlvbiBkcmF3VW5kZXJsYXkoKSB7XG4gICAgaWYgKCFzaG91bGREcmF3T3ZlcmxheSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByLmRyYXdFZGdlVW5kZXJsYXkoY29udGV4dCwgZWRnZSk7XG4gIH07XG4gIHZhciBkcmF3QXJyb3dzID0gZnVuY3Rpb24gZHJhd0Fycm93cygpIHtcbiAgICB2YXIgYXJyb3dPcGFjaXR5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBlZmZlY3RpdmVBcnJvd09wYWNpdHk7XG4gICAgci5kcmF3QXJyb3doZWFkcyhjb250ZXh0LCBlZGdlLCBhcnJvd09wYWNpdHkpO1xuICB9O1xuICB2YXIgZHJhd1RleHQgPSBmdW5jdGlvbiBkcmF3VGV4dCgpIHtcbiAgICByLmRyYXdFbGVtZW50VGV4dChjb250ZXh0LCBlZGdlLCBudWxsLCBkcmF3TGFiZWwpO1xuICB9O1xuICBjb250ZXh0LmxpbmVKb2luID0gJ3JvdW5kJztcbiAgdmFyIGdob3N0ID0gZWRnZS5wc3R5bGUoJ2dob3N0JykudmFsdWUgPT09ICd5ZXMnO1xuICBpZiAoZ2hvc3QpIHtcbiAgICB2YXIgZ3ggPSBlZGdlLnBzdHlsZSgnZ2hvc3Qtb2Zmc2V0LXgnKS5wZlZhbHVlO1xuICAgIHZhciBneSA9IGVkZ2UucHN0eWxlKCdnaG9zdC1vZmZzZXQteScpLnBmVmFsdWU7XG4gICAgdmFyIGdob3N0T3BhY2l0eSA9IGVkZ2UucHN0eWxlKCdnaG9zdC1vcGFjaXR5JykudmFsdWU7XG4gICAgdmFyIGVmZmVjdGl2ZUdob3N0T3BhY2l0eSA9IGVmZmVjdGl2ZUxpbmVPcGFjaXR5ICogZ2hvc3RPcGFjaXR5O1xuICAgIGNvbnRleHQudHJhbnNsYXRlKGd4LCBneSk7XG4gICAgZHJhd0xpbmUoZWZmZWN0aXZlR2hvc3RPcGFjaXR5KTtcbiAgICBkcmF3QXJyb3dzKGVmZmVjdGl2ZUdob3N0T3BhY2l0eSk7XG4gICAgY29udGV4dC50cmFuc2xhdGUoLWd4LCAtZ3kpO1xuICB9IGVsc2Uge1xuICAgIGRyYXdMaW5lT3V0bGluZSgpO1xuICB9XG4gIGRyYXdVbmRlcmxheSgpO1xuICBkcmF3TGluZSgpO1xuICBkcmF3QXJyb3dzKCk7XG4gIGRyYXdPdmVybGF5KCk7XG4gIGRyYXdUZXh0KCk7XG4gIGlmIChzaGlmdFRvT3JpZ2luV2l0aEJiKSB7XG4gICAgY29udGV4dC50cmFuc2xhdGUoYmIueDEsIGJiLnkxKTtcbiAgfVxufTtcbnZhciBkcmF3RWRnZU92ZXJsYXlVbmRlcmxheSA9IGZ1bmN0aW9uIGRyYXdFZGdlT3ZlcmxheVVuZGVybGF5KG92ZXJsYXlPclVuZGVybGF5KSB7XG4gIGlmICghWydvdmVybGF5JywgJ3VuZGVybGF5J10uaW5jbHVkZXMob3ZlcmxheU9yVW5kZXJsYXkpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN0YXRlJyk7XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uIChjb250ZXh0LCBlZGdlKSB7XG4gICAgaWYgKCFlZGdlLnZpc2libGUoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgb3BhY2l0eSA9IGVkZ2UucHN0eWxlKFwiXCIuY29uY2F0KG92ZXJsYXlPclVuZGVybGF5LCBcIi1vcGFjaXR5XCIpKS52YWx1ZTtcbiAgICBpZiAob3BhY2l0eSA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgciA9IHRoaXM7XG4gICAgdmFyIHVzZVBhdGhzID0gci51c2VQYXRocygpO1xuICAgIHZhciBycyA9IGVkZ2UuX3ByaXZhdGUucnNjcmF0Y2g7XG4gICAgdmFyIHBhZGRpbmcgPSBlZGdlLnBzdHlsZShcIlwiLmNvbmNhdChvdmVybGF5T3JVbmRlcmxheSwgXCItcGFkZGluZ1wiKSkucGZWYWx1ZTtcbiAgICB2YXIgd2lkdGggPSAyICogcGFkZGluZztcbiAgICB2YXIgY29sb3IgPSBlZGdlLnBzdHlsZShcIlwiLmNvbmNhdChvdmVybGF5T3JVbmRlcmxheSwgXCItY29sb3JcIikpLnZhbHVlO1xuICAgIGNvbnRleHQubGluZVdpZHRoID0gd2lkdGg7XG4gICAgaWYgKHJzLmVkZ2VUeXBlID09PSAnc2VsZicgJiYgIXVzZVBhdGhzKSB7XG4gICAgICBjb250ZXh0LmxpbmVDYXAgPSAnYnV0dCc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnRleHQubGluZUNhcCA9ICdyb3VuZCc7XG4gICAgfVxuICAgIHIuY29sb3JTdHJva2VTdHlsZShjb250ZXh0LCBjb2xvclswXSwgY29sb3JbMV0sIGNvbG9yWzJdLCBvcGFjaXR5KTtcbiAgICByLmRyYXdFZGdlUGF0aChlZGdlLCBjb250ZXh0LCBycy5hbGxwdHMsICdzb2xpZCcpO1xuICB9O1xufTtcbkNScCQ4LmRyYXdFZGdlT3ZlcmxheSA9IGRyYXdFZGdlT3ZlcmxheVVuZGVybGF5KCdvdmVybGF5Jyk7XG5DUnAkOC5kcmF3RWRnZVVuZGVybGF5ID0gZHJhd0VkZ2VPdmVybGF5VW5kZXJsYXkoJ3VuZGVybGF5Jyk7XG5DUnAkOC5kcmF3RWRnZVBhdGggPSBmdW5jdGlvbiAoZWRnZSwgY29udGV4dCwgcHRzLCB0eXBlKSB7XG4gIHZhciBycyA9IGVkZ2UuX3ByaXZhdGUucnNjcmF0Y2g7XG4gIHZhciBjYW52YXNDeHQgPSBjb250ZXh0O1xuICB2YXIgcGF0aDtcbiAgdmFyIHBhdGhDYWNoZUhpdCA9IGZhbHNlO1xuICB2YXIgdXNlUGF0aHMgPSB0aGlzLnVzZVBhdGhzKCk7XG4gIHZhciBsaW5lRGFzaFBhdHRlcm4gPSBlZGdlLnBzdHlsZSgnbGluZS1kYXNoLXBhdHRlcm4nKS5wZlZhbHVlO1xuICB2YXIgbGluZURhc2hPZmZzZXQgPSBlZGdlLnBzdHlsZSgnbGluZS1kYXNoLW9mZnNldCcpLnBmVmFsdWU7XG4gIGlmICh1c2VQYXRocykge1xuICAgIHZhciBwYXRoQ2FjaGVLZXkgPSBwdHMuam9pbignJCcpO1xuICAgIHZhciBrZXlNYXRjaGVzID0gcnMucGF0aENhY2hlS2V5ICYmIHJzLnBhdGhDYWNoZUtleSA9PT0gcGF0aENhY2hlS2V5O1xuICAgIGlmIChrZXlNYXRjaGVzKSB7XG4gICAgICBwYXRoID0gY29udGV4dCA9IHJzLnBhdGhDYWNoZTtcbiAgICAgIHBhdGhDYWNoZUhpdCA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhdGggPSBjb250ZXh0ID0gbmV3IFBhdGgyRCgpO1xuICAgICAgcnMucGF0aENhY2hlS2V5ID0gcGF0aENhY2hlS2V5O1xuICAgICAgcnMucGF0aENhY2hlID0gcGF0aDtcbiAgICB9XG4gIH1cbiAgaWYgKGNhbnZhc0N4dC5zZXRMaW5lRGFzaCkge1xuICAgIC8vIGZvciB2ZXJ5IG91dG9mZGF0ZSBicm93c2Vyc1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSAnZG90dGVkJzpcbiAgICAgICAgY2FudmFzQ3h0LnNldExpbmVEYXNoKFsxLCAxXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnZGFzaGVkJzpcbiAgICAgICAgY2FudmFzQ3h0LnNldExpbmVEYXNoKGxpbmVEYXNoUGF0dGVybik7XG4gICAgICAgIGNhbnZhc0N4dC5saW5lRGFzaE9mZnNldCA9IGxpbmVEYXNoT2Zmc2V0O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3NvbGlkJzpcbiAgICAgICAgY2FudmFzQ3h0LnNldExpbmVEYXNoKFtdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIGlmICghcGF0aENhY2hlSGl0ICYmICFycy5iYWRMaW5lKSB7XG4gICAgaWYgKGNvbnRleHQuYmVnaW5QYXRoKSB7XG4gICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgIH1cbiAgICBjb250ZXh0Lm1vdmVUbyhwdHNbMF0sIHB0c1sxXSk7XG4gICAgc3dpdGNoIChycy5lZGdlVHlwZSkge1xuICAgICAgY2FzZSAnYmV6aWVyJzpcbiAgICAgIGNhc2UgJ3NlbGYnOlxuICAgICAgY2FzZSAnY29tcG91bmQnOlxuICAgICAgY2FzZSAnbXVsdGliZXppZXInOlxuICAgICAgICBmb3IgKHZhciBpID0gMjsgaSArIDMgPCBwdHMubGVuZ3RoOyBpICs9IDQpIHtcbiAgICAgICAgICBjb250ZXh0LnF1YWRyYXRpY0N1cnZlVG8ocHRzW2ldLCBwdHNbaSArIDFdLCBwdHNbaSArIDJdLCBwdHNbaSArIDNdKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3N0cmFpZ2h0JzpcbiAgICAgIGNhc2UgJ2hheXN0YWNrJzpcbiAgICAgICAgZm9yICh2YXIgX2kgPSAyOyBfaSArIDEgPCBwdHMubGVuZ3RoOyBfaSArPSAyKSB7XG4gICAgICAgICAgY29udGV4dC5saW5lVG8ocHRzW19pXSwgcHRzW19pICsgMV0pO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnc2VnbWVudHMnOlxuICAgICAgICBpZiAocnMuaXNSb3VuZCkge1xuICAgICAgICAgIHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihycy5yb3VuZENvcm5lcnMpLFxuICAgICAgICAgICAgX3N0ZXA7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgICAgIHZhciBjb3JuZXIgPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgICAgICAgZHJhd1ByZXBhcmVkUm91bmRDb3JuZXIoY29udGV4dCwgY29ybmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIF9pdGVyYXRvci5lKGVycik7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIF9pdGVyYXRvci5mKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRleHQubGluZVRvKHB0c1twdHMubGVuZ3RoIC0gMl0sIHB0c1twdHMubGVuZ3RoIC0gMV0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZvciAodmFyIF9pMiA9IDI7IF9pMiArIDEgPCBwdHMubGVuZ3RoOyBfaTIgKz0gMikge1xuICAgICAgICAgICAgY29udGV4dC5saW5lVG8ocHRzW19pMl0sIHB0c1tfaTIgKyAxXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBjb250ZXh0ID0gY2FudmFzQ3h0O1xuICBpZiAodXNlUGF0aHMpIHtcbiAgICBjb250ZXh0LnN0cm9rZShwYXRoKTtcbiAgfSBlbHNlIHtcbiAgICBjb250ZXh0LnN0cm9rZSgpO1xuICB9XG5cbiAgLy8gcmVzZXQgYW55IGxpbmUgZGFzaGVzXG4gIGlmIChjb250ZXh0LnNldExpbmVEYXNoKSB7XG4gICAgLy8gZm9yIHZlcnkgb3V0b2ZkYXRlIGJyb3dzZXJzXG4gICAgY29udGV4dC5zZXRMaW5lRGFzaChbXSk7XG4gIH1cbn07XG5DUnAkOC5kcmF3RWRnZVRyaWFuZ2xlUGF0aCA9IGZ1bmN0aW9uIChlZGdlLCBjb250ZXh0LCBwdHMpIHtcbiAgLy8gdXNlIGxpbmUgc3Ryb2tlIHN0eWxlIGZvciB0cmlhbmdsZSBmaWxsIHN0eWxlXG4gIGNvbnRleHQuZmlsbFN0eWxlID0gY29udGV4dC5zdHJva2VTdHlsZTtcbiAgdmFyIGVkZ2VXaWR0aCA9IGVkZ2UucHN0eWxlKCd3aWR0aCcpLnBmVmFsdWU7XG4gIGZvciAodmFyIGkgPSAwOyBpICsgMSA8IHB0cy5sZW5ndGg7IGkgKz0gMikge1xuICAgIHZhciB2ZWN0b3IgPSBbcHRzW2kgKyAyXSAtIHB0c1tpXSwgcHRzW2kgKyAzXSAtIHB0c1tpICsgMV1dO1xuICAgIHZhciBsZW5ndGggPSBNYXRoLnNxcnQodmVjdG9yWzBdICogdmVjdG9yWzBdICsgdmVjdG9yWzFdICogdmVjdG9yWzFdKTtcbiAgICB2YXIgbm9ybWFsID0gW3ZlY3RvclsxXSAvIGxlbmd0aCwgLXZlY3RvclswXSAvIGxlbmd0aF07XG4gICAgdmFyIHRyaWFuZ2xlSGVhZCA9IFtub3JtYWxbMF0gKiBlZGdlV2lkdGggLyAyLCBub3JtYWxbMV0gKiBlZGdlV2lkdGggLyAyXTtcbiAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgIGNvbnRleHQubW92ZVRvKHB0c1tpXSAtIHRyaWFuZ2xlSGVhZFswXSwgcHRzW2kgKyAxXSAtIHRyaWFuZ2xlSGVhZFsxXSk7XG4gICAgY29udGV4dC5saW5lVG8ocHRzW2ldICsgdHJpYW5nbGVIZWFkWzBdLCBwdHNbaSArIDFdICsgdHJpYW5nbGVIZWFkWzFdKTtcbiAgICBjb250ZXh0LmxpbmVUbyhwdHNbaSArIDJdLCBwdHNbaSArIDNdKTtcbiAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgIGNvbnRleHQuZmlsbCgpO1xuICB9XG59O1xuQ1JwJDguZHJhd0Fycm93aGVhZHMgPSBmdW5jdGlvbiAoY29udGV4dCwgZWRnZSwgb3BhY2l0eSkge1xuICB2YXIgcnMgPSBlZGdlLl9wcml2YXRlLnJzY3JhdGNoO1xuICB2YXIgaXNIYXlzdGFjayA9IHJzLmVkZ2VUeXBlID09PSAnaGF5c3RhY2snO1xuICBpZiAoIWlzSGF5c3RhY2spIHtcbiAgICB0aGlzLmRyYXdBcnJvd2hlYWQoY29udGV4dCwgZWRnZSwgJ3NvdXJjZScsIHJzLmFycm93U3RhcnRYLCBycy5hcnJvd1N0YXJ0WSwgcnMuc3JjQXJyb3dBbmdsZSwgb3BhY2l0eSk7XG4gIH1cbiAgdGhpcy5kcmF3QXJyb3doZWFkKGNvbnRleHQsIGVkZ2UsICdtaWQtdGFyZ2V0JywgcnMubWlkWCwgcnMubWlkWSwgcnMubWlkdGd0QXJyb3dBbmdsZSwgb3BhY2l0eSk7XG4gIHRoaXMuZHJhd0Fycm93aGVhZChjb250ZXh0LCBlZGdlLCAnbWlkLXNvdXJjZScsIHJzLm1pZFgsIHJzLm1pZFksIHJzLm1pZHNyY0Fycm93QW5nbGUsIG9wYWNpdHkpO1xuICBpZiAoIWlzSGF5c3RhY2spIHtcbiAgICB0aGlzLmRyYXdBcnJvd2hlYWQoY29udGV4dCwgZWRnZSwgJ3RhcmdldCcsIHJzLmFycm93RW5kWCwgcnMuYXJyb3dFbmRZLCBycy50Z3RBcnJvd0FuZ2xlLCBvcGFjaXR5KTtcbiAgfVxufTtcbkNScCQ4LmRyYXdBcnJvd2hlYWQgPSBmdW5jdGlvbiAoY29udGV4dCwgZWRnZSwgcHJlZml4LCB4LCB5LCBhbmdsZSwgb3BhY2l0eSkge1xuICBpZiAoaXNOYU4oeCkgfHwgeCA9PSBudWxsIHx8IGlzTmFOKHkpIHx8IHkgPT0gbnVsbCB8fCBpc05hTihhbmdsZSkgfHwgYW5nbGUgPT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBhcnJvd1NoYXBlID0gZWRnZS5wc3R5bGUocHJlZml4ICsgJy1hcnJvdy1zaGFwZScpLnZhbHVlO1xuICBpZiAoYXJyb3dTaGFwZSA9PT0gJ25vbmUnKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBhcnJvd0NsZWFyRmlsbCA9IGVkZ2UucHN0eWxlKHByZWZpeCArICctYXJyb3ctZmlsbCcpLnZhbHVlID09PSAnaG9sbG93JyA/ICdib3RoJyA6ICdmaWxsZWQnO1xuICB2YXIgYXJyb3dGaWxsID0gZWRnZS5wc3R5bGUocHJlZml4ICsgJy1hcnJvdy1maWxsJykudmFsdWU7XG4gIHZhciBlZGdlV2lkdGggPSBlZGdlLnBzdHlsZSgnd2lkdGgnKS5wZlZhbHVlO1xuICB2YXIgcEFycm93V2lkdGggPSBlZGdlLnBzdHlsZShwcmVmaXggKyAnLWFycm93LXdpZHRoJyk7XG4gIHZhciBhcnJvd1dpZHRoID0gcEFycm93V2lkdGgudmFsdWUgPT09ICdtYXRjaC1saW5lJyA/IGVkZ2VXaWR0aCA6IHBBcnJvd1dpZHRoLnBmVmFsdWU7XG4gIGlmIChwQXJyb3dXaWR0aC51bml0cyA9PT0gJyUnKSBhcnJvd1dpZHRoICo9IGVkZ2VXaWR0aDtcbiAgdmFyIGVkZ2VPcGFjaXR5ID0gZWRnZS5wc3R5bGUoJ29wYWNpdHknKS52YWx1ZTtcbiAgaWYgKG9wYWNpdHkgPT09IHVuZGVmaW5lZCkge1xuICAgIG9wYWNpdHkgPSBlZGdlT3BhY2l0eTtcbiAgfVxuICB2YXIgZ2NvID0gY29udGV4dC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb247XG4gIGlmIChvcGFjaXR5ICE9PSAxIHx8IGFycm93RmlsbCA9PT0gJ2hvbGxvdycpIHtcbiAgICAvLyB0aGVuIGV4dHJhIGNsZWFyIGlzIG5lZWRlZFxuICAgIGNvbnRleHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gJ2Rlc3RpbmF0aW9uLW91dCc7XG4gICAgc2VsZi5jb2xvckZpbGxTdHlsZShjb250ZXh0LCAyNTUsIDI1NSwgMjU1LCAxKTtcbiAgICBzZWxmLmNvbG9yU3Ryb2tlU3R5bGUoY29udGV4dCwgMjU1LCAyNTUsIDI1NSwgMSk7XG4gICAgc2VsZi5kcmF3QXJyb3dTaGFwZShlZGdlLCBjb250ZXh0LCBhcnJvd0NsZWFyRmlsbCwgZWRnZVdpZHRoLCBhcnJvd1NoYXBlLCBhcnJvd1dpZHRoLCB4LCB5LCBhbmdsZSk7XG4gICAgY29udGV4dC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBnY287XG4gIH0gLy8gb3RoZXJ3aXNlLCB0aGUgb3BhcXVlIGFycm93IGNsZWFycyBpdCBmb3IgZnJlZSA6KVxuXG4gIHZhciBjb2xvciA9IGVkZ2UucHN0eWxlKHByZWZpeCArICctYXJyb3ctY29sb3InKS52YWx1ZTtcbiAgc2VsZi5jb2xvckZpbGxTdHlsZShjb250ZXh0LCBjb2xvclswXSwgY29sb3JbMV0sIGNvbG9yWzJdLCBvcGFjaXR5KTtcbiAgc2VsZi5jb2xvclN0cm9rZVN0eWxlKGNvbnRleHQsIGNvbG9yWzBdLCBjb2xvclsxXSwgY29sb3JbMl0sIG9wYWNpdHkpO1xuICBzZWxmLmRyYXdBcnJvd1NoYXBlKGVkZ2UsIGNvbnRleHQsIGFycm93RmlsbCwgZWRnZVdpZHRoLCBhcnJvd1NoYXBlLCBhcnJvd1dpZHRoLCB4LCB5LCBhbmdsZSk7XG59O1xuQ1JwJDguZHJhd0Fycm93U2hhcGUgPSBmdW5jdGlvbiAoZWRnZSwgY29udGV4dCwgZmlsbCwgZWRnZVdpZHRoLCBzaGFwZSwgc2hhcGVXaWR0aCwgeCwgeSwgYW5nbGUpIHtcbiAgdmFyIHIgPSB0aGlzO1xuICB2YXIgdXNlUGF0aHMgPSB0aGlzLnVzZVBhdGhzKCkgJiYgc2hhcGUgIT09ICd0cmlhbmdsZS1jcm9zcyc7XG4gIHZhciBwYXRoQ2FjaGVIaXQgPSBmYWxzZTtcbiAgdmFyIHBhdGg7XG4gIHZhciBjYW52YXNDb250ZXh0ID0gY29udGV4dDtcbiAgdmFyIHRyYW5zbGF0aW9uID0ge1xuICAgIHg6IHgsXG4gICAgeTogeVxuICB9O1xuICB2YXIgc2NhbGUgPSBlZGdlLnBzdHlsZSgnYXJyb3ctc2NhbGUnKS52YWx1ZTtcbiAgdmFyIHNpemUgPSB0aGlzLmdldEFycm93V2lkdGgoZWRnZVdpZHRoLCBzY2FsZSk7XG4gIHZhciBzaGFwZUltcGwgPSByLmFycm93U2hhcGVzW3NoYXBlXTtcbiAgaWYgKHVzZVBhdGhzKSB7XG4gICAgdmFyIGNhY2hlID0gci5hcnJvd1BhdGhDYWNoZSA9IHIuYXJyb3dQYXRoQ2FjaGUgfHwgW107XG4gICAgdmFyIGtleSA9IGhhc2hTdHJpbmcoc2hhcGUpO1xuICAgIHZhciBjYWNoZWRQYXRoID0gY2FjaGVba2V5XTtcbiAgICBpZiAoY2FjaGVkUGF0aCAhPSBudWxsKSB7XG4gICAgICBwYXRoID0gY29udGV4dCA9IGNhY2hlZFBhdGg7XG4gICAgICBwYXRoQ2FjaGVIaXQgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXRoID0gY29udGV4dCA9IG5ldyBQYXRoMkQoKTtcbiAgICAgIGNhY2hlW2tleV0gPSBwYXRoO1xuICAgIH1cbiAgfVxuICBpZiAoIXBhdGhDYWNoZUhpdCkge1xuICAgIGlmIChjb250ZXh0LmJlZ2luUGF0aCkge1xuICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICB9XG4gICAgaWYgKHVzZVBhdGhzKSB7XG4gICAgICAvLyBzdG9yZSBpbiB0aGUgcGF0aCBjYWNoZSB3aXRoIHZhbHVlcyBlYXNpbHkgbWFuaXB1bGF0ZWQgbGF0ZXJcbiAgICAgIHNoYXBlSW1wbC5kcmF3KGNvbnRleHQsIDEsIDAsIHtcbiAgICAgICAgeDogMCxcbiAgICAgICAgeTogMFxuICAgICAgfSwgMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNoYXBlSW1wbC5kcmF3KGNvbnRleHQsIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbiwgZWRnZVdpZHRoKTtcbiAgICB9XG4gICAgaWYgKGNvbnRleHQuY2xvc2VQYXRoKSB7XG4gICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgIH1cbiAgfVxuICBjb250ZXh0ID0gY2FudmFzQ29udGV4dDtcbiAgaWYgKHVzZVBhdGhzKSB7XG4gICAgLy8gc2V0IHRyYW5zZm9ybSB0byBhcnJvdyBwb3NpdGlvbi9vcmllbnRhdGlvblxuICAgIGNvbnRleHQudHJhbnNsYXRlKHgsIHkpO1xuICAgIGNvbnRleHQucm90YXRlKGFuZ2xlKTtcbiAgICBjb250ZXh0LnNjYWxlKHNpemUsIHNpemUpO1xuICB9XG4gIGlmIChmaWxsID09PSAnZmlsbGVkJyB8fCBmaWxsID09PSAnYm90aCcpIHtcbiAgICBpZiAodXNlUGF0aHMpIHtcbiAgICAgIGNvbnRleHQuZmlsbChwYXRoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGV4dC5maWxsKCk7XG4gICAgfVxuICB9XG4gIGlmIChmaWxsID09PSAnaG9sbG93JyB8fCBmaWxsID09PSAnYm90aCcpIHtcbiAgICBjb250ZXh0LmxpbmVXaWR0aCA9IHNoYXBlV2lkdGggLyAodXNlUGF0aHMgPyBzaXplIDogMSk7XG4gICAgY29udGV4dC5saW5lSm9pbiA9ICdtaXRlcic7XG4gICAgaWYgKHVzZVBhdGhzKSB7XG4gICAgICBjb250ZXh0LnN0cm9rZShwYXRoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGV4dC5zdHJva2UoKTtcbiAgICB9XG4gIH1cbiAgaWYgKHVzZVBhdGhzKSB7XG4gICAgLy8gcmVzZXQgdHJhbnNmb3JtIGJ5IGFwcGx5aW5nIGludmVyc2VcbiAgICBjb250ZXh0LnNjYWxlKDEgLyBzaXplLCAxIC8gc2l6ZSk7XG4gICAgY29udGV4dC5yb3RhdGUoLWFuZ2xlKTtcbiAgICBjb250ZXh0LnRyYW5zbGF0ZSgteCwgLXkpO1xuICB9XG59O1xuXG52YXIgQ1JwJDcgPSB7fTtcbkNScCQ3LnNhZmVEcmF3SW1hZ2UgPSBmdW5jdGlvbiAoY29udGV4dCwgaW1nLCBpeCwgaXksIGl3LCBpaCwgeCwgeSwgdywgaCkge1xuICAvLyBkZXRlY3QgcHJvYmxlbWF0aWMgY2FzZXMgZm9yIG9sZCBicm93c2VycyB3aXRoIGJhZCBpbWFnZXMgKGNoZWFwZXIgdGhhbiB0cnktY2F0Y2gpXG4gIGlmIChpdyA8PSAwIHx8IGloIDw9IDAgfHwgdyA8PSAwIHx8IGggPD0gMCkge1xuICAgIHJldHVybjtcbiAgfVxuICB0cnkge1xuICAgIGNvbnRleHQuZHJhd0ltYWdlKGltZywgaXgsIGl5LCBpdywgaWgsIHgsIHksIHcsIGgpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgd2FybihlKTtcbiAgfVxufTtcbkNScCQ3LmRyYXdJbnNjcmliZWRJbWFnZSA9IGZ1bmN0aW9uIChjb250ZXh0LCBpbWcsIG5vZGUsIGluZGV4LCBub2RlT3BhY2l0eSkge1xuICB2YXIgciA9IHRoaXM7XG4gIHZhciBwb3MgPSBub2RlLnBvc2l0aW9uKCk7XG4gIHZhciBub2RlWCA9IHBvcy54O1xuICB2YXIgbm9kZVkgPSBwb3MueTtcbiAgdmFyIHN0eWxlT2JqID0gbm9kZS5jeSgpLnN0eWxlKCk7XG4gIHZhciBnZXRJbmRleGVkU3R5bGUgPSBzdHlsZU9iai5nZXRJbmRleGVkU3R5bGUuYmluZChzdHlsZU9iaik7XG4gIHZhciBmaXQgPSBnZXRJbmRleGVkU3R5bGUobm9kZSwgJ2JhY2tncm91bmQtZml0JywgJ3ZhbHVlJywgaW5kZXgpO1xuICB2YXIgcmVwZWF0ID0gZ2V0SW5kZXhlZFN0eWxlKG5vZGUsICdiYWNrZ3JvdW5kLXJlcGVhdCcsICd2YWx1ZScsIGluZGV4KTtcbiAgdmFyIG5vZGVXID0gbm9kZS53aWR0aCgpO1xuICB2YXIgbm9kZUggPSBub2RlLmhlaWdodCgpO1xuICB2YXIgcGFkZGluZ1gyID0gbm9kZS5wYWRkaW5nKCkgKiAyO1xuICB2YXIgbm9kZVRXID0gbm9kZVcgKyAoZ2V0SW5kZXhlZFN0eWxlKG5vZGUsICdiYWNrZ3JvdW5kLXdpZHRoLXJlbGF0aXZlLXRvJywgJ3ZhbHVlJywgaW5kZXgpID09PSAnaW5uZXInID8gMCA6IHBhZGRpbmdYMik7XG4gIHZhciBub2RlVEggPSBub2RlSCArIChnZXRJbmRleGVkU3R5bGUobm9kZSwgJ2JhY2tncm91bmQtaGVpZ2h0LXJlbGF0aXZlLXRvJywgJ3ZhbHVlJywgaW5kZXgpID09PSAnaW5uZXInID8gMCA6IHBhZGRpbmdYMik7XG4gIHZhciBycyA9IG5vZGUuX3ByaXZhdGUucnNjcmF0Y2g7XG4gIHZhciBjbGlwID0gZ2V0SW5kZXhlZFN0eWxlKG5vZGUsICdiYWNrZ3JvdW5kLWNsaXAnLCAndmFsdWUnLCBpbmRleCk7XG4gIHZhciBzaG91bGRDbGlwID0gY2xpcCA9PT0gJ25vZGUnO1xuICB2YXIgaW1nT3BhY2l0eSA9IGdldEluZGV4ZWRTdHlsZShub2RlLCAnYmFja2dyb3VuZC1pbWFnZS1vcGFjaXR5JywgJ3ZhbHVlJywgaW5kZXgpICogbm9kZU9wYWNpdHk7XG4gIHZhciBzbW9vdGggPSBnZXRJbmRleGVkU3R5bGUobm9kZSwgJ2JhY2tncm91bmQtaW1hZ2Utc21vb3RoaW5nJywgJ3ZhbHVlJywgaW5kZXgpO1xuICB2YXIgY29ybmVyUmFkaXVzID0gbm9kZS5wc3R5bGUoJ2Nvcm5lci1yYWRpdXMnKS52YWx1ZTtcbiAgaWYgKGNvcm5lclJhZGl1cyAhPT0gJ2F1dG8nKSBjb3JuZXJSYWRpdXMgPSBub2RlLnBzdHlsZSgnY29ybmVyLXJhZGl1cycpLnBmVmFsdWU7XG4gIHZhciBpbWdXID0gaW1nLndpZHRoIHx8IGltZy5jYWNoZWRXO1xuICB2YXIgaW1nSCA9IGltZy5oZWlnaHQgfHwgaW1nLmNhY2hlZEg7XG5cbiAgLy8gd29ya2Fyb3VuZCBmb3IgYnJva2VuIGJyb3dzZXJzIGxpa2UgaWVcbiAgaWYgKG51bGwgPT0gaW1nVyB8fCBudWxsID09IGltZ0gpIHtcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGltZyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcblxuICAgIGltZ1cgPSBpbWcuY2FjaGVkVyA9IGltZy53aWR0aCB8fCBpbWcub2Zmc2V0V2lkdGg7XG4gICAgaW1nSCA9IGltZy5jYWNoZWRIID0gaW1nLmhlaWdodCB8fCBpbWcub2Zmc2V0SGVpZ2h0O1xuICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoaW1nKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuICB9XG5cbiAgdmFyIHcgPSBpbWdXO1xuICB2YXIgaCA9IGltZ0g7XG4gIGlmIChnZXRJbmRleGVkU3R5bGUobm9kZSwgJ2JhY2tncm91bmQtd2lkdGgnLCAndmFsdWUnLCBpbmRleCkgIT09ICdhdXRvJykge1xuICAgIGlmIChnZXRJbmRleGVkU3R5bGUobm9kZSwgJ2JhY2tncm91bmQtd2lkdGgnLCAndW5pdHMnLCBpbmRleCkgPT09ICclJykge1xuICAgICAgdyA9IGdldEluZGV4ZWRTdHlsZShub2RlLCAnYmFja2dyb3VuZC13aWR0aCcsICdwZlZhbHVlJywgaW5kZXgpICogbm9kZVRXO1xuICAgIH0gZWxzZSB7XG4gICAgICB3ID0gZ2V0SW5kZXhlZFN0eWxlKG5vZGUsICdiYWNrZ3JvdW5kLXdpZHRoJywgJ3BmVmFsdWUnLCBpbmRleCk7XG4gICAgfVxuICB9XG4gIGlmIChnZXRJbmRleGVkU3R5bGUobm9kZSwgJ2JhY2tncm91bmQtaGVpZ2h0JywgJ3ZhbHVlJywgaW5kZXgpICE9PSAnYXV0bycpIHtcbiAgICBpZiAoZ2V0SW5kZXhlZFN0eWxlKG5vZGUsICdiYWNrZ3JvdW5kLWhlaWdodCcsICd1bml0cycsIGluZGV4KSA9PT0gJyUnKSB7XG4gICAgICBoID0gZ2V0SW5kZXhlZFN0eWxlKG5vZGUsICdiYWNrZ3JvdW5kLWhlaWdodCcsICdwZlZhbHVlJywgaW5kZXgpICogbm9kZVRIO1xuICAgIH0gZWxzZSB7XG4gICAgICBoID0gZ2V0SW5kZXhlZFN0eWxlKG5vZGUsICdiYWNrZ3JvdW5kLWhlaWdodCcsICdwZlZhbHVlJywgaW5kZXgpO1xuICAgIH1cbiAgfVxuICBpZiAodyA9PT0gMCB8fCBoID09PSAwKSB7XG4gICAgcmV0dXJuOyAvLyBubyBwb2ludCBpbiBkcmF3aW5nIGVtcHR5IGltYWdlIChhbmQgY2hyb21lIGlzIGJyb2tlbiBpbiB0aGlzIGNhc2UpXG4gIH1cblxuICBpZiAoZml0ID09PSAnY29udGFpbicpIHtcbiAgICB2YXIgc2NhbGUgPSBNYXRoLm1pbihub2RlVFcgLyB3LCBub2RlVEggLyBoKTtcbiAgICB3ICo9IHNjYWxlO1xuICAgIGggKj0gc2NhbGU7XG4gIH0gZWxzZSBpZiAoZml0ID09PSAnY292ZXInKSB7XG4gICAgdmFyIHNjYWxlID0gTWF0aC5tYXgobm9kZVRXIC8gdywgbm9kZVRIIC8gaCk7XG4gICAgdyAqPSBzY2FsZTtcbiAgICBoICo9IHNjYWxlO1xuICB9XG4gIHZhciB4ID0gbm9kZVggLSBub2RlVFcgLyAyOyAvLyBsZWZ0XG4gIHZhciBwb3NYVW5pdHMgPSBnZXRJbmRleGVkU3R5bGUobm9kZSwgJ2JhY2tncm91bmQtcG9zaXRpb24teCcsICd1bml0cycsIGluZGV4KTtcbiAgdmFyIHBvc1hQZlZhbCA9IGdldEluZGV4ZWRTdHlsZShub2RlLCAnYmFja2dyb3VuZC1wb3NpdGlvbi14JywgJ3BmVmFsdWUnLCBpbmRleCk7XG4gIGlmIChwb3NYVW5pdHMgPT09ICclJykge1xuICAgIHggKz0gKG5vZGVUVyAtIHcpICogcG9zWFBmVmFsO1xuICB9IGVsc2Uge1xuICAgIHggKz0gcG9zWFBmVmFsO1xuICB9XG4gIHZhciBvZmZYVW5pdHMgPSBnZXRJbmRleGVkU3R5bGUobm9kZSwgJ2JhY2tncm91bmQtb2Zmc2V0LXgnLCAndW5pdHMnLCBpbmRleCk7XG4gIHZhciBvZmZYUGZWYWwgPSBnZXRJbmRleGVkU3R5bGUobm9kZSwgJ2JhY2tncm91bmQtb2Zmc2V0LXgnLCAncGZWYWx1ZScsIGluZGV4KTtcbiAgaWYgKG9mZlhVbml0cyA9PT0gJyUnKSB7XG4gICAgeCArPSAobm9kZVRXIC0gdykgKiBvZmZYUGZWYWw7XG4gIH0gZWxzZSB7XG4gICAgeCArPSBvZmZYUGZWYWw7XG4gIH1cbiAgdmFyIHkgPSBub2RlWSAtIG5vZGVUSCAvIDI7IC8vIHRvcFxuICB2YXIgcG9zWVVuaXRzID0gZ2V0SW5kZXhlZFN0eWxlKG5vZGUsICdiYWNrZ3JvdW5kLXBvc2l0aW9uLXknLCAndW5pdHMnLCBpbmRleCk7XG4gIHZhciBwb3NZUGZWYWwgPSBnZXRJbmRleGVkU3R5bGUobm9kZSwgJ2JhY2tncm91bmQtcG9zaXRpb24teScsICdwZlZhbHVlJywgaW5kZXgpO1xuICBpZiAocG9zWVVuaXRzID09PSAnJScpIHtcbiAgICB5ICs9IChub2RlVEggLSBoKSAqIHBvc1lQZlZhbDtcbiAgfSBlbHNlIHtcbiAgICB5ICs9IHBvc1lQZlZhbDtcbiAgfVxuICB2YXIgb2ZmWVVuaXRzID0gZ2V0SW5kZXhlZFN0eWxlKG5vZGUsICdiYWNrZ3JvdW5kLW9mZnNldC15JywgJ3VuaXRzJywgaW5kZXgpO1xuICB2YXIgb2ZmWVBmVmFsID0gZ2V0SW5kZXhlZFN0eWxlKG5vZGUsICdiYWNrZ3JvdW5kLW9mZnNldC15JywgJ3BmVmFsdWUnLCBpbmRleCk7XG4gIGlmIChvZmZZVW5pdHMgPT09ICclJykge1xuICAgIHkgKz0gKG5vZGVUSCAtIGgpICogb2ZmWVBmVmFsO1xuICB9IGVsc2Uge1xuICAgIHkgKz0gb2ZmWVBmVmFsO1xuICB9XG4gIGlmIChycy5wYXRoQ2FjaGUpIHtcbiAgICB4IC09IG5vZGVYO1xuICAgIHkgLT0gbm9kZVk7XG4gICAgbm9kZVggPSAwO1xuICAgIG5vZGVZID0gMDtcbiAgfVxuICB2YXIgZ0FscGhhID0gY29udGV4dC5nbG9iYWxBbHBoYTtcbiAgY29udGV4dC5nbG9iYWxBbHBoYSA9IGltZ09wYWNpdHk7XG4gIHZhciBzbW9vdGhpbmdFbmFibGVkID0gci5nZXRJbWdTbW9vdGhpbmcoY29udGV4dCk7XG4gIHZhciBpc1Ntb290aGluZ1N3aXRjaGVkID0gZmFsc2U7XG4gIGlmIChzbW9vdGggPT09ICdubycgJiYgc21vb3RoaW5nRW5hYmxlZCkge1xuICAgIHIuc2V0SW1nU21vb3RoaW5nKGNvbnRleHQsIGZhbHNlKTtcbiAgICBpc1Ntb290aGluZ1N3aXRjaGVkID0gdHJ1ZTtcbiAgfSBlbHNlIGlmIChzbW9vdGggPT09ICd5ZXMnICYmICFzbW9vdGhpbmdFbmFibGVkKSB7XG4gICAgci5zZXRJbWdTbW9vdGhpbmcoY29udGV4dCwgdHJ1ZSk7XG4gICAgaXNTbW9vdGhpbmdTd2l0Y2hlZCA9IHRydWU7XG4gIH1cbiAgaWYgKHJlcGVhdCA9PT0gJ25vLXJlcGVhdCcpIHtcbiAgICBpZiAoc2hvdWxkQ2xpcCkge1xuICAgICAgY29udGV4dC5zYXZlKCk7XG4gICAgICBpZiAocnMucGF0aENhY2hlKSB7XG4gICAgICAgIGNvbnRleHQuY2xpcChycy5wYXRoQ2FjaGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgci5ub2RlU2hhcGVzW3IuZ2V0Tm9kZVNoYXBlKG5vZGUpXS5kcmF3KGNvbnRleHQsIG5vZGVYLCBub2RlWSwgbm9kZVRXLCBub2RlVEgsIGNvcm5lclJhZGl1cywgcnMpO1xuICAgICAgICBjb250ZXh0LmNsaXAoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgci5zYWZlRHJhd0ltYWdlKGNvbnRleHQsIGltZywgMCwgMCwgaW1nVywgaW1nSCwgeCwgeSwgdywgaCk7XG4gICAgaWYgKHNob3VsZENsaXApIHtcbiAgICAgIGNvbnRleHQucmVzdG9yZSgpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgcGF0dGVybiA9IGNvbnRleHQuY3JlYXRlUGF0dGVybihpbWcsIHJlcGVhdCk7XG4gICAgY29udGV4dC5maWxsU3R5bGUgPSBwYXR0ZXJuO1xuICAgIHIubm9kZVNoYXBlc1tyLmdldE5vZGVTaGFwZShub2RlKV0uZHJhdyhjb250ZXh0LCBub2RlWCwgbm9kZVksIG5vZGVUVywgbm9kZVRILCBjb3JuZXJSYWRpdXMsIHJzKTtcbiAgICBjb250ZXh0LnRyYW5zbGF0ZSh4LCB5KTtcbiAgICBjb250ZXh0LmZpbGwoKTtcbiAgICBjb250ZXh0LnRyYW5zbGF0ZSgteCwgLXkpO1xuICB9XG4gIGNvbnRleHQuZ2xvYmFsQWxwaGEgPSBnQWxwaGE7XG4gIGlmIChpc1Ntb290aGluZ1N3aXRjaGVkKSB7XG4gICAgci5zZXRJbWdTbW9vdGhpbmcoY29udGV4dCwgc21vb3RoaW5nRW5hYmxlZCk7XG4gIH1cbn07XG5cbnZhciBDUnAkNiA9IHt9O1xuQ1JwJDYuZWxlVGV4dEJpZ2dlclRoYW5NaW4gPSBmdW5jdGlvbiAoZWxlLCBzY2FsZSkge1xuICBpZiAoIXNjYWxlKSB7XG4gICAgdmFyIHpvb20gPSBlbGUuY3koKS56b29tKCk7XG4gICAgdmFyIHB4UmF0aW8gPSB0aGlzLmdldFBpeGVsUmF0aW8oKTtcbiAgICB2YXIgbHZsID0gTWF0aC5jZWlsKGxvZzIoem9vbSAqIHB4UmF0aW8pKTsgLy8gdGhlIGVmZmVjdGl2ZSB0ZXh0dXJlIGxldmVsXG5cbiAgICBzY2FsZSA9IE1hdGgucG93KDIsIGx2bCk7XG4gIH1cbiAgdmFyIGNvbXB1dGVkU2l6ZSA9IGVsZS5wc3R5bGUoJ2ZvbnQtc2l6ZScpLnBmVmFsdWUgKiBzY2FsZTtcbiAgdmFyIG1pblNpemUgPSBlbGUucHN0eWxlKCdtaW4tem9vbWVkLWZvbnQtc2l6ZScpLnBmVmFsdWU7XG4gIGlmIChjb21wdXRlZFNpemUgPCBtaW5TaXplKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufTtcbkNScCQ2LmRyYXdFbGVtZW50VGV4dCA9IGZ1bmN0aW9uIChjb250ZXh0LCBlbGUsIHNoaWZ0VG9PcmlnaW5XaXRoQmIsIGZvcmNlLCBwcmVmaXgpIHtcbiAgdmFyIHVzZUVsZU9wYWNpdHkgPSBhcmd1bWVudHMubGVuZ3RoID4gNSAmJiBhcmd1bWVudHNbNV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s1XSA6IHRydWU7XG4gIHZhciByID0gdGhpcztcbiAgaWYgKGZvcmNlID09IG51bGwpIHtcbiAgICBpZiAodXNlRWxlT3BhY2l0eSAmJiAhci5lbGVUZXh0QmlnZ2VyVGhhbk1pbihlbGUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9IGVsc2UgaWYgKGZvcmNlID09PSBmYWxzZSkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoZWxlLmlzTm9kZSgpKSB7XG4gICAgdmFyIGxhYmVsID0gZWxlLnBzdHlsZSgnbGFiZWwnKTtcbiAgICBpZiAoIWxhYmVsIHx8ICFsYWJlbC52YWx1ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIganVzdGlmaWNhdGlvbiA9IHIuZ2V0TGFiZWxKdXN0aWZpY2F0aW9uKGVsZSk7XG4gICAgY29udGV4dC50ZXh0QWxpZ24gPSBqdXN0aWZpY2F0aW9uO1xuICAgIGNvbnRleHQudGV4dEJhc2VsaW5lID0gJ2JvdHRvbSc7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGJhZExpbmUgPSBlbGUuZWxlbWVudCgpLl9wcml2YXRlLnJzY3JhdGNoLmJhZExpbmU7XG4gICAgdmFyIF9sYWJlbCA9IGVsZS5wc3R5bGUoJ2xhYmVsJyk7XG4gICAgdmFyIHNyY0xhYmVsID0gZWxlLnBzdHlsZSgnc291cmNlLWxhYmVsJyk7XG4gICAgdmFyIHRndExhYmVsID0gZWxlLnBzdHlsZSgndGFyZ2V0LWxhYmVsJyk7XG4gICAgaWYgKGJhZExpbmUgfHwgKCFfbGFiZWwgfHwgIV9sYWJlbC52YWx1ZSkgJiYgKCFzcmNMYWJlbCB8fCAhc3JjTGFiZWwudmFsdWUpICYmICghdGd0TGFiZWwgfHwgIXRndExhYmVsLnZhbHVlKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb250ZXh0LnRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgIGNvbnRleHQudGV4dEJhc2VsaW5lID0gJ2JvdHRvbSc7XG4gIH1cbiAgdmFyIGFwcGx5Um90YXRpb24gPSAhc2hpZnRUb09yaWdpbldpdGhCYjtcbiAgdmFyIGJiO1xuICBpZiAoc2hpZnRUb09yaWdpbldpdGhCYikge1xuICAgIGJiID0gc2hpZnRUb09yaWdpbldpdGhCYjtcbiAgICBjb250ZXh0LnRyYW5zbGF0ZSgtYmIueDEsIC1iYi55MSk7XG4gIH1cbiAgaWYgKHByZWZpeCA9PSBudWxsKSB7XG4gICAgci5kcmF3VGV4dChjb250ZXh0LCBlbGUsIG51bGwsIGFwcGx5Um90YXRpb24sIHVzZUVsZU9wYWNpdHkpO1xuICAgIGlmIChlbGUuaXNFZGdlKCkpIHtcbiAgICAgIHIuZHJhd1RleHQoY29udGV4dCwgZWxlLCAnc291cmNlJywgYXBwbHlSb3RhdGlvbiwgdXNlRWxlT3BhY2l0eSk7XG4gICAgICByLmRyYXdUZXh0KGNvbnRleHQsIGVsZSwgJ3RhcmdldCcsIGFwcGx5Um90YXRpb24sIHVzZUVsZU9wYWNpdHkpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByLmRyYXdUZXh0KGNvbnRleHQsIGVsZSwgcHJlZml4LCBhcHBseVJvdGF0aW9uLCB1c2VFbGVPcGFjaXR5KTtcbiAgfVxuICBpZiAoc2hpZnRUb09yaWdpbldpdGhCYikge1xuICAgIGNvbnRleHQudHJhbnNsYXRlKGJiLngxLCBiYi55MSk7XG4gIH1cbn07XG5DUnAkNi5nZXRGb250Q2FjaGUgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICB2YXIgY2FjaGU7XG4gIHRoaXMuZm9udENhY2hlcyA9IHRoaXMuZm9udENhY2hlcyB8fCBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmZvbnRDYWNoZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjYWNoZSA9IHRoaXMuZm9udENhY2hlc1tpXTtcbiAgICBpZiAoY2FjaGUuY29udGV4dCA9PT0gY29udGV4dCkge1xuICAgICAgcmV0dXJuIGNhY2hlO1xuICAgIH1cbiAgfVxuICBjYWNoZSA9IHtcbiAgICBjb250ZXh0OiBjb250ZXh0XG4gIH07XG4gIHRoaXMuZm9udENhY2hlcy5wdXNoKGNhY2hlKTtcbiAgcmV0dXJuIGNhY2hlO1xufTtcblxuLy8gc2V0IHVwIGNhbnZhcyBjb250ZXh0IHdpdGggZm9udFxuLy8gcmV0dXJucyB0cmFuc2Zvcm1lZCB0ZXh0IHN0cmluZ1xuQ1JwJDYuc2V0dXBUZXh0U3R5bGUgPSBmdW5jdGlvbiAoY29udGV4dCwgZWxlKSB7XG4gIHZhciB1c2VFbGVPcGFjaXR5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB0cnVlO1xuICAvLyBGb250IHN0eWxlXG4gIHZhciBsYWJlbFN0eWxlID0gZWxlLnBzdHlsZSgnZm9udC1zdHlsZScpLnN0clZhbHVlO1xuICB2YXIgbGFiZWxTaXplID0gZWxlLnBzdHlsZSgnZm9udC1zaXplJykucGZWYWx1ZSArICdweCc7XG4gIHZhciBsYWJlbEZhbWlseSA9IGVsZS5wc3R5bGUoJ2ZvbnQtZmFtaWx5Jykuc3RyVmFsdWU7XG4gIHZhciBsYWJlbFdlaWdodCA9IGVsZS5wc3R5bGUoJ2ZvbnQtd2VpZ2h0Jykuc3RyVmFsdWU7XG4gIHZhciBvcGFjaXR5ID0gdXNlRWxlT3BhY2l0eSA/IGVsZS5lZmZlY3RpdmVPcGFjaXR5KCkgKiBlbGUucHN0eWxlKCd0ZXh0LW9wYWNpdHknKS52YWx1ZSA6IDE7XG4gIHZhciBvdXRsaW5lT3BhY2l0eSA9IGVsZS5wc3R5bGUoJ3RleHQtb3V0bGluZS1vcGFjaXR5JykudmFsdWUgKiBvcGFjaXR5O1xuICB2YXIgY29sb3IgPSBlbGUucHN0eWxlKCdjb2xvcicpLnZhbHVlO1xuICB2YXIgb3V0bGluZUNvbG9yID0gZWxlLnBzdHlsZSgndGV4dC1vdXRsaW5lLWNvbG9yJykudmFsdWU7XG4gIGNvbnRleHQuZm9udCA9IGxhYmVsU3R5bGUgKyAnICcgKyBsYWJlbFdlaWdodCArICcgJyArIGxhYmVsU2l6ZSArICcgJyArIGxhYmVsRmFtaWx5O1xuICBjb250ZXh0LmxpbmVKb2luID0gJ3JvdW5kJzsgLy8gc28gdGV4dCBvdXRsaW5lcyBhcmVuJ3QgamFnZ2VkXG5cbiAgdGhpcy5jb2xvckZpbGxTdHlsZShjb250ZXh0LCBjb2xvclswXSwgY29sb3JbMV0sIGNvbG9yWzJdLCBvcGFjaXR5KTtcbiAgdGhpcy5jb2xvclN0cm9rZVN0eWxlKGNvbnRleHQsIG91dGxpbmVDb2xvclswXSwgb3V0bGluZUNvbG9yWzFdLCBvdXRsaW5lQ29sb3JbMl0sIG91dGxpbmVPcGFjaXR5KTtcbn07XG5cbi8vIFRPRE8gZW5zdXJlIHJlLXVzZWRcbmZ1bmN0aW9uIHJvdW5kUmVjdChjdHgsIHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcbiAgdmFyIHJhZGl1cyA9IGFyZ3VtZW50cy5sZW5ndGggPiA1ICYmIGFyZ3VtZW50c1s1XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzVdIDogNTtcbiAgdmFyIHN0cm9rZSA9IGFyZ3VtZW50cy5sZW5ndGggPiA2ID8gYXJndW1lbnRzWzZdIDogdW5kZWZpbmVkO1xuICBjdHguYmVnaW5QYXRoKCk7XG4gIGN0eC5tb3ZlVG8oeCArIHJhZGl1cywgeSk7XG4gIGN0eC5saW5lVG8oeCArIHdpZHRoIC0gcmFkaXVzLCB5KTtcbiAgY3R4LnF1YWRyYXRpY0N1cnZlVG8oeCArIHdpZHRoLCB5LCB4ICsgd2lkdGgsIHkgKyByYWRpdXMpO1xuICBjdHgubGluZVRvKHggKyB3aWR0aCwgeSArIGhlaWdodCAtIHJhZGl1cyk7XG4gIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHggKyB3aWR0aCwgeSArIGhlaWdodCwgeCArIHdpZHRoIC0gcmFkaXVzLCB5ICsgaGVpZ2h0KTtcbiAgY3R4LmxpbmVUbyh4ICsgcmFkaXVzLCB5ICsgaGVpZ2h0KTtcbiAgY3R4LnF1YWRyYXRpY0N1cnZlVG8oeCwgeSArIGhlaWdodCwgeCwgeSArIGhlaWdodCAtIHJhZGl1cyk7XG4gIGN0eC5saW5lVG8oeCwgeSArIHJhZGl1cyk7XG4gIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHgsIHksIHggKyByYWRpdXMsIHkpO1xuICBjdHguY2xvc2VQYXRoKCk7XG4gIGlmIChzdHJva2UpIGN0eC5zdHJva2UoKTtlbHNlIGN0eC5maWxsKCk7XG59XG5DUnAkNi5nZXRUZXh0QW5nbGUgPSBmdW5jdGlvbiAoZWxlLCBwcmVmaXgpIHtcbiAgdmFyIHRoZXRhO1xuICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gIHZhciByc2NyYXRjaCA9IF9wLnJzY3JhdGNoO1xuICB2YXIgcGRhc2ggPSBwcmVmaXggPyBwcmVmaXggKyAnLScgOiAnJztcbiAgdmFyIHJvdGF0aW9uID0gZWxlLnBzdHlsZShwZGFzaCArICd0ZXh0LXJvdGF0aW9uJyk7XG4gIHZhciB0ZXh0QW5nbGUgPSBnZXRQcmVmaXhlZFByb3BlcnR5KHJzY3JhdGNoLCAnbGFiZWxBbmdsZScsIHByZWZpeCk7XG4gIGlmIChyb3RhdGlvbi5zdHJWYWx1ZSA9PT0gJ2F1dG9yb3RhdGUnKSB7XG4gICAgdGhldGEgPSBlbGUuaXNFZGdlKCkgPyB0ZXh0QW5nbGUgOiAwO1xuICB9IGVsc2UgaWYgKHJvdGF0aW9uLnN0clZhbHVlID09PSAnbm9uZScpIHtcbiAgICB0aGV0YSA9IDA7XG4gIH0gZWxzZSB7XG4gICAgdGhldGEgPSByb3RhdGlvbi5wZlZhbHVlO1xuICB9XG4gIHJldHVybiB0aGV0YTtcbn07XG5DUnAkNi5kcmF3VGV4dCA9IGZ1bmN0aW9uIChjb250ZXh0LCBlbGUsIHByZWZpeCkge1xuICB2YXIgYXBwbHlSb3RhdGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogdHJ1ZTtcbiAgdmFyIHVzZUVsZU9wYWNpdHkgPSBhcmd1bWVudHMubGVuZ3RoID4gNCAmJiBhcmd1bWVudHNbNF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s0XSA6IHRydWU7XG4gIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgdmFyIHJzY3JhdGNoID0gX3AucnNjcmF0Y2g7XG4gIHZhciBwYXJlbnRPcGFjaXR5ID0gdXNlRWxlT3BhY2l0eSA/IGVsZS5lZmZlY3RpdmVPcGFjaXR5KCkgOiAxO1xuICBpZiAodXNlRWxlT3BhY2l0eSAmJiAocGFyZW50T3BhY2l0eSA9PT0gMCB8fCBlbGUucHN0eWxlKCd0ZXh0LW9wYWNpdHknKS52YWx1ZSA9PT0gMCkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyB1c2UgJ21haW4nIGFzIGFuIGFsaWFzIGZvciB0aGUgbWFpbiBsYWJlbCAoaS5lLiBudWxsIHByZWZpeClcbiAgaWYgKHByZWZpeCA9PT0gJ21haW4nKSB7XG4gICAgcHJlZml4ID0gbnVsbDtcbiAgfVxuICB2YXIgdGV4dFggPSBnZXRQcmVmaXhlZFByb3BlcnR5KHJzY3JhdGNoLCAnbGFiZWxYJywgcHJlZml4KTtcbiAgdmFyIHRleHRZID0gZ2V0UHJlZml4ZWRQcm9wZXJ0eShyc2NyYXRjaCwgJ2xhYmVsWScsIHByZWZpeCk7XG4gIHZhciBvcmdUZXh0WCwgb3JnVGV4dFk7IC8vIHVzZWQgZm9yIHJvdGF0aW9uXG4gIHZhciB0ZXh0ID0gdGhpcy5nZXRMYWJlbFRleHQoZWxlLCBwcmVmaXgpO1xuICBpZiAodGV4dCAhPSBudWxsICYmIHRleHQgIT09ICcnICYmICFpc05hTih0ZXh0WCkgJiYgIWlzTmFOKHRleHRZKSkge1xuICAgIHRoaXMuc2V0dXBUZXh0U3R5bGUoY29udGV4dCwgZWxlLCB1c2VFbGVPcGFjaXR5KTtcbiAgICB2YXIgcGRhc2ggPSBwcmVmaXggPyBwcmVmaXggKyAnLScgOiAnJztcbiAgICB2YXIgdGV4dFcgPSBnZXRQcmVmaXhlZFByb3BlcnR5KHJzY3JhdGNoLCAnbGFiZWxXaWR0aCcsIHByZWZpeCk7XG4gICAgdmFyIHRleHRIID0gZ2V0UHJlZml4ZWRQcm9wZXJ0eShyc2NyYXRjaCwgJ2xhYmVsSGVpZ2h0JywgcHJlZml4KTtcbiAgICB2YXIgbWFyZ2luWCA9IGVsZS5wc3R5bGUocGRhc2ggKyAndGV4dC1tYXJnaW4teCcpLnBmVmFsdWU7XG4gICAgdmFyIG1hcmdpblkgPSBlbGUucHN0eWxlKHBkYXNoICsgJ3RleHQtbWFyZ2luLXknKS5wZlZhbHVlO1xuICAgIHZhciBpc0VkZ2UgPSBlbGUuaXNFZGdlKCk7XG4gICAgdmFyIGhhbGlnbiA9IGVsZS5wc3R5bGUoJ3RleHQtaGFsaWduJykudmFsdWU7XG4gICAgdmFyIHZhbGlnbiA9IGVsZS5wc3R5bGUoJ3RleHQtdmFsaWduJykudmFsdWU7XG4gICAgaWYgKGlzRWRnZSkge1xuICAgICAgaGFsaWduID0gJ2NlbnRlcic7XG4gICAgICB2YWxpZ24gPSAnY2VudGVyJztcbiAgICB9XG4gICAgdGV4dFggKz0gbWFyZ2luWDtcbiAgICB0ZXh0WSArPSBtYXJnaW5ZO1xuICAgIHZhciB0aGV0YTtcbiAgICBpZiAoIWFwcGx5Um90YXRpb24pIHtcbiAgICAgIHRoZXRhID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhldGEgPSB0aGlzLmdldFRleHRBbmdsZShlbGUsIHByZWZpeCk7XG4gICAgfVxuICAgIGlmICh0aGV0YSAhPT0gMCkge1xuICAgICAgb3JnVGV4dFggPSB0ZXh0WDtcbiAgICAgIG9yZ1RleHRZID0gdGV4dFk7XG4gICAgICBjb250ZXh0LnRyYW5zbGF0ZShvcmdUZXh0WCwgb3JnVGV4dFkpO1xuICAgICAgY29udGV4dC5yb3RhdGUodGhldGEpO1xuICAgICAgdGV4dFggPSAwO1xuICAgICAgdGV4dFkgPSAwO1xuICAgIH1cbiAgICBzd2l0Y2ggKHZhbGlnbikge1xuICAgICAgY2FzZSAndG9wJzpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdjZW50ZXInOlxuICAgICAgICB0ZXh0WSArPSB0ZXh0SCAvIDI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnYm90dG9tJzpcbiAgICAgICAgdGV4dFkgKz0gdGV4dEg7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICB2YXIgYmFja2dyb3VuZE9wYWNpdHkgPSBlbGUucHN0eWxlKCd0ZXh0LWJhY2tncm91bmQtb3BhY2l0eScpLnZhbHVlO1xuICAgIHZhciBib3JkZXJPcGFjaXR5ID0gZWxlLnBzdHlsZSgndGV4dC1ib3JkZXItb3BhY2l0eScpLnZhbHVlO1xuICAgIHZhciB0ZXh0Qm9yZGVyV2lkdGggPSBlbGUucHN0eWxlKCd0ZXh0LWJvcmRlci13aWR0aCcpLnBmVmFsdWU7XG4gICAgdmFyIGJhY2tncm91bmRQYWRkaW5nID0gZWxlLnBzdHlsZSgndGV4dC1iYWNrZ3JvdW5kLXBhZGRpbmcnKS5wZlZhbHVlO1xuICAgIHZhciBzdHlsZVNoYXBlID0gZWxlLnBzdHlsZSgndGV4dC1iYWNrZ3JvdW5kLXNoYXBlJykuc3RyVmFsdWU7XG4gICAgdmFyIHJvdW5kZWQgPSBzdHlsZVNoYXBlLmluZGV4T2YoJ3JvdW5kJykgPT09IDA7XG4gICAgdmFyIHJvdW5kUmFkaXVzID0gMjtcbiAgICBpZiAoYmFja2dyb3VuZE9wYWNpdHkgPiAwIHx8IHRleHRCb3JkZXJXaWR0aCA+IDAgJiYgYm9yZGVyT3BhY2l0eSA+IDApIHtcbiAgICAgIHZhciBiZ1ggPSB0ZXh0WCAtIGJhY2tncm91bmRQYWRkaW5nO1xuICAgICAgc3dpdGNoIChoYWxpZ24pIHtcbiAgICAgICAgY2FzZSAnbGVmdCc6XG4gICAgICAgICAgYmdYIC09IHRleHRXO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdjZW50ZXInOlxuICAgICAgICAgIGJnWCAtPSB0ZXh0VyAvIDI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICB2YXIgYmdZID0gdGV4dFkgLSB0ZXh0SCAtIGJhY2tncm91bmRQYWRkaW5nO1xuICAgICAgdmFyIGJnVyA9IHRleHRXICsgMiAqIGJhY2tncm91bmRQYWRkaW5nO1xuICAgICAgdmFyIGJnSCA9IHRleHRIICsgMiAqIGJhY2tncm91bmRQYWRkaW5nO1xuICAgICAgaWYgKGJhY2tncm91bmRPcGFjaXR5ID4gMCkge1xuICAgICAgICB2YXIgdGV4dEZpbGwgPSBjb250ZXh0LmZpbGxTdHlsZTtcbiAgICAgICAgdmFyIHRleHRCYWNrZ3JvdW5kQ29sb3IgPSBlbGUucHN0eWxlKCd0ZXh0LWJhY2tncm91bmQtY29sb3InKS52YWx1ZTtcbiAgICAgICAgY29udGV4dC5maWxsU3R5bGUgPSAncmdiYSgnICsgdGV4dEJhY2tncm91bmRDb2xvclswXSArICcsJyArIHRleHRCYWNrZ3JvdW5kQ29sb3JbMV0gKyAnLCcgKyB0ZXh0QmFja2dyb3VuZENvbG9yWzJdICsgJywnICsgYmFja2dyb3VuZE9wYWNpdHkgKiBwYXJlbnRPcGFjaXR5ICsgJyknO1xuICAgICAgICBpZiAocm91bmRlZCkge1xuICAgICAgICAgIHJvdW5kUmVjdChjb250ZXh0LCBiZ1gsIGJnWSwgYmdXLCBiZ0gsIHJvdW5kUmFkaXVzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb250ZXh0LmZpbGxSZWN0KGJnWCwgYmdZLCBiZ1csIGJnSCk7XG4gICAgICAgIH1cbiAgICAgICAgY29udGV4dC5maWxsU3R5bGUgPSB0ZXh0RmlsbDtcbiAgICAgIH1cbiAgICAgIGlmICh0ZXh0Qm9yZGVyV2lkdGggPiAwICYmIGJvcmRlck9wYWNpdHkgPiAwKSB7XG4gICAgICAgIHZhciB0ZXh0U3Ryb2tlID0gY29udGV4dC5zdHJva2VTdHlsZTtcbiAgICAgICAgdmFyIHRleHRMaW5lV2lkdGggPSBjb250ZXh0LmxpbmVXaWR0aDtcbiAgICAgICAgdmFyIHRleHRCb3JkZXJDb2xvciA9IGVsZS5wc3R5bGUoJ3RleHQtYm9yZGVyLWNvbG9yJykudmFsdWU7XG4gICAgICAgIHZhciB0ZXh0Qm9yZGVyU3R5bGUgPSBlbGUucHN0eWxlKCd0ZXh0LWJvcmRlci1zdHlsZScpLnZhbHVlO1xuICAgICAgICBjb250ZXh0LnN0cm9rZVN0eWxlID0gJ3JnYmEoJyArIHRleHRCb3JkZXJDb2xvclswXSArICcsJyArIHRleHRCb3JkZXJDb2xvclsxXSArICcsJyArIHRleHRCb3JkZXJDb2xvclsyXSArICcsJyArIGJvcmRlck9wYWNpdHkgKiBwYXJlbnRPcGFjaXR5ICsgJyknO1xuICAgICAgICBjb250ZXh0LmxpbmVXaWR0aCA9IHRleHRCb3JkZXJXaWR0aDtcbiAgICAgICAgaWYgKGNvbnRleHQuc2V0TGluZURhc2gpIHtcbiAgICAgICAgICAvLyBmb3IgdmVyeSBvdXRvZmRhdGUgYnJvd3NlcnNcbiAgICAgICAgICBzd2l0Y2ggKHRleHRCb3JkZXJTdHlsZSkge1xuICAgICAgICAgICAgY2FzZSAnZG90dGVkJzpcbiAgICAgICAgICAgICAgY29udGV4dC5zZXRMaW5lRGFzaChbMSwgMV0pO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2Rhc2hlZCc6XG4gICAgICAgICAgICAgIGNvbnRleHQuc2V0TGluZURhc2goWzQsIDJdKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdkb3VibGUnOlxuICAgICAgICAgICAgICBjb250ZXh0LmxpbmVXaWR0aCA9IHRleHRCb3JkZXJXaWR0aCAvIDQ7IC8vIDUwJSByZXNlcnZlZCBmb3Igd2hpdGUgYmV0d2VlbiB0aGUgdHdvIGJvcmRlcnNcbiAgICAgICAgICAgICAgY29udGV4dC5zZXRMaW5lRGFzaChbXSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnc29saWQnOlxuICAgICAgICAgICAgICBjb250ZXh0LnNldExpbmVEYXNoKFtdKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChyb3VuZGVkKSB7XG4gICAgICAgICAgcm91bmRSZWN0KGNvbnRleHQsIGJnWCwgYmdZLCBiZ1csIGJnSCwgcm91bmRSYWRpdXMsICdzdHJva2UnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb250ZXh0LnN0cm9rZVJlY3QoYmdYLCBiZ1ksIGJnVywgYmdIKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGV4dEJvcmRlclN0eWxlID09PSAnZG91YmxlJykge1xuICAgICAgICAgIHZhciB3aGl0ZVdpZHRoID0gdGV4dEJvcmRlcldpZHRoIC8gMjtcbiAgICAgICAgICBpZiAocm91bmRlZCkge1xuICAgICAgICAgICAgcm91bmRSZWN0KGNvbnRleHQsIGJnWCArIHdoaXRlV2lkdGgsIGJnWSArIHdoaXRlV2lkdGgsIGJnVyAtIHdoaXRlV2lkdGggKiAyLCBiZ0ggLSB3aGl0ZVdpZHRoICogMiwgcm91bmRSYWRpdXMsICdzdHJva2UnKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29udGV4dC5zdHJva2VSZWN0KGJnWCArIHdoaXRlV2lkdGgsIGJnWSArIHdoaXRlV2lkdGgsIGJnVyAtIHdoaXRlV2lkdGggKiAyLCBiZ0ggLSB3aGl0ZVdpZHRoICogMik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjb250ZXh0LnNldExpbmVEYXNoKSB7XG4gICAgICAgICAgLy8gZm9yIHZlcnkgb3V0b2ZkYXRlIGJyb3dzZXJzXG4gICAgICAgICAgY29udGV4dC5zZXRMaW5lRGFzaChbXSk7XG4gICAgICAgIH1cbiAgICAgICAgY29udGV4dC5saW5lV2lkdGggPSB0ZXh0TGluZVdpZHRoO1xuICAgICAgICBjb250ZXh0LnN0cm9rZVN0eWxlID0gdGV4dFN0cm9rZTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIGxpbmVXaWR0aCA9IDIgKiBlbGUucHN0eWxlKCd0ZXh0LW91dGxpbmUtd2lkdGgnKS5wZlZhbHVlOyAvLyAqMiBiL2MgdGhlIHN0cm9rZSBpcyBkcmF3biBjZW50cmVkIG9uIHRoZSBtaWRkbGVcblxuICAgIGlmIChsaW5lV2lkdGggPiAwKSB7XG4gICAgICBjb250ZXh0LmxpbmVXaWR0aCA9IGxpbmVXaWR0aDtcbiAgICB9XG4gICAgaWYgKGVsZS5wc3R5bGUoJ3RleHQtd3JhcCcpLnZhbHVlID09PSAnd3JhcCcpIHtcbiAgICAgIHZhciBsaW5lcyA9IGdldFByZWZpeGVkUHJvcGVydHkocnNjcmF0Y2gsICdsYWJlbFdyYXBDYWNoZWRMaW5lcycsIHByZWZpeCk7XG4gICAgICB2YXIgbGluZUhlaWdodCA9IGdldFByZWZpeGVkUHJvcGVydHkocnNjcmF0Y2gsICdsYWJlbExpbmVIZWlnaHQnLCBwcmVmaXgpO1xuICAgICAgdmFyIGhhbGZUZXh0VyA9IHRleHRXIC8gMjtcbiAgICAgIHZhciBqdXN0aWZpY2F0aW9uID0gdGhpcy5nZXRMYWJlbEp1c3RpZmljYXRpb24oZWxlKTtcbiAgICAgIGlmIChqdXN0aWZpY2F0aW9uID09PSAnYXV0bycpIDsgZWxzZSBpZiAoaGFsaWduID09PSAnbGVmdCcpIHtcbiAgICAgICAgLy8gYXV0byBqdXN0aWZpY2F0aW9uIDogcmlnaHRcbiAgICAgICAgaWYgKGp1c3RpZmljYXRpb24gPT09ICdsZWZ0Jykge1xuICAgICAgICAgIHRleHRYICs9IC10ZXh0VztcbiAgICAgICAgfSBlbHNlIGlmIChqdXN0aWZpY2F0aW9uID09PSAnY2VudGVyJykge1xuICAgICAgICAgIHRleHRYICs9IC1oYWxmVGV4dFc7XG4gICAgICAgIH0gLy8gZWxzZSBzYW1lIGFzIGF1dG9cbiAgICAgIH0gZWxzZSBpZiAoaGFsaWduID09PSAnY2VudGVyJykge1xuICAgICAgICAvLyBhdXRvIGp1c3RmaWNhdGlvbiA6IGNlbnRlclxuICAgICAgICBpZiAoanVzdGlmaWNhdGlvbiA9PT0gJ2xlZnQnKSB7XG4gICAgICAgICAgdGV4dFggKz0gLWhhbGZUZXh0VztcbiAgICAgICAgfSBlbHNlIGlmIChqdXN0aWZpY2F0aW9uID09PSAncmlnaHQnKSB7XG4gICAgICAgICAgdGV4dFggKz0gaGFsZlRleHRXO1xuICAgICAgICB9IC8vIGVsc2Ugc2FtZSBhcyBhdXRvXG4gICAgICB9IGVsc2UgaWYgKGhhbGlnbiA9PT0gJ3JpZ2h0Jykge1xuICAgICAgICAvLyBhdXRvIGp1c3RpZmljYXRpb24gOiBsZWZ0XG4gICAgICAgIGlmIChqdXN0aWZpY2F0aW9uID09PSAnY2VudGVyJykge1xuICAgICAgICAgIHRleHRYICs9IGhhbGZUZXh0VztcbiAgICAgICAgfSBlbHNlIGlmIChqdXN0aWZpY2F0aW9uID09PSAncmlnaHQnKSB7XG4gICAgICAgICAgdGV4dFggKz0gdGV4dFc7XG4gICAgICAgIH0gLy8gZWxzZSBzYW1lIGFzIGF1dG9cbiAgICAgIH1cblxuICAgICAgc3dpdGNoICh2YWxpZ24pIHtcbiAgICAgICAgY2FzZSAndG9wJzpcbiAgICAgICAgICB0ZXh0WSAtPSAobGluZXMubGVuZ3RoIC0gMSkgKiBsaW5lSGVpZ2h0O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdjZW50ZXInOlxuICAgICAgICBjYXNlICdib3R0b20nOlxuICAgICAgICAgIHRleHRZIC09IChsaW5lcy5sZW5ndGggLSAxKSAqIGxpbmVIZWlnaHQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBsID0gMDsgbCA8IGxpbmVzLmxlbmd0aDsgbCsrKSB7XG4gICAgICAgIGlmIChsaW5lV2lkdGggPiAwKSB7XG4gICAgICAgICAgY29udGV4dC5zdHJva2VUZXh0KGxpbmVzW2xdLCB0ZXh0WCwgdGV4dFkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRleHQuZmlsbFRleHQobGluZXNbbF0sIHRleHRYLCB0ZXh0WSk7XG4gICAgICAgIHRleHRZICs9IGxpbmVIZWlnaHQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChsaW5lV2lkdGggPiAwKSB7XG4gICAgICAgIGNvbnRleHQuc3Ryb2tlVGV4dCh0ZXh0LCB0ZXh0WCwgdGV4dFkpO1xuICAgICAgfVxuICAgICAgY29udGV4dC5maWxsVGV4dCh0ZXh0LCB0ZXh0WCwgdGV4dFkpO1xuICAgIH1cbiAgICBpZiAodGhldGEgIT09IDApIHtcbiAgICAgIGNvbnRleHQucm90YXRlKC10aGV0YSk7XG4gICAgICBjb250ZXh0LnRyYW5zbGF0ZSgtb3JnVGV4dFgsIC1vcmdUZXh0WSk7XG4gICAgfVxuICB9XG59O1xuXG4vKiBnbG9iYWwgUGF0aDJEICovXG52YXIgQ1JwJDUgPSB7fTtcbkNScCQ1LmRyYXdOb2RlID0gZnVuY3Rpb24gKGNvbnRleHQsIG5vZGUsIHNoaWZ0VG9PcmlnaW5XaXRoQmIpIHtcbiAgdmFyIGRyYXdMYWJlbCA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogdHJ1ZTtcbiAgdmFyIHNob3VsZERyYXdPdmVybGF5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgJiYgYXJndW1lbnRzWzRdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNF0gOiB0cnVlO1xuICB2YXIgc2hvdWxkRHJhd09wYWNpdHkgPSBhcmd1bWVudHMubGVuZ3RoID4gNSAmJiBhcmd1bWVudHNbNV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s1XSA6IHRydWU7XG4gIHZhciByID0gdGhpcztcbiAgdmFyIG5vZGVXaWR0aCwgbm9kZUhlaWdodDtcbiAgdmFyIF9wID0gbm9kZS5fcHJpdmF0ZTtcbiAgdmFyIHJzID0gX3AucnNjcmF0Y2g7XG4gIHZhciBwb3MgPSBub2RlLnBvc2l0aW9uKCk7XG4gIGlmICghbnVtYmVyJDEocG9zLngpIHx8ICFudW1iZXIkMShwb3MueSkpIHtcbiAgICByZXR1cm47IC8vIGNhbid0IGRyYXcgbm9kZSB3aXRoIHVuZGVmaW5lZCBwb3NpdGlvblxuICB9XG5cbiAgaWYgKHNob3VsZERyYXdPcGFjaXR5ICYmICFub2RlLnZpc2libGUoKSkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgZWxlT3BhY2l0eSA9IHNob3VsZERyYXdPcGFjaXR5ID8gbm9kZS5lZmZlY3RpdmVPcGFjaXR5KCkgOiAxO1xuICB2YXIgdXNlUGF0aHMgPSByLnVzZVBhdGhzKCk7XG4gIHZhciBwYXRoO1xuICB2YXIgcGF0aENhY2hlSGl0ID0gZmFsc2U7XG4gIHZhciBwYWRkaW5nID0gbm9kZS5wYWRkaW5nKCk7XG4gIG5vZGVXaWR0aCA9IG5vZGUud2lkdGgoKSArIDIgKiBwYWRkaW5nO1xuICBub2RlSGVpZ2h0ID0gbm9kZS5oZWlnaHQoKSArIDIgKiBwYWRkaW5nO1xuXG4gIC8vXG4gIC8vIHNldHVwIHNoaWZ0XG5cbiAgdmFyIGJiO1xuICBpZiAoc2hpZnRUb09yaWdpbldpdGhCYikge1xuICAgIGJiID0gc2hpZnRUb09yaWdpbldpdGhCYjtcbiAgICBjb250ZXh0LnRyYW5zbGF0ZSgtYmIueDEsIC1iYi55MSk7XG4gIH1cblxuICAvL1xuICAvLyBsb2FkIGJnIGltYWdlXG5cbiAgdmFyIGJnSW1nUHJvcCA9IG5vZGUucHN0eWxlKCdiYWNrZ3JvdW5kLWltYWdlJyk7XG4gIHZhciB1cmxzID0gYmdJbWdQcm9wLnZhbHVlO1xuICB2YXIgdXJsRGVmaW5lZCA9IG5ldyBBcnJheSh1cmxzLmxlbmd0aCk7XG4gIHZhciBpbWFnZSA9IG5ldyBBcnJheSh1cmxzLmxlbmd0aCk7XG4gIHZhciBudW1JbWFnZXMgPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHVybHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgdXJsID0gdXJsc1tpXTtcbiAgICB2YXIgZGVmZCA9IHVybERlZmluZWRbaV0gPSB1cmwgIT0gbnVsbCAmJiB1cmwgIT09ICdub25lJztcbiAgICBpZiAoZGVmZCkge1xuICAgICAgdmFyIGJnSW1nQ3Jvc3NPcmlnaW4gPSBub2RlLmN5KCkuc3R5bGUoKS5nZXRJbmRleGVkU3R5bGUobm9kZSwgJ2JhY2tncm91bmQtaW1hZ2UtY3Jvc3NvcmlnaW4nLCAndmFsdWUnLCBpKTtcbiAgICAgIG51bUltYWdlcysrO1xuXG4gICAgICAvLyBnZXQgaW1hZ2UsIGFuZCBpZiBub3QgbG9hZGVkIHRoZW4gYXNrIHRvIHJlZHJhdyB3aGVuIGxhdGVyIGxvYWRlZFxuICAgICAgaW1hZ2VbaV0gPSByLmdldENhY2hlZEltYWdlKHVybCwgYmdJbWdDcm9zc09yaWdpbiwgZnVuY3Rpb24gKCkge1xuICAgICAgICBfcC5iYWNrZ3JvdW5kVGltZXN0YW1wID0gRGF0ZS5ub3coKTtcbiAgICAgICAgbm9kZS5lbWl0QW5kTm90aWZ5KCdiYWNrZ3JvdW5kJyk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvL1xuICAvLyBzZXR1cCBzdHlsZXNcblxuICB2YXIgZGFya25lc3MgPSBub2RlLnBzdHlsZSgnYmFja2dyb3VuZC1ibGFja2VuJykudmFsdWU7XG4gIHZhciBib3JkZXJXaWR0aCA9IG5vZGUucHN0eWxlKCdib3JkZXItd2lkdGgnKS5wZlZhbHVlO1xuICB2YXIgYmdPcGFjaXR5ID0gbm9kZS5wc3R5bGUoJ2JhY2tncm91bmQtb3BhY2l0eScpLnZhbHVlICogZWxlT3BhY2l0eTtcbiAgdmFyIGJvcmRlckNvbG9yID0gbm9kZS5wc3R5bGUoJ2JvcmRlci1jb2xvcicpLnZhbHVlO1xuICB2YXIgYm9yZGVyU3R5bGUgPSBub2RlLnBzdHlsZSgnYm9yZGVyLXN0eWxlJykudmFsdWU7XG4gIHZhciBib3JkZXJKb2luID0gbm9kZS5wc3R5bGUoJ2JvcmRlci1qb2luJykudmFsdWU7XG4gIHZhciBib3JkZXJDYXAgPSBub2RlLnBzdHlsZSgnYm9yZGVyLWNhcCcpLnZhbHVlO1xuICB2YXIgYm9yZGVyUG9zaXRpb24gPSBub2RlLnBzdHlsZSgnYm9yZGVyLXBvc2l0aW9uJykudmFsdWU7XG4gIHZhciBib3JkZXJQYXR0ZXJuID0gbm9kZS5wc3R5bGUoJ2JvcmRlci1kYXNoLXBhdHRlcm4nKS5wZlZhbHVlO1xuICB2YXIgYm9yZGVyT2Zmc2V0ID0gbm9kZS5wc3R5bGUoJ2JvcmRlci1kYXNoLW9mZnNldCcpLnBmVmFsdWU7XG4gIHZhciBib3JkZXJPcGFjaXR5ID0gbm9kZS5wc3R5bGUoJ2JvcmRlci1vcGFjaXR5JykudmFsdWUgKiBlbGVPcGFjaXR5O1xuICB2YXIgb3V0bGluZVdpZHRoID0gbm9kZS5wc3R5bGUoJ291dGxpbmUtd2lkdGgnKS5wZlZhbHVlO1xuICB2YXIgb3V0bGluZUNvbG9yID0gbm9kZS5wc3R5bGUoJ291dGxpbmUtY29sb3InKS52YWx1ZTtcbiAgdmFyIG91dGxpbmVTdHlsZSA9IG5vZGUucHN0eWxlKCdvdXRsaW5lLXN0eWxlJykudmFsdWU7XG4gIHZhciBvdXRsaW5lT3BhY2l0eSA9IG5vZGUucHN0eWxlKCdvdXRsaW5lLW9wYWNpdHknKS52YWx1ZSAqIGVsZU9wYWNpdHk7XG4gIHZhciBvdXRsaW5lT2Zmc2V0ID0gbm9kZS5wc3R5bGUoJ291dGxpbmUtb2Zmc2V0JykudmFsdWU7XG4gIHZhciBjb3JuZXJSYWRpdXMgPSBub2RlLnBzdHlsZSgnY29ybmVyLXJhZGl1cycpLnZhbHVlO1xuICBpZiAoY29ybmVyUmFkaXVzICE9PSAnYXV0bycpIGNvcm5lclJhZGl1cyA9IG5vZGUucHN0eWxlKCdjb3JuZXItcmFkaXVzJykucGZWYWx1ZTtcbiAgdmFyIHNldHVwU2hhcGVDb2xvciA9IGZ1bmN0aW9uIHNldHVwU2hhcGVDb2xvcigpIHtcbiAgICB2YXIgYmdPcHkgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IGJnT3BhY2l0eTtcbiAgICByLmVsZUZpbGxTdHlsZShjb250ZXh0LCBub2RlLCBiZ09weSk7XG4gIH07XG4gIHZhciBzZXR1cEJvcmRlckNvbG9yID0gZnVuY3Rpb24gc2V0dXBCb3JkZXJDb2xvcigpIHtcbiAgICB2YXIgYmRyT3B5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBib3JkZXJPcGFjaXR5O1xuICAgIHIuY29sb3JTdHJva2VTdHlsZShjb250ZXh0LCBib3JkZXJDb2xvclswXSwgYm9yZGVyQ29sb3JbMV0sIGJvcmRlckNvbG9yWzJdLCBiZHJPcHkpO1xuICB9O1xuICB2YXIgc2V0dXBPdXRsaW5lQ29sb3IgPSBmdW5jdGlvbiBzZXR1cE91dGxpbmVDb2xvcigpIHtcbiAgICB2YXIgb3Rsbk9weSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogb3V0bGluZU9wYWNpdHk7XG4gICAgci5jb2xvclN0cm9rZVN0eWxlKGNvbnRleHQsIG91dGxpbmVDb2xvclswXSwgb3V0bGluZUNvbG9yWzFdLCBvdXRsaW5lQ29sb3JbMl0sIG90bG5PcHkpO1xuICB9O1xuXG4gIC8vXG4gIC8vIHNldHVwIHNoYXBlXG5cbiAgdmFyIGdldFBhdGggPSBmdW5jdGlvbiBnZXRQYXRoKHdpZHRoLCBoZWlnaHQsIHNoYXBlLCBwb2ludHMpIHtcbiAgICB2YXIgcGF0aENhY2hlID0gci5ub2RlUGF0aENhY2hlID0gci5ub2RlUGF0aENhY2hlIHx8IFtdO1xuICAgIHZhciBrZXkgPSBoYXNoU3RyaW5ncyhzaGFwZSA9PT0gJ3BvbHlnb24nID8gc2hhcGUgKyAnLCcgKyBwb2ludHMuam9pbignLCcpIDogc2hhcGUsICcnICsgaGVpZ2h0LCAnJyArIHdpZHRoLCAnJyArIGNvcm5lclJhZGl1cyk7XG4gICAgdmFyIGNhY2hlZFBhdGggPSBwYXRoQ2FjaGVba2V5XTtcbiAgICB2YXIgcGF0aDtcbiAgICB2YXIgY2FjaGVIaXQgPSBmYWxzZTtcbiAgICBpZiAoY2FjaGVkUGF0aCAhPSBudWxsKSB7XG4gICAgICBwYXRoID0gY2FjaGVkUGF0aDtcbiAgICAgIGNhY2hlSGl0ID0gdHJ1ZTtcbiAgICAgIHJzLnBhdGhDYWNoZSA9IHBhdGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhdGggPSBuZXcgUGF0aDJEKCk7XG4gICAgICBwYXRoQ2FjaGVba2V5XSA9IHJzLnBhdGhDYWNoZSA9IHBhdGg7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBwYXRoOiBwYXRoLFxuICAgICAgY2FjaGVIaXQ6IGNhY2hlSGl0XG4gICAgfTtcbiAgfTtcbiAgdmFyIHN0eWxlU2hhcGUgPSBub2RlLnBzdHlsZSgnc2hhcGUnKS5zdHJWYWx1ZTtcbiAgdmFyIHNoYXBlUHRzID0gbm9kZS5wc3R5bGUoJ3NoYXBlLXBvbHlnb24tcG9pbnRzJykucGZWYWx1ZTtcbiAgaWYgKHVzZVBhdGhzKSB7XG4gICAgY29udGV4dC50cmFuc2xhdGUocG9zLngsIHBvcy55KTtcbiAgICB2YXIgc2hhcGVQYXRoID0gZ2V0UGF0aChub2RlV2lkdGgsIG5vZGVIZWlnaHQsIHN0eWxlU2hhcGUsIHNoYXBlUHRzKTtcbiAgICBwYXRoID0gc2hhcGVQYXRoLnBhdGg7XG4gICAgcGF0aENhY2hlSGl0ID0gc2hhcGVQYXRoLmNhY2hlSGl0O1xuICB9XG4gIHZhciBkcmF3U2hhcGUgPSBmdW5jdGlvbiBkcmF3U2hhcGUoKSB7XG4gICAgaWYgKCFwYXRoQ2FjaGVIaXQpIHtcbiAgICAgIHZhciBucG9zID0gcG9zO1xuICAgICAgaWYgKHVzZVBhdGhzKSB7XG4gICAgICAgIG5wb3MgPSB7XG4gICAgICAgICAgeDogMCxcbiAgICAgICAgICB5OiAwXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByLm5vZGVTaGFwZXNbci5nZXROb2RlU2hhcGUobm9kZSldLmRyYXcocGF0aCB8fCBjb250ZXh0LCBucG9zLngsIG5wb3MueSwgbm9kZVdpZHRoLCBub2RlSGVpZ2h0LCBjb3JuZXJSYWRpdXMsIHJzKTtcbiAgICB9XG4gICAgaWYgKHVzZVBhdGhzKSB7XG4gICAgICBjb250ZXh0LmZpbGwocGF0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnRleHQuZmlsbCgpO1xuICAgIH1cbiAgfTtcbiAgdmFyIGRyYXdJbWFnZXMgPSBmdW5jdGlvbiBkcmF3SW1hZ2VzKCkge1xuICAgIHZhciBub2RlT3BhY2l0eSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogZWxlT3BhY2l0eTtcbiAgICB2YXIgaW5zaWRlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0cnVlO1xuICAgIHZhciBwcmV2QmdpbmcgPSBfcC5iYWNrZ3JvdW5kaW5nO1xuICAgIHZhciB0b3RhbENvbXBsZXRlZCA9IDA7XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGltYWdlLmxlbmd0aDsgX2krKykge1xuICAgICAgdmFyIGJnQ29udGFpbm1lbnQgPSBub2RlLmN5KCkuc3R5bGUoKS5nZXRJbmRleGVkU3R5bGUobm9kZSwgJ2JhY2tncm91bmQtaW1hZ2UtY29udGFpbm1lbnQnLCAndmFsdWUnLCBfaSk7XG4gICAgICBpZiAoaW5zaWRlICYmIGJnQ29udGFpbm1lbnQgPT09ICdvdmVyJyB8fCAhaW5zaWRlICYmIGJnQ29udGFpbm1lbnQgPT09ICdpbnNpZGUnKSB7XG4gICAgICAgIHRvdGFsQ29tcGxldGVkKys7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKHVybERlZmluZWRbX2ldICYmIGltYWdlW19pXS5jb21wbGV0ZSAmJiAhaW1hZ2VbX2ldLmVycm9yKSB7XG4gICAgICAgIHRvdGFsQ29tcGxldGVkKys7XG4gICAgICAgIHIuZHJhd0luc2NyaWJlZEltYWdlKGNvbnRleHQsIGltYWdlW19pXSwgbm9kZSwgX2ksIG5vZGVPcGFjaXR5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgX3AuYmFja2dyb3VuZGluZyA9ICEodG90YWxDb21wbGV0ZWQgPT09IG51bUltYWdlcyk7XG4gICAgaWYgKHByZXZCZ2luZyAhPT0gX3AuYmFja2dyb3VuZGluZykge1xuICAgICAgLy8gdXBkYXRlIHN0eWxlIGIvYyA6YmFja2dyb3VuZGluZyBzdGF0ZSBjaGFuZ2VkXG4gICAgICBub2RlLnVwZGF0ZVN0eWxlKGZhbHNlKTtcbiAgICB9XG4gIH07XG4gIHZhciBkcmF3UGllID0gZnVuY3Rpb24gZHJhd1BpZSgpIHtcbiAgICB2YXIgcmVkcmF3U2hhcGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IGZhbHNlO1xuICAgIHZhciBwaWVPcGFjaXR5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBlbGVPcGFjaXR5O1xuICAgIGlmIChyLmhhc1BpZShub2RlKSkge1xuICAgICAgci5kcmF3UGllKGNvbnRleHQsIG5vZGUsIHBpZU9wYWNpdHkpO1xuXG4gICAgICAvLyByZWRyYXcvcmVzdG9yZSBwYXRoIGlmIHN0ZXBzIGFmdGVyIHBpZSBuZWVkIGl0XG4gICAgICBpZiAocmVkcmF3U2hhcGUpIHtcbiAgICAgICAgaWYgKCF1c2VQYXRocykge1xuICAgICAgICAgIHIubm9kZVNoYXBlc1tyLmdldE5vZGVTaGFwZShub2RlKV0uZHJhdyhjb250ZXh0LCBwb3MueCwgcG9zLnksIG5vZGVXaWR0aCwgbm9kZUhlaWdodCwgY29ybmVyUmFkaXVzLCBycyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIHZhciBkYXJrZW4gPSBmdW5jdGlvbiBkYXJrZW4oKSB7XG4gICAgdmFyIGRhcmtlbk9wYWNpdHkgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IGVsZU9wYWNpdHk7XG4gICAgdmFyIG9wYWNpdHkgPSAoZGFya25lc3MgPiAwID8gZGFya25lc3MgOiAtZGFya25lc3MpICogZGFya2VuT3BhY2l0eTtcbiAgICB2YXIgYyA9IGRhcmtuZXNzID4gMCA/IDAgOiAyNTU7XG4gICAgaWYgKGRhcmtuZXNzICE9PSAwKSB7XG4gICAgICByLmNvbG9yRmlsbFN0eWxlKGNvbnRleHQsIGMsIGMsIGMsIG9wYWNpdHkpO1xuICAgICAgaWYgKHVzZVBhdGhzKSB7XG4gICAgICAgIGNvbnRleHQuZmlsbChwYXRoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnRleHQuZmlsbCgpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgdmFyIGRyYXdCb3JkZXIgPSBmdW5jdGlvbiBkcmF3Qm9yZGVyKCkge1xuICAgIGlmIChib3JkZXJXaWR0aCA+IDApIHtcbiAgICAgIGNvbnRleHQubGluZVdpZHRoID0gYm9yZGVyV2lkdGg7XG4gICAgICBjb250ZXh0LmxpbmVDYXAgPSBib3JkZXJDYXA7XG4gICAgICBjb250ZXh0LmxpbmVKb2luID0gYm9yZGVySm9pbjtcbiAgICAgIGlmIChjb250ZXh0LnNldExpbmVEYXNoKSB7XG4gICAgICAgIC8vIGZvciB2ZXJ5IG91dG9mZGF0ZSBicm93c2Vyc1xuICAgICAgICBzd2l0Y2ggKGJvcmRlclN0eWxlKSB7XG4gICAgICAgICAgY2FzZSAnZG90dGVkJzpcbiAgICAgICAgICAgIGNvbnRleHQuc2V0TGluZURhc2goWzEsIDFdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ2Rhc2hlZCc6XG4gICAgICAgICAgICBjb250ZXh0LnNldExpbmVEYXNoKGJvcmRlclBhdHRlcm4pO1xuICAgICAgICAgICAgY29udGV4dC5saW5lRGFzaE9mZnNldCA9IGJvcmRlck9mZnNldDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ3NvbGlkJzpcbiAgICAgICAgICBjYXNlICdkb3VibGUnOlxuICAgICAgICAgICAgY29udGV4dC5zZXRMaW5lRGFzaChbXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGJvcmRlclBvc2l0aW9uICE9PSAnY2VudGVyJykge1xuICAgICAgICBjb250ZXh0LnNhdmUoKTtcbiAgICAgICAgY29udGV4dC5saW5lV2lkdGggKj0gMjtcbiAgICAgICAgaWYgKGJvcmRlclBvc2l0aW9uID09PSAnaW5zaWRlJykge1xuICAgICAgICAgIHVzZVBhdGhzID8gY29udGV4dC5jbGlwKHBhdGgpIDogY29udGV4dC5jbGlwKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHJlZ2lvbiA9IG5ldyBQYXRoMkQoKTtcbiAgICAgICAgICByZWdpb24ucmVjdCgtbm9kZVdpZHRoIC8gMiAtIGJvcmRlcldpZHRoLCAtbm9kZUhlaWdodCAvIDIgLSBib3JkZXJXaWR0aCwgbm9kZVdpZHRoICsgMiAqIGJvcmRlcldpZHRoLCBub2RlSGVpZ2h0ICsgMiAqIGJvcmRlcldpZHRoKTtcbiAgICAgICAgICByZWdpb24uYWRkUGF0aChwYXRoKTtcbiAgICAgICAgICBjb250ZXh0LmNsaXAocmVnaW9uLCAnZXZlbm9kZCcpO1xuICAgICAgICB9XG4gICAgICAgIHVzZVBhdGhzID8gY29udGV4dC5zdHJva2UocGF0aCkgOiBjb250ZXh0LnN0cm9rZSgpO1xuICAgICAgICBjb250ZXh0LnJlc3RvcmUoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHVzZVBhdGhzID8gY29udGV4dC5zdHJva2UocGF0aCkgOiBjb250ZXh0LnN0cm9rZSgpO1xuICAgICAgfVxuICAgICAgaWYgKGJvcmRlclN0eWxlID09PSAnZG91YmxlJykge1xuICAgICAgICBjb250ZXh0LmxpbmVXaWR0aCA9IGJvcmRlcldpZHRoIC8gMztcbiAgICAgICAgdmFyIGdjbyA9IGNvbnRleHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uO1xuICAgICAgICBjb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9ICdkZXN0aW5hdGlvbi1vdXQnO1xuICAgICAgICBpZiAodXNlUGF0aHMpIHtcbiAgICAgICAgICBjb250ZXh0LnN0cm9rZShwYXRoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb250ZXh0LnN0cm9rZSgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRleHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gZ2NvO1xuICAgICAgfVxuXG4gICAgICAvLyByZXNldCBpbiBjYXNlIHdlIGNoYW5nZWQgdGhlIGJvcmRlciBzdHlsZVxuICAgICAgaWYgKGNvbnRleHQuc2V0TGluZURhc2gpIHtcbiAgICAgICAgLy8gZm9yIHZlcnkgb3V0b2ZkYXRlIGJyb3dzZXJzXG4gICAgICAgIGNvbnRleHQuc2V0TGluZURhc2goW10pO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgdmFyIGRyYXdPdXRsaW5lID0gZnVuY3Rpb24gZHJhd091dGxpbmUoKSB7XG4gICAgaWYgKG91dGxpbmVXaWR0aCA+IDApIHtcbiAgICAgIGNvbnRleHQubGluZVdpZHRoID0gb3V0bGluZVdpZHRoO1xuICAgICAgY29udGV4dC5saW5lQ2FwID0gJ2J1dHQnO1xuICAgICAgaWYgKGNvbnRleHQuc2V0TGluZURhc2gpIHtcbiAgICAgICAgLy8gZm9yIHZlcnkgb3V0b2ZkYXRlIGJyb3dzZXJzXG4gICAgICAgIHN3aXRjaCAob3V0bGluZVN0eWxlKSB7XG4gICAgICAgICAgY2FzZSAnZG90dGVkJzpcbiAgICAgICAgICAgIGNvbnRleHQuc2V0TGluZURhc2goWzEsIDFdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ2Rhc2hlZCc6XG4gICAgICAgICAgICBjb250ZXh0LnNldExpbmVEYXNoKFs0LCAyXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdzb2xpZCc6XG4gICAgICAgICAgY2FzZSAnZG91YmxlJzpcbiAgICAgICAgICAgIGNvbnRleHQuc2V0TGluZURhc2goW10pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBucG9zID0gcG9zO1xuICAgICAgaWYgKHVzZVBhdGhzKSB7XG4gICAgICAgIG5wb3MgPSB7XG4gICAgICAgICAgeDogMCxcbiAgICAgICAgICB5OiAwXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICB2YXIgc2hhcGUgPSByLmdldE5vZGVTaGFwZShub2RlKTtcbiAgICAgIHZhciBiV2lkdGggPSBib3JkZXJXaWR0aDtcbiAgICAgIGlmIChib3JkZXJQb3NpdGlvbiA9PT0gJ2luc2lkZScpIGJXaWR0aCA9IDA7XG4gICAgICBpZiAoYm9yZGVyUG9zaXRpb24gPT09ICdvdXRzaWRlJykgYldpZHRoICo9IDI7XG4gICAgICB2YXIgc2NhbGVYID0gKG5vZGVXaWR0aCArIGJXaWR0aCArIChvdXRsaW5lV2lkdGggKyBvdXRsaW5lT2Zmc2V0KSkgLyBub2RlV2lkdGg7XG4gICAgICB2YXIgc2NhbGVZID0gKG5vZGVIZWlnaHQgKyBiV2lkdGggKyAob3V0bGluZVdpZHRoICsgb3V0bGluZU9mZnNldCkpIC8gbm9kZUhlaWdodDtcbiAgICAgIHZhciBzV2lkdGggPSBub2RlV2lkdGggKiBzY2FsZVg7XG4gICAgICB2YXIgc0hlaWdodCA9IG5vZGVIZWlnaHQgKiBzY2FsZVk7XG4gICAgICB2YXIgcG9pbnRzID0gci5ub2RlU2hhcGVzW3NoYXBlXS5wb2ludHM7XG4gICAgICB2YXIgX3BhdGg7XG4gICAgICBpZiAodXNlUGF0aHMpIHtcbiAgICAgICAgdmFyIG91dGxpbmVQYXRoID0gZ2V0UGF0aChzV2lkdGgsIHNIZWlnaHQsIHNoYXBlLCBwb2ludHMpO1xuICAgICAgICBfcGF0aCA9IG91dGxpbmVQYXRoLnBhdGg7XG4gICAgICB9XG5cbiAgICAgIC8vIGRyYXcgdGhlIG91dGxpbmUgcGF0aCwgZWl0aGVyIGJ5IHVzaW5nIGV4cGFuZGVkIHBvaW50cyBvciBieSBzY2FsaW5nIFxuICAgICAgLy8gdGhlIGRpbWVuc2lvbnMsIGRlcGVuZGluZyBvbiBzaGFwZVxuICAgICAgaWYgKHNoYXBlID09PSBcImVsbGlwc2VcIikge1xuICAgICAgICByLmRyYXdFbGxpcHNlUGF0aChfcGF0aCB8fCBjb250ZXh0LCBucG9zLngsIG5wb3MueSwgc1dpZHRoLCBzSGVpZ2h0KTtcbiAgICAgIH0gZWxzZSBpZiAoWydyb3VuZC1kaWFtb25kJywgJ3JvdW5kLWhlcHRhZ29uJywgJ3JvdW5kLWhleGFnb24nLCAncm91bmQtb2N0YWdvbicsICdyb3VuZC1wZW50YWdvbicsICdyb3VuZC1wb2x5Z29uJywgJ3JvdW5kLXRyaWFuZ2xlJywgJ3JvdW5kLXRhZyddLmluY2x1ZGVzKHNoYXBlKSkge1xuICAgICAgICB2YXIgc011bHQgPSAwO1xuICAgICAgICB2YXIgb2Zmc2V0WCA9IDA7XG4gICAgICAgIHZhciBvZmZzZXRZID0gMDtcbiAgICAgICAgaWYgKHNoYXBlID09PSAncm91bmQtZGlhbW9uZCcpIHtcbiAgICAgICAgICBzTXVsdCA9IChiV2lkdGggKyBvdXRsaW5lT2Zmc2V0ICsgb3V0bGluZVdpZHRoKSAqIDEuNDtcbiAgICAgICAgfSBlbHNlIGlmIChzaGFwZSA9PT0gJ3JvdW5kLWhlcHRhZ29uJykge1xuICAgICAgICAgIHNNdWx0ID0gKGJXaWR0aCArIG91dGxpbmVPZmZzZXQgKyBvdXRsaW5lV2lkdGgpICogMS4wNzU7XG4gICAgICAgICAgb2Zmc2V0WSA9IC0oYldpZHRoIC8gMiArIG91dGxpbmVPZmZzZXQgKyBvdXRsaW5lV2lkdGgpIC8gMzU7XG4gICAgICAgIH0gZWxzZSBpZiAoc2hhcGUgPT09ICdyb3VuZC1oZXhhZ29uJykge1xuICAgICAgICAgIHNNdWx0ID0gKGJXaWR0aCArIG91dGxpbmVPZmZzZXQgKyBvdXRsaW5lV2lkdGgpICogMS4xMjtcbiAgICAgICAgfSBlbHNlIGlmIChzaGFwZSA9PT0gJ3JvdW5kLXBlbnRhZ29uJykge1xuICAgICAgICAgIHNNdWx0ID0gKGJXaWR0aCArIG91dGxpbmVPZmZzZXQgKyBvdXRsaW5lV2lkdGgpICogMS4xMztcbiAgICAgICAgICBvZmZzZXRZID0gLShiV2lkdGggLyAyICsgb3V0bGluZU9mZnNldCArIG91dGxpbmVXaWR0aCkgLyAxNTtcbiAgICAgICAgfSBlbHNlIGlmIChzaGFwZSA9PT0gJ3JvdW5kLXRhZycpIHtcbiAgICAgICAgICBzTXVsdCA9IChiV2lkdGggKyBvdXRsaW5lT2Zmc2V0ICsgb3V0bGluZVdpZHRoKSAqIDEuMTI7XG4gICAgICAgICAgb2Zmc2V0WCA9IChiV2lkdGggLyAyICsgb3V0bGluZVdpZHRoICsgb3V0bGluZU9mZnNldCkgKiAuMDc7XG4gICAgICAgIH0gZWxzZSBpZiAoc2hhcGUgPT09ICdyb3VuZC10cmlhbmdsZScpIHtcbiAgICAgICAgICBzTXVsdCA9IChiV2lkdGggKyBvdXRsaW5lT2Zmc2V0ICsgb3V0bGluZVdpZHRoKSAqIChNYXRoLlBJIC8gMik7XG4gICAgICAgICAgb2Zmc2V0WSA9IC0oYldpZHRoICsgb3V0bGluZU9mZnNldCAvIDIgKyBvdXRsaW5lV2lkdGgpIC8gTWF0aC5QSTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc011bHQgIT09IDApIHtcbiAgICAgICAgICBzY2FsZVggPSAobm9kZVdpZHRoICsgc011bHQpIC8gbm9kZVdpZHRoO1xuICAgICAgICAgIHNXaWR0aCA9IG5vZGVXaWR0aCAqIHNjYWxlWDtcbiAgICAgICAgICBpZiAoIVsncm91bmQtaGV4YWdvbicsICdyb3VuZC10YWcnXS5pbmNsdWRlcyhzaGFwZSkpIHtcbiAgICAgICAgICAgIHNjYWxlWSA9IChub2RlSGVpZ2h0ICsgc011bHQpIC8gbm9kZUhlaWdodDtcbiAgICAgICAgICAgIHNIZWlnaHQgPSBub2RlSGVpZ2h0ICogc2NhbGVZO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb3JuZXJSYWRpdXMgPSBjb3JuZXJSYWRpdXMgPT09ICdhdXRvJyA/IGdldFJvdW5kUG9seWdvblJhZGl1cyhzV2lkdGgsIHNIZWlnaHQpIDogY29ybmVyUmFkaXVzO1xuICAgICAgICB2YXIgaGFsZlcgPSBzV2lkdGggLyAyO1xuICAgICAgICB2YXIgaGFsZkggPSBzSGVpZ2h0IC8gMjtcbiAgICAgICAgdmFyIHJhZGl1cyA9IGNvcm5lclJhZGl1cyArIChiV2lkdGggKyBvdXRsaW5lV2lkdGggKyBvdXRsaW5lT2Zmc2V0KSAvIDI7XG4gICAgICAgIHZhciBwID0gbmV3IEFycmF5KHBvaW50cy5sZW5ndGggLyAyKTtcbiAgICAgICAgdmFyIGNvcm5lcnMgPSBuZXcgQXJyYXkocG9pbnRzLmxlbmd0aCAvIDIpO1xuICAgICAgICBmb3IgKHZhciBfaTMgPSAwOyBfaTMgPCBwb2ludHMubGVuZ3RoIC8gMjsgX2kzKyspIHtcbiAgICAgICAgICBwW19pM10gPSB7XG4gICAgICAgICAgICB4OiBucG9zLnggKyBvZmZzZXRYICsgaGFsZlcgKiBwb2ludHNbX2kzICogMl0sXG4gICAgICAgICAgICB5OiBucG9zLnkgKyBvZmZzZXRZICsgaGFsZkggKiBwb2ludHNbX2kzICogMiArIDFdXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgX2kyLFxuICAgICAgICAgIHAxLFxuICAgICAgICAgIHAyLFxuICAgICAgICAgIHAzLFxuICAgICAgICAgIGxlbiA9IHAubGVuZ3RoO1xuICAgICAgICBwMSA9IHBbbGVuIC0gMV07XG4gICAgICAgIC8vIGZvciBlYWNoIHBvaW50XG4gICAgICAgIGZvciAoX2kyID0gMDsgX2kyIDwgbGVuOyBfaTIrKykge1xuICAgICAgICAgIHAyID0gcFtfaTIgJSBsZW5dO1xuICAgICAgICAgIHAzID0gcFsoX2kyICsgMSkgJSBsZW5dO1xuICAgICAgICAgIGNvcm5lcnNbX2kyXSA9IGdldFJvdW5kQ29ybmVyKHAxLCBwMiwgcDMsIHJhZGl1cyk7XG4gICAgICAgICAgcDEgPSBwMjtcbiAgICAgICAgICBwMiA9IHAzO1xuICAgICAgICB9XG4gICAgICAgIHIuZHJhd1JvdW5kUG9seWdvblBhdGgoX3BhdGggfHwgY29udGV4dCwgbnBvcy54ICsgb2Zmc2V0WCwgbnBvcy55ICsgb2Zmc2V0WSwgbm9kZVdpZHRoICogc2NhbGVYLCBub2RlSGVpZ2h0ICogc2NhbGVZLCBwb2ludHMsIGNvcm5lcnMpO1xuICAgICAgfSBlbHNlIGlmIChbJ3JvdW5kcmVjdGFuZ2xlJywgJ3JvdW5kLXJlY3RhbmdsZSddLmluY2x1ZGVzKHNoYXBlKSkge1xuICAgICAgICBjb3JuZXJSYWRpdXMgPSBjb3JuZXJSYWRpdXMgPT09ICdhdXRvJyA/IGdldFJvdW5kUmVjdGFuZ2xlUmFkaXVzKHNXaWR0aCwgc0hlaWdodCkgOiBjb3JuZXJSYWRpdXM7XG4gICAgICAgIHIuZHJhd1JvdW5kUmVjdGFuZ2xlUGF0aChfcGF0aCB8fCBjb250ZXh0LCBucG9zLngsIG5wb3MueSwgc1dpZHRoLCBzSGVpZ2h0LCBjb3JuZXJSYWRpdXMgKyAoYldpZHRoICsgb3V0bGluZVdpZHRoICsgb3V0bGluZU9mZnNldCkgLyAyKTtcbiAgICAgIH0gZWxzZSBpZiAoWydjdXRyZWN0YW5nbGUnLCAnY3V0LXJlY3RhbmdsZSddLmluY2x1ZGVzKHNoYXBlKSkge1xuICAgICAgICBjb3JuZXJSYWRpdXMgPSBjb3JuZXJSYWRpdXMgPT09ICdhdXRvJyA/IGdldEN1dFJlY3RhbmdsZUNvcm5lckxlbmd0aCgpIDogY29ybmVyUmFkaXVzO1xuICAgICAgICByLmRyYXdDdXRSZWN0YW5nbGVQYXRoKF9wYXRoIHx8IGNvbnRleHQsIG5wb3MueCwgbnBvcy55LCBzV2lkdGgsIHNIZWlnaHQsIG51bGwsIGNvcm5lclJhZGl1cyArIChiV2lkdGggKyBvdXRsaW5lV2lkdGggKyBvdXRsaW5lT2Zmc2V0KSAvIDQpO1xuICAgICAgfSBlbHNlIGlmIChbJ2JvdHRvbXJvdW5kcmVjdGFuZ2xlJywgJ2JvdHRvbS1yb3VuZC1yZWN0YW5nbGUnXS5pbmNsdWRlcyhzaGFwZSkpIHtcbiAgICAgICAgY29ybmVyUmFkaXVzID0gY29ybmVyUmFkaXVzID09PSAnYXV0bycgPyBnZXRSb3VuZFJlY3RhbmdsZVJhZGl1cyhzV2lkdGgsIHNIZWlnaHQpIDogY29ybmVyUmFkaXVzO1xuICAgICAgICByLmRyYXdCb3R0b21Sb3VuZFJlY3RhbmdsZVBhdGgoX3BhdGggfHwgY29udGV4dCwgbnBvcy54LCBucG9zLnksIHNXaWR0aCwgc0hlaWdodCwgY29ybmVyUmFkaXVzICsgKGJXaWR0aCArIG91dGxpbmVXaWR0aCArIG91dGxpbmVPZmZzZXQpIC8gMik7XG4gICAgICB9IGVsc2UgaWYgKHNoYXBlID09PSBcImJhcnJlbFwiKSB7XG4gICAgICAgIHIuZHJhd0JhcnJlbFBhdGgoX3BhdGggfHwgY29udGV4dCwgbnBvcy54LCBucG9zLnksIHNXaWR0aCwgc0hlaWdodCk7XG4gICAgICB9IGVsc2UgaWYgKHNoYXBlLnN0YXJ0c1dpdGgoXCJwb2x5Z29uXCIpIHx8IFsncmhvbWJvaWQnLCAncmlnaHQtcmhvbWJvaWQnLCAncm91bmQtdGFnJywgJ3RhZycsICd2ZWUnXS5pbmNsdWRlcyhzaGFwZSkpIHtcbiAgICAgICAgdmFyIHBhZCA9IChiV2lkdGggKyBvdXRsaW5lV2lkdGggKyBvdXRsaW5lT2Zmc2V0KSAvIG5vZGVXaWR0aDtcbiAgICAgICAgcG9pbnRzID0gam9pbkxpbmVzKGV4cGFuZFBvbHlnb24ocG9pbnRzLCBwYWQpKTtcbiAgICAgICAgci5kcmF3UG9seWdvblBhdGgoX3BhdGggfHwgY29udGV4dCwgbnBvcy54LCBucG9zLnksIG5vZGVXaWR0aCwgbm9kZUhlaWdodCwgcG9pbnRzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBfcGFkID0gKGJXaWR0aCArIG91dGxpbmVXaWR0aCArIG91dGxpbmVPZmZzZXQpIC8gbm9kZVdpZHRoO1xuICAgICAgICBwb2ludHMgPSBqb2luTGluZXMoZXhwYW5kUG9seWdvbihwb2ludHMsIC1fcGFkKSk7XG4gICAgICAgIHIuZHJhd1BvbHlnb25QYXRoKF9wYXRoIHx8IGNvbnRleHQsIG5wb3MueCwgbnBvcy55LCBub2RlV2lkdGgsIG5vZGVIZWlnaHQsIHBvaW50cyk7XG4gICAgICB9XG4gICAgICBpZiAodXNlUGF0aHMpIHtcbiAgICAgICAgY29udGV4dC5zdHJva2UoX3BhdGgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udGV4dC5zdHJva2UoKTtcbiAgICAgIH1cbiAgICAgIGlmIChvdXRsaW5lU3R5bGUgPT09ICdkb3VibGUnKSB7XG4gICAgICAgIGNvbnRleHQubGluZVdpZHRoID0gYldpZHRoIC8gMztcbiAgICAgICAgdmFyIGdjbyA9IGNvbnRleHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uO1xuICAgICAgICBjb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9ICdkZXN0aW5hdGlvbi1vdXQnO1xuICAgICAgICBpZiAodXNlUGF0aHMpIHtcbiAgICAgICAgICBjb250ZXh0LnN0cm9rZShfcGF0aCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29udGV4dC5zdHJva2UoKTtcbiAgICAgICAgfVxuICAgICAgICBjb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IGdjbztcbiAgICAgIH1cblxuICAgICAgLy8gcmVzZXQgaW4gY2FzZSB3ZSBjaGFuZ2VkIHRoZSBib3JkZXIgc3R5bGVcbiAgICAgIGlmIChjb250ZXh0LnNldExpbmVEYXNoKSB7XG4gICAgICAgIC8vIGZvciB2ZXJ5IG91dG9mZGF0ZSBicm93c2Vyc1xuICAgICAgICBjb250ZXh0LnNldExpbmVEYXNoKFtdKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIHZhciBkcmF3T3ZlcmxheSA9IGZ1bmN0aW9uIGRyYXdPdmVybGF5KCkge1xuICAgIGlmIChzaG91bGREcmF3T3ZlcmxheSkge1xuICAgICAgci5kcmF3Tm9kZU92ZXJsYXkoY29udGV4dCwgbm9kZSwgcG9zLCBub2RlV2lkdGgsIG5vZGVIZWlnaHQpO1xuICAgIH1cbiAgfTtcbiAgdmFyIGRyYXdVbmRlcmxheSA9IGZ1bmN0aW9uIGRyYXdVbmRlcmxheSgpIHtcbiAgICBpZiAoc2hvdWxkRHJhd092ZXJsYXkpIHtcbiAgICAgIHIuZHJhd05vZGVVbmRlcmxheShjb250ZXh0LCBub2RlLCBwb3MsIG5vZGVXaWR0aCwgbm9kZUhlaWdodCk7XG4gICAgfVxuICB9O1xuICB2YXIgZHJhd1RleHQgPSBmdW5jdGlvbiBkcmF3VGV4dCgpIHtcbiAgICByLmRyYXdFbGVtZW50VGV4dChjb250ZXh0LCBub2RlLCBudWxsLCBkcmF3TGFiZWwpO1xuICB9O1xuICB2YXIgZ2hvc3QgPSBub2RlLnBzdHlsZSgnZ2hvc3QnKS52YWx1ZSA9PT0gJ3llcyc7XG4gIGlmIChnaG9zdCkge1xuICAgIHZhciBneCA9IG5vZGUucHN0eWxlKCdnaG9zdC1vZmZzZXQteCcpLnBmVmFsdWU7XG4gICAgdmFyIGd5ID0gbm9kZS5wc3R5bGUoJ2dob3N0LW9mZnNldC15JykucGZWYWx1ZTtcbiAgICB2YXIgZ2hvc3RPcGFjaXR5ID0gbm9kZS5wc3R5bGUoJ2dob3N0LW9wYWNpdHknKS52YWx1ZTtcbiAgICB2YXIgZWZmR2hvc3RPcGFjaXR5ID0gZ2hvc3RPcGFjaXR5ICogZWxlT3BhY2l0eTtcbiAgICBjb250ZXh0LnRyYW5zbGF0ZShneCwgZ3kpO1xuICAgIHNldHVwT3V0bGluZUNvbG9yKCk7XG4gICAgZHJhd091dGxpbmUoKTtcbiAgICBzZXR1cFNoYXBlQ29sb3IoZ2hvc3RPcGFjaXR5ICogYmdPcGFjaXR5KTtcbiAgICBkcmF3U2hhcGUoKTtcbiAgICBkcmF3SW1hZ2VzKGVmZkdob3N0T3BhY2l0eSwgdHJ1ZSk7XG4gICAgc2V0dXBCb3JkZXJDb2xvcihnaG9zdE9wYWNpdHkgKiBib3JkZXJPcGFjaXR5KTtcbiAgICBkcmF3Qm9yZGVyKCk7XG4gICAgZHJhd1BpZShkYXJrbmVzcyAhPT0gMCB8fCBib3JkZXJXaWR0aCAhPT0gMCk7XG4gICAgZHJhd0ltYWdlcyhlZmZHaG9zdE9wYWNpdHksIGZhbHNlKTtcbiAgICBkYXJrZW4oZWZmR2hvc3RPcGFjaXR5KTtcbiAgICBjb250ZXh0LnRyYW5zbGF0ZSgtZ3gsIC1neSk7XG4gIH1cbiAgaWYgKHVzZVBhdGhzKSB7XG4gICAgY29udGV4dC50cmFuc2xhdGUoLXBvcy54LCAtcG9zLnkpO1xuICB9XG4gIGRyYXdVbmRlcmxheSgpO1xuICBpZiAodXNlUGF0aHMpIHtcbiAgICBjb250ZXh0LnRyYW5zbGF0ZShwb3MueCwgcG9zLnkpO1xuICB9XG4gIHNldHVwT3V0bGluZUNvbG9yKCk7XG4gIGRyYXdPdXRsaW5lKCk7XG4gIHNldHVwU2hhcGVDb2xvcigpO1xuICBkcmF3U2hhcGUoKTtcbiAgZHJhd0ltYWdlcyhlbGVPcGFjaXR5LCB0cnVlKTtcbiAgc2V0dXBCb3JkZXJDb2xvcigpO1xuICBkcmF3Qm9yZGVyKCk7XG4gIGRyYXdQaWUoZGFya25lc3MgIT09IDAgfHwgYm9yZGVyV2lkdGggIT09IDApO1xuICBkcmF3SW1hZ2VzKGVsZU9wYWNpdHksIGZhbHNlKTtcbiAgZGFya2VuKCk7XG4gIGlmICh1c2VQYXRocykge1xuICAgIGNvbnRleHQudHJhbnNsYXRlKC1wb3MueCwgLXBvcy55KTtcbiAgfVxuICBkcmF3VGV4dCgpO1xuICBkcmF3T3ZlcmxheSgpO1xuXG4gIC8vXG4gIC8vIGNsZWFuIHVwIHNoaWZ0XG5cbiAgaWYgKHNoaWZ0VG9PcmlnaW5XaXRoQmIpIHtcbiAgICBjb250ZXh0LnRyYW5zbGF0ZShiYi54MSwgYmIueTEpO1xuICB9XG59O1xudmFyIGRyYXdOb2RlT3ZlcmxheVVuZGVybGF5ID0gZnVuY3Rpb24gZHJhd05vZGVPdmVybGF5VW5kZXJsYXkob3ZlcmxheU9yVW5kZXJsYXkpIHtcbiAgaWYgKCFbJ292ZXJsYXknLCAndW5kZXJsYXknXS5pbmNsdWRlcyhvdmVybGF5T3JVbmRlcmxheSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RhdGUnKTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24gKGNvbnRleHQsIG5vZGUsIHBvcywgbm9kZVdpZHRoLCBub2RlSGVpZ2h0KSB7XG4gICAgdmFyIHIgPSB0aGlzO1xuICAgIGlmICghbm9kZS52aXNpYmxlKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHBhZGRpbmcgPSBub2RlLnBzdHlsZShcIlwiLmNvbmNhdChvdmVybGF5T3JVbmRlcmxheSwgXCItcGFkZGluZ1wiKSkucGZWYWx1ZTtcbiAgICB2YXIgb3BhY2l0eSA9IG5vZGUucHN0eWxlKFwiXCIuY29uY2F0KG92ZXJsYXlPclVuZGVybGF5LCBcIi1vcGFjaXR5XCIpKS52YWx1ZTtcbiAgICB2YXIgY29sb3IgPSBub2RlLnBzdHlsZShcIlwiLmNvbmNhdChvdmVybGF5T3JVbmRlcmxheSwgXCItY29sb3JcIikpLnZhbHVlO1xuICAgIHZhciBzaGFwZSA9IG5vZGUucHN0eWxlKFwiXCIuY29uY2F0KG92ZXJsYXlPclVuZGVybGF5LCBcIi1zaGFwZVwiKSkudmFsdWU7XG4gICAgdmFyIHJhZGl1cyA9IG5vZGUucHN0eWxlKFwiXCIuY29uY2F0KG92ZXJsYXlPclVuZGVybGF5LCBcIi1jb3JuZXItcmFkaXVzXCIpKS52YWx1ZTtcbiAgICBpZiAob3BhY2l0eSA+IDApIHtcbiAgICAgIHBvcyA9IHBvcyB8fCBub2RlLnBvc2l0aW9uKCk7XG4gICAgICBpZiAobm9kZVdpZHRoID09IG51bGwgfHwgbm9kZUhlaWdodCA9PSBudWxsKSB7XG4gICAgICAgIHZhciBfcGFkZGluZyA9IG5vZGUucGFkZGluZygpO1xuICAgICAgICBub2RlV2lkdGggPSBub2RlLndpZHRoKCkgKyAyICogX3BhZGRpbmc7XG4gICAgICAgIG5vZGVIZWlnaHQgPSBub2RlLmhlaWdodCgpICsgMiAqIF9wYWRkaW5nO1xuICAgICAgfVxuICAgICAgci5jb2xvckZpbGxTdHlsZShjb250ZXh0LCBjb2xvclswXSwgY29sb3JbMV0sIGNvbG9yWzJdLCBvcGFjaXR5KTtcbiAgICAgIHIubm9kZVNoYXBlc1tzaGFwZV0uZHJhdyhjb250ZXh0LCBwb3MueCwgcG9zLnksIG5vZGVXaWR0aCArIHBhZGRpbmcgKiAyLCBub2RlSGVpZ2h0ICsgcGFkZGluZyAqIDIsIHJhZGl1cyk7XG4gICAgICBjb250ZXh0LmZpbGwoKTtcbiAgICB9XG4gIH07XG59O1xuQ1JwJDUuZHJhd05vZGVPdmVybGF5ID0gZHJhd05vZGVPdmVybGF5VW5kZXJsYXkoJ292ZXJsYXknKTtcbkNScCQ1LmRyYXdOb2RlVW5kZXJsYXkgPSBkcmF3Tm9kZU92ZXJsYXlVbmRlcmxheSgndW5kZXJsYXknKTtcblxuLy8gZG9lcyB0aGUgbm9kZSBoYXZlIGF0IGxlYXN0IG9uZSBwaWUgcGllY2U/XG5DUnAkNS5oYXNQaWUgPSBmdW5jdGlvbiAobm9kZSkge1xuICBub2RlID0gbm9kZVswXTsgLy8gZW5zdXJlIGVsZSByZWZcblxuICByZXR1cm4gbm9kZS5fcHJpdmF0ZS5oYXNQaWU7XG59O1xuQ1JwJDUuZHJhd1BpZSA9IGZ1bmN0aW9uIChjb250ZXh0LCBub2RlLCBub2RlT3BhY2l0eSwgcG9zKSB7XG4gIG5vZGUgPSBub2RlWzBdOyAvLyBlbnN1cmUgZWxlIHJlZlxuICBwb3MgPSBwb3MgfHwgbm9kZS5wb3NpdGlvbigpO1xuICB2YXIgY3lTdHlsZSA9IG5vZGUuY3koKS5zdHlsZSgpO1xuICB2YXIgcGllU2l6ZSA9IG5vZGUucHN0eWxlKCdwaWUtc2l6ZScpO1xuICB2YXIgeCA9IHBvcy54O1xuICB2YXIgeSA9IHBvcy55O1xuICB2YXIgbm9kZVcgPSBub2RlLndpZHRoKCk7XG4gIHZhciBub2RlSCA9IG5vZGUuaGVpZ2h0KCk7XG4gIHZhciByYWRpdXMgPSBNYXRoLm1pbihub2RlVywgbm9kZUgpIC8gMjsgLy8gbXVzdCBmaXQgaW4gbm9kZVxuICB2YXIgbGFzdFBlcmNlbnQgPSAwOyAvLyB3aGF0ICUgdG8gY29udGludWUgZHJhd2luZyBwaWUgc2xpY2VzIGZyb20gb24gWzAsIDFdXG4gIHZhciB1c2VQYXRocyA9IHRoaXMudXNlUGF0aHMoKTtcbiAgaWYgKHVzZVBhdGhzKSB7XG4gICAgeCA9IDA7XG4gICAgeSA9IDA7XG4gIH1cbiAgaWYgKHBpZVNpemUudW5pdHMgPT09ICclJykge1xuICAgIHJhZGl1cyA9IHJhZGl1cyAqIHBpZVNpemUucGZWYWx1ZTtcbiAgfSBlbHNlIGlmIChwaWVTaXplLnBmVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgIHJhZGl1cyA9IHBpZVNpemUucGZWYWx1ZSAvIDI7XG4gIH1cbiAgZm9yICh2YXIgaSA9IDE7IGkgPD0gY3lTdHlsZS5waWVCYWNrZ3JvdW5kTjsgaSsrKSB7XG4gICAgLy8gMS4uTlxuICAgIHZhciBzaXplID0gbm9kZS5wc3R5bGUoJ3BpZS0nICsgaSArICctYmFja2dyb3VuZC1zaXplJykudmFsdWU7XG4gICAgdmFyIGNvbG9yID0gbm9kZS5wc3R5bGUoJ3BpZS0nICsgaSArICctYmFja2dyb3VuZC1jb2xvcicpLnZhbHVlO1xuICAgIHZhciBvcGFjaXR5ID0gbm9kZS5wc3R5bGUoJ3BpZS0nICsgaSArICctYmFja2dyb3VuZC1vcGFjaXR5JykudmFsdWUgKiBub2RlT3BhY2l0eTtcbiAgICB2YXIgcGVyY2VudCA9IHNpemUgLyAxMDA7IC8vIG1hcCBpbnRlZ2VyIHJhbmdlIFswLCAxMDBdIHRvIFswLCAxXVxuXG4gICAgLy8gcGVyY2VudCBjYW4ndCBwdXNoIGJleW9uZCAxXG4gICAgaWYgKHBlcmNlbnQgKyBsYXN0UGVyY2VudCA+IDEpIHtcbiAgICAgIHBlcmNlbnQgPSAxIC0gbGFzdFBlcmNlbnQ7XG4gICAgfVxuICAgIHZhciBhbmdsZVN0YXJ0ID0gMS41ICogTWF0aC5QSSArIDIgKiBNYXRoLlBJICogbGFzdFBlcmNlbnQ7IC8vIHN0YXJ0IGF0IDEyIG8nY2xvY2sgYW5kIGdvIGNsb2Nrd2lzZVxuICAgIHZhciBhbmdsZURlbHRhID0gMiAqIE1hdGguUEkgKiBwZXJjZW50O1xuICAgIHZhciBhbmdsZUVuZCA9IGFuZ2xlU3RhcnQgKyBhbmdsZURlbHRhO1xuXG4gICAgLy8gaWdub3JlIGlmXG4gICAgLy8gLSB6ZXJvIHNpemVcbiAgICAvLyAtIHdlJ3JlIGFscmVhZHkgYmV5b25kIHRoZSBmdWxsIGNpcmNsZVxuICAgIC8vIC0gYWRkaW5nIHRoZSBjdXJyZW50IHNsaWNlIHdvdWxkIGdvIGJleW9uZCB0aGUgZnVsbCBjaXJjbGVcbiAgICBpZiAoc2l6ZSA9PT0gMCB8fCBsYXN0UGVyY2VudCA+PSAxIHx8IGxhc3RQZXJjZW50ICsgcGVyY2VudCA+IDEpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgIGNvbnRleHQubW92ZVRvKHgsIHkpO1xuICAgIGNvbnRleHQuYXJjKHgsIHksIHJhZGl1cywgYW5nbGVTdGFydCwgYW5nbGVFbmQpO1xuICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgdGhpcy5jb2xvckZpbGxTdHlsZShjb250ZXh0LCBjb2xvclswXSwgY29sb3JbMV0sIGNvbG9yWzJdLCBvcGFjaXR5KTtcbiAgICBjb250ZXh0LmZpbGwoKTtcbiAgICBsYXN0UGVyY2VudCArPSBwZXJjZW50O1xuICB9XG59O1xuXG52YXIgQ1JwJDQgPSB7fTtcbnZhciBtb3Rpb25CbHVyRGVsYXkgPSAxMDA7XG5cbi8vIHZhciBpc0ZpcmVmb3ggPSB0eXBlb2YgSW5zdGFsbFRyaWdnZXIgIT09ICd1bmRlZmluZWQnO1xuXG5DUnAkNC5nZXRQaXhlbFJhdGlvID0gZnVuY3Rpb24gKCkge1xuICB2YXIgY29udGV4dCA9IHRoaXMuZGF0YS5jb250ZXh0c1swXTtcbiAgaWYgKHRoaXMuZm9yY2VkUGl4ZWxSYXRpbyAhPSBudWxsKSB7XG4gICAgcmV0dXJuIHRoaXMuZm9yY2VkUGl4ZWxSYXRpbztcbiAgfVxuICB2YXIgY29udGFpbmVyV2luZG93ID0gdGhpcy5jeS53aW5kb3coKTtcbiAgdmFyIGJhY2tpbmdTdG9yZSA9IGNvbnRleHQuYmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fCBjb250ZXh0LndlYmtpdEJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgY29udGV4dC5tb3pCYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8IGNvbnRleHQubXNCYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8IGNvbnRleHQub0JhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgY29udGV4dC5iYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8IDE7XG4gIHJldHVybiAoY29udGFpbmVyV2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMSkgLyBiYWNraW5nU3RvcmU7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbn07XG5cbkNScCQ0LnBhaW50Q2FjaGUgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICB2YXIgY2FjaGVzID0gdGhpcy5wYWludENhY2hlcyA9IHRoaXMucGFpbnRDYWNoZXMgfHwgW107XG4gIHZhciBuZWVkVG9DcmVhdGVDYWNoZSA9IHRydWU7XG4gIHZhciBjYWNoZTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYWNoZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjYWNoZSA9IGNhY2hlc1tpXTtcbiAgICBpZiAoY2FjaGUuY29udGV4dCA9PT0gY29udGV4dCkge1xuICAgICAgbmVlZFRvQ3JlYXRlQ2FjaGUgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBpZiAobmVlZFRvQ3JlYXRlQ2FjaGUpIHtcbiAgICBjYWNoZSA9IHtcbiAgICAgIGNvbnRleHQ6IGNvbnRleHRcbiAgICB9O1xuICAgIGNhY2hlcy5wdXNoKGNhY2hlKTtcbiAgfVxuICByZXR1cm4gY2FjaGU7XG59O1xuQ1JwJDQuY3JlYXRlR3JhZGllbnRTdHlsZUZvciA9IGZ1bmN0aW9uIChjb250ZXh0LCBzaGFwZVN0eWxlTmFtZSwgZWxlLCBmaWxsLCBvcGFjaXR5KSB7XG4gIHZhciBncmFkaWVudFN0eWxlO1xuICB2YXIgdXNlUGF0aHMgPSB0aGlzLnVzZVBhdGhzKCk7XG4gIHZhciBjb2xvcnMgPSBlbGUucHN0eWxlKHNoYXBlU3R5bGVOYW1lICsgJy1ncmFkaWVudC1zdG9wLWNvbG9ycycpLnZhbHVlLFxuICAgIHBvc2l0aW9ucyA9IGVsZS5wc3R5bGUoc2hhcGVTdHlsZU5hbWUgKyAnLWdyYWRpZW50LXN0b3AtcG9zaXRpb25zJykucGZWYWx1ZTtcbiAgaWYgKGZpbGwgPT09ICdyYWRpYWwtZ3JhZGllbnQnKSB7XG4gICAgaWYgKGVsZS5pc0VkZ2UoKSkge1xuICAgICAgdmFyIHN0YXJ0ID0gZWxlLnNvdXJjZUVuZHBvaW50KCksXG4gICAgICAgIGVuZCA9IGVsZS50YXJnZXRFbmRwb2ludCgpLFxuICAgICAgICBtaWQgPSBlbGUubWlkcG9pbnQoKTtcbiAgICAgIHZhciBkMSA9IGRpc3Qoc3RhcnQsIG1pZCk7XG4gICAgICB2YXIgZDIgPSBkaXN0KGVuZCwgbWlkKTtcbiAgICAgIGdyYWRpZW50U3R5bGUgPSBjb250ZXh0LmNyZWF0ZVJhZGlhbEdyYWRpZW50KG1pZC54LCBtaWQueSwgMCwgbWlkLngsIG1pZC55LCBNYXRoLm1heChkMSwgZDIpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHBvcyA9IHVzZVBhdGhzID8ge1xuICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgeTogMFxuICAgICAgICB9IDogZWxlLnBvc2l0aW9uKCksXG4gICAgICAgIHdpZHRoID0gZWxlLnBhZGRlZFdpZHRoKCksXG4gICAgICAgIGhlaWdodCA9IGVsZS5wYWRkZWRIZWlnaHQoKTtcbiAgICAgIGdyYWRpZW50U3R5bGUgPSBjb250ZXh0LmNyZWF0ZVJhZGlhbEdyYWRpZW50KHBvcy54LCBwb3MueSwgMCwgcG9zLngsIHBvcy55LCBNYXRoLm1heCh3aWR0aCwgaGVpZ2h0KSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChlbGUuaXNFZGdlKCkpIHtcbiAgICAgIHZhciBfc3RhcnQgPSBlbGUuc291cmNlRW5kcG9pbnQoKSxcbiAgICAgICAgX2VuZCA9IGVsZS50YXJnZXRFbmRwb2ludCgpO1xuICAgICAgZ3JhZGllbnRTdHlsZSA9IGNvbnRleHQuY3JlYXRlTGluZWFyR3JhZGllbnQoX3N0YXJ0LngsIF9zdGFydC55LCBfZW5kLngsIF9lbmQueSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBfcG9zID0gdXNlUGF0aHMgPyB7XG4gICAgICAgICAgeDogMCxcbiAgICAgICAgICB5OiAwXG4gICAgICAgIH0gOiBlbGUucG9zaXRpb24oKSxcbiAgICAgICAgX3dpZHRoID0gZWxlLnBhZGRlZFdpZHRoKCksXG4gICAgICAgIF9oZWlnaHQgPSBlbGUucGFkZGVkSGVpZ2h0KCksXG4gICAgICAgIGhhbGZXaWR0aCA9IF93aWR0aCAvIDIsXG4gICAgICAgIGhhbGZIZWlnaHQgPSBfaGVpZ2h0IC8gMjtcbiAgICAgIHZhciBkaXJlY3Rpb24gPSBlbGUucHN0eWxlKCdiYWNrZ3JvdW5kLWdyYWRpZW50LWRpcmVjdGlvbicpLnZhbHVlO1xuICAgICAgc3dpdGNoIChkaXJlY3Rpb24pIHtcbiAgICAgICAgY2FzZSAndG8tYm90dG9tJzpcbiAgICAgICAgICBncmFkaWVudFN0eWxlID0gY29udGV4dC5jcmVhdGVMaW5lYXJHcmFkaWVudChfcG9zLngsIF9wb3MueSAtIGhhbGZIZWlnaHQsIF9wb3MueCwgX3Bvcy55ICsgaGFsZkhlaWdodCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3RvLXRvcCc6XG4gICAgICAgICAgZ3JhZGllbnRTdHlsZSA9IGNvbnRleHQuY3JlYXRlTGluZWFyR3JhZGllbnQoX3Bvcy54LCBfcG9zLnkgKyBoYWxmSGVpZ2h0LCBfcG9zLngsIF9wb3MueSAtIGhhbGZIZWlnaHQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICd0by1sZWZ0JzpcbiAgICAgICAgICBncmFkaWVudFN0eWxlID0gY29udGV4dC5jcmVhdGVMaW5lYXJHcmFkaWVudChfcG9zLnggKyBoYWxmV2lkdGgsIF9wb3MueSwgX3Bvcy54IC0gaGFsZldpZHRoLCBfcG9zLnkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICd0by1yaWdodCc6XG4gICAgICAgICAgZ3JhZGllbnRTdHlsZSA9IGNvbnRleHQuY3JlYXRlTGluZWFyR3JhZGllbnQoX3Bvcy54IC0gaGFsZldpZHRoLCBfcG9zLnksIF9wb3MueCArIGhhbGZXaWR0aCwgX3Bvcy55KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAndG8tYm90dG9tLXJpZ2h0JzpcbiAgICAgICAgY2FzZSAndG8tcmlnaHQtYm90dG9tJzpcbiAgICAgICAgICBncmFkaWVudFN0eWxlID0gY29udGV4dC5jcmVhdGVMaW5lYXJHcmFkaWVudChfcG9zLnggLSBoYWxmV2lkdGgsIF9wb3MueSAtIGhhbGZIZWlnaHQsIF9wb3MueCArIGhhbGZXaWR0aCwgX3Bvcy55ICsgaGFsZkhlaWdodCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3RvLXRvcC1yaWdodCc6XG4gICAgICAgIGNhc2UgJ3RvLXJpZ2h0LXRvcCc6XG4gICAgICAgICAgZ3JhZGllbnRTdHlsZSA9IGNvbnRleHQuY3JlYXRlTGluZWFyR3JhZGllbnQoX3Bvcy54IC0gaGFsZldpZHRoLCBfcG9zLnkgKyBoYWxmSGVpZ2h0LCBfcG9zLnggKyBoYWxmV2lkdGgsIF9wb3MueSAtIGhhbGZIZWlnaHQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICd0by1ib3R0b20tbGVmdCc6XG4gICAgICAgIGNhc2UgJ3RvLWxlZnQtYm90dG9tJzpcbiAgICAgICAgICBncmFkaWVudFN0eWxlID0gY29udGV4dC5jcmVhdGVMaW5lYXJHcmFkaWVudChfcG9zLnggKyBoYWxmV2lkdGgsIF9wb3MueSAtIGhhbGZIZWlnaHQsIF9wb3MueCAtIGhhbGZXaWR0aCwgX3Bvcy55ICsgaGFsZkhlaWdodCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3RvLXRvcC1sZWZ0JzpcbiAgICAgICAgY2FzZSAndG8tbGVmdC10b3AnOlxuICAgICAgICAgIGdyYWRpZW50U3R5bGUgPSBjb250ZXh0LmNyZWF0ZUxpbmVhckdyYWRpZW50KF9wb3MueCArIGhhbGZXaWR0aCwgX3Bvcy55ICsgaGFsZkhlaWdodCwgX3Bvcy54IC0gaGFsZldpZHRoLCBfcG9zLnkgLSBoYWxmSGVpZ2h0KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKCFncmFkaWVudFN0eWxlKSByZXR1cm4gbnVsbDsgLy8gaW52YWxpZCBncmFkaWVudCBzdHlsZVxuXG4gIHZhciBoYXNQb3NpdGlvbnMgPSBwb3NpdGlvbnMubGVuZ3RoID09PSBjb2xvcnMubGVuZ3RoO1xuICB2YXIgbGVuZ3RoID0gY29sb3JzLmxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGdyYWRpZW50U3R5bGUuYWRkQ29sb3JTdG9wKGhhc1Bvc2l0aW9ucyA/IHBvc2l0aW9uc1tpXSA6IGkgLyAobGVuZ3RoIC0gMSksICdyZ2JhKCcgKyBjb2xvcnNbaV1bMF0gKyAnLCcgKyBjb2xvcnNbaV1bMV0gKyAnLCcgKyBjb2xvcnNbaV1bMl0gKyAnLCcgKyBvcGFjaXR5ICsgJyknKTtcbiAgfVxuICByZXR1cm4gZ3JhZGllbnRTdHlsZTtcbn07XG5DUnAkNC5ncmFkaWVudEZpbGxTdHlsZSA9IGZ1bmN0aW9uIChjb250ZXh0LCBlbGUsIGZpbGwsIG9wYWNpdHkpIHtcbiAgdmFyIGdyYWRpZW50U3R5bGUgPSB0aGlzLmNyZWF0ZUdyYWRpZW50U3R5bGVGb3IoY29udGV4dCwgJ2JhY2tncm91bmQnLCBlbGUsIGZpbGwsIG9wYWNpdHkpO1xuICBpZiAoIWdyYWRpZW50U3R5bGUpIHJldHVybiBudWxsOyAvLyBlcnJvclxuICBjb250ZXh0LmZpbGxTdHlsZSA9IGdyYWRpZW50U3R5bGU7XG59O1xuQ1JwJDQuY29sb3JGaWxsU3R5bGUgPSBmdW5jdGlvbiAoY29udGV4dCwgciwgZywgYiwgYSkge1xuICBjb250ZXh0LmZpbGxTdHlsZSA9ICdyZ2JhKCcgKyByICsgJywnICsgZyArICcsJyArIGIgKyAnLCcgKyBhICsgJyknO1xuICAvLyB0dXJuIG9mZiBmb3Igbm93LCBzZWVtcyBjb250ZXh0IGRvZXMgaXRzIG93biBjYWNoaW5nXG5cbiAgLy8gdmFyIGNhY2hlID0gdGhpcy5wYWludENhY2hlKGNvbnRleHQpO1xuXG4gIC8vIHZhciBmaWxsU3R5bGUgPSAncmdiYSgnICsgciArICcsJyArIGcgKyAnLCcgKyBiICsgJywnICsgYSArICcpJztcblxuICAvLyBpZiggY2FjaGUuZmlsbFN0eWxlICE9PSBmaWxsU3R5bGUgKXtcbiAgLy8gICBjb250ZXh0LmZpbGxTdHlsZSA9IGNhY2hlLmZpbGxTdHlsZSA9IGZpbGxTdHlsZTtcbiAgLy8gfVxufTtcblxuQ1JwJDQuZWxlRmlsbFN0eWxlID0gZnVuY3Rpb24gKGNvbnRleHQsIGVsZSwgb3BhY2l0eSkge1xuICB2YXIgYmFja2dyb3VuZEZpbGwgPSBlbGUucHN0eWxlKCdiYWNrZ3JvdW5kLWZpbGwnKS52YWx1ZTtcbiAgaWYgKGJhY2tncm91bmRGaWxsID09PSAnbGluZWFyLWdyYWRpZW50JyB8fCBiYWNrZ3JvdW5kRmlsbCA9PT0gJ3JhZGlhbC1ncmFkaWVudCcpIHtcbiAgICB0aGlzLmdyYWRpZW50RmlsbFN0eWxlKGNvbnRleHQsIGVsZSwgYmFja2dyb3VuZEZpbGwsIG9wYWNpdHkpO1xuICB9IGVsc2Uge1xuICAgIHZhciBiYWNrZ3JvdW5kQ29sb3IgPSBlbGUucHN0eWxlKCdiYWNrZ3JvdW5kLWNvbG9yJykudmFsdWU7XG4gICAgdGhpcy5jb2xvckZpbGxTdHlsZShjb250ZXh0LCBiYWNrZ3JvdW5kQ29sb3JbMF0sIGJhY2tncm91bmRDb2xvclsxXSwgYmFja2dyb3VuZENvbG9yWzJdLCBvcGFjaXR5KTtcbiAgfVxufTtcbkNScCQ0LmdyYWRpZW50U3Ryb2tlU3R5bGUgPSBmdW5jdGlvbiAoY29udGV4dCwgZWxlLCBmaWxsLCBvcGFjaXR5KSB7XG4gIHZhciBncmFkaWVudFN0eWxlID0gdGhpcy5jcmVhdGVHcmFkaWVudFN0eWxlRm9yKGNvbnRleHQsICdsaW5lJywgZWxlLCBmaWxsLCBvcGFjaXR5KTtcbiAgaWYgKCFncmFkaWVudFN0eWxlKSByZXR1cm4gbnVsbDsgLy8gZXJyb3JcbiAgY29udGV4dC5zdHJva2VTdHlsZSA9IGdyYWRpZW50U3R5bGU7XG59O1xuQ1JwJDQuY29sb3JTdHJva2VTdHlsZSA9IGZ1bmN0aW9uIChjb250ZXh0LCByLCBnLCBiLCBhKSB7XG4gIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSAncmdiYSgnICsgciArICcsJyArIGcgKyAnLCcgKyBiICsgJywnICsgYSArICcpJztcbiAgLy8gdHVybiBvZmYgZm9yIG5vdywgc2VlbXMgY29udGV4dCBkb2VzIGl0cyBvd24gY2FjaGluZ1xuXG4gIC8vIHZhciBjYWNoZSA9IHRoaXMucGFpbnRDYWNoZShjb250ZXh0KTtcblxuICAvLyB2YXIgc3Ryb2tlU3R5bGUgPSAncmdiYSgnICsgciArICcsJyArIGcgKyAnLCcgKyBiICsgJywnICsgYSArICcpJztcblxuICAvLyBpZiggY2FjaGUuc3Ryb2tlU3R5bGUgIT09IHN0cm9rZVN0eWxlICl7XG4gIC8vICAgY29udGV4dC5zdHJva2VTdHlsZSA9IGNhY2hlLnN0cm9rZVN0eWxlID0gc3Ryb2tlU3R5bGU7XG4gIC8vIH1cbn07XG5cbkNScCQ0LmVsZVN0cm9rZVN0eWxlID0gZnVuY3Rpb24gKGNvbnRleHQsIGVsZSwgb3BhY2l0eSkge1xuICB2YXIgbGluZUZpbGwgPSBlbGUucHN0eWxlKCdsaW5lLWZpbGwnKS52YWx1ZTtcbiAgaWYgKGxpbmVGaWxsID09PSAnbGluZWFyLWdyYWRpZW50JyB8fCBsaW5lRmlsbCA9PT0gJ3JhZGlhbC1ncmFkaWVudCcpIHtcbiAgICB0aGlzLmdyYWRpZW50U3Ryb2tlU3R5bGUoY29udGV4dCwgZWxlLCBsaW5lRmlsbCwgb3BhY2l0eSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGxpbmVDb2xvciA9IGVsZS5wc3R5bGUoJ2xpbmUtY29sb3InKS52YWx1ZTtcbiAgICB0aGlzLmNvbG9yU3Ryb2tlU3R5bGUoY29udGV4dCwgbGluZUNvbG9yWzBdLCBsaW5lQ29sb3JbMV0sIGxpbmVDb2xvclsyXSwgb3BhY2l0eSk7XG4gIH1cbn07XG5cbi8vIFJlc2l6ZSBjYW52YXNcbkNScCQ0Lm1hdGNoQ2FudmFzU2l6ZSA9IGZ1bmN0aW9uIChjb250YWluZXIpIHtcbiAgdmFyIHIgPSB0aGlzO1xuICB2YXIgZGF0YSA9IHIuZGF0YTtcbiAgdmFyIGJiID0gci5maW5kQ29udGFpbmVyQ2xpZW50Q29vcmRzKCk7XG4gIHZhciB3aWR0aCA9IGJiWzJdO1xuICB2YXIgaGVpZ2h0ID0gYmJbM107XG4gIHZhciBwaXhlbFJhdGlvID0gci5nZXRQaXhlbFJhdGlvKCk7XG4gIHZhciBtYlB4UmF0aW8gPSByLm1vdGlvbkJsdXJQeFJhdGlvO1xuICBpZiAoY29udGFpbmVyID09PSByLmRhdGEuYnVmZmVyQ2FudmFzZXNbci5NT1RJT05CTFVSX0JVRkZFUl9OT0RFXSB8fCBjb250YWluZXIgPT09IHIuZGF0YS5idWZmZXJDYW52YXNlc1tyLk1PVElPTkJMVVJfQlVGRkVSX0RSQUddKSB7XG4gICAgcGl4ZWxSYXRpbyA9IG1iUHhSYXRpbztcbiAgfVxuICB2YXIgY2FudmFzV2lkdGggPSB3aWR0aCAqIHBpeGVsUmF0aW87XG4gIHZhciBjYW52YXNIZWlnaHQgPSBoZWlnaHQgKiBwaXhlbFJhdGlvO1xuICB2YXIgY2FudmFzO1xuICBpZiAoY2FudmFzV2lkdGggPT09IHIuY2FudmFzV2lkdGggJiYgY2FudmFzSGVpZ2h0ID09PSByLmNhbnZhc0hlaWdodCkge1xuICAgIHJldHVybjsgLy8gc2F2ZSBjeWNsZXMgaWYgc2FtZVxuICB9XG5cbiAgci5mb250Q2FjaGVzID0gbnVsbDsgLy8gcmVzaXppbmcgcmVzZXRzIHRoZSBzdHlsZVxuXG4gIHZhciBjYW52YXNDb250YWluZXIgPSBkYXRhLmNhbnZhc0NvbnRhaW5lcjtcbiAgY2FudmFzQ29udGFpbmVyLnN0eWxlLndpZHRoID0gd2lkdGggKyAncHgnO1xuICBjYW52YXNDb250YWluZXIuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgJ3B4JztcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCByLkNBTlZBU19MQVlFUlM7IGkrKykge1xuICAgIGNhbnZhcyA9IGRhdGEuY2FudmFzZXNbaV07XG4gICAgY2FudmFzLndpZHRoID0gY2FudmFzV2lkdGg7XG4gICAgY2FudmFzLmhlaWdodCA9IGNhbnZhc0hlaWdodDtcbiAgICBjYW52YXMuc3R5bGUud2lkdGggPSB3aWR0aCArICdweCc7XG4gICAgY2FudmFzLnN0eWxlLmhlaWdodCA9IGhlaWdodCArICdweCc7XG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCByLkJVRkZFUl9DT1VOVDsgaSsrKSB7XG4gICAgY2FudmFzID0gZGF0YS5idWZmZXJDYW52YXNlc1tpXTtcbiAgICBjYW52YXMud2lkdGggPSBjYW52YXNXaWR0aDtcbiAgICBjYW52YXMuaGVpZ2h0ID0gY2FudmFzSGVpZ2h0O1xuICAgIGNhbnZhcy5zdHlsZS53aWR0aCA9IHdpZHRoICsgJ3B4JztcbiAgICBjYW52YXMuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgJ3B4JztcbiAgfVxuICByLnRleHR1cmVNdWx0ID0gMTtcbiAgaWYgKHBpeGVsUmF0aW8gPD0gMSkge1xuICAgIGNhbnZhcyA9IGRhdGEuYnVmZmVyQ2FudmFzZXNbci5URVhUVVJFX0JVRkZFUl07XG4gICAgci50ZXh0dXJlTXVsdCA9IDI7XG4gICAgY2FudmFzLndpZHRoID0gY2FudmFzV2lkdGggKiByLnRleHR1cmVNdWx0O1xuICAgIGNhbnZhcy5oZWlnaHQgPSBjYW52YXNIZWlnaHQgKiByLnRleHR1cmVNdWx0O1xuICB9XG4gIHIuY2FudmFzV2lkdGggPSBjYW52YXNXaWR0aDtcbiAgci5jYW52YXNIZWlnaHQgPSBjYW52YXNIZWlnaHQ7XG59O1xuQ1JwJDQucmVuZGVyVG8gPSBmdW5jdGlvbiAoY3h0LCB6b29tLCBwYW4sIHB4UmF0aW8pIHtcbiAgdGhpcy5yZW5kZXIoe1xuICAgIGZvcmNlZENvbnRleHQ6IGN4dCxcbiAgICBmb3JjZWRab29tOiB6b29tLFxuICAgIGZvcmNlZFBhbjogcGFuLFxuICAgIGRyYXdBbGxMYXllcnM6IHRydWUsXG4gICAgZm9yY2VkUHhSYXRpbzogcHhSYXRpb1xuICB9KTtcbn07XG5DUnAkNC5yZW5kZXIgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCBzdGF0aWNFbXB0eU9iamVjdCgpO1xuICB2YXIgZm9yY2VkQ29udGV4dCA9IG9wdGlvbnMuZm9yY2VkQ29udGV4dDtcbiAgdmFyIGRyYXdBbGxMYXllcnMgPSBvcHRpb25zLmRyYXdBbGxMYXllcnM7XG4gIHZhciBkcmF3T25seU5vZGVMYXllciA9IG9wdGlvbnMuZHJhd09ubHlOb2RlTGF5ZXI7XG4gIHZhciBmb3JjZWRab29tID0gb3B0aW9ucy5mb3JjZWRab29tO1xuICB2YXIgZm9yY2VkUGFuID0gb3B0aW9ucy5mb3JjZWRQYW47XG4gIHZhciByID0gdGhpcztcbiAgdmFyIHBpeGVsUmF0aW8gPSBvcHRpb25zLmZvcmNlZFB4UmF0aW8gPT09IHVuZGVmaW5lZCA/IHRoaXMuZ2V0UGl4ZWxSYXRpbygpIDogb3B0aW9ucy5mb3JjZWRQeFJhdGlvO1xuICB2YXIgY3kgPSByLmN5O1xuICB2YXIgZGF0YSA9IHIuZGF0YTtcbiAgdmFyIG5lZWREcmF3ID0gZGF0YS5jYW52YXNOZWVkc1JlZHJhdztcbiAgdmFyIHRleHR1cmVEcmF3ID0gci50ZXh0dXJlT25WaWV3cG9ydCAmJiAhZm9yY2VkQ29udGV4dCAmJiAoci5waW5jaGluZyB8fCByLmhvdmVyRGF0YS5kcmFnZ2luZyB8fCByLnN3aXBlUGFubmluZyB8fCByLmRhdGEud2hlZWxab29taW5nKTtcbiAgdmFyIG1vdGlvbkJsdXIgPSBvcHRpb25zLm1vdGlvbkJsdXIgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMubW90aW9uQmx1ciA6IHIubW90aW9uQmx1cjtcbiAgdmFyIG1iUHhSYXRpbyA9IHIubW90aW9uQmx1clB4UmF0aW87XG4gIHZhciBoYXNDb21wb3VuZE5vZGVzID0gY3kuaGFzQ29tcG91bmROb2RlcygpO1xuICB2YXIgaW5Ob2RlRHJhZ0dlc3R1cmUgPSByLmhvdmVyRGF0YS5kcmFnZ2luZ0VsZXM7XG4gIHZhciBpbkJveFNlbGVjdGlvbiA9IHIuaG92ZXJEYXRhLnNlbGVjdGluZyB8fCByLnRvdWNoRGF0YS5zZWxlY3RpbmcgPyB0cnVlIDogZmFsc2U7XG4gIG1vdGlvbkJsdXIgPSBtb3Rpb25CbHVyICYmICFmb3JjZWRDb250ZXh0ICYmIHIubW90aW9uQmx1ckVuYWJsZWQgJiYgIWluQm94U2VsZWN0aW9uO1xuICB2YXIgbW90aW9uQmx1ckZhZGVFZmZlY3QgPSBtb3Rpb25CbHVyO1xuICBpZiAoIWZvcmNlZENvbnRleHQpIHtcbiAgICBpZiAoci5wcmV2UHhSYXRpbyAhPT0gcGl4ZWxSYXRpbykge1xuICAgICAgci5pbnZhbGlkYXRlQ29udGFpbmVyQ2xpZW50Q29vcmRzQ2FjaGUoKTtcbiAgICAgIHIubWF0Y2hDYW52YXNTaXplKHIuY29udGFpbmVyKTtcbiAgICAgIHIucmVkcmF3SGludCgnZWxlcycsIHRydWUpO1xuICAgICAgci5yZWRyYXdIaW50KCdkcmFnJywgdHJ1ZSk7XG4gICAgfVxuICAgIHIucHJldlB4UmF0aW8gPSBwaXhlbFJhdGlvO1xuICB9XG4gIGlmICghZm9yY2VkQ29udGV4dCAmJiByLm1vdGlvbkJsdXJUaW1lb3V0KSB7XG4gICAgY2xlYXJUaW1lb3V0KHIubW90aW9uQmx1clRpbWVvdXQpO1xuICB9XG4gIGlmIChtb3Rpb25CbHVyKSB7XG4gICAgaWYgKHIubWJGcmFtZXMgPT0gbnVsbCkge1xuICAgICAgci5tYkZyYW1lcyA9IDA7XG4gICAgfVxuICAgIHIubWJGcmFtZXMrKztcbiAgICBpZiAoci5tYkZyYW1lcyA8IDMpIHtcbiAgICAgIC8vIG5lZWQgc2V2ZXJhbCBmcmFtZXMgYmVmb3JlIGV2ZW4gaGlnaCBxdWFsaXR5IG1vdGlvbmJsdXJcbiAgICAgIG1vdGlvbkJsdXJGYWRlRWZmZWN0ID0gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gZ28gdG8gbG93ZXIgcXVhbGl0eSBibHVycnkgZnJhbWVzIHdoZW4gc2V2ZXJhbCBtL2IgZnJhbWVzIGhhdmUgYmVlbiByZW5kZXJlZCAoYXZvaWRzIGZsYXNoaW5nKVxuICAgIGlmIChyLm1iRnJhbWVzID4gci5taW5NYkxvd1F1YWxGcmFtZXMpIHtcbiAgICAgIC8vci5mdWxsUXVhbGl0eU1iID0gZmFsc2U7XG4gICAgICByLm1vdGlvbkJsdXJQeFJhdGlvID0gci5tYlB4UkJsdXJyeTtcbiAgICB9XG4gIH1cbiAgaWYgKHIuY2xlYXJpbmdNb3Rpb25CbHVyKSB7XG4gICAgci5tb3Rpb25CbHVyUHhSYXRpbyA9IDE7XG4gIH1cblxuICAvLyBiL2MgZHJhd1RvQ29udGV4dCgpIG1heSBiZSBhc3luYyB3LnIudC4gcmVkcmF3KCksIGtlZXAgdHJhY2sgb2YgbGFzdCB0ZXh0dXJlIGZyYW1lXG4gIC8vIGJlY2F1c2UgYSByb2d1ZSBhc3luYyB0ZXh0dXJlIGZyYW1lIHdvdWxkIGNsZWFyIG5lZWREcmF3XG4gIGlmIChyLnRleHR1cmVEcmF3TGFzdEZyYW1lICYmICF0ZXh0dXJlRHJhdykge1xuICAgIG5lZWREcmF3W3IuTk9ERV0gPSB0cnVlO1xuICAgIG5lZWREcmF3W3IuU0VMRUNUX0JPWF0gPSB0cnVlO1xuICB9XG4gIHZhciBzdHlsZSA9IGN5LnN0eWxlKCk7XG4gIHZhciB6b29tID0gY3kuem9vbSgpO1xuICB2YXIgZWZmZWN0aXZlWm9vbSA9IGZvcmNlZFpvb20gIT09IHVuZGVmaW5lZCA/IGZvcmNlZFpvb20gOiB6b29tO1xuICB2YXIgcGFuID0gY3kucGFuKCk7XG4gIHZhciBlZmZlY3RpdmVQYW4gPSB7XG4gICAgeDogcGFuLngsXG4gICAgeTogcGFuLnlcbiAgfTtcbiAgdmFyIHZwID0ge1xuICAgIHpvb206IHpvb20sXG4gICAgcGFuOiB7XG4gICAgICB4OiBwYW4ueCxcbiAgICAgIHk6IHBhbi55XG4gICAgfVxuICB9O1xuICB2YXIgcHJldlZwID0gci5wcmV2Vmlld3BvcnQ7XG4gIHZhciB2aWV3cG9ydElzRGlmZiA9IHByZXZWcCA9PT0gdW5kZWZpbmVkIHx8IHZwLnpvb20gIT09IHByZXZWcC56b29tIHx8IHZwLnBhbi54ICE9PSBwcmV2VnAucGFuLnggfHwgdnAucGFuLnkgIT09IHByZXZWcC5wYW4ueTtcblxuICAvLyB3ZSB3YW50IHRoZSBsb3cgcXVhbGl0eSBtb3Rpb25ibHVyIG9ubHkgd2hlbiB0aGUgdmlld3BvcnQgaXMgYmVpbmcgbWFuaXB1bGF0ZWQgZXRjICh3aGVyZSBpdCdzIG5vdCBub3RpY2VkKVxuICBpZiAoIXZpZXdwb3J0SXNEaWZmICYmICEoaW5Ob2RlRHJhZ0dlc3R1cmUgJiYgIWhhc0NvbXBvdW5kTm9kZXMpKSB7XG4gICAgci5tb3Rpb25CbHVyUHhSYXRpbyA9IDE7XG4gIH1cbiAgaWYgKGZvcmNlZFBhbikge1xuICAgIGVmZmVjdGl2ZVBhbiA9IGZvcmNlZFBhbjtcbiAgfVxuXG4gIC8vIGFwcGx5IHBpeGVsIHJhdGlvXG5cbiAgZWZmZWN0aXZlWm9vbSAqPSBwaXhlbFJhdGlvO1xuICBlZmZlY3RpdmVQYW4ueCAqPSBwaXhlbFJhdGlvO1xuICBlZmZlY3RpdmVQYW4ueSAqPSBwaXhlbFJhdGlvO1xuICB2YXIgZWxlcyA9IHIuZ2V0Q2FjaGVkWlNvcnRlZEVsZXMoKTtcbiAgZnVuY3Rpb24gbWJjbGVhcihjb250ZXh0LCB4LCB5LCB3LCBoKSB7XG4gICAgdmFyIGdjbyA9IGNvbnRleHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uO1xuICAgIGNvbnRleHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gJ2Rlc3RpbmF0aW9uLW91dCc7XG4gICAgci5jb2xvckZpbGxTdHlsZShjb250ZXh0LCAyNTUsIDI1NSwgMjU1LCByLm1vdGlvbkJsdXJUcmFuc3BhcmVuY3kpO1xuICAgIGNvbnRleHQuZmlsbFJlY3QoeCwgeSwgdywgaCk7XG4gICAgY29udGV4dC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBnY287XG4gIH1cbiAgZnVuY3Rpb24gc2V0Q29udGV4dFRyYW5zZm9ybShjb250ZXh0LCBjbGVhcikge1xuICAgIHZhciBlUGFuLCBlWm9vbSwgdywgaDtcbiAgICBpZiAoIXIuY2xlYXJpbmdNb3Rpb25CbHVyICYmIChjb250ZXh0ID09PSBkYXRhLmJ1ZmZlckNvbnRleHRzW3IuTU9USU9OQkxVUl9CVUZGRVJfTk9ERV0gfHwgY29udGV4dCA9PT0gZGF0YS5idWZmZXJDb250ZXh0c1tyLk1PVElPTkJMVVJfQlVGRkVSX0RSQUddKSkge1xuICAgICAgZVBhbiA9IHtcbiAgICAgICAgeDogcGFuLnggKiBtYlB4UmF0aW8sXG4gICAgICAgIHk6IHBhbi55ICogbWJQeFJhdGlvXG4gICAgICB9O1xuICAgICAgZVpvb20gPSB6b29tICogbWJQeFJhdGlvO1xuICAgICAgdyA9IHIuY2FudmFzV2lkdGggKiBtYlB4UmF0aW87XG4gICAgICBoID0gci5jYW52YXNIZWlnaHQgKiBtYlB4UmF0aW87XG4gICAgfSBlbHNlIHtcbiAgICAgIGVQYW4gPSBlZmZlY3RpdmVQYW47XG4gICAgICBlWm9vbSA9IGVmZmVjdGl2ZVpvb207XG4gICAgICB3ID0gci5jYW52YXNXaWR0aDtcbiAgICAgIGggPSByLmNhbnZhc0hlaWdodDtcbiAgICB9XG4gICAgY29udGV4dC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG4gICAgaWYgKGNsZWFyID09PSAnbW90aW9uQmx1cicpIHtcbiAgICAgIG1iY2xlYXIoY29udGV4dCwgMCwgMCwgdywgaCk7XG4gICAgfSBlbHNlIGlmICghZm9yY2VkQ29udGV4dCAmJiAoY2xlYXIgPT09IHVuZGVmaW5lZCB8fCBjbGVhcikpIHtcbiAgICAgIGNvbnRleHQuY2xlYXJSZWN0KDAsIDAsIHcsIGgpO1xuICAgIH1cbiAgICBpZiAoIWRyYXdBbGxMYXllcnMpIHtcbiAgICAgIGNvbnRleHQudHJhbnNsYXRlKGVQYW4ueCwgZVBhbi55KTtcbiAgICAgIGNvbnRleHQuc2NhbGUoZVpvb20sIGVab29tKTtcbiAgICB9XG4gICAgaWYgKGZvcmNlZFBhbikge1xuICAgICAgY29udGV4dC50cmFuc2xhdGUoZm9yY2VkUGFuLngsIGZvcmNlZFBhbi55KTtcbiAgICB9XG4gICAgaWYgKGZvcmNlZFpvb20pIHtcbiAgICAgIGNvbnRleHQuc2NhbGUoZm9yY2VkWm9vbSwgZm9yY2VkWm9vbSk7XG4gICAgfVxuICB9XG4gIGlmICghdGV4dHVyZURyYXcpIHtcbiAgICByLnRleHR1cmVEcmF3TGFzdEZyYW1lID0gZmFsc2U7XG4gIH1cbiAgaWYgKHRleHR1cmVEcmF3KSB7XG4gICAgci50ZXh0dXJlRHJhd0xhc3RGcmFtZSA9IHRydWU7XG4gICAgaWYgKCFyLnRleHR1cmVDYWNoZSkge1xuICAgICAgci50ZXh0dXJlQ2FjaGUgPSB7fTtcbiAgICAgIHIudGV4dHVyZUNhY2hlLmJiID0gY3kubXV0YWJsZUVsZW1lbnRzKCkuYm91bmRpbmdCb3goKTtcbiAgICAgIHIudGV4dHVyZUNhY2hlLnRleHR1cmUgPSByLmRhdGEuYnVmZmVyQ2FudmFzZXNbci5URVhUVVJFX0JVRkZFUl07XG4gICAgICB2YXIgY3h0ID0gci5kYXRhLmJ1ZmZlckNvbnRleHRzW3IuVEVYVFVSRV9CVUZGRVJdO1xuICAgICAgY3h0LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcbiAgICAgIGN4dC5jbGVhclJlY3QoMCwgMCwgci5jYW52YXNXaWR0aCAqIHIudGV4dHVyZU11bHQsIHIuY2FudmFzSGVpZ2h0ICogci50ZXh0dXJlTXVsdCk7XG4gICAgICByLnJlbmRlcih7XG4gICAgICAgIGZvcmNlZENvbnRleHQ6IGN4dCxcbiAgICAgICAgZHJhd09ubHlOb2RlTGF5ZXI6IHRydWUsXG4gICAgICAgIGZvcmNlZFB4UmF0aW86IHBpeGVsUmF0aW8gKiByLnRleHR1cmVNdWx0XG4gICAgICB9KTtcbiAgICAgIHZhciB2cCA9IHIudGV4dHVyZUNhY2hlLnZpZXdwb3J0ID0ge1xuICAgICAgICB6b29tOiBjeS56b29tKCksXG4gICAgICAgIHBhbjogY3kucGFuKCksXG4gICAgICAgIHdpZHRoOiByLmNhbnZhc1dpZHRoLFxuICAgICAgICBoZWlnaHQ6IHIuY2FudmFzSGVpZ2h0XG4gICAgICB9O1xuICAgICAgdnAubXBhbiA9IHtcbiAgICAgICAgeDogKDAgLSB2cC5wYW4ueCkgLyB2cC56b29tLFxuICAgICAgICB5OiAoMCAtIHZwLnBhbi55KSAvIHZwLnpvb21cbiAgICAgIH07XG4gICAgfVxuICAgIG5lZWREcmF3W3IuRFJBR10gPSBmYWxzZTtcbiAgICBuZWVkRHJhd1tyLk5PREVdID0gZmFsc2U7XG4gICAgdmFyIGNvbnRleHQgPSBkYXRhLmNvbnRleHRzW3IuTk9ERV07XG4gICAgdmFyIHRleHR1cmUgPSByLnRleHR1cmVDYWNoZS50ZXh0dXJlO1xuICAgIHZhciB2cCA9IHIudGV4dHVyZUNhY2hlLnZpZXdwb3J0O1xuICAgIGNvbnRleHQuc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuICAgIGlmIChtb3Rpb25CbHVyKSB7XG4gICAgICBtYmNsZWFyKGNvbnRleHQsIDAsIDAsIHZwLndpZHRoLCB2cC5oZWlnaHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb250ZXh0LmNsZWFyUmVjdCgwLCAwLCB2cC53aWR0aCwgdnAuaGVpZ2h0KTtcbiAgICB9XG4gICAgdmFyIG91dHNpZGVCZ0NvbG9yID0gc3R5bGUuY29yZSgnb3V0c2lkZS10ZXh0dXJlLWJnLWNvbG9yJykudmFsdWU7XG4gICAgdmFyIG91dHNpZGVCZ09wYWNpdHkgPSBzdHlsZS5jb3JlKCdvdXRzaWRlLXRleHR1cmUtYmctb3BhY2l0eScpLnZhbHVlO1xuICAgIHIuY29sb3JGaWxsU3R5bGUoY29udGV4dCwgb3V0c2lkZUJnQ29sb3JbMF0sIG91dHNpZGVCZ0NvbG9yWzFdLCBvdXRzaWRlQmdDb2xvclsyXSwgb3V0c2lkZUJnT3BhY2l0eSk7XG4gICAgY29udGV4dC5maWxsUmVjdCgwLCAwLCB2cC53aWR0aCwgdnAuaGVpZ2h0KTtcbiAgICB2YXIgem9vbSA9IGN5Lnpvb20oKTtcbiAgICBzZXRDb250ZXh0VHJhbnNmb3JtKGNvbnRleHQsIGZhbHNlKTtcbiAgICBjb250ZXh0LmNsZWFyUmVjdCh2cC5tcGFuLngsIHZwLm1wYW4ueSwgdnAud2lkdGggLyB2cC56b29tIC8gcGl4ZWxSYXRpbywgdnAuaGVpZ2h0IC8gdnAuem9vbSAvIHBpeGVsUmF0aW8pO1xuICAgIGNvbnRleHQuZHJhd0ltYWdlKHRleHR1cmUsIHZwLm1wYW4ueCwgdnAubXBhbi55LCB2cC53aWR0aCAvIHZwLnpvb20gLyBwaXhlbFJhdGlvLCB2cC5oZWlnaHQgLyB2cC56b29tIC8gcGl4ZWxSYXRpbyk7XG4gIH0gZWxzZSBpZiAoci50ZXh0dXJlT25WaWV3cG9ydCAmJiAhZm9yY2VkQ29udGV4dCkge1xuICAgIC8vIGNsZWFyIHRoZSBjYWNoZSBzaW5jZSB3ZSBkb24ndCBuZWVkIGl0XG4gICAgci50ZXh0dXJlQ2FjaGUgPSBudWxsO1xuICB9XG4gIHZhciBleHRlbnQgPSBjeS5leHRlbnQoKTtcbiAgdmFyIHZwTWFuaXAgPSByLnBpbmNoaW5nIHx8IHIuaG92ZXJEYXRhLmRyYWdnaW5nIHx8IHIuc3dpcGVQYW5uaW5nIHx8IHIuZGF0YS53aGVlbFpvb21pbmcgfHwgci5ob3ZlckRhdGEuZHJhZ2dpbmdFbGVzIHx8IHIuY3kuYW5pbWF0ZWQoKTtcbiAgdmFyIGhpZGVFZGdlcyA9IHIuaGlkZUVkZ2VzT25WaWV3cG9ydCAmJiB2cE1hbmlwO1xuICB2YXIgbmVlZE1iQ2xlYXIgPSBbXTtcbiAgbmVlZE1iQ2xlYXJbci5OT0RFXSA9ICFuZWVkRHJhd1tyLk5PREVdICYmIG1vdGlvbkJsdXIgJiYgIXIuY2xlYXJlZEZvck1vdGlvbkJsdXJbci5OT0RFXSB8fCByLmNsZWFyaW5nTW90aW9uQmx1cjtcbiAgaWYgKG5lZWRNYkNsZWFyW3IuTk9ERV0pIHtcbiAgICByLmNsZWFyZWRGb3JNb3Rpb25CbHVyW3IuTk9ERV0gPSB0cnVlO1xuICB9XG4gIG5lZWRNYkNsZWFyW3IuRFJBR10gPSAhbmVlZERyYXdbci5EUkFHXSAmJiBtb3Rpb25CbHVyICYmICFyLmNsZWFyZWRGb3JNb3Rpb25CbHVyW3IuRFJBR10gfHwgci5jbGVhcmluZ01vdGlvbkJsdXI7XG4gIGlmIChuZWVkTWJDbGVhcltyLkRSQUddKSB7XG4gICAgci5jbGVhcmVkRm9yTW90aW9uQmx1cltyLkRSQUddID0gdHJ1ZTtcbiAgfVxuICBpZiAobmVlZERyYXdbci5OT0RFXSB8fCBkcmF3QWxsTGF5ZXJzIHx8IGRyYXdPbmx5Tm9kZUxheWVyIHx8IG5lZWRNYkNsZWFyW3IuTk9ERV0pIHtcbiAgICB2YXIgdXNlQnVmZmVyID0gbW90aW9uQmx1ciAmJiAhbmVlZE1iQ2xlYXJbci5OT0RFXSAmJiBtYlB4UmF0aW8gIT09IDE7XG4gICAgdmFyIGNvbnRleHQgPSBmb3JjZWRDb250ZXh0IHx8ICh1c2VCdWZmZXIgPyByLmRhdGEuYnVmZmVyQ29udGV4dHNbci5NT1RJT05CTFVSX0JVRkZFUl9OT0RFXSA6IGRhdGEuY29udGV4dHNbci5OT0RFXSk7XG4gICAgdmFyIGNsZWFyID0gbW90aW9uQmx1ciAmJiAhdXNlQnVmZmVyID8gJ21vdGlvbkJsdXInIDogdW5kZWZpbmVkO1xuICAgIHNldENvbnRleHRUcmFuc2Zvcm0oY29udGV4dCwgY2xlYXIpO1xuICAgIGlmIChoaWRlRWRnZXMpIHtcbiAgICAgIHIuZHJhd0NhY2hlZE5vZGVzKGNvbnRleHQsIGVsZXMubm9uZHJhZywgcGl4ZWxSYXRpbywgZXh0ZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgci5kcmF3TGF5ZXJlZEVsZW1lbnRzKGNvbnRleHQsIGVsZXMubm9uZHJhZywgcGl4ZWxSYXRpbywgZXh0ZW50KTtcbiAgICB9XG4gICAgaWYgKHIuZGVidWcpIHtcbiAgICAgIHIuZHJhd0RlYnVnUG9pbnRzKGNvbnRleHQsIGVsZXMubm9uZHJhZyk7XG4gICAgfVxuICAgIGlmICghZHJhd0FsbExheWVycyAmJiAhbW90aW9uQmx1cikge1xuICAgICAgbmVlZERyYXdbci5OT0RFXSA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICBpZiAoIWRyYXdPbmx5Tm9kZUxheWVyICYmIChuZWVkRHJhd1tyLkRSQUddIHx8IGRyYXdBbGxMYXllcnMgfHwgbmVlZE1iQ2xlYXJbci5EUkFHXSkpIHtcbiAgICB2YXIgdXNlQnVmZmVyID0gbW90aW9uQmx1ciAmJiAhbmVlZE1iQ2xlYXJbci5EUkFHXSAmJiBtYlB4UmF0aW8gIT09IDE7XG4gICAgdmFyIGNvbnRleHQgPSBmb3JjZWRDb250ZXh0IHx8ICh1c2VCdWZmZXIgPyByLmRhdGEuYnVmZmVyQ29udGV4dHNbci5NT1RJT05CTFVSX0JVRkZFUl9EUkFHXSA6IGRhdGEuY29udGV4dHNbci5EUkFHXSk7XG4gICAgc2V0Q29udGV4dFRyYW5zZm9ybShjb250ZXh0LCBtb3Rpb25CbHVyICYmICF1c2VCdWZmZXIgPyAnbW90aW9uQmx1cicgOiB1bmRlZmluZWQpO1xuICAgIGlmIChoaWRlRWRnZXMpIHtcbiAgICAgIHIuZHJhd0NhY2hlZE5vZGVzKGNvbnRleHQsIGVsZXMuZHJhZywgcGl4ZWxSYXRpbywgZXh0ZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgci5kcmF3Q2FjaGVkRWxlbWVudHMoY29udGV4dCwgZWxlcy5kcmFnLCBwaXhlbFJhdGlvLCBleHRlbnQpO1xuICAgIH1cbiAgICBpZiAoci5kZWJ1Zykge1xuICAgICAgci5kcmF3RGVidWdQb2ludHMoY29udGV4dCwgZWxlcy5kcmFnKTtcbiAgICB9XG4gICAgaWYgKCFkcmF3QWxsTGF5ZXJzICYmICFtb3Rpb25CbHVyKSB7XG4gICAgICBuZWVkRHJhd1tyLkRSQUddID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIGlmIChyLnNob3dGcHMgfHwgIWRyYXdPbmx5Tm9kZUxheWVyICYmIG5lZWREcmF3W3IuU0VMRUNUX0JPWF0gJiYgIWRyYXdBbGxMYXllcnMpIHtcbiAgICB2YXIgY29udGV4dCA9IGZvcmNlZENvbnRleHQgfHwgZGF0YS5jb250ZXh0c1tyLlNFTEVDVF9CT1hdO1xuICAgIHNldENvbnRleHRUcmFuc2Zvcm0oY29udGV4dCk7XG4gICAgaWYgKHIuc2VsZWN0aW9uWzRdID09IDEgJiYgKHIuaG92ZXJEYXRhLnNlbGVjdGluZyB8fCByLnRvdWNoRGF0YS5zZWxlY3RpbmcpKSB7XG4gICAgICB2YXIgem9vbSA9IHIuY3kuem9vbSgpO1xuICAgICAgdmFyIGJvcmRlcldpZHRoID0gc3R5bGUuY29yZSgnc2VsZWN0aW9uLWJveC1ib3JkZXItd2lkdGgnKS52YWx1ZSAvIHpvb207XG4gICAgICBjb250ZXh0LmxpbmVXaWR0aCA9IGJvcmRlcldpZHRoO1xuICAgICAgY29udGV4dC5maWxsU3R5bGUgPSAncmdiYSgnICsgc3R5bGUuY29yZSgnc2VsZWN0aW9uLWJveC1jb2xvcicpLnZhbHVlWzBdICsgJywnICsgc3R5bGUuY29yZSgnc2VsZWN0aW9uLWJveC1jb2xvcicpLnZhbHVlWzFdICsgJywnICsgc3R5bGUuY29yZSgnc2VsZWN0aW9uLWJveC1jb2xvcicpLnZhbHVlWzJdICsgJywnICsgc3R5bGUuY29yZSgnc2VsZWN0aW9uLWJveC1vcGFjaXR5JykudmFsdWUgKyAnKSc7XG4gICAgICBjb250ZXh0LmZpbGxSZWN0KHIuc2VsZWN0aW9uWzBdLCByLnNlbGVjdGlvblsxXSwgci5zZWxlY3Rpb25bMl0gLSByLnNlbGVjdGlvblswXSwgci5zZWxlY3Rpb25bM10gLSByLnNlbGVjdGlvblsxXSk7XG4gICAgICBpZiAoYm9yZGVyV2lkdGggPiAwKSB7XG4gICAgICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSAncmdiYSgnICsgc3R5bGUuY29yZSgnc2VsZWN0aW9uLWJveC1ib3JkZXItY29sb3InKS52YWx1ZVswXSArICcsJyArIHN0eWxlLmNvcmUoJ3NlbGVjdGlvbi1ib3gtYm9yZGVyLWNvbG9yJykudmFsdWVbMV0gKyAnLCcgKyBzdHlsZS5jb3JlKCdzZWxlY3Rpb24tYm94LWJvcmRlci1jb2xvcicpLnZhbHVlWzJdICsgJywnICsgc3R5bGUuY29yZSgnc2VsZWN0aW9uLWJveC1vcGFjaXR5JykudmFsdWUgKyAnKSc7XG4gICAgICAgIGNvbnRleHQuc3Ryb2tlUmVjdChyLnNlbGVjdGlvblswXSwgci5zZWxlY3Rpb25bMV0sIHIuc2VsZWN0aW9uWzJdIC0gci5zZWxlY3Rpb25bMF0sIHIuc2VsZWN0aW9uWzNdIC0gci5zZWxlY3Rpb25bMV0pO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZGF0YS5iZ0FjdGl2ZVBvc2lzdGlvbiAmJiAhci5ob3ZlckRhdGEuc2VsZWN0aW5nKSB7XG4gICAgICB2YXIgem9vbSA9IHIuY3kuem9vbSgpO1xuICAgICAgdmFyIHBvcyA9IGRhdGEuYmdBY3RpdmVQb3Npc3Rpb247XG4gICAgICBjb250ZXh0LmZpbGxTdHlsZSA9ICdyZ2JhKCcgKyBzdHlsZS5jb3JlKCdhY3RpdmUtYmctY29sb3InKS52YWx1ZVswXSArICcsJyArIHN0eWxlLmNvcmUoJ2FjdGl2ZS1iZy1jb2xvcicpLnZhbHVlWzFdICsgJywnICsgc3R5bGUuY29yZSgnYWN0aXZlLWJnLWNvbG9yJykudmFsdWVbMl0gKyAnLCcgKyBzdHlsZS5jb3JlKCdhY3RpdmUtYmctb3BhY2l0eScpLnZhbHVlICsgJyknO1xuICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgIGNvbnRleHQuYXJjKHBvcy54LCBwb3MueSwgc3R5bGUuY29yZSgnYWN0aXZlLWJnLXNpemUnKS5wZlZhbHVlIC8gem9vbSwgMCwgMiAqIE1hdGguUEkpO1xuICAgICAgY29udGV4dC5maWxsKCk7XG4gICAgfVxuICAgIHZhciB0aW1lVG9SZW5kZXIgPSByLmxhc3RSZWRyYXdUaW1lO1xuICAgIGlmIChyLnNob3dGcHMgJiYgdGltZVRvUmVuZGVyKSB7XG4gICAgICB0aW1lVG9SZW5kZXIgPSBNYXRoLnJvdW5kKHRpbWVUb1JlbmRlcik7XG4gICAgICB2YXIgZnBzID0gTWF0aC5yb3VuZCgxMDAwIC8gdGltZVRvUmVuZGVyKTtcbiAgICAgIGNvbnRleHQuc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuICAgICAgY29udGV4dC5maWxsU3R5bGUgPSAncmdiYSgyNTUsIDAsIDAsIDAuNzUpJztcbiAgICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSAncmdiYSgyNTUsIDAsIDAsIDAuNzUpJztcbiAgICAgIGNvbnRleHQubGluZVdpZHRoID0gMTtcbiAgICAgIGNvbnRleHQuZmlsbFRleHQoJzEgZnJhbWUgPSAnICsgdGltZVRvUmVuZGVyICsgJyBtcyA9ICcgKyBmcHMgKyAnIGZwcycsIDAsIDIwKTtcbiAgICAgIHZhciBtYXhGcHMgPSA2MDtcbiAgICAgIGNvbnRleHQuc3Ryb2tlUmVjdCgwLCAzMCwgMjUwLCAyMCk7XG4gICAgICBjb250ZXh0LmZpbGxSZWN0KDAsIDMwLCAyNTAgKiBNYXRoLm1pbihmcHMgLyBtYXhGcHMsIDEpLCAyMCk7XG4gICAgfVxuICAgIGlmICghZHJhd0FsbExheWVycykge1xuICAgICAgbmVlZERyYXdbci5TRUxFQ1RfQk9YXSA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIC8vIG1vdGlvbmJsdXI6IGJsaXQgcmVuZGVyZWQgYmx1cnJ5IGZyYW1lc1xuICBpZiAobW90aW9uQmx1ciAmJiBtYlB4UmF0aW8gIT09IDEpIHtcbiAgICB2YXIgY3h0Tm9kZSA9IGRhdGEuY29udGV4dHNbci5OT0RFXTtcbiAgICB2YXIgdHh0Tm9kZSA9IHIuZGF0YS5idWZmZXJDYW52YXNlc1tyLk1PVElPTkJMVVJfQlVGRkVSX05PREVdO1xuICAgIHZhciBjeHREcmFnID0gZGF0YS5jb250ZXh0c1tyLkRSQUddO1xuICAgIHZhciB0eHREcmFnID0gci5kYXRhLmJ1ZmZlckNhbnZhc2VzW3IuTU9USU9OQkxVUl9CVUZGRVJfRFJBR107XG4gICAgdmFyIGRyYXdNb3Rpb25CbHVyID0gZnVuY3Rpb24gZHJhd01vdGlvbkJsdXIoY3h0LCB0eHQsIG5lZWRDbGVhcikge1xuICAgICAgY3h0LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcbiAgICAgIGlmIChuZWVkQ2xlYXIgfHwgIW1vdGlvbkJsdXJGYWRlRWZmZWN0KSB7XG4gICAgICAgIGN4dC5jbGVhclJlY3QoMCwgMCwgci5jYW52YXNXaWR0aCwgci5jYW52YXNIZWlnaHQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWJjbGVhcihjeHQsIDAsIDAsIHIuY2FudmFzV2lkdGgsIHIuY2FudmFzSGVpZ2h0KTtcbiAgICAgIH1cbiAgICAgIHZhciBweHIgPSBtYlB4UmF0aW87XG4gICAgICBjeHQuZHJhd0ltYWdlKHR4dCxcbiAgICAgIC8vIGltZ1xuICAgICAgMCwgMCxcbiAgICAgIC8vIHN4LCBzeVxuICAgICAgci5jYW52YXNXaWR0aCAqIHB4ciwgci5jYW52YXNIZWlnaHQgKiBweHIsXG4gICAgICAvLyBzdywgc2hcbiAgICAgIDAsIDAsXG4gICAgICAvLyB4LCB5XG4gICAgICByLmNhbnZhc1dpZHRoLCByLmNhbnZhc0hlaWdodCAvLyB3LCBoXG4gICAgICApO1xuICAgIH07XG5cbiAgICBpZiAobmVlZERyYXdbci5OT0RFXSB8fCBuZWVkTWJDbGVhcltyLk5PREVdKSB7XG4gICAgICBkcmF3TW90aW9uQmx1cihjeHROb2RlLCB0eHROb2RlLCBuZWVkTWJDbGVhcltyLk5PREVdKTtcbiAgICAgIG5lZWREcmF3W3IuTk9ERV0gPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKG5lZWREcmF3W3IuRFJBR10gfHwgbmVlZE1iQ2xlYXJbci5EUkFHXSkge1xuICAgICAgZHJhd01vdGlvbkJsdXIoY3h0RHJhZywgdHh0RHJhZywgbmVlZE1iQ2xlYXJbci5EUkFHXSk7XG4gICAgICBuZWVkRHJhd1tyLkRSQUddID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIHIucHJldlZpZXdwb3J0ID0gdnA7XG4gIGlmIChyLmNsZWFyaW5nTW90aW9uQmx1cikge1xuICAgIHIuY2xlYXJpbmdNb3Rpb25CbHVyID0gZmFsc2U7XG4gICAgci5tb3Rpb25CbHVyQ2xlYXJlZCA9IHRydWU7XG4gICAgci5tb3Rpb25CbHVyID0gdHJ1ZTtcbiAgfVxuICBpZiAobW90aW9uQmx1cikge1xuICAgIHIubW90aW9uQmx1clRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIHIubW90aW9uQmx1clRpbWVvdXQgPSBudWxsO1xuICAgICAgci5jbGVhcmVkRm9yTW90aW9uQmx1cltyLk5PREVdID0gZmFsc2U7XG4gICAgICByLmNsZWFyZWRGb3JNb3Rpb25CbHVyW3IuRFJBR10gPSBmYWxzZTtcbiAgICAgIHIubW90aW9uQmx1ciA9IGZhbHNlO1xuICAgICAgci5jbGVhcmluZ01vdGlvbkJsdXIgPSAhdGV4dHVyZURyYXc7XG4gICAgICByLm1iRnJhbWVzID0gMDtcbiAgICAgIG5lZWREcmF3W3IuTk9ERV0gPSB0cnVlO1xuICAgICAgbmVlZERyYXdbci5EUkFHXSA9IHRydWU7XG4gICAgICByLnJlZHJhdygpO1xuICAgIH0sIG1vdGlvbkJsdXJEZWxheSk7XG4gIH1cbiAgaWYgKCFmb3JjZWRDb250ZXh0KSB7XG4gICAgY3kuZW1pdCgncmVuZGVyJyk7XG4gIH1cbn07XG5cbnZhciBDUnAkMyA9IHt9O1xuXG4vLyBATyBQb2x5Z29uIGRyYXdpbmdcbkNScCQzLmRyYXdQb2x5Z29uUGF0aCA9IGZ1bmN0aW9uIChjb250ZXh0LCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCBwb2ludHMpIHtcbiAgdmFyIGhhbGZXID0gd2lkdGggLyAyO1xuICB2YXIgaGFsZkggPSBoZWlnaHQgLyAyO1xuICBpZiAoY29udGV4dC5iZWdpblBhdGgpIHtcbiAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICB9XG4gIGNvbnRleHQubW92ZVRvKHggKyBoYWxmVyAqIHBvaW50c1swXSwgeSArIGhhbGZIICogcG9pbnRzWzFdKTtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBwb2ludHMubGVuZ3RoIC8gMjsgaSsrKSB7XG4gICAgY29udGV4dC5saW5lVG8oeCArIGhhbGZXICogcG9pbnRzW2kgKiAyXSwgeSArIGhhbGZIICogcG9pbnRzW2kgKiAyICsgMV0pO1xuICB9XG4gIGNvbnRleHQuY2xvc2VQYXRoKCk7XG59O1xuQ1JwJDMuZHJhd1JvdW5kUG9seWdvblBhdGggPSBmdW5jdGlvbiAoY29udGV4dCwgeCwgeSwgd2lkdGgsIGhlaWdodCwgcG9pbnRzLCBjb3JuZXJzKSB7XG4gIGNvcm5lcnMuZm9yRWFjaChmdW5jdGlvbiAoY29ybmVyKSB7XG4gICAgcmV0dXJuIGRyYXdQcmVwYXJlZFJvdW5kQ29ybmVyKGNvbnRleHQsIGNvcm5lcik7XG4gIH0pO1xuICBjb250ZXh0LmNsb3NlUGF0aCgpO1xufTtcblxuLy8gUm91bmQgcmVjdGFuZ2xlIGRyYXdpbmdcbkNScCQzLmRyYXdSb3VuZFJlY3RhbmdsZVBhdGggPSBmdW5jdGlvbiAoY29udGV4dCwgeCwgeSwgd2lkdGgsIGhlaWdodCwgcmFkaXVzKSB7XG4gIHZhciBoYWxmV2lkdGggPSB3aWR0aCAvIDI7XG4gIHZhciBoYWxmSGVpZ2h0ID0gaGVpZ2h0IC8gMjtcbiAgdmFyIGNvcm5lclJhZGl1cyA9IHJhZGl1cyA9PT0gJ2F1dG8nID8gZ2V0Um91bmRSZWN0YW5nbGVSYWRpdXMod2lkdGgsIGhlaWdodCkgOiBNYXRoLm1pbihyYWRpdXMsIGhhbGZIZWlnaHQsIGhhbGZXaWR0aCk7XG4gIGlmIChjb250ZXh0LmJlZ2luUGF0aCkge1xuICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gIH1cblxuICAvLyBTdGFydCBhdCB0b3AgbWlkZGxlXG4gIGNvbnRleHQubW92ZVRvKHgsIHkgLSBoYWxmSGVpZ2h0KTtcbiAgLy8gQXJjIGZyb20gbWlkZGxlIHRvcCB0byByaWdodCBzaWRlXG4gIGNvbnRleHQuYXJjVG8oeCArIGhhbGZXaWR0aCwgeSAtIGhhbGZIZWlnaHQsIHggKyBoYWxmV2lkdGgsIHksIGNvcm5lclJhZGl1cyk7XG4gIC8vIEFyYyBmcm9tIHJpZ2h0IHNpZGUgdG8gYm90dG9tXG4gIGNvbnRleHQuYXJjVG8oeCArIGhhbGZXaWR0aCwgeSArIGhhbGZIZWlnaHQsIHgsIHkgKyBoYWxmSGVpZ2h0LCBjb3JuZXJSYWRpdXMpO1xuICAvLyBBcmMgZnJvbSBib3R0b20gdG8gbGVmdCBzaWRlXG4gIGNvbnRleHQuYXJjVG8oeCAtIGhhbGZXaWR0aCwgeSArIGhhbGZIZWlnaHQsIHggLSBoYWxmV2lkdGgsIHksIGNvcm5lclJhZGl1cyk7XG4gIC8vIEFyYyBmcm9tIGxlZnQgc2lkZSB0byB0b3BCb3JkZXJcbiAgY29udGV4dC5hcmNUbyh4IC0gaGFsZldpZHRoLCB5IC0gaGFsZkhlaWdodCwgeCwgeSAtIGhhbGZIZWlnaHQsIGNvcm5lclJhZGl1cyk7XG4gIC8vIEpvaW4gbGluZVxuICBjb250ZXh0LmxpbmVUbyh4LCB5IC0gaGFsZkhlaWdodCk7XG4gIGNvbnRleHQuY2xvc2VQYXRoKCk7XG59O1xuQ1JwJDMuZHJhd0JvdHRvbVJvdW5kUmVjdGFuZ2xlUGF0aCA9IGZ1bmN0aW9uIChjb250ZXh0LCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCByYWRpdXMpIHtcbiAgdmFyIGhhbGZXaWR0aCA9IHdpZHRoIC8gMjtcbiAgdmFyIGhhbGZIZWlnaHQgPSBoZWlnaHQgLyAyO1xuICB2YXIgY29ybmVyUmFkaXVzID0gcmFkaXVzID09PSAnYXV0bycgPyBnZXRSb3VuZFJlY3RhbmdsZVJhZGl1cyh3aWR0aCwgaGVpZ2h0KSA6IHJhZGl1cztcbiAgaWYgKGNvbnRleHQuYmVnaW5QYXRoKSB7XG4gICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgfVxuXG4gIC8vIFN0YXJ0IGF0IHRvcCBtaWRkbGVcbiAgY29udGV4dC5tb3ZlVG8oeCwgeSAtIGhhbGZIZWlnaHQpO1xuICBjb250ZXh0LmxpbmVUbyh4ICsgaGFsZldpZHRoLCB5IC0gaGFsZkhlaWdodCk7XG4gIGNvbnRleHQubGluZVRvKHggKyBoYWxmV2lkdGgsIHkpO1xuICBjb250ZXh0LmFyY1RvKHggKyBoYWxmV2lkdGgsIHkgKyBoYWxmSGVpZ2h0LCB4LCB5ICsgaGFsZkhlaWdodCwgY29ybmVyUmFkaXVzKTtcbiAgY29udGV4dC5hcmNUbyh4IC0gaGFsZldpZHRoLCB5ICsgaGFsZkhlaWdodCwgeCAtIGhhbGZXaWR0aCwgeSwgY29ybmVyUmFkaXVzKTtcbiAgY29udGV4dC5saW5lVG8oeCAtIGhhbGZXaWR0aCwgeSAtIGhhbGZIZWlnaHQpO1xuICBjb250ZXh0LmxpbmVUbyh4LCB5IC0gaGFsZkhlaWdodCk7XG4gIGNvbnRleHQuY2xvc2VQYXRoKCk7XG59O1xuQ1JwJDMuZHJhd0N1dFJlY3RhbmdsZVBhdGggPSBmdW5jdGlvbiAoY29udGV4dCwgeCwgeSwgd2lkdGgsIGhlaWdodCwgcG9pbnRzLCBjb3JuZXJzKSB7XG4gIHZhciBoYWxmV2lkdGggPSB3aWR0aCAvIDI7XG4gIHZhciBoYWxmSGVpZ2h0ID0gaGVpZ2h0IC8gMjtcbiAgdmFyIGNvcm5lckxlbmd0aCA9IGNvcm5lcnMgPT09ICdhdXRvJyA/IGdldEN1dFJlY3RhbmdsZUNvcm5lckxlbmd0aCgpIDogY29ybmVycztcbiAgaWYgKGNvbnRleHQuYmVnaW5QYXRoKSB7XG4gICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgfVxuICBjb250ZXh0Lm1vdmVUbyh4IC0gaGFsZldpZHRoICsgY29ybmVyTGVuZ3RoLCB5IC0gaGFsZkhlaWdodCk7XG4gIGNvbnRleHQubGluZVRvKHggKyBoYWxmV2lkdGggLSBjb3JuZXJMZW5ndGgsIHkgLSBoYWxmSGVpZ2h0KTtcbiAgY29udGV4dC5saW5lVG8oeCArIGhhbGZXaWR0aCwgeSAtIGhhbGZIZWlnaHQgKyBjb3JuZXJMZW5ndGgpO1xuICBjb250ZXh0LmxpbmVUbyh4ICsgaGFsZldpZHRoLCB5ICsgaGFsZkhlaWdodCAtIGNvcm5lckxlbmd0aCk7XG4gIGNvbnRleHQubGluZVRvKHggKyBoYWxmV2lkdGggLSBjb3JuZXJMZW5ndGgsIHkgKyBoYWxmSGVpZ2h0KTtcbiAgY29udGV4dC5saW5lVG8oeCAtIGhhbGZXaWR0aCArIGNvcm5lckxlbmd0aCwgeSArIGhhbGZIZWlnaHQpO1xuICBjb250ZXh0LmxpbmVUbyh4IC0gaGFsZldpZHRoLCB5ICsgaGFsZkhlaWdodCAtIGNvcm5lckxlbmd0aCk7XG4gIGNvbnRleHQubGluZVRvKHggLSBoYWxmV2lkdGgsIHkgLSBoYWxmSGVpZ2h0ICsgY29ybmVyTGVuZ3RoKTtcbiAgY29udGV4dC5jbG9zZVBhdGgoKTtcbn07XG5DUnAkMy5kcmF3QmFycmVsUGF0aCA9IGZ1bmN0aW9uIChjb250ZXh0LCB4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG4gIHZhciBoYWxmV2lkdGggPSB3aWR0aCAvIDI7XG4gIHZhciBoYWxmSGVpZ2h0ID0gaGVpZ2h0IC8gMjtcbiAgdmFyIHhCZWdpbiA9IHggLSBoYWxmV2lkdGg7XG4gIHZhciB4RW5kID0geCArIGhhbGZXaWR0aDtcbiAgdmFyIHlCZWdpbiA9IHkgLSBoYWxmSGVpZ2h0O1xuICB2YXIgeUVuZCA9IHkgKyBoYWxmSGVpZ2h0O1xuICB2YXIgYmFycmVsQ3VydmVDb25zdGFudHMgPSBnZXRCYXJyZWxDdXJ2ZUNvbnN0YW50cyh3aWR0aCwgaGVpZ2h0KTtcbiAgdmFyIHdPZmZzZXQgPSBiYXJyZWxDdXJ2ZUNvbnN0YW50cy53aWR0aE9mZnNldDtcbiAgdmFyIGhPZmZzZXQgPSBiYXJyZWxDdXJ2ZUNvbnN0YW50cy5oZWlnaHRPZmZzZXQ7XG4gIHZhciBjdHJsUHRYT2Zmc2V0ID0gYmFycmVsQ3VydmVDb25zdGFudHMuY3RybFB0T2Zmc2V0UGN0ICogd09mZnNldDtcbiAgaWYgKGNvbnRleHQuYmVnaW5QYXRoKSB7XG4gICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgfVxuICBjb250ZXh0Lm1vdmVUbyh4QmVnaW4sIHlCZWdpbiArIGhPZmZzZXQpO1xuICBjb250ZXh0LmxpbmVUbyh4QmVnaW4sIHlFbmQgLSBoT2Zmc2V0KTtcbiAgY29udGV4dC5xdWFkcmF0aWNDdXJ2ZVRvKHhCZWdpbiArIGN0cmxQdFhPZmZzZXQsIHlFbmQsIHhCZWdpbiArIHdPZmZzZXQsIHlFbmQpO1xuICBjb250ZXh0LmxpbmVUbyh4RW5kIC0gd09mZnNldCwgeUVuZCk7XG4gIGNvbnRleHQucXVhZHJhdGljQ3VydmVUbyh4RW5kIC0gY3RybFB0WE9mZnNldCwgeUVuZCwgeEVuZCwgeUVuZCAtIGhPZmZzZXQpO1xuICBjb250ZXh0LmxpbmVUbyh4RW5kLCB5QmVnaW4gKyBoT2Zmc2V0KTtcbiAgY29udGV4dC5xdWFkcmF0aWNDdXJ2ZVRvKHhFbmQgLSBjdHJsUHRYT2Zmc2V0LCB5QmVnaW4sIHhFbmQgLSB3T2Zmc2V0LCB5QmVnaW4pO1xuICBjb250ZXh0LmxpbmVUbyh4QmVnaW4gKyB3T2Zmc2V0LCB5QmVnaW4pO1xuICBjb250ZXh0LnF1YWRyYXRpY0N1cnZlVG8oeEJlZ2luICsgY3RybFB0WE9mZnNldCwgeUJlZ2luLCB4QmVnaW4sIHlCZWdpbiArIGhPZmZzZXQpO1xuICBjb250ZXh0LmNsb3NlUGF0aCgpO1xufTtcbnZhciBzaW4wID0gTWF0aC5zaW4oMCk7XG52YXIgY29zMCA9IE1hdGguY29zKDApO1xudmFyIHNpbiA9IHt9O1xudmFyIGNvcyA9IHt9O1xudmFyIGVsbGlwc2VTdGVwU2l6ZSA9IE1hdGguUEkgLyA0MDtcbmZvciAodmFyIGkgPSAwICogTWF0aC5QSTsgaSA8IDIgKiBNYXRoLlBJOyBpICs9IGVsbGlwc2VTdGVwU2l6ZSkge1xuICBzaW5baV0gPSBNYXRoLnNpbihpKTtcbiAgY29zW2ldID0gTWF0aC5jb3MoaSk7XG59XG5DUnAkMy5kcmF3RWxsaXBzZVBhdGggPSBmdW5jdGlvbiAoY29udGV4dCwgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCkge1xuICBpZiAoY29udGV4dC5iZWdpblBhdGgpIHtcbiAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICB9XG4gIGlmIChjb250ZXh0LmVsbGlwc2UpIHtcbiAgICBjb250ZXh0LmVsbGlwc2UoY2VudGVyWCwgY2VudGVyWSwgd2lkdGggLyAyLCBoZWlnaHQgLyAyLCAwLCAwLCAyICogTWF0aC5QSSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHhQb3MsIHlQb3M7XG4gICAgdmFyIHJ3ID0gd2lkdGggLyAyO1xuICAgIHZhciByaCA9IGhlaWdodCAvIDI7XG4gICAgZm9yICh2YXIgaSA9IDAgKiBNYXRoLlBJOyBpIDwgMiAqIE1hdGguUEk7IGkgKz0gZWxsaXBzZVN0ZXBTaXplKSB7XG4gICAgICB4UG9zID0gY2VudGVyWCAtIHJ3ICogc2luW2ldICogc2luMCArIHJ3ICogY29zW2ldICogY29zMDtcbiAgICAgIHlQb3MgPSBjZW50ZXJZICsgcmggKiBjb3NbaV0gKiBzaW4wICsgcmggKiBzaW5baV0gKiBjb3MwO1xuICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgY29udGV4dC5tb3ZlVG8oeFBvcywgeVBvcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250ZXh0LmxpbmVUbyh4UG9zLCB5UG9zKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY29udGV4dC5jbG9zZVBhdGgoKTtcbn07XG5cbi8qIGdsb2JhbCBhdG9iLCBBcnJheUJ1ZmZlciwgVWludDhBcnJheSwgQmxvYiAqL1xudmFyIENScCQyID0ge307XG5DUnAkMi5jcmVhdGVCdWZmZXIgPSBmdW5jdGlvbiAodywgaCkge1xuICB2YXIgYnVmZmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbiAgYnVmZmVyLndpZHRoID0gdztcbiAgYnVmZmVyLmhlaWdodCA9IGg7XG4gIHJldHVybiBbYnVmZmVyLCBidWZmZXIuZ2V0Q29udGV4dCgnMmQnKV07XG59O1xuQ1JwJDIuYnVmZmVyQ2FudmFzSW1hZ2UgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICB2YXIgY3kgPSB0aGlzLmN5O1xuICB2YXIgZWxlcyA9IGN5Lm11dGFibGVFbGVtZW50cygpO1xuICB2YXIgYmIgPSBlbGVzLmJvdW5kaW5nQm94KCk7XG4gIHZhciBjdHJSZWN0ID0gdGhpcy5maW5kQ29udGFpbmVyQ2xpZW50Q29vcmRzKCk7XG4gIHZhciB3aWR0aCA9IG9wdGlvbnMuZnVsbCA/IE1hdGguY2VpbChiYi53KSA6IGN0clJlY3RbMl07XG4gIHZhciBoZWlnaHQgPSBvcHRpb25zLmZ1bGwgPyBNYXRoLmNlaWwoYmIuaCkgOiBjdHJSZWN0WzNdO1xuICB2YXIgc3BlY2RNYXhEaW1zID0gbnVtYmVyJDEob3B0aW9ucy5tYXhXaWR0aCkgfHwgbnVtYmVyJDEob3B0aW9ucy5tYXhIZWlnaHQpO1xuICB2YXIgcHhSYXRpbyA9IHRoaXMuZ2V0UGl4ZWxSYXRpbygpO1xuICB2YXIgc2NhbGUgPSAxO1xuICBpZiAob3B0aW9ucy5zY2FsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgd2lkdGggKj0gb3B0aW9ucy5zY2FsZTtcbiAgICBoZWlnaHQgKj0gb3B0aW9ucy5zY2FsZTtcbiAgICBzY2FsZSA9IG9wdGlvbnMuc2NhbGU7XG4gIH0gZWxzZSBpZiAoc3BlY2RNYXhEaW1zKSB7XG4gICAgdmFyIG1heFNjYWxlVyA9IEluZmluaXR5O1xuICAgIHZhciBtYXhTY2FsZUggPSBJbmZpbml0eTtcbiAgICBpZiAobnVtYmVyJDEob3B0aW9ucy5tYXhXaWR0aCkpIHtcbiAgICAgIG1heFNjYWxlVyA9IHNjYWxlICogb3B0aW9ucy5tYXhXaWR0aCAvIHdpZHRoO1xuICAgIH1cbiAgICBpZiAobnVtYmVyJDEob3B0aW9ucy5tYXhIZWlnaHQpKSB7XG4gICAgICBtYXhTY2FsZUggPSBzY2FsZSAqIG9wdGlvbnMubWF4SGVpZ2h0IC8gaGVpZ2h0O1xuICAgIH1cbiAgICBzY2FsZSA9IE1hdGgubWluKG1heFNjYWxlVywgbWF4U2NhbGVIKTtcbiAgICB3aWR0aCAqPSBzY2FsZTtcbiAgICBoZWlnaHQgKj0gc2NhbGU7XG4gIH1cbiAgaWYgKCFzcGVjZE1heERpbXMpIHtcbiAgICB3aWR0aCAqPSBweFJhdGlvO1xuICAgIGhlaWdodCAqPSBweFJhdGlvO1xuICAgIHNjYWxlICo9IHB4UmF0aW87XG4gIH1cbiAgdmFyIGJ1ZmZDYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuXG4gIGJ1ZmZDYW52YXMud2lkdGggPSB3aWR0aDtcbiAgYnVmZkNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG4gIGJ1ZmZDYW52YXMuc3R5bGUud2lkdGggPSB3aWR0aCArICdweCc7XG4gIGJ1ZmZDYW52YXMuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgJ3B4JztcbiAgdmFyIGJ1ZmZDeHQgPSBidWZmQ2FudmFzLmdldENvbnRleHQoJzJkJyk7XG5cbiAgLy8gUmFzdGVyaXplIHRoZSBsYXllcnMsIGJ1dCBvbmx5IGlmIGNvbnRhaW5lciBoYXMgbm9uemVybyBzaXplXG4gIGlmICh3aWR0aCA+IDAgJiYgaGVpZ2h0ID4gMCkge1xuICAgIGJ1ZmZDeHQuY2xlYXJSZWN0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgIGJ1ZmZDeHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gJ3NvdXJjZS1vdmVyJztcbiAgICB2YXIgenNvcnRlZEVsZXMgPSB0aGlzLmdldENhY2hlZFpTb3J0ZWRFbGVzKCk7XG4gICAgaWYgKG9wdGlvbnMuZnVsbCkge1xuICAgICAgLy8gZHJhdyB0aGUgZnVsbCBib3VuZHMgb2YgdGhlIGdyYXBoXG4gICAgICBidWZmQ3h0LnRyYW5zbGF0ZSgtYmIueDEgKiBzY2FsZSwgLWJiLnkxICogc2NhbGUpO1xuICAgICAgYnVmZkN4dC5zY2FsZShzY2FsZSwgc2NhbGUpO1xuICAgICAgdGhpcy5kcmF3RWxlbWVudHMoYnVmZkN4dCwgenNvcnRlZEVsZXMpO1xuICAgICAgYnVmZkN4dC5zY2FsZSgxIC8gc2NhbGUsIDEgLyBzY2FsZSk7XG4gICAgICBidWZmQ3h0LnRyYW5zbGF0ZShiYi54MSAqIHNjYWxlLCBiYi55MSAqIHNjYWxlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZHJhdyB0aGUgY3VycmVudCB2aWV3XG4gICAgICB2YXIgcGFuID0gY3kucGFuKCk7XG4gICAgICB2YXIgdHJhbnNsYXRpb24gPSB7XG4gICAgICAgIHg6IHBhbi54ICogc2NhbGUsXG4gICAgICAgIHk6IHBhbi55ICogc2NhbGVcbiAgICAgIH07XG4gICAgICBzY2FsZSAqPSBjeS56b29tKCk7XG4gICAgICBidWZmQ3h0LnRyYW5zbGF0ZSh0cmFuc2xhdGlvbi54LCB0cmFuc2xhdGlvbi55KTtcbiAgICAgIGJ1ZmZDeHQuc2NhbGUoc2NhbGUsIHNjYWxlKTtcbiAgICAgIHRoaXMuZHJhd0VsZW1lbnRzKGJ1ZmZDeHQsIHpzb3J0ZWRFbGVzKTtcbiAgICAgIGJ1ZmZDeHQuc2NhbGUoMSAvIHNjYWxlLCAxIC8gc2NhbGUpO1xuICAgICAgYnVmZkN4dC50cmFuc2xhdGUoLXRyYW5zbGF0aW9uLngsIC10cmFuc2xhdGlvbi55KTtcbiAgICB9XG5cbiAgICAvLyBuZWVkIHRvIGZpbGwgYmcgYXQgZW5kIGxpa2UgdGhpcyBpbiBvcmRlciB0byBmaWxsIGNsZWFyZWQgdHJhbnNwYXJlbnQgcGl4ZWxzIGluIGpwZ3NcbiAgICBpZiAob3B0aW9ucy5iZykge1xuICAgICAgYnVmZkN4dC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSAnZGVzdGluYXRpb24tb3Zlcic7XG4gICAgICBidWZmQ3h0LmZpbGxTdHlsZSA9IG9wdGlvbnMuYmc7XG4gICAgICBidWZmQ3h0LnJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICBidWZmQ3h0LmZpbGwoKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGJ1ZmZDYW52YXM7XG59O1xuZnVuY3Rpb24gYjY0VG9CbG9iKGI2NCwgbWltZVR5cGUpIHtcbiAgdmFyIGJ5dGVzID0gYXRvYihiNjQpO1xuICB2YXIgYnVmZiA9IG5ldyBBcnJheUJ1ZmZlcihieXRlcy5sZW5ndGgpO1xuICB2YXIgYnVmZlVpbnQ4ID0gbmV3IFVpbnQ4QXJyYXkoYnVmZik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICBidWZmVWludDhbaV0gPSBieXRlcy5jaGFyQ29kZUF0KGkpO1xuICB9XG4gIHJldHVybiBuZXcgQmxvYihbYnVmZl0sIHtcbiAgICB0eXBlOiBtaW1lVHlwZVxuICB9KTtcbn1cbmZ1bmN0aW9uIGI2NFVyaVRvQjY0KGI2NHVyaSkge1xuICB2YXIgaSA9IGI2NHVyaS5pbmRleE9mKCcsJyk7XG4gIHJldHVybiBiNjR1cmkuc3Vic3RyKGkgKyAxKTtcbn1cbmZ1bmN0aW9uIG91dHB1dChvcHRpb25zLCBjYW52YXMsIG1pbWVUeXBlKSB7XG4gIHZhciBnZXRCNjRVcmkgPSBmdW5jdGlvbiBnZXRCNjRVcmkoKSB7XG4gICAgcmV0dXJuIGNhbnZhcy50b0RhdGFVUkwobWltZVR5cGUsIG9wdGlvbnMucXVhbGl0eSk7XG4gIH07XG4gIHN3aXRjaCAob3B0aW9ucy5vdXRwdXQpIHtcbiAgICBjYXNlICdibG9iLXByb21pc2UnOlxuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlJDEoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNhbnZhcy50b0Jsb2IoZnVuY3Rpb24gKGJsb2IpIHtcbiAgICAgICAgICAgIGlmIChibG9iICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgcmVzb2x2ZShibG9iKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ2BjYW52YXMudG9CbG9iKClgIHNlbnQgYSBudWxsIHZhbHVlIGluIGl0cyBjYWxsYmFjaycpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCBtaW1lVHlwZSwgb3B0aW9ucy5xdWFsaXR5KTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIGNhc2UgJ2Jsb2InOlxuICAgICAgcmV0dXJuIGI2NFRvQmxvYihiNjRVcmlUb0I2NChnZXRCNjRVcmkoKSksIG1pbWVUeXBlKTtcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgcmV0dXJuIGI2NFVyaVRvQjY0KGdldEI2NFVyaSgpKTtcbiAgICBjYXNlICdiYXNlNjR1cmknOlxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZ2V0QjY0VXJpKCk7XG4gIH1cbn1cbkNScCQyLnBuZyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIHJldHVybiBvdXRwdXQob3B0aW9ucywgdGhpcy5idWZmZXJDYW52YXNJbWFnZShvcHRpb25zKSwgJ2ltYWdlL3BuZycpO1xufTtcbkNScCQyLmpwZyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIHJldHVybiBvdXRwdXQob3B0aW9ucywgdGhpcy5idWZmZXJDYW52YXNJbWFnZShvcHRpb25zKSwgJ2ltYWdlL2pwZWcnKTtcbn07XG5cbnZhciBDUnAkMSA9IHt9O1xuQ1JwJDEubm9kZVNoYXBlSW1wbCA9IGZ1bmN0aW9uIChuYW1lLCBjb250ZXh0LCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0LCBwb2ludHMsIGNvcm5lcnMpIHtcbiAgc3dpdGNoIChuYW1lKSB7XG4gICAgY2FzZSAnZWxsaXBzZSc6XG4gICAgICByZXR1cm4gdGhpcy5kcmF3RWxsaXBzZVBhdGgoY29udGV4dCwgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCk7XG4gICAgY2FzZSAncG9seWdvbic6XG4gICAgICByZXR1cm4gdGhpcy5kcmF3UG9seWdvblBhdGgoY29udGV4dCwgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCwgcG9pbnRzKTtcbiAgICBjYXNlICdyb3VuZC1wb2x5Z29uJzpcbiAgICAgIHJldHVybiB0aGlzLmRyYXdSb3VuZFBvbHlnb25QYXRoKGNvbnRleHQsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQsIHBvaW50cywgY29ybmVycyk7XG4gICAgY2FzZSAncm91bmRyZWN0YW5nbGUnOlxuICAgIGNhc2UgJ3JvdW5kLXJlY3RhbmdsZSc6XG4gICAgICByZXR1cm4gdGhpcy5kcmF3Um91bmRSZWN0YW5nbGVQYXRoKGNvbnRleHQsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQsIGNvcm5lcnMpO1xuICAgIGNhc2UgJ2N1dHJlY3RhbmdsZSc6XG4gICAgY2FzZSAnY3V0LXJlY3RhbmdsZSc6XG4gICAgICByZXR1cm4gdGhpcy5kcmF3Q3V0UmVjdGFuZ2xlUGF0aChjb250ZXh0LCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0LCBwb2ludHMsIGNvcm5lcnMpO1xuICAgIGNhc2UgJ2JvdHRvbXJvdW5kcmVjdGFuZ2xlJzpcbiAgICBjYXNlICdib3R0b20tcm91bmQtcmVjdGFuZ2xlJzpcbiAgICAgIHJldHVybiB0aGlzLmRyYXdCb3R0b21Sb3VuZFJlY3RhbmdsZVBhdGgoY29udGV4dCwgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCwgY29ybmVycyk7XG4gICAgY2FzZSAnYmFycmVsJzpcbiAgICAgIHJldHVybiB0aGlzLmRyYXdCYXJyZWxQYXRoKGNvbnRleHQsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQpO1xuICB9XG59O1xuXG52YXIgQ1IgPSBDYW52YXNSZW5kZXJlcjtcbnZhciBDUnAgPSBDYW52YXNSZW5kZXJlci5wcm90b3R5cGU7XG5DUnAuQ0FOVkFTX0xBWUVSUyA9IDM7XG4vL1xuQ1JwLlNFTEVDVF9CT1ggPSAwO1xuQ1JwLkRSQUcgPSAxO1xuQ1JwLk5PREUgPSAyO1xuQ1JwLkJVRkZFUl9DT1VOVCA9IDM7XG4vL1xuQ1JwLlRFWFRVUkVfQlVGRkVSID0gMDtcbkNScC5NT1RJT05CTFVSX0JVRkZFUl9OT0RFID0gMTtcbkNScC5NT1RJT05CTFVSX0JVRkZFUl9EUkFHID0gMjtcbmZ1bmN0aW9uIENhbnZhc1JlbmRlcmVyKG9wdGlvbnMpIHtcbiAgdmFyIHIgPSB0aGlzO1xuICB2YXIgY29udGFpbmVyV2luZG93ID0gci5jeS53aW5kb3coKTtcbiAgdmFyIGRvY3VtZW50ID0gY29udGFpbmVyV2luZG93LmRvY3VtZW50O1xuICByLmRhdGEgPSB7XG4gICAgY2FudmFzZXM6IG5ldyBBcnJheShDUnAuQ0FOVkFTX0xBWUVSUyksXG4gICAgY29udGV4dHM6IG5ldyBBcnJheShDUnAuQ0FOVkFTX0xBWUVSUyksXG4gICAgY2FudmFzTmVlZHNSZWRyYXc6IG5ldyBBcnJheShDUnAuQ0FOVkFTX0xBWUVSUyksXG4gICAgYnVmZmVyQ2FudmFzZXM6IG5ldyBBcnJheShDUnAuQlVGRkVSX0NPVU5UKSxcbiAgICBidWZmZXJDb250ZXh0czogbmV3IEFycmF5KENScC5DQU5WQVNfTEFZRVJTKVxuICB9O1xuICB2YXIgdGFwSGxPZmZBdHRyID0gJy13ZWJraXQtdGFwLWhpZ2hsaWdodC1jb2xvcic7XG4gIHZhciB0YXBIbE9mZlN0eWxlID0gJ3JnYmEoMCwwLDAsMCknO1xuICByLmRhdGEuY2FudmFzQ29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbiAgdmFyIGNvbnRhaW5lclN0eWxlID0gci5kYXRhLmNhbnZhc0NvbnRhaW5lci5zdHlsZTtcbiAgci5kYXRhLmNhbnZhc0NvbnRhaW5lci5zdHlsZVt0YXBIbE9mZkF0dHJdID0gdGFwSGxPZmZTdHlsZTtcbiAgY29udGFpbmVyU3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnO1xuICBjb250YWluZXJTdHlsZS56SW5kZXggPSAnMCc7XG4gIGNvbnRhaW5lclN0eWxlLm92ZXJmbG93ID0gJ2hpZGRlbic7XG4gIHZhciBjb250YWluZXIgPSBvcHRpb25zLmN5LmNvbnRhaW5lcigpO1xuICBjb250YWluZXIuYXBwZW5kQ2hpbGQoci5kYXRhLmNhbnZhc0NvbnRhaW5lcik7XG4gIGNvbnRhaW5lci5zdHlsZVt0YXBIbE9mZkF0dHJdID0gdGFwSGxPZmZTdHlsZTtcbiAgdmFyIHN0eWxlTWFwID0ge1xuICAgICctd2Via2l0LXVzZXItc2VsZWN0JzogJ25vbmUnLFxuICAgICctbW96LXVzZXItc2VsZWN0JzogJy1tb3otbm9uZScsXG4gICAgJ3VzZXItc2VsZWN0JzogJ25vbmUnLFxuICAgICctd2Via2l0LXRhcC1oaWdobGlnaHQtY29sb3InOiAncmdiYSgwLDAsMCwwKScsXG4gICAgJ291dGxpbmUtc3R5bGUnOiAnbm9uZSdcbiAgfTtcbiAgaWYgKG1zKCkpIHtcbiAgICBzdHlsZU1hcFsnLW1zLXRvdWNoLWFjdGlvbiddID0gJ25vbmUnO1xuICAgIHN0eWxlTWFwWyd0b3VjaC1hY3Rpb24nXSA9ICdub25lJztcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IENScC5DQU5WQVNfTEFZRVJTOyBpKyspIHtcbiAgICB2YXIgY2FudmFzID0gci5kYXRhLmNhbnZhc2VzW2ldID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbiAgICByLmRhdGEuY29udGV4dHNbaV0gPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICBPYmplY3Qua2V5cyhzdHlsZU1hcCkuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICAgICAgY2FudmFzLnN0eWxlW2tdID0gc3R5bGVNYXBba107XG4gICAgfSk7XG4gICAgY2FudmFzLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICBjYW52YXMuc2V0QXR0cmlidXRlKCdkYXRhLWlkJywgJ2xheWVyJyArIGkpO1xuICAgIGNhbnZhcy5zdHlsZS56SW5kZXggPSBTdHJpbmcoQ1JwLkNBTlZBU19MQVlFUlMgLSBpKTtcbiAgICByLmRhdGEuY2FudmFzQ29udGFpbmVyLmFwcGVuZENoaWxkKGNhbnZhcyk7XG4gICAgci5kYXRhLmNhbnZhc05lZWRzUmVkcmF3W2ldID0gZmFsc2U7XG4gIH1cbiAgci5kYXRhLnRvcENhbnZhcyA9IHIuZGF0YS5jYW52YXNlc1swXTtcbiAgci5kYXRhLmNhbnZhc2VzW0NScC5OT0RFXS5zZXRBdHRyaWJ1dGUoJ2RhdGEtaWQnLCAnbGF5ZXInICsgQ1JwLk5PREUgKyAnLW5vZGUnKTtcbiAgci5kYXRhLmNhbnZhc2VzW0NScC5TRUxFQ1RfQk9YXS5zZXRBdHRyaWJ1dGUoJ2RhdGEtaWQnLCAnbGF5ZXInICsgQ1JwLlNFTEVDVF9CT1ggKyAnLXNlbGVjdGJveCcpO1xuICByLmRhdGEuY2FudmFzZXNbQ1JwLkRSQUddLnNldEF0dHJpYnV0ZSgnZGF0YS1pZCcsICdsYXllcicgKyBDUnAuRFJBRyArICctZHJhZycpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IENScC5CVUZGRVJfQ09VTlQ7IGkrKykge1xuICAgIHIuZGF0YS5idWZmZXJDYW52YXNlc1tpXSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG4gICAgci5kYXRhLmJ1ZmZlckNvbnRleHRzW2ldID0gci5kYXRhLmJ1ZmZlckNhbnZhc2VzW2ldLmdldENvbnRleHQoJzJkJyk7XG4gICAgci5kYXRhLmJ1ZmZlckNhbnZhc2VzW2ldLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICByLmRhdGEuYnVmZmVyQ2FudmFzZXNbaV0uc2V0QXR0cmlidXRlKCdkYXRhLWlkJywgJ2J1ZmZlcicgKyBpKTtcbiAgICByLmRhdGEuYnVmZmVyQ2FudmFzZXNbaV0uc3R5bGUuekluZGV4ID0gU3RyaW5nKC1pIC0gMSk7XG4gICAgci5kYXRhLmJ1ZmZlckNhbnZhc2VzW2ldLnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcbiAgICAvL3IuZGF0YS5jYW52YXNDb250YWluZXIuYXBwZW5kQ2hpbGQoci5kYXRhLmJ1ZmZlckNhbnZhc2VzW2ldKTtcbiAgfVxuXG4gIHIucGF0aHNFbmFibGVkID0gdHJ1ZTtcbiAgdmFyIGVtcHR5QmIgPSBtYWtlQm91bmRpbmdCb3goKTtcbiAgdmFyIGdldEJveENlbnRlciA9IGZ1bmN0aW9uIGdldEJveENlbnRlcihiYikge1xuICAgIHJldHVybiB7XG4gICAgICB4OiAoYmIueDEgKyBiYi54MikgLyAyLFxuICAgICAgeTogKGJiLnkxICsgYmIueTIpIC8gMlxuICAgIH07XG4gIH07XG4gIHZhciBnZXRDZW50ZXJPZmZzZXQgPSBmdW5jdGlvbiBnZXRDZW50ZXJPZmZzZXQoYmIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDogLWJiLncgLyAyLFxuICAgICAgeTogLWJiLmggLyAyXG4gICAgfTtcbiAgfTtcbiAgdmFyIGJhY2tncm91bmRUaW1lc3RhbXBIYXNDaGFuZ2VkID0gZnVuY3Rpb24gYmFja2dyb3VuZFRpbWVzdGFtcEhhc0NoYW5nZWQoZWxlKSB7XG4gICAgdmFyIF9wID0gZWxlWzBdLl9wcml2YXRlO1xuICAgIHZhciBzYW1lID0gX3Aub2xkQmFja2dyb3VuZFRpbWVzdGFtcCA9PT0gX3AuYmFja2dyb3VuZFRpbWVzdGFtcDtcbiAgICByZXR1cm4gIXNhbWU7XG4gIH07XG4gIHZhciBnZXRTdHlsZUtleSA9IGZ1bmN0aW9uIGdldFN0eWxlS2V5KGVsZSkge1xuICAgIHJldHVybiBlbGVbMF0uX3ByaXZhdGUubm9kZUtleTtcbiAgfTtcbiAgdmFyIGdldExhYmVsS2V5ID0gZnVuY3Rpb24gZ2V0TGFiZWxLZXkoZWxlKSB7XG4gICAgcmV0dXJuIGVsZVswXS5fcHJpdmF0ZS5sYWJlbFN0eWxlS2V5O1xuICB9O1xuICB2YXIgZ2V0U291cmNlTGFiZWxLZXkgPSBmdW5jdGlvbiBnZXRTb3VyY2VMYWJlbEtleShlbGUpIHtcbiAgICByZXR1cm4gZWxlWzBdLl9wcml2YXRlLnNvdXJjZUxhYmVsU3R5bGVLZXk7XG4gIH07XG4gIHZhciBnZXRUYXJnZXRMYWJlbEtleSA9IGZ1bmN0aW9uIGdldFRhcmdldExhYmVsS2V5KGVsZSkge1xuICAgIHJldHVybiBlbGVbMF0uX3ByaXZhdGUudGFyZ2V0TGFiZWxTdHlsZUtleTtcbiAgfTtcbiAgdmFyIGRyYXdFbGVtZW50ID0gZnVuY3Rpb24gZHJhd0VsZW1lbnQoY29udGV4dCwgZWxlLCBiYiwgc2NhbGVkTGFiZWxTaG93biwgdXNlRWxlT3BhY2l0eSkge1xuICAgIHJldHVybiByLmRyYXdFbGVtZW50KGNvbnRleHQsIGVsZSwgYmIsIGZhbHNlLCBmYWxzZSwgdXNlRWxlT3BhY2l0eSk7XG4gIH07XG4gIHZhciBkcmF3TGFiZWwgPSBmdW5jdGlvbiBkcmF3TGFiZWwoY29udGV4dCwgZWxlLCBiYiwgc2NhbGVkTGFiZWxTaG93biwgdXNlRWxlT3BhY2l0eSkge1xuICAgIHJldHVybiByLmRyYXdFbGVtZW50VGV4dChjb250ZXh0LCBlbGUsIGJiLCBzY2FsZWRMYWJlbFNob3duLCAnbWFpbicsIHVzZUVsZU9wYWNpdHkpO1xuICB9O1xuICB2YXIgZHJhd1NvdXJjZUxhYmVsID0gZnVuY3Rpb24gZHJhd1NvdXJjZUxhYmVsKGNvbnRleHQsIGVsZSwgYmIsIHNjYWxlZExhYmVsU2hvd24sIHVzZUVsZU9wYWNpdHkpIHtcbiAgICByZXR1cm4gci5kcmF3RWxlbWVudFRleHQoY29udGV4dCwgZWxlLCBiYiwgc2NhbGVkTGFiZWxTaG93biwgJ3NvdXJjZScsIHVzZUVsZU9wYWNpdHkpO1xuICB9O1xuICB2YXIgZHJhd1RhcmdldExhYmVsID0gZnVuY3Rpb24gZHJhd1RhcmdldExhYmVsKGNvbnRleHQsIGVsZSwgYmIsIHNjYWxlZExhYmVsU2hvd24sIHVzZUVsZU9wYWNpdHkpIHtcbiAgICByZXR1cm4gci5kcmF3RWxlbWVudFRleHQoY29udGV4dCwgZWxlLCBiYiwgc2NhbGVkTGFiZWxTaG93biwgJ3RhcmdldCcsIHVzZUVsZU9wYWNpdHkpO1xuICB9O1xuICB2YXIgZ2V0RWxlbWVudEJveCA9IGZ1bmN0aW9uIGdldEVsZW1lbnRCb3goZWxlKSB7XG4gICAgZWxlLmJvdW5kaW5nQm94KCk7XG4gICAgcmV0dXJuIGVsZVswXS5fcHJpdmF0ZS5ib2R5Qm91bmRzO1xuICB9O1xuICB2YXIgZ2V0TGFiZWxCb3ggPSBmdW5jdGlvbiBnZXRMYWJlbEJveChlbGUpIHtcbiAgICBlbGUuYm91bmRpbmdCb3goKTtcbiAgICByZXR1cm4gZWxlWzBdLl9wcml2YXRlLmxhYmVsQm91bmRzLm1haW4gfHwgZW1wdHlCYjtcbiAgfTtcbiAgdmFyIGdldFNvdXJjZUxhYmVsQm94ID0gZnVuY3Rpb24gZ2V0U291cmNlTGFiZWxCb3goZWxlKSB7XG4gICAgZWxlLmJvdW5kaW5nQm94KCk7XG4gICAgcmV0dXJuIGVsZVswXS5fcHJpdmF0ZS5sYWJlbEJvdW5kcy5zb3VyY2UgfHwgZW1wdHlCYjtcbiAgfTtcbiAgdmFyIGdldFRhcmdldExhYmVsQm94ID0gZnVuY3Rpb24gZ2V0VGFyZ2V0TGFiZWxCb3goZWxlKSB7XG4gICAgZWxlLmJvdW5kaW5nQm94KCk7XG4gICAgcmV0dXJuIGVsZVswXS5fcHJpdmF0ZS5sYWJlbEJvdW5kcy50YXJnZXQgfHwgZW1wdHlCYjtcbiAgfTtcbiAgdmFyIGlzTGFiZWxWaXNpYmxlQXRTY2FsZSA9IGZ1bmN0aW9uIGlzTGFiZWxWaXNpYmxlQXRTY2FsZShlbGUsIHNjYWxlZExhYmVsU2hvd24pIHtcbiAgICByZXR1cm4gc2NhbGVkTGFiZWxTaG93bjtcbiAgfTtcbiAgdmFyIGdldEVsZW1lbnRSb3RhdGlvblBvaW50ID0gZnVuY3Rpb24gZ2V0RWxlbWVudFJvdGF0aW9uUG9pbnQoZWxlKSB7XG4gICAgcmV0dXJuIGdldEJveENlbnRlcihnZXRFbGVtZW50Qm94KGVsZSkpO1xuICB9O1xuICB2YXIgYWRkVGV4dE1hcmdpbiA9IGZ1bmN0aW9uIGFkZFRleHRNYXJnaW4ocHJlZml4LCBwdCwgZWxlKSB7XG4gICAgdmFyIHByZSA9IHByZWZpeCA/IHByZWZpeCArICctJyA6ICcnO1xuICAgIHJldHVybiB7XG4gICAgICB4OiBwdC54ICsgZWxlLnBzdHlsZShwcmUgKyAndGV4dC1tYXJnaW4teCcpLnBmVmFsdWUsXG4gICAgICB5OiBwdC55ICsgZWxlLnBzdHlsZShwcmUgKyAndGV4dC1tYXJnaW4teScpLnBmVmFsdWVcbiAgICB9O1xuICB9O1xuICB2YXIgZ2V0UnNQdCA9IGZ1bmN0aW9uIGdldFJzUHQoZWxlLCB4LCB5KSB7XG4gICAgdmFyIHJzID0gZWxlWzBdLl9wcml2YXRlLnJzY3JhdGNoO1xuICAgIHJldHVybiB7XG4gICAgICB4OiByc1t4XSxcbiAgICAgIHk6IHJzW3ldXG4gICAgfTtcbiAgfTtcbiAgdmFyIGdldExhYmVsUm90YXRpb25Qb2ludCA9IGZ1bmN0aW9uIGdldExhYmVsUm90YXRpb25Qb2ludChlbGUpIHtcbiAgICByZXR1cm4gYWRkVGV4dE1hcmdpbignJywgZ2V0UnNQdChlbGUsICdsYWJlbFgnLCAnbGFiZWxZJyksIGVsZSk7XG4gIH07XG4gIHZhciBnZXRTb3VyY2VMYWJlbFJvdGF0aW9uUG9pbnQgPSBmdW5jdGlvbiBnZXRTb3VyY2VMYWJlbFJvdGF0aW9uUG9pbnQoZWxlKSB7XG4gICAgcmV0dXJuIGFkZFRleHRNYXJnaW4oJ3NvdXJjZScsIGdldFJzUHQoZWxlLCAnc291cmNlTGFiZWxYJywgJ3NvdXJjZUxhYmVsWScpLCBlbGUpO1xuICB9O1xuICB2YXIgZ2V0VGFyZ2V0TGFiZWxSb3RhdGlvblBvaW50ID0gZnVuY3Rpb24gZ2V0VGFyZ2V0TGFiZWxSb3RhdGlvblBvaW50KGVsZSkge1xuICAgIHJldHVybiBhZGRUZXh0TWFyZ2luKCd0YXJnZXQnLCBnZXRSc1B0KGVsZSwgJ3RhcmdldExhYmVsWCcsICd0YXJnZXRMYWJlbFknKSwgZWxlKTtcbiAgfTtcbiAgdmFyIGdldEVsZW1lbnRSb3RhdGlvbk9mZnNldCA9IGZ1bmN0aW9uIGdldEVsZW1lbnRSb3RhdGlvbk9mZnNldChlbGUpIHtcbiAgICByZXR1cm4gZ2V0Q2VudGVyT2Zmc2V0KGdldEVsZW1lbnRCb3goZWxlKSk7XG4gIH07XG4gIHZhciBnZXRTb3VyY2VMYWJlbFJvdGF0aW9uT2Zmc2V0ID0gZnVuY3Rpb24gZ2V0U291cmNlTGFiZWxSb3RhdGlvbk9mZnNldChlbGUpIHtcbiAgICByZXR1cm4gZ2V0Q2VudGVyT2Zmc2V0KGdldFNvdXJjZUxhYmVsQm94KGVsZSkpO1xuICB9O1xuICB2YXIgZ2V0VGFyZ2V0TGFiZWxSb3RhdGlvbk9mZnNldCA9IGZ1bmN0aW9uIGdldFRhcmdldExhYmVsUm90YXRpb25PZmZzZXQoZWxlKSB7XG4gICAgcmV0dXJuIGdldENlbnRlck9mZnNldChnZXRUYXJnZXRMYWJlbEJveChlbGUpKTtcbiAgfTtcbiAgdmFyIGdldExhYmVsUm90YXRpb25PZmZzZXQgPSBmdW5jdGlvbiBnZXRMYWJlbFJvdGF0aW9uT2Zmc2V0KGVsZSkge1xuICAgIHZhciBiYiA9IGdldExhYmVsQm94KGVsZSk7XG4gICAgdmFyIHAgPSBnZXRDZW50ZXJPZmZzZXQoZ2V0TGFiZWxCb3goZWxlKSk7XG4gICAgaWYgKGVsZS5pc05vZGUoKSkge1xuICAgICAgc3dpdGNoIChlbGUucHN0eWxlKCd0ZXh0LWhhbGlnbicpLnZhbHVlKSB7XG4gICAgICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgICAgIHAueCA9IC1iYi53IC0gKGJiLmxlZnRQYWQgfHwgMCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgICBwLnggPSAtKGJiLnJpZ2h0UGFkIHx8IDApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgc3dpdGNoIChlbGUucHN0eWxlKCd0ZXh0LXZhbGlnbicpLnZhbHVlKSB7XG4gICAgICAgIGNhc2UgJ3RvcCc6XG4gICAgICAgICAgcC55ID0gLWJiLmggLSAoYmIudG9wUGFkIHx8IDApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdib3R0b20nOlxuICAgICAgICAgIHAueSA9IC0oYmIuYm90UGFkIHx8IDApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcDtcbiAgfTtcbiAgdmFyIGVsZVR4ckNhY2hlID0gci5kYXRhLmVsZVR4ckNhY2hlID0gbmV3IEVsZW1lbnRUZXh0dXJlQ2FjaGUociwge1xuICAgIGdldEtleTogZ2V0U3R5bGVLZXksXG4gICAgZG9lc0VsZUludmFsaWRhdGVLZXk6IGJhY2tncm91bmRUaW1lc3RhbXBIYXNDaGFuZ2VkLFxuICAgIGRyYXdFbGVtZW50OiBkcmF3RWxlbWVudCxcbiAgICBnZXRCb3VuZGluZ0JveDogZ2V0RWxlbWVudEJveCxcbiAgICBnZXRSb3RhdGlvblBvaW50OiBnZXRFbGVtZW50Um90YXRpb25Qb2ludCxcbiAgICBnZXRSb3RhdGlvbk9mZnNldDogZ2V0RWxlbWVudFJvdGF0aW9uT2Zmc2V0LFxuICAgIGFsbG93RWRnZVR4ckNhY2hpbmc6IGZhbHNlLFxuICAgIGFsbG93UGFyZW50VHhyQ2FjaGluZzogZmFsc2VcbiAgfSk7XG4gIHZhciBsYmxUeHJDYWNoZSA9IHIuZGF0YS5sYmxUeHJDYWNoZSA9IG5ldyBFbGVtZW50VGV4dHVyZUNhY2hlKHIsIHtcbiAgICBnZXRLZXk6IGdldExhYmVsS2V5LFxuICAgIGRyYXdFbGVtZW50OiBkcmF3TGFiZWwsXG4gICAgZ2V0Qm91bmRpbmdCb3g6IGdldExhYmVsQm94LFxuICAgIGdldFJvdGF0aW9uUG9pbnQ6IGdldExhYmVsUm90YXRpb25Qb2ludCxcbiAgICBnZXRSb3RhdGlvbk9mZnNldDogZ2V0TGFiZWxSb3RhdGlvbk9mZnNldCxcbiAgICBpc1Zpc2libGU6IGlzTGFiZWxWaXNpYmxlQXRTY2FsZVxuICB9KTtcbiAgdmFyIHNsYlR4ckNhY2hlID0gci5kYXRhLnNsYlR4ckNhY2hlID0gbmV3IEVsZW1lbnRUZXh0dXJlQ2FjaGUociwge1xuICAgIGdldEtleTogZ2V0U291cmNlTGFiZWxLZXksXG4gICAgZHJhd0VsZW1lbnQ6IGRyYXdTb3VyY2VMYWJlbCxcbiAgICBnZXRCb3VuZGluZ0JveDogZ2V0U291cmNlTGFiZWxCb3gsXG4gICAgZ2V0Um90YXRpb25Qb2ludDogZ2V0U291cmNlTGFiZWxSb3RhdGlvblBvaW50LFxuICAgIGdldFJvdGF0aW9uT2Zmc2V0OiBnZXRTb3VyY2VMYWJlbFJvdGF0aW9uT2Zmc2V0LFxuICAgIGlzVmlzaWJsZTogaXNMYWJlbFZpc2libGVBdFNjYWxlXG4gIH0pO1xuICB2YXIgdGxiVHhyQ2FjaGUgPSByLmRhdGEudGxiVHhyQ2FjaGUgPSBuZXcgRWxlbWVudFRleHR1cmVDYWNoZShyLCB7XG4gICAgZ2V0S2V5OiBnZXRUYXJnZXRMYWJlbEtleSxcbiAgICBkcmF3RWxlbWVudDogZHJhd1RhcmdldExhYmVsLFxuICAgIGdldEJvdW5kaW5nQm94OiBnZXRUYXJnZXRMYWJlbEJveCxcbiAgICBnZXRSb3RhdGlvblBvaW50OiBnZXRUYXJnZXRMYWJlbFJvdGF0aW9uUG9pbnQsXG4gICAgZ2V0Um90YXRpb25PZmZzZXQ6IGdldFRhcmdldExhYmVsUm90YXRpb25PZmZzZXQsXG4gICAgaXNWaXNpYmxlOiBpc0xhYmVsVmlzaWJsZUF0U2NhbGVcbiAgfSk7XG4gIHZhciBseXJUeHJDYWNoZSA9IHIuZGF0YS5seXJUeHJDYWNoZSA9IG5ldyBMYXllcmVkVGV4dHVyZUNhY2hlKHIpO1xuICByLm9uVXBkYXRlRWxlQ2FsY3MoZnVuY3Rpb24gaW52YWxpZGF0ZVRleHR1cmVDYWNoZXMod2lsbERyYXcsIGVsZXMpIHtcbiAgICAvLyBlYWNoIGNhY2hlIHNob3VsZCBjaGVjayBmb3Igc3ViLWtleSBkaWZmIHRvIHNlZSB0aGF0IHRoZSB1cGRhdGUgYWZmZWN0cyB0aGF0IGNhY2hlIHBhcnRpY3VsYXJseVxuICAgIGVsZVR4ckNhY2hlLmludmFsaWRhdGVFbGVtZW50cyhlbGVzKTtcbiAgICBsYmxUeHJDYWNoZS5pbnZhbGlkYXRlRWxlbWVudHMoZWxlcyk7XG4gICAgc2xiVHhyQ2FjaGUuaW52YWxpZGF0ZUVsZW1lbnRzKGVsZXMpO1xuICAgIHRsYlR4ckNhY2hlLmludmFsaWRhdGVFbGVtZW50cyhlbGVzKTtcblxuICAgIC8vIGFueSBjaGFuZ2UgaW52YWxpZGF0ZXMgdGhlIGxheWVyc1xuICAgIGx5clR4ckNhY2hlLmludmFsaWRhdGVFbGVtZW50cyhlbGVzKTtcblxuICAgIC8vIHVwZGF0ZSB0aGUgb2xkIGJnIHRpbWVzdGFtcCBzbyBkaWZmcyBjYW4gYmUgZG9uZSBpbiB0aGUgZWxlIHR4ciBjYWNoZXNcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgZWxlcy5sZW5ndGg7IF9pKyspIHtcbiAgICAgIHZhciBfcCA9IGVsZXNbX2ldLl9wcml2YXRlO1xuICAgICAgX3Aub2xkQmFja2dyb3VuZFRpbWVzdGFtcCA9IF9wLmJhY2tncm91bmRUaW1lc3RhbXA7XG4gICAgfVxuICB9KTtcbiAgdmFyIHJlZmluZUluTGF5ZXJzID0gZnVuY3Rpb24gcmVmaW5lSW5MYXllcnMocmVxcykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVxcy5sZW5ndGg7IGkrKykge1xuICAgICAgbHlyVHhyQ2FjaGUuZW5xdWV1ZUVsZW1lbnRSZWZpbmVtZW50KHJlcXNbaV0uZWxlKTtcbiAgICB9XG4gIH07XG4gIGVsZVR4ckNhY2hlLm9uRGVxdWV1ZShyZWZpbmVJbkxheWVycyk7XG4gIGxibFR4ckNhY2hlLm9uRGVxdWV1ZShyZWZpbmVJbkxheWVycyk7XG4gIHNsYlR4ckNhY2hlLm9uRGVxdWV1ZShyZWZpbmVJbkxheWVycyk7XG4gIHRsYlR4ckNhY2hlLm9uRGVxdWV1ZShyZWZpbmVJbkxheWVycyk7XG59XG5DUnAucmVkcmF3SGludCA9IGZ1bmN0aW9uIChncm91cCwgYm9vbCkge1xuICB2YXIgciA9IHRoaXM7XG4gIHN3aXRjaCAoZ3JvdXApIHtcbiAgICBjYXNlICdlbGVzJzpcbiAgICAgIHIuZGF0YS5jYW52YXNOZWVkc1JlZHJhd1tDUnAuTk9ERV0gPSBib29sO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnZHJhZyc6XG4gICAgICByLmRhdGEuY2FudmFzTmVlZHNSZWRyYXdbQ1JwLkRSQUddID0gYm9vbDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgICByLmRhdGEuY2FudmFzTmVlZHNSZWRyYXdbQ1JwLlNFTEVDVF9CT1hdID0gYm9vbDtcbiAgICAgIGJyZWFrO1xuICB9XG59O1xuXG4vLyB3aGV0aGVyIHRvIHVzZSBQYXRoMkQgY2FjaGluZyBmb3IgZHJhd2luZ1xudmFyIHBhdGhzSW1wbGQgPSB0eXBlb2YgUGF0aDJEICE9PSAndW5kZWZpbmVkJztcbkNScC5wYXRoMmRFbmFibGVkID0gZnVuY3Rpb24gKG9uKSB7XG4gIGlmIChvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHRoaXMucGF0aHNFbmFibGVkO1xuICB9XG4gIHRoaXMucGF0aHNFbmFibGVkID0gb24gPyB0cnVlIDogZmFsc2U7XG59O1xuQ1JwLnVzZVBhdGhzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gcGF0aHNJbXBsZCAmJiB0aGlzLnBhdGhzRW5hYmxlZDtcbn07XG5DUnAuc2V0SW1nU21vb3RoaW5nID0gZnVuY3Rpb24gKGNvbnRleHQsIGJvb2wpIHtcbiAgaWYgKGNvbnRleHQuaW1hZ2VTbW9vdGhpbmdFbmFibGVkICE9IG51bGwpIHtcbiAgICBjb250ZXh0LmltYWdlU21vb3RoaW5nRW5hYmxlZCA9IGJvb2w7XG4gIH0gZWxzZSB7XG4gICAgY29udGV4dC53ZWJraXRJbWFnZVNtb290aGluZ0VuYWJsZWQgPSBib29sO1xuICAgIGNvbnRleHQubW96SW1hZ2VTbW9vdGhpbmdFbmFibGVkID0gYm9vbDtcbiAgICBjb250ZXh0Lm1zSW1hZ2VTbW9vdGhpbmdFbmFibGVkID0gYm9vbDtcbiAgfVxufTtcbkNScC5nZXRJbWdTbW9vdGhpbmcgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICBpZiAoY29udGV4dC5pbWFnZVNtb290aGluZ0VuYWJsZWQgIT0gbnVsbCkge1xuICAgIHJldHVybiBjb250ZXh0LmltYWdlU21vb3RoaW5nRW5hYmxlZDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gY29udGV4dC53ZWJraXRJbWFnZVNtb290aGluZ0VuYWJsZWQgfHwgY29udGV4dC5tb3pJbWFnZVNtb290aGluZ0VuYWJsZWQgfHwgY29udGV4dC5tc0ltYWdlU21vb3RoaW5nRW5hYmxlZDtcbiAgfVxufTtcbkNScC5tYWtlT2Zmc2NyZWVuQ2FudmFzID0gZnVuY3Rpb24gKHdpZHRoLCBoZWlnaHQpIHtcbiAgdmFyIGNhbnZhcztcbiAgaWYgKCh0eXBlb2YgT2Zmc2NyZWVuQ2FudmFzID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2YoT2Zmc2NyZWVuQ2FudmFzKSkgIT09IChcInVuZGVmaW5lZFwiICkpIHtcbiAgICBjYW52YXMgPSBuZXcgT2Zmc2NyZWVuQ2FudmFzKHdpZHRoLCBoZWlnaHQpO1xuICB9IGVsc2Uge1xuICAgIHZhciBjb250YWluZXJXaW5kb3cgPSB0aGlzLmN5LndpbmRvdygpO1xuICAgIHZhciBkb2N1bWVudCA9IGNvbnRhaW5lcldpbmRvdy5kb2N1bWVudDtcbiAgICBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuICAgIGNhbnZhcy53aWR0aCA9IHdpZHRoO1xuICAgIGNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG4gIH1cbiAgcmV0dXJuIGNhbnZhcztcbn07XG5bQ1JwJGEsIENScCQ5LCBDUnAkOCwgQ1JwJDcsIENScCQ2LCBDUnAkNSwgQ1JwJDQsIENScCQzLCBDUnAkMiwgQ1JwJDFdLmZvckVhY2goZnVuY3Rpb24gKHByb3BzKSB7XG4gIGV4dGVuZChDUnAsIHByb3BzKTtcbn0pO1xuXG52YXIgcmVuZGVyZXIgPSBbe1xuICBuYW1lOiAnbnVsbCcsXG4gIGltcGw6IE51bGxSZW5kZXJlclxufSwge1xuICBuYW1lOiAnYmFzZScsXG4gIGltcGw6IEJSXG59LCB7XG4gIG5hbWU6ICdjYW52YXMnLFxuICBpbXBsOiBDUlxufV07XG5cbnZhciBpbmNFeHRzID0gW3tcbiAgdHlwZTogJ2xheW91dCcsXG4gIGV4dGVuc2lvbnM6IGxheW91dFxufSwge1xuICB0eXBlOiAncmVuZGVyZXInLFxuICBleHRlbnNpb25zOiByZW5kZXJlclxufV07XG5cbi8vIHJlZ2lzdGVyZWQgZXh0ZW5zaW9ucyB0byBjeXRvc2NhcGUsIGluZGV4ZWQgYnkgbmFtZVxudmFyIGV4dGVuc2lvbnMgPSB7fTtcblxuLy8gcmVnaXN0ZXJlZCBtb2R1bGVzIGZvciBleHRlbnNpb25zLCBpbmRleGVkIGJ5IG5hbWVcbnZhciBtb2R1bGVzID0ge307XG5mdW5jdGlvbiBzZXRFeHRlbnNpb24odHlwZSwgbmFtZSwgcmVnaXN0cmFudCkge1xuICB2YXIgZXh0ID0gcmVnaXN0cmFudDtcbiAgdmFyIG92ZXJyaWRlRXJyID0gZnVuY3Rpb24gb3ZlcnJpZGVFcnIoZmllbGQpIHtcbiAgICB3YXJuKCdDYW4gbm90IHJlZ2lzdGVyIGAnICsgbmFtZSArICdgIGZvciBgJyArIHR5cGUgKyAnYCBzaW5jZSBgJyArIGZpZWxkICsgJ2AgYWxyZWFkeSBleGlzdHMgaW4gdGhlIHByb3RvdHlwZSBhbmQgY2FuIG5vdCBiZSBvdmVycmlkZGVuJyk7XG4gIH07XG4gIGlmICh0eXBlID09PSAnY29yZScpIHtcbiAgICBpZiAoQ29yZS5wcm90b3R5cGVbbmFtZV0pIHtcbiAgICAgIHJldHVybiBvdmVycmlkZUVycihuYW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgQ29yZS5wcm90b3R5cGVbbmFtZV0gPSByZWdpc3RyYW50O1xuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlID09PSAnY29sbGVjdGlvbicpIHtcbiAgICBpZiAoQ29sbGVjdGlvbi5wcm90b3R5cGVbbmFtZV0pIHtcbiAgICAgIHJldHVybiBvdmVycmlkZUVycihuYW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgQ29sbGVjdGlvbi5wcm90b3R5cGVbbmFtZV0gPSByZWdpc3RyYW50O1xuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlID09PSAnbGF5b3V0Jykge1xuICAgIC8vIGZpbGwgaW4gbWlzc2luZyBsYXlvdXQgZnVuY3Rpb25zIGluIHRoZSBwcm90b3R5cGVcblxuICAgIHZhciBMYXlvdXQgPSBmdW5jdGlvbiBMYXlvdXQob3B0aW9ucykge1xuICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgIHJlZ2lzdHJhbnQuY2FsbCh0aGlzLCBvcHRpb25zKTtcblxuICAgICAgLy8gbWFrZSBzdXJlIGxheW91dCBoYXMgX3ByaXZhdGUgZm9yIHVzZSB3LyBzdGQgYXBpcyBsaWtlIC5vbigpXG4gICAgICBpZiAoIXBsYWluT2JqZWN0KHRoaXMuX3ByaXZhdGUpKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGUgPSB7fTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3ByaXZhdGUuY3kgPSBvcHRpb25zLmN5O1xuICAgICAgdGhpcy5fcHJpdmF0ZS5saXN0ZW5lcnMgPSBbXTtcbiAgICAgIHRoaXMuY3JlYXRlRW1pdHRlcigpO1xuICAgIH07XG4gICAgdmFyIGxheW91dFByb3RvID0gTGF5b3V0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUocmVnaXN0cmFudC5wcm90b3R5cGUpO1xuICAgIHZhciBvcHRMYXlvdXRGbnMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9wdExheW91dEZucy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGZuTmFtZSA9IG9wdExheW91dEZuc1tpXTtcbiAgICAgIGxheW91dFByb3RvW2ZuTmFtZV0gPSBsYXlvdXRQcm90b1tmbk5hbWVdIHx8IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIGVpdGhlciAuc3RhcnQoKSBvciAucnVuKCkgaXMgZGVmaW5lZCwgc28gYXV0b2dlbiB0aGUgb3RoZXJcbiAgICBpZiAobGF5b3V0UHJvdG8uc3RhcnQgJiYgIWxheW91dFByb3RvLnJ1bikge1xuICAgICAgbGF5b3V0UHJvdG8ucnVuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnN0YXJ0KCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKCFsYXlvdXRQcm90by5zdGFydCAmJiBsYXlvdXRQcm90by5ydW4pIHtcbiAgICAgIGxheW91dFByb3RvLnN0YXJ0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnJ1bigpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH07XG4gICAgfVxuICAgIHZhciByZWdTdG9wID0gcmVnaXN0cmFudC5wcm90b3R5cGUuc3RvcDtcbiAgICBsYXlvdXRQcm90by5zdG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIG9wdHMgPSB0aGlzLm9wdGlvbnM7XG4gICAgICBpZiAob3B0cyAmJiBvcHRzLmFuaW1hdGUpIHtcbiAgICAgICAgdmFyIGFuaXMgPSB0aGlzLmFuaW1hdGlvbnM7XG4gICAgICAgIGlmIChhbmlzKSB7XG4gICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFuaXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBhbmlzW19pXS5zdG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocmVnU3RvcCkge1xuICAgICAgICByZWdTdG9wLmNhbGwodGhpcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmVtaXQoJ2xheW91dHN0b3AnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgaWYgKCFsYXlvdXRQcm90by5kZXN0cm95KSB7XG4gICAgICBsYXlvdXRQcm90by5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH07XG4gICAgfVxuICAgIGxheW91dFByb3RvLmN5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUuY3k7XG4gICAgfTtcbiAgICB2YXIgZ2V0Q3kgPSBmdW5jdGlvbiBnZXRDeShsYXlvdXQpIHtcbiAgICAgIHJldHVybiBsYXlvdXQuX3ByaXZhdGUuY3k7XG4gICAgfTtcbiAgICB2YXIgZW1pdHRlck9wdHMgPSB7XG4gICAgICBhZGRFdmVudEZpZWxkczogZnVuY3Rpb24gYWRkRXZlbnRGaWVsZHMobGF5b3V0LCBldnQpIHtcbiAgICAgICAgZXZ0LmxheW91dCA9IGxheW91dDtcbiAgICAgICAgZXZ0LmN5ID0gZ2V0Q3kobGF5b3V0KTtcbiAgICAgICAgZXZ0LnRhcmdldCA9IGxheW91dDtcbiAgICAgIH0sXG4gICAgICBidWJibGU6IGZ1bmN0aW9uIGJ1YmJsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9LFxuICAgICAgcGFyZW50OiBmdW5jdGlvbiBwYXJlbnQobGF5b3V0KSB7XG4gICAgICAgIHJldHVybiBnZXRDeShsYXlvdXQpO1xuICAgICAgfVxuICAgIH07XG4gICAgZXh0ZW5kKGxheW91dFByb3RvLCB7XG4gICAgICBjcmVhdGVFbWl0dGVyOiBmdW5jdGlvbiBjcmVhdGVFbWl0dGVyKCkge1xuICAgICAgICB0aGlzLl9wcml2YXRlLmVtaXR0ZXIgPSBuZXcgRW1pdHRlcihlbWl0dGVyT3B0cywgdGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcbiAgICAgIGVtaXR0ZXI6IGZ1bmN0aW9uIGVtaXR0ZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlLmVtaXR0ZXI7XG4gICAgICB9LFxuICAgICAgb246IGZ1bmN0aW9uIG9uKGV2dCwgY2IpIHtcbiAgICAgICAgdGhpcy5lbWl0dGVyKCkub24oZXZ0LCBjYik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcbiAgICAgIG9uZTogZnVuY3Rpb24gb25lKGV2dCwgY2IpIHtcbiAgICAgICAgdGhpcy5lbWl0dGVyKCkub25lKGV2dCwgY2IpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG4gICAgICBvbmNlOiBmdW5jdGlvbiBvbmNlKGV2dCwgY2IpIHtcbiAgICAgICAgdGhpcy5lbWl0dGVyKCkub25lKGV2dCwgY2IpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG4gICAgICByZW1vdmVMaXN0ZW5lcjogZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIoZXZ0LCBjYikge1xuICAgICAgICB0aGlzLmVtaXR0ZXIoKS5yZW1vdmVMaXN0ZW5lcihldnQsIGNiKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuICAgICAgcmVtb3ZlQWxsTGlzdGVuZXJzOiBmdW5jdGlvbiByZW1vdmVBbGxMaXN0ZW5lcnMoKSB7XG4gICAgICAgIHRoaXMuZW1pdHRlcigpLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG4gICAgICBlbWl0OiBmdW5jdGlvbiBlbWl0KGV2dCwgcGFyYW1zKSB7XG4gICAgICAgIHRoaXMuZW1pdHRlcigpLmVtaXQoZXZ0LCBwYXJhbXMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICB9KTtcbiAgICBkZWZpbmUuZXZlbnRBbGlhc2VzT24obGF5b3V0UHJvdG8pO1xuICAgIGV4dCA9IExheW91dDsgLy8gcmVwbGFjZSB3aXRoIG91ciB3cmFwcGVkIGxheW91dFxuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdyZW5kZXJlcicgJiYgbmFtZSAhPT0gJ251bGwnICYmIG5hbWUgIT09ICdiYXNlJykge1xuICAgIC8vIHVzZXIgcmVnaXN0ZXJlZCByZW5kZXJlcnMgaW5oZXJpdCBmcm9tIGJhc2VcblxuICAgIHZhciBCYXNlUmVuZGVyZXIgPSBnZXRFeHRlbnNpb24oJ3JlbmRlcmVyJywgJ2Jhc2UnKTtcbiAgICB2YXIgYlByb3RvID0gQmFzZVJlbmRlcmVyLnByb3RvdHlwZTtcbiAgICB2YXIgUmVnaXN0cmFudFJlbmRlcmVyID0gcmVnaXN0cmFudDtcbiAgICB2YXIgclByb3RvID0gcmVnaXN0cmFudC5wcm90b3R5cGU7XG4gICAgdmFyIFJlbmRlcmVyID0gZnVuY3Rpb24gUmVuZGVyZXIoKSB7XG4gICAgICBCYXNlUmVuZGVyZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIFJlZ2lzdHJhbnRSZW5kZXJlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG4gICAgdmFyIHByb3RvID0gUmVuZGVyZXIucHJvdG90eXBlO1xuICAgIGZvciAodmFyIHBOYW1lIGluIGJQcm90bykge1xuICAgICAgdmFyIHBWYWwgPSBiUHJvdG9bcE5hbWVdO1xuICAgICAgdmFyIGV4aXN0c0luUiA9IHJQcm90b1twTmFtZV0gIT0gbnVsbDtcbiAgICAgIGlmIChleGlzdHNJblIpIHtcbiAgICAgICAgcmV0dXJuIG92ZXJyaWRlRXJyKHBOYW1lKTtcbiAgICAgIH1cbiAgICAgIHByb3RvW3BOYW1lXSA9IHBWYWw7IC8vIHRha2UgaW1wbCBmcm9tIGJhc2VcbiAgICB9XG5cbiAgICBmb3IgKHZhciBfcE5hbWUgaW4gclByb3RvKSB7XG4gICAgICBwcm90b1tfcE5hbWVdID0gclByb3RvW19wTmFtZV07IC8vIHRha2UgaW1wbCBmcm9tIHJlZ2lzdHJhbnRcbiAgICB9XG5cbiAgICBiUHJvdG8uY2xpZW50RnVuY3Rpb25zLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIHByb3RvW25hbWVdID0gcHJvdG9bbmFtZV0gfHwgZnVuY3Rpb24gKCkge1xuICAgICAgICBlcnJvcignUmVuZGVyZXIgZG9lcyBub3QgaW1wbGVtZW50IGByZW5kZXJlci4nICsgbmFtZSArICcoKWAgb24gaXRzIHByb3RvdHlwZScpO1xuICAgICAgfTtcbiAgICB9KTtcbiAgICBleHQgPSBSZW5kZXJlcjtcbiAgfSBlbHNlIGlmICh0eXBlID09PSAnX19wcm90b19fJyB8fCB0eXBlID09PSAnY29uc3RydWN0b3InIHx8IHR5cGUgPT09ICdwcm90b3R5cGUnKSB7XG4gICAgLy8gdG8gYXZvaWQgcG90ZW50aWFsIHByb3RvdHlwZSBwb2xsdXRpb25cbiAgICByZXR1cm4gZXJyb3IodHlwZSArICcgaXMgYW4gaWxsZWdhbCB0eXBlIHRvIGJlIHJlZ2lzdGVyZWQsIHBvc3NpYmx5IGxlYWQgdG8gcHJvdG90eXBlIHBvbGx1dGlvbnMnKTtcbiAgfVxuICByZXR1cm4gc2V0TWFwKHtcbiAgICBtYXA6IGV4dGVuc2lvbnMsXG4gICAga2V5czogW3R5cGUsIG5hbWVdLFxuICAgIHZhbHVlOiBleHRcbiAgfSk7XG59XG5mdW5jdGlvbiBnZXRFeHRlbnNpb24odHlwZSwgbmFtZSkge1xuICByZXR1cm4gZ2V0TWFwKHtcbiAgICBtYXA6IGV4dGVuc2lvbnMsXG4gICAga2V5czogW3R5cGUsIG5hbWVdXG4gIH0pO1xufVxuZnVuY3Rpb24gc2V0TW9kdWxlKHR5cGUsIG5hbWUsIG1vZHVsZVR5cGUsIG1vZHVsZU5hbWUsIHJlZ2lzdHJhbnQpIHtcbiAgcmV0dXJuIHNldE1hcCh7XG4gICAgbWFwOiBtb2R1bGVzLFxuICAgIGtleXM6IFt0eXBlLCBuYW1lLCBtb2R1bGVUeXBlLCBtb2R1bGVOYW1lXSxcbiAgICB2YWx1ZTogcmVnaXN0cmFudFxuICB9KTtcbn1cbmZ1bmN0aW9uIGdldE1vZHVsZSh0eXBlLCBuYW1lLCBtb2R1bGVUeXBlLCBtb2R1bGVOYW1lKSB7XG4gIHJldHVybiBnZXRNYXAoe1xuICAgIG1hcDogbW9kdWxlcyxcbiAgICBrZXlzOiBbdHlwZSwgbmFtZSwgbW9kdWxlVHlwZSwgbW9kdWxlTmFtZV1cbiAgfSk7XG59XG52YXIgZXh0ZW5zaW9uID0gZnVuY3Rpb24gZXh0ZW5zaW9uKCkge1xuICAvLyBlLmcuIGV4dGVuc2lvbigncmVuZGVyZXInLCAnc3ZnJylcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICByZXR1cm4gZ2V0RXh0ZW5zaW9uLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gIH1cblxuICAvLyBlLmcuIGV4dGVuc2lvbigncmVuZGVyZXInLCAnc3ZnJywgeyAuLi4gfSlcbiAgZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgIHJldHVybiBzZXRFeHRlbnNpb24uYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgfVxuXG4gIC8vIGUuZy4gZXh0ZW5zaW9uKCdyZW5kZXJlcicsICdzdmcnLCAnbm9kZVNoYXBlJywgJ2VsbGlwc2UnKVxuICBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSA0KSB7XG4gICAgcmV0dXJuIGdldE1vZHVsZS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgLy8gZS5nLiBleHRlbnNpb24oJ3JlbmRlcmVyJywgJ3N2ZycsICdub2RlU2hhcGUnLCAnZWxsaXBzZScsIHsgLi4uIH0pXG4gIGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDUpIHtcbiAgICByZXR1cm4gc2V0TW9kdWxlLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gIH0gZWxzZSB7XG4gICAgZXJyb3IoJ0ludmFsaWQgZXh0ZW5zaW9uIGFjY2VzcyBzeW50YXgnKTtcbiAgfVxufTtcblxuLy8gYWxsb3dzIGEgY29yZSBpbnN0YW5jZSB0byBhY2Nlc3MgZXh0ZW5zaW9ucyBpbnRlcm5hbGx5XG5Db3JlLnByb3RvdHlwZS5leHRlbnNpb24gPSBleHRlbnNpb247XG5cbi8vIGluY2x1ZGVkIGV4dGVuc2lvbnNcbmluY0V4dHMuZm9yRWFjaChmdW5jdGlvbiAoZ3JvdXApIHtcbiAgZ3JvdXAuZXh0ZW5zaW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChleHQpIHtcbiAgICBzZXRFeHRlbnNpb24oZ3JvdXAudHlwZSwgZXh0Lm5hbWUsIGV4dC5pbXBsKTtcbiAgfSk7XG59KTtcblxuLy8gYSBkdW1teSBzdHlsZXNoZWV0IG9iamVjdCB0aGF0IGRvZXNuJ3QgbmVlZCBhIHJlZmVyZW5jZSB0byB0aGUgY29yZVxuLy8gKHVzZWZ1bCBmb3IgaW5pdClcbnZhciBTdHlsZXNoZWV0ID0gZnVuY3Rpb24gU3R5bGVzaGVldCgpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFN0eWxlc2hlZXQpKSB7XG4gICAgcmV0dXJuIG5ldyBTdHlsZXNoZWV0KCk7XG4gIH1cbiAgdGhpcy5sZW5ndGggPSAwO1xufTtcbnZhciBzaGVldGZuID0gU3R5bGVzaGVldC5wcm90b3R5cGU7XG5zaGVldGZuLmluc3RhbmNlU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gJ3N0eWxlc2hlZXQnO1xufTtcblxuLy8ganVzdCBzdG9yZSB0aGUgc2VsZWN0b3IgdG8gYmUgcGFyc2VkIGxhdGVyXG5zaGVldGZuLnNlbGVjdG9yID0gZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG4gIHZhciBpID0gdGhpcy5sZW5ndGgrKztcbiAgdGhpc1tpXSA9IHtcbiAgICBzZWxlY3Rvcjogc2VsZWN0b3IsXG4gICAgcHJvcGVydGllczogW11cbiAgfTtcbiAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG59O1xuXG4vLyBqdXN0IHN0b3JlIHRoZSBwcm9wZXJ0eSB0byBiZSBwYXJzZWQgbGF0ZXJcbnNoZWV0Zm4uY3NzID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gIHZhciBpID0gdGhpcy5sZW5ndGggLSAxO1xuICBpZiAoc3RyaW5nKG5hbWUpKSB7XG4gICAgdGhpc1tpXS5wcm9wZXJ0aWVzLnB1c2goe1xuICAgICAgbmFtZTogbmFtZSxcbiAgICAgIHZhbHVlOiB2YWx1ZVxuICAgIH0pO1xuICB9IGVsc2UgaWYgKHBsYWluT2JqZWN0KG5hbWUpKSB7XG4gICAgdmFyIG1hcCA9IG5hbWU7XG4gICAgdmFyIHByb3BOYW1lcyA9IE9iamVjdC5rZXlzKG1hcCk7XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBwcm9wTmFtZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgIHZhciBrZXkgPSBwcm9wTmFtZXNbal07XG4gICAgICB2YXIgbWFwVmFsID0gbWFwW2tleV07XG4gICAgICBpZiAobWFwVmFsID09IG51bGwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB2YXIgcHJvcCA9IFN0eWxlLnByb3BlcnRpZXNba2V5XSB8fCBTdHlsZS5wcm9wZXJ0aWVzW2Rhc2gyY2FtZWwoa2V5KV07XG4gICAgICBpZiAocHJvcCA9PSBudWxsKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdmFyIF9uYW1lID0gcHJvcC5uYW1lO1xuICAgICAgdmFyIF92YWx1ZSA9IG1hcFZhbDtcbiAgICAgIHRoaXNbaV0ucHJvcGVydGllcy5wdXNoKHtcbiAgICAgICAgbmFtZTogX25hbWUsXG4gICAgICAgIHZhbHVlOiBfdmFsdWVcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbn07XG5cbnNoZWV0Zm4uc3R5bGUgPSBzaGVldGZuLmNzcztcblxuLy8gZ2VuZXJhdGUgYSByZWFsIHN0eWxlIG9iamVjdCBmcm9tIHRoZSBkdW1teSBzdHlsZXNoZWV0XG5zaGVldGZuLmdlbmVyYXRlU3R5bGUgPSBmdW5jdGlvbiAoY3kpIHtcbiAgdmFyIHN0eWxlID0gbmV3IFN0eWxlKGN5KTtcbiAgcmV0dXJuIHRoaXMuYXBwZW5kVG9TdHlsZShzdHlsZSk7XG59O1xuXG4vLyBhcHBlbmQgYSBkdW1teSBzdHlsZXNoZWV0IG9iamVjdCBvbiBhIHJlYWwgc3R5bGUgb2JqZWN0XG5zaGVldGZuLmFwcGVuZFRvU3R5bGUgPSBmdW5jdGlvbiAoc3R5bGUpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGNvbnRleHQgPSB0aGlzW2ldO1xuICAgIHZhciBzZWxlY3RvciA9IGNvbnRleHQuc2VsZWN0b3I7XG4gICAgdmFyIHByb3BzID0gY29udGV4dC5wcm9wZXJ0aWVzO1xuICAgIHN0eWxlLnNlbGVjdG9yKHNlbGVjdG9yKTsgLy8gYXBwbHkgc2VsZWN0b3JcblxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgcHJvcHMubGVuZ3RoOyBqKyspIHtcbiAgICAgIHZhciBwcm9wID0gcHJvcHNbal07XG4gICAgICBzdHlsZS5jc3MocHJvcC5uYW1lLCBwcm9wLnZhbHVlKTsgLy8gYXBwbHkgcHJvcGVydHlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3R5bGU7XG59O1xuXG52YXIgdmVyc2lvbiA9IFwiMy4zMC40XCI7XG5cbnZhciBjeXRvc2NhcGUgPSBmdW5jdGlvbiBjeXRvc2NhcGUob3B0aW9ucykge1xuICAvLyBpZiBubyBvcHRpb25zIHNwZWNpZmllZCwgdXNlIGRlZmF1bHRcbiAgaWYgKG9wdGlvbnMgPT09IHVuZGVmaW5lZCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuXG4gIC8vIGNyZWF0ZSBpbnN0YW5jZVxuICBpZiAocGxhaW5PYmplY3Qob3B0aW9ucykpIHtcbiAgICByZXR1cm4gbmV3IENvcmUob3B0aW9ucyk7XG4gIH1cblxuICAvLyBhbGxvdyBmb3IgcmVnaXN0cmF0aW9uIG9mIGV4dGVuc2lvbnNcbiAgZWxzZSBpZiAoc3RyaW5nKG9wdGlvbnMpKSB7XG4gICAgcmV0dXJuIGV4dGVuc2lvbi5hcHBseShleHRlbnNpb24sIGFyZ3VtZW50cyk7XG4gIH1cbn07XG5cbi8vIGUuZy4gY3l0b3NjYXBlLnVzZSggcmVxdWlyZSgnY3l0b3NjYXBlLWZvbycpLCBiYXIgKVxuY3l0b3NjYXBlLnVzZSA9IGZ1bmN0aW9uIChleHQpIHtcbiAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpOyAvLyBhcmdzIHRvIHBhc3MgdG8gZXh0XG5cbiAgYXJncy51bnNoaWZ0KGN5dG9zY2FwZSk7IC8vIGN5dG9zY2FwZSBpcyBmaXJzdCBhcmcgdG8gZXh0XG5cbiAgZXh0LmFwcGx5KG51bGwsIGFyZ3MpO1xuICByZXR1cm4gdGhpcztcbn07XG5jeXRvc2NhcGUud2FybmluZ3MgPSBmdW5jdGlvbiAoYm9vbCkge1xuICByZXR1cm4gd2FybmluZ3MoYm9vbCk7XG59O1xuXG4vLyByZXBsYWNlZCBieSBidWlsZCBzeXN0ZW1cbmN5dG9zY2FwZS52ZXJzaW9uID0gdmVyc2lvbjtcblxuLy8gZXhwb3NlIHB1YmxpYyBhcGlzIChtb3N0bHkgZm9yIGV4dGVuc2lvbnMpXG5jeXRvc2NhcGUuc3R5bGVzaGVldCA9IGN5dG9zY2FwZS5TdHlsZXNoZWV0ID0gU3R5bGVzaGVldDtcblxuZXhwb3J0IHsgY3l0b3NjYXBlIGFzIGRlZmF1bHQgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/cytoscape/dist/cytoscape.esm.mjs\n"));

/***/ }),

/***/ "./node_modules/mermaid/dist/chunks/mermaid.core/mindmap-definition-GWI6TPTV.mjs":
/*!***************************************************************************************!*\
  !*** ./node_modules/mermaid/dist/chunks/mermaid.core/mindmap-definition-GWI6TPTV.mjs ***!
  \***************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   diagram: function() { return /* binding */ diagram; }\n/* harmony export */ });\n/* harmony import */ var _chunk_6JOS74DS_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./chunk-6JOS74DS.mjs */ \"./node_modules/mermaid/dist/chunks/mermaid.core/chunk-6JOS74DS.mjs\");\n/* harmony import */ var _chunk_7DKRZKHE_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./chunk-7DKRZKHE.mjs */ \"./node_modules/mermaid/dist/chunks/mermaid.core/chunk-7DKRZKHE.mjs\");\n/* harmony import */ var _chunk_EJ4ZWXGL_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./chunk-EJ4ZWXGL.mjs */ \"./node_modules/mermaid/dist/chunks/mermaid.core/chunk-EJ4ZWXGL.mjs\");\n/* harmony import */ var _chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./chunk-6DBFFHIP.mjs */ \"./node_modules/mermaid/dist/chunks/mermaid.core/chunk-6DBFFHIP.mjs\");\n/* harmony import */ var cytoscape__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! cytoscape */ \"./node_modules/cytoscape/dist/cytoscape.esm.mjs\");\n/* harmony import */ var cytoscape_cose_bilkent__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! cytoscape-cose-bilkent */ \"./node_modules/cytoscape-cose-bilkent/cytoscape-cose-bilkent.js\");\n/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! d3 */ \"./node_modules/d3/src/index.js\");\n/* harmony import */ var khroma__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! khroma */ \"./node_modules/khroma/dist/methods/is_dark.js\");\n/* harmony import */ var khroma__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! khroma */ \"./node_modules/khroma/dist/methods/lighten.js\");\n/* harmony import */ var khroma__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! khroma */ \"./node_modules/khroma/dist/methods/darken.js\");\n\n\n\n\n\n// src/diagrams/mindmap/parser/mindmap.jison\nvar parser = function() {\n  var o = /* @__PURE__ */ (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_3__.__name)(function(k, v, o2, l) {\n    for (o2 = o2 || {}, l = k.length; l--; o2[k[l]] = v) ;\n    return o2;\n  }, \"o\"), $V0 = [1, 4], $V1 = [1, 13], $V2 = [1, 12], $V3 = [1, 15], $V4 = [1, 16], $V5 = [1, 20], $V6 = [1, 19], $V7 = [6, 7, 8], $V8 = [1, 26], $V9 = [1, 24], $Va = [1, 25], $Vb = [6, 7, 11], $Vc = [1, 6, 13, 15, 16, 19, 22], $Vd = [1, 33], $Ve = [1, 34], $Vf = [1, 6, 7, 11, 13, 15, 16, 19, 22];\n  var parser2 = {\n    trace: /* @__PURE__ */ (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_3__.__name)(function trace() {\n    }, \"trace\"),\n    yy: {},\n    symbols_: { \"error\": 2, \"start\": 3, \"mindMap\": 4, \"spaceLines\": 5, \"SPACELINE\": 6, \"NL\": 7, \"MINDMAP\": 8, \"document\": 9, \"stop\": 10, \"EOF\": 11, \"statement\": 12, \"SPACELIST\": 13, \"node\": 14, \"ICON\": 15, \"CLASS\": 16, \"nodeWithId\": 17, \"nodeWithoutId\": 18, \"NODE_DSTART\": 19, \"NODE_DESCR\": 20, \"NODE_DEND\": 21, \"NODE_ID\": 22, \"$accept\": 0, \"$end\": 1 },\n    terminals_: { 2: \"error\", 6: \"SPACELINE\", 7: \"NL\", 8: \"MINDMAP\", 11: \"EOF\", 13: \"SPACELIST\", 15: \"ICON\", 16: \"CLASS\", 19: \"NODE_DSTART\", 20: \"NODE_DESCR\", 21: \"NODE_DEND\", 22: \"NODE_ID\" },\n    productions_: [0, [3, 1], [3, 2], [5, 1], [5, 2], [5, 2], [4, 2], [4, 3], [10, 1], [10, 1], [10, 1], [10, 2], [10, 2], [9, 3], [9, 2], [12, 2], [12, 2], [12, 2], [12, 1], [12, 1], [12, 1], [12, 1], [12, 1], [14, 1], [14, 1], [18, 3], [17, 1], [17, 4]],\n    performAction: /* @__PURE__ */ (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_3__.__name)(function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$) {\n      var $0 = $$.length - 1;\n      switch (yystate) {\n        case 6:\n        case 7:\n          return yy;\n          break;\n        case 8:\n          yy.getLogger().trace(\"Stop NL \");\n          break;\n        case 9:\n          yy.getLogger().trace(\"Stop EOF \");\n          break;\n        case 11:\n          yy.getLogger().trace(\"Stop NL2 \");\n          break;\n        case 12:\n          yy.getLogger().trace(\"Stop EOF2 \");\n          break;\n        case 15:\n          yy.getLogger().info(\"Node: \", $$[$0].id);\n          yy.addNode($$[$0 - 1].length, $$[$0].id, $$[$0].descr, $$[$0].type);\n          break;\n        case 16:\n          yy.getLogger().trace(\"Icon: \", $$[$0]);\n          yy.decorateNode({ icon: $$[$0] });\n          break;\n        case 17:\n        case 21:\n          yy.decorateNode({ class: $$[$0] });\n          break;\n        case 18:\n          yy.getLogger().trace(\"SPACELIST\");\n          break;\n        case 19:\n          yy.getLogger().trace(\"Node: \", $$[$0].id);\n          yy.addNode(0, $$[$0].id, $$[$0].descr, $$[$0].type);\n          break;\n        case 20:\n          yy.decorateNode({ icon: $$[$0] });\n          break;\n        case 25:\n          yy.getLogger().trace(\"node found ..\", $$[$0 - 2]);\n          this.$ = { id: $$[$0 - 1], descr: $$[$0 - 1], type: yy.getType($$[$0 - 2], $$[$0]) };\n          break;\n        case 26:\n          this.$ = { id: $$[$0], descr: $$[$0], type: yy.nodeType.DEFAULT };\n          break;\n        case 27:\n          yy.getLogger().trace(\"node found ..\", $$[$0 - 3]);\n          this.$ = { id: $$[$0 - 3], descr: $$[$0 - 1], type: yy.getType($$[$0 - 2], $$[$0]) };\n          break;\n      }\n    }, \"anonymous\"),\n    table: [{ 3: 1, 4: 2, 5: 3, 6: [1, 5], 8: $V0 }, { 1: [3] }, { 1: [2, 1] }, { 4: 6, 6: [1, 7], 7: [1, 8], 8: $V0 }, { 6: $V1, 7: [1, 10], 9: 9, 12: 11, 13: $V2, 14: 14, 15: $V3, 16: $V4, 17: 17, 18: 18, 19: $V5, 22: $V6 }, o($V7, [2, 3]), { 1: [2, 2] }, o($V7, [2, 4]), o($V7, [2, 5]), { 1: [2, 6], 6: $V1, 12: 21, 13: $V2, 14: 14, 15: $V3, 16: $V4, 17: 17, 18: 18, 19: $V5, 22: $V6 }, { 6: $V1, 9: 22, 12: 11, 13: $V2, 14: 14, 15: $V3, 16: $V4, 17: 17, 18: 18, 19: $V5, 22: $V6 }, { 6: $V8, 7: $V9, 10: 23, 11: $Va }, o($Vb, [2, 22], { 17: 17, 18: 18, 14: 27, 15: [1, 28], 16: [1, 29], 19: $V5, 22: $V6 }), o($Vb, [2, 18]), o($Vb, [2, 19]), o($Vb, [2, 20]), o($Vb, [2, 21]), o($Vb, [2, 23]), o($Vb, [2, 24]), o($Vb, [2, 26], { 19: [1, 30] }), { 20: [1, 31] }, { 6: $V8, 7: $V9, 10: 32, 11: $Va }, { 1: [2, 7], 6: $V1, 12: 21, 13: $V2, 14: 14, 15: $V3, 16: $V4, 17: 17, 18: 18, 19: $V5, 22: $V6 }, o($Vc, [2, 14], { 7: $Vd, 11: $Ve }), o($Vf, [2, 8]), o($Vf, [2, 9]), o($Vf, [2, 10]), o($Vb, [2, 15]), o($Vb, [2, 16]), o($Vb, [2, 17]), { 20: [1, 35] }, { 21: [1, 36] }, o($Vc, [2, 13], { 7: $Vd, 11: $Ve }), o($Vf, [2, 11]), o($Vf, [2, 12]), { 21: [1, 37] }, o($Vb, [2, 25]), o($Vb, [2, 27])],\n    defaultActions: { 2: [2, 1], 6: [2, 2] },\n    parseError: /* @__PURE__ */ (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_3__.__name)(function parseError(str, hash) {\n      if (hash.recoverable) {\n        this.trace(str);\n      } else {\n        var error = new Error(str);\n        error.hash = hash;\n        throw error;\n      }\n    }, \"parseError\"),\n    parse: /* @__PURE__ */ (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_3__.__name)(function parse(input) {\n      var self = this, stack = [0], tstack = [], vstack = [null], lstack = [], table = this.table, yytext = \"\", yylineno = 0, yyleng = 0, recovering = 0, TERROR = 2, EOF = 1;\n      var args = lstack.slice.call(arguments, 1);\n      var lexer2 = Object.create(this.lexer);\n      var sharedState = { yy: {} };\n      for (var k in this.yy) {\n        if (Object.prototype.hasOwnProperty.call(this.yy, k)) {\n          sharedState.yy[k] = this.yy[k];\n        }\n      }\n      lexer2.setInput(input, sharedState.yy);\n      sharedState.yy.lexer = lexer2;\n      sharedState.yy.parser = this;\n      if (typeof lexer2.yylloc == \"undefined\") {\n        lexer2.yylloc = {};\n      }\n      var yyloc = lexer2.yylloc;\n      lstack.push(yyloc);\n      var ranges = lexer2.options && lexer2.options.ranges;\n      if (typeof sharedState.yy.parseError === \"function\") {\n        this.parseError = sharedState.yy.parseError;\n      } else {\n        this.parseError = Object.getPrototypeOf(this).parseError;\n      }\n      function popStack(n) {\n        stack.length = stack.length - 2 * n;\n        vstack.length = vstack.length - n;\n        lstack.length = lstack.length - n;\n      }\n      (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_3__.__name)(popStack, \"popStack\");\n      function lex() {\n        var token;\n        token = tstack.pop() || lexer2.lex() || EOF;\n        if (typeof token !== \"number\") {\n          if (token instanceof Array) {\n            tstack = token;\n            token = tstack.pop();\n          }\n          token = self.symbols_[token] || token;\n        }\n        return token;\n      }\n      (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_3__.__name)(lex, \"lex\");\n      var symbol, preErrorSymbol, state, action, a, r, yyval = {}, p, len, newState, expected;\n      while (true) {\n        state = stack[stack.length - 1];\n        if (this.defaultActions[state]) {\n          action = this.defaultActions[state];\n        } else {\n          if (symbol === null || typeof symbol == \"undefined\") {\n            symbol = lex();\n          }\n          action = table[state] && table[state][symbol];\n        }\n        if (typeof action === \"undefined\" || !action.length || !action[0]) {\n          var errStr = \"\";\n          expected = [];\n          for (p in table[state]) {\n            if (this.terminals_[p] && p > TERROR) {\n              expected.push(\"'\" + this.terminals_[p] + \"'\");\n            }\n          }\n          if (lexer2.showPosition) {\n            errStr = \"Parse error on line \" + (yylineno + 1) + \":\\n\" + lexer2.showPosition() + \"\\nExpecting \" + expected.join(\", \") + \", got '\" + (this.terminals_[symbol] || symbol) + \"'\";\n          } else {\n            errStr = \"Parse error on line \" + (yylineno + 1) + \": Unexpected \" + (symbol == EOF ? \"end of input\" : \"'\" + (this.terminals_[symbol] || symbol) + \"'\");\n          }\n          this.parseError(errStr, {\n            text: lexer2.match,\n            token: this.terminals_[symbol] || symbol,\n            line: lexer2.yylineno,\n            loc: yyloc,\n            expected\n          });\n        }\n        if (action[0] instanceof Array && action.length > 1) {\n          throw new Error(\"Parse Error: multiple actions possible at state: \" + state + \", token: \" + symbol);\n        }\n        switch (action[0]) {\n          case 1:\n            stack.push(symbol);\n            vstack.push(lexer2.yytext);\n            lstack.push(lexer2.yylloc);\n            stack.push(action[1]);\n            symbol = null;\n            if (!preErrorSymbol) {\n              yyleng = lexer2.yyleng;\n              yytext = lexer2.yytext;\n              yylineno = lexer2.yylineno;\n              yyloc = lexer2.yylloc;\n              if (recovering > 0) {\n                recovering--;\n              }\n            } else {\n              symbol = preErrorSymbol;\n              preErrorSymbol = null;\n            }\n            break;\n          case 2:\n            len = this.productions_[action[1]][1];\n            yyval.$ = vstack[vstack.length - len];\n            yyval._$ = {\n              first_line: lstack[lstack.length - (len || 1)].first_line,\n              last_line: lstack[lstack.length - 1].last_line,\n              first_column: lstack[lstack.length - (len || 1)].first_column,\n              last_column: lstack[lstack.length - 1].last_column\n            };\n            if (ranges) {\n              yyval._$.range = [\n                lstack[lstack.length - (len || 1)].range[0],\n                lstack[lstack.length - 1].range[1]\n              ];\n            }\n            r = this.performAction.apply(yyval, [\n              yytext,\n              yyleng,\n              yylineno,\n              sharedState.yy,\n              action[1],\n              vstack,\n              lstack\n            ].concat(args));\n            if (typeof r !== \"undefined\") {\n              return r;\n            }\n            if (len) {\n              stack = stack.slice(0, -1 * len * 2);\n              vstack = vstack.slice(0, -1 * len);\n              lstack = lstack.slice(0, -1 * len);\n            }\n            stack.push(this.productions_[action[1]][0]);\n            vstack.push(yyval.$);\n            lstack.push(yyval._$);\n            newState = table[stack[stack.length - 2]][stack[stack.length - 1]];\n            stack.push(newState);\n            break;\n          case 3:\n            return true;\n        }\n      }\n      return true;\n    }, \"parse\")\n  };\n  var lexer = /* @__PURE__ */ function() {\n    var lexer2 = {\n      EOF: 1,\n      parseError: /* @__PURE__ */ (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_3__.__name)(function parseError(str, hash) {\n        if (this.yy.parser) {\n          this.yy.parser.parseError(str, hash);\n        } else {\n          throw new Error(str);\n        }\n      }, \"parseError\"),\n      // resets the lexer, sets new input\n      setInput: /* @__PURE__ */ (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_3__.__name)(function(input, yy) {\n        this.yy = yy || this.yy || {};\n        this._input = input;\n        this._more = this._backtrack = this.done = false;\n        this.yylineno = this.yyleng = 0;\n        this.yytext = this.matched = this.match = \"\";\n        this.conditionStack = [\"INITIAL\"];\n        this.yylloc = {\n          first_line: 1,\n          first_column: 0,\n          last_line: 1,\n          last_column: 0\n        };\n        if (this.options.ranges) {\n          this.yylloc.range = [0, 0];\n        }\n        this.offset = 0;\n        return this;\n      }, \"setInput\"),\n      // consumes and returns one char from the input\n      input: /* @__PURE__ */ (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_3__.__name)(function() {\n        var ch = this._input[0];\n        this.yytext += ch;\n        this.yyleng++;\n        this.offset++;\n        this.match += ch;\n        this.matched += ch;\n        var lines = ch.match(/(?:\\r\\n?|\\n).*/g);\n        if (lines) {\n          this.yylineno++;\n          this.yylloc.last_line++;\n        } else {\n          this.yylloc.last_column++;\n        }\n        if (this.options.ranges) {\n          this.yylloc.range[1]++;\n        }\n        this._input = this._input.slice(1);\n        return ch;\n      }, \"input\"),\n      // unshifts one char (or a string) into the input\n      unput: /* @__PURE__ */ (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_3__.__name)(function(ch) {\n        var len = ch.length;\n        var lines = ch.split(/(?:\\r\\n?|\\n)/g);\n        this._input = ch + this._input;\n        this.yytext = this.yytext.substr(0, this.yytext.length - len);\n        this.offset -= len;\n        var oldLines = this.match.split(/(?:\\r\\n?|\\n)/g);\n        this.match = this.match.substr(0, this.match.length - 1);\n        this.matched = this.matched.substr(0, this.matched.length - 1);\n        if (lines.length - 1) {\n          this.yylineno -= lines.length - 1;\n        }\n        var r = this.yylloc.range;\n        this.yylloc = {\n          first_line: this.yylloc.first_line,\n          last_line: this.yylineno + 1,\n          first_column: this.yylloc.first_column,\n          last_column: lines ? (lines.length === oldLines.length ? this.yylloc.first_column : 0) + oldLines[oldLines.length - lines.length].length - lines[0].length : this.yylloc.first_column - len\n        };\n        if (this.options.ranges) {\n          this.yylloc.range = [r[0], r[0] + this.yyleng - len];\n        }\n        this.yyleng = this.yytext.length;\n        return this;\n      }, \"unput\"),\n      // When called from action, caches matched text and appends it on next action\n      more: /* @__PURE__ */ (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_3__.__name)(function() {\n        this._more = true;\n        return this;\n      }, \"more\"),\n      // When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.\n      reject: /* @__PURE__ */ (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_3__.__name)(function() {\n        if (this.options.backtrack_lexer) {\n          this._backtrack = true;\n        } else {\n          return this.parseError(\"Lexical error on line \" + (this.yylineno + 1) + \". You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\\n\" + this.showPosition(), {\n            text: \"\",\n            token: null,\n            line: this.yylineno\n          });\n        }\n        return this;\n      }, \"reject\"),\n      // retain first n characters of the match\n      less: /* @__PURE__ */ (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_3__.__name)(function(n) {\n        this.unput(this.match.slice(n));\n      }, \"less\"),\n      // displays already matched input, i.e. for error messages\n      pastInput: /* @__PURE__ */ (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_3__.__name)(function() {\n        var past = this.matched.substr(0, this.matched.length - this.match.length);\n        return (past.length > 20 ? \"...\" : \"\") + past.substr(-20).replace(/\\n/g, \"\");\n      }, \"pastInput\"),\n      // displays upcoming input, i.e. for error messages\n      upcomingInput: /* @__PURE__ */ (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_3__.__name)(function() {\n        var next = this.match;\n        if (next.length < 20) {\n          next += this._input.substr(0, 20 - next.length);\n        }\n        return (next.substr(0, 20) + (next.length > 20 ? \"...\" : \"\")).replace(/\\n/g, \"\");\n      }, \"upcomingInput\"),\n      // displays the character position where the lexing error occurred, i.e. for error messages\n      showPosition: /* @__PURE__ */ (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_3__.__name)(function() {\n        var pre = this.pastInput();\n        var c = new Array(pre.length + 1).join(\"-\");\n        return pre + this.upcomingInput() + \"\\n\" + c + \"^\";\n      }, \"showPosition\"),\n      // test the lexed token: return FALSE when not a match, otherwise return token\n      test_match: /* @__PURE__ */ (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_3__.__name)(function(match, indexed_rule) {\n        var token, lines, backup;\n        if (this.options.backtrack_lexer) {\n          backup = {\n            yylineno: this.yylineno,\n            yylloc: {\n              first_line: this.yylloc.first_line,\n              last_line: this.last_line,\n              first_column: this.yylloc.first_column,\n              last_column: this.yylloc.last_column\n            },\n            yytext: this.yytext,\n            match: this.match,\n            matches: this.matches,\n            matched: this.matched,\n            yyleng: this.yyleng,\n            offset: this.offset,\n            _more: this._more,\n            _input: this._input,\n            yy: this.yy,\n            conditionStack: this.conditionStack.slice(0),\n            done: this.done\n          };\n          if (this.options.ranges) {\n            backup.yylloc.range = this.yylloc.range.slice(0);\n          }\n        }\n        lines = match[0].match(/(?:\\r\\n?|\\n).*/g);\n        if (lines) {\n          this.yylineno += lines.length;\n        }\n        this.yylloc = {\n          first_line: this.yylloc.last_line,\n          last_line: this.yylineno + 1,\n          first_column: this.yylloc.last_column,\n          last_column: lines ? lines[lines.length - 1].length - lines[lines.length - 1].match(/\\r?\\n?/)[0].length : this.yylloc.last_column + match[0].length\n        };\n        this.yytext += match[0];\n        this.match += match[0];\n        this.matches = match;\n        this.yyleng = this.yytext.length;\n        if (this.options.ranges) {\n          this.yylloc.range = [this.offset, this.offset += this.yyleng];\n        }\n        this._more = false;\n        this._backtrack = false;\n        this._input = this._input.slice(match[0].length);\n        this.matched += match[0];\n        token = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);\n        if (this.done && this._input) {\n          this.done = false;\n        }\n        if (token) {\n          return token;\n        } else if (this._backtrack) {\n          for (var k in backup) {\n            this[k] = backup[k];\n          }\n          return false;\n        }\n        return false;\n      }, \"test_match\"),\n      // return next match in input\n      next: /* @__PURE__ */ (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_3__.__name)(function() {\n        if (this.done) {\n          return this.EOF;\n        }\n        if (!this._input) {\n          this.done = true;\n        }\n        var token, match, tempMatch, index;\n        if (!this._more) {\n          this.yytext = \"\";\n          this.match = \"\";\n        }\n        var rules = this._currentRules();\n        for (var i = 0; i < rules.length; i++) {\n          tempMatch = this._input.match(this.rules[rules[i]]);\n          if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {\n            match = tempMatch;\n            index = i;\n            if (this.options.backtrack_lexer) {\n              token = this.test_match(tempMatch, rules[i]);\n              if (token !== false) {\n                return token;\n              } else if (this._backtrack) {\n                match = false;\n                continue;\n              } else {\n                return false;\n              }\n            } else if (!this.options.flex) {\n              break;\n            }\n          }\n        }\n        if (match) {\n          token = this.test_match(match, rules[index]);\n          if (token !== false) {\n            return token;\n          }\n          return false;\n        }\n        if (this._input === \"\") {\n          return this.EOF;\n        } else {\n          return this.parseError(\"Lexical error on line \" + (this.yylineno + 1) + \". Unrecognized text.\\n\" + this.showPosition(), {\n            text: \"\",\n            token: null,\n            line: this.yylineno\n          });\n        }\n      }, \"next\"),\n      // return next match that has a token\n      lex: /* @__PURE__ */ (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_3__.__name)(function lex() {\n        var r = this.next();\n        if (r) {\n          return r;\n        } else {\n          return this.lex();\n        }\n      }, \"lex\"),\n      // activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)\n      begin: /* @__PURE__ */ (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_3__.__name)(function begin(condition) {\n        this.conditionStack.push(condition);\n      }, \"begin\"),\n      // pop the previously active lexer condition state off the condition stack\n      popState: /* @__PURE__ */ (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_3__.__name)(function popState() {\n        var n = this.conditionStack.length - 1;\n        if (n > 0) {\n          return this.conditionStack.pop();\n        } else {\n          return this.conditionStack[0];\n        }\n      }, \"popState\"),\n      // produce the lexer rule set which is active for the currently active lexer condition state\n      _currentRules: /* @__PURE__ */ (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_3__.__name)(function _currentRules() {\n        if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {\n          return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;\n        } else {\n          return this.conditions[\"INITIAL\"].rules;\n        }\n      }, \"_currentRules\"),\n      // return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available\n      topState: /* @__PURE__ */ (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_3__.__name)(function topState(n) {\n        n = this.conditionStack.length - 1 - Math.abs(n || 0);\n        if (n >= 0) {\n          return this.conditionStack[n];\n        } else {\n          return \"INITIAL\";\n        }\n      }, \"topState\"),\n      // alias for begin(condition)\n      pushState: /* @__PURE__ */ (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_3__.__name)(function pushState(condition) {\n        this.begin(condition);\n      }, \"pushState\"),\n      // return the number of states currently on the stack\n      stateStackSize: /* @__PURE__ */ (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_3__.__name)(function stateStackSize() {\n        return this.conditionStack.length;\n      }, \"stateStackSize\"),\n      options: { \"case-insensitive\": true },\n      performAction: /* @__PURE__ */ (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_3__.__name)(function anonymous(yy, yy_, $avoiding_name_collisions, YY_START) {\n        var YYSTATE = YY_START;\n        switch ($avoiding_name_collisions) {\n          case 0:\n            yy.getLogger().trace(\"Found comment\", yy_.yytext);\n            return 6;\n            break;\n          case 1:\n            return 8;\n            break;\n          case 2:\n            this.begin(\"CLASS\");\n            break;\n          case 3:\n            this.popState();\n            return 16;\n            break;\n          case 4:\n            this.popState();\n            break;\n          case 5:\n            yy.getLogger().trace(\"Begin icon\");\n            this.begin(\"ICON\");\n            break;\n          case 6:\n            yy.getLogger().trace(\"SPACELINE\");\n            return 6;\n            break;\n          case 7:\n            return 7;\n            break;\n          case 8:\n            return 15;\n            break;\n          case 9:\n            yy.getLogger().trace(\"end icon\");\n            this.popState();\n            break;\n          case 10:\n            yy.getLogger().trace(\"Exploding node\");\n            this.begin(\"NODE\");\n            return 19;\n            break;\n          case 11:\n            yy.getLogger().trace(\"Cloud\");\n            this.begin(\"NODE\");\n            return 19;\n            break;\n          case 12:\n            yy.getLogger().trace(\"Explosion Bang\");\n            this.begin(\"NODE\");\n            return 19;\n            break;\n          case 13:\n            yy.getLogger().trace(\"Cloud Bang\");\n            this.begin(\"NODE\");\n            return 19;\n            break;\n          case 14:\n            this.begin(\"NODE\");\n            return 19;\n            break;\n          case 15:\n            this.begin(\"NODE\");\n            return 19;\n            break;\n          case 16:\n            this.begin(\"NODE\");\n            return 19;\n            break;\n          case 17:\n            this.begin(\"NODE\");\n            return 19;\n            break;\n          case 18:\n            return 13;\n            break;\n          case 19:\n            return 22;\n            break;\n          case 20:\n            return 11;\n            break;\n          case 21:\n            this.begin(\"NSTR2\");\n            break;\n          case 22:\n            return \"NODE_DESCR\";\n            break;\n          case 23:\n            this.popState();\n            break;\n          case 24:\n            yy.getLogger().trace(\"Starting NSTR\");\n            this.begin(\"NSTR\");\n            break;\n          case 25:\n            yy.getLogger().trace(\"description:\", yy_.yytext);\n            return \"NODE_DESCR\";\n            break;\n          case 26:\n            this.popState();\n            break;\n          case 27:\n            this.popState();\n            yy.getLogger().trace(\"node end ))\");\n            return \"NODE_DEND\";\n            break;\n          case 28:\n            this.popState();\n            yy.getLogger().trace(\"node end )\");\n            return \"NODE_DEND\";\n            break;\n          case 29:\n            this.popState();\n            yy.getLogger().trace(\"node end ...\", yy_.yytext);\n            return \"NODE_DEND\";\n            break;\n          case 30:\n            this.popState();\n            yy.getLogger().trace(\"node end ((\");\n            return \"NODE_DEND\";\n            break;\n          case 31:\n            this.popState();\n            yy.getLogger().trace(\"node end (-\");\n            return \"NODE_DEND\";\n            break;\n          case 32:\n            this.popState();\n            yy.getLogger().trace(\"node end (-\");\n            return \"NODE_DEND\";\n            break;\n          case 33:\n            this.popState();\n            yy.getLogger().trace(\"node end ((\");\n            return \"NODE_DEND\";\n            break;\n          case 34:\n            this.popState();\n            yy.getLogger().trace(\"node end ((\");\n            return \"NODE_DEND\";\n            break;\n          case 35:\n            yy.getLogger().trace(\"Long description:\", yy_.yytext);\n            return 20;\n            break;\n          case 36:\n            yy.getLogger().trace(\"Long description:\", yy_.yytext);\n            return 20;\n            break;\n        }\n      }, \"anonymous\"),\n      rules: [/^(?:\\s*%%.*)/i, /^(?:mindmap\\b)/i, /^(?::::)/i, /^(?:.+)/i, /^(?:\\n)/i, /^(?:::icon\\()/i, /^(?:[\\s]+[\\n])/i, /^(?:[\\n]+)/i, /^(?:[^\\)]+)/i, /^(?:\\))/i, /^(?:-\\))/i, /^(?:\\(-)/i, /^(?:\\)\\))/i, /^(?:\\))/i, /^(?:\\(\\()/i, /^(?:\\{\\{)/i, /^(?:\\()/i, /^(?:\\[)/i, /^(?:[\\s]+)/i, /^(?:[^\\(\\[\\n\\)\\{\\}]+)/i, /^(?:$)/i, /^(?:[\"][`])/i, /^(?:[^`\"]+)/i, /^(?:[`][\"])/i, /^(?:[\"])/i, /^(?:[^\"]+)/i, /^(?:[\"])/i, /^(?:[\\)]\\))/i, /^(?:[\\)])/i, /^(?:[\\]])/i, /^(?:\\}\\})/i, /^(?:\\(-)/i, /^(?:-\\))/i, /^(?:\\(\\()/i, /^(?:\\()/i, /^(?:[^\\)\\]\\(\\}]+)/i, /^(?:.+(?!\\(\\())/i],\n      conditions: { \"CLASS\": { \"rules\": [3, 4], \"inclusive\": false }, \"ICON\": { \"rules\": [8, 9], \"inclusive\": false }, \"NSTR2\": { \"rules\": [22, 23], \"inclusive\": false }, \"NSTR\": { \"rules\": [25, 26], \"inclusive\": false }, \"NODE\": { \"rules\": [21, 24, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36], \"inclusive\": false }, \"INITIAL\": { \"rules\": [0, 1, 2, 5, 6, 7, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20], \"inclusive\": true } }\n    };\n    return lexer2;\n  }();\n  parser2.lexer = lexer;\n  function Parser() {\n    this.yy = {};\n  }\n  (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_3__.__name)(Parser, \"Parser\");\n  Parser.prototype = parser2;\n  parser2.Parser = Parser;\n  return new Parser();\n}();\nparser.parser = parser;\nvar mindmap_default = parser;\n\n// src/diagrams/mindmap/mindmapDb.ts\nvar nodes = [];\nvar cnt = 0;\nvar elements = {};\nvar clear = /* @__PURE__ */ (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_3__.__name)(() => {\n  nodes = [];\n  cnt = 0;\n  elements = {};\n}, \"clear\");\nvar getParent = /* @__PURE__ */ (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_3__.__name)(function(level) {\n  for (let i = nodes.length - 1; i >= 0; i--) {\n    if (nodes[i].level < level) {\n      return nodes[i];\n    }\n  }\n  return null;\n}, \"getParent\");\nvar getMindmap = /* @__PURE__ */ (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_3__.__name)(() => {\n  return nodes.length > 0 ? nodes[0] : null;\n}, \"getMindmap\");\nvar addNode = /* @__PURE__ */ (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_3__.__name)((level, id, descr, type) => {\n  _chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_3__.log.info(\"addNode\", level, id, descr, type);\n  const conf = (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_3__.getConfig2)();\n  let padding = conf.mindmap?.padding ?? _chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_3__.defaultConfig_default.mindmap.padding;\n  switch (type) {\n    case nodeType.ROUNDED_RECT:\n    case nodeType.RECT:\n    case nodeType.HEXAGON:\n      padding *= 2;\n  }\n  const node = {\n    id: cnt++,\n    nodeId: (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_3__.sanitizeText)(id, conf),\n    level,\n    descr: (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_3__.sanitizeText)(descr, conf),\n    type,\n    children: [],\n    width: conf.mindmap?.maxNodeWidth ?? _chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_3__.defaultConfig_default.mindmap.maxNodeWidth,\n    padding\n  };\n  const parent = getParent(level);\n  if (parent) {\n    parent.children.push(node);\n    nodes.push(node);\n  } else {\n    if (nodes.length === 0) {\n      nodes.push(node);\n    } else {\n      throw new Error(\n        'There can be only one root. No parent could be found for (\"' + node.descr + '\")'\n      );\n    }\n  }\n}, \"addNode\");\nvar nodeType = {\n  DEFAULT: 0,\n  NO_BORDER: 0,\n  ROUNDED_RECT: 1,\n  RECT: 2,\n  CIRCLE: 3,\n  CLOUD: 4,\n  BANG: 5,\n  HEXAGON: 6\n};\nvar getType = /* @__PURE__ */ (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_3__.__name)((startStr, endStr) => {\n  _chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_3__.log.debug(\"In get type\", startStr, endStr);\n  switch (startStr) {\n    case \"[\":\n      return nodeType.RECT;\n    case \"(\":\n      return endStr === \")\" ? nodeType.ROUNDED_RECT : nodeType.CLOUD;\n    case \"((\":\n      return nodeType.CIRCLE;\n    case \")\":\n      return nodeType.CLOUD;\n    case \"))\":\n      return nodeType.BANG;\n    case \"{{\":\n      return nodeType.HEXAGON;\n    default:\n      return nodeType.DEFAULT;\n  }\n}, \"getType\");\nvar setElementForId = /* @__PURE__ */ (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_3__.__name)((id, element) => {\n  elements[id] = element;\n}, \"setElementForId\");\nvar decorateNode = /* @__PURE__ */ (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_3__.__name)((decoration) => {\n  if (!decoration) {\n    return;\n  }\n  const config = (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_3__.getConfig2)();\n  const node = nodes[nodes.length - 1];\n  if (decoration.icon) {\n    node.icon = (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_3__.sanitizeText)(decoration.icon, config);\n  }\n  if (decoration.class) {\n    node.class = (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_3__.sanitizeText)(decoration.class, config);\n  }\n}, \"decorateNode\");\nvar type2Str = /* @__PURE__ */ (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_3__.__name)((type) => {\n  switch (type) {\n    case nodeType.DEFAULT:\n      return \"no-border\";\n    case nodeType.RECT:\n      return \"rect\";\n    case nodeType.ROUNDED_RECT:\n      return \"rounded-rect\";\n    case nodeType.CIRCLE:\n      return \"circle\";\n    case nodeType.CLOUD:\n      return \"cloud\";\n    case nodeType.BANG:\n      return \"bang\";\n    case nodeType.HEXAGON:\n      return \"hexgon\";\n    default:\n      return \"no-border\";\n  }\n}, \"type2Str\");\nvar getLogger = /* @__PURE__ */ (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_3__.__name)(() => _chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_3__.log, \"getLogger\");\nvar getElementById = /* @__PURE__ */ (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_3__.__name)((id) => elements[id], \"getElementById\");\nvar db = {\n  clear,\n  addNode,\n  getMindmap,\n  nodeType,\n  getType,\n  setElementForId,\n  decorateNode,\n  type2Str,\n  getLogger,\n  getElementById\n};\nvar mindmapDb_default = db;\n\n// src/diagrams/mindmap/mindmapRenderer.ts\n\n\n\n\n// src/diagrams/mindmap/svgDraw.ts\nvar MAX_SECTIONS = 12;\nvar defaultBkg = /* @__PURE__ */ (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_3__.__name)(function(db2, elem, node, section) {\n  const rd = 5;\n  elem.append(\"path\").attr(\"id\", \"node-\" + node.id).attr(\"class\", \"node-bkg node-\" + db2.type2Str(node.type)).attr(\n    \"d\",\n    `M0 ${node.height - rd} v${-node.height + 2 * rd} q0,-5 5,-5 h${node.width - 2 * rd} q5,0 5,5 v${node.height - rd} H0 Z`\n  );\n  elem.append(\"line\").attr(\"class\", \"node-line-\" + section).attr(\"x1\", 0).attr(\"y1\", node.height).attr(\"x2\", node.width).attr(\"y2\", node.height);\n}, \"defaultBkg\");\nvar rectBkg = /* @__PURE__ */ (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_3__.__name)(function(db2, elem, node) {\n  elem.append(\"rect\").attr(\"id\", \"node-\" + node.id).attr(\"class\", \"node-bkg node-\" + db2.type2Str(node.type)).attr(\"height\", node.height).attr(\"width\", node.width);\n}, \"rectBkg\");\nvar cloudBkg = /* @__PURE__ */ (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_3__.__name)(function(db2, elem, node) {\n  const w = node.width;\n  const h = node.height;\n  const r1 = 0.15 * w;\n  const r2 = 0.25 * w;\n  const r3 = 0.35 * w;\n  const r4 = 0.2 * w;\n  elem.append(\"path\").attr(\"id\", \"node-\" + node.id).attr(\"class\", \"node-bkg node-\" + db2.type2Str(node.type)).attr(\n    \"d\",\n    `M0 0 a${r1},${r1} 0 0,1 ${w * 0.25},${-1 * w * 0.1}\n      a${r3},${r3} 1 0,1 ${w * 0.4},${-1 * w * 0.1}\n      a${r2},${r2} 1 0,1 ${w * 0.35},${1 * w * 0.2}\n\n      a${r1},${r1} 1 0,1 ${w * 0.15},${1 * h * 0.35}\n      a${r4},${r4} 1 0,1 ${-1 * w * 0.15},${1 * h * 0.65}\n\n      a${r2},${r1} 1 0,1 ${-1 * w * 0.25},${w * 0.15}\n      a${r3},${r3} 1 0,1 ${-1 * w * 0.5},${0}\n      a${r1},${r1} 1 0,1 ${-1 * w * 0.25},${-1 * w * 0.15}\n\n      a${r1},${r1} 1 0,1 ${-1 * w * 0.1},${-1 * h * 0.35}\n      a${r4},${r4} 1 0,1 ${w * 0.1},${-1 * h * 0.65}\n\n    H0 V0 Z`\n  );\n}, \"cloudBkg\");\nvar bangBkg = /* @__PURE__ */ (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_3__.__name)(function(db2, elem, node) {\n  const w = node.width;\n  const h = node.height;\n  const r = 0.15 * w;\n  elem.append(\"path\").attr(\"id\", \"node-\" + node.id).attr(\"class\", \"node-bkg node-\" + db2.type2Str(node.type)).attr(\n    \"d\",\n    `M0 0 a${r},${r} 1 0,0 ${w * 0.25},${-1 * h * 0.1}\n      a${r},${r} 1 0,0 ${w * 0.25},${0}\n      a${r},${r} 1 0,0 ${w * 0.25},${0}\n      a${r},${r} 1 0,0 ${w * 0.25},${1 * h * 0.1}\n\n      a${r},${r} 1 0,0 ${w * 0.15},${1 * h * 0.33}\n      a${r * 0.8},${r * 0.8} 1 0,0 ${0},${1 * h * 0.34}\n      a${r},${r} 1 0,0 ${-1 * w * 0.15},${1 * h * 0.33}\n\n      a${r},${r} 1 0,0 ${-1 * w * 0.25},${h * 0.15}\n      a${r},${r} 1 0,0 ${-1 * w * 0.25},${0}\n      a${r},${r} 1 0,0 ${-1 * w * 0.25},${0}\n      a${r},${r} 1 0,0 ${-1 * w * 0.25},${-1 * h * 0.15}\n\n      a${r},${r} 1 0,0 ${-1 * w * 0.1},${-1 * h * 0.33}\n      a${r * 0.8},${r * 0.8} 1 0,0 ${0},${-1 * h * 0.34}\n      a${r},${r} 1 0,0 ${w * 0.1},${-1 * h * 0.33}\n\n    H0 V0 Z`\n  );\n}, \"bangBkg\");\nvar circleBkg = /* @__PURE__ */ (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_3__.__name)(function(db2, elem, node) {\n  elem.append(\"circle\").attr(\"id\", \"node-\" + node.id).attr(\"class\", \"node-bkg node-\" + db2.type2Str(node.type)).attr(\"r\", node.width / 2);\n}, \"circleBkg\");\nfunction insertPolygonShape(parent, w, h, points, node) {\n  return parent.insert(\"polygon\", \":first-child\").attr(\n    \"points\",\n    points.map(function(d) {\n      return d.x + \",\" + d.y;\n    }).join(\" \")\n  ).attr(\"transform\", \"translate(\" + (node.width - w) / 2 + \", \" + h + \")\");\n}\n(0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_3__.__name)(insertPolygonShape, \"insertPolygonShape\");\nvar hexagonBkg = /* @__PURE__ */ (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_3__.__name)(function(_db, elem, node) {\n  const h = node.height;\n  const f = 4;\n  const m = h / f;\n  const w = node.width - node.padding + 2 * m;\n  const points = [\n    { x: m, y: 0 },\n    { x: w - m, y: 0 },\n    { x: w, y: -h / 2 },\n    { x: w - m, y: -h },\n    { x: m, y: -h },\n    { x: 0, y: -h / 2 }\n  ];\n  insertPolygonShape(elem, w, h, points, node);\n}, \"hexagonBkg\");\nvar roundedRectBkg = /* @__PURE__ */ (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_3__.__name)(function(db2, elem, node) {\n  elem.append(\"rect\").attr(\"id\", \"node-\" + node.id).attr(\"class\", \"node-bkg node-\" + db2.type2Str(node.type)).attr(\"height\", node.height).attr(\"rx\", node.padding).attr(\"ry\", node.padding).attr(\"width\", node.width);\n}, \"roundedRectBkg\");\nvar drawNode = /* @__PURE__ */ (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_3__.__name)(async function(db2, elem, node, fullSection, conf) {\n  const htmlLabels = conf.htmlLabels;\n  const section = fullSection % (MAX_SECTIONS - 1);\n  const nodeElem = elem.append(\"g\");\n  node.section = section;\n  let sectionClass = \"section-\" + section;\n  if (section < 0) {\n    sectionClass += \" section-root\";\n  }\n  nodeElem.attr(\"class\", (node.class ? node.class + \" \" : \"\") + \"mindmap-node \" + sectionClass);\n  const bkgElem = nodeElem.append(\"g\");\n  const textElem = nodeElem.append(\"g\");\n  const description = node.descr.replace(/(<br\\/*>)/g, \"\\n\");\n  await (0,_chunk_6JOS74DS_mjs__WEBPACK_IMPORTED_MODULE_0__.createText)(\n    textElem,\n    description,\n    {\n      useHtmlLabels: htmlLabels,\n      width: node.width,\n      classes: \"mindmap-node-label\"\n    },\n    conf\n  );\n  if (!htmlLabels) {\n    textElem.attr(\"dy\", \"1em\").attr(\"alignment-baseline\", \"middle\").attr(\"dominant-baseline\", \"middle\").attr(\"text-anchor\", \"middle\");\n  }\n  const bbox = textElem.node().getBBox();\n  const [fontSize] = (0,_chunk_7DKRZKHE_mjs__WEBPACK_IMPORTED_MODULE_1__.parseFontSize)(conf.fontSize);\n  node.height = bbox.height + fontSize * 1.1 * 0.5 + node.padding;\n  node.width = bbox.width + 2 * node.padding;\n  if (node.icon) {\n    if (node.type === db2.nodeType.CIRCLE) {\n      node.height += 50;\n      node.width += 50;\n      const icon = nodeElem.append(\"foreignObject\").attr(\"height\", \"50px\").attr(\"width\", node.width).attr(\"style\", \"text-align: center;\");\n      icon.append(\"div\").attr(\"class\", \"icon-container\").append(\"i\").attr(\"class\", \"node-icon-\" + section + \" \" + node.icon);\n      textElem.attr(\n        \"transform\",\n        \"translate(\" + node.width / 2 + \", \" + (node.height / 2 - 1.5 * node.padding) + \")\"\n      );\n    } else {\n      node.width += 50;\n      const orgHeight = node.height;\n      node.height = Math.max(orgHeight, 60);\n      const heightDiff = Math.abs(node.height - orgHeight);\n      const icon = nodeElem.append(\"foreignObject\").attr(\"width\", \"60px\").attr(\"height\", node.height).attr(\"style\", \"text-align: center;margin-top:\" + heightDiff / 2 + \"px;\");\n      icon.append(\"div\").attr(\"class\", \"icon-container\").append(\"i\").attr(\"class\", \"node-icon-\" + section + \" \" + node.icon);\n      textElem.attr(\n        \"transform\",\n        \"translate(\" + (25 + node.width / 2) + \", \" + (heightDiff / 2 + node.padding / 2) + \")\"\n      );\n    }\n  } else {\n    if (!htmlLabels) {\n      const dx = node.width / 2;\n      const dy = node.padding / 2;\n      textElem.attr(\"transform\", \"translate(\" + dx + \", \" + dy + \")\");\n    } else {\n      const dx = (node.width - bbox.width) / 2;\n      const dy = (node.height - bbox.height) / 2;\n      textElem.attr(\"transform\", \"translate(\" + dx + \", \" + dy + \")\");\n    }\n  }\n  switch (node.type) {\n    case db2.nodeType.DEFAULT:\n      defaultBkg(db2, bkgElem, node, section);\n      break;\n    case db2.nodeType.ROUNDED_RECT:\n      roundedRectBkg(db2, bkgElem, node, section);\n      break;\n    case db2.nodeType.RECT:\n      rectBkg(db2, bkgElem, node, section);\n      break;\n    case db2.nodeType.CIRCLE:\n      bkgElem.attr(\"transform\", \"translate(\" + node.width / 2 + \", \" + +node.height / 2 + \")\");\n      circleBkg(db2, bkgElem, node, section);\n      break;\n    case db2.nodeType.CLOUD:\n      cloudBkg(db2, bkgElem, node, section);\n      break;\n    case db2.nodeType.BANG:\n      bangBkg(db2, bkgElem, node, section);\n      break;\n    case db2.nodeType.HEXAGON:\n      hexagonBkg(db2, bkgElem, node, section);\n      break;\n  }\n  db2.setElementForId(node.id, nodeElem);\n  return node.height;\n}, \"drawNode\");\nvar positionNode = /* @__PURE__ */ (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_3__.__name)(function(db2, node) {\n  const nodeElem = db2.getElementById(node.id);\n  const x = node.x || 0;\n  const y = node.y || 0;\n  nodeElem.attr(\"transform\", \"translate(\" + x + \",\" + y + \")\");\n}, \"positionNode\");\n\n// src/diagrams/mindmap/mindmapRenderer.ts\ncytoscape__WEBPACK_IMPORTED_MODULE_4__[\"default\"].use(cytoscape_cose_bilkent__WEBPACK_IMPORTED_MODULE_5__);\nasync function drawNodes(db2, svg, mindmap, section, conf) {\n  await drawNode(db2, svg, mindmap, section, conf);\n  if (mindmap.children) {\n    await Promise.all(\n      mindmap.children.map(\n        (child, index) => drawNodes(db2, svg, child, section < 0 ? index : section, conf)\n      )\n    );\n  }\n}\n(0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_3__.__name)(drawNodes, \"drawNodes\");\nfunction drawEdges(edgesEl, cy) {\n  cy.edges().map((edge, id) => {\n    const data = edge.data();\n    if (edge[0]._private.bodyBounds) {\n      const bounds = edge[0]._private.rscratch;\n      _chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_3__.log.trace(\"Edge: \", id, data);\n      edgesEl.insert(\"path\").attr(\n        \"d\",\n        `M ${bounds.startX},${bounds.startY} L ${bounds.midX},${bounds.midY} L${bounds.endX},${bounds.endY} `\n      ).attr(\"class\", \"edge section-edge-\" + data.section + \" edge-depth-\" + data.depth);\n    }\n  });\n}\n(0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_3__.__name)(drawEdges, \"drawEdges\");\nfunction addNodes(mindmap, cy, conf, level) {\n  cy.add({\n    group: \"nodes\",\n    data: {\n      id: mindmap.id.toString(),\n      labelText: mindmap.descr,\n      height: mindmap.height,\n      width: mindmap.width,\n      level,\n      nodeId: mindmap.id,\n      padding: mindmap.padding,\n      type: mindmap.type\n    },\n    position: {\n      x: mindmap.x,\n      y: mindmap.y\n    }\n  });\n  if (mindmap.children) {\n    mindmap.children.forEach((child) => {\n      addNodes(child, cy, conf, level + 1);\n      cy.add({\n        group: \"edges\",\n        data: {\n          id: `${mindmap.id}_${child.id}`,\n          source: mindmap.id,\n          target: child.id,\n          depth: level,\n          section: child.section\n        }\n      });\n    });\n  }\n}\n(0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_3__.__name)(addNodes, \"addNodes\");\nfunction layoutMindmap(node, conf) {\n  return new Promise((resolve) => {\n    const renderEl = (0,d3__WEBPACK_IMPORTED_MODULE_6__.select)(\"body\").append(\"div\").attr(\"id\", \"cy\").attr(\"style\", \"display:none\");\n    const cy = (0,cytoscape__WEBPACK_IMPORTED_MODULE_4__[\"default\"])({\n      container: document.getElementById(\"cy\"),\n      // container to render in\n      style: [\n        {\n          selector: \"edge\",\n          style: {\n            \"curve-style\": \"bezier\"\n          }\n        }\n      ]\n    });\n    renderEl.remove();\n    addNodes(node, cy, conf, 0);\n    cy.nodes().forEach(function(n) {\n      n.layoutDimensions = () => {\n        const data = n.data();\n        return { w: data.width, h: data.height };\n      };\n    });\n    cy.layout({\n      name: \"cose-bilkent\",\n      // @ts-ignore Types for cose-bilkent are not correct?\n      quality: \"proof\",\n      styleEnabled: false,\n      animate: false\n    }).run();\n    cy.ready((e) => {\n      _chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_3__.log.info(\"Ready\", e);\n      resolve(cy);\n    });\n  });\n}\n(0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_3__.__name)(layoutMindmap, \"layoutMindmap\");\nfunction positionNodes(db2, cy) {\n  cy.nodes().map((node, id) => {\n    const data = node.data();\n    data.x = node.position().x;\n    data.y = node.position().y;\n    positionNode(db2, data);\n    const el = db2.getElementById(data.nodeId);\n    _chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_3__.log.info(\"Id:\", id, \"Position: (\", node.position().x, \", \", node.position().y, \")\", data);\n    el.attr(\n      \"transform\",\n      `translate(${node.position().x - data.width / 2}, ${node.position().y - data.height / 2})`\n    );\n    el.attr(\"attr\", `apa-${id})`);\n  });\n}\n(0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_3__.__name)(positionNodes, \"positionNodes\");\nvar draw = /* @__PURE__ */ (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_3__.__name)(async (text, id, _version, diagObj) => {\n  _chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_3__.log.debug(\"Rendering mindmap diagram\\n\" + text);\n  const db2 = diagObj.db;\n  const mm = db2.getMindmap();\n  if (!mm) {\n    return;\n  }\n  const conf = (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_3__.getConfig2)();\n  conf.htmlLabels = false;\n  const svg = (0,_chunk_EJ4ZWXGL_mjs__WEBPACK_IMPORTED_MODULE_2__.selectSvgElement)(id);\n  const edgesElem = svg.append(\"g\");\n  edgesElem.attr(\"class\", \"mindmap-edges\");\n  const nodesElem = svg.append(\"g\");\n  nodesElem.attr(\"class\", \"mindmap-nodes\");\n  await drawNodes(db2, nodesElem, mm, -1, conf);\n  const cy = await layoutMindmap(mm, conf);\n  drawEdges(edgesElem, cy);\n  positionNodes(db2, cy);\n  (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_3__.setupGraphViewbox)(\n    void 0,\n    svg,\n    conf.mindmap?.padding ?? _chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_3__.defaultConfig_default.mindmap.padding,\n    conf.mindmap?.useMaxWidth ?? _chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_3__.defaultConfig_default.mindmap.useMaxWidth\n  );\n}, \"draw\");\nvar mindmapRenderer_default = {\n  draw\n};\n\n// src/diagrams/mindmap/styles.ts\n\nvar genSections = /* @__PURE__ */ (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_3__.__name)((options) => {\n  let sections = \"\";\n  for (let i = 0; i < options.THEME_COLOR_LIMIT; i++) {\n    options[\"lineColor\" + i] = options[\"lineColor\" + i] || options[\"cScaleInv\" + i];\n    if ((0,khroma__WEBPACK_IMPORTED_MODULE_7__[\"default\"])(options[\"lineColor\" + i])) {\n      options[\"lineColor\" + i] = (0,khroma__WEBPACK_IMPORTED_MODULE_8__[\"default\"])(options[\"lineColor\" + i], 20);\n    } else {\n      options[\"lineColor\" + i] = (0,khroma__WEBPACK_IMPORTED_MODULE_9__[\"default\"])(options[\"lineColor\" + i], 20);\n    }\n  }\n  for (let i = 0; i < options.THEME_COLOR_LIMIT; i++) {\n    const sw = \"\" + (17 - 3 * i);\n    sections += `\n    .section-${i - 1} rect, .section-${i - 1} path, .section-${i - 1} circle, .section-${i - 1} polygon, .section-${i - 1} path  {\n      fill: ${options[\"cScale\" + i]};\n    }\n    .section-${i - 1} text {\n     fill: ${options[\"cScaleLabel\" + i]};\n    }\n    .node-icon-${i - 1} {\n      font-size: 40px;\n      color: ${options[\"cScaleLabel\" + i]};\n    }\n    .section-edge-${i - 1}{\n      stroke: ${options[\"cScale\" + i]};\n    }\n    .edge-depth-${i - 1}{\n      stroke-width: ${sw};\n    }\n    .section-${i - 1} line {\n      stroke: ${options[\"cScaleInv\" + i]} ;\n      stroke-width: 3;\n    }\n\n    .disabled, .disabled circle, .disabled text {\n      fill: lightgray;\n    }\n    .disabled text {\n      fill: #efefef;\n    }\n    `;\n  }\n  return sections;\n}, \"genSections\");\nvar getStyles = /* @__PURE__ */ (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_3__.__name)((options) => `\n  .edge {\n    stroke-width: 3;\n  }\n  ${genSections(options)}\n  .section-root rect, .section-root path, .section-root circle, .section-root polygon  {\n    fill: ${options.git0};\n  }\n  .section-root text {\n    fill: ${options.gitBranchLabel0};\n  }\n  .icon-container {\n    height:100%;\n    display: flex;\n    justify-content: center;\n    align-items: center;\n  }\n  .edge {\n    fill: none;\n  }\n  .mindmap-node-label {\n    dy: 1em;\n    alignment-baseline: middle;\n    text-anchor: middle;\n    dominant-baseline: middle;\n    text-align: center;\n  }\n`, \"getStyles\");\nvar styles_default = getStyles;\n\n// src/diagrams/mindmap/mindmap-definition.ts\nvar diagram = {\n  db: mindmapDb_default,\n  renderer: mindmapRenderer_default,\n  parser: mindmap_default,\n  styles: styles_default\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbWVybWFpZC9kaXN0L2NodW5rcy9tZXJtYWlkLmNvcmUvbWluZG1hcC1kZWZpbml0aW9uLUdXSTZUUFRWLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUU4QjtBQUdBO0FBR0E7QUFRQTs7QUFFOUI7QUFDQTtBQUNBLDBCQUEwQiwyREFBTTtBQUNoQyxzQkFBc0IsZ0JBQWdCLEtBQUs7QUFDM0M7QUFDQSxHQUFHO0FBQ0g7QUFDQSwyQkFBMkIsMkRBQU07QUFDakMsS0FBSztBQUNMLFVBQVU7QUFDVixnQkFBZ0IsZ1ZBQWdWO0FBQ2hXLGtCQUFrQiw2S0FBNks7QUFDL0w7QUFDQSxtQ0FBbUMsMkRBQU07QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGNBQWM7QUFDMUM7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGVBQWU7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGNBQWM7QUFDMUM7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsY0FBYyxxQ0FBcUMsSUFBSSxRQUFRLElBQUksV0FBVyxJQUFJLG9DQUFvQyxJQUFJLHVHQUF1RyxvQkFBb0IsV0FBVyxvQ0FBb0MsZ0dBQWdHLElBQUksNEZBQTRGLElBQUksaUNBQWlDLG9CQUFvQixvRUFBb0UsMkhBQTJILGFBQWEsS0FBSyxhQUFhLElBQUksaUNBQWlDLElBQUksZ0dBQWdHLG9CQUFvQixpQkFBaUIseUdBQXlHLGFBQWEsSUFBSSxhQUFhLG9CQUFvQixpQkFBaUIsdUNBQXVDLGFBQWE7QUFDem9D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LDJEQUFNO0FBQ3hDO0FBQ0Esa0JBQWtCLCtCQUErQjtBQUNqRDtBQUNBLFFBQVEsa0RBQU07QUFDZCxpQ0FBaUMsa0RBQU87QUFDeEMsTUFBTTtBQUNOLGlDQUFpQyxrREFBTTtBQUN2QztBQUNBO0FBQ0Esa0JBQWtCLCtCQUErQjtBQUNqRDtBQUNBO0FBQ0EsZUFBZSxPQUFPLGlCQUFpQixPQUFPLGlCQUFpQixPQUFPLG1CQUFtQixPQUFPLG9CQUFvQixPQUFPO0FBQzNILGNBQWM7QUFDZDtBQUNBLGVBQWUsT0FBTztBQUN0QixhQUFhO0FBQ2I7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxlQUFlO0FBQ2Y7QUFDQSxvQkFBb0I7QUFDcEIsZ0JBQWdCO0FBQ2hCO0FBQ0Esa0JBQWtCO0FBQ2xCLHNCQUFzQjtBQUN0QjtBQUNBLGVBQWUsT0FBTztBQUN0QixnQkFBZ0I7QUFDaEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsZ0NBQWdDLDJEQUFNO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL21lcm1haWQvZGlzdC9jaHVua3MvbWVybWFpZC5jb3JlL21pbmRtYXAtZGVmaW5pdGlvbi1HV0k2VFBUVi5tanM/OWU3NiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBjcmVhdGVUZXh0XG59IGZyb20gXCIuL2NodW5rLTZKT1M3NERTLm1qc1wiO1xuaW1wb3J0IHtcbiAgcGFyc2VGb250U2l6ZVxufSBmcm9tIFwiLi9jaHVuay03REtSWktIRS5tanNcIjtcbmltcG9ydCB7XG4gIHNlbGVjdFN2Z0VsZW1lbnRcbn0gZnJvbSBcIi4vY2h1bmstRUo0WldYR0wubWpzXCI7XG5pbXBvcnQge1xuICBfX25hbWUsXG4gIGRlZmF1bHRDb25maWdfZGVmYXVsdCxcbiAgZ2V0Q29uZmlnMiBhcyBnZXRDb25maWcsXG4gIGxvZyxcbiAgc2FuaXRpemVUZXh0LFxuICBzZXR1cEdyYXBoVmlld2JveFxufSBmcm9tIFwiLi9jaHVuay02REJGRkhJUC5tanNcIjtcblxuLy8gc3JjL2RpYWdyYW1zL21pbmRtYXAvcGFyc2VyL21pbmRtYXAuamlzb25cbnZhciBwYXJzZXIgPSBmdW5jdGlvbigpIHtcbiAgdmFyIG8gPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKGZ1bmN0aW9uKGssIHYsIG8yLCBsKSB7XG4gICAgZm9yIChvMiA9IG8yIHx8IHt9LCBsID0gay5sZW5ndGg7IGwtLTsgbzJba1tsXV0gPSB2KSA7XG4gICAgcmV0dXJuIG8yO1xuICB9LCBcIm9cIiksICRWMCA9IFsxLCA0XSwgJFYxID0gWzEsIDEzXSwgJFYyID0gWzEsIDEyXSwgJFYzID0gWzEsIDE1XSwgJFY0ID0gWzEsIDE2XSwgJFY1ID0gWzEsIDIwXSwgJFY2ID0gWzEsIDE5XSwgJFY3ID0gWzYsIDcsIDhdLCAkVjggPSBbMSwgMjZdLCAkVjkgPSBbMSwgMjRdLCAkVmEgPSBbMSwgMjVdLCAkVmIgPSBbNiwgNywgMTFdLCAkVmMgPSBbMSwgNiwgMTMsIDE1LCAxNiwgMTksIDIyXSwgJFZkID0gWzEsIDMzXSwgJFZlID0gWzEsIDM0XSwgJFZmID0gWzEsIDYsIDcsIDExLCAxMywgMTUsIDE2LCAxOSwgMjJdO1xuICB2YXIgcGFyc2VyMiA9IHtcbiAgICB0cmFjZTogLyogQF9fUFVSRV9fICovIF9fbmFtZShmdW5jdGlvbiB0cmFjZSgpIHtcbiAgICB9LCBcInRyYWNlXCIpLFxuICAgIHl5OiB7fSxcbiAgICBzeW1ib2xzXzogeyBcImVycm9yXCI6IDIsIFwic3RhcnRcIjogMywgXCJtaW5kTWFwXCI6IDQsIFwic3BhY2VMaW5lc1wiOiA1LCBcIlNQQUNFTElORVwiOiA2LCBcIk5MXCI6IDcsIFwiTUlORE1BUFwiOiA4LCBcImRvY3VtZW50XCI6IDksIFwic3RvcFwiOiAxMCwgXCJFT0ZcIjogMTEsIFwic3RhdGVtZW50XCI6IDEyLCBcIlNQQUNFTElTVFwiOiAxMywgXCJub2RlXCI6IDE0LCBcIklDT05cIjogMTUsIFwiQ0xBU1NcIjogMTYsIFwibm9kZVdpdGhJZFwiOiAxNywgXCJub2RlV2l0aG91dElkXCI6IDE4LCBcIk5PREVfRFNUQVJUXCI6IDE5LCBcIk5PREVfREVTQ1JcIjogMjAsIFwiTk9ERV9ERU5EXCI6IDIxLCBcIk5PREVfSURcIjogMjIsIFwiJGFjY2VwdFwiOiAwLCBcIiRlbmRcIjogMSB9LFxuICAgIHRlcm1pbmFsc186IHsgMjogXCJlcnJvclwiLCA2OiBcIlNQQUNFTElORVwiLCA3OiBcIk5MXCIsIDg6IFwiTUlORE1BUFwiLCAxMTogXCJFT0ZcIiwgMTM6IFwiU1BBQ0VMSVNUXCIsIDE1OiBcIklDT05cIiwgMTY6IFwiQ0xBU1NcIiwgMTk6IFwiTk9ERV9EU1RBUlRcIiwgMjA6IFwiTk9ERV9ERVNDUlwiLCAyMTogXCJOT0RFX0RFTkRcIiwgMjI6IFwiTk9ERV9JRFwiIH0sXG4gICAgcHJvZHVjdGlvbnNfOiBbMCwgWzMsIDFdLCBbMywgMl0sIFs1LCAxXSwgWzUsIDJdLCBbNSwgMl0sIFs0LCAyXSwgWzQsIDNdLCBbMTAsIDFdLCBbMTAsIDFdLCBbMTAsIDFdLCBbMTAsIDJdLCBbMTAsIDJdLCBbOSwgM10sIFs5LCAyXSwgWzEyLCAyXSwgWzEyLCAyXSwgWzEyLCAyXSwgWzEyLCAxXSwgWzEyLCAxXSwgWzEyLCAxXSwgWzEyLCAxXSwgWzEyLCAxXSwgWzE0LCAxXSwgWzE0LCAxXSwgWzE4LCAzXSwgWzE3LCAxXSwgWzE3LCA0XV0sXG4gICAgcGVyZm9ybUFjdGlvbjogLyogQF9fUFVSRV9fICovIF9fbmFtZShmdW5jdGlvbiBhbm9ueW1vdXMoeXl0ZXh0LCB5eWxlbmcsIHl5bGluZW5vLCB5eSwgeXlzdGF0ZSwgJCQsIF8kKSB7XG4gICAgICB2YXIgJDAgPSAkJC5sZW5ndGggLSAxO1xuICAgICAgc3dpdGNoICh5eXN0YXRlKSB7XG4gICAgICAgIGNhc2UgNjpcbiAgICAgICAgY2FzZSA3OlxuICAgICAgICAgIHJldHVybiB5eTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA4OlxuICAgICAgICAgIHl5LmdldExvZ2dlcigpLnRyYWNlKFwiU3RvcCBOTCBcIik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgOTpcbiAgICAgICAgICB5eS5nZXRMb2dnZXIoKS50cmFjZShcIlN0b3AgRU9GIFwiKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICB5eS5nZXRMb2dnZXIoKS50cmFjZShcIlN0b3AgTkwyIFwiKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICB5eS5nZXRMb2dnZXIoKS50cmFjZShcIlN0b3AgRU9GMiBcIik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgeXkuZ2V0TG9nZ2VyKCkuaW5mbyhcIk5vZGU6IFwiLCAkJFskMF0uaWQpO1xuICAgICAgICAgIHl5LmFkZE5vZGUoJCRbJDAgLSAxXS5sZW5ndGgsICQkWyQwXS5pZCwgJCRbJDBdLmRlc2NyLCAkJFskMF0udHlwZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTY6XG4gICAgICAgICAgeXkuZ2V0TG9nZ2VyKCkudHJhY2UoXCJJY29uOiBcIiwgJCRbJDBdKTtcbiAgICAgICAgICB5eS5kZWNvcmF0ZU5vZGUoeyBpY29uOiAkJFskMF0gfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTc6XG4gICAgICAgIGNhc2UgMjE6XG4gICAgICAgICAgeXkuZGVjb3JhdGVOb2RlKHsgY2xhc3M6ICQkWyQwXSB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxODpcbiAgICAgICAgICB5eS5nZXRMb2dnZXIoKS50cmFjZShcIlNQQUNFTElTVFwiKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxOTpcbiAgICAgICAgICB5eS5nZXRMb2dnZXIoKS50cmFjZShcIk5vZGU6IFwiLCAkJFskMF0uaWQpO1xuICAgICAgICAgIHl5LmFkZE5vZGUoMCwgJCRbJDBdLmlkLCAkJFskMF0uZGVzY3IsICQkWyQwXS50eXBlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyMDpcbiAgICAgICAgICB5eS5kZWNvcmF0ZU5vZGUoeyBpY29uOiAkJFskMF0gfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjU6XG4gICAgICAgICAgeXkuZ2V0TG9nZ2VyKCkudHJhY2UoXCJub2RlIGZvdW5kIC4uXCIsICQkWyQwIC0gMl0pO1xuICAgICAgICAgIHRoaXMuJCA9IHsgaWQ6ICQkWyQwIC0gMV0sIGRlc2NyOiAkJFskMCAtIDFdLCB0eXBlOiB5eS5nZXRUeXBlKCQkWyQwIC0gMl0sICQkWyQwXSkgfTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyNjpcbiAgICAgICAgICB0aGlzLiQgPSB7IGlkOiAkJFskMF0sIGRlc2NyOiAkJFskMF0sIHR5cGU6IHl5Lm5vZGVUeXBlLkRFRkFVTFQgfTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyNzpcbiAgICAgICAgICB5eS5nZXRMb2dnZXIoKS50cmFjZShcIm5vZGUgZm91bmQgLi5cIiwgJCRbJDAgLSAzXSk7XG4gICAgICAgICAgdGhpcy4kID0geyBpZDogJCRbJDAgLSAzXSwgZGVzY3I6ICQkWyQwIC0gMV0sIHR5cGU6IHl5LmdldFR5cGUoJCRbJDAgLSAyXSwgJCRbJDBdKSB9O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0sIFwiYW5vbnltb3VzXCIpLFxuICAgIHRhYmxlOiBbeyAzOiAxLCA0OiAyLCA1OiAzLCA2OiBbMSwgNV0sIDg6ICRWMCB9LCB7IDE6IFszXSB9LCB7IDE6IFsyLCAxXSB9LCB7IDQ6IDYsIDY6IFsxLCA3XSwgNzogWzEsIDhdLCA4OiAkVjAgfSwgeyA2OiAkVjEsIDc6IFsxLCAxMF0sIDk6IDksIDEyOiAxMSwgMTM6ICRWMiwgMTQ6IDE0LCAxNTogJFYzLCAxNjogJFY0LCAxNzogMTcsIDE4OiAxOCwgMTk6ICRWNSwgMjI6ICRWNiB9LCBvKCRWNywgWzIsIDNdKSwgeyAxOiBbMiwgMl0gfSwgbygkVjcsIFsyLCA0XSksIG8oJFY3LCBbMiwgNV0pLCB7IDE6IFsyLCA2XSwgNjogJFYxLCAxMjogMjEsIDEzOiAkVjIsIDE0OiAxNCwgMTU6ICRWMywgMTY6ICRWNCwgMTc6IDE3LCAxODogMTgsIDE5OiAkVjUsIDIyOiAkVjYgfSwgeyA2OiAkVjEsIDk6IDIyLCAxMjogMTEsIDEzOiAkVjIsIDE0OiAxNCwgMTU6ICRWMywgMTY6ICRWNCwgMTc6IDE3LCAxODogMTgsIDE5OiAkVjUsIDIyOiAkVjYgfSwgeyA2OiAkVjgsIDc6ICRWOSwgMTA6IDIzLCAxMTogJFZhIH0sIG8oJFZiLCBbMiwgMjJdLCB7IDE3OiAxNywgMTg6IDE4LCAxNDogMjcsIDE1OiBbMSwgMjhdLCAxNjogWzEsIDI5XSwgMTk6ICRWNSwgMjI6ICRWNiB9KSwgbygkVmIsIFsyLCAxOF0pLCBvKCRWYiwgWzIsIDE5XSksIG8oJFZiLCBbMiwgMjBdKSwgbygkVmIsIFsyLCAyMV0pLCBvKCRWYiwgWzIsIDIzXSksIG8oJFZiLCBbMiwgMjRdKSwgbygkVmIsIFsyLCAyNl0sIHsgMTk6IFsxLCAzMF0gfSksIHsgMjA6IFsxLCAzMV0gfSwgeyA2OiAkVjgsIDc6ICRWOSwgMTA6IDMyLCAxMTogJFZhIH0sIHsgMTogWzIsIDddLCA2OiAkVjEsIDEyOiAyMSwgMTM6ICRWMiwgMTQ6IDE0LCAxNTogJFYzLCAxNjogJFY0LCAxNzogMTcsIDE4OiAxOCwgMTk6ICRWNSwgMjI6ICRWNiB9LCBvKCRWYywgWzIsIDE0XSwgeyA3OiAkVmQsIDExOiAkVmUgfSksIG8oJFZmLCBbMiwgOF0pLCBvKCRWZiwgWzIsIDldKSwgbygkVmYsIFsyLCAxMF0pLCBvKCRWYiwgWzIsIDE1XSksIG8oJFZiLCBbMiwgMTZdKSwgbygkVmIsIFsyLCAxN10pLCB7IDIwOiBbMSwgMzVdIH0sIHsgMjE6IFsxLCAzNl0gfSwgbygkVmMsIFsyLCAxM10sIHsgNzogJFZkLCAxMTogJFZlIH0pLCBvKCRWZiwgWzIsIDExXSksIG8oJFZmLCBbMiwgMTJdKSwgeyAyMTogWzEsIDM3XSB9LCBvKCRWYiwgWzIsIDI1XSksIG8oJFZiLCBbMiwgMjddKV0sXG4gICAgZGVmYXVsdEFjdGlvbnM6IHsgMjogWzIsIDFdLCA2OiBbMiwgMl0gfSxcbiAgICBwYXJzZUVycm9yOiAvKiBAX19QVVJFX18gKi8gX19uYW1lKGZ1bmN0aW9uIHBhcnNlRXJyb3Ioc3RyLCBoYXNoKSB7XG4gICAgICBpZiAoaGFzaC5yZWNvdmVyYWJsZSkge1xuICAgICAgICB0aGlzLnRyYWNlKHN0cik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3Ioc3RyKTtcbiAgICAgICAgZXJyb3IuaGFzaCA9IGhhc2g7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgIH0sIFwicGFyc2VFcnJvclwiKSxcbiAgICBwYXJzZTogLyogQF9fUFVSRV9fICovIF9fbmFtZShmdW5jdGlvbiBwYXJzZShpbnB1dCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzLCBzdGFjayA9IFswXSwgdHN0YWNrID0gW10sIHZzdGFjayA9IFtudWxsXSwgbHN0YWNrID0gW10sIHRhYmxlID0gdGhpcy50YWJsZSwgeXl0ZXh0ID0gXCJcIiwgeXlsaW5lbm8gPSAwLCB5eWxlbmcgPSAwLCByZWNvdmVyaW5nID0gMCwgVEVSUk9SID0gMiwgRU9GID0gMTtcbiAgICAgIHZhciBhcmdzID0gbHN0YWNrLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgIHZhciBsZXhlcjIgPSBPYmplY3QuY3JlYXRlKHRoaXMubGV4ZXIpO1xuICAgICAgdmFyIHNoYXJlZFN0YXRlID0geyB5eToge30gfTtcbiAgICAgIGZvciAodmFyIGsgaW4gdGhpcy55eSkge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMueXksIGspKSB7XG4gICAgICAgICAgc2hhcmVkU3RhdGUueXlba10gPSB0aGlzLnl5W2tdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBsZXhlcjIuc2V0SW5wdXQoaW5wdXQsIHNoYXJlZFN0YXRlLnl5KTtcbiAgICAgIHNoYXJlZFN0YXRlLnl5LmxleGVyID0gbGV4ZXIyO1xuICAgICAgc2hhcmVkU3RhdGUueXkucGFyc2VyID0gdGhpcztcbiAgICAgIGlmICh0eXBlb2YgbGV4ZXIyLnl5bGxvYyA9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIGxleGVyMi55eWxsb2MgPSB7fTtcbiAgICAgIH1cbiAgICAgIHZhciB5eWxvYyA9IGxleGVyMi55eWxsb2M7XG4gICAgICBsc3RhY2sucHVzaCh5eWxvYyk7XG4gICAgICB2YXIgcmFuZ2VzID0gbGV4ZXIyLm9wdGlvbnMgJiYgbGV4ZXIyLm9wdGlvbnMucmFuZ2VzO1xuICAgICAgaWYgKHR5cGVvZiBzaGFyZWRTdGF0ZS55eS5wYXJzZUVycm9yID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdGhpcy5wYXJzZUVycm9yID0gc2hhcmVkU3RhdGUueXkucGFyc2VFcnJvcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucGFyc2VFcnJvciA9IE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKS5wYXJzZUVycm9yO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gcG9wU3RhY2sobikge1xuICAgICAgICBzdGFjay5sZW5ndGggPSBzdGFjay5sZW5ndGggLSAyICogbjtcbiAgICAgICAgdnN0YWNrLmxlbmd0aCA9IHZzdGFjay5sZW5ndGggLSBuO1xuICAgICAgICBsc3RhY2subGVuZ3RoID0gbHN0YWNrLmxlbmd0aCAtIG47XG4gICAgICB9XG4gICAgICBfX25hbWUocG9wU3RhY2ssIFwicG9wU3RhY2tcIik7XG4gICAgICBmdW5jdGlvbiBsZXgoKSB7XG4gICAgICAgIHZhciB0b2tlbjtcbiAgICAgICAgdG9rZW4gPSB0c3RhY2sucG9wKCkgfHwgbGV4ZXIyLmxleCgpIHx8IEVPRjtcbiAgICAgICAgaWYgKHR5cGVvZiB0b2tlbiAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgIGlmICh0b2tlbiBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICB0c3RhY2sgPSB0b2tlbjtcbiAgICAgICAgICAgIHRva2VuID0gdHN0YWNrLnBvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0b2tlbiA9IHNlbGYuc3ltYm9sc19bdG9rZW5dIHx8IHRva2VuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgIH1cbiAgICAgIF9fbmFtZShsZXgsIFwibGV4XCIpO1xuICAgICAgdmFyIHN5bWJvbCwgcHJlRXJyb3JTeW1ib2wsIHN0YXRlLCBhY3Rpb24sIGEsIHIsIHl5dmFsID0ge30sIHAsIGxlbiwgbmV3U3RhdGUsIGV4cGVjdGVkO1xuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgc3RhdGUgPSBzdGFja1tzdGFjay5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYgKHRoaXMuZGVmYXVsdEFjdGlvbnNbc3RhdGVdKSB7XG4gICAgICAgICAgYWN0aW9uID0gdGhpcy5kZWZhdWx0QWN0aW9uc1tzdGF0ZV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHN5bWJvbCA9PT0gbnVsbCB8fCB0eXBlb2Ygc3ltYm9sID09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIHN5bWJvbCA9IGxleCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhY3Rpb24gPSB0YWJsZVtzdGF0ZV0gJiYgdGFibGVbc3RhdGVdW3N5bWJvbF07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBhY3Rpb24gPT09IFwidW5kZWZpbmVkXCIgfHwgIWFjdGlvbi5sZW5ndGggfHwgIWFjdGlvblswXSkge1xuICAgICAgICAgIHZhciBlcnJTdHIgPSBcIlwiO1xuICAgICAgICAgIGV4cGVjdGVkID0gW107XG4gICAgICAgICAgZm9yIChwIGluIHRhYmxlW3N0YXRlXSkge1xuICAgICAgICAgICAgaWYgKHRoaXMudGVybWluYWxzX1twXSAmJiBwID4gVEVSUk9SKSB7XG4gICAgICAgICAgICAgIGV4cGVjdGVkLnB1c2goXCInXCIgKyB0aGlzLnRlcm1pbmFsc19bcF0gKyBcIidcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChsZXhlcjIuc2hvd1Bvc2l0aW9uKSB7XG4gICAgICAgICAgICBlcnJTdHIgPSBcIlBhcnNlIGVycm9yIG9uIGxpbmUgXCIgKyAoeXlsaW5lbm8gKyAxKSArIFwiOlxcblwiICsgbGV4ZXIyLnNob3dQb3NpdGlvbigpICsgXCJcXG5FeHBlY3RpbmcgXCIgKyBleHBlY3RlZC5qb2luKFwiLCBcIikgKyBcIiwgZ290ICdcIiArICh0aGlzLnRlcm1pbmFsc19bc3ltYm9sXSB8fCBzeW1ib2wpICsgXCInXCI7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVyclN0ciA9IFwiUGFyc2UgZXJyb3Igb24gbGluZSBcIiArICh5eWxpbmVubyArIDEpICsgXCI6IFVuZXhwZWN0ZWQgXCIgKyAoc3ltYm9sID09IEVPRiA/IFwiZW5kIG9mIGlucHV0XCIgOiBcIidcIiArICh0aGlzLnRlcm1pbmFsc19bc3ltYm9sXSB8fCBzeW1ib2wpICsgXCInXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLnBhcnNlRXJyb3IoZXJyU3RyLCB7XG4gICAgICAgICAgICB0ZXh0OiBsZXhlcjIubWF0Y2gsXG4gICAgICAgICAgICB0b2tlbjogdGhpcy50ZXJtaW5hbHNfW3N5bWJvbF0gfHwgc3ltYm9sLFxuICAgICAgICAgICAgbGluZTogbGV4ZXIyLnl5bGluZW5vLFxuICAgICAgICAgICAgbG9jOiB5eWxvYyxcbiAgICAgICAgICAgIGV4cGVjdGVkXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFjdGlvblswXSBpbnN0YW5jZW9mIEFycmF5ICYmIGFjdGlvbi5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUGFyc2UgRXJyb3I6IG11bHRpcGxlIGFjdGlvbnMgcG9zc2libGUgYXQgc3RhdGU6IFwiICsgc3RhdGUgKyBcIiwgdG9rZW46IFwiICsgc3ltYm9sKTtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKGFjdGlvblswXSkge1xuICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIHN0YWNrLnB1c2goc3ltYm9sKTtcbiAgICAgICAgICAgIHZzdGFjay5wdXNoKGxleGVyMi55eXRleHQpO1xuICAgICAgICAgICAgbHN0YWNrLnB1c2gobGV4ZXIyLnl5bGxvYyk7XG4gICAgICAgICAgICBzdGFjay5wdXNoKGFjdGlvblsxXSk7XG4gICAgICAgICAgICBzeW1ib2wgPSBudWxsO1xuICAgICAgICAgICAgaWYgKCFwcmVFcnJvclN5bWJvbCkge1xuICAgICAgICAgICAgICB5eWxlbmcgPSBsZXhlcjIueXlsZW5nO1xuICAgICAgICAgICAgICB5eXRleHQgPSBsZXhlcjIueXl0ZXh0O1xuICAgICAgICAgICAgICB5eWxpbmVubyA9IGxleGVyMi55eWxpbmVubztcbiAgICAgICAgICAgICAgeXlsb2MgPSBsZXhlcjIueXlsbG9jO1xuICAgICAgICAgICAgICBpZiAocmVjb3ZlcmluZyA+IDApIHtcbiAgICAgICAgICAgICAgICByZWNvdmVyaW5nLS07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHN5bWJvbCA9IHByZUVycm9yU3ltYm9sO1xuICAgICAgICAgICAgICBwcmVFcnJvclN5bWJvbCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICBsZW4gPSB0aGlzLnByb2R1Y3Rpb25zX1thY3Rpb25bMV1dWzFdO1xuICAgICAgICAgICAgeXl2YWwuJCA9IHZzdGFja1t2c3RhY2subGVuZ3RoIC0gbGVuXTtcbiAgICAgICAgICAgIHl5dmFsLl8kID0ge1xuICAgICAgICAgICAgICBmaXJzdF9saW5lOiBsc3RhY2tbbHN0YWNrLmxlbmd0aCAtIChsZW4gfHwgMSldLmZpcnN0X2xpbmUsXG4gICAgICAgICAgICAgIGxhc3RfbGluZTogbHN0YWNrW2xzdGFjay5sZW5ndGggLSAxXS5sYXN0X2xpbmUsXG4gICAgICAgICAgICAgIGZpcnN0X2NvbHVtbjogbHN0YWNrW2xzdGFjay5sZW5ndGggLSAobGVuIHx8IDEpXS5maXJzdF9jb2x1bW4sXG4gICAgICAgICAgICAgIGxhc3RfY29sdW1uOiBsc3RhY2tbbHN0YWNrLmxlbmd0aCAtIDFdLmxhc3RfY29sdW1uXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHJhbmdlcykge1xuICAgICAgICAgICAgICB5eXZhbC5fJC5yYW5nZSA9IFtcbiAgICAgICAgICAgICAgICBsc3RhY2tbbHN0YWNrLmxlbmd0aCAtIChsZW4gfHwgMSldLnJhbmdlWzBdLFxuICAgICAgICAgICAgICAgIGxzdGFja1tsc3RhY2subGVuZ3RoIC0gMV0ucmFuZ2VbMV1cbiAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHIgPSB0aGlzLnBlcmZvcm1BY3Rpb24uYXBwbHkoeXl2YWwsIFtcbiAgICAgICAgICAgICAgeXl0ZXh0LFxuICAgICAgICAgICAgICB5eWxlbmcsXG4gICAgICAgICAgICAgIHl5bGluZW5vLFxuICAgICAgICAgICAgICBzaGFyZWRTdGF0ZS55eSxcbiAgICAgICAgICAgICAgYWN0aW9uWzFdLFxuICAgICAgICAgICAgICB2c3RhY2ssXG4gICAgICAgICAgICAgIGxzdGFja1xuICAgICAgICAgICAgXS5jb25jYXQoYXJncykpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiByICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgIHJldHVybiByO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxlbikge1xuICAgICAgICAgICAgICBzdGFjayA9IHN0YWNrLnNsaWNlKDAsIC0xICogbGVuICogMik7XG4gICAgICAgICAgICAgIHZzdGFjayA9IHZzdGFjay5zbGljZSgwLCAtMSAqIGxlbik7XG4gICAgICAgICAgICAgIGxzdGFjayA9IGxzdGFjay5zbGljZSgwLCAtMSAqIGxlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdGFjay5wdXNoKHRoaXMucHJvZHVjdGlvbnNfW2FjdGlvblsxXV1bMF0pO1xuICAgICAgICAgICAgdnN0YWNrLnB1c2goeXl2YWwuJCk7XG4gICAgICAgICAgICBsc3RhY2sucHVzaCh5eXZhbC5fJCk7XG4gICAgICAgICAgICBuZXdTdGF0ZSA9IHRhYmxlW3N0YWNrW3N0YWNrLmxlbmd0aCAtIDJdXVtzdGFja1tzdGFjay5sZW5ndGggLSAxXV07XG4gICAgICAgICAgICBzdGFjay5wdXNoKG5ld1N0YXRlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LCBcInBhcnNlXCIpXG4gIH07XG4gIHZhciBsZXhlciA9IC8qIEBfX1BVUkVfXyAqLyBmdW5jdGlvbigpIHtcbiAgICB2YXIgbGV4ZXIyID0ge1xuICAgICAgRU9GOiAxLFxuICAgICAgcGFyc2VFcnJvcjogLyogQF9fUFVSRV9fICovIF9fbmFtZShmdW5jdGlvbiBwYXJzZUVycm9yKHN0ciwgaGFzaCkge1xuICAgICAgICBpZiAodGhpcy55eS5wYXJzZXIpIHtcbiAgICAgICAgICB0aGlzLnl5LnBhcnNlci5wYXJzZUVycm9yKHN0ciwgaGFzaCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHN0cik7XG4gICAgICAgIH1cbiAgICAgIH0sIFwicGFyc2VFcnJvclwiKSxcbiAgICAgIC8vIHJlc2V0cyB0aGUgbGV4ZXIsIHNldHMgbmV3IGlucHV0XG4gICAgICBzZXRJbnB1dDogLyogQF9fUFVSRV9fICovIF9fbmFtZShmdW5jdGlvbihpbnB1dCwgeXkpIHtcbiAgICAgICAgdGhpcy55eSA9IHl5IHx8IHRoaXMueXkgfHwge307XG4gICAgICAgIHRoaXMuX2lucHV0ID0gaW5wdXQ7XG4gICAgICAgIHRoaXMuX21vcmUgPSB0aGlzLl9iYWNrdHJhY2sgPSB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy55eWxpbmVubyA9IHRoaXMueXlsZW5nID0gMDtcbiAgICAgICAgdGhpcy55eXRleHQgPSB0aGlzLm1hdGNoZWQgPSB0aGlzLm1hdGNoID0gXCJcIjtcbiAgICAgICAgdGhpcy5jb25kaXRpb25TdGFjayA9IFtcIklOSVRJQUxcIl07XG4gICAgICAgIHRoaXMueXlsbG9jID0ge1xuICAgICAgICAgIGZpcnN0X2xpbmU6IDEsXG4gICAgICAgICAgZmlyc3RfY29sdW1uOiAwLFxuICAgICAgICAgIGxhc3RfbGluZTogMSxcbiAgICAgICAgICBsYXN0X2NvbHVtbjogMFxuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnJhbmdlcykge1xuICAgICAgICAgIHRoaXMueXlsbG9jLnJhbmdlID0gWzAsIDBdO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub2Zmc2V0ID0gMDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LCBcInNldElucHV0XCIpLFxuICAgICAgLy8gY29uc3VtZXMgYW5kIHJldHVybnMgb25lIGNoYXIgZnJvbSB0aGUgaW5wdXRcbiAgICAgIGlucHV0OiAvKiBAX19QVVJFX18gKi8gX19uYW1lKGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY2ggPSB0aGlzLl9pbnB1dFswXTtcbiAgICAgICAgdGhpcy55eXRleHQgKz0gY2g7XG4gICAgICAgIHRoaXMueXlsZW5nKys7XG4gICAgICAgIHRoaXMub2Zmc2V0Kys7XG4gICAgICAgIHRoaXMubWF0Y2ggKz0gY2g7XG4gICAgICAgIHRoaXMubWF0Y2hlZCArPSBjaDtcbiAgICAgICAgdmFyIGxpbmVzID0gY2gubWF0Y2goLyg/Olxcclxcbj98XFxuKS4qL2cpO1xuICAgICAgICBpZiAobGluZXMpIHtcbiAgICAgICAgICB0aGlzLnl5bGluZW5vKys7XG4gICAgICAgICAgdGhpcy55eWxsb2MubGFzdF9saW5lKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy55eWxsb2MubGFzdF9jb2x1bW4rKztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnJhbmdlcykge1xuICAgICAgICAgIHRoaXMueXlsbG9jLnJhbmdlWzFdKys7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faW5wdXQgPSB0aGlzLl9pbnB1dC5zbGljZSgxKTtcbiAgICAgICAgcmV0dXJuIGNoO1xuICAgICAgfSwgXCJpbnB1dFwiKSxcbiAgICAgIC8vIHVuc2hpZnRzIG9uZSBjaGFyIChvciBhIHN0cmluZykgaW50byB0aGUgaW5wdXRcbiAgICAgIHVucHV0OiAvKiBAX19QVVJFX18gKi8gX19uYW1lKGZ1bmN0aW9uKGNoKSB7XG4gICAgICAgIHZhciBsZW4gPSBjaC5sZW5ndGg7XG4gICAgICAgIHZhciBsaW5lcyA9IGNoLnNwbGl0KC8oPzpcXHJcXG4/fFxcbikvZyk7XG4gICAgICAgIHRoaXMuX2lucHV0ID0gY2ggKyB0aGlzLl9pbnB1dDtcbiAgICAgICAgdGhpcy55eXRleHQgPSB0aGlzLnl5dGV4dC5zdWJzdHIoMCwgdGhpcy55eXRleHQubGVuZ3RoIC0gbGVuKTtcbiAgICAgICAgdGhpcy5vZmZzZXQgLT0gbGVuO1xuICAgICAgICB2YXIgb2xkTGluZXMgPSB0aGlzLm1hdGNoLnNwbGl0KC8oPzpcXHJcXG4/fFxcbikvZyk7XG4gICAgICAgIHRoaXMubWF0Y2ggPSB0aGlzLm1hdGNoLnN1YnN0cigwLCB0aGlzLm1hdGNoLmxlbmd0aCAtIDEpO1xuICAgICAgICB0aGlzLm1hdGNoZWQgPSB0aGlzLm1hdGNoZWQuc3Vic3RyKDAsIHRoaXMubWF0Y2hlZC5sZW5ndGggLSAxKTtcbiAgICAgICAgaWYgKGxpbmVzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICB0aGlzLnl5bGluZW5vIC09IGxpbmVzLmxlbmd0aCAtIDE7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHIgPSB0aGlzLnl5bGxvYy5yYW5nZTtcbiAgICAgICAgdGhpcy55eWxsb2MgPSB7XG4gICAgICAgICAgZmlyc3RfbGluZTogdGhpcy55eWxsb2MuZmlyc3RfbGluZSxcbiAgICAgICAgICBsYXN0X2xpbmU6IHRoaXMueXlsaW5lbm8gKyAxLFxuICAgICAgICAgIGZpcnN0X2NvbHVtbjogdGhpcy55eWxsb2MuZmlyc3RfY29sdW1uLFxuICAgICAgICAgIGxhc3RfY29sdW1uOiBsaW5lcyA/IChsaW5lcy5sZW5ndGggPT09IG9sZExpbmVzLmxlbmd0aCA/IHRoaXMueXlsbG9jLmZpcnN0X2NvbHVtbiA6IDApICsgb2xkTGluZXNbb2xkTGluZXMubGVuZ3RoIC0gbGluZXMubGVuZ3RoXS5sZW5ndGggLSBsaW5lc1swXS5sZW5ndGggOiB0aGlzLnl5bGxvYy5maXJzdF9jb2x1bW4gLSBsZW5cbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5yYW5nZXMpIHtcbiAgICAgICAgICB0aGlzLnl5bGxvYy5yYW5nZSA9IFtyWzBdLCByWzBdICsgdGhpcy55eWxlbmcgLSBsZW5dO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMueXlsZW5nID0gdGhpcy55eXRleHQubGVuZ3RoO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sIFwidW5wdXRcIiksXG4gICAgICAvLyBXaGVuIGNhbGxlZCBmcm9tIGFjdGlvbiwgY2FjaGVzIG1hdGNoZWQgdGV4dCBhbmQgYXBwZW5kcyBpdCBvbiBuZXh0IGFjdGlvblxuICAgICAgbW9yZTogLyogQF9fUFVSRV9fICovIF9fbmFtZShmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5fbW9yZSA9IHRydWU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSwgXCJtb3JlXCIpLFxuICAgICAgLy8gV2hlbiBjYWxsZWQgZnJvbSBhY3Rpb24sIHNpZ25hbHMgdGhlIGxleGVyIHRoYXQgdGhpcyBydWxlIGZhaWxzIHRvIG1hdGNoIHRoZSBpbnB1dCwgc28gdGhlIG5leHQgbWF0Y2hpbmcgcnVsZSAocmVnZXgpIHNob3VsZCBiZSB0ZXN0ZWQgaW5zdGVhZC5cbiAgICAgIHJlamVjdDogLyogQF9fUFVSRV9fICovIF9fbmFtZShmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5iYWNrdHJhY2tfbGV4ZXIpIHtcbiAgICAgICAgICB0aGlzLl9iYWNrdHJhY2sgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlRXJyb3IoXCJMZXhpY2FsIGVycm9yIG9uIGxpbmUgXCIgKyAodGhpcy55eWxpbmVubyArIDEpICsgXCIuIFlvdSBjYW4gb25seSBpbnZva2UgcmVqZWN0KCkgaW4gdGhlIGxleGVyIHdoZW4gdGhlIGxleGVyIGlzIG9mIHRoZSBiYWNrdHJhY2tpbmcgcGVyc3Vhc2lvbiAob3B0aW9ucy5iYWNrdHJhY2tfbGV4ZXIgPSB0cnVlKS5cXG5cIiArIHRoaXMuc2hvd1Bvc2l0aW9uKCksIHtcbiAgICAgICAgICAgIHRleHQ6IFwiXCIsXG4gICAgICAgICAgICB0b2tlbjogbnVsbCxcbiAgICAgICAgICAgIGxpbmU6IHRoaXMueXlsaW5lbm9cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sIFwicmVqZWN0XCIpLFxuICAgICAgLy8gcmV0YWluIGZpcnN0IG4gY2hhcmFjdGVycyBvZiB0aGUgbWF0Y2hcbiAgICAgIGxlc3M6IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoZnVuY3Rpb24obikge1xuICAgICAgICB0aGlzLnVucHV0KHRoaXMubWF0Y2guc2xpY2UobikpO1xuICAgICAgfSwgXCJsZXNzXCIpLFxuICAgICAgLy8gZGlzcGxheXMgYWxyZWFkeSBtYXRjaGVkIGlucHV0LCBpLmUuIGZvciBlcnJvciBtZXNzYWdlc1xuICAgICAgcGFzdElucHV0OiAvKiBAX19QVVJFX18gKi8gX19uYW1lKGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcGFzdCA9IHRoaXMubWF0Y2hlZC5zdWJzdHIoMCwgdGhpcy5tYXRjaGVkLmxlbmd0aCAtIHRoaXMubWF0Y2gubGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIChwYXN0Lmxlbmd0aCA+IDIwID8gXCIuLi5cIiA6IFwiXCIpICsgcGFzdC5zdWJzdHIoLTIwKS5yZXBsYWNlKC9cXG4vZywgXCJcIik7XG4gICAgICB9LCBcInBhc3RJbnB1dFwiKSxcbiAgICAgIC8vIGRpc3BsYXlzIHVwY29taW5nIGlucHV0LCBpLmUuIGZvciBlcnJvciBtZXNzYWdlc1xuICAgICAgdXBjb21pbmdJbnB1dDogLyogQF9fUFVSRV9fICovIF9fbmFtZShmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG5leHQgPSB0aGlzLm1hdGNoO1xuICAgICAgICBpZiAobmV4dC5sZW5ndGggPCAyMCkge1xuICAgICAgICAgIG5leHQgKz0gdGhpcy5faW5wdXQuc3Vic3RyKDAsIDIwIC0gbmV4dC5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAobmV4dC5zdWJzdHIoMCwgMjApICsgKG5leHQubGVuZ3RoID4gMjAgPyBcIi4uLlwiIDogXCJcIikpLnJlcGxhY2UoL1xcbi9nLCBcIlwiKTtcbiAgICAgIH0sIFwidXBjb21pbmdJbnB1dFwiKSxcbiAgICAgIC8vIGRpc3BsYXlzIHRoZSBjaGFyYWN0ZXIgcG9zaXRpb24gd2hlcmUgdGhlIGxleGluZyBlcnJvciBvY2N1cnJlZCwgaS5lLiBmb3IgZXJyb3IgbWVzc2FnZXNcbiAgICAgIHNob3dQb3NpdGlvbjogLyogQF9fUFVSRV9fICovIF9fbmFtZShmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHByZSA9IHRoaXMucGFzdElucHV0KCk7XG4gICAgICAgIHZhciBjID0gbmV3IEFycmF5KHByZS5sZW5ndGggKyAxKS5qb2luKFwiLVwiKTtcbiAgICAgICAgcmV0dXJuIHByZSArIHRoaXMudXBjb21pbmdJbnB1dCgpICsgXCJcXG5cIiArIGMgKyBcIl5cIjtcbiAgICAgIH0sIFwic2hvd1Bvc2l0aW9uXCIpLFxuICAgICAgLy8gdGVzdCB0aGUgbGV4ZWQgdG9rZW46IHJldHVybiBGQUxTRSB3aGVuIG5vdCBhIG1hdGNoLCBvdGhlcndpc2UgcmV0dXJuIHRva2VuXG4gICAgICB0ZXN0X21hdGNoOiAvKiBAX19QVVJFX18gKi8gX19uYW1lKGZ1bmN0aW9uKG1hdGNoLCBpbmRleGVkX3J1bGUpIHtcbiAgICAgICAgdmFyIHRva2VuLCBsaW5lcywgYmFja3VwO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmJhY2t0cmFja19sZXhlcikge1xuICAgICAgICAgIGJhY2t1cCA9IHtcbiAgICAgICAgICAgIHl5bGluZW5vOiB0aGlzLnl5bGluZW5vLFxuICAgICAgICAgICAgeXlsbG9jOiB7XG4gICAgICAgICAgICAgIGZpcnN0X2xpbmU6IHRoaXMueXlsbG9jLmZpcnN0X2xpbmUsXG4gICAgICAgICAgICAgIGxhc3RfbGluZTogdGhpcy5sYXN0X2xpbmUsXG4gICAgICAgICAgICAgIGZpcnN0X2NvbHVtbjogdGhpcy55eWxsb2MuZmlyc3RfY29sdW1uLFxuICAgICAgICAgICAgICBsYXN0X2NvbHVtbjogdGhpcy55eWxsb2MubGFzdF9jb2x1bW5cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB5eXRleHQ6IHRoaXMueXl0ZXh0LFxuICAgICAgICAgICAgbWF0Y2g6IHRoaXMubWF0Y2gsXG4gICAgICAgICAgICBtYXRjaGVzOiB0aGlzLm1hdGNoZXMsXG4gICAgICAgICAgICBtYXRjaGVkOiB0aGlzLm1hdGNoZWQsXG4gICAgICAgICAgICB5eWxlbmc6IHRoaXMueXlsZW5nLFxuICAgICAgICAgICAgb2Zmc2V0OiB0aGlzLm9mZnNldCxcbiAgICAgICAgICAgIF9tb3JlOiB0aGlzLl9tb3JlLFxuICAgICAgICAgICAgX2lucHV0OiB0aGlzLl9pbnB1dCxcbiAgICAgICAgICAgIHl5OiB0aGlzLnl5LFxuICAgICAgICAgICAgY29uZGl0aW9uU3RhY2s6IHRoaXMuY29uZGl0aW9uU3RhY2suc2xpY2UoMCksXG4gICAgICAgICAgICBkb25lOiB0aGlzLmRvbmVcbiAgICAgICAgICB9O1xuICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMucmFuZ2VzKSB7XG4gICAgICAgICAgICBiYWNrdXAueXlsbG9jLnJhbmdlID0gdGhpcy55eWxsb2MucmFuZ2Uuc2xpY2UoMCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxpbmVzID0gbWF0Y2hbMF0ubWF0Y2goLyg/Olxcclxcbj98XFxuKS4qL2cpO1xuICAgICAgICBpZiAobGluZXMpIHtcbiAgICAgICAgICB0aGlzLnl5bGluZW5vICs9IGxpbmVzLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnl5bGxvYyA9IHtcbiAgICAgICAgICBmaXJzdF9saW5lOiB0aGlzLnl5bGxvYy5sYXN0X2xpbmUsXG4gICAgICAgICAgbGFzdF9saW5lOiB0aGlzLnl5bGluZW5vICsgMSxcbiAgICAgICAgICBmaXJzdF9jb2x1bW46IHRoaXMueXlsbG9jLmxhc3RfY29sdW1uLFxuICAgICAgICAgIGxhc3RfY29sdW1uOiBsaW5lcyA/IGxpbmVzW2xpbmVzLmxlbmd0aCAtIDFdLmxlbmd0aCAtIGxpbmVzW2xpbmVzLmxlbmd0aCAtIDFdLm1hdGNoKC9cXHI/XFxuPy8pWzBdLmxlbmd0aCA6IHRoaXMueXlsbG9jLmxhc3RfY29sdW1uICsgbWF0Y2hbMF0ubGVuZ3RoXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMueXl0ZXh0ICs9IG1hdGNoWzBdO1xuICAgICAgICB0aGlzLm1hdGNoICs9IG1hdGNoWzBdO1xuICAgICAgICB0aGlzLm1hdGNoZXMgPSBtYXRjaDtcbiAgICAgICAgdGhpcy55eWxlbmcgPSB0aGlzLnl5dGV4dC5sZW5ndGg7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMucmFuZ2VzKSB7XG4gICAgICAgICAgdGhpcy55eWxsb2MucmFuZ2UgPSBbdGhpcy5vZmZzZXQsIHRoaXMub2Zmc2V0ICs9IHRoaXMueXlsZW5nXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9tb3JlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2JhY2t0cmFjayA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9pbnB1dCA9IHRoaXMuX2lucHV0LnNsaWNlKG1hdGNoWzBdLmxlbmd0aCk7XG4gICAgICAgIHRoaXMubWF0Y2hlZCArPSBtYXRjaFswXTtcbiAgICAgICAgdG9rZW4gPSB0aGlzLnBlcmZvcm1BY3Rpb24uY2FsbCh0aGlzLCB0aGlzLnl5LCB0aGlzLCBpbmRleGVkX3J1bGUsIHRoaXMuY29uZGl0aW9uU3RhY2tbdGhpcy5jb25kaXRpb25TdGFjay5sZW5ndGggLSAxXSk7XG4gICAgICAgIGlmICh0aGlzLmRvbmUgJiYgdGhpcy5faW5wdXQpIHtcbiAgICAgICAgICB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodG9rZW4pIHtcbiAgICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fYmFja3RyYWNrKSB7XG4gICAgICAgICAgZm9yICh2YXIgayBpbiBiYWNrdXApIHtcbiAgICAgICAgICAgIHRoaXNba10gPSBiYWNrdXBba107XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9LCBcInRlc3RfbWF0Y2hcIiksXG4gICAgICAvLyByZXR1cm4gbmV4dCBtYXRjaCBpbiBpbnB1dFxuICAgICAgbmV4dDogLyogQF9fUFVSRV9fICovIF9fbmFtZShmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuZG9uZSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLkVPRjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuX2lucHV0KSB7XG4gICAgICAgICAgdGhpcy5kb25lID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdG9rZW4sIG1hdGNoLCB0ZW1wTWF0Y2gsIGluZGV4O1xuICAgICAgICBpZiAoIXRoaXMuX21vcmUpIHtcbiAgICAgICAgICB0aGlzLnl5dGV4dCA9IFwiXCI7XG4gICAgICAgICAgdGhpcy5tYXRjaCA9IFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJ1bGVzID0gdGhpcy5fY3VycmVudFJ1bGVzKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcnVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB0ZW1wTWF0Y2ggPSB0aGlzLl9pbnB1dC5tYXRjaCh0aGlzLnJ1bGVzW3J1bGVzW2ldXSk7XG4gICAgICAgICAgaWYgKHRlbXBNYXRjaCAmJiAoIW1hdGNoIHx8IHRlbXBNYXRjaFswXS5sZW5ndGggPiBtYXRjaFswXS5sZW5ndGgpKSB7XG4gICAgICAgICAgICBtYXRjaCA9IHRlbXBNYXRjaDtcbiAgICAgICAgICAgIGluZGV4ID0gaTtcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYmFja3RyYWNrX2xleGVyKSB7XG4gICAgICAgICAgICAgIHRva2VuID0gdGhpcy50ZXN0X21hdGNoKHRlbXBNYXRjaCwgcnVsZXNbaV0pO1xuICAgICAgICAgICAgICBpZiAodG9rZW4gIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2JhY2t0cmFjaykge1xuICAgICAgICAgICAgICAgIG1hdGNoID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLm9wdGlvbnMuZmxleCkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgdG9rZW4gPSB0aGlzLnRlc3RfbWF0Y2gobWF0Y2gsIHJ1bGVzW2luZGV4XSk7XG4gICAgICAgICAgaWYgKHRva2VuICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2lucHV0ID09PSBcIlwiKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuRU9GO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlRXJyb3IoXCJMZXhpY2FsIGVycm9yIG9uIGxpbmUgXCIgKyAodGhpcy55eWxpbmVubyArIDEpICsgXCIuIFVucmVjb2duaXplZCB0ZXh0LlxcblwiICsgdGhpcy5zaG93UG9zaXRpb24oKSwge1xuICAgICAgICAgICAgdGV4dDogXCJcIixcbiAgICAgICAgICAgIHRva2VuOiBudWxsLFxuICAgICAgICAgICAgbGluZTogdGhpcy55eWxpbmVub1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9LCBcIm5leHRcIiksXG4gICAgICAvLyByZXR1cm4gbmV4dCBtYXRjaCB0aGF0IGhhcyBhIHRva2VuXG4gICAgICBsZXg6IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoZnVuY3Rpb24gbGV4KCkge1xuICAgICAgICB2YXIgciA9IHRoaXMubmV4dCgpO1xuICAgICAgICBpZiAocikge1xuICAgICAgICAgIHJldHVybiByO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB0aGlzLmxleCgpO1xuICAgICAgICB9XG4gICAgICB9LCBcImxleFwiKSxcbiAgICAgIC8vIGFjdGl2YXRlcyBhIG5ldyBsZXhlciBjb25kaXRpb24gc3RhdGUgKHB1c2hlcyB0aGUgbmV3IGxleGVyIGNvbmRpdGlvbiBzdGF0ZSBvbnRvIHRoZSBjb25kaXRpb24gc3RhY2spXG4gICAgICBiZWdpbjogLyogQF9fUFVSRV9fICovIF9fbmFtZShmdW5jdGlvbiBiZWdpbihjb25kaXRpb24pIHtcbiAgICAgICAgdGhpcy5jb25kaXRpb25TdGFjay5wdXNoKGNvbmRpdGlvbik7XG4gICAgICB9LCBcImJlZ2luXCIpLFxuICAgICAgLy8gcG9wIHRoZSBwcmV2aW91c2x5IGFjdGl2ZSBsZXhlciBjb25kaXRpb24gc3RhdGUgb2ZmIHRoZSBjb25kaXRpb24gc3RhY2tcbiAgICAgIHBvcFN0YXRlOiAvKiBAX19QVVJFX18gKi8gX19uYW1lKGZ1bmN0aW9uIHBvcFN0YXRlKCkge1xuICAgICAgICB2YXIgbiA9IHRoaXMuY29uZGl0aW9uU3RhY2subGVuZ3RoIC0gMTtcbiAgICAgICAgaWYgKG4gPiAwKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuY29uZGl0aW9uU3RhY2sucG9wKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuY29uZGl0aW9uU3RhY2tbMF07XG4gICAgICAgIH1cbiAgICAgIH0sIFwicG9wU3RhdGVcIiksXG4gICAgICAvLyBwcm9kdWNlIHRoZSBsZXhlciBydWxlIHNldCB3aGljaCBpcyBhY3RpdmUgZm9yIHRoZSBjdXJyZW50bHkgYWN0aXZlIGxleGVyIGNvbmRpdGlvbiBzdGF0ZVxuICAgICAgX2N1cnJlbnRSdWxlczogLyogQF9fUFVSRV9fICovIF9fbmFtZShmdW5jdGlvbiBfY3VycmVudFJ1bGVzKCkge1xuICAgICAgICBpZiAodGhpcy5jb25kaXRpb25TdGFjay5sZW5ndGggJiYgdGhpcy5jb25kaXRpb25TdGFja1t0aGlzLmNvbmRpdGlvblN0YWNrLmxlbmd0aCAtIDFdKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuY29uZGl0aW9uc1t0aGlzLmNvbmRpdGlvblN0YWNrW3RoaXMuY29uZGl0aW9uU3RhY2subGVuZ3RoIC0gMV1dLnJ1bGVzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB0aGlzLmNvbmRpdGlvbnNbXCJJTklUSUFMXCJdLnJ1bGVzO1xuICAgICAgICB9XG4gICAgICB9LCBcIl9jdXJyZW50UnVsZXNcIiksXG4gICAgICAvLyByZXR1cm4gdGhlIGN1cnJlbnRseSBhY3RpdmUgbGV4ZXIgY29uZGl0aW9uIHN0YXRlOyB3aGVuIGFuIGluZGV4IGFyZ3VtZW50IGlzIHByb3ZpZGVkIGl0IHByb2R1Y2VzIHRoZSBOLXRoIHByZXZpb3VzIGNvbmRpdGlvbiBzdGF0ZSwgaWYgYXZhaWxhYmxlXG4gICAgICB0b3BTdGF0ZTogLyogQF9fUFVSRV9fICovIF9fbmFtZShmdW5jdGlvbiB0b3BTdGF0ZShuKSB7XG4gICAgICAgIG4gPSB0aGlzLmNvbmRpdGlvblN0YWNrLmxlbmd0aCAtIDEgLSBNYXRoLmFicyhuIHx8IDApO1xuICAgICAgICBpZiAobiA+PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuY29uZGl0aW9uU3RhY2tbbl07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIFwiSU5JVElBTFwiO1xuICAgICAgICB9XG4gICAgICB9LCBcInRvcFN0YXRlXCIpLFxuICAgICAgLy8gYWxpYXMgZm9yIGJlZ2luKGNvbmRpdGlvbilcbiAgICAgIHB1c2hTdGF0ZTogLyogQF9fUFVSRV9fICovIF9fbmFtZShmdW5jdGlvbiBwdXNoU3RhdGUoY29uZGl0aW9uKSB7XG4gICAgICAgIHRoaXMuYmVnaW4oY29uZGl0aW9uKTtcbiAgICAgIH0sIFwicHVzaFN0YXRlXCIpLFxuICAgICAgLy8gcmV0dXJuIHRoZSBudW1iZXIgb2Ygc3RhdGVzIGN1cnJlbnRseSBvbiB0aGUgc3RhY2tcbiAgICAgIHN0YXRlU3RhY2tTaXplOiAvKiBAX19QVVJFX18gKi8gX19uYW1lKGZ1bmN0aW9uIHN0YXRlU3RhY2tTaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25kaXRpb25TdGFjay5sZW5ndGg7XG4gICAgICB9LCBcInN0YXRlU3RhY2tTaXplXCIpLFxuICAgICAgb3B0aW9uczogeyBcImNhc2UtaW5zZW5zaXRpdmVcIjogdHJ1ZSB9LFxuICAgICAgcGVyZm9ybUFjdGlvbjogLyogQF9fUFVSRV9fICovIF9fbmFtZShmdW5jdGlvbiBhbm9ueW1vdXMoeXksIHl5XywgJGF2b2lkaW5nX25hbWVfY29sbGlzaW9ucywgWVlfU1RBUlQpIHtcbiAgICAgICAgdmFyIFlZU1RBVEUgPSBZWV9TVEFSVDtcbiAgICAgICAgc3dpdGNoICgkYXZvaWRpbmdfbmFtZV9jb2xsaXNpb25zKSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgeXkuZ2V0TG9nZ2VyKCkudHJhY2UoXCJGb3VuZCBjb21tZW50XCIsIHl5Xy55eXRleHQpO1xuICAgICAgICAgICAgcmV0dXJuIDY7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICByZXR1cm4gODtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIHRoaXMuYmVnaW4oXCJDTEFTU1wiKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHRoaXMucG9wU3RhdGUoKTtcbiAgICAgICAgICAgIHJldHVybiAxNjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIHRoaXMucG9wU3RhdGUoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgIHl5LmdldExvZ2dlcigpLnRyYWNlKFwiQmVnaW4gaWNvblwiKTtcbiAgICAgICAgICAgIHRoaXMuYmVnaW4oXCJJQ09OXCIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgeXkuZ2V0TG9nZ2VyKCkudHJhY2UoXCJTUEFDRUxJTkVcIik7XG4gICAgICAgICAgICByZXR1cm4gNjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgIHJldHVybiA3O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgcmV0dXJuIDE1O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgeXkuZ2V0TG9nZ2VyKCkudHJhY2UoXCJlbmQgaWNvblwiKTtcbiAgICAgICAgICAgIHRoaXMucG9wU3RhdGUoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICB5eS5nZXRMb2dnZXIoKS50cmFjZShcIkV4cGxvZGluZyBub2RlXCIpO1xuICAgICAgICAgICAgdGhpcy5iZWdpbihcIk5PREVcIik7XG4gICAgICAgICAgICByZXR1cm4gMTk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgeXkuZ2V0TG9nZ2VyKCkudHJhY2UoXCJDbG91ZFwiKTtcbiAgICAgICAgICAgIHRoaXMuYmVnaW4oXCJOT0RFXCIpO1xuICAgICAgICAgICAgcmV0dXJuIDE5O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICAgIHl5LmdldExvZ2dlcigpLnRyYWNlKFwiRXhwbG9zaW9uIEJhbmdcIik7XG4gICAgICAgICAgICB0aGlzLmJlZ2luKFwiTk9ERVwiKTtcbiAgICAgICAgICAgIHJldHVybiAxOTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgICB5eS5nZXRMb2dnZXIoKS50cmFjZShcIkNsb3VkIEJhbmdcIik7XG4gICAgICAgICAgICB0aGlzLmJlZ2luKFwiTk9ERVwiKTtcbiAgICAgICAgICAgIHJldHVybiAxOTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMTQ6XG4gICAgICAgICAgICB0aGlzLmJlZ2luKFwiTk9ERVwiKTtcbiAgICAgICAgICAgIHJldHVybiAxOTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgICB0aGlzLmJlZ2luKFwiTk9ERVwiKTtcbiAgICAgICAgICAgIHJldHVybiAxOTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMTY6XG4gICAgICAgICAgICB0aGlzLmJlZ2luKFwiTk9ERVwiKTtcbiAgICAgICAgICAgIHJldHVybiAxOTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMTc6XG4gICAgICAgICAgICB0aGlzLmJlZ2luKFwiTk9ERVwiKTtcbiAgICAgICAgICAgIHJldHVybiAxOTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMTg6XG4gICAgICAgICAgICByZXR1cm4gMTM7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDE5OlxuICAgICAgICAgICAgcmV0dXJuIDIyO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAyMDpcbiAgICAgICAgICAgIHJldHVybiAxMTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMjE6XG4gICAgICAgICAgICB0aGlzLmJlZ2luKFwiTlNUUjJcIik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDIyOlxuICAgICAgICAgICAgcmV0dXJuIFwiTk9ERV9ERVNDUlwiO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAyMzpcbiAgICAgICAgICAgIHRoaXMucG9wU3RhdGUoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMjQ6XG4gICAgICAgICAgICB5eS5nZXRMb2dnZXIoKS50cmFjZShcIlN0YXJ0aW5nIE5TVFJcIik7XG4gICAgICAgICAgICB0aGlzLmJlZ2luKFwiTlNUUlwiKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMjU6XG4gICAgICAgICAgICB5eS5nZXRMb2dnZXIoKS50cmFjZShcImRlc2NyaXB0aW9uOlwiLCB5eV8ueXl0ZXh0KTtcbiAgICAgICAgICAgIHJldHVybiBcIk5PREVfREVTQ1JcIjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMjY6XG4gICAgICAgICAgICB0aGlzLnBvcFN0YXRlKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDI3OlxuICAgICAgICAgICAgdGhpcy5wb3BTdGF0ZSgpO1xuICAgICAgICAgICAgeXkuZ2V0TG9nZ2VyKCkudHJhY2UoXCJub2RlIGVuZCApKVwiKTtcbiAgICAgICAgICAgIHJldHVybiBcIk5PREVfREVORFwiO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAyODpcbiAgICAgICAgICAgIHRoaXMucG9wU3RhdGUoKTtcbiAgICAgICAgICAgIHl5LmdldExvZ2dlcigpLnRyYWNlKFwibm9kZSBlbmQgKVwiKTtcbiAgICAgICAgICAgIHJldHVybiBcIk5PREVfREVORFwiO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAyOTpcbiAgICAgICAgICAgIHRoaXMucG9wU3RhdGUoKTtcbiAgICAgICAgICAgIHl5LmdldExvZ2dlcigpLnRyYWNlKFwibm9kZSBlbmQgLi4uXCIsIHl5Xy55eXRleHQpO1xuICAgICAgICAgICAgcmV0dXJuIFwiTk9ERV9ERU5EXCI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDMwOlxuICAgICAgICAgICAgdGhpcy5wb3BTdGF0ZSgpO1xuICAgICAgICAgICAgeXkuZ2V0TG9nZ2VyKCkudHJhY2UoXCJub2RlIGVuZCAoKFwiKTtcbiAgICAgICAgICAgIHJldHVybiBcIk5PREVfREVORFwiO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAzMTpcbiAgICAgICAgICAgIHRoaXMucG9wU3RhdGUoKTtcbiAgICAgICAgICAgIHl5LmdldExvZ2dlcigpLnRyYWNlKFwibm9kZSBlbmQgKC1cIik7XG4gICAgICAgICAgICByZXR1cm4gXCJOT0RFX0RFTkRcIjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMzI6XG4gICAgICAgICAgICB0aGlzLnBvcFN0YXRlKCk7XG4gICAgICAgICAgICB5eS5nZXRMb2dnZXIoKS50cmFjZShcIm5vZGUgZW5kICgtXCIpO1xuICAgICAgICAgICAgcmV0dXJuIFwiTk9ERV9ERU5EXCI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDMzOlxuICAgICAgICAgICAgdGhpcy5wb3BTdGF0ZSgpO1xuICAgICAgICAgICAgeXkuZ2V0TG9nZ2VyKCkudHJhY2UoXCJub2RlIGVuZCAoKFwiKTtcbiAgICAgICAgICAgIHJldHVybiBcIk5PREVfREVORFwiO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAzNDpcbiAgICAgICAgICAgIHRoaXMucG9wU3RhdGUoKTtcbiAgICAgICAgICAgIHl5LmdldExvZ2dlcigpLnRyYWNlKFwibm9kZSBlbmQgKChcIik7XG4gICAgICAgICAgICByZXR1cm4gXCJOT0RFX0RFTkRcIjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMzU6XG4gICAgICAgICAgICB5eS5nZXRMb2dnZXIoKS50cmFjZShcIkxvbmcgZGVzY3JpcHRpb246XCIsIHl5Xy55eXRleHQpO1xuICAgICAgICAgICAgcmV0dXJuIDIwO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAzNjpcbiAgICAgICAgICAgIHl5LmdldExvZ2dlcigpLnRyYWNlKFwiTG9uZyBkZXNjcmlwdGlvbjpcIiwgeXlfLnl5dGV4dCk7XG4gICAgICAgICAgICByZXR1cm4gMjA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSwgXCJhbm9ueW1vdXNcIiksXG4gICAgICBydWxlczogWy9eKD86XFxzKiUlLiopL2ksIC9eKD86bWluZG1hcFxcYikvaSwgL14oPzo6OjopL2ksIC9eKD86LispL2ksIC9eKD86XFxuKS9pLCAvXig/Ojo6aWNvblxcKCkvaSwgL14oPzpbXFxzXStbXFxuXSkvaSwgL14oPzpbXFxuXSspL2ksIC9eKD86W15cXCldKykvaSwgL14oPzpcXCkpL2ksIC9eKD86LVxcKSkvaSwgL14oPzpcXCgtKS9pLCAvXig/OlxcKVxcKSkvaSwgL14oPzpcXCkpL2ksIC9eKD86XFwoXFwoKS9pLCAvXig/Olxce1xceykvaSwgL14oPzpcXCgpL2ksIC9eKD86XFxbKS9pLCAvXig/OltcXHNdKykvaSwgL14oPzpbXlxcKFxcW1xcblxcKVxce1xcfV0rKS9pLCAvXig/OiQpL2ksIC9eKD86W1wiXVtgXSkvaSwgL14oPzpbXmBcIl0rKS9pLCAvXig/OltgXVtcIl0pL2ksIC9eKD86W1wiXSkvaSwgL14oPzpbXlwiXSspL2ksIC9eKD86W1wiXSkvaSwgL14oPzpbXFwpXVxcKSkvaSwgL14oPzpbXFwpXSkvaSwgL14oPzpbXFxdXSkvaSwgL14oPzpcXH1cXH0pL2ksIC9eKD86XFwoLSkvaSwgL14oPzotXFwpKS9pLCAvXig/OlxcKFxcKCkvaSwgL14oPzpcXCgpL2ksIC9eKD86W15cXClcXF1cXChcXH1dKykvaSwgL14oPzouKyg/IVxcKFxcKCkpL2ldLFxuICAgICAgY29uZGl0aW9uczogeyBcIkNMQVNTXCI6IHsgXCJydWxlc1wiOiBbMywgNF0sIFwiaW5jbHVzaXZlXCI6IGZhbHNlIH0sIFwiSUNPTlwiOiB7IFwicnVsZXNcIjogWzgsIDldLCBcImluY2x1c2l2ZVwiOiBmYWxzZSB9LCBcIk5TVFIyXCI6IHsgXCJydWxlc1wiOiBbMjIsIDIzXSwgXCJpbmNsdXNpdmVcIjogZmFsc2UgfSwgXCJOU1RSXCI6IHsgXCJydWxlc1wiOiBbMjUsIDI2XSwgXCJpbmNsdXNpdmVcIjogZmFsc2UgfSwgXCJOT0RFXCI6IHsgXCJydWxlc1wiOiBbMjEsIDI0LCAyNywgMjgsIDI5LCAzMCwgMzEsIDMyLCAzMywgMzQsIDM1LCAzNl0sIFwiaW5jbHVzaXZlXCI6IGZhbHNlIH0sIFwiSU5JVElBTFwiOiB7IFwicnVsZXNcIjogWzAsIDEsIDIsIDUsIDYsIDcsIDEwLCAxMSwgMTIsIDEzLCAxNCwgMTUsIDE2LCAxNywgMTgsIDE5LCAyMF0sIFwiaW5jbHVzaXZlXCI6IHRydWUgfSB9XG4gICAgfTtcbiAgICByZXR1cm4gbGV4ZXIyO1xuICB9KCk7XG4gIHBhcnNlcjIubGV4ZXIgPSBsZXhlcjtcbiAgZnVuY3Rpb24gUGFyc2VyKCkge1xuICAgIHRoaXMueXkgPSB7fTtcbiAgfVxuICBfX25hbWUoUGFyc2VyLCBcIlBhcnNlclwiKTtcbiAgUGFyc2VyLnByb3RvdHlwZSA9IHBhcnNlcjI7XG4gIHBhcnNlcjIuUGFyc2VyID0gUGFyc2VyO1xuICByZXR1cm4gbmV3IFBhcnNlcigpO1xufSgpO1xucGFyc2VyLnBhcnNlciA9IHBhcnNlcjtcbnZhciBtaW5kbWFwX2RlZmF1bHQgPSBwYXJzZXI7XG5cbi8vIHNyYy9kaWFncmFtcy9taW5kbWFwL21pbmRtYXBEYi50c1xudmFyIG5vZGVzID0gW107XG52YXIgY250ID0gMDtcbnZhciBlbGVtZW50cyA9IHt9O1xudmFyIGNsZWFyID0gLyogQF9fUFVSRV9fICovIF9fbmFtZSgoKSA9PiB7XG4gIG5vZGVzID0gW107XG4gIGNudCA9IDA7XG4gIGVsZW1lbnRzID0ge307XG59LCBcImNsZWFyXCIpO1xudmFyIGdldFBhcmVudCA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoZnVuY3Rpb24obGV2ZWwpIHtcbiAgZm9yIChsZXQgaSA9IG5vZGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgaWYgKG5vZGVzW2ldLmxldmVsIDwgbGV2ZWwpIHtcbiAgICAgIHJldHVybiBub2Rlc1tpXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59LCBcImdldFBhcmVudFwiKTtcbnZhciBnZXRNaW5kbWFwID0gLyogQF9fUFVSRV9fICovIF9fbmFtZSgoKSA9PiB7XG4gIHJldHVybiBub2Rlcy5sZW5ndGggPiAwID8gbm9kZXNbMF0gOiBudWxsO1xufSwgXCJnZXRNaW5kbWFwXCIpO1xudmFyIGFkZE5vZGUgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKChsZXZlbCwgaWQsIGRlc2NyLCB0eXBlKSA9PiB7XG4gIGxvZy5pbmZvKFwiYWRkTm9kZVwiLCBsZXZlbCwgaWQsIGRlc2NyLCB0eXBlKTtcbiAgY29uc3QgY29uZiA9IGdldENvbmZpZygpO1xuICBsZXQgcGFkZGluZyA9IGNvbmYubWluZG1hcD8ucGFkZGluZyA/PyBkZWZhdWx0Q29uZmlnX2RlZmF1bHQubWluZG1hcC5wYWRkaW5nO1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIG5vZGVUeXBlLlJPVU5ERURfUkVDVDpcbiAgICBjYXNlIG5vZGVUeXBlLlJFQ1Q6XG4gICAgY2FzZSBub2RlVHlwZS5IRVhBR09OOlxuICAgICAgcGFkZGluZyAqPSAyO1xuICB9XG4gIGNvbnN0IG5vZGUgPSB7XG4gICAgaWQ6IGNudCsrLFxuICAgIG5vZGVJZDogc2FuaXRpemVUZXh0KGlkLCBjb25mKSxcbiAgICBsZXZlbCxcbiAgICBkZXNjcjogc2FuaXRpemVUZXh0KGRlc2NyLCBjb25mKSxcbiAgICB0eXBlLFxuICAgIGNoaWxkcmVuOiBbXSxcbiAgICB3aWR0aDogY29uZi5taW5kbWFwPy5tYXhOb2RlV2lkdGggPz8gZGVmYXVsdENvbmZpZ19kZWZhdWx0Lm1pbmRtYXAubWF4Tm9kZVdpZHRoLFxuICAgIHBhZGRpbmdcbiAgfTtcbiAgY29uc3QgcGFyZW50ID0gZ2V0UGFyZW50KGxldmVsKTtcbiAgaWYgKHBhcmVudCkge1xuICAgIHBhcmVudC5jaGlsZHJlbi5wdXNoKG5vZGUpO1xuICAgIG5vZGVzLnB1c2gobm9kZSk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKG5vZGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgbm9kZXMucHVzaChub2RlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnVGhlcmUgY2FuIGJlIG9ubHkgb25lIHJvb3QuIE5vIHBhcmVudCBjb3VsZCBiZSBmb3VuZCBmb3IgKFwiJyArIG5vZGUuZGVzY3IgKyAnXCIpJ1xuICAgICAgKTtcbiAgICB9XG4gIH1cbn0sIFwiYWRkTm9kZVwiKTtcbnZhciBub2RlVHlwZSA9IHtcbiAgREVGQVVMVDogMCxcbiAgTk9fQk9SREVSOiAwLFxuICBST1VOREVEX1JFQ1Q6IDEsXG4gIFJFQ1Q6IDIsXG4gIENJUkNMRTogMyxcbiAgQ0xPVUQ6IDQsXG4gIEJBTkc6IDUsXG4gIEhFWEFHT046IDZcbn07XG52YXIgZ2V0VHlwZSA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoKHN0YXJ0U3RyLCBlbmRTdHIpID0+IHtcbiAgbG9nLmRlYnVnKFwiSW4gZ2V0IHR5cGVcIiwgc3RhcnRTdHIsIGVuZFN0cik7XG4gIHN3aXRjaCAoc3RhcnRTdHIpIHtcbiAgICBjYXNlIFwiW1wiOlxuICAgICAgcmV0dXJuIG5vZGVUeXBlLlJFQ1Q7XG4gICAgY2FzZSBcIihcIjpcbiAgICAgIHJldHVybiBlbmRTdHIgPT09IFwiKVwiID8gbm9kZVR5cGUuUk9VTkRFRF9SRUNUIDogbm9kZVR5cGUuQ0xPVUQ7XG4gICAgY2FzZSBcIigoXCI6XG4gICAgICByZXR1cm4gbm9kZVR5cGUuQ0lSQ0xFO1xuICAgIGNhc2UgXCIpXCI6XG4gICAgICByZXR1cm4gbm9kZVR5cGUuQ0xPVUQ7XG4gICAgY2FzZSBcIikpXCI6XG4gICAgICByZXR1cm4gbm9kZVR5cGUuQkFORztcbiAgICBjYXNlIFwie3tcIjpcbiAgICAgIHJldHVybiBub2RlVHlwZS5IRVhBR09OO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gbm9kZVR5cGUuREVGQVVMVDtcbiAgfVxufSwgXCJnZXRUeXBlXCIpO1xudmFyIHNldEVsZW1lbnRGb3JJZCA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoKGlkLCBlbGVtZW50KSA9PiB7XG4gIGVsZW1lbnRzW2lkXSA9IGVsZW1lbnQ7XG59LCBcInNldEVsZW1lbnRGb3JJZFwiKTtcbnZhciBkZWNvcmF0ZU5vZGUgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKChkZWNvcmF0aW9uKSA9PiB7XG4gIGlmICghZGVjb3JhdGlvbikge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBjb25maWcgPSBnZXRDb25maWcoKTtcbiAgY29uc3Qgbm9kZSA9IG5vZGVzW25vZGVzLmxlbmd0aCAtIDFdO1xuICBpZiAoZGVjb3JhdGlvbi5pY29uKSB7XG4gICAgbm9kZS5pY29uID0gc2FuaXRpemVUZXh0KGRlY29yYXRpb24uaWNvbiwgY29uZmlnKTtcbiAgfVxuICBpZiAoZGVjb3JhdGlvbi5jbGFzcykge1xuICAgIG5vZGUuY2xhc3MgPSBzYW5pdGl6ZVRleHQoZGVjb3JhdGlvbi5jbGFzcywgY29uZmlnKTtcbiAgfVxufSwgXCJkZWNvcmF0ZU5vZGVcIik7XG52YXIgdHlwZTJTdHIgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKCh0eXBlKSA9PiB7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2Ugbm9kZVR5cGUuREVGQVVMVDpcbiAgICAgIHJldHVybiBcIm5vLWJvcmRlclwiO1xuICAgIGNhc2Ugbm9kZVR5cGUuUkVDVDpcbiAgICAgIHJldHVybiBcInJlY3RcIjtcbiAgICBjYXNlIG5vZGVUeXBlLlJPVU5ERURfUkVDVDpcbiAgICAgIHJldHVybiBcInJvdW5kZWQtcmVjdFwiO1xuICAgIGNhc2Ugbm9kZVR5cGUuQ0lSQ0xFOlxuICAgICAgcmV0dXJuIFwiY2lyY2xlXCI7XG4gICAgY2FzZSBub2RlVHlwZS5DTE9VRDpcbiAgICAgIHJldHVybiBcImNsb3VkXCI7XG4gICAgY2FzZSBub2RlVHlwZS5CQU5HOlxuICAgICAgcmV0dXJuIFwiYmFuZ1wiO1xuICAgIGNhc2Ugbm9kZVR5cGUuSEVYQUdPTjpcbiAgICAgIHJldHVybiBcImhleGdvblwiO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gXCJuby1ib3JkZXJcIjtcbiAgfVxufSwgXCJ0eXBlMlN0clwiKTtcbnZhciBnZXRMb2dnZXIgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKCgpID0+IGxvZywgXCJnZXRMb2dnZXJcIik7XG52YXIgZ2V0RWxlbWVudEJ5SWQgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKChpZCkgPT4gZWxlbWVudHNbaWRdLCBcImdldEVsZW1lbnRCeUlkXCIpO1xudmFyIGRiID0ge1xuICBjbGVhcixcbiAgYWRkTm9kZSxcbiAgZ2V0TWluZG1hcCxcbiAgbm9kZVR5cGUsXG4gIGdldFR5cGUsXG4gIHNldEVsZW1lbnRGb3JJZCxcbiAgZGVjb3JhdGVOb2RlLFxuICB0eXBlMlN0cixcbiAgZ2V0TG9nZ2VyLFxuICBnZXRFbGVtZW50QnlJZFxufTtcbnZhciBtaW5kbWFwRGJfZGVmYXVsdCA9IGRiO1xuXG4vLyBzcmMvZGlhZ3JhbXMvbWluZG1hcC9taW5kbWFwUmVuZGVyZXIudHNcbmltcG9ydCBjeXRvc2NhcGUgZnJvbSBcImN5dG9zY2FwZVwiO1xuaW1wb3J0IGNvc2VCaWxrZW50IGZyb20gXCJjeXRvc2NhcGUtY29zZS1iaWxrZW50XCI7XG5pbXBvcnQgeyBzZWxlY3QgfSBmcm9tIFwiZDNcIjtcblxuLy8gc3JjL2RpYWdyYW1zL21pbmRtYXAvc3ZnRHJhdy50c1xudmFyIE1BWF9TRUNUSU9OUyA9IDEyO1xudmFyIGRlZmF1bHRCa2cgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKGZ1bmN0aW9uKGRiMiwgZWxlbSwgbm9kZSwgc2VjdGlvbikge1xuICBjb25zdCByZCA9IDU7XG4gIGVsZW0uYXBwZW5kKFwicGF0aFwiKS5hdHRyKFwiaWRcIiwgXCJub2RlLVwiICsgbm9kZS5pZCkuYXR0cihcImNsYXNzXCIsIFwibm9kZS1ia2cgbm9kZS1cIiArIGRiMi50eXBlMlN0cihub2RlLnR5cGUpKS5hdHRyKFxuICAgIFwiZFwiLFxuICAgIGBNMCAke25vZGUuaGVpZ2h0IC0gcmR9IHYkey1ub2RlLmhlaWdodCArIDIgKiByZH0gcTAsLTUgNSwtNSBoJHtub2RlLndpZHRoIC0gMiAqIHJkfSBxNSwwIDUsNSB2JHtub2RlLmhlaWdodCAtIHJkfSBIMCBaYFxuICApO1xuICBlbGVtLmFwcGVuZChcImxpbmVcIikuYXR0cihcImNsYXNzXCIsIFwibm9kZS1saW5lLVwiICsgc2VjdGlvbikuYXR0cihcIngxXCIsIDApLmF0dHIoXCJ5MVwiLCBub2RlLmhlaWdodCkuYXR0cihcIngyXCIsIG5vZGUud2lkdGgpLmF0dHIoXCJ5MlwiLCBub2RlLmhlaWdodCk7XG59LCBcImRlZmF1bHRCa2dcIik7XG52YXIgcmVjdEJrZyA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoZnVuY3Rpb24oZGIyLCBlbGVtLCBub2RlKSB7XG4gIGVsZW0uYXBwZW5kKFwicmVjdFwiKS5hdHRyKFwiaWRcIiwgXCJub2RlLVwiICsgbm9kZS5pZCkuYXR0cihcImNsYXNzXCIsIFwibm9kZS1ia2cgbm9kZS1cIiArIGRiMi50eXBlMlN0cihub2RlLnR5cGUpKS5hdHRyKFwiaGVpZ2h0XCIsIG5vZGUuaGVpZ2h0KS5hdHRyKFwid2lkdGhcIiwgbm9kZS53aWR0aCk7XG59LCBcInJlY3RCa2dcIik7XG52YXIgY2xvdWRCa2cgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKGZ1bmN0aW9uKGRiMiwgZWxlbSwgbm9kZSkge1xuICBjb25zdCB3ID0gbm9kZS53aWR0aDtcbiAgY29uc3QgaCA9IG5vZGUuaGVpZ2h0O1xuICBjb25zdCByMSA9IDAuMTUgKiB3O1xuICBjb25zdCByMiA9IDAuMjUgKiB3O1xuICBjb25zdCByMyA9IDAuMzUgKiB3O1xuICBjb25zdCByNCA9IDAuMiAqIHc7XG4gIGVsZW0uYXBwZW5kKFwicGF0aFwiKS5hdHRyKFwiaWRcIiwgXCJub2RlLVwiICsgbm9kZS5pZCkuYXR0cihcImNsYXNzXCIsIFwibm9kZS1ia2cgbm9kZS1cIiArIGRiMi50eXBlMlN0cihub2RlLnR5cGUpKS5hdHRyKFxuICAgIFwiZFwiLFxuICAgIGBNMCAwIGEke3IxfSwke3IxfSAwIDAsMSAke3cgKiAwLjI1fSwkey0xICogdyAqIDAuMX1cbiAgICAgIGEke3IzfSwke3IzfSAxIDAsMSAke3cgKiAwLjR9LCR7LTEgKiB3ICogMC4xfVxuICAgICAgYSR7cjJ9LCR7cjJ9IDEgMCwxICR7dyAqIDAuMzV9LCR7MSAqIHcgKiAwLjJ9XG5cbiAgICAgIGEke3IxfSwke3IxfSAxIDAsMSAke3cgKiAwLjE1fSwkezEgKiBoICogMC4zNX1cbiAgICAgIGEke3I0fSwke3I0fSAxIDAsMSAkey0xICogdyAqIDAuMTV9LCR7MSAqIGggKiAwLjY1fVxuXG4gICAgICBhJHtyMn0sJHtyMX0gMSAwLDEgJHstMSAqIHcgKiAwLjI1fSwke3cgKiAwLjE1fVxuICAgICAgYSR7cjN9LCR7cjN9IDEgMCwxICR7LTEgKiB3ICogMC41fSwkezB9XG4gICAgICBhJHtyMX0sJHtyMX0gMSAwLDEgJHstMSAqIHcgKiAwLjI1fSwkey0xICogdyAqIDAuMTV9XG5cbiAgICAgIGEke3IxfSwke3IxfSAxIDAsMSAkey0xICogdyAqIDAuMX0sJHstMSAqIGggKiAwLjM1fVxuICAgICAgYSR7cjR9LCR7cjR9IDEgMCwxICR7dyAqIDAuMX0sJHstMSAqIGggKiAwLjY1fVxuXG4gICAgSDAgVjAgWmBcbiAgKTtcbn0sIFwiY2xvdWRCa2dcIik7XG52YXIgYmFuZ0JrZyA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoZnVuY3Rpb24oZGIyLCBlbGVtLCBub2RlKSB7XG4gIGNvbnN0IHcgPSBub2RlLndpZHRoO1xuICBjb25zdCBoID0gbm9kZS5oZWlnaHQ7XG4gIGNvbnN0IHIgPSAwLjE1ICogdztcbiAgZWxlbS5hcHBlbmQoXCJwYXRoXCIpLmF0dHIoXCJpZFwiLCBcIm5vZGUtXCIgKyBub2RlLmlkKS5hdHRyKFwiY2xhc3NcIiwgXCJub2RlLWJrZyBub2RlLVwiICsgZGIyLnR5cGUyU3RyKG5vZGUudHlwZSkpLmF0dHIoXG4gICAgXCJkXCIsXG4gICAgYE0wIDAgYSR7cn0sJHtyfSAxIDAsMCAke3cgKiAwLjI1fSwkey0xICogaCAqIDAuMX1cbiAgICAgIGEke3J9LCR7cn0gMSAwLDAgJHt3ICogMC4yNX0sJHswfVxuICAgICAgYSR7cn0sJHtyfSAxIDAsMCAke3cgKiAwLjI1fSwkezB9XG4gICAgICBhJHtyfSwke3J9IDEgMCwwICR7dyAqIDAuMjV9LCR7MSAqIGggKiAwLjF9XG5cbiAgICAgIGEke3J9LCR7cn0gMSAwLDAgJHt3ICogMC4xNX0sJHsxICogaCAqIDAuMzN9XG4gICAgICBhJHtyICogMC44fSwke3IgKiAwLjh9IDEgMCwwICR7MH0sJHsxICogaCAqIDAuMzR9XG4gICAgICBhJHtyfSwke3J9IDEgMCwwICR7LTEgKiB3ICogMC4xNX0sJHsxICogaCAqIDAuMzN9XG5cbiAgICAgIGEke3J9LCR7cn0gMSAwLDAgJHstMSAqIHcgKiAwLjI1fSwke2ggKiAwLjE1fVxuICAgICAgYSR7cn0sJHtyfSAxIDAsMCAkey0xICogdyAqIDAuMjV9LCR7MH1cbiAgICAgIGEke3J9LCR7cn0gMSAwLDAgJHstMSAqIHcgKiAwLjI1fSwkezB9XG4gICAgICBhJHtyfSwke3J9IDEgMCwwICR7LTEgKiB3ICogMC4yNX0sJHstMSAqIGggKiAwLjE1fVxuXG4gICAgICBhJHtyfSwke3J9IDEgMCwwICR7LTEgKiB3ICogMC4xfSwkey0xICogaCAqIDAuMzN9XG4gICAgICBhJHtyICogMC44fSwke3IgKiAwLjh9IDEgMCwwICR7MH0sJHstMSAqIGggKiAwLjM0fVxuICAgICAgYSR7cn0sJHtyfSAxIDAsMCAke3cgKiAwLjF9LCR7LTEgKiBoICogMC4zM31cblxuICAgIEgwIFYwIFpgXG4gICk7XG59LCBcImJhbmdCa2dcIik7XG52YXIgY2lyY2xlQmtnID0gLyogQF9fUFVSRV9fICovIF9fbmFtZShmdW5jdGlvbihkYjIsIGVsZW0sIG5vZGUpIHtcbiAgZWxlbS5hcHBlbmQoXCJjaXJjbGVcIikuYXR0cihcImlkXCIsIFwibm9kZS1cIiArIG5vZGUuaWQpLmF0dHIoXCJjbGFzc1wiLCBcIm5vZGUtYmtnIG5vZGUtXCIgKyBkYjIudHlwZTJTdHIobm9kZS50eXBlKSkuYXR0cihcInJcIiwgbm9kZS53aWR0aCAvIDIpO1xufSwgXCJjaXJjbGVCa2dcIik7XG5mdW5jdGlvbiBpbnNlcnRQb2x5Z29uU2hhcGUocGFyZW50LCB3LCBoLCBwb2ludHMsIG5vZGUpIHtcbiAgcmV0dXJuIHBhcmVudC5pbnNlcnQoXCJwb2x5Z29uXCIsIFwiOmZpcnN0LWNoaWxkXCIpLmF0dHIoXG4gICAgXCJwb2ludHNcIixcbiAgICBwb2ludHMubWFwKGZ1bmN0aW9uKGQpIHtcbiAgICAgIHJldHVybiBkLnggKyBcIixcIiArIGQueTtcbiAgICB9KS5qb2luKFwiIFwiKVxuICApLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoXCIgKyAobm9kZS53aWR0aCAtIHcpIC8gMiArIFwiLCBcIiArIGggKyBcIilcIik7XG59XG5fX25hbWUoaW5zZXJ0UG9seWdvblNoYXBlLCBcImluc2VydFBvbHlnb25TaGFwZVwiKTtcbnZhciBoZXhhZ29uQmtnID0gLyogQF9fUFVSRV9fICovIF9fbmFtZShmdW5jdGlvbihfZGIsIGVsZW0sIG5vZGUpIHtcbiAgY29uc3QgaCA9IG5vZGUuaGVpZ2h0O1xuICBjb25zdCBmID0gNDtcbiAgY29uc3QgbSA9IGggLyBmO1xuICBjb25zdCB3ID0gbm9kZS53aWR0aCAtIG5vZGUucGFkZGluZyArIDIgKiBtO1xuICBjb25zdCBwb2ludHMgPSBbXG4gICAgeyB4OiBtLCB5OiAwIH0sXG4gICAgeyB4OiB3IC0gbSwgeTogMCB9LFxuICAgIHsgeDogdywgeTogLWggLyAyIH0sXG4gICAgeyB4OiB3IC0gbSwgeTogLWggfSxcbiAgICB7IHg6IG0sIHk6IC1oIH0sXG4gICAgeyB4OiAwLCB5OiAtaCAvIDIgfVxuICBdO1xuICBpbnNlcnRQb2x5Z29uU2hhcGUoZWxlbSwgdywgaCwgcG9pbnRzLCBub2RlKTtcbn0sIFwiaGV4YWdvbkJrZ1wiKTtcbnZhciByb3VuZGVkUmVjdEJrZyA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoZnVuY3Rpb24oZGIyLCBlbGVtLCBub2RlKSB7XG4gIGVsZW0uYXBwZW5kKFwicmVjdFwiKS5hdHRyKFwiaWRcIiwgXCJub2RlLVwiICsgbm9kZS5pZCkuYXR0cihcImNsYXNzXCIsIFwibm9kZS1ia2cgbm9kZS1cIiArIGRiMi50eXBlMlN0cihub2RlLnR5cGUpKS5hdHRyKFwiaGVpZ2h0XCIsIG5vZGUuaGVpZ2h0KS5hdHRyKFwicnhcIiwgbm9kZS5wYWRkaW5nKS5hdHRyKFwicnlcIiwgbm9kZS5wYWRkaW5nKS5hdHRyKFwid2lkdGhcIiwgbm9kZS53aWR0aCk7XG59LCBcInJvdW5kZWRSZWN0QmtnXCIpO1xudmFyIGRyYXdOb2RlID0gLyogQF9fUFVSRV9fICovIF9fbmFtZShhc3luYyBmdW5jdGlvbihkYjIsIGVsZW0sIG5vZGUsIGZ1bGxTZWN0aW9uLCBjb25mKSB7XG4gIGNvbnN0IGh0bWxMYWJlbHMgPSBjb25mLmh0bWxMYWJlbHM7XG4gIGNvbnN0IHNlY3Rpb24gPSBmdWxsU2VjdGlvbiAlIChNQVhfU0VDVElPTlMgLSAxKTtcbiAgY29uc3Qgbm9kZUVsZW0gPSBlbGVtLmFwcGVuZChcImdcIik7XG4gIG5vZGUuc2VjdGlvbiA9IHNlY3Rpb247XG4gIGxldCBzZWN0aW9uQ2xhc3MgPSBcInNlY3Rpb24tXCIgKyBzZWN0aW9uO1xuICBpZiAoc2VjdGlvbiA8IDApIHtcbiAgICBzZWN0aW9uQ2xhc3MgKz0gXCIgc2VjdGlvbi1yb290XCI7XG4gIH1cbiAgbm9kZUVsZW0uYXR0cihcImNsYXNzXCIsIChub2RlLmNsYXNzID8gbm9kZS5jbGFzcyArIFwiIFwiIDogXCJcIikgKyBcIm1pbmRtYXAtbm9kZSBcIiArIHNlY3Rpb25DbGFzcyk7XG4gIGNvbnN0IGJrZ0VsZW0gPSBub2RlRWxlbS5hcHBlbmQoXCJnXCIpO1xuICBjb25zdCB0ZXh0RWxlbSA9IG5vZGVFbGVtLmFwcGVuZChcImdcIik7XG4gIGNvbnN0IGRlc2NyaXB0aW9uID0gbm9kZS5kZXNjci5yZXBsYWNlKC8oPGJyXFwvKj4pL2csIFwiXFxuXCIpO1xuICBhd2FpdCBjcmVhdGVUZXh0KFxuICAgIHRleHRFbGVtLFxuICAgIGRlc2NyaXB0aW9uLFxuICAgIHtcbiAgICAgIHVzZUh0bWxMYWJlbHM6IGh0bWxMYWJlbHMsXG4gICAgICB3aWR0aDogbm9kZS53aWR0aCxcbiAgICAgIGNsYXNzZXM6IFwibWluZG1hcC1ub2RlLWxhYmVsXCJcbiAgICB9LFxuICAgIGNvbmZcbiAgKTtcbiAgaWYgKCFodG1sTGFiZWxzKSB7XG4gICAgdGV4dEVsZW0uYXR0cihcImR5XCIsIFwiMWVtXCIpLmF0dHIoXCJhbGlnbm1lbnQtYmFzZWxpbmVcIiwgXCJtaWRkbGVcIikuYXR0cihcImRvbWluYW50LWJhc2VsaW5lXCIsIFwibWlkZGxlXCIpLmF0dHIoXCJ0ZXh0LWFuY2hvclwiLCBcIm1pZGRsZVwiKTtcbiAgfVxuICBjb25zdCBiYm94ID0gdGV4dEVsZW0ubm9kZSgpLmdldEJCb3goKTtcbiAgY29uc3QgW2ZvbnRTaXplXSA9IHBhcnNlRm9udFNpemUoY29uZi5mb250U2l6ZSk7XG4gIG5vZGUuaGVpZ2h0ID0gYmJveC5oZWlnaHQgKyBmb250U2l6ZSAqIDEuMSAqIDAuNSArIG5vZGUucGFkZGluZztcbiAgbm9kZS53aWR0aCA9IGJib3gud2lkdGggKyAyICogbm9kZS5wYWRkaW5nO1xuICBpZiAobm9kZS5pY29uKSB7XG4gICAgaWYgKG5vZGUudHlwZSA9PT0gZGIyLm5vZGVUeXBlLkNJUkNMRSkge1xuICAgICAgbm9kZS5oZWlnaHQgKz0gNTA7XG4gICAgICBub2RlLndpZHRoICs9IDUwO1xuICAgICAgY29uc3QgaWNvbiA9IG5vZGVFbGVtLmFwcGVuZChcImZvcmVpZ25PYmplY3RcIikuYXR0cihcImhlaWdodFwiLCBcIjUwcHhcIikuYXR0cihcIndpZHRoXCIsIG5vZGUud2lkdGgpLmF0dHIoXCJzdHlsZVwiLCBcInRleHQtYWxpZ246IGNlbnRlcjtcIik7XG4gICAgICBpY29uLmFwcGVuZChcImRpdlwiKS5hdHRyKFwiY2xhc3NcIiwgXCJpY29uLWNvbnRhaW5lclwiKS5hcHBlbmQoXCJpXCIpLmF0dHIoXCJjbGFzc1wiLCBcIm5vZGUtaWNvbi1cIiArIHNlY3Rpb24gKyBcIiBcIiArIG5vZGUuaWNvbik7XG4gICAgICB0ZXh0RWxlbS5hdHRyKFxuICAgICAgICBcInRyYW5zZm9ybVwiLFxuICAgICAgICBcInRyYW5zbGF0ZShcIiArIG5vZGUud2lkdGggLyAyICsgXCIsIFwiICsgKG5vZGUuaGVpZ2h0IC8gMiAtIDEuNSAqIG5vZGUucGFkZGluZykgKyBcIilcIlxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZS53aWR0aCArPSA1MDtcbiAgICAgIGNvbnN0IG9yZ0hlaWdodCA9IG5vZGUuaGVpZ2h0O1xuICAgICAgbm9kZS5oZWlnaHQgPSBNYXRoLm1heChvcmdIZWlnaHQsIDYwKTtcbiAgICAgIGNvbnN0IGhlaWdodERpZmYgPSBNYXRoLmFicyhub2RlLmhlaWdodCAtIG9yZ0hlaWdodCk7XG4gICAgICBjb25zdCBpY29uID0gbm9kZUVsZW0uYXBwZW5kKFwiZm9yZWlnbk9iamVjdFwiKS5hdHRyKFwid2lkdGhcIiwgXCI2MHB4XCIpLmF0dHIoXCJoZWlnaHRcIiwgbm9kZS5oZWlnaHQpLmF0dHIoXCJzdHlsZVwiLCBcInRleHQtYWxpZ246IGNlbnRlcjttYXJnaW4tdG9wOlwiICsgaGVpZ2h0RGlmZiAvIDIgKyBcInB4O1wiKTtcbiAgICAgIGljb24uYXBwZW5kKFwiZGl2XCIpLmF0dHIoXCJjbGFzc1wiLCBcImljb24tY29udGFpbmVyXCIpLmFwcGVuZChcImlcIikuYXR0cihcImNsYXNzXCIsIFwibm9kZS1pY29uLVwiICsgc2VjdGlvbiArIFwiIFwiICsgbm9kZS5pY29uKTtcbiAgICAgIHRleHRFbGVtLmF0dHIoXG4gICAgICAgIFwidHJhbnNmb3JtXCIsXG4gICAgICAgIFwidHJhbnNsYXRlKFwiICsgKDI1ICsgbm9kZS53aWR0aCAvIDIpICsgXCIsIFwiICsgKGhlaWdodERpZmYgLyAyICsgbm9kZS5wYWRkaW5nIC8gMikgKyBcIilcIlxuICAgICAgKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKCFodG1sTGFiZWxzKSB7XG4gICAgICBjb25zdCBkeCA9IG5vZGUud2lkdGggLyAyO1xuICAgICAgY29uc3QgZHkgPSBub2RlLnBhZGRpbmcgLyAyO1xuICAgICAgdGV4dEVsZW0uYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZShcIiArIGR4ICsgXCIsIFwiICsgZHkgKyBcIilcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGR4ID0gKG5vZGUud2lkdGggLSBiYm94LndpZHRoKSAvIDI7XG4gICAgICBjb25zdCBkeSA9IChub2RlLmhlaWdodCAtIGJib3guaGVpZ2h0KSAvIDI7XG4gICAgICB0ZXh0RWxlbS5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKFwiICsgZHggKyBcIiwgXCIgKyBkeSArIFwiKVwiKTtcbiAgICB9XG4gIH1cbiAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICBjYXNlIGRiMi5ub2RlVHlwZS5ERUZBVUxUOlxuICAgICAgZGVmYXVsdEJrZyhkYjIsIGJrZ0VsZW0sIG5vZGUsIHNlY3Rpb24pO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBkYjIubm9kZVR5cGUuUk9VTkRFRF9SRUNUOlxuICAgICAgcm91bmRlZFJlY3RCa2coZGIyLCBia2dFbGVtLCBub2RlLCBzZWN0aW9uKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgZGIyLm5vZGVUeXBlLlJFQ1Q6XG4gICAgICByZWN0QmtnKGRiMiwgYmtnRWxlbSwgbm9kZSwgc2VjdGlvbik7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGRiMi5ub2RlVHlwZS5DSVJDTEU6XG4gICAgICBia2dFbGVtLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoXCIgKyBub2RlLndpZHRoIC8gMiArIFwiLCBcIiArICtub2RlLmhlaWdodCAvIDIgKyBcIilcIik7XG4gICAgICBjaXJjbGVCa2coZGIyLCBia2dFbGVtLCBub2RlLCBzZWN0aW9uKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgZGIyLm5vZGVUeXBlLkNMT1VEOlxuICAgICAgY2xvdWRCa2coZGIyLCBia2dFbGVtLCBub2RlLCBzZWN0aW9uKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgZGIyLm5vZGVUeXBlLkJBTkc6XG4gICAgICBiYW5nQmtnKGRiMiwgYmtnRWxlbSwgbm9kZSwgc2VjdGlvbik7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGRiMi5ub2RlVHlwZS5IRVhBR09OOlxuICAgICAgaGV4YWdvbkJrZyhkYjIsIGJrZ0VsZW0sIG5vZGUsIHNlY3Rpb24pO1xuICAgICAgYnJlYWs7XG4gIH1cbiAgZGIyLnNldEVsZW1lbnRGb3JJZChub2RlLmlkLCBub2RlRWxlbSk7XG4gIHJldHVybiBub2RlLmhlaWdodDtcbn0sIFwiZHJhd05vZGVcIik7XG52YXIgcG9zaXRpb25Ob2RlID0gLyogQF9fUFVSRV9fICovIF9fbmFtZShmdW5jdGlvbihkYjIsIG5vZGUpIHtcbiAgY29uc3Qgbm9kZUVsZW0gPSBkYjIuZ2V0RWxlbWVudEJ5SWQobm9kZS5pZCk7XG4gIGNvbnN0IHggPSBub2RlLnggfHwgMDtcbiAgY29uc3QgeSA9IG5vZGUueSB8fCAwO1xuICBub2RlRWxlbS5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKFwiICsgeCArIFwiLFwiICsgeSArIFwiKVwiKTtcbn0sIFwicG9zaXRpb25Ob2RlXCIpO1xuXG4vLyBzcmMvZGlhZ3JhbXMvbWluZG1hcC9taW5kbWFwUmVuZGVyZXIudHNcbmN5dG9zY2FwZS51c2UoY29zZUJpbGtlbnQpO1xuYXN5bmMgZnVuY3Rpb24gZHJhd05vZGVzKGRiMiwgc3ZnLCBtaW5kbWFwLCBzZWN0aW9uLCBjb25mKSB7XG4gIGF3YWl0IGRyYXdOb2RlKGRiMiwgc3ZnLCBtaW5kbWFwLCBzZWN0aW9uLCBjb25mKTtcbiAgaWYgKG1pbmRtYXAuY2hpbGRyZW4pIHtcbiAgICBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgIG1pbmRtYXAuY2hpbGRyZW4ubWFwKFxuICAgICAgICAoY2hpbGQsIGluZGV4KSA9PiBkcmF3Tm9kZXMoZGIyLCBzdmcsIGNoaWxkLCBzZWN0aW9uIDwgMCA/IGluZGV4IDogc2VjdGlvbiwgY29uZilcbiAgICAgIClcbiAgICApO1xuICB9XG59XG5fX25hbWUoZHJhd05vZGVzLCBcImRyYXdOb2Rlc1wiKTtcbmZ1bmN0aW9uIGRyYXdFZGdlcyhlZGdlc0VsLCBjeSkge1xuICBjeS5lZGdlcygpLm1hcCgoZWRnZSwgaWQpID0+IHtcbiAgICBjb25zdCBkYXRhID0gZWRnZS5kYXRhKCk7XG4gICAgaWYgKGVkZ2VbMF0uX3ByaXZhdGUuYm9keUJvdW5kcykge1xuICAgICAgY29uc3QgYm91bmRzID0gZWRnZVswXS5fcHJpdmF0ZS5yc2NyYXRjaDtcbiAgICAgIGxvZy50cmFjZShcIkVkZ2U6IFwiLCBpZCwgZGF0YSk7XG4gICAgICBlZGdlc0VsLmluc2VydChcInBhdGhcIikuYXR0cihcbiAgICAgICAgXCJkXCIsXG4gICAgICAgIGBNICR7Ym91bmRzLnN0YXJ0WH0sJHtib3VuZHMuc3RhcnRZfSBMICR7Ym91bmRzLm1pZFh9LCR7Ym91bmRzLm1pZFl9IEwke2JvdW5kcy5lbmRYfSwke2JvdW5kcy5lbmRZfSBgXG4gICAgICApLmF0dHIoXCJjbGFzc1wiLCBcImVkZ2Ugc2VjdGlvbi1lZGdlLVwiICsgZGF0YS5zZWN0aW9uICsgXCIgZWRnZS1kZXB0aC1cIiArIGRhdGEuZGVwdGgpO1xuICAgIH1cbiAgfSk7XG59XG5fX25hbWUoZHJhd0VkZ2VzLCBcImRyYXdFZGdlc1wiKTtcbmZ1bmN0aW9uIGFkZE5vZGVzKG1pbmRtYXAsIGN5LCBjb25mLCBsZXZlbCkge1xuICBjeS5hZGQoe1xuICAgIGdyb3VwOiBcIm5vZGVzXCIsXG4gICAgZGF0YToge1xuICAgICAgaWQ6IG1pbmRtYXAuaWQudG9TdHJpbmcoKSxcbiAgICAgIGxhYmVsVGV4dDogbWluZG1hcC5kZXNjcixcbiAgICAgIGhlaWdodDogbWluZG1hcC5oZWlnaHQsXG4gICAgICB3aWR0aDogbWluZG1hcC53aWR0aCxcbiAgICAgIGxldmVsLFxuICAgICAgbm9kZUlkOiBtaW5kbWFwLmlkLFxuICAgICAgcGFkZGluZzogbWluZG1hcC5wYWRkaW5nLFxuICAgICAgdHlwZTogbWluZG1hcC50eXBlXG4gICAgfSxcbiAgICBwb3NpdGlvbjoge1xuICAgICAgeDogbWluZG1hcC54LFxuICAgICAgeTogbWluZG1hcC55XG4gICAgfVxuICB9KTtcbiAgaWYgKG1pbmRtYXAuY2hpbGRyZW4pIHtcbiAgICBtaW5kbWFwLmNoaWxkcmVuLmZvckVhY2goKGNoaWxkKSA9PiB7XG4gICAgICBhZGROb2RlcyhjaGlsZCwgY3ksIGNvbmYsIGxldmVsICsgMSk7XG4gICAgICBjeS5hZGQoe1xuICAgICAgICBncm91cDogXCJlZGdlc1wiLFxuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgaWQ6IGAke21pbmRtYXAuaWR9XyR7Y2hpbGQuaWR9YCxcbiAgICAgICAgICBzb3VyY2U6IG1pbmRtYXAuaWQsXG4gICAgICAgICAgdGFyZ2V0OiBjaGlsZC5pZCxcbiAgICAgICAgICBkZXB0aDogbGV2ZWwsXG4gICAgICAgICAgc2VjdGlvbjogY2hpbGQuc2VjdGlvblxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxufVxuX19uYW1lKGFkZE5vZGVzLCBcImFkZE5vZGVzXCIpO1xuZnVuY3Rpb24gbGF5b3V0TWluZG1hcChub2RlLCBjb25mKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgIGNvbnN0IHJlbmRlckVsID0gc2VsZWN0KFwiYm9keVwiKS5hcHBlbmQoXCJkaXZcIikuYXR0cihcImlkXCIsIFwiY3lcIikuYXR0cihcInN0eWxlXCIsIFwiZGlzcGxheTpub25lXCIpO1xuICAgIGNvbnN0IGN5ID0gY3l0b3NjYXBlKHtcbiAgICAgIGNvbnRhaW5lcjogZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJjeVwiKSxcbiAgICAgIC8vIGNvbnRhaW5lciB0byByZW5kZXIgaW5cbiAgICAgIHN0eWxlOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBzZWxlY3RvcjogXCJlZGdlXCIsXG4gICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgIFwiY3VydmUtc3R5bGVcIjogXCJiZXppZXJcIlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgXVxuICAgIH0pO1xuICAgIHJlbmRlckVsLnJlbW92ZSgpO1xuICAgIGFkZE5vZGVzKG5vZGUsIGN5LCBjb25mLCAwKTtcbiAgICBjeS5ub2RlcygpLmZvckVhY2goZnVuY3Rpb24obikge1xuICAgICAgbi5sYXlvdXREaW1lbnNpb25zID0gKCkgPT4ge1xuICAgICAgICBjb25zdCBkYXRhID0gbi5kYXRhKCk7XG4gICAgICAgIHJldHVybiB7IHc6IGRhdGEud2lkdGgsIGg6IGRhdGEuaGVpZ2h0IH07XG4gICAgICB9O1xuICAgIH0pO1xuICAgIGN5LmxheW91dCh7XG4gICAgICBuYW1lOiBcImNvc2UtYmlsa2VudFwiLFxuICAgICAgLy8gQHRzLWlnbm9yZSBUeXBlcyBmb3IgY29zZS1iaWxrZW50IGFyZSBub3QgY29ycmVjdD9cbiAgICAgIHF1YWxpdHk6IFwicHJvb2ZcIixcbiAgICAgIHN0eWxlRW5hYmxlZDogZmFsc2UsXG4gICAgICBhbmltYXRlOiBmYWxzZVxuICAgIH0pLnJ1bigpO1xuICAgIGN5LnJlYWR5KChlKSA9PiB7XG4gICAgICBsb2cuaW5mbyhcIlJlYWR5XCIsIGUpO1xuICAgICAgcmVzb2x2ZShjeSk7XG4gICAgfSk7XG4gIH0pO1xufVxuX19uYW1lKGxheW91dE1pbmRtYXAsIFwibGF5b3V0TWluZG1hcFwiKTtcbmZ1bmN0aW9uIHBvc2l0aW9uTm9kZXMoZGIyLCBjeSkge1xuICBjeS5ub2RlcygpLm1hcCgobm9kZSwgaWQpID0+IHtcbiAgICBjb25zdCBkYXRhID0gbm9kZS5kYXRhKCk7XG4gICAgZGF0YS54ID0gbm9kZS5wb3NpdGlvbigpLng7XG4gICAgZGF0YS55ID0gbm9kZS5wb3NpdGlvbigpLnk7XG4gICAgcG9zaXRpb25Ob2RlKGRiMiwgZGF0YSk7XG4gICAgY29uc3QgZWwgPSBkYjIuZ2V0RWxlbWVudEJ5SWQoZGF0YS5ub2RlSWQpO1xuICAgIGxvZy5pbmZvKFwiSWQ6XCIsIGlkLCBcIlBvc2l0aW9uOiAoXCIsIG5vZGUucG9zaXRpb24oKS54LCBcIiwgXCIsIG5vZGUucG9zaXRpb24oKS55LCBcIilcIiwgZGF0YSk7XG4gICAgZWwuYXR0cihcbiAgICAgIFwidHJhbnNmb3JtXCIsXG4gICAgICBgdHJhbnNsYXRlKCR7bm9kZS5wb3NpdGlvbigpLnggLSBkYXRhLndpZHRoIC8gMn0sICR7bm9kZS5wb3NpdGlvbigpLnkgLSBkYXRhLmhlaWdodCAvIDJ9KWBcbiAgICApO1xuICAgIGVsLmF0dHIoXCJhdHRyXCIsIGBhcGEtJHtpZH0pYCk7XG4gIH0pO1xufVxuX19uYW1lKHBvc2l0aW9uTm9kZXMsIFwicG9zaXRpb25Ob2Rlc1wiKTtcbnZhciBkcmF3ID0gLyogQF9fUFVSRV9fICovIF9fbmFtZShhc3luYyAodGV4dCwgaWQsIF92ZXJzaW9uLCBkaWFnT2JqKSA9PiB7XG4gIGxvZy5kZWJ1ZyhcIlJlbmRlcmluZyBtaW5kbWFwIGRpYWdyYW1cXG5cIiArIHRleHQpO1xuICBjb25zdCBkYjIgPSBkaWFnT2JqLmRiO1xuICBjb25zdCBtbSA9IGRiMi5nZXRNaW5kbWFwKCk7XG4gIGlmICghbW0pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgY29uZiA9IGdldENvbmZpZygpO1xuICBjb25mLmh0bWxMYWJlbHMgPSBmYWxzZTtcbiAgY29uc3Qgc3ZnID0gc2VsZWN0U3ZnRWxlbWVudChpZCk7XG4gIGNvbnN0IGVkZ2VzRWxlbSA9IHN2Zy5hcHBlbmQoXCJnXCIpO1xuICBlZGdlc0VsZW0uYXR0cihcImNsYXNzXCIsIFwibWluZG1hcC1lZGdlc1wiKTtcbiAgY29uc3Qgbm9kZXNFbGVtID0gc3ZnLmFwcGVuZChcImdcIik7XG4gIG5vZGVzRWxlbS5hdHRyKFwiY2xhc3NcIiwgXCJtaW5kbWFwLW5vZGVzXCIpO1xuICBhd2FpdCBkcmF3Tm9kZXMoZGIyLCBub2Rlc0VsZW0sIG1tLCAtMSwgY29uZik7XG4gIGNvbnN0IGN5ID0gYXdhaXQgbGF5b3V0TWluZG1hcChtbSwgY29uZik7XG4gIGRyYXdFZGdlcyhlZGdlc0VsZW0sIGN5KTtcbiAgcG9zaXRpb25Ob2RlcyhkYjIsIGN5KTtcbiAgc2V0dXBHcmFwaFZpZXdib3goXG4gICAgdm9pZCAwLFxuICAgIHN2ZyxcbiAgICBjb25mLm1pbmRtYXA/LnBhZGRpbmcgPz8gZGVmYXVsdENvbmZpZ19kZWZhdWx0Lm1pbmRtYXAucGFkZGluZyxcbiAgICBjb25mLm1pbmRtYXA/LnVzZU1heFdpZHRoID8/IGRlZmF1bHRDb25maWdfZGVmYXVsdC5taW5kbWFwLnVzZU1heFdpZHRoXG4gICk7XG59LCBcImRyYXdcIik7XG52YXIgbWluZG1hcFJlbmRlcmVyX2RlZmF1bHQgPSB7XG4gIGRyYXdcbn07XG5cbi8vIHNyYy9kaWFncmFtcy9taW5kbWFwL3N0eWxlcy50c1xuaW1wb3J0IHsgZGFya2VuLCBsaWdodGVuLCBpc0RhcmsgfSBmcm9tIFwia2hyb21hXCI7XG52YXIgZ2VuU2VjdGlvbnMgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKChvcHRpb25zKSA9PiB7XG4gIGxldCBzZWN0aW9ucyA9IFwiXCI7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgb3B0aW9ucy5USEVNRV9DT0xPUl9MSU1JVDsgaSsrKSB7XG4gICAgb3B0aW9uc1tcImxpbmVDb2xvclwiICsgaV0gPSBvcHRpb25zW1wibGluZUNvbG9yXCIgKyBpXSB8fCBvcHRpb25zW1wiY1NjYWxlSW52XCIgKyBpXTtcbiAgICBpZiAoaXNEYXJrKG9wdGlvbnNbXCJsaW5lQ29sb3JcIiArIGldKSkge1xuICAgICAgb3B0aW9uc1tcImxpbmVDb2xvclwiICsgaV0gPSBsaWdodGVuKG9wdGlvbnNbXCJsaW5lQ29sb3JcIiArIGldLCAyMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9wdGlvbnNbXCJsaW5lQ29sb3JcIiArIGldID0gZGFya2VuKG9wdGlvbnNbXCJsaW5lQ29sb3JcIiArIGldLCAyMCk7XG4gICAgfVxuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgb3B0aW9ucy5USEVNRV9DT0xPUl9MSU1JVDsgaSsrKSB7XG4gICAgY29uc3Qgc3cgPSBcIlwiICsgKDE3IC0gMyAqIGkpO1xuICAgIHNlY3Rpb25zICs9IGBcbiAgICAuc2VjdGlvbi0ke2kgLSAxfSByZWN0LCAuc2VjdGlvbi0ke2kgLSAxfSBwYXRoLCAuc2VjdGlvbi0ke2kgLSAxfSBjaXJjbGUsIC5zZWN0aW9uLSR7aSAtIDF9IHBvbHlnb24sIC5zZWN0aW9uLSR7aSAtIDF9IHBhdGggIHtcbiAgICAgIGZpbGw6ICR7b3B0aW9uc1tcImNTY2FsZVwiICsgaV19O1xuICAgIH1cbiAgICAuc2VjdGlvbi0ke2kgLSAxfSB0ZXh0IHtcbiAgICAgZmlsbDogJHtvcHRpb25zW1wiY1NjYWxlTGFiZWxcIiArIGldfTtcbiAgICB9XG4gICAgLm5vZGUtaWNvbi0ke2kgLSAxfSB7XG4gICAgICBmb250LXNpemU6IDQwcHg7XG4gICAgICBjb2xvcjogJHtvcHRpb25zW1wiY1NjYWxlTGFiZWxcIiArIGldfTtcbiAgICB9XG4gICAgLnNlY3Rpb24tZWRnZS0ke2kgLSAxfXtcbiAgICAgIHN0cm9rZTogJHtvcHRpb25zW1wiY1NjYWxlXCIgKyBpXX07XG4gICAgfVxuICAgIC5lZGdlLWRlcHRoLSR7aSAtIDF9e1xuICAgICAgc3Ryb2tlLXdpZHRoOiAke3N3fTtcbiAgICB9XG4gICAgLnNlY3Rpb24tJHtpIC0gMX0gbGluZSB7XG4gICAgICBzdHJva2U6ICR7b3B0aW9uc1tcImNTY2FsZUludlwiICsgaV19IDtcbiAgICAgIHN0cm9rZS13aWR0aDogMztcbiAgICB9XG5cbiAgICAuZGlzYWJsZWQsIC5kaXNhYmxlZCBjaXJjbGUsIC5kaXNhYmxlZCB0ZXh0IHtcbiAgICAgIGZpbGw6IGxpZ2h0Z3JheTtcbiAgICB9XG4gICAgLmRpc2FibGVkIHRleHQge1xuICAgICAgZmlsbDogI2VmZWZlZjtcbiAgICB9XG4gICAgYDtcbiAgfVxuICByZXR1cm4gc2VjdGlvbnM7XG59LCBcImdlblNlY3Rpb25zXCIpO1xudmFyIGdldFN0eWxlcyA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoKG9wdGlvbnMpID0+IGBcbiAgLmVkZ2Uge1xuICAgIHN0cm9rZS13aWR0aDogMztcbiAgfVxuICAke2dlblNlY3Rpb25zKG9wdGlvbnMpfVxuICAuc2VjdGlvbi1yb290IHJlY3QsIC5zZWN0aW9uLXJvb3QgcGF0aCwgLnNlY3Rpb24tcm9vdCBjaXJjbGUsIC5zZWN0aW9uLXJvb3QgcG9seWdvbiAge1xuICAgIGZpbGw6ICR7b3B0aW9ucy5naXQwfTtcbiAgfVxuICAuc2VjdGlvbi1yb290IHRleHQge1xuICAgIGZpbGw6ICR7b3B0aW9ucy5naXRCcmFuY2hMYWJlbDB9O1xuICB9XG4gIC5pY29uLWNvbnRhaW5lciB7XG4gICAgaGVpZ2h0OjEwMCU7XG4gICAgZGlzcGxheTogZmxleDtcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICB9XG4gIC5lZGdlIHtcbiAgICBmaWxsOiBub25lO1xuICB9XG4gIC5taW5kbWFwLW5vZGUtbGFiZWwge1xuICAgIGR5OiAxZW07XG4gICAgYWxpZ25tZW50LWJhc2VsaW5lOiBtaWRkbGU7XG4gICAgdGV4dC1hbmNob3I6IG1pZGRsZTtcbiAgICBkb21pbmFudC1iYXNlbGluZTogbWlkZGxlO1xuICAgIHRleHQtYWxpZ246IGNlbnRlcjtcbiAgfVxuYCwgXCJnZXRTdHlsZXNcIik7XG52YXIgc3R5bGVzX2RlZmF1bHQgPSBnZXRTdHlsZXM7XG5cbi8vIHNyYy9kaWFncmFtcy9taW5kbWFwL21pbmRtYXAtZGVmaW5pdGlvbi50c1xudmFyIGRpYWdyYW0gPSB7XG4gIGRiOiBtaW5kbWFwRGJfZGVmYXVsdCxcbiAgcmVuZGVyZXI6IG1pbmRtYXBSZW5kZXJlcl9kZWZhdWx0LFxuICBwYXJzZXI6IG1pbmRtYXBfZGVmYXVsdCxcbiAgc3R5bGVzOiBzdHlsZXNfZGVmYXVsdFxufTtcbmV4cG9ydCB7XG4gIGRpYWdyYW1cbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/mermaid/dist/chunks/mermaid.core/mindmap-definition-GWI6TPTV.mjs\n"));

/***/ })

}]);