{"/foreword":{"title":"üëã Hi! My name is Tomas.","data":{"":"I have been programming for the web for 15+ years, developed reactive frontend frameworks at Facebook, and absolutely love JavaScript (well, as much as anyone loves JavaScript).In that time, I've had the chance to teach a few people about frontend development; inevitably they'll ask me, \"hey, this is all great, is there anywhere I can go to read more\", or worse, \"I was doing some reading online and read an article that says {some hyperbole about how a certain framework / library / technology solves all problems}. Why don't we just use that?\" And that's when I explain three truths about the frontend ecosystem:\nIt's quickly evolving and highly volatile: what was true last year (/ month / week) may not be true today.\nIt's very hype-driven: because so few technologies have been around to stand the test of time, technology popularity is heavily influenced by marketing hype instead of robustness.\nA lot of the documentation is targeting first time programmers: For whatever reason, frontend attracts a lot of new developers, which is awesome; however, a lot of the documentation excludes context, tradeoffs, and nuance because it assumes the reader won't be able to, or care to, evaluate it themselves.\nThat last point, in particular, upsets me. I think frontend has many real engineering problems to work on, and the lack of experienced-developer-facing documentation discourages many developers from engaging with it.So that's why I'm here: I want to share frontend with you. I wanted to write a document that:\nTeaches frontend: assuming little to no background knowledge.\nTargets experienced developers: including any relevant context, trade-offs, and nuance. If you're just looking to get started, there are better documents for you.\nIs short: I've worked really hard to keep this whole thing front-to-back readable, and under 20 pages.\nPerhaps you're a backend developer dipping your toes into frontend for the first time; perhaps you're a frontend developer who wants to go deeper; perhaps, you've just always been curious. Regardless of the situation, if you've been coding for a while and want to learn more about frontend, this is for you.Lastly, two quick editorial notes:\nWhile I aim to be fair with this, I'm certainly not impartial. My goal is to pass on both my opinions and their reasoning, hopefully allowing you to bootstrap your own.\nThere is a lot to cover and this is very much a work in progress. If you feel I missed something, got it wrong, or just could have gone deeper feel free to DM me on Twitter (link in header).\nAnyway, I only have ~19 pages left, so let's dive in!"}},"/components":{"title":"Components: The building blocks of UI","data":{"":"As JavaScript became more powerful, the browser transformed from a rendering engine into a sandbox. User expectations kept up and users demanded more: suddenly, it wasn't an acceptable user experience to refresh the page when a user added something to their shopping cart, or their password and confirm password fields didn't match, web apps were expected to compute and rerender those details client-side.The natural result was increasingly large parts of web pages had to be rendered on the client; however, there was no canonical way to do this. On the server, data was fetched in response to user requests and piped into templates, but the client lived in this awkward in-between where the initial render came from the server, but then subsequent renders and updates had to be constructed on the client.The split source-of-truth between initial render and updates led to predictable problems: HTML fell out-of-sync with data in JavaScript, and rerenders could change the UI in unexpected, and often unintentional, ways.","jsx-html-in-js#JSX: HTML in JS":"It is in this context that JSX was born. Technologically, JSX wasn't that interesting, but as a developer experience improvement, it was genius. JSX flipped the paradigm on its head: JavaScript, not HTML, became the source of truth for all renders (including the initial render). Because that required more HTML to be written in JavaScript than before, JSX introduced a first-class HTML-like syntax embedded within JavaScript: JSX.JSX takes in a DOM element, and mounts a React tree into it using the .render() method. If you're using a higher-level framework (such as Next.js), this is typically handled for you.\nJSX enabled this syntax by adding a build step to transpile the HTML-like syntax into JavaScript functions.Not only could you render HTML inside of JavaScript, but you could also interpolate JavaScript back into HTML using curly braces.","components#Components":"Beyond letting developers write the standard HTML tags, JSX allowed developers to define their own tags, called components, using JavaScript functions (tags native to HTML are called \"primitives\").Like normal functions, these tags evaluate to their return value and take in arguments (called props and passed as attributes to the tag).\nIn fact, the App function itself is a component!One special prop to call out is children; unlike other props, children is defined as the contents of the tag (instead of as an attribute) and is always a ReactNode (an object that react knows how to render into HTML).\n// With this component definition\nfunction CustomTag(props) {\n  return <div>\n    Hello, {props.children}!\n  </div>;\n}\n// This: \n<CustomTag>\n  <span>world</span>\n</CustomTag>\n// Evaluates to this:\n<div>\n  Hello, <span>world</span>!\n</div>","fragments#Fragments":"Something that's not quite a component, but looks like one is a React Fragment: <Fragment> or <>.Fragments allow you to wrap multiple components as one, but don't render to any HTML themselves.\n// With this component definition\nfunction CustomTag(props) {\n  return <>\n    Hello, {props.children}!\n  </>;\n}\n// This: \n<p>\n  <CustomTag>\n    <span>world</span>\n  </CustomTag>\n</p>\n// Evaluates to this:\n<p>\n  Hello, <span>world</span>!\n</p>","reactivity#Reactivity":"Every app needs to do two things: (1) the initial render; (2) updating the UI in response to user interaction.Because React is a declarative framework, developers don't directly manipulate the DOM to update the UI; instead, developers describe the UI as a function of some data (called state), and update that state. When state is updated, React rerenders and computes any changes it needs to make to the DOM.","event-handlers#Event handlers":"Typically user interactions cause state to change. To listen to user interactions, event handlers can be passed like any other attribute to HTML primitives.","state#State":"State is created with useState(), which takes an initial value generator and returns a getter and setter tuple:\nconst [getter, setter] = useState(() => {\n  // ... does some expensive compute and returns initial state...\n  return 0;\n});\nState is updated by calling the setter with a function that takes in the old state and returns the new state.\n<div onClick={() => { setter((oldValue) => oldValue + 1) }} />\nOn click, the function passed to the setter is called, a new state is computed, and React triggers a rerender.\nTwo common shorthands for the above are:\nuseState(0) is equivalent to useState(() => 0): This is dangerous if the initial value is expensive to compute or shouldn't be recreated; for example, useState(new ComplexClass()) will create a new instance of ComplexClass every time the component rerenders.\nsetState(1) is equivalent to setState(() => 1): This is dangerous if the new value depends on the old value (setCount(count + 1)), as this code is evaluated at render time to setCount(2), and it will set the value to 2 regardless of how many times the user presses the button (until the frontend rerenders).\nBecause setState will trigger a rerender, you should avoid unconditionally calling setState during a render (as that will create an infinite render loop).","rerendering#Rerendering":"When state is updated in a component, React marks that component, and all of its descendent components, as \"dirty\"; whenever React has dirty nodes in its tree, it rerenders that subtree (React may rerender multiple subtrees simultaneously if they are all dirty and share no common ancestor that also needs rerendering).\nTo rerender a component, React:\nRenders: Calls the same function that initially rendered it\nReconciles: Compares its output against its previous output to create a list of changes\nCommits: Applies those changes to the DOM\nThe second step was the technical innovation behind React. Reading and writing to the DOM is expensive, but by keeping an in-memory representation of the DOM (a \"virtual DOM\"), developers only write one render function (as opposed to render and rerender) and React can quickly translate that into a list of updates.As React rerenders the tree, it needs to determine whether the node it's currently rendering is the same as a previous node it has rendered, so it can reuse the state. React determines this by looking at:\nIs the parent node the same (this algorithm is recursive)\nIs this component defined by the same function (\"same\" meaning pointer equality)\nIs the key the same (more on this later)\nThe second rule is why components should never be defined inside of another function. For example, the counter below will reset state on every render.\nfunction App() {\n  function Counter() {\n    const [count, setCount] = useState(() => 0);\n    return <div onClick={() => { setCount((oldCount) => oldCount + 1); }}>\n      Click me (current count: {count})\n    </div>;\n  }\n  return <Counter />;\n}","lists-and-keys#Lists and keys":"Reconciling state across elements of a list is tricky because every element has the same parent node and the same function. In the example below, type something into one of the textboxes and click \"add item\".\nThe state will move components. This is because, by default, React will use the item's index to resolve any ambiguity in which child a state belongs to. You can override this by providing a key attribute, keys tell React how to match children elements across rerenders. This line would fix the example above.\n{items.map((item) => { \n  return <Item id={item} key={item} />; \n})}\nWhile primarily used for lists, keys are a general concept in react, and changing a key will reset the state.","example-inputs#Example: inputs":"One place where this all comes together beautifully is when dealing with input tags.\nIn a controlled input (where the value is defined in React),\nReact renders an input tag that says \"hello, w\"\nThe user types \"o\" into that input tag\nThe event handler triggers, and reads whats in the input (\"hello, wo\")\nReact updates the state to match that value\nReact rerenders (because state was updated)\nReact reconciles the differences to determine it should issue an update to the input from \"hello, w\" (what was in the virtual dom) to \"hello, wo\" (what was most recently rendered)\nThe DOM update no-ops (because \"hello, wo\" is already the value)","hooks#Hooks":"useState is actually one of many built-in React \"hooks\", or integration points with React. Hooks provide access to information stored across renders or hook into React's lifecycle.You may have wondered how useState worked across renders, React knows when a component is rendering, and tracks the order of hook calls. For example, when rerendering the below, React knows to return \"John\" for the first useState call and \"Doe\" for the second call:\nfunction SomeComponent() {\n  const [firstName, setFirstName] = useState(\"John\");\n  const [lastName, setLastName] = useState(\"Doe\");\n  // ...\n}\nHooks are always prefixed with use, and--because of their implementation--have two important rules:Rule 1: Even though components are JavaScript functions, don't call them directly (e.g. never call const element = SomeComponent()) because React does set-up before it renders components to enable hooks.Rule 2: Hooks must be called in the same exact order on every render. That means, hooks should not be called conditionally (in an if-statement) or a variable number of times (in a loop). For example, as far as React is concerned, the first name state and last name state are the same: the second call to useState.\nFor a full list of built-in hooks, see the documentation. In addition, you can define your own hooks, just be sure to prefix them with use.","lifecycle#Lifecycle":"While rendering and rerendering are intended to be implementation details of React, sometimes you need to take action throughout the component's lifecycle. useEffect is a hook that takes in a function to call whenever the component has been rendered; it returns a function to call either before the component is rendered again or before it is removed from the DOM.A common use-case for this is to synchronize the component with external sources of data. For example, here is a custom hook that stores the window size in state (so your component can react to it):\nconst useWindowSize = () => {\n  const [windowSize, setWindowSize] = useState({\n    height: window.innerHeight,\n    width: window.innerWidth,\n  });\n  useEffect(() => {\n    const windowSizeHandler = () => {\n      setWindowSize({\n        height: window.innerHeight,\n        width: window.innerWidth,\n      });\n    };\n    // Subscribe when component is created\n    window.addEventListener(\"resize\", windowSizeHandler);\n    return () => {\n      // Unsubscribe when component is removed\n      window.removeEventListener(\"resize\", windowSizeHandler);\n    };\n  }, []);\n  return windowSize;\n};\nBecause you may not want to run code on every render, useEffect takes in a second parameter, a list of values. If provided, useEffect will only rerun if one of those values changes. In our example, because we are passing an empty list, useEffect will only run when the component is first created.","refs#Refs":"In addition to wanting to run code on render, sometimes you need escape hatches from React's declarative nature and access the DOM elements that React creates. Refs are how you do that.In React, for historical reasons, ref refers to two related, but distinct, conceptsuseRef(...): is a hook that takes in an initial value and returns a JavaScript object of the form { current: INITIAL_VALUE }. This is useful because you can set the current property to anything as a way to persist that data across renders (however, unlike state, changing it won't trigger a rerender).\nconst useIsFirstRender = () => {\n  // We're using a ref instead of state, because we don't want checking \n  // whether we're on the first render to immediately trigger a rerender.\n  const firstRenderRef = useRef(true);\n  const isFirstRender = firstRenderRef.current;\n  firstRenderRef.current = false;\n  \n  return isFirstRender;\n};\nref={...}: is a property on every tag in React that takes in a ref object and provides an imperative handle to that DOM element. For example, the below creates a text element which auto-focuses when rendered:\nCustom components can also have refs, you can either forward the ref to one of the returned DOM nodes using forwardRef, or define a custom value to use as the value for the ref using useImperativeHandle.For more complicated use-cases, for example when you have a variable amount of elements you need refs to, you can instead pass a function to ref={...} that takes in the current DOM node.\nfunction CustomTag() {\n  // This will call focus on itself EVERY time it's rendered\n  // A more practical example would be to add the ref to an array\n  return <input type='text' ref={(element) => element.focus()} />;\n}","higher-order-components#Higher order components":"In many ways, components are like functions, and like functions, you may find yourself writing the same logic over and over again as you write more of them. When working with functions, you can reduce this repetition with higher order functions, and the same concept exists with components: higher order components (HOCs).Higher order components are functions that return components. For example, imagine you wanted every page to log whenever it rendered. Because of that you found every page beginning with the same:\nuseEffect(() => {\n  console.log(\"NAME OF PAGE\")\n}, [])\nInstead of copy and pasting that across components, you could create a higher order component:\nfunction withLogging(pageName, Component) {\n  return (props) => {\n    useEffect(() => {\n      console.log(pageName)\n    }, [])\n    return <Component {...props} />\n  }\n}\nAnd then create your components like this:\nconst MyPage = withLogging(\"MY PAGE\", MyPageComponent);\nThat said, these days I don't see higher order components as much because hooks make a lot of that same logic reuse easier. For example, another way to implement the above is as a custom hook:\nfunction useLogRender(name) {\n  useEffect(() => {\n    console.log(name)\n  }, []);\n}\nIf you do find yourself creating HOCs, make sure to create them in the global scope of your application (and not during render), because React uses the function pointer to determine component equality, and if you create a new component function every render, React will never reconcile state across them.","file-structure-locality#File structure (locality)":"Like functions do in normal JS, components create a natural place to introduce abstraction to your code:\nroot.render(\n  <App>\n    <Header />\n    <MainContents>\n      <Sidebar />\n      <SignUpPage />\n    </MainContents>\n  </App>\n);\nThis abstraction is typically reflected in the file structure:\nproject-root/\n  components/\n    Header/\n      Header.jsx \n    Sidebar/\n      Sidebar.jsx \n    MainContents/\n      MainContents.jsx \n  pages/\n    SignUpPage/\n      SignUpPage.jsx\nConventionally--and unlike other programming paradigms--in a component-based architecture, all parts of a component (code, style, tests) are co-located to optimize discoverability (a principle referred to as locality).\nproject-root/\n  components/\n    Header/\n      Header.jsx \n      Header.test.jsx\n      Header.css","styling#Styling":"Speaking of styling: in recent years, CSS has transformed in many of the same ways as JavaScript has:\nBetter syntax: LESS and SASS have emerged as alternative syntaxes to CSS.\nModularization: CSS modules help developers isolate code.\nBetter support for components: With CSS modules and a bundler (like webpack), I can now author a React component that imports a style and references any defined classnames like variables.\nimport s from \"./my-style-file.module.scss\";\nfunction SomeReactComponent() {\n  return <div className={s.someClassname}>Hello, world!</div>\n}\nThe above is my recommended way to write CSS; however, I'm keeping my eye on the efforts to colocate CSS definitions in JS (much like JSX moved HTML into JS files). Two examples are StyledComponents and StyleX. I believe this is the right long-term direction, but there are still unsolved challenges around:\nPseudo-selectors (:hover)\nPseudo-elements (::before)\nKeyframes (@keyframes)\nMedia queries (@media)\netc.\nPrior to CSS modules, BEM provided a structure to map your CSS to components."}},"/":{"title":"Index","data":{}},"/css":{"title":"CSS: The style of web pages","data":{"":"HTML was great for academic documents, but not great for marketing materials and definitely not great for full applications. People wanted a way to style their documents, and that is how we got CSS.Building on our earlier example, let's create a folder with two documents:\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <title>Demo app</title>\n    <link rel=\"stylesheet\" type=\"text/css\" href=\"styles.css\" />\n  </head>\n  <body>\n    <p>Hello, world!</p>\n  </body>\n</html>\nThis is the same as above, but with an added <link> tag (which is just telling the browser the address it can request to find an associated CSS file; because the address doesn't begin with a / it's presumed to be relative to the HTML file). And:\np {\n  color: red;\n}\nThis is a CSS file! It says that all paragraph tags, p, should have a text color of red.You can open that HTML file to see it with the style applied. And, like our HTML example, we can continue to experiment using CodeSandbox:","selectors#Selectors":"CSS is all about selecting elements and modifying their properties. CSS files are structured as lists of these rules, which use a selector to specify element(s) the rule applies to and lists properties to apply to those matched elements.\n/**\n * This is a c-style comment.\n *\n * This paragraph says all paragraph tags should be red. \n */\np {\n  color: red;\n}\n/* This paragraph says all headings should be bold and blue. */\nh1 {\n  color: blue;\n  font-weight: bold;\n}\nThere are three main types of selectors:\nfoo: this matches all elements of the tag foo (for example, <foo />)\n#foo: this matches the element with the attribute id=\"foo\". Every ID must be unique.\n.foo: this matches all elements which include the attribute class=\"foo\". Unlike IDs, there can be many elements with the same class; there can also be multiple classes per element; for example, an element with class=\"foo bar\" will match both .foo and .bar.\nThere are also attribute selectors, which match elements based on the value of an attribute, for example [type=\"text\"] matches all tags with the type attribute set to text.","composing-selectors#Composing selectors":"Selectors can also be combined:\nCommas allow either selector to match (e.g. #foo, #bar applies to either #foo or #bar)\nSelectors can be concatenated so ALL selectors must match (e.g. p#foo.bar matches any p tags with the ID foo and the class bar)\nSpaces match descendents (e.g. .foo .bar matches any element with class bar that is a descendent of an element with class foo)\nCombinators can be used to build more complicated relationships (e.g. .foo > .bar matches any element with class bar that is a direct descendent of an element with class foo)","specificity#Specificity":"If two different selectors apply to an element:\nthe properties in the selector with the most IDs in it wins (#foo has 1 ID but #foo #bar has two IDs);\nif both selectors have the same number of IDs, the properties in the selector with the most classes wins;\nif both selectors have the same number of classes, the properties in the selector with the most tags wins;\nif both selectors have the same number of tags, the properties in the selector defined later in the file wins.\nThis is called specificity.CSS rules can be thought of as applying from lowest specificity upwards. So, if a rule sets the text color to red, and no higher specificity rule overrides it (or there is no higher specificity rule), the text color will still be red. (This is where the cascading of Cascading Style Sheets comes from).","pseudo-selectors#Pseudo-selectors":"Selectors can also match states. These selectors are prefixed with a colon. For example, .foo:hover matches elements with class .foo when the mouse hovers over them:","properties#Properties":"As I said, CSS is all about selecting elements and modifying their properties. Properties are all of the form property-name colon property-value (which sometimes includes a unit). For example,\nwidth: 200px\nwidth: is the property\n200px is the value (px is the unit, meaning pixels)\nValues can either be:\nEnums (e.g. text-decoration: underline): which are property specific.\nMeasurements (e.g. width: 200px): that take the form of pixels (px), inches (in), as a percent of the screen‚Äôs height (vh), or something else entirely. Zero is always unitless (because it‚Äôs always the same).\nPaths to other files (e.g. background-image: url(./file.png)): the value is a filepath relative to the CSS file, and while url() may look like a function, it is just telling CSS the type of the value. The path can either be quoted or unquoted (like bash parameters, the quotes are only important if there is a space).\nColors (e.g. color: red): which either take the form of names (e.g. red) or as triplets of red, green, and blue values (RGB). If you're new to digital graphics, an online color picker is a good way to build intuition mapping colors to RGB (rgb(255, 0, 0)) or hex(adecimal) values (#FF0000). (Note: there are other ways to specify colors, but they are less common.)\nWith CSS properties, you can do everything from change the cursor to full 3d transforms. While I can't cover everything CSS can do, some basics you might encounter are:\nText color: color: red;\nText size: font-size: 12px;\nBold text: font-weight: bold;\nBackground color: background-color: red;","layout#Layout":"One particularly important set of properties are those that effect the size and position of your elements.By default, divs are arranged in one column from the top of the page to the bottom and have the height of their contents. This is one of three default layout kinds:\nblock: the element takes up a whole row (e.g. <div>)\ninline: a selection of text, the element takes up no space beyond the inner content (e.g. <span>)\ninline-block: something that has a height and width, but doesn't need a full row to itself (e.g. <img>)\nYou can override the layout kind via the display property. For example, normally divs don‚Äôt show up next to each other, but by changing their display to inline-block we can get the browser to lay them out next to each other.","sizing-the-box-model#Sizing: the box model":"As for how these elements are sized, no CSS tutorial would be complete without a discussion of the box model. The box model is a framework for how much space each element takes.Each element is modeled as four concentric rectangles (or boxes):\nContent: the innermost box that contains the children of the element\nPadding: white space that includes the background\nBorder: a line around the padding\nMargin: space outside the border separating the element from adjacent elements.\nFor each rectangle, you can define all sides at once (padding; 16px), each side individually (padding-left: 16px), or each side individually using a shorthand (padding: 16px 12px 8px 4px defines the top as 16px, right as 12px, bottom as 8px, and left as 4px).The height and width of the content default to whatever height and width the children require to be laid out, but can be explicitly set via the height and width properties (e.g. height: 100px). In addition to specifying a height and width, you can also constrain them using max-height, max-width, min-width, and min-height. For example, an element with the example below will be as wide as possible, but not more than 800px:\n.example {\n  width: 100%;\n  max-width: 800px;\n}\nWhile height was intended to define height of the content, many developers assume it refers to height of the element (including the height of contents, padding, and border). For example, a developer that assigns a box a height of 16px and a padding of 4px, might be confused when the height of the element is 24px instead of 16px (4px top padding + 16px height + 4px bottom padding).This confusion was sufficiently widespread (as was the desire to specify the overall height of the element) that css introduced the box-sizing property to allow developers to toggle whether height refers to the height of the content or the height of the element: box-sizing: border-box redefines height as content height + padding height + border height (the same applies to width).So far, we haven't talked much about margin, a word of caution there: many developers shy away from margin because doesn't always behave intuitively. Specifically: if you have two div's on top of each other with a margin of 10px, the total space between them will only be 10px (as both are at least 10px away from their neighbors). This is called margin collapsing.","flex-and-grid#Flex and Grid":"While blocks and inline-blocks worked well for documents, they reached their limits with applications. For a long time people hacked <tables>'s for layout, then <div>'s became popular, but ultimately application UIs demanded something more. As a result, two layouts were introduced: flexbox and grid, which both let you define elements flexibly and in relation to other elements.\nWhile the full APIs are probably more complicated than we have space to get into, there are wonderful tutorials:\nFlexbox: https://flexboxfroggy.com/\nGrid: https://cssgridgarden.com/","positioning#Positioning":"Lastly, sometimes you want to position an element directly (rather than having the browser lay it out for you). In this case, you can position an element relative to:\nits parent: using position: absolute\nthe browser window: using position: fixed","browser-defaults#Browser defaults":"If you don't define a property, the browser will fall back to its default; different tags have different defaults (for example, on Chrome, the <body> has a default padding of 8px). These defaults are not consistent across browsers. As a result, developers will frequently reset these properties themselves, and it is common to see declarations like the below in boilerplate projects:\nhtml, body {\n  padding: 0;\n  margin: 0;\n}\nTo standardize CSS defaults across browsers, the idea of a \"CSS Reset\" was introduced:a stylesheet that overrides browser defaults. One of the more popular resets is normalize.css.","devtools#Devtools":"You might be wondering, is that all it really is? Is every web page written this way? Yes, and I can prove it. If you're using Chrome, right click on this page and click ‚ÄúInspect‚Äù you‚Äôll open up your browser‚Äôs developer tools panel (a similar concept exists in most browsers, but I'll be focusing on Chrome's).The developer tools panel includes a variety of tools, but if you open ‚ÄúElements‚Äù you‚Äôll see the full HTML of the webpage, starting with the <html> tag (technically this is showing you the DOM, but more on that later). You can select an element to see its CSS and box model.\nYou can read more about the developer tools panel here; the rest of the tools primarily help you debug any JavaScript running alongside the page, and we‚Äôll get to that in the next chapter.","advanced#Advanced":"There is no way to cover all of CSS in one chapter. There are simply too many properties. Even people who have been working with CSS for years still discover new properties (partially because new properties are also introduced regularly).Hopefully, I've given you enough of a foundation to understand any new properties you run into. To that end, there are a few remaining concepts that could benefit from additional explanation. Here is a whirlwind tour.","media-queries#Media queries":"Media queries allow you to apply different CSS properties based on properties of the medium (most commonly, browser width or color scheme). This lets you have different designs for, for example, mobile vs desktop or light mode vs dark mode.","variables#Variables":"CSS has gotten more advanced over the years, and you can now specify properties that compose into other properties.\nYou can also compute things with calc (e.g. width: calc(80% - 10px). calc certainly has its place, but in general, I see first-time CSS developers overuse it. Calc is rarely necessary and leads to hard-to-understand code--that can be less performant--compared to using the browser's native layout technologies (flex or grid).","animations#Animations":"There are two types of animations you can define in CSS. Transitions, which define how to change between different values of a property:\nAnimations, which animate an object:\nAnimations rely on \"keyframes\": a concept borrowed from animation, you specify the properties at specific points, and let the runtime interpolate the middle state (for example, if you know that a box starts at 10px wide and ends at 20px wide, you can infer that half way through that animation, the box should be 15px wide).","pseudo-elements#Pseudo-elements":"Selectors can also create elements. For example, .foo::before will create an element within all elements with class foo but before their children.Yes this is weird; an example of when you might use it is to add a bullet point before items in a bullet point list."}},"/javascript":{"title":"JavaScript: The function of web pages","data":{"":"All UI pretty much boils down to this:\nDraw something on the screen\nListen to and react to user events (clicks, hovers, swipes, etc.) or global events (time changed, window resized, wifi disabled)\nJavaScript was developed in response to that second requirement; it was famously ‚Äúdeveloped in 5 days‚Äù as a way to add limited interactivity to documents: for example, to power dropdown menus.","the-language#The language":"Despite the name, the language shares very little with Java, and is instead based on the ECMAscript standard (an scripting language specification). Because of its rapid adoption and growth from a small scripting language to a full-blown application framework, JavaScript has a fair bit of bloat and plenty of language quirks that should be avoided.\nFor a good highlight-reel of those quirks, check out the WAT of JavaScript.\nHowever, quirks aside, it is an incredibly powerful programming language. In fact, your browser has a full JavaScript REPL embedded in it: open up devtools and click on the ‚ÄúConsole‚Äù tab and type:\nconsole.log(\"Hello, world!\");\nWhen you click enter, the browser will evaluate that line and print ‚ÄúHello, world!‚Äù. To take it a step further, you can copy the following to print your name!\nconst name = \"YOUR NAME\";\nconsole.log(\"Hello, \" + name + \"!\");\nFor a crash course on the syntax of JavaScript, check out Learn X in Y.","the-browser-runtime#The browser runtime":"In the context of web pages, JavaScript is either included as a referenced file (same way CSS is included):\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <title>Demo app</title>\n    <script src=\"script.js\" />\n  </head>\n  <body>\n    <p>Hello, world!</p>\n  </body>\n</html>\nOr directly written inline:\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <title>Demo app</title>\n    <script>\n      console.log(\"Hello, world!\");\n    </script>\n  </head>\n  <body>\n    <p>Hello, world!</p>\n  </body>\n</html>\nBy default, when the browser is parsing the HTML, if it encounters a script tag, it will stop, load, parse, and run the JavaScript before it resumes parsing the HTML. This is very rarely desired‚Äîas you almost always want to display SOMETHING to the user before you start loading a script‚Äîso you‚Äôll either see script tags included at the bottom of the body (after the main content has been parsed and displayed) or with an async attribute (e.g. <script src=\"...\" async />) which does the same thing.","the-dom#The DOM":"JavaScript is loaded along-side the webpage, and the runtime provides hooks into the browser‚Äôs in-memory model of the page: called the ‚Äúdocument object model‚Äù or ‚ÄúDOM‚Äù. The DOM lets JavaScript listen for events and modify the page in response.Much like we did with HTML or CSS, we can experiment using CodeSandbox. For example, I can query for all the paragraph tags using:\nconsole.log(document.querySelectorAll(\"p\"));\nAnd I can modify, or remove, those matching elements:","events#Events":"As I said before, every UI language needs a way to respond to user events. In JavaScript, this takes the form of explicit event listeners that you can attach. For example, I can add an event listener for click events:\nBecause components are nested, events may occur on multiple components:\nYou may have noticed that the parent event happens AFTER the child event. by default, events bubble from child to parent up the document tree.By selecting the element in your browser‚Äôs developer tools, you can see any event handlers attached to it:\nAnd if you go to the source panel, you can even set a breakpoint on it.In these examples, I've mostly focused on the click event, but there are many, many event types available. Some examples include:\nmouse events\ndrag and drop events\nanimation events (animation started, completed)\nwindow events (scroll, resize)\ngyroscope and accelerometer events\nnetwork events (went online / offline)\n...and hundreds more","html5-apis#HTML5 APIs":"With the building blocks of HTML, CSS, and JavaScript, the web changed very quickly: JavaScript didn‚Äôt stay a scripting language intended to open and close dropdowns for long; developers got increasingly ambitious with what web applications could do; and APIs were added to enable increasingly more native experiences; specifically:\nXHR: enabling webpages to programmatically query the network for additional data. (These days, the fetch API is more common.)\nHTML5: an updated specification for HTML, adding APIs targeted at full application development such as offline, history, geolocation, file reading, image rendering, etc.\nFor a full list of JavaScript APIs, check out MDN.","frontend-frameworks#Frontend frameworks":"Alongside the new APIs and browser-based applications (or perhaps powering the browser-based applications) came a suite of libraries built at targeting frontend.","wave-1-utilities#Wave 1: Utilities":"The first wave of popular frontend frameworks came about in the 2000s and provided utilities to decorate static documents rendered on the server with interactivity. They general shape was \"select element\" and \"do something to it\" (at this point, you could not select elements with CSS selectors natively). Alongside that core functionality, they provided shims to simplify various brower tasks, such as requesting data from the network (something that was difficult at the time).\n$( \"#button-container button\" ).on( \"click\", function( event ) {\n  hiddenBox.show();\n});\nExamples include: Mootools, Prototype, and jQuery.","wave-2-data-binding#Wave 2: Data binding":"The second wave came about in the late 2000s / early 2010s and made it easier to bind data to HTML. Unlike the first wave, which treated the HTML as the source of truth for data, this wave assumed that JavaScript was the source of truth for data (treating JavaScript as a first-class citizen, rather than a progressive enhancement); these frameworks made it easy to store state in JavaScript, interpolate that state into their HTML, and modify that state in response to HTML events.\n<html ng-app>\n <!-- Body tag augmented with ngController directive  -->\n <body ng-controller=\"MyController\">\n   <input ng-model=\"foo\" value=\"bar\">\n   <!-- Button tag with ngClick directive, and\n          string expression 'buttonText'\n          wrapped in \"{{ }}\" markup -->\n   <button ng-click=\"changeFoo()\">{{buttonText}}</button>\n   <script src=\"angular.js\"></script>\n </body>\n</html>\nExamples include: Backbone, Angular 1.0, Ember, and Knockout.","wave-3-components#Wave 3: Components":"The third wave further abstracted UI into components: bundles of structure, style, and function creating reusable UI concepts (a menu, table row, or form input).\nfunction Welcome(props) {\n  return <h1>Hello, {props.name}</h1>;\n}\nExamples include: React, Angular 2.0, Svelte, Vue, and Solid.js.A key innovation of React was JSX, a superset of JavaScript that allowed developers to write HTML-like syntax in JavaScript files. This language could be transpiled into JavaScript (with a object-based representation of the inlined HTML). We'll cover this more later.","wave-4-fullstack#Wave 4: Fullstack":"More recently, we've seen a fourth wave begin to emerge. Technologies like Next.js take advantage of the fact that JavaScript now powers both the client and server for many sites. By using Next.js, you can write React code that renders on the server, and keeps the client up-to-date.While this wave is still early, examples include: Next.js, Remix, and Astro.I will call out that these waves are fuzzy, and the idea of writing JavaScript that was shared between client and server started much earlier with Meteor."}},"/html":{"title":"HTML: The structure of web pages","data":{"":"HTML started as a portable markup language to share academic papers with other people on the same network. Browsers were co-developed as a way to (1) fetch those files, and (2) display them.While the web has changed a lot since then, those core technologies haven't.","a-basic-page#A basic page":"The most basic HTML page you could write looks something like this:\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <title>Demo app</title>\n  </head>\n  <body>\n    <p>Hello, world!</p>\n  </body>\n</html>\nIn this example, we're creating a page that has a single paragraph, <p>, with the text \"Hello, world!\".HTML is a subset of XML, that is to say it encodes the document as a tree of tags; tags can be <opening>, </closing>, or <both />. Every opening tag must have a closing tag, and opening and self-closing tag (what we referred to as \"both\") can have attributes that change the behavior of the tag (for example, <img width=\"800\" /> is an image with a width of 800px). You can even define your own attributes if you prefix them with data- (this is used for scripting and is covered later).A tag nested within another tag is referred to as a child, and the outer tag is referred to as the parent:\n<parent>\n  <child />\n</parent>\nBuilding on that, the entire nomenclature for family trees applies (there are grandparents, siblings, descendants, etc...)HTML documents begin with a <!DOCTYPE html> declaration that tells the parser the document is HTML (much like a shebang in a scripting language), and consist of at most two children:\nhead: defining the metadata of the document (such as the tab's title)\nbody: defining the contents of the document (such as the paragraph with the text hello world to show)","tags-tags-tags#Tags, tags, tags":"If you were to only know 2 other tags beyond <html>, <title>, and <body> they would definitely be:\n<div>: an arbitrary block of content\n<span>: a way to select text within a block\nWe'll talk about both of these more in the CSS section.There are other common tags to add functionality to the page: <img> for images, <video> for videos, <textarea> for long-form text-input, but we don't need to understand those yet. There are also other tags that encode the purpose of the element: <main>, <article>, <header> (these act the same as a div, but allow bots and accessibility software to more easily read the webpage). My advice with these semantic elements is to use them where you can, but not to stress about them; there are still many, many websites that get along just fine with divs.","try-it-yourself#Try it yourself":"To play with this further, you can use a service like CodeSandbox, which allows you to define and render an HTML file (and allows you to define CSS and JS files, but more on that later).","the-browser-and-urls#The browser and URLs":"When you navigate to a URL like google.com/foo/bar.html, the browser requests the shared file foo/bar.html from the server at google.com; if you specify a folder path without a file, the browser will automatically request index.html on your behalf (specifically, the requests google.com/foo/ and google.com/foo/index.html are the same).URLs can also contain query parameters, which are used to pass information to the server. For example, google.com/search?q=hello will pass \"hello\" to Google as an argument as it generates the search page.While most of this is probably familiar to anyone who's worked with web services before, one part that's unique to the browser is the hashtag (#): an artifact of the browser's origins as a document viewer. If there is a hashtag, the browser will scroll to the corresponding a element with that ID; for example, navigating to #try-it-yourself will scroll to the element <a id=\"try-it-yourself\">.","embedding-media#Embedding media":"In addition to HTML, browsers can render and embed a variety of media files to make documents more rich. For example, they can handle a variety of images:\nJPEG: Lossy image files\nPNG: Lossless image files\nWEBP: Google-optimized image files\nSVG: Vector files, structured as XML\nThey can also natively embed audio and video through MP4s."}}}